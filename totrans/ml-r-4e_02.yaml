- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Managing and Understanding Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理和理解数据
- en: A key early component of any machine learning project involves managing and
    understanding data. Although this may not be as gratifying as building and deploying
    models—the stages in which you begin to see the fruits of your labor—it is unwise
    to ignore this important preparatory work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 任何机器学习项目的关键早期组成部分都涉及管理和理解数据。尽管这可能不如构建和部署模型——你开始看到劳动成果的阶段——那么令人满意，但忽视这项重要的准备工作是不明智的。
- en: Any learning algorithm is only as good as its training data, and in many cases,
    this data is complex, messy, and spread across multiple sources and formats. Due
    to this complexity, often the largest portion of effort invested in machine learning
    projects is spent on data preparation and exploration.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 任何学习算法都只有与其训练数据一样好，在很多情况下，这些数据是复杂的、混乱的，并且分布在多个来源和格式中。由于这种复杂性，机器学习项目中投入的大部分努力通常都花费在数据准备和探索上。
- en: This chapter approaches data preparation in three ways. The first section discusses
    the basic data structures R uses to store data. You will become very familiar
    with these structures as you create and manipulate datasets. The second section
    is practical, as it covers several functions that are used for getting data in
    and out of R. In the third section, methods for understanding data are illustrated
    while exploring a real-world dataset.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从三个方面探讨数据准备。第一部分讨论了R用于存储数据的基本数据结构。随着你创建和操作数据集，你将非常熟悉这些结构。第二部分是实用的，因为它涵盖了用于将数据输入和输出R的几个函数。在第三部分，通过探索一个真实世界的数据集，展示了理解数据的方法。
- en: 'By the end of this chapter, you will understand:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解：
- en: How to use R’s basic data structures to store and manipulate values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用R的基本数据结构来存储和操作值
- en: Simple functions to get data into R from common source formats
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据从常见源格式导入R的简单函数
- en: Typical methods to understand and visualize complex data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和可视化复杂数据的典型方法
- en: The ways R handles data will dictate the ways you must work with data, so it
    is helpful to understand R’s data structures before jumping directly into data
    preparation. However, if you are already familiar with R programming, feel free
    to skip ahead to the section on data preprocessing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: R处理数据的方式将决定你必须如何处理数据，因此在直接进行数据准备之前了解R的数据结构是有帮助的。然而，如果你已经熟悉R编程，可以自由地跳到数据预处理的部分。
- en: All code files for this book can be found at [https://github.com/PacktPublishing/Machine-Learning-with-R-Fourth-Edition](https://github.com/PacktPublishing/Machine-Learning-with-R-Fourth-Edition)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所有代码文件均可在[https://github.com/PacktPublishing/Machine-Learning-with-R-Fourth-Edition](https://github.com/PacktPublishing/Machine-Learning-with-R-Fourth-Edition)找到
- en: R data structures
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R数据结构
- en: There are numerous types of data structures found in programming languages,
    each with strengths and weaknesses suited to specific tasks. Since R is a programming
    language used widely for statistical data analysis, the data structures it utilizes
    were designed with this type of work in mind.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言中存在多种类型的数据结构，每种都有适合特定任务的优点和缺点。由于R是一种广泛用于统计数据分析的编程语言，因此它所利用的数据结构是针对这种类型的工作设计的。
- en: The R data structures used most frequently in machine learning are vectors,
    factors, lists, arrays, matrices, and data frames. Each is tailored to a specific
    data management task, which makes it important to understand how they will interact
    in your R project. In the sections that follow, we will review their similarities
    and differences.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，最频繁使用的R数据结构是向量、因子、列表、数组、矩阵和数据框。每个都是针对特定的数据管理任务定制的，这使得了解它们在你的R项目中如何交互变得很重要。在接下来的部分中，我们将回顾它们的相似之处和不同之处。
- en: Vectors
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量
- en: The fundamental R data structure is a **vector**, which stores an ordered set
    of values called **elements**. A vector can contain any number of elements. However,
    all of a vector’s elements must be of the same type; for instance, a vector cannot
    contain both numbers and text. To determine the type of vector `v`, use the `typeof(v)`
    command. Note that R is a **case-sensitive** language, which means that lower-case
    `v` and upper-case `V` could represent two different vectors. This is also true
    for R’s built-in functions and keywords, so be sure to always use the correct
    capitalization when typing R commands or expressions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: R 的基本数据结构是 **向量**，它存储了一组有序的值，称为 **元素**。向量可以包含任意数量的元素。然而，向量的所有元素必须属于同一类型；例如，向量不能同时包含数字和文本。要确定向量
    `v` 的类型，请使用 `typeof(v)` 命令。请注意，R 是一个 **区分大小写** 的语言，这意味着小写的 `v` 和大写的 `V` 可能代表两个不同的向量。这同样适用于
    R 的内置函数和关键字，因此在输入 R 命令或表达式时，务必确保使用正确的首字母大小写。
- en: 'Several vector types are commonly used in machine learning: `integer` (numbers
    without decimals), `double` (numbers with decimals), `character` (text data, also
    commonly called “string” data), and `logical` (`TRUE` or `FALSE` values). Some
    R functions will report both `integer` and `double` vectors as `numeric`, while
    others distinguish between the two; generally, this distinction is unimportant.
    Vectors of logical values are used often in R, but notice that the `TRUE` and
    `FALSE` values must be written in all caps. This is slightly different from some
    other programming languages.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，常用的几种向量类型包括：`integer`（没有小数的数字）、`double`（有小数的数字）、`character`（文本数据，也常称为“字符串”数据）和
    `logical`（`TRUE` 或 `FALSE` 值）。某些 R 函数将 `integer` 和 `double` 向量都报告为 `numeric`，而其他函数则区分两者；通常，这种区别并不重要。在
    R 中，逻辑值向量被广泛使用，但请注意，`TRUE` 和 `FALSE` 值必须全部大写。这与一些其他编程语言略有不同。
- en: 'There are also two special values that are relevant to all vector types: `NA`,
    which indicates a *missing* value, and `NULL`, which is used to indicate the absence
    of *any* value. Although these two may seem to be synonymous, they are indeed
    slightly different. The `NA` value is a placeholder for something else and therefore
    has a length of one, while the `NULL` value is truly empty and has a length of
    zero.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有向量类型，也存在两个相关的特殊值：`NA`，表示一个 *缺失* 的值，以及 `NULL`，用于表示 *任何* 值的缺失。尽管这两个值看起来似乎是同义的，但它们实际上是略有不同的。`NA`
    值是其他某物的占位符，因此其长度为 1，而 `NULL` 值确实是空的，其长度为 0。
- en: It is tedious to enter large amounts of data by hand, but simple vectors can
    be created by using the `c()` combine function. The vector can also be given a
    name using the arrow `<-` operator. This is R’s assignment operator, used much
    like the `=` assignment operator used in many other programming languages.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 手动输入大量数据是件麻烦事，但可以通过使用 `c()` 组合函数创建简单的向量。向量也可以使用箭头 `<-` 操作符来命名。这是 R 的赋值操作符，其用法与许多其他编程语言中的
    `=` 赋值操作符类似。
- en: R also allows the use of the `=` operator for assignment, but it is considered
    a poor coding style according to commonly accepted style guidelines.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: R 也允许使用 `=` 操作符进行赋值，但根据普遍接受的编码风格指南，这被认为是一种较差的编码风格。
- en: 'For example, let’s construct a set of vectors containing data on three medical
    patients. We’ll create a character vector named `subject_name` to store the three
    patient names, a numeric vector named `temperature` to store each patient’s body
    temperature in degrees Fahrenheit, and a logical vector named `flu_status` to
    store each patient’s diagnosis (`TRUE` if they have influenza, `FALSE` otherwise).
    As shown in the following code, the three vectors are:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们构建一个包含三个医疗患者数据的向量集。我们将创建一个名为 `subject_name` 的字符向量来存储三个患者的姓名，一个名为 `temperature`
    的数值向量来存储每个患者的体温（华氏度），以及一个名为 `flu_status` 的逻辑向量来存储每个患者的诊断（如果他们患有流感则为 `TRUE`，否则为
    `FALSE`）。如下面的代码所示，这三个向量是：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Values stored in R vectors retain their order. Therefore, data for each patient
    can be accessed using their position in the set, beginning at `1`, then supplying
    this number inside square brackets (that is, `[` and `]`) following the name of
    the vector. For instance, to obtain the temperature value for patient Jane Doe,
    the second patient, simply type:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 R 向量中的值保留其顺序。因此，可以通过在集合中的位置来访问每个患者的数据，从 `1` 开始，然后在向量名称后面提供这个数字（即 `[` 和 `]`
    方括号内）。例如，要获取 Jane Doe 患者的体温值，即第二个患者，只需简单地输入：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'R offers a variety of methods to extract data from vectors. A range of values
    can be obtained using the colon operator. For instance, to obtain the body temperature
    of the second and third patients, type:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: R提供了各种方法从向量中提取数据。可以使用冒号运算符获取一系列值。例如，要获取第二位和第三位患者的体温，请输入以下内容：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Items can be excluded by specifying a negative item number. To exclude the
    second patient’s temperature data, type:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过指定负项目编号来排除项目。要排除第二位患者的体温数据，请输入以下内容：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It is also sometimes useful to specify a logical vector indicating whether
    each item should be included. For example, to include the first two temperature
    readings but exclude the third, type:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时指定一个表示每个项目是否应包含的逻辑向量也是有用的。例如，要包含前两个体温读数但排除第三个，请输入以下内容：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The importance of this type of operation is clearer with the realization that
    the result of a logical expression like `temperature > 100` is a logical vector.
    This expression returns `TRUE` or `FALSE` depending on whether the temperature
    is greater than 100 degrees Fahrenheit, which indicates a fever. Therefore, the
    following commands will identify the patients exhibiting a fever:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过意识到像`temperature > 100`这样的逻辑表达式的结果是逻辑向量，这种操作的的重要性变得更加清晰。这个表达式根据温度是否超过100华氏度返回`TRUE`或`FALSE`，这表明发烧。因此，以下命令将识别出发烧的患者：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, the logical expression can also be moved inside the brackets,
    which returns the same result in a single step:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑表达式也可以移入括号内，这可以在一步中返回相同的结果：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you will see shortly, the vector provides the foundation for many other R
    data structures and can be combined with programming expressions to complete more
    complex operations for selecting data and constructing new features. Therefore,
    knowing the various vector operations is crucial for working with data in R.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如您将很快看到的，向量是许多其他R数据结构的基础，并且可以与编程表达式结合使用，以完成更复杂的数据选择和构建新特征的操作。因此，了解各种向量操作对于在R中处理数据至关重要。
- en: Factors
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 因子
- en: Recall from *Chapter 1*, *Introducing Machine Learning*, that nominal features
    represent a characteristic with categories of values. Although it is possible
    to use a character vector to store nominal data, R provides a data structure specifically
    for this task.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下*第一章*，*介绍机器学习*，名义特征表示具有值类别的特征。虽然可以使用字符向量来存储名义数据，但R提供了一种专门为此任务的数据结构。
- en: 'A **factor** is a special type of vector that is solely used for representing
    categorical or ordinal data. In the medical dataset we are building, we might
    use a factor to represent the patients’ biological sex and record two categories:
    male and female.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**因子**是一种特殊类型的向量，仅用于表示分类或有序数据。在我们构建的医疗数据集中，我们可能会使用因子来表示患者的生物性别，并记录两个类别：男性和女性。'
- en: Why use factors rather than character vectors? One advantage of factors is that
    the category labels are stored only once. Rather than storing `MALE`, `MALE`,
    `FEMALE`, the computer may store `1`, `1`, `2`, which can reduce the memory needed
    to store the values. Additionally, many machine learning algorithms handle nominal
    and numeric features differently. Coding categorical features as factors allows
    R to treat the categorical features appropriately.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用因子而不是字符向量？因子的一项优点是类别标签只存储一次。而不是存储`MALE`，`MALE`，`FEMALE`，计算机可能存储`1`，`1`，`2`，这可以减少存储值所需的内存。此外，许多机器学习算法以不同的方式处理名义和数值特征。将分类特征编码为因子允许R适当地处理分类特征。
- en: A factor should not be used for character vectors with values that don’t truly
    fall into categories. If a vector stores mostly unique values such as names or
    identification codes like social security numbers, keep it as a character vector.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因子不应用于存储值不真正属于类别的字符向量。如果一个向量存储了大部分唯一的值，如姓名或识别码，如社会保障号码，请将其保留为字符向量。
- en: 'To create a factor from a character vector, simply apply the `factor()` function.
    For example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字符向量创建因子，只需应用`factor()`函数。例如：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that when the `gender` factor was displayed, R printed additional information
    about its levels. The levels comprise the set of possible categories the factor
    could take, in this case, `MALE` or `FEMALE`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当`gender`因子被显示时，R打印了有关其级别的额外信息。级别包含因子可能采取的可能类别集合，在这种情况下，`MALE`或`FEMALE`。
- en: 'When we create factors, we can add additional levels that may not appear in
    the original data. Suppose we created another factor for blood type, as shown
    in the following example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建因素时，我们可以添加可能不在原始数据中出现的附加水平。例如，我们可以创建另一个血型因素，如下面的示例所示：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When we defined the `blood` factor, we specified an additional vector of four
    possible blood types using the `levels` parameter. As a result, even though our
    data includes only blood types O, AB, and A, all four types are retained with
    the `blood` factor, as the output shows. Storing the additional level allows for
    the possibility of adding patients with the other blood type in the future. It
    also ensures that if we were to create a table of blood types, we would know that
    type B exists, despite it not being found in our initial data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义`blood`因素时，我们使用`levels`参数指定了一个包含四种可能血型的附加向量。因此，尽管我们的数据中只包括O型、AB型和A型血型，但所有四种血型都通过`blood`因素保留，正如输出所示。存储附加水平允许将来添加具有其他血型的患者。这也确保了，如果我们创建一个血型表，我们会知道存在B型血，尽管它在我们的初始数据中未被发现。
- en: 'The factor data structure also allows us to include information about the order
    of a nominal feature’s categories, which provides a method for creating ordinal
    features. For example, suppose we have data on the severity of patient symptoms,
    coded in increasing order of severity from mild, to moderate, to severe. We indicate
    the presence of ordinal data by providing the factor’s levels in the desired order,
    listed ascending from lowest to highest, and setting the `ordered` parameter to
    `TRUE` as shown:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因素数据结构还允许我们包含有关名义特征类别顺序的信息，这为创建序数特征提供了一种方法。例如，假设我们有关于患者症状严重程度的数据，按严重程度递增的顺序编码，从轻微到中度，再到严重。我们通过提供因素的水平以所需的顺序，从最低到最高列出，并将`ordered`参数设置为`TRUE`来表示序数数据的存在，如下所示：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The resulting `symptoms` factor now includes information about the requested
    order. Unlike our prior factors, the levels of this factor are separated by `<`
    symbols to indicate the presence of a sequential order from `MILD` to `SEVERE`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的`症状`因素现在包括有关请求顺序的信息。与我们的先前因素不同，此因素的水平由`<`符号分隔，以表示从`MILD`到`SEVERE`的顺序存在：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A helpful feature of ordered factors is that logical tests work as you would
    expect. For instance, we can test whether each patient’s symptoms are more severe
    than moderate:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有序因素的便利之处在于逻辑测试按预期工作。例如，我们可以测试每位患者的症状是否比中度更严重：
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Machine learning algorithms capable of modeling ordinal data will expect ordered
    factors, so be sure to code your data accordingly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 能够对序数数据进行建模的机器学习算法将期望有序因素，因此请确保按照相应的方式对您的数据进行编码。
- en: Lists
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: A **list** is a data structure, much like a vector, in that it is used for storing
    an ordered set of elements. However, where a vector requires all its elements
    to be the same type, a list allows different R data types to be collected. Due
    to this flexibility, lists are often used to store various types of input and
    output data and sets of configuration parameters for machine learning models.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表**是一种数据结构，类似于向量，因为它用于存储有序元素集。然而，与向量要求所有元素必须是相同类型不同，列表允许收集不同的R数据类型。由于这种灵活性，列表常用于存储各种类型的输入和输出数据以及机器学习模型的配置参数集。'
- en: 'To illustrate lists, consider the medical patient dataset we have been constructing,
    with data for three patients stored in six vectors. If we wanted to display all
    the data for the first patient, we would need to enter five R commands:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明列表，考虑我们一直在构建的医疗患者数据集，其中三个患者的数据存储在六个向量中。如果我们想显示第一位患者的所有数据，我们需要输入五个R命令：
- en: '[PRE22]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we expect to examine the patient’s data again in the future, rather than
    retyping these commands, a list allows us to group all the values into one object
    we can use repeatedly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们预计将来再次检查患者的数据，而不是重新输入这些命令，列表允许我们将所有值组合成一个可以重复使用的对象。
- en: 'Similar to creating a vector with `c()`, a list is created using the `list()`
    function, as shown in the following example. One notable difference is that when
    a list is constructed, each component in the sequence should be given a name.
    The names are not strictly required, but allow the values to be accessed later
    by name rather than by numbered position and a mess of square brackets. To create
    a list with named components for the first patient’s values, type the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 `c()` 创建向量类似，列表是通过 `list()` 函数创建的，如下面的示例所示。一个值得注意的区别是，当构建列表时，序列中的每个组件都应该有一个名称。名称不是必需的，但允许以后通过名称而不是通过编号位置和一串方括号来访问值。要为第一个患者的值创建具有命名组件的列表，请输入以下内容：
- en: '[PRE34]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This patient’s data is now collected in the `subject1` list:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这位患者的数据现在收集在 `subject1` 列表中：
- en: '[PRE35]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note that the values are labeled with the names we specified in the preceding
    command. As a list retains order like a vector, its components can be accessed
    using numeric positions, as shown here for the `temperature` value:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，值被标记为我们之前命令中指定的名称。由于列表像向量一样保留顺序，其组件可以通过数字位置访问，如下面所示的 `temperature` 值：
- en: '[PRE37]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The result of using vector-style operators on a list object is another list
    object, which is a subset of the original list. For example, the preceding code
    returned a list with a single `temperature` component. To instead return a single
    list item in its *native* data type, use double brackets (`[[` and `]]`) when
    selecting the list component. For example, the following command returns a numeric
    vector of length 1:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表对象上使用向量风格运算符的结果是另一个列表对象，它是原始列表的子集。例如，前面的代码返回了一个只有一个 `temperature` 组件的列表。要返回单个列表项的
    *原生* 数据类型，请在选择列表组件时使用双括号 (`[[` 和 `]]`)。例如，以下命令返回了一个长度为 1 的数值向量：
- en: '[PRE39]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For clarity, it is often better to access list components by name, by appending
    a `$` and the component name to the list name as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，通常最好通过名称访问列表组件，方法是将 `$` 和组件名称附加到列表名称上，如下所示：
- en: '[PRE41]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Like the double-bracket notation, this returns the list component in its native
    data type (in this case, a numeric vector of length 1).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与双括号表示法类似，这返回了列表组件的 *原生* 数据类型（在这种情况下，长度为 1 的数值向量）。
- en: Accessing the value by name also ensures that the correct item is retrieved
    even if the order of the list elements is changed later.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过名称访问值也确保了即使列表元素的顺序后来发生变化，也能检索到正确的项目。
- en: 'It is possible to obtain several list items by specifying a vector of names.
    The following returns a subset of the `subject1` list, which contains only the
    `temperature` and `flu_status` components:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定名称向量，可以获取多个列表项。以下返回 `subject1` 列表的子集，仅包含 `temperature` 和 `flu_status` 组件：
- en: '[PRE43]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Entire datasets could be constructed using lists, and lists of lists. For example,
    you might consider creating a `subject2` and `subject3` list and grouping these
    into a list object named `pt_data`. However, constructing a dataset in this way
    is common enough that R provides a specialized data structure specifically for
    this task.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 整个数据集可以使用列表和列表的列表来构建。例如，你可能考虑创建一个名为 `subject2` 和 `subject3` 的列表，并将这些列表组合成一个名为
    `pt_data` 的列表对象。然而，以这种方式构建数据集是如此常见，以至于 R 提供了一种专门的数据结构来专门处理这项任务。
- en: Data frames
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据框
- en: By far the most important R data structure for machine learning is the **data
    frame**, a structure analogous to a spreadsheet or database in that it has both
    rows and columns of data. In R terms, a data frame can be understood as a list
    of vectors or factors, each having exactly the same number of values. Because
    the data frame is literally a list of vector-type objects, it combines aspects
    of both vectors and lists.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，对于机器学习来说，最重要的 R 数据结构是 **数据框**，它类似于电子表格或数据库的结构，因为它既有行又有列的数据。在 R 的术语中，数据框可以理解为向量的列表或因子，每个都具有相同数量的值。因为数据框实际上是向量类型对象的列表，它结合了向量和列表的方面。
- en: 'Let’s create a data frame for our patient dataset. Using the patient data vectors
    we created previously, the `data.frame()` function combines them into a data frame:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的患者数据集创建一个数据框。使用我们之前创建的患者数据向量，`data.frame()` 函数将它们组合成一个数据框：
- en: '[PRE45]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When displaying the `pt_data` data frame, we see that the structure is quite
    different from the data structures we’ve worked with previously:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示 `pt_data` 数据框时，我们看到其结构与之前我们处理过的数据结构相当不同：
- en: '[PRE46]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Compared to one-dimensional vectors, factors, and lists, a data frame has two
    dimensions and is displayed in a tabular format. Our data frame has one row for
    each patient and one column for each vector of patient measurements. In machine
    learning terms, the data frame’s rows are the examples, and the columns are the
    features or attributes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与一维向量、因子和列表相比，数据框有两个维度，并以表格格式显示。我们的数据框为每位患者有一行，为每位患者的测量值向量有一列。在机器学习的术语中，数据框的行是示例，列是特征或属性。
- en: 'To extract entire columns (vectors) of data, we can take advantage of the fact
    that a data frame is simply a list of vectors. Like lists, the most direct way
    to extract a single element is by referring to it by name. For example, to obtain
    the `subject_name` vector, type:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取整个数据列（向量），我们可以利用数据框实际上是一个向量列表的事实。像列表一样，提取单个元素的最直接方法是通过其名称引用。例如，要获取`subject_name`向量，输入以下内容：
- en: '[PRE48]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Like lists, a vector of names can be used to extract multiple columns from
    a data frame:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 像列表一样，名称向量可以用来从数据框中提取多个列：
- en: '[PRE50]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When we request data frame columns by name, the result is a data frame containing
    all rows of data for the specified columns. The command `pt_data[2:3]` will also
    extract the `temperature` and `flu_status` columns. However, referring to the
    columns by name results in clear and easy-to-maintain R code, which will not break
    if the data frame is later reordered.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按名称请求数据框列时，结果是包含指定列的所有行的数据框。命令`pt_data[2:3]`也将提取`temperature`和`flu_status`列。然而，通过名称引用的列会产生清晰且易于维护的R代码，如果数据框稍后重新排序，代码也不会出错。
- en: 'To extract specific values from the data frame, methods like those for accessing
    values in vectors are used. However, there is an important distinction—because
    the data frame is two-dimensional, both the desired rows and columns must be specified.
    Rows are specified first, followed by a comma, followed by the columns in a format
    like this: `[rows, columns]`. As with vectors, rows and columns are counted beginning
    at one.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数据框中提取特定值，可以使用与访问向量值相同的方法。然而，有一个重要的区别——因为数据框是二维的，必须指定所需的行和列。首先指定行，然后是逗号，然后是类似这样的列格式：`[行,
    列]`。与向量一样，行和列都是从一开始计数的。
- en: 'For instance, to extract the value in the first row and second column of the
    patient data frame, use the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要提取患者数据框的第一行和第二列的值，使用以下命令：
- en: '[PRE52]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you would like more than a single row or column of data, specify vectors
    indicating the desired rows and columns. The following statement will pull data
    from the first and third rows and the second and fourth columns:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要多于一行或一列的数据，请指定表示所需行和列的向量。以下语句将从第一行和第三行以及第二行和第四列中提取数据：
- en: '[PRE54]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To refer to every row or every column, simply leave the row or column portion
    blank. For example, to extract all rows of the first column:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用每一行或每一列，只需将行或列部分留空。例如，要提取第一列的所有行：
- en: '[PRE56]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To extract all columns for the first row:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取第一行的所有列：
- en: '[PRE58]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And to extract everything:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取所有内容：
- en: '[PRE60]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Of course, columns are better accessed by name rather than position, and negative
    signs can be used to exclude rows or columns of data. Therefore, the output of
    the command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，通过名称访问列比通过位置访问列更好，并且可以使用负号排除数据行或列。因此，命令的输出：
- en: '[PRE62]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'is equivalent to:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于：
- en: '[PRE64]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We often need to create new columns in data frames—perhaps, for instance, as
    a function of existing columns. For example, we may need to convert the Fahrenheit
    temperature readings in the patient data frame into the Celsius scale. To do this,
    we simply use the assignment operator to assign the result of the conversion calculation
    to a new column name as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要在数据框中创建新的列——例如，可能作为现有列的函数。例如，我们可能需要将患者数据框中的华氏温度读数转换为摄氏度。为此，我们只需使用赋值运算符将转换计算的结果分配给新的列名，如下所示：
- en: '[PRE66]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To confirm the calculation worked, let’s compare the new Celsius-based `temp_c`
    column to the previous Fahrenheit-scale `temperature` column:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认计算是否成功，让我们将基于摄氏度的`temp_c`新列与之前的华氏温度`temperature`列进行比较：
- en: '[PRE67]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Seeing these side by side, we can confirm that the calculation has worked correctly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些并排放置，我们可以确认计算已经正确完成。
- en: As these types of operations are crucial for much of the work we will do in
    upcoming chapters, it is important to become very familiar with data frames. You
    might try practicing similar operations with the patient dataset, or even better,
    use data from one of your own projects—the functions to load your own data files
    into R will be described later in this chapter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些类型的操作对于我们在接下来的章节中将要做的许多工作至关重要，因此熟悉数据框非常重要。你可以尝试使用患者数据集练习类似的操作，或者更好的是，使用你自己的项目中的数据——在本章后面将描述将你的数据文件加载到R中的函数。
- en: Matrices and arrays
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵和数组
- en: In addition to data frames, R provides other structures that store values in
    tabular form. A **matrix** is a data structure that represents a two-dimensional
    table with rows and columns of data. Like vectors, R matrices can contain only
    one type of data, although they are most often used for mathematical operations
    and therefore typically store only numbers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据框之外，R还提供了其他以表格形式存储值的结构。**矩阵**是一种表示二维数据表的二维数据结构。与向量一样，R矩阵只能包含一种类型的数据，尽管它们通常用于数学运算，因此通常只存储数字。
- en: 'To create a matrix, simply supply a vector of data to the `matrix()` function,
    along with a parameter specifying the number of rows (`nrow`) or number of columns
    (`ncol`). For example, to create a 2x2 matrix storing the numbers one to four,
    we can use the `nrow` parameter to request the data be divided into two rows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个矩阵，只需向`matrix()`函数提供一个数据向量，以及一个指定行数（`nrow`）或列数（`ncol`）的参数。例如，要创建一个2x2矩阵存储数字一到四，我们可以使用`nrow`参数请求数据被分成两行：
- en: '[PRE69]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This is equivalent to the matrix produced using `ncol = 2`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这与使用`ncol = 2`产生的矩阵等效：
- en: '[PRE71]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You will notice that R loaded the first column of the matrix first before loading
    the second column. This is called **column-major order**, which is R’s default
    method for loading matrices.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到R首先加载矩阵的第一列，然后加载第二列。这被称为**列主序**，它是R加载矩阵的默认方法。
- en: To override this default setting and load a matrix by rows, set the parameter
    `byrow = TRUE` when creating the matrix.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖此默认设置并按行加载矩阵，在创建矩阵时设置参数`byrow = TRUE`。
- en: 'To illustrate this further, let’s see what happens if we add more values to
    the matrix. With six values, requesting two rows creates a matrix with three columns:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明这一点，让我们看看如果我们向矩阵中添加更多值会发生什么。有六个值时，请求两行会创建一个三列的矩阵：
- en: '[PRE73]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Requesting two columns creates a matrix with three rows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请求两列会创建一个三行的矩阵：
- en: '[PRE75]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As with data frames, values in matrices can be extracted using `[row, column]`
    notation. For instance, `m[1, 1]` will return the value `1` while `m[3, 2]` will
    extract `6` from the `m` matrix. Additionally, entire rows or columns can be requested:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据框一样，矩阵中的值可以使用`[行, 列]`表示法提取。例如，`m[1, 1]`将返回值`1`，而`m[3, 2]`将从`m`矩阵中提取`6`。此外，还可以请求整个行或列：
- en: '[PRE77]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Closely related to the matrix structure is the **array**, which is a multidimensional
    table of data. Where a matrix has rows and columns of values, an array has rows,
    columns, and one or more additional layers of values. Although we will occasionally
    use matrices in later chapters, the use of arrays is unnecessary within the scope
    of this book.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与矩阵结构密切相关的是**数组**，它是一个多维数据表。矩阵有行和列的值，而数组有行、列和一或多个额外的值层。尽管我们将在后面的章节中偶尔使用矩阵，但在这个书的范围内使用数组是不必要的。
- en: Managing data with R
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用R管理数据
- en: One of the challenges faced while working with massive datasets involves gathering,
    preparing, and otherwise managing data from a variety of sources. Although we
    will cover data preparation, data cleaning, and data management in depth by working
    on real-world machine learning tasks in later chapters, this section highlights
    the basic functionality for getting data in and out of R.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大规模数据集时面临的挑战之一涉及从各种来源收集、准备和管理工作数据。尽管我们将在后面的章节中通过实际机器学习任务深入探讨数据准备、数据清洗和数据管理，但本节突出了将数据输入和输出R的基本功能。
- en: Saving, loading, and removing R data structures
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存、加载和删除R数据结构
- en: When you’ve spent a lot of time getting a data frame into the desired form,
    you shouldn’t need to recreate your work each time you restart your R session.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当你花费了大量时间将数据框调整到所需的形式后，每次重启R会话时，你不需要重新创建你的工作。
- en: To save data structures to a file that can be reloaded later or transferred
    to another system, the `save()` function can be used to write one or more R data
    structures to the location specified by the `file` parameter. R data files have
    an `.RData` or `.rda` extension.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据结构保存到可以稍后重新加载或传输到另一个系统的文件中，可以使用`save()`函数将一个或多个R数据结构写入由`file`参数指定的位置。R数据文件具有`.RData`或`.rda`扩展名。
- en: 'Suppose you had three objects named `x`, `y`, and `z` that you would like to
    save to a permanent file. These might be vectors, factors, lists, data frames,
    or any other R object. To save them to a file named `mydata.RData`, use the following
    command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有三个名为`x`、`y`和`z`的对象，您希望将它们保存到永久文件中。这些可能是向量、因子、列表、数据框或任何其他R对象。要将它们保存到名为`mydata.RData`的文件中，请使用以下命令：
- en: '[PRE81]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `load()` command can recreate any data structures that have been saved
    to an `.RData` file. To load the `mydata.RData` file created in the preceding
    code, simply type:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()`命令可以重新创建已保存到`.RData`文件中的任何数据结构。要加载前面代码中创建的`mydata.RData`文件，只需键入以下内容：'
- en: '[PRE82]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This will recreate the `x`, `y`, and `z` data structures in your R environment.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的R环境中重新创建`x`、`y`和`z`数据结构。
- en: Be careful what you are loading! All data structures stored in the file you
    are importing with the `load()` command will be added to your workspace, even
    if they overwrite something else you are working on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载时要小心！使用`load()`命令导入的文件中存储的所有数据结构都将添加到您的工作空间中，即使它们覆盖了您正在工作的其他内容。
- en: Alternatively, the `saveRDS()` function can be used to save a single R object
    to a file. Although it is much like the `save()` function, a key distinction is
    that the corresponding `loadRDS()` function allows the object to be loaded with
    a different name to the original object. For this reason, `saveRDS()` may be safer
    to use when transferring R objects across projects, because it reduces the risk
    of accidentally overwriting existing objects in the R environment.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用`saveRDS()`函数将单个R对象保存到文件中。尽管它与`save()`函数非常相似，但一个关键的区别是相应的`loadRDS()`函数允许以与原始对象不同的名称加载对象。因此，在跨项目传输R对象时，`saveRDS()`可能更安全使用，因为它减少了意外覆盖R环境中现有对象的风险。
- en: 'The `saveRDS()` function is especially helpful for saving machine learning
    model objects. Because some machine learning algorithms take a long time to train
    the model, saving the model to an `.rds` file can help avoid a long re-training
    process when a project is resumed. For example, to save a model object named `my_model`
    to a file named `my_model.rds`, use the following syntax:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveRDS()`函数对于保存机器学习模型对象特别有帮助。因为一些机器学习算法需要很长时间来训练模型，将模型保存到`.rds`文件中可以帮助避免在项目恢复时进行长时间的重训练过程。例如，要将名为`my_model`的模型对象保存到名为`my_model.rds`的文件中，请使用以下语法：'
- en: '[PRE83]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To load the model, use the `readRDS()` function and assign the result an object
    name as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载模型，请使用`readRDS()`函数，并将结果分配给一个对象名，如下所示：
- en: '[PRE84]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: After you’ve been working in an R session for some time, you may have accumulated
    unused data structures. In RStudio, these objects are visible in the **Environment**
    tab of the interface, but it is also possible to access these objects programmatically
    using the listing function `ls()`, which returns a vector of all data structures
    currently in memory.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在您使用R会话工作一段时间后，您可能已经积累了未使用的数据结构。在RStudio中，这些对象在界面的**环境**选项卡中可见，但也可以使用列表函数`ls()`以编程方式访问这些对象，该函数返回当前内存中所有数据结构的向量。
- en: 'For example, if you’ve been following along with the code in this chapter,
    the `ls()` function returns the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您一直跟随本章中的代码，`ls()`函数将返回以下内容：
- en: '[PRE85]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'R automatically clears all data structures from memory upon quitting the session,
    but for large objects, you may want to free up the memory sooner. The remove function
    `rm()` can be used for this purpose. For example, to eliminate the `m` and `subject1`
    objects, simply type:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: R在退出会话时会自动从内存中清除所有数据结构，但对于大型对象，您可能希望更早地释放内存。移除函数`rm()`可用于此目的。例如，要消除`m`和`subject1`对象，只需键入以下内容：
- en: '[PRE87]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `rm()` function can also be supplied with a character vector of object
    names to remove. This works with the `ls()` function to clear the entire R session:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`rm()`函数也可以接受一个字符向量作为对象名来删除。这与`ls()`函数一起使用，可以清除整个R会话：'
- en: '[PRE88]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Be very careful when executing the preceding code, as you will not be prompted
    before your objects are removed!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行前面的代码时要非常小心，因为您的对象被删除之前不会收到提示！
- en: If you need to wrap up your R session in a hurry, the `save.image()` command
    will write your entire session to a file simply called `.RData`. By default, when
    quitting R or RStudio, you will be asked if you would like to create this file.
    R will look for this file the next time you start R, and if it exists, your session
    will be recreated just as you had left it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Importing and saving datasets from CSV files
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is common for public datasets to be stored in text files. Text files can
    be read on virtually any computer or operating system, which makes the format
    nearly universal. They can also be exported and imported from and to programs
    such as Microsoft Excel, providing a quick and easy way to work with spreadsheet
    data.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: A **tabular** (as in “table”) data file is structured in matrix form, such that
    each line of text reflects one example, and each example has the same number of
    features. The feature values on each line are separated by a predefined symbol
    known as a **delimiter**. Often, the first line of a tabular data file lists the
    names of the data columns. This is called a **header** line.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most common tabular text file format is the **comma-separated values**
    (**CSV**) file, which, as the name suggests, uses the comma as a delimiter. CSV
    files can be imported to and exported from many common applications. A CSV file
    representing the medical dataset constructed previously could be stored as:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Given a patient data file named `pt_data.csv` located in the R working directory,
    the `read.csv()` function can be used as follows to load the file into R:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This will read the CSV file into a data frame titled `pt_data`. If your dataset
    resides outside the R working directory, the full path to the CSV file (for example,
    `"/path/to/mydata.csv"`) can be used when calling the `read.csv()` function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, R assumes that the CSV file includes a header line listing the
    names of the features in the dataset. If a CSV file does not have a header, specify
    the option `header = FALSE` as shown in the following command, and R will assign
    generic feature names by numbering the columns sequentially as `V1`, `V2`, and
    so on:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'As an important historical note, in versions of R prior to 4.0, the `read.csv()`
    function automatically converted all character type columns into factors due to
    a `stringsAsFactors` parameter that was set to `TRUE` by default. This feature
    was occasionally helpful, especially on the smaller and simpler datasets used
    in the earlier years of R. However, as datasets have become larger and more complex,
    this feature began to cause more problems than it solved. Now, starting with version
    4.0, R sets `stringsAsFactors = FALSE` by default. If you are certain that every
    character column in a CSV file is truly a factor, it is possible to convert them
    using the following syntax:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We will set `stringsAsFactors = TRUE` occasionally throughout the book, when
    working with datasets in which all character columns are truly factors.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting results data out of R can be almost as important as getting it in!
    To save a data frame to a CSV file, use the `write.csv()` function. For a data
    frame named `pt_data`, simply enter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This will write a CSV file with the name `pt_data.csv` to the R working folder.
    The `row.names` parameter overrides R’s default setting, which is to output row
    names in the CSV file. Generally, this output is unnecessary and will simply inflate
    the size of the resulting file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: For more sophisticated control over reading in files, note that `read.csv()`
    is a special case of the `read.table()` function, which can read tabular data
    in many different forms. This includes other delimited formats such as **tab-separated
    values** (**TSV**) and vertical bar (`|`) delimited files. For more detailed information
    on the `read.table()` family of functions, refer to the R help page using the
    `?read.table` command.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Importing common dataset formats using RStudio
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more complex importation scenarios, the RStudio Desktop software offers
    a simple interface, which will guide you through the process of writing R code
    that can be used to load the data into your project. Although it has always been
    relatively easy to load plaintext data formats like CSV, importing other common
    analytical data formats like Microsoft Excel (`.xls` and `.xlsx`), SAS (`.sas7bdat`
    and `.xpt`), SPSS (`.sav` and `.por`), and Stata (`.dta`) was once a tedious and
    time-consuming process, requiring knowledge of specific tricks and tools across
    multiple R packages. Now, the functionality is available via the **Import Dataset**
    command near the upper right of the RStudio interface, as shown in *Figure 2.1*:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B17290_02_01.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: RStudio’s “Import Dataset” feature provides options to load data
    from a variety of common formats'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the data format selected, you may be prompted to install R packages
    that are required for the functionality in question. Behind the scenes, these
    packages will translate the data format so that it can be used in R. You will
    then be presented with a dialog box allowing you to choose the options for the
    data import process and see a live preview of how the data will appear in R as
    these changes are made.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates the process of importing a Microsoft Excel
    version of the used cars dataset using the `readxl` package ([https://readxl.tidyverse.org](https://readxl.tidyverse.org)),
    but the process is similar for any of the dataset formats:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B17290_02_02.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: The data import dialog provides a “Code Preview” that can be copy-and-pasted
    into your R code file'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The **Code Preview** in the bottom-right of this dialog provides the R code
    to perform the importation with the specified options. Selecting the **Import**
    button will immediately execute the code; however, a better practice is to copy
    and paste the code into your R source code file, so that you can re-import the
    dataset in future sessions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The `read_excel()` function RStudio uses to load Excel data creates an R object
    called a “tibble” rather than a data frame. The differences are so subtle that
    you may not even notice! However, tibbles are an important R innovation enabling
    new ways to work with data frames. The tibble and its functionality are discussed
    in *Chapter 12*, *Advanced Data Preparation*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The RStudio interface has made it easier than ever to work with data in a variety
    of formats, but more advanced functionality exists for working with large datasets.
    In particular, if you have data residing in database platforms like Microsoft
    SQL, MySQL, PostgreSQL, and others, it is possible to connect R to such databases
    to pull the data into R, or even utilize the database hardware itself to perform
    big data computations prior to bringing the results into R. *Chapter 15*, *Making
    Use of Big Data*, introduces these techniques and provides instructions for connecting
    to common databases using RStudio.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Exploring and understanding data
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After collecting data and loading it into R data structures, the next step in
    the machine learning process involves examining the data in detail. It is during
    this step that you will begin to explore the data’s features and examples and
    realize the peculiarities that make your data unique. The better you understand
    your data, the better you will be able to match a machine learning model to your
    learning problem.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The best way to learn the process of data exploration is by example. In this
    section, we will explore the `usedcars.csv` dataset, which contains actual data
    about used cars advertised for sale on a popular US website in the year 2012.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The `usedcars.csv` dataset is available for download on the Packt Publishing
    support page for this book. If you are following along with the examples, be sure
    that this file has been downloaded and saved to your R working directory.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the dataset is stored in CSV form, we can use the `read.csv()` function
    to load the data into an R data frame:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Using the `usedcars` data frame, we will now assume the role of a data scientist
    who has the task of understanding the used car data. Although data exploration
    is a fluid process, the steps can be imagined as a sort of investigation in which
    questions about the data are answered. The exact questions may vary across projects,
    but the types of questions are always similar.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to adapt the basic steps of this investigation to any dataset
    you like, whether large or small.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, toy, vector graphics, automaton  Description automatically
    generated](img/B17290_02_03.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: “Do pricing algorithms get a test drive?” (image created by Midjourney
    AI with the prompt of “cute cartoon robot buying a used car”)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the structure of data
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first questions to ask in an investigation of a new dataset should be about
    how the dataset is organized. If you are fortunate, your source will provide a
    **data dictionary**, a document that describes the dataset’s features. In our
    case, the used car data does not come with this documentation, so we’ll need to
    create our own.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'The `str()` function provides a method for displaying the structure of R objects,
    such as data frames, vectors, or lists. It can be used to create the basic outline
    for our data dictionary:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: For such a simple command, we learn a wealth of information about the dataset.
    The statement `150 obs` informs us that the data includes 150 **observations**,
    which is just another way of saying that the dataset contains 150 rows or examples.
    The number of observations is often simply abbreviated as *n*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Since we know that the data describes used cars, we can now presume that we
    have examples of n = 150 automobiles for sale.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'The `6 variables` statement refers to the six features that were recorded in
    the data. The term **variable** is borrowed from the field of statistics, and
    simply means a mathematical object that can take various values—like the *x* and
    *y* variables you might solve for in an algebraic equation. These features, or
    variables, are listed by name on separate lines. Looking at the line for the feature
    called `color`, we note some additional details:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: After the variable’s name, the `chr` label tells us that the feature is the
    character type. In this dataset, three of the variables are character while three
    are noted as `int`, which refers to the integer type. Although the `usedcars`
    dataset includes only character and integer features, you are also likely to encounter
    `num`, or numeric type, when using non-integer data. Any factors would be listed
    as the `factor` type. Following each variable’s type, R presents a sequence of
    the first few feature values. The values `"Yellow" "Gray" "Silver" "Gray"` are
    the first four values of the `color` feature.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Applying a bit of subject-area knowledge to the feature names and values allows
    us to make some assumptions about what the features represent. `year` could refer
    to the year the vehicle was manufactured, or it could specify the year the advertisement
    was posted. We’ll have to investigate this feature later in more detail, since
    the four example values (`2011 2011 2011 2011`) could be used to argue for either
    possibility. The `model`, `price`, `mileage`, `color`, and `transmission` most
    likely refer to the characteristics of the car for sale.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Although our data appears to have been given meaningful names, this is not always
    the case. Sometimes datasets have features with nonsensical names or codes, like
    `V1`. In these cases, it may be necessary to do additional sleuthing to determine
    what a feature represents. Still, even with helpful feature names, it is always
    prudent to be skeptical about the provided labels. Let’s investigate further.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Exploring numeric features
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To investigate the numeric features in the used car data, we will employ a
    common set of measurements for describing values known as **summary statistics**.
    The `summary()` function displays several common summary statistics. Let’s look
    at a single feature, `year`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Ignoring the meaning of the values for now, the fact that we see numbers such
    as `2000`, `2008`, and `2009` leads us to believe that `year` indicates the year
    of manufacture rather than the year the advertisement was posted, since we know
    the vehicle listings were obtained in 2012.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'By supplying a vector of column names, we can also use the `summary()` function
    to obtain summary statistics for several numeric columns at the same time:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The six summary statistics provided by the `summary()` function are simple,
    yet powerful tools for investigating data. They can be divided into two types:
    measures of center and measures of spread.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the central tendency – mean and median
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Measures of **central tendency** are a class of statistics used to identify
    a value that falls in the middle of a set of data. You are most likely already
    familiar with one common measure of center: the average. In common use, when something
    is deemed average, it falls somewhere between the extreme ends of the scale. An
    average student might have marks falling in the middle of their classmates’. An
    average weight is neither unusually light nor heavy. In general, an average item
    is typical and not too unlike the others in its group. You might think of it as
    an exemplar by which all the others are judged.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'In statistics, the average is also known as the **mean**, which is a measurement
    defined as the sum of all values divided by the number of values. For example,
    to calculate the mean income in a group of three people with incomes of $36,000,
    $44,000, and $56,000, we could type:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'R also provides a `mean()` function, which calculates the mean for a vector
    of numbers:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The mean income of this group of people is about $45,333\. Conceptually, this
    can be imagined as the income each person would have if the total income was divided
    equally across every person.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the preceding `summary()` output listed mean values for `price`
    and `mileage`. These values suggest that the typical used car in this dataset
    was listed at a price of $12,962 and had an odometer reading of 44,261\. What
    does this tell us about our data? We can note that because the average price is
    relatively low, we might expect that the dataset contains economy-class cars.
    Of course, the data could also include late-model luxury cars with high mileage,
    but the relatively low mean mileage statistic doesn’t provide evidence to support
    this hypothesis. On the other hand, it doesn’t provide evidence to ignore the
    possibility either. We’ll need to keep this in mind as we examine the data further.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the mean is by far the most cited statistic for measuring the center
    of a dataset, it is not always the most appropriate one. Another commonly used
    measure of central tendency is the **median**, which is the value that occurs
    at the midpoint of an ordered list of values. As with the mean, R provides a `median()`
    function, which we can apply to our salary data as shown in the following example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: So, because the middle value is `44000`, the median income is $44,000.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: If a dataset has an even number of values, there is no middle value. In this
    case, the median is commonly calculated as the average of the two values at the
    center of the ordered list. For example, the median of the values 1, 2, 3, and
    4 is 2.5.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, it seems like the median and mean are very similar measures.
    Certainly, the mean value of $45,333 and the median value of $44,000 are not very
    far apart. Why have two measures of central tendency? The reason relates to the
    fact that the mean and median are affected differently by values falling at the
    far ends of the range. In particular, the mean is highly sensitive to **outliers**,
    or values that are atypically high or low relative to the majority of data. A
    more nuanced take on outliers will be presented in *Chapter 11*, *Being Successful
    with Machine Learning*, but for now, we can consider them extreme values that
    tend to shift the mean higher or lower relative to the median, because the median
    is largely insensitive to the outlying values.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Recall again the reported median values in the `summary()` output for the used
    car dataset. Although the mean and median for price are similar (differing by
    approximately five percent), there is a much larger difference between the mean
    and median for mileage. For mileage, the mean of 44,261 is more than 20 percent
    larger than the median of 36,385\. Since the mean is more sensitive to extreme
    values than the median, the fact that the mean is much higher than the median
    might lead us to suspect that there are some used cars with extremely high mileage
    values relative to the others in the dataset. To investigate this further, we’ll
    need to add additional summary statistics to our analysis.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Measuring spread – quartiles and the five-number summary
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mean and median provide ways to quickly summarize values, but these measures
    of center tell us little about whether there is diversity in the measurements.
    To measure the diversity, we need to employ another type of summary statistics
    concerned with the **spread** of the data, or how tightly or loosely the values
    are spaced. Knowing about the spread provides a sense of the data’s highs and
    lows, and whether most values are like or unlike the mean and median.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'The **five-number summary** is a set of five statistics that roughly depict
    the spread of a feature’s values. All five statistics are included in the `summary()`
    function output. Written in order, they are:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Minimum (`Min.`)
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First quartile, or Q1 (`1st Qu.`)
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Median, or Q2 (`Median`)
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Third quartile, or Q3 (`3rd Qu.`)
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maximum (`Max.`)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you would expect, the minimum and maximum are the most extreme feature values,
    indicating the smallest and largest values respectively. R provides the `min()`
    and `max()` functions to calculate these for a vector.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'The span between the minimum and maximum value is known as the range. In R,
    the `range()` function returns both the minimum and maximum value:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Combining `range()` with the difference function `diff()` allows you to compute
    the range statistic with a single line of code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: One quarter of the dataset’s values fall below the first quartile (Q1), and
    another quarter is above the third quartile (Q3). Along with the median, which
    is the midpoint of the data values, the quartiles divide a dataset into four portions,
    each containing 25 percent of the values.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Quartiles are a special case of a type of statistic called **quantiles**, which
    are numbers that divide data into equally sized quantities. In addition to quartiles,
    commonly used quantiles include **tertiles** (three parts), **quintiles** (five
    parts), **deciles** (10 parts), and **percentiles** (100 parts). Percentiles are
    often used to describe the ranking of a value; for instance, a student whose test
    score was ranked at the 99th percentile performed better than or equal to 99 percent
    of the other test takers.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'The middle 50 percent of data, found between the first and third quartiles,
    is of particular interest because it is a simple measure of spread. The difference
    between Q1 and Q3 is known as the **interquartile range** (**IQR**), and can be
    calculated with the `IQR()` function:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: We could have also calculated this value by hand from the `summary()` output
    for the `usedcars$price` vector by computing `14904 – 10995 = 3909`. The small
    difference between our calculation and the `IQR()` output is due to the fact that
    R automatically rounds the `summary()` output.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'The `quantile()` function provides a versatile tool for identifying quantiles
    for a set of values. By default, `quantile()` returns the five-number summary.
    Applying the function to the `usedcars$price` vector results in the same summary
    statistics as before:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: When computing quantiles, there are many methods for handling ties among sets
    of values with no single middle value. The `quantile()` function allows you to
    specify among nine different tie-breaking algorithms by specifying the `type`
    parameter. If your project requires a precisely defined quantile, it is important
    to read the function documentation using the `?quantile` command.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'By supplying an additional `probs` parameter for a vector denoting cut points,
    we can obtain arbitrary quantiles, such as the 1st and 99th percentiles:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The sequence function `seq()` generates vectors of evenly spaced values. This
    makes it easy to obtain other slices of data, such as the quintiles (five groups)
    shown in the following command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Equipped with an understanding of the five-number summary, we can re-examine
    the used car `summary()` output. For `price`, the minimum was $3,800 and the maximum
    was $21,992\. Interestingly, the difference between the minimum and Q1 is about
    $7,000, as is the difference between Q3 and the maximum; yet, the difference from
    Q1 to the median to Q3 is roughly $2,000\. This suggests that the lower and upper
    25 percent of values are more widely dispersed than the middle 50 percent of values,
    which seem to be more tightly grouped around the center. We also see a similar
    trend with `mileage`. As you will learn later in this chapter, this pattern of
    spread is common enough that it has been called a “normal” distribution of data.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: The spread of `mileage` also exhibits another interesting property—the difference
    between Q3 and the maximum is far greater than that between the minimum and Q1\.
    In other words, the larger values are far more spread out than the smaller values.
    This finding helps explain why the mean value is much greater than the median.
    Because the mean is sensitive to extreme values, it is pulled higher, while the
    median stays in relatively the same place. This is an important property, which
    becomes more apparent when the data is presented visually.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing numeric features – boxplots
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visualizing numeric features can help diagnose data problems that might negatively
    affect machine learning model performance. A common visualization of the five-number
    summary is a **boxplot**, also known as a **box-and-whisker** plot. The boxplot
    displays the center and spread of a numeric variable in a format that allows you
    to quickly obtain a sense of its range and skew or compare it to other features.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a boxplot for the used car price and mileage data. To obtain
    a boxplot for a numeric vector, we will use the `boxplot()` function. We will
    also specify a pair of extra parameters, `main` and `ylab`, to add a title to
    the figure and label the *y* axis (the vertical axis), respectively. The commands
    to create the `price` and `mileage` boxplots are:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'R will produce figures as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, box and whisker chart  Description automatically generated](img/B17290_02_04.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Boxplots of used car price and mileage data'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: A boxplot depicts the five-number summary using horizontal lines and dots. The
    horizontal lines forming the box in the middle of each figure represent Q1, Q2
    (the median), and Q3 when reading the plot from bottom to top. The median is denoted
    by the dark line, which lines up with $13,592 on the vertical axis for `price`
    and 36,385 mi. on the vertical axis for `mileage`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: In simple boxplots, such as those in the preceding diagram, the box width is
    arbitrary and does not illustrate any characteristic of the data. For more sophisticated
    analyses, it is possible to use the shape and size of the boxes to facilitate
    comparisons of the data across several groups. To learn more about such features,
    begin by examining the `notch` and `varwidth` options in the R `boxplot()` documentation
    by typing the `?boxplot` command.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The minimum and maximum values can be illustrated using whiskers that extend
    below and above the box; however, a widely used convention only allows the whiskers
    to extend to a minimum or maximum of 1.5 times the IQR below Q1 or above Q3\.
    Any values that fall beyond this threshold are considered outliers and are denoted
    as circles or dots. For example, recall that the IQR for `price` was 3,909 with
    Q1 of 10,995 and Q3 of 14,904\. An outlier is therefore any value that is less
    than 10995 - 1.5 * 3909 = 5131.5 or greater than 14904 + 1.5 * 3909 = 20767.5.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The `price` boxplot shows two outliers on both the high and low ends. On the
    `mileage` boxplot, there are no outliers on the low end and thus the bottom whisker
    extends to the minimum value of 4,867\. On the high end, we see several outliers
    beyond the 100,000-mile mark. These outliers are responsible for our earlier finding,
    which noted that the mean value was much greater than the median.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing numeric features – histograms
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **histogram** is another way to visualize the spread of a numeric feature.
    It is like a boxplot in that it divides the feature values into a predefined number
    of portions or **bins**, which act as containers for values. Their similarities
    end there, however. Where a boxplot creates four portions containing the same
    number of values but varying in range, a histogram uses a larger number of portions
    of identical range and allows the bins to contain different numbers of values.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a histogram for the used car `price` and `mileage` data using
    the `hist()` function. As we did with the boxplot, we will specify a title for
    the figure using the `main` parameter and label the *x* axis with the `xlab` parameter.
    The commands to create the histograms are:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'This produces the following diagrams:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, histogram  Description automatically generated](img/B17290_02_05.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Histograms of used car price and mileage data'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The histogram is composed of a series of bars with heights indicating the count,
    or **frequency**, of values falling within each of the equal-width bins partitioning
    the values. The vertical lines that separate the bars, as labeled on the horizontal
    axis, indicate the start and end points of the range of values falling within
    the bin.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the preceding histograms have differing numbers of
    bins. This is because the `hist()` function attempts to identify the optimal number
    of bins for the feature’s range. If you’d like to override this default, use the
    `breaks` parameter. Supplying an integer such as `breaks = 10` creates exactly
    10 bins of equal width, while supplying a vector such as `c(5000, 10000, 15000,
    20000)` creates bins that break at the specified values.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: On the `price` histogram, each of the 10 bars spans an interval of $2,000, beginning
    at $2,000 and ending at $22,000\. The tallest bar in the center of the figure
    covers the range from $12,000 to $14,000 and has a frequency of 50\. Since we
    know our data includes 150 cars, we know that one-third of all the cars are priced
    from $12,000 to $14,000\. Nearly 90 cars—more than half—are priced from $12,000
    to $16,000.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: The `mileage` histogram includes eight bars representing bins of 20,000 miles
    each, beginning at 0 and ending at 160,000 miles. Unlike the `price` histogram,
    the tallest bar is not in the center of the data, but on the left-hand side of
    the diagram. The 70 cars contained in this bin have odometer readings from 20,000
    to 40,000 miles.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: You might also notice that the shape of the two histograms is somewhat different.
    It seems that the used car prices tend to be evenly divided on both sides of the
    middle, while the car mileages stretch further to the right.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'This characteristic is known as **skew**, or more specifically right skew,
    because the values on the high end (right side) are far more spread out than the
    values on the low end (left side). As shown in the following diagram, histograms
    of skewed data look stretched on one of the sides:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, furniture, mirror, table  Description automatically
    generated](img/B17290_02_06.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Three skew patterns visualized with idealized histograms'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The ability to quickly diagnose such patterns in our data is one of the strengths
    of the histogram as a data exploration tool. This will become even more important
    as we start examining other patterns of spread in numeric data.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Understanding numeric data – uniform and normal distributions
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Histograms, boxplots, and statistics describing the center and spread provide
    ways to examine the distribution of a feature’s values. A variable’s **distribution**
    describes how likely a value is to fall within various ranges.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'If all values are equally likely to occur—say, for instance, in a dataset recording
    the values rolled on a fair six-sided die—the distribution is said to be uniform.
    A uniform distribution is easy to detect with a histogram because the bars are
    approximately the same height. The histogram may look something like the following
    diagram:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape, rectangle  Description automatically generated](img/B17290_02_07.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: A uniform distribution visualized with an idealized histogram'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that not all random events are uniform. For instance,
    rolling a weighted six-sided trick die would result in some numbers coming up
    more often than others. While each roll of the die results in a randomly selected
    number, they are not equally likely.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'The used car `price` and `mileage` data are also clearly not uniform, since
    some values are seemingly far more likely to occur than others. In fact, on the
    `price` histogram, it seems that values become less likely to occur as they are
    further away from both sides of the center bar, which results in a bell-shaped
    distribution of data. This characteristic is so common in real-world data that
    it is the hallmark of the so-called **normal distribution**. The stereotypical
    bell-shaped curve of the normal distribution is shown in the following diagram:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17290_02_08.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: A normal distribution visualized with an idealized histogram'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Although there are numerous types of non-normal distributions, many real-world
    phenomena generate data that can be described by the normal distribution. Therefore,
    the normal distribution’s properties have been studied in detail.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Measuring spread – variance and standard deviation
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Distributions allow us to characterize a large number of values using a smaller
    number of parameters. The normal distribution, which describes many types of real-world
    data, can be defined with just two: center and spread. The center of the normal
    distribution is defined by its mean value, which we have used before. The spread
    is measured by a statistic called the **standard deviation**.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the standard deviation, we must first obtain the **variance**,
    which is defined as the average of the squared differences between each value
    and the mean value. In mathematical notation, the variance of a set of *n* values
    in a set named *x* is defined by the following formula:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17290_02_001.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: In this formula, the Greek letter *mu* (written as *![](img/B17290_02_003.png)*)
    denotes the mean of the values, and the variance itself is denoted by the Greek
    letter *sigma* squared (written as *![](img/B17290_02_004.png)*).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard deviation is the square root of the variance, and is denoted by
    sigma (written as *![](img/B17290_02_005.png)*) as shown in the following formula:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17290_02_002.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
- en: 'In R, the `var()` and `sd()` functions save us the trouble of calculating the
    variance and standard deviation by hand. For example, computing the variance and
    standard deviation of the `price` and `mileage` vectors, we find:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: When interpreting the variance, larger numbers indicate that the data is spread
    more widely around the mean. The standard deviation indicates, on average, how
    much each value differs from the mean.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: If you compute these statistics by hand using the formulas in the preceding
    diagrams, you will obtain a slightly different result than the built-in R functions.
    This is because the preceding formulas use the population variance (which divides
    by *n*), while R uses the sample variance (which divides by *n - 1*). Except for
    very small datasets, the distinction is minor.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard deviation can be used to quickly estimate how extreme a given
    value is under the assumption that it came from a normal distribution. The **68–95–99.7
    rule** states that 68 percent of values in a normal distribution fall within one
    standard deviation of the mean, while 95 percent and 99.7 percent of values fall
    within two and three standard deviations, respectively. This is illustrated in
    the following diagram:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, diagram, histogram  Description automatically generated](img/B17290_02_09.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: The percent of values within one, two, and three standard deviations
    of a normal distribution’s mean'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Applying this information to the used car data, we know that the mean and standard
    deviation of `price` were $12,962 and $3,122 respectively. Therefore, by assuming
    that the prices are normally distributed, approximately 68 percent of cars in
    our data were advertised at prices between $12,962 - $3,122 = $9,840 and $12,962
    + $3,122 = $16,804.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Although, strictly speaking, the 68–95–99.7 rule only applies to normal distributions,
    the basic principle applies to almost any data; values more than three standard
    deviations away from the mean tend to be exceedingly rare events.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Exploring categorical features
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you recall, the used car dataset contains three categorical features: `model`,
    `color`, and `transmission`. Additionally, although `year` is stored as a numeric
    vector, each year can be imagined as a category applying to multiple cars. We
    might therefore consider treating it as categorical as well.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast to numeric data, categorical data is typically examined using tables
    rather than summary statistics. A table that presents a single categorical feature
    is known as a **one-way table**. The `table()` function can be used to generate
    one-way tables for the used car data:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The `table()` output lists the categories of the nominal variable and a count
    of the number of values falling into each category. Since we know there are 150
    used cars in the dataset, we can determine that roughly one-third of all the cars
    were manufactured in 2010, given that 49/150 = 0.327.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'R can also perform the calculation of table proportions directly, by using
    the `prop.table()` command on a table produced by the `table()` function:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The results of `prop.table()` can be combined with other R functions to transform
    the output. Suppose we would like to display the results in percentages with a
    single decimal place. We can do this by multiplying the proportions by 100, then
    using the `round()` function while specifying `digits = 1`, as shown in the following
    example:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Although this includes the same information as the default `prop.table()` output,
    the changes make it easier to read. The results show that black is the most common
    color, with nearly a quarter (23.3 percent) of all advertised cars. Silver is
    a close second with 21.3 percent, and red is third with 16.7 percent.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the central tendency – the mode
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In statistics terminology, the **mode** of a feature is the value occurring
    most often. Like the mean and median, the mode is another measure of central tendency.
    It is typically used for categorical data, since the mean and median are not defined
    for nominal variables.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the used car data, the mode of `year` is 2010, while the modes
    for the `model` and `color` variables are `SE` and `Black`, respectively. A variable
    may have more than one mode; a variable with a single mode is **unimodal**, while
    a variable with two modes is **bimodal**. Data with multiple modes is more generally
    called **multimodal**.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Although you might suspect that you could use the `mode()` function, R uses
    this to obtain the type of variable (as in numeric, list, and so on) rather than
    the statistical mode. Instead, to find the statistical mode, simply look at the
    `table()` output for the category with the greatest number of values.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: The mode or modes are used in a qualitative sense to gain an understanding of
    important values. Even so, it would be dangerous to place too much emphasis on
    the mode since the most common value is not necessarily a majority. For instance,
    although black was the single most common car color, it was only about a quarter
    of all advertised cars.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: It is best to think about the modes in relation to the other categories. Is
    there one category that dominates all others, or are there several? Thinking about
    modes this way may help to generate testable hypotheses by raising questions about
    what makes certain values more common than others. If black and silver are common
    used car colors, we might believe that the data represents luxury cars, which
    tend to be sold in more conservative colors. Alternatively, these colors could
    indicate economy cars, which are sold with fewer color options. We will keep these
    questions in mind as we continue to examine this data.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about the modes as common values allows us to apply the concept of
    the statistical mode to numeric data. Strictly speaking, it would be unlikely
    to have a mode for a continuous variable, since no two values are likely to repeat.
    However, if we think about modes as the highest bars on a histogram, we can discuss
    the modes of variables such as `price` and `mileage`. It can be helpful to consider
    the mode when exploring numeric data, particularly to examine whether the data
    is multimodal.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing graphical user interface  Description automatically
    generated](img/B17290_02_10.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Hypothetical distributions of numeric data with one and two modes'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Exploring relationships between features
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have examined variables one at a time, calculating only **univariate**
    statistics. During our investigation, we raised questions that we were unable
    to answer before:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Does the `price` and `mileage` data imply that we are examining only economy-class
    cars, or are there luxury cars with high mileage?
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do relationships between `model` and `color` provide insight into the types
    of cars we are examining?
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These types of questions can be addressed by looking at **bivariate** relationships,
    which consider the relationship between two variables. Relationships of more than
    two variables are called **multivariate** relationships. Let’s begin with the
    bivariate case.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing relationships – scatterplots
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **scatterplot** is a diagram that visualizes a bivariate relationship between
    numeric features. It is a two-dimensional figure in which dots are drawn on a
    coordinate plane using the values of one feature to provide the horizontal *x*
    coordinates, and the values of another feature to provide the vertical *y* coordinates.
    Patterns in the placement of dots reveal underlying associations between the two
    features.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: To answer our question about the relationship between `price` and `mileage`,
    we will examine a scatterplot. We’ll use the `plot()` function, along with the
    `main`, `xlab`, and `ylab` parameters used previously to label the diagram.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: To use `plot()`, we need to specify `x` and `y` vectors containing the values
    used to position the dots on the figure. Although the conclusions would be the
    same regardless of the variable used to supply the *x* and *y* coordinates, convention
    dictates that the *y* variable is the one that is presumed to depend on the other
    (and is therefore known as the **dependent variable**). Since a seller cannot
    modify a car’s odometer reading, mileage is unlikely to be dependent on the car’s
    price. Instead, our hypothesis is that a car’s price depends on the odometer mileage.
    Therefore, we will select `price` as the dependent *y* variable.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'The full command to create our scatterplot is:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'This produces the following scatterplot:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, scatter chart  Description automatically generated](img/B17290_02_11.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: The relationship between used car price and mileage'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Using the scatterplot, we notice a clear relationship between the price of a
    used car and the odometer reading. To read the plot, examine how the values of
    the *y* axis variable change as the values on the *x* axis increase. In this case,
    car prices tend to be lower as the mileage increases. If you have ever sold or
    shopped for a used car, this is not a profound insight.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps a more interesting finding is the fact that there are very few cars
    that have both high price and high mileage, aside from a lone outlier at about
    125,000 miles and $14,000\. The absence of more points like this provides evidence
    to support the conclusion that our dataset is unlikely to include any high-mileage
    luxury cars. All the most expensive cars in the data, particularly those above
    $17,500, seem to have extraordinarily low mileage, which implies that we could
    be looking at a single type of car that retails for a price of around $20,000
    when new.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: The relationship we’ve observed between car prices and mileage is known as a
    negative association because it forms a pattern of dots in a line sloping downward.
    A positive association would appear to form a line sloping upward. A flat line,
    or a seemingly random scattering of dots, is evidence that the two variables are
    not associated at all. The strength of a linear association between two variables
    is measured by a statistic known as **correlation**. Correlations are discussed
    in detail in *Chapter 6*, *Forecasting Numeric Data – Regression Methods*, which
    covers methods for modeling linear relationships.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that not all associations form straight lines. Sometimes the dots
    form a U shape or V shape, while sometimes the pattern seems to be weaker or stronger
    for increasing values of the *x* or *y* variable. Such patterns imply that the
    relationship between the two variables is not linear, and thus correlation would
    be a poor measure of their association.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Examining relationships – two-way cross-tabulations
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To examine a relationship between two nominal variables, a **two-way cross-tabulation**
    is used (also known as a **crosstab** or **contingency table**). A cross-tabulation
    is like a scatterplot in that it allows you to examine how the values of one variable
    vary by the values of another. The format is a table in which the rows are the
    levels of one variable, while the columns are the levels of another. Counts in
    each of the table’s cells indicate the number of values falling into the row and
    column combination.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer our earlier question about whether there is a relationship between
    `model` and `color`, we will examine a crosstab. There are several functions to
    produce two-way tables in R, including `table()`, which we used before for one-way
    tables. The `CrossTable()` function in the `gmodels` package by Gregory R. Warnes
    is perhaps the most user-friendly, as it presents the row, column, and margin
    percentages in a single table, saving us the trouble of computing them ourselves.
    To install the `gmodels` package if you haven’t already done so using the instructions
    in the prior chapter, use the following command:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: After the package installs, type `library(gmodels)` to load the package. Although
    you only need to install the package once, you will need to load the package with
    the `library()` command during each R session in which you plan to use the `CrossTable()`
    function.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding with our analysis, let’s simplify our project by reducing
    the number of levels in the `color` variable. This variable has nine levels, but
    we don’t really need this much detail. What we are truly interested in is whether
    the car’s color is conservative. Toward this end, we’ll divide the nine colors
    into two groups—the first group will include the conservative colors black, gray,
    silver, and white; the second group will include blue, gold, green, red, and yellow.
    We’ll create a logical vector indicating whether the car’s color is conservative
    by our definition. The following returns `TRUE` if the car is one of the four
    conservative colors, and `FALSE` otherwise:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: You may have noticed a new command here. The `%in%` operator returns `TRUE`
    or `FALSE` for each value in the vector on the left-hand side of the operator,
    indicating whether the value is found in the vector on the right-hand side. In
    simple terms, you can translate this line as “is the used car color in the set
    of black, gray, silver, and white?”
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Examining the `table()` output for our newly created variable, we see that
    about two-thirds of the cars have conservative colors while one-third do not:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Now, let’s look at a cross-tabulation to see how the proportion of conservatively
    colored cars varies by model. Since we’re assuming that the model of car dictates
    the choice of color, we’ll treat the conservative color indicator as the dependent
    (`y`) variable. The `CrossTable()` command is therefore:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'This results in the following table:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'The `CrossTable()` output is dense with numbers, but the legend at the top
    (labeled `Cell Contents`) indicates how to interpret each value. The table rows
    indicate the three models of used cars: `SE`, `SEL`, and `SES` (plus an additional
    row for the total across all models). The columns indicate whether the car’s color
    is conservative (plus a column totaling across both types of color).'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: The first value in each cell indicates the number of cars with that combination
    of model and color. The proportions indicate each cell’s contribution to the chi-square
    statistic, the row total, the column total, and the table’s overall total.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: What we are most interested in is the proportion of conservative cars for each
    model. The row proportions tell us that 0.654 (65 percent) of `SE` cars are colored
    conservatively, in comparison to 0.696 (70 percent) of `SEL` cars, and 0.653 (65
    percent) of `SES`. These differences are relatively small, which suggests that
    there are no substantial differences in the types of colors chosen for each model
    of car.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: The chi-square values refer to the cell’s contribution in the **Pearson’s chi-squared
    test** for independence between two variables. Although a complete discussion
    of the statistics behind this test is highly technical, the test measures how
    likely it is that the difference in cell counts in the table is due to chance
    alone, which can help us confirm our hypothesis that the differences by group
    are not substantial. Beginning by adding the cell contributions for the six cells
    in the table, we find *0.009 + 0.004 + 0.086 + 0.044 + 0.007 + 0.004 = 0.154*.
    This is the chi-squared test statistic.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the probability that this statistic is observed under the hypothesis
    that there is no association between the variables, we pass the test statistic
    to the `pchisq()` function as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: The `df` parameter refers to the degrees of freedom, which is a component of
    the statistical test related to the number of rows and columns in the table; again,
    ignoring what it means, it can be computed as (*rows - 1*) * (*columns - 1*),
    or 1 for a 2x2 table and 2 for the 3x2 table used here. Setting `lower.tail =
    FALSE` requests the right-tailed probability of about 0.926, which can be understood
    intuitively as the probability of obtaining a test statistic of at least 0.154
    or greater due to chance alone.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: If the probability of the chi-squared test is very low—perhaps below ten, five,
    or even one percent—it provides strong evidence that the two variables are associated,
    because the observed association in the table is unlikely to have happened by
    chance. In our case, the probability is much closer to 100 percent than to 10
    percent, so it is unlikely we are observing an association between `model` and
    `color` for cars in this dataset.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than computing this by hand, you can also obtain the chi-squared test
    results by adding an additional parameter specifying `chisq = TRUE` when calling
    the `CrossTable()` function. For example:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Note that, aside from slight differences due to rounding, this produces the
    same chi-squared test statistic and probability as was computed by hand.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: The chi-squared test performed here is one of many types of formal hypothesis
    testing that can be performed using traditional statistics. If you’ve ever heard
    the phrase “statistically significant,” it means a statistical test like chi-squared
    (or one of many others) was performed, and it reached a “significant” level—typically,
    a probability less than five percent. Although hypothesis testing is somewhat
    beyond the scope of this book, it will be encountered again briefly in *Chapter
    6*, *Forecasting Numeric Data – Regression Methods*.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the basics of managing data in R. We started
    by taking an in-depth look at the structures used for storing various types of
    data. The foundational R data structure is the vector, which is extended and combined
    into more complex data types, such as lists and data frames. The data frame is
    an R data structure that corresponds to the notion of a dataset having both features
    and examples. R provides functions for reading and writing data frames to spreadsheet-like
    tabular data files.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: We then explored a real-world dataset containing the prices of used cars. We
    examined numeric variables using common summary statistics of center and spread,
    and visualized relationships between prices and odometer readings with a scatterplot.
    Next, we examined nominal variables using tables. In examining the used car data,
    we followed an exploratory process that can be used to understand any dataset.
    These skills will be required for the other projects throughout this book.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have spent some time understanding the basics of data management
    with R, you are ready to begin using machine learning to solve real-world problems.
    In the next chapter, we will tackle our first classification task using nearest
    neighbor methods. You may be surprised to discover that with just a few lines
    of R code, a machine can achieve human-like performance on a challenging medical
    diagnosis task.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Join our book’s Discord space
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our Discord community to meet like-minded people and learn alongside more
    than 4000 people at:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/r](https://packt.link/r)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/r.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
