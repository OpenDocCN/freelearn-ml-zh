["```py\n// Calculate the Euclidean distance, specified here via\n// the last argument in the Distance function.\ndistance := floats.Distance([]float64{1, 2}, []float64{3, 4}, 2)\n\nfmt.Printf(\"\\nDistance: %0.2f\\n\\n\", distance)\n```", "```py\ntype centroid []float64\n```", "```py\n// Pull in the CSV file.\nirisFile, err := os.Open(\"iris.csv\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer irisFile.Close()\n\n// Create a dataframe from the CSV file.\nirisDF := dataframe.ReadCSV(irisFile)\n\n// Define the names of the three separate species contained in the CSV file.\nspeciesNames := []string{\n    \"Iris-setosa\",\n    \"Iris-versicolor\",\n    \"Iris-virginica\",\n}\n\n// Create a map to hold our centroid information.\ncentroids := make(map[string]centroid)\n\n// Filter the dataset into three separate dataframes,\n// each corresponding to one of the Iris species.\nfor _, species := range speciesNames {\n\n    // Filter the original dataset.\n    filter := dataframe.F{\n        Colname:    \"species\",\n        Comparator: \"==\",\n        Comparando: species,\n    }\n    filtered := irisDF.Filter(filter)\n\n    // Calculate the mean of features.\n    summaryDF := filtered.Describe()\n\n    // Put each dimension's mean into the corresponding centroid.\n    var c centroid\n    for _, feature := range summaryDF.Names() {\n\n        // Skip the irrelevant columns.\n        if feature == \"column\" || feature == \"species\" {\n            continue\n        }\n        c = append(c, summaryDF.Col(feature).Float()[0])\n     }\n\n     // Add this centroid to our map.\n     centroids[species] = c\n}\n\n// As a sanity check, output our centroids.\nfor _, species := range speciesNames {\n    fmt.Printf(\"%s centroid: %v\\n\", species, centroids[species])\n}\n```", "```py\n$ go build\n$ ./myprogram \nIris-setosa centroid: [5.005999999999999 3.4180000000000006 1.464 0.2439999999999999]\nIris-versicolor centroid: [5.936 2.7700000000000005 4.26 1.3259999999999998]\nIris-virginica centroid: [6.587999999999998 2.9739999999999998 5.552 2.026]\n```", "```py\n// Create a map to hold the filtered dataframe for each cluster.\nclusters := make(map[string]dataframe.DataFrame)\n\n// Filter the dataset into three separate dataframes,\n// each corresponding to one of the Iris species.\nfor _, species := range speciesNames {\n\n    ...\n\n    // Add the filtered dataframe to the map of clusters.\n    clusters[species] = filtered\n\n    ...\n}\n```", "```py\n// dfFloatRow retrieves a slice of float values from a DataFrame\n// at the given index and for the given column names.\nfunc dfFloatRow(df dataframe.DataFrame, names []string, idx int) []float64 {\n        var row []float64\n        for _, name := range names {\n                row = append(row, df.Col(name).Float()[idx])\n        }\n        return row\n}\n```", "```py\n// Convert our labels into a slice of strings and create a slice\n// of float column names for convenience.\nlabels := irisDF.Col(\"species\").Records()\nfloatColumns := []string{\n    \"sepal_length\",\n    \"sepal_width\",\n    \"petal_length\",\n    \"petal_width\",\n}\n\n// Loop over the records accumulating the average silhouette coefficient.\nvar silhouette float64\n\nfor idx, label := range labels {\n\n    // a will store our accumulated value for a.\n    var a float64\n\n    // Loop over the data points in the same cluster.\n    for i := 0; i < clusters[label].Nrow(); i++ {\n\n        // Get the data point for comparison.\n        current := dfFloatRow(irisDF, floatColumns, idx)\n        other := dfFloatRow(clusters[label], floatColumns, i)\n\n        // Add to a.\n        a += floats.Distance(current, other, 2) / float64(clusters[label].Nrow())\n    }\n\n    // Determine the nearest other cluster.\n    var otherCluster string\n    var distanceToCluster float64\n    for _, species := range speciesNames {\n\n        // Skip the cluster containing the data point.\n        if species == label {\n            continue\n        }\n\n        // Calculate the distance to the cluster from the current cluster.\n        distanceForThisCluster := floats.Distance(centroids[label], centroids[species], 2)\n\n        // Replace the current cluster if relevant.\n        if distanceToCluster == 0.0 || distanceForThisCluster < distanceToCluster {\n            otherCluster = species\n            distanceToCluster = distanceForThisCluster\n        }\n    }\n\n    // b will store our accumulated value for b.\n    var b float64\n\n    // Loop over the data points in the nearest other cluster.\n    for i := 0; i < clusters[otherCluster].Nrow(); i++ {\n\n        // Get the data point for comparison.\n        current := dfFloatRow(irisDF, floatColumns, idx)\n        other := dfFloatRow(clusters[otherCluster], floatColumns, i)\n\n        // Add to b.\n        b += floats.Distance(current, other, 2) / float64(clusters[otherCluster].Nrow())\n    }\n\n    // Add to the average silhouette coefficient.\n    if a > b {\n        silhouette += ((b - a) / a) / float64(len(labels))\n    }\n    silhouette += ((b - a) / b) / float64(len(labels))\n}\n\n// Output the final average silhouette coeffcient to stdout.\nfmt.Printf(\"\\nAverage Silhouette Coefficient: %0.2f\\n\\n\", silhouette)\n```", "```py\n$ go build\n$ ./myprogram\n\nAverage Silhouette Coefficient: 0.51\n```", "```py\n$ head fleet_data.csv \nDriver_ID,Distance_Feature,Speeding_Feature\n3423311935,71.24,28.0\n3423313212,52.53,25.0\n3423313724,64.54,27.0\n3423311373,55.69,22.0\n3423310999,54.58,25.0\n3423313857,41.91,10.0\n3423312432,58.64,20.0\n3423311434,52.02,8.0\n3423311328,31.25,34.0\n```", "```py\n$ go build\n$ ./myprogram\n[7x4] DataFrame\n\n    column   Driver_ID         Distance_Feature Speeding_Feature\n 0: mean     3423312447.500000 76.041523        10.721000       \n 1: stddev   1154.844867       53.469563        13.708543       \n 2: min      3423310448.000000 15.520000        0.000000        \n 3: 25%      3423311447.000000 45.240000        4.000000        \n 4: 50%      3423312447.000000 53.330000        6.000000        \n 5: 75%      3423313447.000000 65.610000        9.000000        \n 6: max      3423314447.000000 244.790000       100.000000      \n    <string> <float>           <float>          <float> \n```", "```py\n// Open the driver dataset file.\nf, err := os.Open(\"fleet_data.csv\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer f.Close()\n\n// Create a dataframe from the CSV file.\ndriverDF := dataframe.ReadCSV(f)\n\n// Extract the distance column.\nyVals := driverDF.Col(\"Distance_Feature\").Float()\n\n// pts will hold the values for plotting\npts := make(plotter.XYs, driverDF.Nrow())\n\n// Fill pts with data.\nfor i, floatVal := range driverDF.Col(\"Speeding_Feature\").Float() {\n    pts[i].X = floatVal\n    pts[i].Y = yVals[i]\n}\n\n// Create the plot.\np, err := plot.New()\nif err != nil {\n    log.Fatal(err)\n}\np.X.Label.Text = \"Speeding\"\np.Y.Label.Text = \"Distance\"\np.Add(plotter.NewGrid())\n\ns, err := plotter.NewScatter(pts)\nif err != nil {\n    log.Fatal(err)\n}\ns.GlyphStyle.Color = color.RGBA{R: 255, B: 128, A: 255}\ns.GlyphStyle.Radius = vg.Points(3)\n\n// Save the plot to a PNG file.\np.Add(s)\nif err := p.Save(4*vg.Inch, 4*vg.Inch, \"fleet_data_scatter.png\"); err != nil {\n    log.Fatal(err)\n} \n```", "```py\n// Open the driver dataset file.\nf, err := os.Open(\"fleet_data.csv\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer f.Close()        \n\n// Create a new CSV reader.\nr := csv.NewReader(f)\nr.FieldsPerRecord = 3\n\n// Initialize a slice of gokmeans.Node's to\n// hold our input data.\nvar data []gokmeans.Node\n\n// Loop over the records creating our slice of\n// gokmeans.Node's.\nfor {\n\n    // Read in our record and check for errors.\n    record, err := r.Read()\n    if err == io.EOF {\n        break\n    }\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Skip the header.\n    if record[0] == \"Driver_ID\" {\n        continue\n    }\n\n    // Initialize a point.\n    var point []float64\n\n    // Fill in our point.\n    for i := 1; i < 3; i++ {\n\n        // Parse the float value.\n        val, err := strconv.ParseFloat(record[i], 64)\n        if err != nil {\n            log.Fatal(err)\n        }\n\n        // Append this value to our point.\n        point = append(point, val)\n    }\n\n    // Append our point to the data.\n    data = append(data, gokmeans.Node{point[0], point[1]})\n}\n```", "```py\n// Generate our clusters with k-means.\nsuccess, centroids := gokmeans.Train(data, 2, 50)\nif !success {\n    log.Fatal(\"Could not generate clusters\")\n}\n\n// Output the centroids to stdout.\nfmt.Println(\"The centroids for our clusters are:\")\nfor _, centroid := range centroids {\n    fmt.Println(centroid)\n}\n```", "```py\n$ go build\n$ ./myprogram \nThe centroids for our clusters are:\n[50.04763437499999 8.82875]\n[180.01707499999992 18.29]\n```", "```py\n// Open the driver dataset file.\nf, err := os.Open(\"fleet_data.csv\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer f.Close()\n\n// Create a dataframe from the CSV file.\ndriverDF := dataframe.ReadCSV(f)\n\n// Extract the distance column.\nyVals := driverDF.Col(\"Distance_Feature\").Float()        \n\n// clusterOne and clusterTwo will hold the values for plotting.\nvar clusterOne [][]float64\nvar clusterTwo [][]float64\n\n// Fill the clusters with data.\nfor i, xVal := range driverDF.Col(\"Speeding_Feature\").Float() {\n    distanceOne := floats.Distance([]float64{yVals[i], xVal}, []float64{50.05, 8.83}, 2)\n    distanceTwo := floats.Distance([]float64{yVals[i], xVal}, []float64{180.02, 18.29}, 2)\n    if distanceOne < distanceTwo {\n        clusterOne = append(clusterOne, []float64{xVal, yVals[i]})\n        continue\n    }\n    clusterTwo = append(clusterTwo, []float64{xVal, yVals[i]})\n}\n\n// pts* will hold the values for plotting\nptsOne := make(plotter.XYs, len(clusterOne))\nptsTwo := make(plotter.XYs, len(clusterTwo))\n\n// Fill pts with data.\nfor i, point := range clusterOne {\n    ptsOne[i].X = point[0]\n    ptsOne[i].Y = point[1]\n}\n\nfor i, point := range clusterTwo {\n    ptsTwo[i].X = point[0]\n    ptsTwo[i].Y = point[1]\n}\n\n// Create the plot.\np, err := plot.New()\nif err != nil {\n    log.Fatal(err)\n}\np.X.Label.Text = \"Speeding\"\np.Y.Label.Text = \"Distance\"\np.Add(plotter.NewGrid())\n\nsOne, err := plotter.NewScatter(ptsOne)\nif err != nil {\n    log.Fatal(err)\n}\nsOne.GlyphStyle.Radius = vg.Points(3)\nsOne.GlyphStyle.Shape = draw.PyramidGlyph{}\n\nsTwo, err := plotter.NewScatter(ptsTwo)\nif err != nil {\n    log.Fatal(err)\n}\nsTwo.GlyphStyle.Radius = vg.Points(3)\n\n// Save the plot to a PNG file.\np.Add(sOne, sTwo)\nif err := p.Save(4*vg.Inch, 4*vg.Inch, \"fleet_data_clusters.png\"); err != nil {\n    log.Fatal(err)\n}\n```", "```py\n// withinClusterMean calculates the mean distance between\n// points in a cluster and the centroid of the cluster.\nfunc withinClusterMean(cluster [][]float64, centroid []float64) float64 {\n\n    // meanDistance will hold our result.\n    var meanDistance float64\n\n    // Loop over the points in the cluster.\n    for _, point := range cluster {\n        meanDistance += floats.Distance(point, centroid, 2) / float64(len(cluster))\n    }\n\n    return meanDistance\n}\n```", "```py\n// Output our within cluster metrics.\nfmt.Printf(\"\\nCluster 1 Metric: %0.2f\\n\", withinClusterMean(clusterOne, []float64{50.05, 8.83}))\nfmt.Printf(\"\\nCluster 2 Metric: %0.2f\\n\", withinClusterMean(clusterTwo, []float64{180.02, 18.29}))\n```", "```py\n$ go build\n$ ./myprogram \n\nCluster 1 Metric: 11.68\n\nCluster 2 Metric: 23.52\n\n```"]