<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Gathering and Organizing Data</h1>
                </header>
            
            <article>
                
<p>Polls have shown that 90% or more of a data scientist's time is spent gathering data, organizing it, and cleaning it, not training/tuning their sophisticated machine learning models. Why is this? Isn't the machine learning part the fun part? Why do we need to care so much about the state of our data? Firstly, without data, our machine learning models can't learn. This might seem obvious. However, we need to realize that part of the strength of the models that we build is in the data that we feed them. As the common phrase goes, <em>garbage in, garbage out</em>. We need to make sure that we gather relevant, clean data to power our machine learning models, such that they can operate on the data as expected and produce valuable results.</p>
<p>Not all types of data are appropriate when using certain types of models. For example, certain models do not perform well when we have high-dimensional data (for example, text data), and other models assume that variables are normally distributed, which is definitely not always the case. Thus, we must take care in gathering data that fits our use case and make sure that we understand how our data and models will interact.</p>
<p>Another reason why gathering and organizing data consumes so much of a data scientist's time is that data is often messy and hard to aggregate. In most organizations, data might be housed in various systems and formats, and have various access control policies. We can't assume that supplying a training set to our model will be as easy as specifying a file path; this is often not the case.</p>
<p>To form a training/test set or to supply variables to a model for predictions, we will likely need to deal with various formats of data, such as CSV, JSON, database tables, and so on, and we will likely need to transform individual values. Common transformations include parsing date times, converting categorical data to numerical data, normalizing values, and applying some function across values. However, we can't always assume that all values of a certain variable are present or able to be parsed in a similar manner.</p>
<p>Often data includes missing values, mixed types, or corrupted values. How we handle each of these scenarios will directly influence the quality of the models that we build, and thus, we have to be willing to carefully gather, organize, and understand our data.</p>
<p>Even though much of this book will be focused on various modeling techniques, you should always consider data gathering, parsing, and organization as a (or maybe the) key component of a successful data science project. If this part of your project is not carefully developed with a high level of integrity, you are setting yourself up for trouble in the long run.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling data - Gopher style</h1>
                </header>
            
            <article>
                
<p>In comparison to many other languages that are used for data science/analysis, Go provides a very strong foundation for data manipulation and parsing. Although other languages (for example, Python or R) may allow users to quickly explore data interactively, they often promote integrity-breaking convenience, that is, dynamic and interactive data exploration often results in code that behaves strangely when applied more generally.</p>
<p>Take, for instance, this simple CSV file:</p>
<pre>1,blah1<br/>2,blah2<br/>3,blah3</pre>
<p>It is true that, very quickly, we can write some Python code to parse this CSV and output the maximum value from the integer column without even knowing what types are in the data:</p>
<pre>import pandas as pd<br/><br/># Define column names.<br/>cols = [<br/> 'integercolumn',<br/> 'stringcolumn'<br/> ]<br/><br/># Read in the CSV with pandas.<br/>data = pd.read_csv('myfile.csv', names=cols)<br/><br/># Print out the maximum value in the integer column.<br/>print(data['integercolumn'].max())</pre>
<p>This simple program will print the correct result:</p>
<pre><strong>$ python myprogram.py</strong><br/><strong>3</strong></pre>
<p>We now remove one of the integer values to produce a missing value, as shown here:</p>
<pre>1,blah1<br/>2,blah2<br/>,blah3</pre>
<p>The Python program consequently has a complete breakdown in integrity; specifically, the program still runs, doesn't tell us that anything went differently, still produces a value, and produces a value of a different type:</p>
<pre><strong>$ python myprogram.py</strong><br/><strong>2.0</strong></pre>
<p>This is unacceptable. All but one of our integer values could disappear, and we wouldn't have any insight into the changes. This could produce profound changes in our modeling, but they would be extremely hard to track down. Generally, when we opt for the conveniences of dynamic types and abstraction, we are accepting this sort of variability in behavior.</p>
<div class="packt_infobox">The important thing here is not that you cannot handle such behavior in Python, because Python, experts will quickly recognize that you can properly handle such behavior. The point is that such conveniences do not promote integrity by default, and thus, it is very easy to shoot yourself in the foot.</div>
<p>On the other hand, we can leverage Go's static typing and explicit error handling to ensure that our data is parsed as expected. In this small example, we can also write some Go code, without too much trouble, to parse our CSV (don't worry about the details right now):</p>
<pre>// Open the CSV.<br/>f, err := os.Open("myfile.csv")<br/>if err != nil {<br/>    log.Fatal(err)<br/>}<br/><br/>// Read in the CSV records.<br/>r := csv.NewReader(f)<br/>records, err := r.ReadAll()<br/>if err != nil {<br/>    log.Fatal(err)<br/>}<br/><br/>// Get the maximum value in the integer column.<br/>var intMax int<br/>for _, record := range records {<br/><br/>    // Parse the integer value.<br/>    intVal, err := strconv.Atoi(record[0])<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }<br/><br/>    // Replace the maximum value if appropriate.<br/>    if intVal &gt; intMax {<br/>        intMax = intVal<br/>    }<br/>}<br/><br/>// Print the maximum value.<br/>fmt.Println(intMax)</pre>
<p>This will produce the same correct result for the CSV file with all the integer values present:</p>
<pre><strong>$ go build</strong><br/><strong>$ ./myprogram</strong><br/><strong>3</strong></pre>
<p>But in contrast to our previous Python code, our Go code will inform us when we encounter something that we don't expect in the input CSV (for the case when we remove the value 3):</p>
<pre><strong>$ go build</strong><br/><strong>$ ./myprogram</strong><br/><strong>2017/04/29 12:29:45 strconv.ParseInt: parsing "": invalid syntax</strong></pre>
<p>Here, we have maintained integrity, and we can ensure that we can handle missing values in a manner that is appropriate for our use case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Best practices for gathering and organizing data with Go</h1>
                </header>
            
            <article>
                
<p>As you can see in the preceding section, Go itself provides us with an opportunity to maintain high levels of integrity in our data gathering, parsing, and organization. We want to ensure that we leverage Go's unique properties whenever we are preparing our data for machine learning workflows.</p>
<p>Generally, Go data scientists/analysts should follow the following best practices when gathering and organizing data. These best practices are meant to help you maintain integrity in your applications, and been able you to reproduce any analysis:</p>
<ol>
<li><strong>Check for and enforce expected types</strong>: This might seem obvious, but it is too often overlooked when using dynamically typed languages. Although it is slightly verbose, explicitly parsing data into expected types and handling related errors can save you big headaches down the road.</li>
<li><strong>Standardize and simplify your data ingress/egress</strong>: There are many third-party packages for handling certain types of data or interactions with certain sources of data (some of which we will cover in this book). However, if you standardize the ways you are interacting with data sources, particularly centered around the use of <kbd>stdlib</kbd>, you can develop predictable patterns and maintain consistency within your team. A good example of this is a choice to utilize <kbd>database/sql</kbd> for database interactions rather than using various third-party APIs and DSLs.</li>
<li><strong>Version your data</strong>: Machine learning models produce extremely different results depending on the training data you use, your choice of parameters, and input data. Thus, it is impossible to reproduce results without versioning both your code and data. We will discuss the appropriate techniques for data versioning later in this chapter.</li>
</ol>
<div class="packt_tip">If you start to stray from these general principles, you should stop immediately. You are likely to sacrifice integrity for the sake of convenience, which is a dangerous road. We will let these principles guide us through the book and as we consider various data formats/sources in the following section.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CSV files</h1>
                </header>
            
            <article>
                
<p>CSV files might not be a go-to format for big data, but as a data scientist or developer working in machine learning, you are sure to encounter this format. You might need a mapping of zip codes to latitude/longitude and find this as a CSV file on the internet, or you may be given sales figures from your sales team in a CSV format. In any event, we need to understand how to parse these files.</p>
<p>The main package that we will utilize in parsing CSV files is <kbd>encoding/csv</kbd> from Go's standard library. However, we will also discuss a couple of packages that allow us to quickly manipulate or transform CSV data--<kbd>github.com/kniren/gota/dataframe</kbd> and <span><kbd>go-hep.org/x/hep/csvutil</kbd>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading in CSV data from a file</h1>
                </header>
            
            <article>
                
<p>Let's consider a simple CSV file, which we will return to later, named <kbd>iris.csv</kbd> (available here: <a href="https://archive.ics.uci.edu/ml/datasets/iris">https://archive.ics.uci.edu/ml/datasets/iris</a>). This CSV file includes four float columns of flower measurements and a string column with the corresponding flower species:</p>
<pre><strong>$</strong> <strong>head iris.csv</strong> <br/><strong>5.1,3.5,1.4,0.2,Iris-setosa</strong><br/><strong>4.9,3.0,1.4,0.2,Iris-setosa</strong><br/><strong>4.7,3.2,1.3,0.2,Iris-setosa</strong><br/><strong>4.6,3.1,1.5,0.2,Iris-setosa</strong><br/><strong>5.0,3.6,1.4,0.2,Iris-setosa</strong><br/><strong>5.4,3.9,1.7,0.4,Iris-setosa</strong><br/><strong>4.6,3.4,1.4,0.3,Iris-setosa</strong><br/><strong>5.0,3.4,1.5,0.2,Iris-setosa</strong><br/><strong>4.4,2.9,1.4,0.2,Iris-setosa</strong><br/><strong>4.9,3.1,1.5,0.1,Iris-setosa</strong></pre>
<p>With <kbd>encoding/csv</kbd> imported, we first open the CSV file and create a CSV reader value:</p>
<pre>// Open the iris dataset file.<br/>f, err := os.Open("../data/iris.csv")<br/>if err != nil {<br/>    log.Fatal(err)<br/>}<br/>defer f.Close()<br/><br/>// Create a new CSV reader reading from the opened file.<br/>reader := csv.NewReader(f)</pre>
<p>Then we can read in all of the records (corresponding to rows) of the CSV file. These records are imported as <kbd>[][]string</kbd>:</p>
<pre>// Assume we don't know the number of fields per line. By setting<br/>// FieldsPerRecord negative, each row may have a variable<br/>// number of fields.<br/>reader.FieldsPerRecord = -1<br/><br/>// Read in all of the CSV records.<br/>rawCSVData, err := reader.ReadAll()<br/>if err != nil {<br/>    log.Fatal(err)<br/>}</pre>
<p>We can also read in records one at a time in an infinite loop. Just make sure that you check for the end of the file (<kbd>io.EOF</kbd>) so that the loop ends after reading in all of your data:</p>
<pre>// Create a new CSV reader reading from the opened file.<br/>reader := csv.NewReader(f)<br/>reader.FieldsPerRecord = -1<br/><br/>// rawCSVData will hold our successfully parsed rows.<br/>var rawCSVData [][]string<br/><br/>// Read in the records one by one.<br/>for {<br/><br/>    // Read in a row. Check if we are at the end of the file.<br/>    record, err := reader.Read()<br/>    if err == io.EOF {<br/>        break<br/>    }<br/><br/>    // Append the record to our dataset.<br/>    rawCSVData = append(rawCSVData, record)<br/>}</pre>
<div class="packt_tip">If your CSV file is not delimited by commas and/or if your CSV file contains commented rows, you can utilize the <kbd>csv.Reader.Comma</kbd> and <kbd>csv.Reader.Comment</kbd> fields to properly handle uniquely formatted CSV files. In cases where the fields in your CSV file are single-quoted, you may need to add in a helper function to trim the single quotes and parse the values.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling unexpected fields</h1>
                </header>
            
            <article>
                
<p>The preceding methods work fine with clean CSV data, but, in general, we don't encounter clean data. We have to parse messy data. For example, you might find unexpected fields or numbers of fields in your CSV records. This is why <kbd>reader.FieldsPerRecord</kbd> exists. This field of the reader value lets us easily handle messy data, as follows:</p>
<pre><strong>4.3,3.0,1.1,0.1,Iris-setosa</strong><br/><strong>5.8,4.0,1.2,0.2,Iris-setosa</strong><br/><strong>5.7,4.4,1.5,0.4,Iris-setosa</strong><br/><strong>5.4,3.9,1.3,0.4,blah,Iris-setosa</strong><br/><strong>5.1,3.5,1.4,0.3,Iris-setosa</strong><br/><strong>5.7,3.8,1.7,0.3,Iris-setosa</strong><br/><strong>5.1,3.8,1.5,0.3,Iris-setosa</strong></pre>
<p>This version of the <kbd>iris.csv</kbd> file has an extra field in one of the rows. We know that each record should have five fields, so let's set our <kbd>reader.FieldsPerRecord</kbd> <span>value to <kbd>5</kbd>:</span></p>
<pre>// We should have 5 fields per line. By setting<br/>// FieldsPerRecord to 5, we can validate that each of the<br/>// rows in our CSV has the correct number of fields.<br/>reader.FieldsPerRecord = 5</pre>
<p>Then as we are reading in records from the CSV file, we can check for unexpected fields and maintain the integrity of our data:</p>
<pre>// rawCSVData will hold our successfully parsed rows.<br/>var rawCSVData [][]string<br/><br/>// Read in the records looking for unexpected numbers of fields.<br/>for {<br/><br/>    // Read in a row. Check if we are at the end of the file.<br/>    record, err := reader.Read()<br/>    if err == io.EOF {<br/>        break<br/>    }<br/><br/>    // If we had a parsing error, log the error and move on.<br/>    if err != nil {<br/>        log.Println(err)<br/>        continue<br/>    }<br/><br/>    // Append the record to our dataset, if it has the expected<br/>    // number of fields.<br/>    rawCSVData = append(rawCSVData, record)<br/>}</pre>
<p>Here, we have chosen to handle the error by logging the error, and we only collect successfully parsed records into <kbd>rawCSVData</kbd>. The reader will note that this error could be handled in many different ways. The important thing is that we are forcing ourselves to check for an expected property of the data and increasing the integrity of our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling unexpected types</h1>
                </header>
            
            <article>
                
<p>We just saw that CSV data is read into Go as <kbd>[][]string</kbd>. However, Go is statically typed, which allows us to enforce strict checks for each of the CSV fields. We can do this as we parse each field for further processing. Consider some messy data that has random fields that don't match the type of the other values in a column:</p>
<pre><strong>4.6,3.1,1.5,0.2,Iris-setosa</strong><br/><strong>5.0,string,1.4,0.2,Iris-setosa</strong><br/><strong>5.4,3.9,1.7,0.4,Iris-setosa</strong><br/><strong>5.3,3.7,1.5,0.2,Iris-setosa</strong><br/><strong>5.0,3.3,1.4,0.2,Iris-setosa</strong><br/><strong>7.0,3.2,4.7,1.4,Iris-versicolor</strong><br/><strong>6.4,3.2,4.5,1.5,</strong><br/><strong>6.9,3.1,4.9,1.5,Iris-versicolor</strong><br/><strong>5.5,2.3,4.0,1.3,Iris-versicolor</strong><br/><strong>4.9,3.1,1.5,0.1,Iris-setosa</strong><br/><strong>5.0,3.2,1.2,string,Iris-setosa</strong><br/><strong>5.5,3.5,1.3,0.2,Iris-setosa</strong><br/><strong>4.9,3.1,1.5,0.1,Iris-setosa</strong><br/><strong>4.4,3.0,1.3,0.2,Iris-setosa</strong></pre>
<p>To check the types of the fields in our CSV records, let's create a <kbd>struct</kbd> variable to hold successfully parsed values:</p>
<pre>// CSVRecord contains a successfully parsed row of the CSV file.<br/>type CSVRecord struct {<br/>    SepalLength  float64<br/>    SepalWidth   float64<br/>    PetalLength  float64<br/>    PetalWidth   float64<br/>    Species      string<br/>    ParseError   error<br/>}</pre>
<p>Then, before we loop over the records, let's initialize a slice of these values:</p>
<pre>// Create a slice value that will hold all of the successfully parsed<br/>// records from the CSV.<br/>var csvData []CSVRecord</pre>
<p>Now as we loop over the records, we can parse into the relevant type for that record, catch any errors, and log as needed:</p>
<pre><br/>// Read in the records looking for unexpected types.<br/>for {<br/><br/>    // Read in a row. Check if we are at the end of the file.<br/>    record, err := reader.Read()<br/>    if err == io.EOF {<br/>        break<br/>    }<br/><br/>    // Create a CSVRecord value for the row.<br/>    var csvRecord CSVRecord<br/><br/>    // Parse each of the values in the record based on an expected type.<br/>    for idx, value := range record {<br/><br/>        // Parse the value in the record as a string for the string column.<br/>        if idx == 4 {<br/><br/>            // Validate that the value is not an empty string. If the<br/>            // value is an empty string break the parsing loop.<br/>            if value == "" {<br/>                log.Printf("Unexpected type in column %d\n", idx)<br/>                csvRecord.ParseError = fmt.Errorf("Empty string value")<br/>                break<br/>            }<br/><br/>            // Add the string value to the CSVRecord.<br/>            csvRecord.Species = value<br/>            continue<br/>        }<br/><br/>        // Otherwise, parse the value in the record as a float64.<br/>        var floatValue float64<br/><br/>        // If the value can not be parsed as a float, log and break the<br/>        // parsing loop.<br/>        if floatValue, err = strconv.ParseFloat(value, 64); err != nil {<br/>            log.Printf("Unexpected type in column %d\n", idx)<br/>            csvRecord.ParseError = fmt.Errorf("Could not parse float")<br/>            break<br/>        }<br/><br/>        // Add the float value to the respective field in the CSVRecord.<br/>        switch idx {<br/>        case 0:<br/>            csvRecord.SepalLength = floatValue<br/>        case 1:<br/>            csvRecord.SepalWidth = floatValue<br/>        case 2:<br/>            csvRecord.PetalLength = floatValue<br/>        case 3:<br/>            csvRecord.PetalWidth = floatValue<br/>        }<br/>    }<br/><br/>    // Append successfully parsed records to the slice defined above.<br/>    if csvRecord.ParseError == nil {<br/>        csvData = append(csvData, csvRecord)<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Manipulating CSV data with data frames</h1>
                </header>
            
            <article>
                
<p>As you can see, manually parsing many different fields and performing row-by-row operations can be rather verbose and tedious. This is definitely <em>not</em> an excuse to increase complexity and import a bunch of non standard functionalities. You should still default to the use of <kbd>encoding/csv</kbd> in most cases.</p>
<p>However, manipulation of data frames has proven to be a successful and somewhat standardized way (in the data science community) of dealing with tabular data. Thus, in some cases, it is worth employing some third-party functionality to manipulate tabular data, such as CSV data. For example, data frames and the corresponding functionality can be very useful when you are trying to filter, subset, and select portions of tabular datasets. In this section, we will introduce <kbd>github.com/kniren/gota/dataframe</kbd>, a wonderful <kbd>dataframe</kbd> package for Go:</p>
<pre>import "github.com/kniren/gota/dataframe" </pre>
<p>To create a data frame from a CSV file, we open a file with <kbd>os.Open()</kbd> and then supply the returned pointer to the <kbd>dataframe.ReadCSV()</kbd> function:</p>
<pre>// Open the CSV file.<br/>irisFile, err := os.Open("iris.csv")<br/>if err != nil {<br/>    log.Fatal(err)<br/>}<br/>defer irisFile.Close()<br/><br/>// Create a dataframe from the CSV file.<br/>// The types of the columns will be inferred.<br/>irisDF := dataframe.ReadCSV(irisFile)<br/><br/>// As a sanity check, display the records to stdout.<br/>// Gota will format the dataframe for pretty printing.<br/>fmt.Println(irisDF)</pre>
<p>If we compile and run this Go program, we will see a nice, pretty-printed version of our data with the types that were inferred during parsing:</p>
<pre><strong>$ go build</strong><br/><strong>$ ./myprogram</strong><br/><strong>[150x5] DataFrame</strong><br/><br/><strong> sepal_length sepal_width petal_length petal_width species </strong><br/><strong> 0: 5.100000 3.500000 1.400000 0.200000 Iris-setosa</strong><br/><strong> 1: 4.900000 3.000000 1.400000 0.200000 Iris-setosa</strong><br/><strong> 2: 4.700000 3.200000 1.300000 0.200000 Iris-setosa</strong><br/><strong> 3: 4.600000 3.100000 1.500000 0.200000 Iris-setosa</strong><br/><strong> 4: 5.000000 3.600000 1.400000 0.200000 Iris-setosa</strong><br/><strong> 5: 5.400000 3.900000 1.700000 0.400000 Iris-setosa</strong><br/><strong> 6: 4.600000 3.400000 1.400000 0.300000 Iris-setosa</strong><br/><strong> 7: 5.000000 3.400000 1.500000 0.200000 Iris-setosa</strong><br/><strong> 8: 4.400000 2.900000 1.400000 0.200000 Iris-setosa</strong><br/><strong> 9: 4.900000 3.100000 1.500000 0.100000 Iris-setosa</strong><br/><strong> ... ... ... ... ... </strong><br/><strong> &lt;float&gt; &lt;float&gt; &lt;float&gt; &lt;float&gt; &lt;string&gt;</strong></pre>
<p>Once we have the data parsed into a <kbd>dataframe</kbd>, we can filter, subset, and select our data easily:</p>
<pre>// Create a filter for the dataframe.<br/>filter := dataframe.F{<br/>    Colname: "species",<br/>    Comparator: "==",<br/>    Comparando: "Iris-versicolor",<br/>}<br/><br/>// Filter the dataframe to see only the rows where<br/>// the iris species is "Iris-versicolor".<br/>versicolorDF := irisDF.Filter(filter)<br/>if versicolorDF.Err != nil {<br/>    log.Fatal(versicolorDF.Err)<br/>}<br/><br/>// Filter the dataframe again, but only select out the<br/>// sepal_width and species columns.<br/>versicolorDF = irisDF.Filter(filter).Select([]string{"sepal_width", "species"})<br/><br/>// Filter and select the dataframe again, but only display<br/>// the first three results.<br/>versicolorDF = irisDF.Filter(filter).Select([]string{"sepal_width", "species"}).Subset([]int{0, 1, 2})</pre>
<p>This is really only scratching the surface of the <kbd>github.com/kniren/gota/dataframe</kbd> package. You can merge datasets, output to other formats, and even process JSON data. For more information about this package, you should visit the auto generated GoDocs at <a href="https://godoc.org/github.com/kniren/gota/dataframe">https://godoc.org/github.com/kniren/gota/dataframe</a>, which is good practice, in general, for any packages we discuss in the book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON</h1>
                </header>
            
            <article>
                
<p>In a world in which the majority of data is accessed via the web, and most engineering organizations implement some number of microservices, we are going to encounter data in JSON format fairly frequently. We may only need to deal with it when pulling some random data from an API, or it might actually be the primary data format that drives our analytics and machine learning workflows.</p>
<p>Typically, JSON is used when ease of use is the primary goal of data interchange. Since JSON is human readable, it is easy to debug if something breaks. Remember that we want to maintain the integrity of our data handling as we process data with Go, and part of that process is ensuring that, when possible, our data is interpretable and readable. JSON turns out to be very useful in achieving these goals (which is why it is also used for logging, in many cases).</p>
<p>Go offers really great JSON functionality in its standard library with <kbd>encoding/json</kbd>. We will utilize this standard library functionality throughout the book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parsing JSON</h1>
                </header>
            
            <article>
                
<p>To understand how to parse (that is, unmarshal) JSON data in Go, we will be using some data from the Citi Bike API (<a href="https://www.citibikenyc.com/system-data" target="_blank">https://www.citibikenyc.com/system-data</a>), a bike-sharing service operating in New York City. Citi Bike provides frequently updated operational information about its network of bike sharing stations in JSON format at <a href="https://gbfs.citibikenyc.com/gbfs/en/station_status.json" target="_blank">https://gbfs.citibikenyc.com/gbfs/en/station_status.json</a>:</p>
<pre>{<br/>  "last_updated": 1495252868,<br/>  "ttl": 10,<br/>  "data": {<br/>    "stations": [<br/>      {<br/>        "station_id": "72",<br/>        "num_bikes_available": 10,<br/>        "num_bikes_disabled": 3,<br/>        "num_docks_available": 26,<br/>        "num_docks_disabled": 0,<br/>        "is_installed": 1,<br/>        "is_renting": 1,<br/>        "is_returning": 1,<br/>        "last_reported": 1495249679,<br/>        "eightd_has_available_keys": false<br/>      },<br/>      {<br/>        "station_id": "79",<br/>        "num_bikes_available": 0,<br/>        "num_bikes_disabled": 0,<br/>        "num_docks_available": 33,<br/>        "num_docks_disabled": 0,<br/>        "is_installed": 1,<br/>        "is_renting": 1,<br/>        "is_returning": 1,<br/>        "last_reported": 1495248017,<br/>        "eightd_has_available_keys": false<br/>      },<br/><br/>      etc...<br/><br/>      {<br/>        "station_id": "3464",<br/>        "num_bikes_available": 1,<br/>        "num_bikes_disabled": 3,<br/>        "num_docks_available": 53,<br/>        "num_docks_disabled": 0,<br/>        "is_installed": 1,<br/>        "is_renting": 1,<br/>        "is_returning": 1,<br/>        "last_reported": 1495250340,<br/>        "eightd_has_available_keys": false<br/>      }<br/>    ]<br/>  }<br/>}</pre>
<p>To parse the import and this type of data in Go, we first need to import <kbd>encoding/json</kbd> (along with a couple of other things from a standard library, such as <kbd>net/http</kbd>, because we are going to pull this data off of the previously mentioned website). We will also define <kbd>struct</kbd> that mimics the structure of the JSON shown in the preceding code:</p>
<pre>import (<br/>    "encoding/json"<br/>    "fmt"<br/>    "io/ioutil"<br/>    "log"<br/>    "net/http"<br/>)<br/><br/>// citiBikeURL provides the station statuses of CitiBike bike sharing stations.<br/>const citiBikeURL = "https://gbfs.citibikenyc.com/gbfs/en/station_status.json"<br/><br/>// stationData is used to unmarshal the JSON document returned form citiBikeURL.<br/>type stationData struct {<br/>    LastUpdated int `json:"last_updated"`<br/>    TTL int `json:"ttl"`<br/>    Data struct {<br/>        Stations []station `json:"stations"`<br/>    } `json:"data"`<br/>}<br/><br/>// station is used to unmarshal each of the station documents in stationData.<br/>type station struct {<br/>    ID string `json:"station_id"`<br/>    NumBikesAvailable int `json:"num_bikes_available"`<br/>    NumBikesDisabled int `json:"num_bike_disabled"`<br/>    NumDocksAvailable int `json:"num_docks_available"`<br/>    NumDocksDisabled int `json:"num_docks_disabled"`<br/>    IsInstalled int `json:"is_installed"`<br/>    IsRenting int `json:"is_renting"`<br/>    IsReturning int `json:"is_returning"`<br/>    LastReported int `json:"last_reported"`<br/>    HasAvailableKeys bool `json:"eightd_has_available_keys"`<br/>}</pre>
<p>Note a couple of things here: (i) we have followed Go idioms by avoiding the <kbd>struct</kbd> field name with underscores, but (ii) we have utilized the <kbd>json</kbd> struct tags to label the <kbd>struct</kbd> fields with the corresponding expected fields in the JSON data.</p>
<div class="packt_infobox">Note, to properly parse JSON data, the struct fields need to be exported fields. That is, the fields need to begin with a capital letter. <kbd>encoding/json</kbd> does cannot view fields using reflect unless they are exported.</div>
<p>Now we can get the JSON data from the URL and unmarshal it into a new <kbd>stationData</kbd> value. This will produce a <kbd>struct</kbd> variable with the respective fields filled with the data in the tagged JSON data fields. We can check it by printing out some data associated with one of the stations:</p>
<pre>// Get the JSON response from the URL.<br/>response, err := http.Get(citiBikeURL)<br/>if err != nil {<br/>    log.Fatal(err)<br/>}<br/>defer response.Body.Close()<br/><br/>// Read the body of the response into []byte.<br/>body, err := ioutil.ReadAll(response.Body)<br/>if err != nil {<br/>    log.Fatal(err)<br/>}<br/><br/>// Declare a variable of type stationData.<br/>var sd stationData<br/><br/>// Unmarshal the JSON data into the variable.<br/>if err := json.Unmarshal(body, &amp;sd); err != nil {<br/>    log.Fatal(err)<br/>}<br/><br/>// Print the first station.<br/>fmt.Printf("%+v\n\n", sd.Data.Stations[0])</pre>
<p>When we run this, we can see that our <kbd>struct</kbd> contains the parsed data from the URL:</p>
<pre><strong>$ go build</strong><br/><strong>$ ./myprogram</strong> <br/><strong>{ID:72 NumBikesAvailable:11 NumBikesDisabled:0 NumDocksAvailable:25 NumDocksDisabled:0 IsInstalled:1 IsRenting:1 IsReturning:1 LastReported:1495252934 HasAvailableKeys:false}</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON output</h1>
                </header>
            
            <article>
                
<p>Now let's say that we have the Citi Bike station data in our <kbd>stationData</kbd> struct value and we want to save that data out to a file. We can do this with <kbd>json.marshal</kbd>:</p>
<pre>// Marshal the data.<br/>outputData, err := json.Marshal(sd)<br/>if err != nil {<br/>    log.Fatal(err)<br/>}<br/><br/>// Save the marshalled data to a file.<br/>if err := ioutil.WriteFile("citibike.json", outputData, 0644); err != nil {<br/>    log.Fatal(err)<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SQL-like databases</h1>
                </header>
            
            <article>
                
<p>Although there is a good bit of hype around interesting NoSQL databases and key-value stores, SQL-like databases are still ubiquitous. Every data scientist will, at some point, be processing data from an SQL-like database, such as Postgres, MySQL, or SQLite.</p>
<p>For example, we may be required to query one or more tables in a Postgres database to generate a set of features for model training. After using that model to make predictions or identify anomalies, we may send results to another database table that drives a dashboard or other reporting tool.</p>
<p>Go, of course, interacts nicely with all the popular <span>data stores, such as</span> SQL, NoSQL, key-value, and so on, but here, we will focus on SQL-like interactions. <span>W</span>e will utilize <kbd>database/sql</kbd> for these interactions throughout the book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting to an SQL database</h1>
                </header>
            
            <article>
                
<p>The first thing we need do before connecting to an SQL-like database is identify the particular database that we will be interacting with and import a corresponding driver. In the following examples, we will be connecting to a Postgres database and will utilize the <kbd>github.com/lib/pq</kbd> database driver for <kbd>database/sql</kbd>. This driver can be loaded via an empty import (with a corresponding comment):</p>
<pre>import (<br/>    "database/sql"<br/>    "fmt"<br/>    "log"<br/>    "os"<br/><br/>    // pq is the library that allows us to connect<br/>    // to postgres with databases/sql.<br/>    _ "github.com/lib/pq"<br/>)</pre>
<p>Now let's assume that you have exported the Postgres connection string to an environmental variable <kbd>PGURL</kbd>. We can easily create an <kbd>sql.DB</kbd> value for our connection via the follow code:</p>
<pre>// Get the postgres connection URL. I have it stored in<br/>// an environmental variable.<br/>pgURL := os.Getenv("PGURL")<br/>if pgURL == "" {<br/>    log.Fatal("PGURL empty")<br/>}<br/><br/>// Open a database value. Specify the postgres driver<br/>// for databases/sql.<br/>db, err := sql.Open("postgres", pgURL)<br/>if err != nil {<br/>    log.Fatal(err)<br/>}<br/>defer db.Close()</pre>
<p>Note that we need to defer the <kbd>close</kbd> method on this value. Also, note that creating this value does not mean that you have made a successful connection to the database. This is merely a value used by <kbd>database/sql</kbd> to connect to the database when triggered to do so by certain operations (such as a query).</p>
<p>To ensure that we can make a successful connection to the database, we can use the <kbd>Ping</kbd> method:</p>
<pre>if err := db.Ping(); err != nil {<br/>    log.Fatal(err)<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Querying the database</h1>
                </header>
            
            <article>
                
<p>Now that we know how to connect to the database, let's see how we can get data out of the database. We won't cover the specifics of SQL queries and statements in this book. If you are not familiar with SQL, I would highly recommend that you learn how to query, insert, and so on, but for our purposes here, you should know that there are basically two types of operations we want to perform as related to SQL databases:</p>
<ul>
<li>A <kbd>Query</kbd> operation selects, groups, or aggregates data in the database and returns rows of data to us</li>
<li>An <kbd>Exec</kbd> operation updates, inserts, or otherwise modifies the state of the database without an expectation that portions of the data stored in the database should be returned</li>
</ul>
<p>As you might expect, to get data out of our database, we will use a <kbd>Query</kbd> operation. To do this, we need to query the database with an SQL statement string. For example, imagine we have a database storing a bunch of iris flower measurements (petal length, petal width, and so on), we could query some of that data related to a particular iris species as follows:</p>
<pre>// Query the database.<br/>rows, err := db.Query(`<br/>    SELECT <br/>        sepal_length as sLength, <br/>        sepal_width as sWidth, <br/>        petal_length as pLength, <br/>        petal_width as pWidth <br/>    FROM iris<br/>    WHERE species = $1`, "Iris-setosa")<br/>if err != nil {<br/>    log.Fatal(err)<br/>}<br/>defer rows.Close()</pre>
<p>Note that this returns a pointer to an <kbd>sql.Rows</kbd> value, and we need to defer the closing of this rows value. Then we can loop over our rows and parse the data into values of expected type. We utilize the <kbd>Scan</kbd> method on rows to parse out the columns returned by the SQL query and print them to standard out:</p>
<pre>// Iterate over the rows, sending the results to<br/>// standard out.<br/>for rows.Next() {<br/> <br/>    var (<br/>        sLength float64<br/>        sWidth float64<br/>        pLength float64<br/>        pWidth float64<br/>    )<br/> <br/>    if err := rows.Scan(&amp;sLength, &amp;sWidth, &amp;pLength, &amp;pWidth); err != nil {<br/>        log.Fatal(err)<br/>    }<br/> <br/>    fmt.Printf("%.2f, %.2f, %.2f, %.2f\n", sLength, sWidth, pLength, pWidth)<br/>}</pre>
<p>Finally, we need to check for any errors that might have occurred while processing our rows. We want to maintain the integrity of our data handling, and we cannot assume that we looped over all the rows without encountering an error:</p>
<pre>// Check for errors after we are done iterating over rows.<br/>if err := rows.Err(); err != nil {<br/>    log.Fatal(err)<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifying the database</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, there is another flavor of interaction with the database called <kbd>Exec</kbd>. With these types of statements, we are concerned with updating, adding to, or otherwise modifying the state of one or more tables in the database. We use the same type of database connection, but instead of calling <kbd>db.Query</kbd>, we will call <kbd>db.Exec</kbd>.</p>
<p>For example, let's say we want to update some of the values in our iris database table:</p>
<pre>// Update some values.<br/>res, err := db.Exec("UPDATE iris SET species = 'setosa' WHERE species = 'Iris-setosa'")<br/>if err != nil {<br/>    log.Fatal(err)<br/>}</pre>
<p>But how do we know whether we were successful and changed something? Well, the <kbd>res</kbd> function returned here allows us to see how many rows of our table were affected by our update:</p>
<pre>// See how many rows where updated.<br/>rowCount, err := res.RowsAffected()<br/>if err != nil {<br/>    log.Fatal(err)<br/>}<br/><br/>// Output the number of rows to standard out.<br/>log.Printf("affected = %d\n", rowCount)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Caching</h1>
                </header>
            
            <article>
                
<p>Sometimes, our machine learning algorithms will be trained by and/or given input for prediction via data from external sources (for example, APIs), that is, data that isn't local to the application running our modeling or analysis. Further, we might have various sets of data that are being accessed frequently, may be accessed again soon, or may need to be made available while the application is running.</p>
<p>In at least some of these cases, it might make sense to cache data in memory or embed the data locally where the application is running. For example, if you are reaching out to a government API (typically having high latency) for census data frequently, you may consider maintaining a local or in-memory cache of the census data being used so that you can avoid constantly reaching out to the API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Caching data in memory</h1>
                </header>
            
            <article>
                
<p>To cache a series of values in memory, we will use <kbd>github.com/patrickmn/go-cache</kbd>. With this package, we can create an in-memory cache of keys and corresponding values. We can even specify things, such as the time to live, in the cache for specific key-value pairs.</p>
<p>To create a new in-memory cache and set a key-value pair in the cache, we do the following:</p>
<pre>// Create a cache with a default expiration time of 5 minutes, and which<br/>// purges expired items every 30 seconds<br/>c := cache.New(5*time.Minute, 30*time.Second)<br/><br/>// Put a key and value into the cache.<br/>c.Set("mykey", "myvalue", cache.DefaultExpiration)</pre>
<p>To then retrieve the value for <kbd>mykey</kbd> out of the cache, we just need to use the <kbd>Get</kbd> method:</p>
<pre>v, found := c.Get("mykey")<br/>if found {<br/>    fmt.Printf("key: mykey, value: %s\n", v)<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Caching data locally on disk</h1>
                </header>
            
            <article>
                
<p>The caching we just saw is in memory. That is, the cached data exists and is accessible while your application is running, but as soon as your application exits, your data disappears. In some cases, you may want your cached data to stick around when your application restarts or exits. You may also want to back up your cache such that you don't have to start applications from scratch without a cache of relevant data.</p>
<p>In these scenarios, you may consider using a local, embedded cache, such as <kbd>github.com/boltdb/bolt</kbd>. BoltDB, as it is referred to, is a very popular project for these sorts of applications, and basically consists of a local key-value store. To initialize one of these local key-value stores, do the following:</p>
<pre>// Open an embedded.db data file in your current directory.<br/>// It will be created if it doesn't exist.<br/>db, err := bolt.Open("embedded.db", 0600, nil)<br/>if err != nil {<br/>    log.Fatal(err)<br/>}<br/>defer db.Close()<br/><br/>// Create a "bucket" in the boltdb file for our data.<br/>if err := db.Update(func(tx *bolt.Tx) error {<br/>    _, err := tx.CreateBucket([]byte("MyBucket"))<br/>    if err != nil {<br/>        return fmt.Errorf("create bucket: %s", err)<br/>    }<br/>    return nil<br/>}); err != nil {<br/>    log.Fatal(err)<br/>}</pre>
<p>You can, of course, have multiple different buckets of data in your BoltDB and use a filename other than <kbd>embedded.db</kbd>.</p>
<p>Next, let's say you had a map of string values in memory that you need to cache in BoltDB. To do this, you would range over the keys and values in the map, updating your BoltDB:</p>
<pre>// Put the map keys and values into the BoltDB file.<br/>if err := db.Update(func(tx *bolt.Tx) error {<br/>    b := tx.Bucket([]byte("MyBucket"))<br/>    err := b.Put([]byte("mykey"), []byte("myvalue"))<br/>    return err<br/>}); err != nil {<br/>    log.Fatal(err)<br/>}</pre>
<p>Then, to get values out of BoltDB, you can view your data:</p>
<pre>// Output the keys and values in the embedded<br/>// BoltDB file to standard out.<br/>if err := db.View(func(tx *bolt.Tx) error {<br/>    b := tx.Bucket([]byte("MyBucket"))<br/>    c := b.Cursor()<br/>    for k, v := c.First(); k != nil; k, v = c.Next() {<br/>        fmt.Printf("key: %s, value: %s\n", k, v)<br/>    }<br/>    return nil<br/>}); err != nil {<br/>    log.Fatal(err)<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data versioning</h1>
                </header>
            
            <article>
                
<p>As mentioned, machine learning models produce extremely different results depending on the training data you use, the choices of parameters, and the input data. It is essential to be able to reproduce results for collaborative, creative, and compliance reasons:</p>
<ul>
<li><strong>Collaboration</strong>: Despite what you see on social media, there are no data science and machine learning unicorns (that is, people with knowledge and capabilities in every area of data science and machine learning). We need to have our colleagues' reviews and improve on our work, and this is impossible if they aren't able to reproduce our model results and analyses.</li>
<li><strong>Creativity</strong>: I don't know about you, but I have trouble remembering even what I did yesterday. We can't trust ourselves to always remember our reasoning and logic, especially when we are dealing with machine learning workflows. We need to track exactly what data we are using, what results we created, and how we created them. This is the only way we will be able to continually improve our models and techniques.</li>
<li><strong>Compliance</strong>: Finally, we may not have a choice regarding data versioning and reproducibility in machine learning very soon. Laws are being passed around the world (for example, the <strong>General Data Protection Regulation</strong> (<strong>GDPR</strong>) in the European Union) that give users a right to an explanation for algorithmically made decisions. We simply cannot hope to comply with these rulings if we don't have a robust way of tracking what data we are processing and what results we are producing.</li>
</ul>
<p>There are multiple open source data versioning projects. Some of these are focused on security and peer-to-peer distributed storage of data. Others are focused on data science workflows. In this book, we will focus on and utilize Pachyderm (<a href="http://pachyderm.io/" target="_blank">http://pachyderm.io/</a>), an open source framework for data versioning and data pipelining. Some of the reasons for this will be clear later in the book when we talk about production deploys and managing ML pipelines. For now, I will just summarize some of the features of Pachyderm that make it an attractive choice for data versioning in Go-based (and other) ML projects:</p>
<ul>
<li>It has an convenient Go client, <kbd>github.com/pachyderm/pachyderm/src/client</kbd></li>
<li>The ability to version any type and format of data</li>
<li>A flexible object store backing for the versioned data</li>
<li>Integration with a data pipelining system for driving versioned ML workflows</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pachyderm jargon</h1>
                </header>
            
            <article>
                
<p>Think about versioning data in Pachyderm kind of like versioning code in Git. The primitives are similar:</p>
<ul>
<li><strong>Repositories</strong>: These are versioned collections of data, similar to having versioned collections of code in Git repositories</li>
<li><strong>Commits</strong>: Data is versioned in Pachyderm by making commits of that data into data repositories</li>
<li><strong>Branches</strong>: These lightweight points to certain commits or sets of commits (for example, master points to the latest HEAD commit)</li>
<li><strong>Files</strong>: Data is versioned at the file level in Pachyderm, and Pachyderm automatically employs strategies, such as de-duplication, to keep your versioned data space efficient</li>
</ul>
<div class="packt_infobox">Even though versioning data with Pachyderm feels similar to versioning code with Git, there are some major differences. For example, merging data doesn't exactly make sense. If there are merge conflicts on petabytes of data, no human could resolve these. Furthermore, the Git protocol would not be space efficient in general for large sets of data. Pachyderm uses its own internal logic to perform the versioning and work with versioned data, and the logic is both space efficient and processing efficient in terms of caching.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying/installing Pachyderm</h1>
                </header>
            
            <article>
                
<p>We will be using Pachyderm in various other places in the book to both version data and create distributed ML workflows. Pachyderm itself is an app that runs on top of Kubernetes (<a href="https://kubernetes.io/" target="_blank">https://kubernetes.io/</a>), and is backed by an object store of your choice. For the purposes of this book, development, and experimentation, you can easily install and run Pachyderm locally. It should take 5-10 minutes to install and doesn't require much effort. The instructions for the local installation can be found in the Pachyderm documentation at <a href="http://docs.pachyderm.io" target="_blank">http://docs.pachyderm.io</a>.</p>
<p>When you are ready to run your workflows in production or your deploy model, you can easily deploy a production-ready Pachyderm cluster that will behave the same exact way as your local installation. Pachyderm can be deployed to any cloud, or even on premises.</p>
<p>As mentioned, Pachyderm is an open source project and has an active group of users. If you have questions or need help, you can join the public Pachyderm Slack channel by visiting <a href="http://slack.pachyderm.io/" target="_blank">http://slack.pachyderm.io/</a>. The active Pachyderm users and the Pachyderm team itself will be able to respond very quickly to your questions there.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating data repositories for data versioning</h1>
                </header>
            
            <article>
                
<p>If you followed the local installation of Pachyderm specified in the Pachyderm documentation, you should have the following:</p>
<ul>
<li>Kubernetes running in a Minikube VM on your machine</li>
<li>The <kbd>pachctl</kbd> command line tool installed and connected to your Pachyderm cluster</li>
</ul>
<p>Of course, if you have a production cluster running in a cloud, the following steps still apply. Your <kbd>pachctl</kbd> would just be connected to the remote cluster.</p>
<div class="packt_infobox">We will be demonstrating data versioning functionality with the <kbd>pachctl</kbd> <strong>Command-line Interface</strong> (<strong>CLI</strong>) tool below (which is a Go program). However, as mentioned above, Pachyderm has a full-fledged Go client. You can create repositories, commit data, and much more directly from your Go programs. This functionality will be demonstrated later in Chapter 9, <em>Deploying and distributing Analyses and Models</em>.</div>
<p>To create a repository of data called <kbd>myrepo</kbd>, you can run this code:</p>
<pre><strong>$ pachctl create-repo myrepo</strong></pre>
<p>You can then confirm that the repository exists with <kbd>list-repo</kbd>:</p>
<pre><strong>$ pachctl list-repo</strong><br/><strong>NAME CREATED SIZE </strong><br/><strong>myrepo 2 seconds ago 0 B</strong></pre>
<p>This <kbd>myrepo</kbd> repository is a collection of data that we have defined and is ready for housing-versioned data. Right now, there is no data in the repository, because we haven't put any data there yet.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Putting data into data repositories</h1>
                </header>
            
            <article>
                
<p>Let's say that we have a simple text file:</p>
<pre><strong>$ cat blah.txt </strong><br/><strong>This is an example file.</strong></pre>
<p>If this file is part of the data we are utilizing in our ML workflow, we should version it. To version this file in our repository, <kbd>myrepo</kbd>, we just need to commit it into that repository:</p>
<pre><strong>$ pachctl put-file myrepo master -c -f blah.txt</strong> </pre>
<p>The <kbd>-c</kbd> flag specifies that we want Pachyderm to open a new commit, insert the file we are referencing, and close the commit all in one shot. The <kbd>-f</kbd> flag specifies that we are providing a file.</p>
<p>Note that we are committing a single file to the master branch of a single repository here. However, the Pachyderm API is incredibly flexible. We can commit, delete, or otherwise modify many versioned files in a single commit or over multiple commits. Further, these files could be versioned via a URL, object store link, database dump, and so on.</p>
<p>As a sanity check, we can confirm that our file was versioned in the repository:</p>
<pre><strong>$ pachctl list-repo</strong><br/><strong>NAME CREATED SIZE </strong><br/><strong>myrepo 10 minutes ago 25 B </strong><br/><strong>$ pachctl list-file myrepo master</strong><br/><strong>NAME TYPE SIZE </strong><br/><strong>blah.txt file 25 B</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting data out of versioned data repositories</h1>
                </header>
            
            <article>
                
<p>Now that we have versioned data in Pachyderm, we probably want to know how to interact with that data. The primary way is via Pachyderm data pipelines (which will be discussed later in this book). The mechanism for interacting with versioned data when using pipelines is a simple file I/O.</p>
<p>However, if we manually want to pull certain sets of versioned data out of Pachyderm, analyze them interactively, then we can use the <kbd>pachctl</kbd> CLI to get data:</p>
<pre><strong>$ pachctl get-file myrepo master blah.txt</strong><br/><strong>This is an example file.</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">References</h1>
                </header>
            
            <article>
                
<p>CSV data:</p>
<ul>
<li><kbd>encoding/csv</kbd> docs: <a href="https://golang.org/pkg/encoding/csv/">https://golang.org/pkg/encoding/csv/</a></li>
<li><kbd>github.com/kniren/gota/dataframe</kbd> docs: <a href="https://godoc.org/github.com/kniren/gota/dataframe">https://godoc.org/github.com/kniren/gota/dataframe</a></li>
</ul>
<p>JSON data:</p>
<ul>
<li><kbd>encoding/json</kbd> <span>docs: <a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a></span></li>
<li>Bill Kennedy's blog post of JSON decoding: <a href="https://www.goinggo.net/2014/01/decode-json-documents-in-go.html">https://www.goinggo.net/2014/01/decode-json-documents-in-go.html</a></li>
<li>Ben Johnson's blog post Go Walkthrough: <kbd>encoding/json</kbd> package: <a href="https://medium.com/go-walkthrough/go-walkthrough-encoding-json-package-9681d1d37a8f">https://medium.com/go-walkthrough/go-walkthrough-encoding-json-package-9681d1d37a8f</a></li>
</ul>
<p>Caching:</p>
<ul>
<li><kbd>github.com/patrickmn/go-cache</kbd> docs: <a href="https://godoc.org/github.com/patrickmn/go-cache">https://godoc.org/github.com/patrickmn/go-cache</a></li>
<li><kbd>github.com/boltdb/bolt</kbd> docs: <a href="https://godoc.org/github.com/boltdb/bolt">https://godoc.org/github.com/boltdb/bolt</a></li>
<li>Information about and motivation for BoltDB: <a href="https://npf.io/2014/07/intro-to-boltdb-painless-performant-persistence/">https://npf.io/2014/07/intro-to-boltdb-painless-performant-persistence/</a></li>
</ul>
<p>Pachyderm:</p>
<ul>
<li>General documentation: <a href="http://docs.pachyderm.io">http://docs.pachyderm.io</a></li>
<li>Go client docs: <a href="https://godoc.org/github.com/pachyderm/pachyderm/src/client">https://godoc.org/github.com/pachyderm/pachyderm/src/client</a></li>
<li>Public users Slack team registration: <a href="http://docs.pachyderm.io">http://docs.pachyderm.io</a></li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span>In this chapter, you learned how to gather, organize, and parse data. This is the first step, and one of the most important step, in developing machine learning models, but having data does not get us very far if we do not gain some intuition about our data and put it into a standard form for processing. Next, we will tackle some techniques for further structuring our data (matrices) and for understanding our data (statistics and probability).</span></p>


            </article>

            
        </section>
    </body></html>