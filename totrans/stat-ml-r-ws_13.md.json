["```py\n\n    # The probability of success\n    p = 0.6\n    # Produce a random Bernoulli outcome\n    outcome = rbinom(1, size = 1, prob = p)\n    >>> print(outcome)\n    0\n    ```", "```py\n    set.seed(8)\n    >>> rbinom(1, size = 1, prob = p)\n    1\n    ```", "```py\n\n    # Number of experiments\n    n = 5\n    # Generate corresponding outcomes\n    outcomes = rbinom(n, size = 1, prob = p)\n    >>> print(outcomes)\n    1 0 0 1 0\n    ```", "```py\n\n    # Get mean and variance\n    mean_bernoulli = p\n    var_bernoulli = p * (1 - p)\n    >>> cat(\"Mean:\", mean_bernoulli, \"\\nVariance:\", var_bernoulli)\n    Mean: 0.6\n    Variance: 0.24\n    ```", "```py\n\n    # Number of successes\n    num_successes = sum(outcomes)\n    # Empirical probability of success\n    empirical_p = num_successes / n\n    >>> cat(\"Number of successes:\", num_successes, \"\\nEmpirical probability of success:\", empirical_p)\n    Number of successes: 2\n    Empirical probability of success: 0.4\n    ```", "```py\n    n = 1000\n    num_successes = sum(rbinom(n, size = 1, prob = p))\n    empirical_p = num_successes / n\n    >>> cat(\"Number of successes:\", num_successes, \"\\nEmpirical probability of success:\", empirical_p)\n    Number of successes: 600\n    Empirical probability of success: 0.6\n    ```", "```py\n\n    n = 10 # Number of trials\n    p = 0.5 # Probability of success\n    # Get binomial probabilities for different occurrences of successes\n    binom_probs = dbinom(0:n, n, p)\n    >>> binom_probs\n    [1] 0.0009765625 0.0097656250 0.0439453125 0.1171875000\n     [5] 0.2050781250 0.2460937500 0.2050781250 0.1171875000\n     [9] 0.0439453125 0.0097656250 0.0009765625\n    ```", "```py\n\n    >>> barplot(binom_probs, names.arg = 0:n, xlab = \"Number of Successes\", ylab = \"Probability\", main = \"Binomial Distribution (n = 10, p = 0.5)\")\n    ```", "```py\n\n    cum_binom_probs <- pbinom(0:n, n, p)\n    >>> cum_binom_probs\n    [1] 0.0009765625 0.0107421875 0.0546875000 0.1718750000\n     [5] 0.3769531250 0.6230468750 0.8281250000 0.9453125000\n     [9] 0.9892578125 0.9990234375 1.0000000000\n    ```", "```py\n\n    prob_at_least_7_successes = 1 - pbinom(6, n, p)\n    >>> prob_at_least_7_successes\n    0.171875\n    ```", "```py\n\n    n = 5\n    p = 0.8\n    prob_at_least_4_wins = 1 - pbinom(3, n, p)\n    >>> prob_at_least_4_wins\n    0.73728\n    ```", "```py\n\n    prob_at_most_3_wins = pbinom(3, n, p)\n    >>> prob_at_most_3_wins\n    0.26272\n    ```", "```py\n    >>> prob_at_most_3_wins == 1 – prob_at_least_4_wins\n    TRUE\n    ```", "```py\n\nn = 100\np = 0.5\n# check conditions for normal approximation\n>>> n*p > 10\nTRUE\n>>> n*p*(1-p) > 10\nTRUE\n```", "```py\n\n# compute mean and std\nmu = n*p\n>>> mu\n50\nstd = sqrt(n*p*(1-p))\n>>> std\n5\n# compute P(lower_limit <= X <= upper_limit)\nlower_limit = 40\nupper_limit = 60\n# Using z score\nstandard_lower_limit = (lower_limit – mu) / std\nstandard_upper_limit = (upper_limit – mu) / std\n>>> standard_lower_limit\n-2\n>>> standard_upper_limit\n2\n```", "```py\n\n# approximate using standard normal cdf\n>>> pnorm(standard_upper_limit) - pnorm(standard_lower_limit)\n0.9544997\n```", "```py\n\n# use binomial distribution\n>>> pbinom(upper_limit, n, p) - pbinom(lower_limit, n, p)\n0.9539559\n```", "```py\n\n    lambda = 5 # distribution parameter\n    # Calculate probabilities for each scenario\n    pois_probs = dpois(0:15, lambda)\n    >>> pois_probs\n    [1] 0.0067379470 0.0336897350 0.0842243375 0.1403738958\n     [5] 0.1754673698 0.1754673698 0.1462228081 0.1044448630\n     [9] 0.0652780393 0.0362655774 0.0181327887 0.0082421767\n    [13] 0.0034342403 0.0013208616 0.0004717363 0.0001572454\n    ```", "```py\n\n    >>> barplot(pois_probs, names.arg = 0:15, xlab = \"Number of Events\", ylab = \"Probability\", main = \"Poisson Distribution (lambda = 5)\")\n    ```", "```py\n\n    cum_pois_probs = ppois(0:15, lambda)\n    >>> cum_pois_probs\n    [1] 0.006737947 0.040427682 0.124652019 0.265025915\n     [5] 0.440493285 0.615960655 0.762183463 0.866628326\n     [9] 0.931906365 0.968171943 0.986304731 0.994546908\n    [13] 0.997981148 0.999302010 0.999773746 0.999930992\n    >>> barplot(cum_pois_probs, names.arg = 0:15, xlab = \"Number of Events\", ylab = \"Cumulative Probability\", main = \"CDF of Poisson Distribution (lambda = 5)\")\n    ```", "```py\n\n    pois_samples = rpois(100, lambda)\n    >>> pois_samples\n      [1]  8  5  8  4  3  4  6  2  5  6  3  3  7  8  8  7\n     [17]  5  9  6  1  4  2  7  7  5  5  5  2  7  4  6  5\n     [33]  4  4  3  0  8  5  4  4  7  5 11  6  5  4  8  8\n     [49]  2  5  6  2  3  4  6  4  6  2  5  3  6  0  5  8\n     [65]  7  1  8  4  4  4  4  5  4  4  4  5  5  6  3  4\n     [81]  3  0  8  9  2  3  4 13  2  6  8  9  6  4  7  7\n     [97]  8  6  3  5\n    ```", "```py\n\n# Binomial parameters\nn = 1000\np = 0.01\n# Probability of observing 15 successes\nbinom_prob = dbinom(15, n, p)\n>>> binom_prob\n0.03454173\n```", "```py\n\nlambda_approx = n * p\n>>> lambda_approx\n10\n```", "```py\n\npois_approx_prob <- dpois(15, lambda_approx)\n>>> pois_approx_prob\n0.03471807\n```", "```py\n\n    # Parameters\n    p = 0.25 # Probability of success\n    # Get geometric probabilities\n    geom_probs = dgeom(0:9, p)\n    >>> geom_probs\n    [1] 0.25000000 0.18750000 0.14062500 0.10546875 0.07910156 0.05932617\n     [7] 0.04449463 0.03337097 0.02502823 0.01877117\n    ```", "```py\n\n    >>> barplot(geom_probs, names.arg = 1:10, xlab = \"Number of Trials\", ylab = \"Probability\", main = \"Geometric Distribution (p = 0.25)\")\n    ```", "```py\n\n    cum_geom_probs = pgeom(0:9, p)\n    >>> cum_geom_probs\n    [1] 0.2500000 0.4375000 0.5781250 0.6835938 0.7626953\n     [6] 0.8220215 0.8665161 0.8998871 0.9249153 0.9436865\n    ```", "```py\n\n    geom_samples = rgeom(100, p)\n    >>> geom_samples\n      [1]  0  0  0  2 10  1  1 10  0  0  1  1  5  3  1  0  2  0  0\n     [20]  4  0  1  4  2  3  2  2  2  4  1  6 12  4  1  7  3  1  1\n     [39]  0  2  1  2  3  0  8  0  0  2 10  3  2  8  0  3  1  2  3\n     [58]  0  0  1  7  0  0  3  4 11  8  8  2  0  5  1  1  1  3  1\n     [77]  3  1  3  3  6  0  0  7  1  0  0  1  0  1  0  0  0  3  0\n     [96]  0  4 25  0  3\n    ```", "```py\n\n    p = 0.1 # Probability of finding a bug on each attempt\n    # Calculate the CDF for up to 5 attempts\n    prob_within_5_attempts = pgeom(4, p)\n    >>> prob_within_5_attempts\n    0.40951\n    ```", "```py\n    >>> sum(dgeom(0:4, p))\n    0.40951\n    ```", "```py\n\n    mean_attempts <- 1 / p\n    >>> mean_attempts\n    10\n    ```", "```py\n\n    geom_probs <- dgeom(0:19, p)\n    # Create a bar plot of probabilities\n    barplot(geom_probs, names.arg = 1:20, xlab = \"Number of Attempts\", ylab = \"Probability\", main = \"Geometric Distribution (p = 0.1)\")\n    ```", "```py\n\n    # Parameters\n    mu = 0      # Mean\n    sigma = 1   # Standard deviation\n    # Get the probability density for different x\n    x = seq(-4, 4, by = 0.1)\n    normal_density = dnorm(x, mu, sigma)\n    ```", "```py\n\n    # Plot the normal distribution\n    >>> plot(x, normal_density, type = \"l\", xlab = \"x\", ylab = \"Probability Density\", main = \"Normal Distribution (μ = 0, σ = 1)\")\n    ```", "```py\n\n    # Get cumulative probabilities for different x\n    normal_cum_prob <- pnorm(x, mu, sigma)\n    >>> plot(x, normal_cum_prob, type = \"l\", xlab = \"x\", ylab = \"Cumulative Probability Density\", main = \"Cumulative Normal Distribution (μ = 0, σ = 1)\")\n    ```", "```py\n\n    # Generate 100 random samples from a normal distribution with μ = 0 and σ = 1\n    normal_samples <- rnorm(100, mu, sigma)\n    ```", "```py\n\n    # Find the quantile corresponding to the 90th percentile\n    quantile_90 <- qnorm(0.9, mu, sigma)\n    >>> quantile_90\n    1.281552\n    ```", "```py\n\n    set.seed(8)\n    mean_lifespan = 100\n    sd_lifespan = 10\n    n = 1000\n    lifespans = rnorm(n, mean_lifespan, sd_lifespan)\n    ```", "```py\n\n    threshold = 120\n    probability = 1 - pnorm(threshold, mean_lifespan, sd_lifespan)\n    >>> probability\n    0.02275013\n    ```", "```py\n\n    df <- data.frame(lifespan = lifespans)\n    df_density <- density(lifespans)\n    df_shaded <- data.frame(x = df_density$x, y = df_density$y)\n    df_shaded <- df_shaded[df_shaded$x > threshold,]\n    ggplot(df, aes(x=lifespan)) +\n      geom_density(fill=\"lightblue\") +\n      geom_vline(xintercept = threshold, linetype=\"dashed\", color=\"red\") +\n      geom_area(data = df_shaded, aes(x=x, y=y), fill=\"orange\", alpha=0.5) +\n      theme_minimal() +\n      labs(title=\"Lifespan of batteries\", x=\"Lifespan (hours)\", y=\"Probability Density\")\n    ```", "```py\n\n    set.seed(8) # Set seed for reproducibility\n    lambda = 0.01\n    sample_size = 1000\n    exponential_sample = rexp(sample_size, rate = lambda)\n    ```", "```py\n\n    threshold = 150\n    probability_above_threshold = 1 - pexp(threshold, rate = lambda)\n    >>> probability_above_threshold\n    0.2231302\n    ```", "```py\n\n    # Create a data frame for the waiting times\n    waiting_times = seq(0, max(exponential_sample), length.out = 1000)\n    density_values = dexp(waiting_times, rate = lambda)\n    df = data.frame(waiting_times, density_values)\n    # Filter data for the shaded region\n    df_shaded = df[df$waiting_times > threshold,]\n    # Plot the PDF of the exponential distribution\n    ggplot(df, aes(x = waiting_times, y = density_values)) +\n      geom_line() +\n      geom_area(data = df_shaded, aes(x = waiting_times, y = density_values), fill = \"orange\", alpha = 0.5) +\n      geom_vline(xintercept = threshold, linetype = \"dashed\", color = \"red\") +\n      theme_minimal() +\n      labs(title = \"Exponential Distribution ( = 0.01)\", x = \"Waiting Time\", y = \"Probability Density\")\n    ```", "```py\n\n    set.seed(8) # Set seed for reproducibility\n    a = 2\n    b = 10\n    sample_size = 10000\n    uniform_sample = runif(sample_size, min = a, max = b)\n    ```", "```py\n\n    threshold = 7\n    probability = 1 - punif(threshold, min = a, max = b)\n    >>> probability\n    0.375\n    ```", "```py\n    probability2 = sum(uniform_sample > t\n    hreshold) / length(uniform_sample)\n    >>> probability2\n    0.3771\n    ```", "```py\n\n    library(ggplot2)\n    # Create a data frame for the distribution\n    x_values = seq(a, b, length.out = 1000)\n    density_values = dunif(x_values, min = a, max = b)\n    df = data.frame(x_values, density_values)\n    # Plot the PDF of the uniform distribution\n    ggplot(df, aes(x = x_values, y = density_values)) +\n      geom_line() +\n      theme_minimal() +\n      labs(title = \"Uniform Distribution (a = 2, b = 10)\", x = \"Value\", y = \"Probability Density\")\n    ```", "```py\n\nset.seed(8) # Set seed for reproducibility\n# Define the target normal distribution parameters\nmu = 5\nsigma = 2\n# Generate uniform random variables\nn = 5\nuniform_sample = runif(n)\n# Calculate the corresponding quantiles for the uniform sample using the inverse CDF (quantile function) of the normal distribution\nnormal_sample = qnorm(uniform_sample, mean = mu, sd = sigma)\n>>> normal_sample\n[1] 4.830828 3.372006 6.680800 5.780755 4.073034\n```", "```py\n\nnormal_sample2 = qnorm(uniform_sample, mean = 0, sd = 1)\n>>> normal_sample2 * sigma + mu\n[1] 4.830828 3.372006 6.680800 5.780755 4.073034\n```", "```py\n\n    set.seed(8) # Set seed for reproducibility\n    # Define the population parameters\n    population_mean = 50\n    population_sd = 10\n    population_size = 100000\n    # Generate the population using a normal distribution\n    population <- rnorm(population_size, mean = population_mean, sd = population_sd)\n    >>> summary(population)\n       Min. 1st Qu.  Median    Mean 3rd Qu.    Max.\n      7.597  43.261  50.051  50.027  56.781  89.365\n    ```", "```py\n\n    # Define the sample size in each round\n    sample_size_per_round = 50\n    # Function to draw a sample and calculate its mean\n    get_sample_mean <- function(population, sample_size_per_round) {\n      sample <- sample(population, size = sample_size_per_round, replace = FALSE)\n      return(mean(sample))\n    }\n    ```", "```py\n    >>> get_sample_mean(population, sample_size_per_round)\n    50.30953\n    >>> get_sample_mean(population, sample_size_per_round)\n    48.9098\n    ```", "```py\n\n    # Generate multiple rounds of sample means\n    num_rounds = 1000 # the number of rounds to sample\n    sample_means = replicate(num_rounds, get_sample_mean(population, sample_size))\n    >>> summary(sample_means)\n       Min. 1st Qu.  Median    Mean 3rd Qu.    Max.\n      49.76   49.96   50.02   50.03   50.09   50.34\n    ```", "```py\n\n    library(ggplot2)\n    sampling_distribution_df = data.frame(sample_means)\n    ggplot(sampling_distribution_df, aes(x = sample_means)) +\n      geom_histogram(aes(y = after_stat(density)), bins = 30, color = \"black\", fill = \"lightblue\") +\n      geom_density(color = \"red\", lwd = 1.2) +\n      theme_minimal() +\n      labs(title = \"Sampling Distribution of the Sample Mean\",\n           x = \"Sample Mean\",\n           y = \"Density\")\n    ```", "```py\n\n    sample_size = 10\n    mu = 50\n    sigma = 10\n    samples = rnorm(sample_size, mean = mu, sd = sigma)\n    >>> samples\n    [1] 41.57424 39.61629 59.86689 58.94655 43.43934 28.41854 67.05759 50.36661 51.61680 37.71842\n    ```", "```py\n\n    sample_mean = mean(samples)\n    sample_sd = sd(samples)\n    >>> sample_mean\n    47.86213\n    >>> sample_sd\n    11.85024\n    ```", "```py\n\n    alpha = 0.05\n    t_critical = qt(1 - alpha/2, df = sample_size - 1)  # t-value for a two-tailed test with alpha = 0.05 and df = n - 1\n    margin_of_error_t = t_critical * (sample_sd / sqrt(sample_size))\n    ci_t = c(sample_mean - margin_of_error_t, sample_mean + margin_of_error_t)\n    >>> ci_t\n    39.38497 56.33928\n    ```", "```py\n\n    set.seed(8)\n    samples = rnorm(10, mean = 50, sd = 10)\n    >>> samples\n    [1] 49.15414 58.40400 45.36517 44.49165 57.36040 48.92119 48.29711 39.11668 19.88948 44.06826\n    ```", "```py\n\n    sorted_samples = sort(samples)\n    >>> sorted_samples\n    [1] 19.88948 39.11668 44.06826 44.49165 45.36517 48.29711 48.92119 49.15414 57.36040 58.40400\n    ```", "```py\n    >>> sort(samples, decreasing = T)\n    [1] 58.40400 57.36040 49.15414 48.92119 48.29711 45.36517 44.49165 44.06826 39.11668 19.88948\n    ```", "```py\n\n    min_value = sorted_samples[1]\n    >>> min_value\n    19.88948\n    ```", "```py\n\n    max_value = sorted_samples[length(sorted_samples)]\n    >>> max_value\n    58.404\n    ```", "```py\n\n    k = 3\n    kth_order_stat = sorted_samples[k]\n    >>> kth_order_stat\n    44.06826\n    ```", "```py\n\n    median_value = median(samples)\n    >>> median_value\n    46.83114\n    ```", "```py\n    >>> median(sorted_samples)\n    46.83114\n    ```", "```py\n\n    quartiles = quantile(samples, probs = c(0.25, 0.75))\n    >>> quartiles\n        25%     75%\n    44.1741 49.0959\n    ```", "```py\n    >>> quantile(sorted_samples, probs = c(0.25, 0.75))\n        25%     75%\n    44.1741 49.0959\n    ```", "```py\n\n    # Set a seed for reproducibility\n    set.seed(8)\n    # Generate a random sample of daily returns from a normal distribution\n    sample_size = 252  # Number of trading days in a year\n    mu = 0.08          # Mean daily return\n    sigma = 0.05       # Standard deviation of daily returns\n    daily_returns = rnorm(sample_size, mean = mu, sd = sigma)\n    ```", "```py\n    >>> summary(daily_returns)\n        Min.  1st Qu.   Median     Mean  3rd Qu.     Max.\n    -0.07073  0.04480  0.07926  0.07799  0.11424  0.20195\n    ```", "```py\n\n    confidence_level = 0.95\n    portfolio_value = 1000000  # Portfolio value in USD\n    sorted_returns = sort(daily_returns)\n    VaR_index = ceiling(sample_size * (1 - confidence_level))\n    VaR = sorted_returns[VaR_index]\n    VaR_amount = portfolio_value * (1 - (1 + VaR))\n    >>> VaR\n    -0.006301223\n    >>> VaR_amount\n    6301.223\n    ```", "```py\n\n    library(dplyr)\n    daily_returns_df <- data.frame(DailyReturns = daily_returns)\n    # Create the density plot\n    density_plot <- ggplot(daily_returns_df, aes(x = DailyReturns)) +\n      geom_density(fill = \"blue\", alpha = 0.5) +\n      geom_vline(aes(xintercept = VaR), linetype = \"dashed\", color = \"red\") +\n      labs(x = \"Daily Returns\", y = \"Density\", title = \"Density Plot of Daily Returns with VaR\") +\n      theme_minimal()\n    # Add shaded area below the VaR to the density plot\n    density_data <- ggplot_build(density_plot)$data[[1]] %>%\n      as.data.frame() %>%\n      filter(x < VaR)\n    density_plot +\n      geom_ribbon(data = density_data, aes(x = x, ymin = 0, ymax = y), fill = \"red\", alpha = 0.5)\n    ```"]