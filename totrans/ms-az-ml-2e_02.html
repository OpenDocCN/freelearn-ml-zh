<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer068">
			<h1 id="_idParaDest-16"><em class="italic"><a id="_idTextAnchor015"/>Chapter 1</em>: Understanding the End-to-End Machine Learning Process</h1>
			<p>Welcome to the second edition of <em class="italic">Mastering Azure Machine Learning</em>. In this first chapter, we want to give you an understanding of what kinds of problems require the use of <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>), how the full ML process unfolds, and what knowledge is required to navigate this vast terrain. You can view it as an introduction to ML and an overview of the book itself, where for most topics we will provide you with a reference to upcoming chapters so that you can easily find your way around the book.</p>
			<p>In the first section, we will ask ourselves what ML is, when we should use it, and where it comes from. In addition, we will reflect on how ML is just another form of programming.</p>
			<p>In the second section, we will lay the mathematical groundwork you require to process data, and we will understand that the data you work with probably cannot be fully trusted. Further, we will look at different classes of ML algorithms, how they are defined, and how we can define the performance of a trained model.</p>
			<p>Finally, in the third section, we will have a look at the end-to-end process of an ML project. We will understand where to get data from, how to preprocess data, how to choose a fitting model, and how to deploy this model into production environments. This will also get us into the topic of <strong class="bold">ML operations</strong>, known as <strong class="bold">MLOps</strong>.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Grasping the idea behind ML</li>
				<li>Understanding the mathematical basis for statistical analysis and ML modeling</li>
				<li>Discovering the end-to-end ML process</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Grasping the idea behind ML</h1>
			<p>The terms <strong class="bold">artificial intelligence</strong> (<strong class="bold">AI</strong>) and—partially—<strong class="bold">ML</strong> are omnipresent in today's world. However, a lot of what is found under the term <em class="italic">AI</em> is often nothing more than a containerized ML solution, and to<a id="_idIndexMarker000"/> make matters worse, ML is sometimes unnecessarily used to solve something extremely simple.</p>
			<p>Therefore, in this first section, let's understand the class of problems ML tries to solve, in which scenarios to use ML, and when not to use it.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Problems and scenarios requiring ML</h2>
			<p>If you look for a definition of ML, you<a id="_idIndexMarker001"/> will often find a description such as this: <em class="italic">It is the study of self-improving machine algorithms using data</em>. ML is basically described as an algorithm we are trying to evolve, which in turn can be seen as one complex mathematical function.</p>
			<p>Any computer process today follows the <a id="_idIndexMarker002"/>simple structure of the <strong class="bold">input-process-output (IPO) model</strong>. We define allowed inputs, we define a process working with those inputs, and we define an output through the type of results the process will show us. A simple example would be a word processing application, where every keystroke will result in a letter shown as the output on the screen. A completely different process might run in parallel to that one, having a time-based trigger to store the text file periodically to a hard disk. </p>
			<p>All these processes or algorithms have one thing in common—they were manually written by someone using a <strong class="bold">high-level programming language</strong>. It is clear which actions need to be done when someone presses a letter in a word processing application. Therefore, we can easily build a process in which we implement which input values should create which output values. </p>
			<p>Now, let's look at a more complex problem. Imagine we have a picture of a dog and want an application to just say: <em class="italic">This is a dog</em>. This sounds simple enough, as we know the input <em class="italic">picture of a dog</em> and the output value <em class="italic">dog</em>. Unfortunately, our brain (our own machine) is far superior to the machines we built, especially when it comes to pattern recognition. For a computer, a picture is just a square of <img src="image/B17928_Formula_1.01.png" alt="" width="97" height="22"/> pixels, each containing three color channels defined by an 8-bit or 10-bit value. Therefore, an image is just a bunch of pixels made up of vectors for the computer, so in essence, a lot of numbers.</p>
			<p>We could manually start writing an algorithm that maybe clusters groups of pixels, looks for edges and points of interest, and eventually, with a lot of effort, we might succeed in having an algorithm that finds dogs in pictures. That is when we get a picture of a cat. </p>
			<p>It should be clear to you by now that we might run into a problem. Therefore, let's define one problem that ML solves, as follows:</p>
			<p><em class="italic">Building the desired algorithm for a required solution programmatically is either extremely time-consuming, completely unfeasible, or impossible.  </em></p>
			<p>Taking this description, we can surely define good scenarios to use ML, be it finding objects in images and<a id="_idIndexMarker003"/> videos or understanding voices and extracting their intent from audio files. We will further understand what building ML solutions entails throughout this chapter (and the rest of the book, for that matter), but to make a simple statement, let's just acknowledge that building an ML model is also a time-consuming matter.</p>
			<p>In that vein, it should be of utmost importance to avoid ML if we have the chance to do so. This might be an obvious statement, but as we (the authors) can attest, it is not for a lot of people. We have seen projects realized with ML where the output could be defined with a simple combination of <strong class="source-inline">if</strong> statements given some input vectors. In such scenarios, a solution could be obtained with a couple of hundred lines of code. Instead, months of training and testing an ML algorithm occurred, costing a lot of time and resources. </p>
			<p>An example of this would be a company wanting to predict fraud (stolen money) committed by their own employees in a retail store. You might have heard that predicting fraud is a typical scenario for ML. Here, it was <em class="italic">not necessary</em> to use ML, as the company already knew the influencing factors (length of time the cashier was open, error codes on return receipts, and so on) and therefore wanted to be alerted when certain combinations of these factors occurred. As they knew the factors already, they could have just written the code and be done with it. But what does this scenario tell us about ML?</p>
			<p>So far, we have looked at ML as a solution to solve a problem that, in essence, is too hard to code. Looking at the preceding scenario, you might understand another aspect or another class of problems that ML can solve. Therefore, let's add a second problem description, as follows:</p>
			<p><em class="italic">Building the desired algorithm for a required solution is not feasible, as the influencing factors for the outcome of the desired outputs are only partially known or completely unknown.</em></p>
			<p>Looking at this problem, you might now understand why ML relies so heavily on the field of statistics as, through the application of statistics, we can learn how data points influence one another, and therefore we might be able to solve such a problem. At the same time, we can build an algorithm that can find and predict the desired outcome. </p>
			<p>In the previously mentioned<a id="_idIndexMarker004"/> scenario for detecting fraud, it might be prudent to still use ML, as it may be able to find a combination of influencing factors no one has thought about. But if this is not your set goal—as it was not in this case—you should not use ML for something that is easily written in code.</p>
			<p>Now that we have discussed some of the problems solved by ML and have had a look at some scenarios for ML, let's have a look at how ML came to be. </p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>The history of ML</h2>
			<p>To understand ML as a whole, we must first <a id="_idIndexMarker005"/>understand where it comes from. Therefore, let's delve into the history of ML. As with all events in history, different currents are happening simultaneously, adding pieces to the whole picture. We'll now look at a few important pillars that birthed the idea of ML as we know it today.</p>
			<h3>Learnings from neuroscience</h3>
			<p>A neuropsychologist named Donald O. Hebb<a id="_idIndexMarker006"/> published a book titled <em class="italic">The Organization of Behavior</em> in 1949. In this book, he described his <a id="_idIndexMarker007"/>theory of how <strong class="bold">neurons</strong> (neural cells) in our brain function, and how they contribute to what we understand as <em class="italic">learning</em>. This theory is known as <strong class="bold">Hebbian learning</strong>, and it makes<a id="_idIndexMarker008"/> the following proposition:</p>
			<p class="author-quote">When an axon of cell A is near enough to excite cell B and repeatedly or persistently takes part in firing it, some growth process or metabolic change takes place in one or both cells such that A's efficiency, as one of the cells firing B, is increased.</p>
			<p>This basically describes that there is a process where one cell excites another repeatedly (the initiating cell) and maybe even the receiving cell is changed through a hidden process. This process is what we call learning.</p>
			<p>To understand this a bit more visually, let's have a look at the biological structure of a neuron, as follows: </p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/B17928_01_01.jpg" alt="Figure 1.1 – Neuron in a biological neural network " width="1650" height="615"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Neuron in a biological neural network</p>
			<p>What is visualized here? Firstly, on the left, we see the main body of the cell and its nucleus. The body receives input signals through dendrites that are connected to other neurons. In addition, there is a larger <a id="_idIndexMarker009"/>exit perturbing from the body called the axon, which connects the main <a id="_idIndexMarker010"/>body through a chain of Schwann cells to the so-called axon terminal, which in turn connects again to other neurons.  </p>
			<p>Looking at this structure with some creativity, it certainly resembles what a function or an algorithm might be. We have input signals coming from external neurons, we have some hidden process happening with these signals, and we have an output in the form of an axon terminal that connects the results to other neurons, and therefore other processes again. </p>
			<p>It would take another decade again for someone to realize this connection.</p>
			<h3>Learnings from computer science</h3>
			<p>It is hard to talk about the history of<a id="_idIndexMarker011"/> ML in the context of computer science without mentioning one of the fathers of modern machines, Alan Turing. In a paper called <em class="italic">Computing Machinery and Intelligence</em> published in 1950, Turing defines <a id="_idIndexMarker012"/>a test called the <strong class="bold">Imitation Game</strong> (later <a id="_idIndexMarker013"/>called the <strong class="bold">Turing test</strong>) to evaluate whether a machine shows human behavior indistinguishable from a human. There are multiple iterations and variants of the test, but in essence, the idea is that a person would at no point in a conversation get the feeling they are not speaking with a human.</p>
			<p>Certainly, this test is flawed, as there are ways to give relatively intelligent answers to questions while not being intelligent at all. If you want to learn more about this, have a look at <strong class="bold">ELIZA</strong> built by Joseph Weizenbaum, which passed the Turing test.</p>
			<p>Nevertheless, this paper triggered one of the first discussions on what AI could be and what it means that a machine can learn.</p>
			<p>Living in these exciting times, Arthur Samuel, a researcher working at <strong class="bold">International Business Machines Corporation</strong> (<strong class="bold">IBM</strong>) at that time, started developing a computer program that could make the right decisions in a game of checkers. In each move, he let the program evaluate a scoring function that tried to measure the chances of winning for each available move. Limited by the available resources at the time, it was not feasible to calculate all possible combinations of moves all the way to the end of the game. </p>
			<p>This first step led to the definition <a id="_idIndexMarker014"/>of the so-called <strong class="bold">minimax algorithm</strong> and its <a id="_idIndexMarker015"/>accompanying <strong class="bold">search tree</strong>, which can commonly be used for any two-player adversarial game. Later, the <strong class="bold">alpha-beta pruning</strong> algorithm was added to automatically trim the tree<a id="_idIndexMarker016"/> from decisions that did not lead to better results than the ones already evaluated.</p>
			<p>We are talking about Arthur Samuel, as it was he who coined the name <em class="italic">machine learning</em>, defining it as follows:</p>
			<p class="author-quote">The field of study that gives computers the ability to learn without being explicitly programmed.</p>
			<p>Combining these first ideas of building an evaluation function for training a machine and the research done by Donald O. Hebb in neuroscience, Frank Rosenblatt, a researcher at the Cornell Aeronautical Laboratory, invented a new<a id="_idIndexMarker017"/> linear classifier that he called a <strong class="bold">perceptron</strong>. Even though his progress in building this perceptron into hardware was relatively short-lived and would not live up to its potential, its original definition is nowadays the <a id="_idIndexMarker018"/>basis for every neuron in an <strong class="bold">artificial neural network</strong> (<strong class="bold">ANN</strong>). </p>
			<p>Therefore, let's now dive <a id="_idIndexMarker019"/>deeper into understanding how ANNs work and what we can deduce about the inner workings of an ML algorithm from them.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Understanding the inner workings of ML through the example of ANNs</h2>
			<p>ANNs, as we know them<a id="_idIndexMarker020"/> today, are defined by the following two major components, one of which we learned about already:</p>
			<ul>
				<li><strong class="bold">The neural network</strong>: The base structure of the system. A <a id="_idIndexMarker021"/>perceptron is basically an NN with only one neuron. By now, this structure comes in multiple facets, often involving hidden layers of hundreds of neurons, in the case of <strong class="bold">deep neural networks</strong> (<strong class="bold">DNNs</strong>). </li>
				<li><strong class="bold">The backpropagation function</strong>: A rule for the <a id="_idIndexMarker022"/>system to learn and evolve. An idea thought of in the 1970s came into appreciation through a paper called <em class="italic">Learning Representations by Back-Propagating Errors</em> by <em class="italic">D. Rumelhart</em>, <em class="italic">Geoffrey E. Hinton</em>, <em class="italic">Ronald J. Williams</em> in 1986.</li>
			</ul>
			<p>To understand these two components and how they work in tandem with each other, let's have a deeper look at both.</p>
			<h3>The neural network </h3>
			<p>First, let's understand how a single <a id="_idIndexMarker023"/>neuron operates, which<a id="_idIndexMarker024"/> is very close to the idea of a perceptron defined by Rosenblatt. The following diagram shows the inner workings of such an artificial neuron:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B17928_01_02.jpg" alt="Figure 1.2 – Neuron in an ANN " width="1650" height="607"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Neuron in an ANN</p>
			<p>We can clearly see the similarities to a real neuron. We get inputs from the connected neurons called <img src="image/B17928_Formula_1.02.png" alt="" width="35" height="32"/>. Each of those inputs is weighted with a corresponding weight <img src="image/B17928_Formula_1.03.png" alt="" width="36" height="28"/>, and then, in the neuron itself, they <a id="_idIndexMarker025"/>are all summed up, including a <strong class="bold">bias</strong> <img src="image/B17928_Formula_1.04.png" alt="" width="21" height="33"/>. This is often<a id="_idIndexMarker026"/> referred to as the <strong class="bold">net input function</strong>. </p>
			<p>As the final <a id="_idIndexMarker027"/>operation, a so-called <strong class="bold">activation function</strong> <img src="image/B17928_Formula_1.05.png" alt="" width="36" height="41"/> is applied to this net input that decides how the output <a id="_idIndexMarker028"/>signal of the neuron should look. This function must be continuous and differentiable and should typically create results in the range of [0:1] or [-1:1] to keep results scaled. In addition, this function could be<a id="_idIndexMarker029"/> linear or non-linear in nature, even though using a linear activation function has its downfalls, as described next:</p>
			<ul>
				<li>You cannot learn a non-linear relationship presented in your data through a system of linear functions.</li>
				<li>A multilayered network made up of nodes with only linear activation functions can be broken down to just one layer of nodes with one linear activation function, making the network obsolete.</li>
				<li>You cannot use a linear activation function with backpropagation, as this requires calculating the derivative of this function, which we will discuss next. </li>
			</ul>
			<p>Commonly used activation<a id="_idIndexMarker030"/> functions are <strong class="bold">sigmoid</strong>, <strong class="bold">hyperbolic tangent</strong> (<strong class="bold">tanh</strong>), <strong class="bold">rectified linear unit</strong> (<strong class="bold">ReLU</strong>), and <strong class="bold">softmax</strong>. Keeping this in mind, let's have<a id="_idIndexMarker031"/> a look at how <a id="_idIndexMarker032"/>we connect neurons together to achieve <a id="_idIndexMarker033"/>an ANN. A whole network is typically defined by three types of layers, as outlined here:</p>
			<ul>
				<li><strong class="bold">Input layer</strong>: Consists of<a id="_idIndexMarker034"/> neurons accepting singular input signals (not a weighted sum) to the network. Their weights<a id="_idIndexMarker035"/> might be constant or randomized depending on the application.</li>
				<li><strong class="bold">Hidden layer</strong>: Consists of the types of <a id="_idIndexMarker036"/>neurons we described before. They are defined by an activation function and given weights to the weighted sum of the input signals. In DNNs, these layers typically represent specific transformation steps.</li>
				<li><strong class="bold">Output layer</strong>: Consists of neurons<a id="_idIndexMarker037"/> performing the final transformation <a id="_idIndexMarker038"/>of the data. They can behave like neurons in hidden layers, but they do not have to.</li>
			</ul>
			<p>These together result in a typical ANN, as shown in the following diagram:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B17928_01_03.jpg" alt="Figure 1.3 – ANN with one hidden layer " width="1650" height="897"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – ANN with one hidden layer</p>
			<p>With this, we build a generic structure that can receive some input, realize some form of mathematical function through different layers of weights and activation functions, and in the end, hopefully show the correct output. This process of pushing information through the network from inputs to<a id="_idIndexMarker039"/> outputs is typically referred to as <strong class="bold">forward propagation</strong>. This, of course, only<a id="_idIndexMarker040"/> shows us what is happening with an input that passes through the network. The following question remains: <em class="italic">How does it learn the desired function in the first place?</em> The next<a id="_idIndexMarker041"/> section will answer this question.</p>
			<h3>The backpropagation function</h3>
			<p>The question that should have popped up in<a id="_idIndexMarker042"/> your mind by now is: <em class="italic">How do we define the correct output?</em> To have a way to change the <a id="_idIndexMarker043"/>behavior of the network, which mostly boils down to changing the values of the weights in the system, don't we need a way to quantize the error the system made? </p>
			<p>Therefore, we need a function describing the<a id="_idIndexMarker044"/> error or loss, referred to as a <strong class="bold">loss function</strong> or <strong class="bold">error function</strong>. You might have even<a id="_idIndexMarker045"/> heard another name—a <strong class="bold">cost function</strong>. Let's define<a id="_idIndexMarker046"/> them next.</p>
			<p class="callout-heading">Loss Function versus Cost Function</p>
			<p class="callout">A loss function (error function) computes the error for a single training example. A cost function, on the other hand, averages all loss function results for the entire training dataset.</p>
			<p>This is the correct definition for those terms, but they are often used interchangeably. Just keep in mind that we are using some form of metric to measure the error we made or the distance we have from the correct results.</p>
			<p>In classic backpropagation and other ML scenarios, the <strong class="bold">mean squared error</strong> (<strong class="bold">MSE</strong>) between the correct <img src="image/B17928_Formula_1.06.png" alt="" width="34" height="31"/> and the<a id="_idIndexMarker047"/> computed <img src="image/B17928_Formula_1.07.png" alt="" width="35" height="51"/> is used to define the error or loss of the operation. The obvious target is to now minimize this error. Therefore, the actual task to perform is to find the total minimum of this function in <em class="italic">n</em>-dimensional space.</p>
			<p>To do this, we use<a id="_idIndexMarker048"/> something that is often referred to as an <strong class="bold">optimizer</strong>, defined next.</p>
			<p class="callout-heading">Optimizer (Objective Function)</p>
			<p class="callout">An optimizer is a function that implements a specific way to reach the objective of minimizing the cost function.</p>
			<p>One such optimizer is an iterative<a id="_idIndexMarker049"/> process called <strong class="bold">gradient descent</strong>. Its idea is visualized in the following screenshot: </p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B17928_01_04.jpg" alt="Figure 1.4 – Gradient descent with loss function influenced by only one input (left: finding global minimum, right: stuck in local minimum) " width="1650" height="617"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Gradient descent with loss function influenced by only one input (left: finding global minimum, right: stuck in local minimum)</p>
			<p>In gradient descent, we<a id="_idIndexMarker050"/> try to navigate an <em class="italic">n</em>-dimensional loss function by taking reasonably large enough steps, often defined by a <em class="italic">learning rate</em>, with the goal to find the global minimum, while avoiding getting stuck in a local minimum.</p>
			<p>Keeping this in mind and without going into too much detail, let's finish this thought by going through the steps the backpropagation algorithm performs on the neural network. These are set out here:</p>
			<ol>
				<li>Pass a pair <img src="image/B17928_Formula_1.08.png" alt="" width="105" height="43"/> through the network (forward propagation).</li>
				<li>Compute the loss between the expected <img src="image/B17928_Formula_1.09.png" alt="" width="33" height="30"/> and the computed <img src="image/B17928_Formula_1.10.png" alt="" width="29" height="35"/>.</li>
				<li>Compute all derivatives for all functions and weights throughout the layers using a mathematical chain rule.</li>
				<li>Update all weights beginning from the back of the network to the front, with slightly changed weights defined by the optimizer.</li>
				<li>Repeat until convergence<a id="_idIndexMarker051"/> is achieved (the weights are not receiving any meaningful updates anymore).</li>
			</ol>
			<p>This is, in a nutshell, how an ANN learns. Be aware that it is vital to constantly change the pairs in <em class="italic">Step 1</em>, as otherwise, you might push the network too far into memorizing these couple of pairs you constantly showed it. We <a id="_idIndexMarker052"/>will discuss the phenomenon of <strong class="bold">overfitting</strong> and <strong class="bold">underfitting</strong> later in this chapter. </p>
			<p>As a final step in this section, let's now <a id="_idIndexMarker053"/>bring together what we have learned so far about ML and what this means for building software solutions in the future.</p>
			<h3>ML and Software 2.0</h3>
			<p>What we learned so far is that ML <a id="_idIndexMarker054"/>seems to be defined by<a id="_idIndexMarker055"/> a base structure with various knobs and levers (settings and values) that can be changed. In the case of ANNs, that would be the structure of the network itself and the weights, bias, and activation function we can set in some regard. </p>
			<p>Accompanying this base structure is some sort of rule or function as to how these knobs and levers should be transformed through a learning process. In the case of ANNs, this is defined through the backpropagation function, which combines a loss function with an optimizer and some math.</p>
			<p>In 2017, Andrej Karpathy, the <strong class="bold">chief technical officer</strong> (<strong class="bold">CTO</strong>) of Tesla's AI division, proposed that the <a id="_idIndexMarker056"/>aforementioned idea could be just another way<a id="_idIndexMarker057"/> of programming, which he called <strong class="bold">Software 2.0</strong> (<a href="https://karpathy.medium.com/software-2-0-a64152b37c35">https://karpathy.medium.com/software-2-0-a64152b37c35</a>).</p>
			<p>Up to this point, writing software <a id="_idIndexMarker058"/>was about explaining to the machine precisely what it must do and what outcome it must produce through defining specific commands it had to follow. In this classical software development paradigm, we define algorithms by their code and let data run through it, typically written in a reasonably readable language.</p>
			<p>Instead of doing that, another<a id="_idIndexMarker059"/> idea could be to define a program we build by a base structure, a way to evolve this structure, and the type of data it must process. In this case, we get something very human-unfriendly to understand (an ANN with weights, for example), but it might be much better to understand for a machine.</p>
			<p>So, we leave you at the end of this section with the thought that Andrej wanted to convey. Perhaps ML is just another form of programming machines. </p>
			<p>Keeping all this in mind, let's now talk about math. </p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Understanding the mathematical basis for statistical analysis and ML modeling</h1>
			<p>Looking at what we have learned so far, it becomes<a id="_idIndexMarker060"/> abundantly clear that ML requires an ample understanding of mathematics. We already came across multiple mathematical functions we have to handle. Think about the activation function of neurons and the optimizer and loss functions for training. On top of that, we have not talked about the second aspect of our new programming paradigm—the data!</p>
			<p>To choose the right ML algorithm<a id="_idIndexMarker061"/> and derive a good metric for a loss function, we have to take apart the data points we work with. In addition, we need to bring in the data points in relation to the domain we are working with. Therefore, when defining the role of a data scientist, you will often find a visual like this one: </p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B17928_01_05.jpg" alt="Figure 1.5 – Requirements for data scientists " width="1650" height="776"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Requirements for data scientists</p>
			<p>In this section, we will concentrate on what is referred to in <em class="italic">Figure 1.5</em> as <em class="italic">statistical research</em>. We will understand why we need statistics and what base information we can derive from a given dataset, learn<a id="_idIndexMarker062"/> what bias is and ways to avoid that, mathematically classify possible ML algorithms, and finally, discuss how we choose useful metrics to define the performance of our trained models.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>The case for statistics in ML</h2>
			<p>As we have seen, we<a id="_idIndexMarker063"/> require statistics to clean and analyze our given data. Therefore, let's start by asking: <em class="italic">What do we understand from the term "statistics"?</em></p>
			<p class="author-quote"><em class="italic">Statistics is the science of collecting and analyzing a representative sample made up of a large quantity of numerical data with the purpose of inferring the statistical distribution of the underlying population. </em></p>
			<p>A typical example of something such as this would be the prediction for the results of an election you see during the campaign or shortly after voting booths close. At those points in time, we do not know the precise result of the full <strong class="bold">population</strong> but we can acquire a <strong class="bold">sample</strong>, sometimes referred to as an <strong class="bold">observation</strong>. We get that by asking people for responses through a questionnaire. Then, based on this subset, we make a sound prediction for the full population by applying statistical methods.</p>
			<p>We learned that in ML, we are trying to let the machine figure out a mathematical function that fits our problem, such as this:</p>
			<p><img src="image/B17928_Formula_1.11.png" alt="" width="177" height="49"/></p>
			<p>Thinking back to our ANN, <img src="image/B17928_Formula_1.12.png" alt="" width="25" height="38"/> would be<a id="_idIndexMarker064"/> an input vector and <img src="image/B17928_Formula_1.13.png" alt="" width="26" height="47"/> would be the resulting output vector. In ML jargon, they are known under a different name, as seen next. </p>
			<p class="callout-heading">Features and Labels </p>
			<p class="callout">One element of the input vector <em class="italic">x</em> is called a feature; the full output vector is called the label. Often, we only deal with a <strong class="bold">one-dimensional</strong> label.</p>
			<p>Now, to bring this together, when training an ML model, we typically only have a sample of the given world, and as with any other time you are dealing with only a sample or subset of reality, you want to pick highly representative features and samples of the underlying population.</p>
			<p>So, what does this mean? Let's think of an example. Imagine you want to train a small little robot car to be able to automatically drive through a tunnel. First, we need to think about what our features and labels in this scenario are. As features, we probably need something that measures the distance from the edges of the car to the tunnel in each direction, as we probably do not want to drive into the sides of the tunnel. Let's assume we have some infrared sensors attached to the front, the sides, and the back of the vehicle. Then, the output of our program would probably control the steering and the speed of the vehicle, which would be our labels.</p>
			<p>Given that, as a next step, we should think of a whole bunch of scenarios in which the vehicle could find itself. This might be a simple scenario of the vehicle sitting straight-facing in the tunnel, or it could be a bad scenario where the vehicle is nearly stuck in a corner and the tunnel is going left or right from that point on. In all these cases, we read out the values of our infrared sensors and then do the more complicated tasks of making an educated guess as to how the steering has to be changed and how the motor has to operate. Eventually, we end up with a bunch of example situations and corresponding actions to take, which would be our training dataset. This can then be used to train an ANN so that the small car can learn how to follow a tunnel. </p>
			<p>If you ever get the opportunity, try to <a id="_idIndexMarker065"/>perform this training. If you pick very good examples, you will understand the full power of ML, as you will most likely see something exciting, which I can attest to. In my setup, even though we never had a<a id="_idIndexMarker066"/> sample where we would instruct the vehicle to drive backward, the optimal function the machine trained had values where the vehicle learned to do exactly that.</p>
			<p>In an example such as that, we would do everything from scratch and hopefully take representative samples by ourselves. In most cases you will encounter, the dataset already exists, and you need to figure out whether it is representative or whether we need to introduce additional data to achieve an optimal training result.</p>
			<p>Therefore, let's have a look at some statistical properties you should familiarize yourself with.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Basics of statistics</h2>
			<p>We now understand that we<a id="_idIndexMarker067"/> need to be able to analyze the statistical properties of single features, derive their distribution, and analyze their relationship with other features and labels in the dataset.</p>
			<p>Let's start with the properties of single features and their distribution. All the following operations require numerical data. This means that if you work with categorical data or something such as media files, you need to transform them into some form of numerical representation to get such results. </p>
			<p>The following screenshot shows the main statistical properties you are after, their importance, and how you can calculate them:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B17928_01_06.jpg" alt="Figure 1.6 – List of major statistical properties " width="643" height="497"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – List of major statistical properties</p>
			<p>From here onward, we <a id="_idIndexMarker068"/>can make the reasonable assumption that the underlying stochastic process follows a <strong class="bold">normal distribution</strong>. Be aware that this must not be the case, and therefore you should make yourself comfortable with other distributions (see <a href="https://www.itl.nist.gov/div898/handbook/eda/section3/eda36.htm">https://www.itl.nist.gov/div898/handbook/eda/section3/eda36.htm</a>).</p>
			<p>The following screenshot shows a visual representation of a standard normal distribution:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B17928_01_07.jpg" alt="Figure 1.7 – Standard normal distribution and its properties " width="1650" height="627"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 1.7 – Standard normal distribution and its properties</p>
			<p>Now, the strength of this normal distribution is that, based on the mean <img src="image/B17928_Formula_1.14.png" alt="" width="23" height="29"/> and standard deviation <img src="image/B17928_Formula_1.15.png" alt="" width="25" height="22"/>, we can make assumptions for the probabilities of samples to be in a certain range. As shown in <em class="italic">Figure 1.7</em>, there is a probability of around <strong class="bold">68.27%</strong> for a value to have a distance from the <a id="_idIndexMarker069"/>mean of 1<img src="image/B17928_Formula_1.16.png" alt="" width="23" height="21"/>, <strong class="bold">95.45%</strong> for a distance of <img src="image/B17928_Formula_1.17.png" alt="" width="40" height="26"/>, and <strong class="bold">99.73%</strong> for a distance of <img src="image/B17928_Formula_1.18.png" alt="" width="43" height="27"/>. Based on this, we can ask questions such as this:</p>
			<p><em class="italic">How probable is it to find a value with a distance of 5</em><img src="image/B17928_Formula_1.19.png" alt="" width="27" height="25"/><em class="italic"> from the mean?</em></p>
			<p>Through questions such as this, we can start assessing whether what we see in our data is a statistical anomaly of the distribution, is a value that is simply false, or whether our suspected distribution is incorrect. This is done through a<a id="_idIndexMarker070"/> process called <strong class="bold">hypothesis testing</strong>, defined next.</p>
			<p class="callout-heading">Hypothesis Testing (Definition)</p>
			<p class="callout">This is a method of testing if the so-called null hypothesis <img src="image/B17928_Formula_1.20.png" alt="" width="41" height="36"/> is false, typically referring to the current suspected distribution. It means that the unlikely observation we encounter is pure chance. This hypothesis is rejected in favor of an alternative hypothesis <img src="image/B17928_Formula_1.21.png" alt="" width="42" height="35"/>, if the probability falls below a predefined significance level (typically higher than <img src="image/B17928_Formula_1.22.png" alt="" width="43" height="28"/>/lower than 5%). The alternative hypothesis thus presumes that the observation we have is due to a real effect that is not taken into account in the initial distribution. </p>
			<p>We will not go into further details on<a id="_idIndexMarker071"/> how to perform this test properly, but we urge you to familiarize yourself with this process thoroughly.</p>
			<p>What we will talk about is the types of errors you can make in this process, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B17928_01_08.jpg" alt="Figure 1.8 – Type I and Type II errors " width="747" height="293"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – Type I and Type II errors</p>
			<p>We define the errors you see in <em class="italic">Figure 1.8</em> as follows:</p>
			<ul>
				<li><strong class="bold">Type I error</strong>: This denotes that we reject the hypothesis <img src="image/B17928_Formula_1.23.png" alt="" width="43" height="37"/> and the underlying distribution, even though it is <a id="_idIndexMarker072"/>correct. This is also referred to as <a id="_idIndexMarker073"/>a <strong class="bold">false-positive</strong> result or an <strong class="bold">alpha error</strong>. </li>
				<li><strong class="bold">Type II error</strong>: This denotes that we do not reject the hypothesis <img src="image/B17928_Formula_1.24.png" alt="" width="43" height="38"/> and the underlying distribution, even though <img src="image/B17928_Formula_1.25.png" alt="" width="51" height="43"/> is<a id="_idIndexMarker074"/> correct. This error is also <a id="_idIndexMarker075"/>referred to as a <strong class="bold">false-negative</strong> result or a <strong class="bold">beta</strong> <strong class="bold">error</strong>. </li>
			</ul>
			<p>You might have heard the term <em class="italic">false positive</em> before. Often, it comes up when you take a medical test. A false positive would denote that <a id="_idIndexMarker076"/>you have a positive result from a test, even though you do not have the disease you are testing for. As a medical test is also a <strong class="bold">stochastic process</strong>, as with nearly everything else in our world, the term is correctly used in this scenario. </p>
			<p>At the end of this section, when we talk about errors and metrics in ML model training, we will come back to these definitions. As a final step, let's discuss relationships among features and between features and labels. Such a<a id="_idIndexMarker077"/> relationship is referred to as a <strong class="bold">correlation</strong>. </p>
			<p>There are multiple ways to calculate a<a id="_idIndexMarker078"/> correlation between two vectors <img src="image/B17928_Formula_1.26.png" alt="" width="23" height="36"/> and <img src="image/B17928_Formula_1.27.png" alt="" width="23" height="42"/>, but what they all have in common is that their results will fall in the range of [-1,1]. The result of this operation can be broadly defined by the following three categories:</p>
			<ul>
				<li><strong class="bold">Negatively correlated</strong>: The result leans<a id="_idIndexMarker079"/> toward -1. When the value of vector <img src="image/B17928_Formula_1.28.png" alt="" width="23" height="37"/> rises, the values of vector <img src="image/B17928_Formula_1.29.png" alt="" width="23" height="43"/> fall and vice versa.</li>
				<li><strong class="bold">Uncorrelated</strong>: The result leans toward 0. There is no<a id="_idIndexMarker080"/> real interaction between vectors <img src="image/B17928_Formula_1.30.png" alt="" width="20" height="31"/> and <img src="image/B17928_Formula_1.31.png" alt="" width="23" height="43"/>. </li>
				<li><strong class="bold">Positively correlated</strong>: The result leans toward 1. When the<a id="_idIndexMarker081"/> value of vector <img src="image/B17928_Formula_1.32.png" alt="" width="21" height="34"/> rises, the values of vector <img src="image/B17928_Formula_1.33.png" alt="" width="23" height="44"/> rise and vice versa.</li>
			</ul>
			<p>Through this, we can get an idea of relationships between data points, but please be aware of the differences between causation and correlation, as outlined next.</p>
			<p class="callout-heading">Causation versus Correlation</p>
			<p class="callout">Even if two vectors are correlated with each other, it does not <a id="_idIndexMarker082"/>mean one of them is the cause of the other one—it simply means that one of them influences the other one. It is not causation as we probably don't see the full picture and every single influencing factor.</p>
			<p>The mathematical theory we discussed so far should give you a good basis to build upon. In the next section, we <a id="_idIndexMarker083"/>will have a quick look at what kinds of errors we can make when taking samples, typically referred to as the bias in the data.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Understanding bias</h2>
			<p>At any stage of taking samples and when working with data, it is easily possible to introduce what is called <strong class="bold">bias</strong>. Typically, this influences the sampling quality and therefore has a big impact on any ML model we would like to fit to the data.</p>
			<p>One example would be the <em class="italic">causation versus correlation</em> we just discussed. Seeing causation where none exists can <a id="_idIndexMarker084"/>have consequences in terms of the way you continue processing the data points. Other prominent biases that influence data are shown next:</p>
			<ul>
				<li><strong class="bold">Selection bias</strong>: This bias happens<a id="_idIndexMarker085"/> when samples are taken that are not representative of the real-life distribution of data. This is the case when randomization is not properly <a id="_idIndexMarker086"/>done or when only a certain subgroup is selected for a study—for example, when a questionnaire about city planning is only given out to people in half of the neighborhoods of the city.</li>
				<li><strong class="bold">Funding bias</strong>: This bias should be very well known and happens when a study or data project is funded by a sponsor <a id="_idIndexMarker087"/>and the results will therefore have a tendency toward the<a id="_idIndexMarker088"/> interests of the funding party.</li>
				<li><strong class="bold">Reporting bias</strong>: This bias happens when only a selection of outcomes is represented in a dataset due to the <a id="_idIndexMarker089"/>fact that it is the tendency of people to underreport certain outcomes. Examples of this are given here: when you report bad weather <a id="_idIndexMarker090"/>events but not when there is sunshine; when you write negative reviews for a product but not positive reviews; when you only know about results written in your own language or from your own region but not from others.</li>
				<li><strong class="bold">Observer bias/confirmation bias</strong>: This bias happens when someone favors results that confirm or <a id="_idIndexMarker091"/>support their own beliefs and values. Typically, this results in ignoring <a id="_idIndexMarker092"/>contrary information, not following the agreed guideline, or using ambiguous studies that support the existing preconceived opinion. The dangerous part here is that this can happen unconsciously.</li>
				<li><strong class="bold">Exclusion bias</strong>: This bias<a id="_idIndexMarker093"/> happens when you remove data points during<a id="_idIndexMarker094"/> preprocessing that you consider irrelevant but are not. This includes removing null values, outliers, or other special data points. The removal might result in the loss of accuracy concerning the underlying real-life distribution. </li>
				<li><strong class="bold">Automation bias</strong>: This bias <a id="_idIndexMarker095"/>happens when you favor results generated from automated systems<a id="_idIndexMarker096"/> over information taken from humans, even if they are correct.</li>
				<li><strong class="bold">Overgeneralization bias</strong>: This bias <a id="_idIndexMarker097"/>happens when you project a<a id="_idIndexMarker098"/> property of your dataset toward the whole population. An example would be that you would assume that all cats have gray fur because in the large dataset you have, this is true.</li>
				<li><strong class="bold">Group attribution bias</strong>: This bias happens when <a id="_idIndexMarker099"/>stereotypes are added as attributes to a whole group because of the <a id="_idIndexMarker100"/>actions of a few individuals within that group. </li>
				<li><strong class="bold">Survivorship bias</strong>: This bias happens <a id="_idIndexMarker101"/>when you focus on successful examples while<a id="_idIndexMarker102"/> completely ignoring failures. An example would be that you study the competition of your company while ignoring all companies that failed, merged, or went bankrupt.</li>
			</ul>
			<p>This list should give you a good understanding of problems that may arise when gathering and processing data. We can only urge you to read further into this topic while following these next guidelines.</p>
			<p class="callout-heading">Guidance for Handling Bias in Data</p>
			<p class="callout">When using existing datasets, figure out the circumstances in which they were obtained to be able to judge their quality. When<a id="_idIndexMarker103"/> processing data either alone or in a team, define clear guidelines on how you define data and how you handle certain situations, and always reflect whether you are making assumptions based on your own predispositions.</p>
			<p>To solidify your <a id="_idIndexMarker104"/>understanding that things are—most of the time—not as they seem, have a look at what is referred to as <strong class="bold">Simpson's paradox</strong> and the corresponding <strong class="bold">University of California</strong> (<strong class="bold">UC</strong>) Berkeley case (<a href="http://corysimon.github.io/articles/simpsons-paradox/">http://corysimon.github.io/articles/simpsons-paradox/</a>).</p>
			<p>Now that we have a good understanding of what to look out for when working with data, let's come back to the basics of ML.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Classifying ML algorithms</h2>
			<p>In the first section of this chapter, we got<a id="_idIndexMarker105"/> a glimpse into ANNs. These are special in the sense that they can be used in a so-called supervised or unsupervised training setup. To understand what is meant by this, let's define the current three major types of ML algorithms, as follows:</p>
			<ul>
				<li><strong class="bold">Supervised learning</strong>: In supervised learning, models are<a id="_idIndexMarker106"/> trained with a so-called<a id="_idIndexMarker107"/> labeled dataset. That means besides knowing the input for the required algorithm, we also know the required output. This type of learning is split into two groups of problems—namely, <strong class="bold">classification problems</strong> and <strong class="bold">regression problems</strong>. Classification works with discrete results, where the output is a class or group, while regression works with continuous results, where the output would be a certain value. Examples of classification would be identifying fraud in money transactions or doing object detection in images. Examples of regression would be forecasting prices for houses or <a id="_idIndexMarker108"/>the stock market or predicting population growth. It is important to understand that this type of learning <em class="italic">requires</em> labels, which often results in the tedious task of labeling the whole dataset.</li>
				<li><strong class="bold">Unsupervised learning</strong>: In unsupervised learning, models are trained on unlabeled data. This is basically self-organized learning to find patterns in data, referred to as <strong class="bold">clustering</strong>. Examples of this would be the filtering of spam emails in an inbox or the recommendation of movies or clothing a person might like to watch or purchase. Often, the learning algorithms are used in a real-time scenario where the data needs to be processed directly. The beauty of this type of learning is that we do not have to label the dataset. </li>
				<li><strong class="bold">Reinforcement learning</strong>: In reinforcement learning, algorithms learn by reacting to a given environment on their own. The idea of this comes from how we as humans learn as we grow up. We did a certain action, and the outcome of that action was either good or bad or somewhere in between. We then either receive some sort of reward or we don't. Another similar example would be the way you would train a dog to behave. Technically, this is realized through a so-called <em class="italic">agent</em> that is guided by a <em class="italic">policy map</em>, deciding the probability to take actions when in a specific state. For the environment itself, we define a so-called <em class="italic">state-value function</em> that returns the <em class="italic">value</em> of being in a specific state. Good examples of this type of learning are training navigation control for a robot or an AI opponent for a game.</li>
			</ul>
			<p>The following diagram provides an overview of the discussed ML types and the corresponding algorithms that are utilized in those areas:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B17928_01_09.jpg" alt="Figure 1.9 – Types of ML algorithms " width="1650" height="671"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9 – Types of ML algorithms</p>
			<p>A detailed overview of many of the prominent ML algorithms can be found on the <em class="italic">scikit-learn</em> web page (<a href="https://scikit-learn.org/stable/">https://scikit-learn.org/stable/</a>), which is one of the major Python libraries for ML.</p>
			<p>Now that we have an idea of the types of training we can perform, let's have a short look at what types of results we get from a training run and how to interpret them.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Analyzing errors and the quality of results of model training</h2>
			<p>As we discussed in the first section of this chapter, we require a loss function that we can minimize to optimize our training results. Typically, this is defined through what is referred to in mathematics as a metric. We need to differentiate at this point between metrics that are used to define a loss function and therefore used in an optimizer to train the model, and metrics that can be calculated to give additional hints toward the performance of the trained model. We will have a look at both kinds in this section.</p>
			<p>As we have seen when looking at types of ML algorithms, we might work with an output represented by continuous data (regression), or we might work with an output represented by discrete data (classification).</p>
			<p>The most prominent loss functions used in regression are <strong class="bold">MSE</strong> and <strong class="bold">root MSE </strong>(<strong class="bold">RMSE</strong>). Imagine you try to determine a fitted line for a bunch of samples in linear regression. The distance between the line and the sample point in <strong class="bold">two-dimensional</strong> (<strong class="bold">2D</strong>) space is your error. To calculate the RMSE for all data points, you would take the expected values <img src="image/B17928_Formula_1.34.png" alt="" width="34" height="32"/> and the predicted values <img src="image/B17928_Formula_1.35.png" alt="" width="36" height="44"/> and calculate the following:</p>
			<p><img src="image/B17928_Formula_1.36.png" alt="" width="475" height="160"/></p>
			<p>For classifications, this gets a little bit trickier. In most cases, the model can predict the correct class or cannot, making it a binary result. Further, we might have a binary classification problem (1 or 0—yes or no), or a multi-class problem (cat, dog, horse, and so on).</p>
			<p>For both classification problems, there is a prominent loss function used called <strong class="bold">cross-entropy loss</strong>. To solve the problem of having a binary result, this loss function requires a model that outputs a probability <img src="image/B17928_Formula_1.37.png" alt="" width="25" height="34"/> between 0 and 1 for a given data point <img src="image/B17928_Formula_1.38.png" alt="" width="25" height="24"/> and a suggested prediction <img src="image/B17928_Formula_1.39.png" alt="" width="27" height="33"/>. For a binary classification model, it is calculated as follows:</p>
			<p><img src="image/B17928_Formula_1.40.png" alt="" width="640" height="61"/></p>
			<p>For multi-class classification, we sum up this error for all classes <img src="image/B17928_Formula_1.41.png" alt="" width="27" height="34"/>, as follows:</p>
			<p><img src="image/B17928_Formula_1.42.png" alt="" width="295" height="155"/></p>
			<p>If you want to look further into this topic, consider other useful loss functions for regression, such as the <strong class="bold">absolute error</strong> loss and the <strong class="bold">Huber loss</strong> functions (used in <strong class="bold">support vector machines</strong>, or <strong class="bold">SVMs</strong>), useful loss functions for binary classification, such as the <strong class="bold">hinge loss</strong> function, and useful loss functions for multi-class classification, such as the <strong class="bold">Kullback-Leibler divergence</strong> (<strong class="bold">KL-divergence</strong>) function. The last one can also be used in RL as a metric to monitor the policy function during training.</p>
			<p>Everything we have discussed so far requires something we can put into a mathematical formula. Imagine working with text files to build a model for <strong class="bold">natural language processing</strong> (<strong class="bold">NLP</strong>). In such a case, we do not have a useful mathematical representation for text besides something such as <strong class="bold">Unicode</strong>. We will learn in <a href="B17928_07_ePub.xhtml#_idTextAnchor112"><em class="italic">Chapter 7</em></a>, <em class="italic">Advanced Feature Extraction with NLP</em>, how to represent it in a useful, vectorized manner. Having vectors, we can use a different kind of metric to calculate how similar vectors are, called the <strong class="bold">cosine similarity</strong> metric, which we will discuss in <a href="B17928_06_ePub.xhtml#_idTextAnchor102"><em class="italic">Chapter 6</em></a>,<em class="italic"> Feature Engineering and Labeling</em>.</p>
			<p>So far, we have discussed how to calculate loss functions for a couple of scenarios, but how can we define the performance of our model overall?</p>
			<p>For regression models, our loss function was defined over the whole corpus of our training set. The error of a single observation or prediction would be <img src="image/B17928_Formula_1.43.png" alt="" width="130" height="42"/>. Therefore, RMSE is already a cost function and can be used by an optimizer to improve the model performance, so we can use it to judge the performance of the model.</p>
			<p>For classification models, this gets a little bit more interesting. Cross-entropy can be used with an optimizer to train the model and can be used to judge the model, but besides that, we can define an additional metric to look out for.</p>
			<p>Something obvious would be what is referred to as the <strong class="bold">accuracy</strong> of a model, calculated as follows:</p>
			<p><img src="image/B17928_Formula_1.44.png" alt="" width="697" height="97"/></p>
			<p>Now, this looks about right. We just say that the quality of our model is the percentage of how often we guessed correctly, and the reality is that a lot of people agree with this statement. Remember when we defined <strong class="bold">false positives</strong> and <strong class="bold">false negatives</strong>? These now come into play. Let's look at an example. </p>
			<p>Imagine a test that checks for a contagious virus. <em class="italic">Figure 1.10</em> shows the results for 100 people being tested for this virus, including the correctness of the results:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B17928_01_10.jpg" alt="Figure 1.10 – Test results for a group of 100 people " width="755" height="317"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.10 – Test results for a group of 100 people</p>
			<p>Now, what would be the <a id="_idIndexMarker109"/>accuracy of this test given these results? Let's define it <a id="_idIndexMarker110"/>again using the values for true positive (<img src="image/B17928_Formula_1.45.png" alt="" width="50" height="31"/>), false positive (<img src="image/B17928_Formula_1.46.png" alt="" width="52" height="31"/>), false negative (<img src="image/B17928_Formula_1.47.png" alt="" width="53" height="29"/>), and true negative (<img src="image/B17928_Formula_1.48.png" alt="" width="53" height="30"/>) and calculate the results for our example, as follows:</p>
			<p><img src="image/B17928_Formula_1.49.png" alt="" width="1157" height="88"/></p>
			<p>This sounds like a good test. It gives accurate results in 92% of cases, but perhaps you see the problem here. Accuracy sees everything equally. Our test misclassifies someone having the virus eight times as someone being virus-free, which might have dire ramifications. That means it might be useful having performance metrics that put more emphasis on false-positive or false-negative outcomes. Therefore, let's define two additional metrics to calculate.</p>
			<p>The first one we call <strong class="bold">precision</strong>, a value that defines how many positive identifications were correct. The formula is shown here:</p>
			<p><img src="image/B17928_Formula_1.50.png" alt="" width="785" height="95"/></p>
			<p>In our example, only <a id="_idIndexMarker111"/>in two out of three cases are we correct when we declare someone to be infected. A model with a precision value of 1 would have no false-positive results.</p>
			<p>The second one we call <strong class="bold">recall</strong>, a value that defines how many positive results we identify correctly. The formula is shown here:</p>
			<p><img src="image/B17928_Formula_1.51.png" alt="" width="660" height="105"/></p>
			<p>This means in our example, we correctly identify 20% of all infected patients, which is a bad result. A model with a recall value of 1 would have no false-negative results.</p>
			<p>To evaluate our test or<a id="_idIndexMarker112"/> classification correctly, we need to evaluate accuracy, precision, and recall. Be aware that, as mentioned when we talked about hypothesis testing, precision and recall can work against each other. Therefore, you often have to decide whether you prefer to be precise when saying "<em class="italic">You have the virus</em>" or whether you prefer to find everyone who has the virus. You might now understand why such tests are often designed toward recall.</p>
			<p>With this, we conclude the section on the mathematical basis required to get better at building ML models and working with data. Based on what we have learned so far, you should take the next point with you.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Never just use methods from ML libraries for data analysis and modeling; understand them mathematically.</p>
			<p>In the next section, we will guide you through the structure of the end-to-end ML process and the structure of this book.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Discovering the end-to-end ML process</h1>
			<p>We have finally arrived at<a id="_idIndexMarker113"/> the main topic of this chapter. After reviewing the past and understanding the purpose of ML and how it takes its roots in mathematical data analysis, let's now get a clear picture of which steps need to be taken to create a high-quality ML model. </p>
			<p>The following diagram shows an overview of the (sometimes recursive) steps from data to model to deployed model:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B17928_01_11.jpg" alt="Figure 1.11 – End-to-end ML process " width="1650" height="949"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11 – End-to-end ML process</p>
			<p>Looking at this flow, we can define the following distinct steps to take:</p>
			<ol>
				<li value="1">Excavating data and sources </li>
				<li>Preparing and cleaning data</li>
				<li>Defining labels and engineering features </li>
				<li>Training models</li>
				<li>Deploying models</li>
			</ol>
			<p>These show the steps for running one single ML project. When you deal with a lot of projects and data, it<a id="_idIndexMarker114"/> becomes increasingly important to adopt some form of automation and operationalization, which is typically referred to as MLOps. </p>
			<p>In this section, we will give an overview of each of these steps, including MLOps and its importance, and explain in which chapters we will delve deeper into the corresponding topic. Before we start going through those steps, reflect on the following question:</p>
			<p><em class="italic">As a percentage, how much time would you put aside for each of those steps?</em></p>
			<p>After you are done, have a look at the following screenshot, which shows you the typical time investment required for those tasks:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B17928_01_12.jpg" alt="Figure 1.12 – ML time invested " width="1634" height="1152"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12 – ML time invested</p>
			<p>Was your guess reasonably close to this? You might be surprised that only 20% of the time, you will work on something that has to do with the actual training and deployment of ML models. Therefore, you should take the next point to heart. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">In an ML project, you should spend most of your time taking apart your datasets and finding other useful data sources.  </p>
			<p>Failure to do so will have<a id="_idIndexMarker115"/> ramifications on the quality of your model and its performance. Now, having said that, let's go through the steps one by one, starting with where to source your data from.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Excavating data and sources</h2>
			<p>When you start an ML project, you<a id="_idIndexMarker116"/> probably have some outcome in mind, and often, you have some form of existing dataset you or your company wants to start with. This is where you start familiarizing yourself with the given data, understanding what you have and what is missing by doing analysis, which we will come back to in the following steps.</p>
			<p>At some point, you might realize that you are missing additional—but crucial—data points to increase the quality of your results. This highly depends on what you are missing—whether it is something you or your company can obtain or whether you need to find it somewhere else. To give you some ideas, let's have a look at the following options to acquire additional data and what you should be aware of:</p>
			<ul>
				<li><strong class="bold">In-house data sources</strong>: If you are running this project in or with a company, the first point to look is internally. Advantages of this are that it is free of charge, it is often standardized, and you should be able to find a person that knows this data and how it was obtained. Depending on the project, it might also be the only place you can acquire the required data. Disadvantages of this option are that you might not find what you are looking for, that the data is poorly documented, and that the quality might be in question due to bias in the data.</li>
				<li><strong class="bold">Open data sources</strong>: Another option is to use freely available datasets. Advantages of those are that they are typically gigantic in size (<strong class="bold">terabytes</strong> (<strong class="bold">TB</strong>) of data), they cover different time periods, and they are typically well structured and documented. Disadvantages are that some data fields might be hard to understand (and the creator is not available), the quality might also vary due to bias in the data, and often when used, they require you to publish your results. Examples of this would be the <strong class="bold">National Oceanic and Atmospheric Administration</strong> (<strong class="bold">NOAA</strong>) (<a href="https://www.ncei.noaa.gov/weather-climate-links">https://www.ncei.noaa.gov/weather-climate-links</a>) and the <strong class="bold">European Union</strong> (<strong class="bold">EU</strong>) Open Data Portal (<a href="https://data.europa.eu/en">https://data.europa.eu/en</a>), among many others.</li>
				<li><strong class="bold">Data seller (data as a service, or DaaS)</strong>: A final option would be to buy data from a data seller, either by purchasing an existing dataset or by requesting the creation of one. Advantages of this option are that it saves you time, it can give you access to <a id="_idIndexMarker117"/>an individualized dataset, and you might even get access to preprocessed data. Disadvantages are that this is expensive, you still need to do all the other following steps to make this data useful, and there might be questions concerning privacy and ethics.</li>
			</ul>
			<p>Now that we have a good idea of where to get data initially or additionally, let's look at the next step: preparing and cleaning the data.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Preparing and cleaning data</h2>
			<p>As alluded to before, descriptive data<a id="_idIndexMarker118"/> exploration is without a doubt one of the most important steps in an ML project. If you want to clean data and<a id="_idIndexMarker119"/> build derived features or select an ML algorithm to predict a target variable in your dataset, then you need to understand your data first. Your data will define many of the necessary cleaning and preprocessing steps. It will define which algorithms you can choose, and it will ultimately define the performance of your predictive model.</p>
			<p>The exploration should be done as a structured analytical process rather than a set of experimental tasks. Therefore, we will go through a checklist of data exploration tasks that you can perform as an initial step in every ML project, before starting any data cleaning, preprocessing, <strong class="bold">feature engineering</strong>, or model selection. By applying these steps, you will be<a id="_idIndexMarker120"/> able to understand the data and gain knowledge about the required preprocessing tasks. </p>
			<p>Along with that, it will give <a id="_idIndexMarker121"/>you a good estimate of what kinds of difficulties you can expect in your prediction task, which is essential for judging the required algorithms and validation strategies. You will also gain an insight into which possible feature engineering methods could apply to your dataset and have a better understanding of how to select a good loss function.</p>
			<p>Let's have a look at the required steps.</p>
			<h3>Storing and preparing data</h3>
			<p>Your data might come in a variety of different formats. You might work with tabular data stored in a <strong class="bold">comma-separated values</strong> (<strong class="bold">CSV</strong>) file; you might have images stored as <strong class="bold">Joint Photographic Experts Group</strong> (<strong class="bold">JPEG</strong>) or <strong class="bold">Portable Network Graphics</strong> (<strong class="bold">PNG</strong>) files, text stored in a <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) file, or audio files in <strong class="bold">MP3</strong> or <strong class="bold">M4V</strong> format. CSV can be a good format as it is human-readable and can be parsed efficiently. You can <a id="_idIndexMarker122"/>open and browse it using any text editor.</p>
			<p>If you work on your own, you <a id="_idIndexMarker123"/>might just store this raw data in a folder on your system, but when you are working with a cloud infrastructure or even just a company infrastructure in general, you might need some form of cloud storage. Certainly, you can just upload your raw data by hand to such storage, but often, the data you work with is coming from a live system and needs to be extracted from there. This means it might be worthwhile<a id="_idIndexMarker124"/> having a look at so-called <strong class="bold">extract-transform-load</strong> (<strong class="bold">ETL</strong>) tools that can automate this process and bring the required raw data into cloud storage.</p>
			<p>After all of the preprocessing steps are done, you will have some form of layered data in your storage, from raw to cleaned to labeled to processed datasets.</p>
			<p>We will dive deeper into this topic in <a href="B17928_04_ePub.xhtml#_idTextAnchor071"><em class="italic">Chapter 4</em></a>, <em class="italic">Ingesting Data and Managing Datasets</em>. For now, just understand that we will automate this process of making data available for processing.</p>
			<h3>Cleaning data</h3>
			<p>In this step, we have a look at inconsistency <a id="_idIndexMarker125"/>and structural errors in the data itself. This step is often required for tabular data and sometimes text files, but not so much for image or audio files. For the latter, we might be able to crop images and change their brightness or contrast, but it might be required to go back to the source to create better-quality samples. The same goes for audio files.</p>
			<p>For tabular datasets, we have much more options for processing. Let's go through what to look out for, as follows:</p>
			<ul>
				<li><strong class="bold">Duplicates</strong>: Through mistakes in copying data or due to a combination of different data sources, you might find duplicate samples. Typically, copies can be deleted. Just make sure that these are not two different samples that look the same. </li>
				<li><strong class="bold">Irrelevant information</strong>: In most cases, you will have datasets with a lot of different features, some of which will be completely unnecessary for your project. The obvious ones you should just remove in the beginning; others you will be able to remove later after analyzing the data further.</li>
				<li><strong class="bold">Structural errors</strong>: This refers to the values you can see in the samples. You might run into different entries with the same meaning (such as <strong class="source-inline">US</strong> and <strong class="source-inline">United States</strong>) or simply typos. These should be standardized or cleaned up. A good way to do this is by visualizing all available values of a feature.</li>
				<li><strong class="bold">Anomalies (outliers)</strong>: This refers to very unlikely values for which you need to decide whether they are errors or actually true. This is typically done after analyzing the data when you know the distribution of a feature.</li>
				<li><strong class="bold">Missing values</strong>: This refers to cells in your data that are either blank or have some generic value in them, such as <strong class="source-inline">NA</strong> or <strong class="source-inline">NaN</strong>. There are different ways to rectify this besides deleting entire samples. It is also prudent to wait until you have more insight from analyzing the data, as you might see better ways to replace them.</li>
			</ul>
			<p>After this step, we can start analyzing the cleaned version of our dataset further.</p>
			<h3>Analyzing data</h3>
			<p>In this step, we apply our understanding of <a id="_idIndexMarker126"/>statistics to get some insights into our features and labels. This includes calculating statistical properties for each feature, visualizing them, finding correlated features, and measuring something that is called <strong class="bold">feature importance</strong>, which <a id="_idIndexMarker127"/>calculates the impact of a<a id="_idIndexMarker128"/> feature on the label, also referred to as the <strong class="bold">target variable</strong>.</p>
			<p>Through these methods, we get ideas about relationships among features and between features and targets, which can help us to make a decision. In this decision-making process, we also start adding something vitally important—our <strong class="bold">domain knowledge</strong>. If you do not know what the data represents, you will have a hard time pruning it and choosing optimal features and samples for training.</p>
			<p>There are a lot more techniques that can be applied in this step, including something called <strong class="bold">dimensional reduction</strong>. If you <a id="_idIndexMarker129"/>have thousands of features (a numerical representation of an image, for example), it gets very complicated for humans and even for ML processes to understand relationships. In such cases, it might be useful to map this high-dimensional sample to a two-dimensional or three-dimensional representation in the form of a vector. Through this, we can easily find similarities in different samples.</p>
			<p>We will dive deeper into the topics of cleaning and analyzing data in <a href="B17928_05_ePub.xhtml#_idTextAnchor085"><em class="italic">Chapter 5</em></a>, <em class="italic">Performing Data Analysis and Visualization</em>. </p>
			<p>Having done all these steps, we will have a good understanding of the data we have at hand, and we might already know what we are missing. As the final step in preprocessing our data, we will have a look at creating and transforming features, typically referred to as <strong class="bold">feature engineering</strong>, and creating labels when missing. </p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Defining labels and engineering features</h2>
			<p>In the second part of the preprocessing of data, we will discuss the labeling of data and the actions we can perform on features. To perform these steps, we need the knowledge obtained through the exploratory steps we've discussed so far. Let's start by looking at labeling data.</p>
			<h3>Labeling</h3>
			<p>Let's start with a bummer: this <a id="_idIndexMarker130"/>process is very tedious. Labeling, also called <strong class="bold">annotation</strong>, is the least<a id="_idIndexMarker131"/> exciting part of an ML project yet one of the most important tasks in the whole process. The goal is to feed high-quality training data into the ML algorithms.</p>
			<p>While proper labels greatly help to improve prediction performance, the labeling process will also help you to study the dataset in greater detail. Let me clarify that labeling data requires deep insight and understanding of the context of the dataset and the prediction process, which you should have acquired at this point. If we were, for example, aiming to predict breast cancer using <strong class="bold">computerized tomography</strong> (<strong class="bold">CT</strong>) scans, we would also<a id="_idIndexMarker132"/> need to understand how breast cancer can be detected in CT images to label the data.</p>
			<p>Mislabeling the training data has a couple of <a id="_idIndexMarker133"/>consequences, such as <strong class="bold">label noise</strong>, which you want to avoid as it will affect the performance of every downstream process in the ML pipeline. In some cases, your labeling methodology is dependent on the chosen ML approach for a prediction problem. A good example is the difference between object detection and segmentation, both of which require completely differently labeled data. </p>
			<p>There are some techniques and tooling available to speed up the labeling process that make use of the fact that we can use ML algorithms not only for the desired project but also to learn how to label our data. Such models start proposing labels during your manual annotation of the dataset. </p>
			<h3>Feature engineering</h3>
			<p>In a nutshell, in this step, we will start<a id="_idIndexMarker134"/> transforming the features or adding new features. Obviously, we are not doing such actions on a whim, but rather due to the knowledge we gathered in the previous steps. We might have understood, for example, that the full date and time are far too precise, and we need just the day of the <a id="_idIndexMarker135"/>week or the month. Whatever it might be, we will try to shape and extract what we need. </p>
			<p>Typically, we will perform one of the following actions:</p>
			<ul>
				<li><strong class="bold">Feature creation</strong>: Create new features from a <a id="_idIndexMarker136"/>given set of features or from additional information sources.</li>
				<li><strong class="bold">Feature transformation</strong>: Transform single<a id="_idIndexMarker137"/> features to make them useful and stable for the utilized ML algorithm.</li>
				<li><strong class="bold">Feature extraction</strong>: Create derived <a id="_idIndexMarker138"/>features from the original data.</li>
				<li><strong class="bold">Feature selection</strong>: Choose the most prominent and predictive features.</li>
			</ul>
			<p>We will dive deeper into labeling and the multitude of methods to apply to our features in <a href="B17928_06_ePub.xhtml#_idTextAnchor102"><em class="italic">Chapter 6</em></a>, <em class="italic">Feature Engineering and Labeling</em>. In addition, we will have a detailed look at a more complex example of feature engineering when working with text data in an NLP project. You will find this in <a href="B17928_07_ePub.xhtml#_idTextAnchor112"><em class="italic">Chapter 7</em></a>, <em class="italic">Advanced Feature Extraction with NLP</em>.</p>
			<p>We conclude this step by<a id="_idIndexMarker139"/> reiterating how important the whole preprocessing data steps are and how much influence they have on the next step, where we will discuss model training. Further, we remember that we might need to come back to this after model training in case of lackluster performance of our model. </p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Training models</h2>
			<p>We finally reached the point where we can bring ML algorithms into play. As with data experimentation and preprocessing, training an ML model is an analytical, step-by-step process. Each step involves a thought process that evaluates the pros and cons of each algorithm according to the results of the experimentation phase. As in every other scientific process, it is recommended that you come up with a hypothesis first and verify whether this hypothesis is true afterward.</p>
			<p>Let's look at the steps that define the process of training an ML model, as follows:</p>
			<ol>
				<li value="1"><strong class="bold">Define your ML task</strong>: First, we<a id="_idIndexMarker140"/> need to define the ML task we are facing, which most of the time is defined by the business decision behind your use case. Depending on the amount of labeled data, you can choose between unsupervised and supervised learning methods, as well as many other subcategories.</li>
				<li><strong class="bold">Pick a suitable model</strong>: Pick a suitable model for the chosen ML task. This might be a logistical regression, a gradient-boosted ensemble tree, or a DNN, just to name a few popular ML model choices. The choice is mainly dependent on the training (or production) infrastructure (such as Python, R, Julia, C, and so on) and the shape and type of the data. </li>
				<li><strong class="bold">Pick or implement a loss function and an optimizer</strong>: During the data experimentation phase, you should have already come up with a strategy on how to test your model performance. Hence, you should have picked a data split, loss function, and optimizer already. If you have not done so, you should at this point evaluate what you want to measure and optimize.</li>
				<li><strong class="bold">Pick a dataset split</strong>: Splitting your data into different sets—namely, training, validation, and test sets—gives you additional insights into the performance of your training and optimization process and helps you to avoid overfitting your model to your training data. </li>
				<li><strong class="bold">Train a simple model using cross-validation</strong>: When all the preceding choices are made, you can go ahead and train your ML model. Optimally, this is done as cross-validation on a training and validation set, without leaking training data into validation. After training a baseline model, it's time to interpret the error metric of the validation runs. Does it make sense? Is it as high or low as expected? Is it (hopefully) better than random and better than always predicting the most popular target? </li>
				<li><strong class="bold">Tune the model</strong>: Finally, you can either tune the outcome of the model by working with the so-called hyperparameters of a model, do model stacking or other advanced methods, or you might have to go back to the initial data and work on that before training the model again. </li>
			</ol>
			<p>These are the base steps we perform when training our model. In the following section, we will give some more insights into the aforementioned steps, starting with how to choose a model.</p>
			<h3>Choosing a model</h3>
			<p>When it comes to <a id="_idIndexMarker141"/>choosing a good model for your data, it is recommended that you favor simple traditional models before going toward the more complex options. An example would be ensemble models, such as <strong class="bold">gradient-boosted tree ensembles</strong>, when training data is limited. These <a id="_idIndexMarker142"/>models perform well on a broad set of input values (ordinal, nominal, and numeric) as well as training efficiently, and they are understandable. </p>
			<p>Tree-based ensemble models combine many weak learners into a single predictor based on decision trees. This greatly reduces the problem of the overfitting and instability aspects of a single decision tree. The output, after a few iterations using the default parameter, usually delivers great baseline results for many different applications.</p>
			<p>In <a href="B17928_09_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 9</em></a>, <em class="italic">Building ML Models Using Azure Machine Learning</em>, we dedicate a complete section to training a <a id="_idIndexMarker143"/>gradient-boosted tree ensemble classifier using <strong class="bold">LightGBM</strong>, a popular tree ensemble library from Microsoft.</p>
			<p>To capture the meaning<a id="_idIndexMarker144"/> of large amounts of complex training data, we need large parametric models. However, training parametric models with many hundreds of millions of parameters is no easy task, due to exploding and vanishing gradients, loss propagation through such a complex model, numerical instability, and normalization. In recent years, a branch of such high-parametric models achieved extremely good results through many complex tasks—namely, <strong class="bold">deep learning</strong> (<strong class="bold">DL</strong>).</p>
			<p>DL basically spans up a multilayer ANN, where each layer is seen as a certain step in the data processing pipeline of the model.</p>
			<p>In <a href="B17928_10_ePub.xhtml#_idTextAnchor165"><em class="italic">Chapter 10</em></a>, <em class="italic">Training Deep Neural Networks on Azure</em>, and <a href="B17928_12_ePub.xhtml#_idTextAnchor189"><em class="italic">Chapter 12</em></a>,<em class="italic"> Distributed Machine Learning on Azure</em>, we will delve deeper into how to train large and complex DL models on single machines and on a distributed GPU cluster.</p>
			<p>Finally, you might work with a completely different form of data, such as audio or text data. In such cases, there are specialized ways to preprocess and score this data. One of these fields would be <strong class="bold">recommendation engines</strong>, which we will discuss thoroughly in <a href="B17928_13_ePub.xhtml#_idTextAnchor202"><em class="italic">Chapter 13</em></a>, <em class="italic">Building a Recommendation Engine in Azure</em>.</p>
			<h3>Choosing a loss function and an optimizer </h3>
			<p>As we discussed in the <a id="_idIndexMarker145"/>previous section, there are many metrics to choose from, depending on the type of training and model you want to use. After looking at the<a id="_idIndexMarker146"/> relationship between the feature and target dimensions, as well as the separability of the data, you should continue to evaluate which loss function and optimizer you will use to train your model. </p>
			<p>Many ML practitioners don't value the importance of a proper error metric highly enough and just use what is easy, such as accuracy and RMSE. This choice is critical. Furthermore, it is useful to understand the baseline performance and the model's robustness to noise. The first can be achieved by computing the error metric using only the target variable with the<a id="_idIndexMarker147"/> highest occurrence as a prediction. This will be your baseline performance. The second can be done by modifying the random seed of your ML model and observing the changes to the error metric. This will show you which decimal place you <a id="_idIndexMarker148"/>can trust the error metric to.</p>
			<p>Keep in mind that it is prudent to evaluate the chosen error metric and any additional metric you desire after training runs, and experiment whether others might be more beneficial.</p>
			<p>As for the optimizer, it highly depends on the model you chose as to which options you have in this regard. Just remember the optimizer is how we get to the target, and the target is defined by the loss function.</p>
			<h3>Splitting the dataset</h3>
			<p>Once you have selected an <a id="_idIndexMarker149"/>ML model, a loss function, and an optimizer, you need to think about splitting your dataset for training. Optimally, the data should be split into three disjointed sets: a training, a validation, and a test dataset. We use multiple sets to ensure that the model generalizes well on unseen data and that the reported error metric can be trusted. Hence, you can see that dividing the data into representative sets is a task that should be performed as an analytical process. These sets are defined as follows:</p>
			<ul>
				<li><strong class="bold">Training dataset</strong>: The subset of data used to fit/train the model.</li>
				<li><strong class="bold">Validation dataset</strong>: The subset of data used to provide an evaluation during training to tune hyperparameters. The algorithm sees this data during training, but never learns from it. Therefore, it has an indirect influence on the model.</li>
				<li><strong class="bold">Test dataset</strong>: The subset of data used to run an unbiased evaluation of the trained model after training.</li>
			</ul>
			<p>If training data leaks into the validation or testing set, you risk overfitting the model and skewing the validation and testing results. Overfitting is a problem that you must handle besides underfitting the model. Both are defined as follows:</p>
			<p class="callout-heading">Underfitting versus Overfitting</p>
			<p class="callout">An underfitted model performs purely on the data. The reasons for that are often that the model is too simplistic to understand the relationship between the features and the target variables, or that your initial data is lacking useful features. An overfitted model performs perfectly on the training dataset and purely on any other data. The reason for that is that it basically memorized the training data and is unable to generalize.</p>
			<p>There are different discussions <a id="_idIndexMarker150"/>on what the size of these splits should be and many different further techniques to choose samples for each category, such as stratified splitting (sampling based on class distributions), temporal splitting, and group-based splitting. We will take a deeper look at these in <a href="B17928_09_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 9</em></a>, <em class="italic">Building ML </em><em class="italic">Models Using Azure Machine Learning</em>.</p>
			<h3>Running the model training</h3>
			<p>In most cases, you will not build an ANN structure and an optimizer from scratch. You will use ready-made ML libraries, such as <strong class="bold">scikit-learn</strong>, <strong class="bold">TensorFlow</strong>, or <strong class="bold">PyTorch</strong>. Most of these frameworks and libraries are written in Python, which should therefore be the language of choice for <a id="_idIndexMarker151"/>your ML projects. </p>
			<p>When writing your code for model training, it is a good idea to logically divide the required code into two files, as follows:</p>
			<ul>
				<li><strong class="bold">Authoring script (authoring environment)</strong>: The script that defines the environment (libraries, training location, and so on) in which the ML training will take place and the one triggering the execution script</li>
				<li><strong class="bold">Execution script (execution environment)</strong>: The script that only contains the actual ML training</li>
			</ul>
			<p>By splitting your code in this way, you avoid updating the actual training script when your target environment changes. This will make code versioning and MLOps much cleaner.</p>
			<p>To understand what types of class methods we might encounter in an ML library, let's have a look at a short code snippet from TensorFlow here:</p>
			<p class="source-code">model = tf.keras.models.<strong class="bold">Sequential</strong>([</p>
			<p class="source-code">  tf.keras.layers.Flatten(input_shape=(28, 28)),…])</p>
			<p class="source-code"><strong class="bold">model.compile</strong>(optimizer='adam',</p>
			<p class="source-code">              loss='sparse_categorical_crossentropy',</p>
			<p class="source-code">              metrics=['accuracy'])</p>
			<p class="source-code"><strong class="bold">model.fit</strong>(x_train, y_train, epochs=5)</p>
			<p class="source-code"><strong class="bold">model.evaluate</strong>(x_test, y_test)</p>
			<p>Looking at this code, we see that we are using a model called <strong class="source-inline">Sequential</strong> that is a basic ANN defined by a sequential set of layers with one input and one output. We see in the model creation step that there are layers defined and some omitted other settings. In addition, in the <strong class="source-inline">compile()</strong> method, we define an optimizer, a loss function, and some additional metrics we are interested in. Finally, we see a method called <strong class="source-inline">fit()</strong> running on the training<a id="_idIndexMarker152"/> dataset and a method called <strong class="source-inline">evaluate()</strong> running on the test dataset. Now, what do these methods do exactly? Before we get to that, let's first define something.</p>
			<p class="callout-heading">Hyperparameters versus Parameters of a Model</p>
			<p class="callout">There are two kinds of settings that are adjusted during model training. Settings such as the weights and the bias in an <a id="_idIndexMarker153"/>ANN are referred to as the parameters. They are changed during the training phase. Other settings—such as the activation functions and the number of layers in an ANN, the data split, the learning rate, or the chosen optimizer—are referred to as hyperparameters. Those are the meta settings we adjust before a training run.</p>
			<p>Having this out of the way, let's define the typical methods you will encounter, as follows:</p>
			<ul>
				<li><strong class="bold">Hyperparameter methods</strong>: These are methods<a id="_idIndexMarker154"/> used to define the characteristics of the model. They are often found in the constructor (as for the <strong class="source-inline">Sequential</strong> class), in a special function such as <strong class="source-inline">compile()</strong>, or they are part of the training method we discuss next.</li>
				<li><strong class="bold">Training method</strong>: Often named <strong class="source-inline">fit()</strong> or <strong class="source-inline">train()</strong>, this is the main method that trains the parameter of the model<a id="_idIndexMarker155"/> based on the training dataset, the loss function, and the optimizer. These methods do not return any type of value—they just update the model object and its parameters.</li>
				<li><strong class="bold">Test method</strong>: Often named <strong class="source-inline">evaluate()</strong>, <strong class="source-inline">transform()</strong>, <strong class="source-inline">score()</strong>, or <strong class="source-inline">predict()</strong>. In most cases, these<a id="_idIndexMarker156"/> return some form of result, as they are typically running the test dataset against the trained model.</li>
			</ul>
			<p>This is the typical structure of methods you will encounter for a model in an ML library. Now that we have a<a id="_idIndexMarker157"/> good idea of how to set up our coding environment and use available ML libraries, let's look at how to tune the model after our initial training.</p>
			<h3>Tuning the model</h3>
			<p>After we have trained a <a id="_idIndexMarker158"/>simple ensemble model that performs reasonably better than the baseline model and achieves acceptable performance according to the expected performance estimated during data preparation, we can progress with optimization. This is a point we really want to emphasize. It's strongly discouraged to begin model optimization and stacking when a simple ensemble technique fails to deliver useful results. If this is the case, it would be much better to take a step back and dive deeper into data analysis and feature engineering.</p>
			<p>Common ML optimization techniques—such as hyperparameter optimization, model stacking, and even <strong class="bold">automated machine learning</strong> (<strong class="bold">AutoML</strong>)—help you get the last 10% of performance boost out of your model. </p>
			<p>Hyperparameter optimization concentrates on changing the initial settings of the model training to improve its final performance. Similarly, model stacking is a very common technique used to improve prediction performance by putting a combination of multiple <em class="italic">different</em> model types into a single stacked model. Hence, the output of each model is fed into a meta-model, which itself is trained through cross-validation and hyperparameter tuning. By combining significantly different models into a single stacked model, you can always outperform a single model.</p>
			<p>If you decide to use any of those optimization techniques, it is advised to perform them in parallel and fully automated on a distributed cluster. After seeing too many ML practitioners manually parametrizing, tuning, and stacking models together, we want to raise this important message: <em class="italic">optimizing ML models is boring</em>. </p>
			<p>It should rarely be done <a id="_idIndexMarker159"/>manually as it is much faster to perform it automatically as an end-to-end optimization process. Most of your time and effort should go into experimentation, data preparation, and feature engineering—that is, everything that cannot be easily automated and optimized using raw compute power. We will delve deeper into the topic of model tuning in <a href="B17928_11_ePub.xhtml#_idTextAnchor178"><em class="italic">Chapter 11</em></a>, <em class="italic">Hyperparameter Tuning and Automated Machine Learning</em>.</p>
			<p>This concludes all important topics to know about model training. Next, we will have a look at options for the deployment of ML models.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Deploying models</h2>
			<p>Once you have<a id="_idIndexMarker160"/> trained and optimized an ML model, it is ready for deployment. This step is<a id="_idIndexMarker161"/> typically referred to as <strong class="bold">inferencing</strong> or <strong class="bold">scoring</strong> a model. Many data science teams, in <a id="_idIndexMarker162"/>practice, stop here and move the model to production as a Docker image, often embedded in a <strong class="bold">REpresentational State Transfer</strong> (<strong class="bold">REST</strong>) <strong class="bold">API</strong> using Flask or similar frameworks. However, as you can imagine, this is not always the best solution, depending on your requirements. An ML or data engineer's responsibility doesn't stop here.</p>
			<p>The deployment and operation of an ML pipeline can be best seen when testing the model on live data in production. A test is done to collect insights and data to continuously improve the model. Hence, collecting model performance over time is an essential step to guaranteeing and improving the performance of the model.</p>
			<p>In general, we differentiate two main architectures for ML-scoring pipelines, as follows:</p>
			<ul>
				<li><strong class="bold">Batch scoring using pipelines</strong>: An offline process where you evaluate an ML model against a batch of data. The result of<a id="_idIndexMarker163"/> this scoring technique is usually not time-critical, and the data to be scored is usually larger than the model.</li>
				<li><strong class="bold">Real-time scoring using a container-based web service endpoint</strong>: This refers to a technique where we score single data inputs. This is very common in stream processing, where <a id="_idIndexMarker164"/>single events are scored in real time. It's obvious that this task is highly time-critical, and the execution is blocked until the resulting score is computed.</li>
			</ul>
			<p>We will discuss these two architectures in more detail in <a href="B17928_14_ePub.xhtml#_idTextAnchor217"><em class="italic">Chapter 14</em></a>, <em class="italic">Model Deployments, Endpoints, and Operations</em>. There, we will also investigate an efficient way of collecting runtimes, latency, and other operational metrics, as well as model performance.</p>
			<p>The model files we create, and the <a id="_idIndexMarker165"/>previously mentioned options, are typically defined by a standard hardware architecture. As mentioned, we probably create a Docker image that is deployed to a <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>) or a web service. What if we want to deploy our model to a highly specialized hardware environment, such as a GPU <a id="_idIndexMarker166"/>or a <strong class="bold">field-programmable gate array</strong> (<strong class="bold">FPGA</strong>)? </p>
			<p>To explore this further, we will dive deeper into alternative deployment targets and methods in <a href="B17928_15_ePub.xhtml#_idTextAnchor238"><em class="italic">Chapter 15</em></a>, <em class="italic">Model Interoperability, Hardware Optimization, and Integrations</em>. There, we will have a look at a <a id="_idIndexMarker167"/>framework called <strong class="bold">Open Neural Network eXchange</strong> (<strong class="bold">ONNX</strong>) that allows us to convert our model into a standardized model format to be deployed to virtually any environment. Additionally, we have a look at FPGAs and why they might be a good deployment target for ML, and finally, we will explore other Azure services such as <strong class="bold">Azure IoT Edge</strong> and <strong class="bold">Power BI</strong> for integration.</p>
			<p>This step wraps up the end-to-end process for a single ML model. Next, we will see a short overview of how to make such ML projects operational in an enterprise-grade environment using MLOps.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Developing and operating enterprise-grade ML solutions</h2>
			<p>To operationalize ML projects requires the use of automated pipelines and <strong class="bold">development-operations</strong> (<strong class="bold">DevOps</strong>) methodologies such as <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) and <strong class="bold">continuous delivery</strong>/<strong class="bold">continuous deployment</strong> (<strong class="bold">CD</strong>). These combined are typically referred to as MLOps.</p>
			<p>When looking at the steps we<a id="_idIndexMarker168"/> performed in an ML project, we <a id="_idIndexMarker169"/>can see that there are typically two major operations happening—the training of a model and the deployment of a model. As these can happen independently of one another, it is worthwhile defining two different automated pipelines, as follows:</p>
			<ul>
				<li><strong class="bold">Training pipeline</strong>: This includes loading<a id="_idIndexMarker170"/> datasets (possibly even including an ETL pipeline), transformation, model training, and registering final models. This pipeline could be triggered by changes in the dataset or possible detected data drift in a deployed model.</li>
				<li><strong class="bold">Deployment pipeline</strong>: This includes<a id="_idIndexMarker171"/> loading of models from the registry, creating and deploying Docker images, creating and deploying operational scripts, and the final deployment of the model to the target. This pipeline could be triggered by new versions of an ML model.</li>
			</ul>
			<p>We will have a deep dive into<a id="_idIndexMarker172"/> ML pipelining with Azure Machine Learning in <a href="B17928_08_ePub.xhtml#_idTextAnchor135"><em class="italic">Chapter 8</em></a>,<em class="italic"> Azure Machine Learning Pipelines</em>.</p>
			<p>Having these pipelines, we<a id="_idIndexMarker173"/> can then turn our eye on <strong class="bold">Azure DevOps</strong> besides other tooling. With that, we can build a life cycle for our ML projects defined by the following parts:</p>
			<ul>
				<li><strong class="bold">Creating or retraining a model</strong>: Here, we use training pipelines to create or retrain our model while version-controlling the pipelines and the code.</li>
				<li><strong class="bold">Deploying the model and creating scoring files and dependencies</strong>: Here, we use a deployment pipeline to deploy a specific model version while version-controlling the pipeline and the code.</li>
				<li><strong class="bold">Creating an audit trail</strong>: Through CI/CD pipelines and version control, we create an audit trail for all assets ensuring integrity and compliance.</li>
				<li><strong class="bold">Monitoring model in production</strong>: We monitor the performance and possible data drift, which might automatically trigger retraining of the model.</li>
			</ul>
			<p>We will discuss these topics and others in more detail in <a href="B17928_16_ePub.xhtml#_idTextAnchor252"><em class="italic">Chapter 16</em></a>, <em class="italic">Bringing Models into Production with MLOps</em>.</p>
			<p>This concludes our discussion on the end-to-end ML process and this chapter. If you hadn't already, you should now have a good understanding of ML and what to expect in the rest of the book.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Summary</h1>
			<p>In this chapter, we learned in which situations we should use ML and where it is coming from, we understood basic concepts of statistics and the mathematical knowledge we require for ML, and we discovered the steps we need to go through to create a performing ML model. In addition, we had a first glimpse at what is required to operationalize ML projects. This should give a base idea of what ML is about and what we will dive into in this book. </p>
			<p>As this book not only covers ML but also the cloud platform Azure, in the next two chapters, we will go deeper into a topic that we have not covered so far—we will speak about tooling for ML. Therefore, in the next chapter, we will discover what Azure has to offer in the form of tools and services for ML, and in the third chapter, we will use the most useful tool to run our first hands-on experimentation with ML on Azure. </p>
		</div>
	</div>
</div>
</body></html>