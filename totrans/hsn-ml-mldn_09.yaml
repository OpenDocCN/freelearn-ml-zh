- en: Matrix Factorization Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵分解模型
- en: With anomaly detection models behind us, it is now time to dive into matrix
    factorization models. Matrix factorization is one of the newer additions to ML.NET,
    with a transform of the same name. In this chapter, we will dive into matrix factorization,
    as well as the various applications best suited to utilizing matrix factorization.
    In addition, we will build a new sample application to predict music recommendations
    based on the sample training data. Finally, we will explore how to evaluate a
    matrix factorization model with the properties that ML.NET exposes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在异常检测模型之后，现在是时候深入研究矩阵分解模型了。矩阵分解是ML.NET中较新的添加之一，具有相同的转换名称。在本章中，我们将深入研究矩阵分解，以及最适合利用矩阵分解的各种应用。此外，我们将构建一个新的示例应用程序，根据样本训练数据预测音乐推荐。最后，我们将探讨如何使用ML.NET公开的特性来评估矩阵分解模型。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Breaking down matrix factorizations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破解矩阵分解
- en: Creating a matrix factorization application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建矩阵分解应用程序
- en: Evaluating a matrix factorization model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估矩阵分解模型
- en: Breaking down matrix factorizations
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破解矩阵分解
- en: As mentioned in [Chapter 1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml), *Getting
    Started with Machine Learning and ML.NET*, matrix factorization, by definition,
    is an unsupervised learning algorithm. This means that the algorithm will train
    on data and build a matrix of patterns in user ratings, and during a prediction
    call, will attempt to find like ratings based on the data provided. In this section,
    we will dive into use cases for matrix factorization and have a look into the
    matrix factorization trainer in ML.NET.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml)中所述，《开始使用机器学习和ML.NET》，矩阵分解，按定义，是一种无监督学习算法。这意味着该算法将在数据上训练并构建用户评分的模式矩阵，在预测调用期间，将尝试根据提供的数据找到类似评分。在本节中，我们将深入研究矩阵分解的应用案例，并查看ML.NET中的矩阵分解训练器。
- en: Use cases for matrix factorizations
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵分解的应用案例
- en: Matrix factorizations, as you might be starting to realize, have numerous applications
    where data is available, but the idea is to suggest other matches based on previously
    unselected data. Without needing to do manual spot-checking, matrix factorization
    algorithms train on this unselected data and determine patterns using a key-value
    pair combination. ML.NET provides various matrix factorization values to look
    at programmatically, inside of your application. We will review these values later on
    in this chapter, to better ensure the recommendation was not a false positive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能开始意识到的，矩阵分解在数据可用但基于先前未选择的数据提出其他匹配建议的许多应用中都有用。无需进行手动检查，矩阵分解算法在未选择的数据上训练，并使用键值对组合确定模式。ML.NET提供了各种矩阵分解值，可以在你的应用程序中以编程方式查看。我们将在本章后面回顾这些值，以确保推荐不是假阳性。
- en: 'Some of the potential applications best suited for matrix factorization are:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最适合矩阵分解的应用包括：
- en: Music recommendations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音乐推荐
- en: Product recommendations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品推荐
- en: Movie recommendations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电影推荐
- en: Book recommendations
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍推荐
- en: Effectively, anything where data can be traced back to a single user and then
    built upon as more data is entered can utilize matrix factorizations. This problem
    is called a **cold start** **problem**. Take, for instance, a new music platform
    geared toward helping you to find new bands to listen to. When you first reach
    the site and create a profile, there is no prior data available. You, as the end
    user, must tell the system what you like and don't like. Due to the nature of
    the algorithm, matrix factorization is better suited to this application than
    the straight regression or binary classification algorithms we explored in earlier
    chapters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，任何可以追溯到单个用户的数据，并且随着更多数据的输入而构建的情况都可以利用矩阵分解。这个问题被称为**冷启动**问题。以一个旨在帮助你发现新乐队听的音乐平台为例。当你第一次到达网站并创建个人资料时，没有先前数据可用。作为最终用户，你必须告诉系统你喜欢什么，不喜欢什么。由于算法的性质，矩阵分解比我们在前几章中探讨的直接回归或二元分类算法更适合这个应用。
- en: Diving into the matrix factorization trainer
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解矩阵分解训练器
- en: The matrix factorization trainer is the only traditional trainer found in ML.NET
    as of this writing. The matrix factorization trainer requires both normalization
    of the values and caching. In addition, to utilize matrix factorization in ML.NET, the `Microsoft.ML.Recommender` NuGet
    package is required if you are creating the project from scratch. The included
    sample from the GitHub repository includes this package.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在 ML.NET 中找到的唯一传统训练器是矩阵分解训练器。矩阵分解训练器需要值的归一化和缓存。此外，如果您是从零开始创建项目，则要利用 ML.NET
    中的矩阵分解，需要`Microsoft.ML.Recommender` NuGet 包。GitHub 仓库中包含的示例包括此包。
- en: Similar to other algorithms, normalization is required, but matrix factorization
    is unique. Other algorithms, as we have seen with binary classification or regression
    algorithms, have multiple values that can be normalized. In matrix factorization, there
    are only three values involved: `Label`, `Row`, and `Column` values. The output
    is comprised of two properties: `Score `and `Label`. The `Score` value is of type `Float`,
    non-negative and unbounded.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他算法类似，需要归一化，但矩阵分解是独特的。我们之前看到的二进制分类或回归算法，有多种值可以进行归一化。在矩阵分解中，只有三个值：`Label`、`Row`和`Column`值。输出由两个属性组成：`Score`和`Label`。`Score`值是`Float`类型，非负且无界。
- en: It should be noted that in July 2018's ML.NET 0.3 update, field-aware factorization
    machines were added. However, this type of trainer offered only binary recommendations
    (such as either like or dislike), as opposed to matrix factorization, which supports
    floating-point values of any range. This provides considerably better flexibility
    in usage, such as getting more granular predictions. If, for instance, a matrix
    factorization recommendation on a scale from 0 to 100 returned 30, the recommendation
    engine would more than likely return a negative recommendation. With simply a
    binary response, the application—and thereby the end-user—is not shown how strong
    the recommendation is either way.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，在 2018 年 7 月的 ML.NET 0.3 更新中，添加了字段感知因子机。然而，此类训练器仅提供二进制推荐（例如喜欢或不喜欢），而与支持任何范围的浮点值的矩阵分解不同。这提供了相当大的使用灵活性，例如获得更细粒度的预测。例如，如果矩阵分解推荐在
    0 到 100 的范围内返回 30，则推荐引擎很可能返回一个负面的推荐。而仅仅是一个二进制响应，应用程序以及最终用户都没有看到推荐的强度。
- en: We will demonstrate this trainer in the sample application later, in the next
    section, by providing music recommendations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节通过提供音乐推荐来演示此训练器。
- en: Creating a matrix factorization application
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建矩阵分解应用程序
- en: As mentioned earlier, the application we will be creating is for music prediction.
    Given a UserID, MusicID, and a rating, the algorithm will use that data to create
    recommendations. As with other applications, this is not meant to power the next
    Spotifyesque machine learning product; however, it will show you how to use matrix
    factorization in ML.NET.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将创建的应用程序是用于音乐预测。给定 UserID、MusicID 和评分，算法将使用这些数据创建推荐。与其他应用程序一样，这并不是要推动下一个类似
    Spotify 的机器学习产品；然而，它将向您展示如何在 ML.NET 中使用矩阵分解。
- en: As with previous chapters, the completed project code, sample dataset, and project
    files can be downloaded here: [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter07](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter07).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，完整的项目代码、示例数据集和项目文件可以在此处下载：[https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter07](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter07).
- en: Exploring the project architecture
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索项目架构
- en: Building on the project architecture and code we created in previous chapters,
    the bulk of the changes are in the training of the model, as matrix factorization requires
    a fairly significant paradigm shift from what we have reviewed in previous chapters.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中创建的项目架构和代码的基础上，大部分更改都在模型的训练中，因为矩阵分解需要从我们之前章节中回顾的内容进行相当大的范式转变。
- en: 'In the following screenshot, you will find the Visual Studio Solution Explorer
    view of the project. The new additions to the solution are the `MusicRating`and `MusicPrediction`files,
    which we will review later in this section:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您将找到项目的 Visual Studio 解决方案资源管理器视图。解决方案的新增内容包括`MusicRating`和`MusicPrediction`文件，我们将在本节稍后进行回顾：
- en: '![](img/d3568d52-b3fd-48a1-8630-72b8c1bebf0d.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3568d52-b3fd-48a1-8630-72b8c1bebf0d.png)'
- en: 'The `sampledata.csv` file contains 10 rows of random music ratings. Feel free
    to adjust the data to fit your own observations, or to adjust the trained model.
    Here is a snippet of the data:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampledata.csv` 文件包含 10 行随机的音乐评分。您可以随意调整数据以适应您的观察，或者调整训练模型。以下是数据的一个片段：'
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each of these rows contains the value for the properties in the newly created `MusicRating`class
    that we will review later on in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都包含我们将在此章节稍后审查的 `MusicRating` 类中属性的价值。
- en: 'In addition to this, we added the `testdata.csv` file that contains additional
    data points to test the newly trained model against and evaluate. Here is a snippet
    of the data inside of `testdata.csv`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还添加了 `testdata.csv` 文件，其中包含额外的数据点以测试新训练的模型并评估。以下是 `testdata.csv` 内的数据片段：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Diving into the code
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入代码分析
- en: For this application, as noted in the previous section, we are building on top
    of the work completed in [Chapter 6](4e2ca910-b4a8-4f00-b8e4-5f2cf7ee5222.xhtml), *Anomaly
    Detection Model*. For this deep dive, we are going to focus solely on the code
    that was changed for this application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用，正如前一个章节所述，我们是在[第 6 章](4e2ca910-b4a8-4f00-b8e4-5f2cf7ee5222.xhtml)完成的工作基础上构建的，*异常检测模型*。对于这次深入研究，我们将专注于这个应用中更改的代码。
- en: 'Classes that were changed or added are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 修改或添加的类如下：
- en: '`MusicRating`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MusicRating`'
- en: '`MusicPrediction`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MusicPrediction`'
- en: '`Predictor`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Predictor`'
- en: '`Trainer`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trainer`'
- en: '`Constants`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Constants`'
- en: The MusicRating class
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`MusicRating` 类'
- en: 'The `MusicRating`class is the container class that contains the data to both
    predict and train our model. As described in previous chapters, the number in
    the `LoadColumn` decorator maps to the index in the CSV files. As noted in the
    earlier section, matrix factorization in ML.NET requires the use of normalization,
    as shown in the following code block:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`MusicRating` 类是包含预测和训练模型所需数据的容器类。如前几章所述，`LoadColumn` 装饰器中的数字映射到 CSV 文件中的索引。正如前面章节所述，ML.NET
    中的矩阵分解需要使用归一化，如下面的代码块所示：'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The MusicPrediction class
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`MusicPrediction` 类'
- en: 'The `MusicPrediction`class contains the properties mapped to our prediction
    output. The `Score` contains the likelihood the prediction is accurate. We will
    review these values later on in this section, but for now, they can be seen in
    the following code block:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`MusicPrediction` 类包含映射到预测输出的属性。`Score` 包含预测准确的概率。我们将在本节稍后审查这些值，但现在它们可以在以下代码块中看到：'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Predictor class
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Predictor` 类'
- en: 'There are a couple of changes in this class to handle the music-prediction
    scenario, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中有一两个更改来处理音乐预测场景，如下所示：
- en: 'First, we create our prediction engine with the `MusicRating`and `MusicPrediction` types,
    like this:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用 `MusicRating` 和 `MusicPrediction` 类型创建我们的预测引擎，如下所示：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we read the input file into a string object, like this:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将输入文件读取到字符串对象中，如下所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '3\. Next, we deserialize the string into an object of type `MusicRating`, like
    this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 接下来，我们将字符串反序列化为 `MusicRating` 类型的对象，如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, we need to run the prediction, and then output the results of the model
    run, as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要运行预测，然后输出模型运行的结果，如下所示：
- en: '[PRE7]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the transform only returning the three-element vector, the original row
    data is outputted to give context.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于转换只返回三个元素的向量，原始行数据被输出以提供上下文。
- en: The Trainer class
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Trainer` 类'
- en: 'Inside the `Trainer` class, several modifications need to be made to support
    the matrix factorization. In many ways, a simplification is required due to the
    nature of only having three inputs:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `Trainer` 类中，需要做出一些修改以支持矩阵分解。由于只有三个输入的性质，在很多方面都需要简化：
- en: 'The first addition is the two constant variables for the variable encoding,
    shown in the following code block:'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个增加的是两个用于变量编码的常量变量，如下面的代码块所示：
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then build the `MatrixFactorizationTrainer` options. The `Row` and `Column`
    properties are set to the column names previously defined. The `Quiet` flag displays
    additional model building information on every iteration, as illustrated in the
    following code block:'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们构建 `MatrixFactorizationTrainer` 选项。`Row` 和 `Column` 属性设置为之前定义的列名。`Quiet`
    标志在每次迭代时显示额外的模型构建信息，如下面的代码块所示：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can then create the matrix factorization trainer, as follows:'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建矩阵分解训练器，如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we fit the model on the training data and save the model, as follows:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将模型拟合到训练数据中并保存模型，如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Lastly, we load the testing data and pass the data to the matrix factorization
    evaluator, like this:'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们加载测试数据并将数据传递给矩阵分解评估器，如下所示：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Constants class
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常数类
- en: 'In addition, given the training only requires the training data, some modifications
    to the `Program` class need to be performed, as follows:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，由于训练过程仅需要训练数据，因此需要对`Program`类进行一些修改，如下所示：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Running the application
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'To run the application, the process is nearly identical to Chapter 6''s sample
    application, as follows:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要运行应用程序，过程几乎与第6章的示例应用程序相同，如下所示：
- en: 'After preparing the data, we must then train the model by passing in the newly
    created `sampledata.csv` file, like this:'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好数据后，我们必须通过传递新创建的`sampledata.csv`文件来训练模型，如下所示：
- en: '[PRE14]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To run the model with this file, simply pass the `testdata.csv` filementioned
    earlier into the newly built application, and the predicted output will show the
    following:'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用此文件运行模型，只需将前面提到的`testdata.csv`文件传递给新构建的应用程序，预测输出将显示以下内容：
- en: '[PRE16]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Prior to running the prediction, create a JSON file in Notepad with the following
    text:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在运行预测之前，在记事本中创建一个包含以下文本的JSON文件：
- en: '[PRE17]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then save the file to your output folder.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后将文件保存到你的输出文件夹。
- en: 'Then, run the prediction, like this:'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行预测，如下所示：
- en: '[PRE18]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Feel free to modify the values, and see how the prediction changes based on
    the dataset that the model was trained on. A few areas of experimentation from
    this point might be to:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随意修改这些值，并查看基于模型训练的数据集，预测如何变化。从这个点开始，一些实验的领域可能包括：
- en: Change the hyperparameters mentioned in the `Trainer` class deep dive.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`Trainer`类深入探讨中提到的超参数。
- en: Add diversification and more data points to the training and test data.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向训练和测试数据添加多样化和更多数据点。
- en: Evaluating a matrix factorization model
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估矩阵分解模型
- en: As discussed in previous chapters, evaluating a model is a critical part of
    the overall model-building process. A poorly trained model will only provide inaccurate
    predictions. Fortunately, ML.NET provides many popular attributes to calculate
    model accuracy based on a test set at the time of training, to give you an idea
    of how well your model will perform in a production environment.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前几章所述，评估模型是整个模型构建过程中的关键部分。一个训练不良的模型只会提供不准确的预测。幸运的是，ML.NET在训练时提供了许多流行的属性来计算模型准确度，基于测试集来给你一个关于你的模型在生产环境中表现如何的直观印象。
- en: 'As noted earlier in the sample application, for matrix factorization model
    evaluation in ML.NET, there are five properties that comprise the `RegressionMetrics`class
    object. Let us dive into the properties exposed in the `RegressionMetrics`object
    here:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述，在ML.NET中评估矩阵分解模型时，有五个属性构成了`RegressionMetrics`类对象。让我们深入了解`RegressionMetrics`对象中公开的属性：
- en: Loss function
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 损失函数
- en: '**Mean Squared Error** (**MSE**)'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**均方误差**（**MSE**）'
- en: '**Mean Absolute Error** (**MAE**)'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平均绝对误差**（**MAE**）'
- en: R-squared
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: R平方
- en: '**Root Mean Squared Error** (**RMSE**)'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**均方根误差**（**RMSE**）'
- en: In the next sections, we will break down how these values are calculated, and
    detail the ideal values to look for.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将分解这些值的计算方法，并详细说明理想值。
- en: Loss function
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 损失函数
- en: This property uses the loss function set when the matrix factorization trainer
    was initialized. In the case of our matrix factorization example application,
    we used the default constructor, which defaults to the `SquaredLossRegression` class.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此属性使用在矩阵分解训练器初始化时设置的损失函数。在我们的矩阵分解示例应用程序中，我们使用了默认构造函数，它默认为`SquaredLossRegression`类。
- en: 'Other regression loss functions offered by ML.NET are:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ML.NET提供的其他回归损失函数包括：
- en: Squared-loss one class
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平方损失单类
- en: Squared-loss regression
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平方损失回归
- en: The idea behind this property is to allow some flexibility when it comes to
    evaluating your model compared to the other four properties, which use fixed algorithms
    for evaluation.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个属性的目的是在评估模型时提供一些灵活性，与其他四个属性相比，这四个属性使用固定的算法进行评估。
- en: MSE
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 均方误差（MSE）
- en: 'MSE is defined as the measure of the average of the squares of the errors.
    To put this simply, take the plot shown in the following screenshot:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 均方误差（MSE）定义为误差平方的平均值。简单来说，就是查看以下截图所示的图表：
- en: '![](img/f8a787c2-7855-4379-a5a3-8c40633dadf7.png)'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/f8a787c2-7855-4379-a5a3-8c40633dadf7.png)'
- en: The dots correlate to data points for our model, while the blue line is the
    prediction line. The distance between the red dots and the prediction line is
    the error. For MSE, the value is calculated based on these points and their distances
    to the line. From that value, the mean is calculated. For MSE, the smaller the
    value, the better the fitting, and the more accurate the predictions you will
    have with your model.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些点代表我们模型的数据点，而蓝色线是预测线。红色点与预测线之间的距离是误差。对于均方误差（MSE），该值是基于这些点及其到线的距离计算的。从这个值中，计算平均值。对于MSE，值越小，拟合越好，使用你的模型得到的预测将越准确。
- en: MSE is best used to evaluate models when outliers are critical to the prediction
    output.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MSE最适合在异常值对预测输出至关重要时评估模型。
- en: MAE
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: MAE
- en: MAE is similar to MSE, with the critical difference being that it sums the distances
    between the points and the prediction lines, as opposed to computing the mean.
    It should be noted that MAE does not take into account directions in calculating
    the sum. For instance, if you had two data points equal distance from the line,
    one above and the other below, in effect this would be balanced out with a positive
    and negative value. In machine learning, this is referred to as **Mean Bias Error**
    (**MBE**). However, ML.NET does not provide this as part of the `RegressionMetrics` class
    at the time of this writing.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MAE与MSE相似，关键区别在于它是对点与预测线之间的距离求和，而不是计算平均值。需要注意的是，MAE在计算总和时不考虑方向。例如，如果你有两个与线等距离的数据点，一个在上面，一个在下面，实际上这将通过正负值相互抵消。在机器学习中，这被称为**平均偏差误差**（**MBE**）。然而，ML.NET在撰写本文时并未提供作为`RegressionMetrics`类的一部分。
- en: MAE is best used to evaluate models when outliers are considered simply anomalies,
    and shouldn't be counted in evaluating a model's performance.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MAE最适合在将异常值视为简单异常时评估模型，并且不应计入评估模型性能。
- en: R-squared
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: R-squared
- en: R-squared, also called **the coefficient of determination**, is another method
    of representing how well the prediction compares to the test set. R-squared is
    calculated by taking the difference between each predicted value and its corresponding
    actual value, squaring that difference, then summing the squares for each pair
    of points.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: R-squared，也称为**确定系数**，是另一种表示预测与测试集比较效果的方法。R-squared是通过取每个预测值与其对应实际值之间的差值，平方该差值，然后对每对点的平方和进行求和来计算的。
- en: R-squared values generally range between 0 and 1, represented as a floating-point
    value. A negative value can occur when the fitted model is evaluated to be worse
    than an average fit. However, a low number does not always reflect that the model
    is bad. Predictions, such as the one we looked at in this chapter, that are based
    on predicting human actions are often found to be under 50%.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: R-squared的值通常在0到1之间，表示为浮点数。当拟合模型被评估为比平均拟合更差时，可能会出现负值。然而，低数值并不总是反映模型不好。基于预测人类行为的预测，如我们在本章中看到的，通常发现其值低于50%。
- en: Conversely, higher values aren't necessarily a sure sign of the model's performance,
    as this could be considered as overfitting of the model. This happens in cases
    when there are a lot of features fed to the model, thereby making the model more
    complex as compared to the model we built in the *Creating your first ML.NET application* section
    of [Chapter 2](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml), *Setting Up the ML.NET
    Environment*, as there is simply not enough diversity in the training and test
    sets. For example, if all of the employees were roughly the same values, and then
    the test set holdout was comprised of the same ranges of values, this would be
    considered overfitting.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相反，高值并不一定是模型性能的可靠指标，因为这可能是模型过拟合的迹象。这种情况发生在向模型提供大量特征时，与我们在第2章的“创建第一个ML.NET应用程序”部分中构建的模型相比，模型变得更加复杂。在“设置ML.NET环境”部分中，训练集和测试集的多样性不足。例如，如果所有员工的价值大致相同，并且测试集保留组由相同范围的价值组成，这将被视为过拟合。
- en: RMSE
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: RMSE
- en: 'RMSE is arguably the easiest property to understand, given the previous methods.
    Take the plot shown in the following screenshot:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RMSE可以说是最容易理解的性质，鉴于前面的方法。以下截图显示了以下截图中的图：
- en: '![](img/39c169e9-4a2f-4798-9e73-7dea68e45fbc.png)'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/39c169e9-4a2f-4798-9e73-7dea68e45fbc.png)'
- en: In the case of testing the model, as we did previously with the holdout set,
    the red dots are the actual values from the test set, while the blue dots are
    the predicted values. The X depicted is the distance between the predicted and
    actual values. RMSE simply takes a mean of all of those distances, squares that
    value, and then takes the square root.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在测试模型的情况下，正如我们之前使用保留集所做的，红色点代表测试集的实际值，而蓝色点代表预测值。X 所表示的是预测值和实际值之间的距离。RMSE 简单地取所有这些距离的平均值，然后平方该值，最后取平方根。
- en: A value under 180 is generally considered a good model.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 低于 180 的值通常被认为是一个好的模型。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Over the course of this chapter, we have deep-dived into ML.NET's matrix factorization
    support. We have also created and trained our first matrix factorization application
    to predict music recommendations. Lastly, we also dove into how to evaluate a
    matrix factorization model and looked at the various properties that ML.NET exposes
    to achieve a proper evaluation of a matrix factorization model.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们深入探讨了 ML.NET 的矩阵分解支持。我们还创建并训练了我们的第一个矩阵分解应用程序，用于预测音乐推荐。最后，我们还深入了解了如何评估矩阵分解模型，并查看了
    ML.NET 提供的各种属性，以实现矩阵分解模型的正确评估。
- en: With this chapter coming to a close, we have also completed our initial investigation
    of the various models ML.NET provides. In the next chapter, we will be creating
    full applications, building on the knowledge garnered over the last few chapters,
    with the first being a full .NET Core application providing stock forecasting.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随着本章的结束，我们也完成了对 ML.NET 提供的各种模型的初步调查。在下一章中，我们将创建完整的应用程序，基于前几章所获得的知识，第一个将是一个完整的
    .NET Core 应用程序，提供股票预测。
