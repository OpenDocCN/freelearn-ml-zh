- en: Fuzzy Logic – Navigating the Obstacle Course
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊逻辑 – 在障碍赛道中导航
- en: '**Fuzzy logic**. Another one of those buzzword-compliant terms you hear all
    the time. But what does it really mean, and could it mean more than one thing?
    We are about to find out just that. We will use fuzzy logic to help guide an autonomous
    vehicle around an obstacle course, and if we do it correctly, we will avoid obstacles
    along the way. Our **automated guided vehicle** (**AGV**) will navigate its way
    around the obstacle course, sensing for obstacles in its path. It will use an
    inference system to help guide it along. You, the user, will be able to create
    obstacles or throughways, which the AGV either must avoid or can utilize. You
    can watch the tracking beams work as well as track the path of the AGV along its
    course. Each step the AGV takes will be updated on the user interface so that
    you can see what is going on.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**模糊逻辑**。这是那些你经常听到的 buzzword-compliant 术语之一。但它究竟意味着什么，它是否意味着不止一件事？我们马上就要找出答案了。我们将使用模糊逻辑来帮助引导自动驾驶车辆绕过障碍赛道，如果我们做得正确，我们将避免途中的障碍。我们的**自动导引车**（**AGV**）将绕过障碍赛道导航，感知其路径上的障碍。它将使用推理系统来帮助引导。作为用户，你将能够创建障碍或通道，AGV要么必须避开，要么可以利用。你可以观看追踪光束的工作，以及跟踪AGV在其路径上的行进。AGV每迈出的一步都会在用户界面上更新，这样你就可以看到发生了什么。'
- en: In Boolean logic, things are either true or false, on or off, black or white.
    What many people do not know is that there is also what is known as **many-valued
    logic**, where the truth lies somewhere between 1 and 0\. Fuzzy logic is a conceptual
    implementation of many-valued logic that handles partial truth. What many people
    also do not know is that the famous sigmoid function, which you will hear of later,
    in our chapter on activation functions, is a fuzzification method.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在布尔逻辑中，事物要么是真的，要么是假的，要么是开，要么是关，要么是黑，要么是白。许多人不知道的是，还有一种被称为**多值逻辑**的逻辑，其中真值介于1和0之间。模糊逻辑是多值逻辑的概念实现，它处理部分真值。许多人也不知道的是，你将在我们关于激活函数的章节中听到的著名sigmoid函数，实际上是一种模糊化方法。
- en: 'Wikipedia has a great visual of this, as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科有一个很好的视觉表示，如下所示：
- en: '![](img/dda03ae2-295a-4898-9fd4-7d78c8312853.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dda03ae2-295a-4898-9fd4-7d78c8312853.png)'
- en: 'According to Wikipedia:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科：
- en: '"In this image, the meanings of the expressions cold, warm, and hot are represented
    by functions mapping a temperature scale. A point on that scale has three "truth
    values"-one for each of the three functions. The vertical line in the image represents
    a particular temperature that the three arrows (truth values) gauge. Since the
    red arrow points to zero, this temperature may be interpreted as "not hot". The
    orange arrow (pointing at 0.2) may describe it as "slightly warm" and the blue
    arrow (pointing at 0.8) "fairly cold"."'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '"在这张图中，冷、暖和热这些表达的含义是通过映射温度尺度的函数来表示的。该尺度上的一个点有三个“真值”——每个函数对应一个。图中的垂直线代表三个箭头（真值）所测量的特定温度。由于红色箭头指向零，这个温度可以解释为“不热”。橙色箭头（指向0.2）可能描述它为“略微温暖”，而蓝色箭头（指向0.8）则“相当冷”。"'
- en: This diagram and description are a very accurate representation of what we are
    about to delve into. Why do we show this? Because our first example is going to
    show exactly this. To illustrate fuzzy logic, we will be using the AForge.NET
    open source machine learning framework. For a user, it is an excellent framework
    to show how easy it is to use the inference engine to accomplish tasks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表和描述非常准确地代表了我们将要深入探讨的内容。我们为什么要展示这个？因为我们的第一个例子将正好展示这一点。为了说明模糊逻辑，我们将使用AForge.NET开源机器学习框架。对于用户来说，这是一个展示如何轻松使用推理引擎来完成任务的优秀框架。
- en: 'In this chapter we will cover:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Fuzzy logic
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊逻辑
- en: Autonomously guided vehicles
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自主导引车辆
- en: Obstacle avoidance and recognition
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 障碍物避让和识别
- en: Fuzzy logic
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊逻辑
- en: 'Our application will have two simple buttons, one for running the fuzzy set
    test and the other for running the linguistic variable test. Here is a quick snapshot
    of what our example application will look like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将有两个简单的按钮，一个用于运行模糊集测试，另一个用于运行语言变量测试。以下是我们示例应用程序的快速快照：
- en: '![](img/a95d0ce8-a83f-4978-8825-bb0041f0d2ba.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a95d0ce8-a83f-4978-8825-bb0041f0d2ba.png)'
- en: 'The code to create this sample is relatively small and simple. Here is what
    it looks like when we click on the Run Fuzzy Set Test button. We will create two
    fuzzy sets (one for Cool and one for Warm), add some membership data values for
    each, and then plot them:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此示例的代码相对较小且简单。当我们点击运行模糊集测试按钮时，它看起来是这样的。我们将创建两个模糊集（一个用于凉爽，一个用于温暖），为每个添加一些隶属度数据值，然后绘制它们：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code for running the linguistic variable test is as follows. Again, we
    create fuzzy sets, but this time we create four instead of two. As with our first
    test, we add membership data and then plot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 运行语言变量测试的代码如下。同样，我们创建模糊集，但这次我们创建了四个而不是两个。就像我们的第一个测试一样，我们添加隶属度数据然后绘制：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And finally we chart the values:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们绘制这些值：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Linguistic variable shape:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 语言变量形状：
- en: '![](img/78d3c1c5-8a9c-4fb8-a2ec-4e76a08f8d62.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/78d3c1c5-8a9c-4fb8-a2ec-4e76a08f8d62.png)'
- en: As you can see, we were able to easily show the exact visual definition and
    clarity that the Wikipedia definition presented.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们能够轻松地展示出维基百科定义所呈现的精确视觉定义和清晰度。
- en: Fuzzy AGV
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊AGV
- en: 'In this example, we are going to go more in depth than we did for our first
    example. Before we go any further, let me show you what our application will look
    like, and then a brief explanation of an inference engine is in order:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将比我们第一个例子更深入地探讨。在我们继续之前，让我先向您展示我们的应用程序将是什么样子，然后简要解释一下推理引擎：
- en: '![](img/6462a37e-0518-402b-aa89-d3c38ae894bd.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6462a37e-0518-402b-aa89-d3c38ae894bd.png)'
- en: 'Although AForge.NET makes it very easy and transparent for us to create an
    `InferenceSystem` object, we should probably start first by telling you a little
    bit about what such a system is. A fuzzy inference system is a model capable of
    executing fuzzy computing. This is accomplished using a database, linguistic variables
    and a rule base, all of which can be in memory. The typical operation of a fuzzy
    inference system is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然AForge.NET使我们创建`InferenceSystem`对象变得非常简单和透明，但我们可能首先应该向您简要介绍一下这样一个系统是什么。模糊推理系统是一个能够执行模糊计算的模型。这是通过使用数据库、语言变量和规则库来实现的，所有这些都可以在内存中。模糊推理系统的典型操作如下：
- en: Get the numeric inputs
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数值输入
- en: Utilize the database with the linguistic variables to obtain linguistic meaning
    for each numerical input
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用包含语言变量的数据库来获取每个数值输入的语言意义
- en: Verify which rules from the rule base are activated by the input
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证哪些规则从规则库中被激活
- en: Combine the results of the activated rules to obtain a fuzzy output
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将激活的规则的结果组合起来以获得模糊输出
- en: For us, the part where most of the work will be performed is in initializing
    our fuzzy logic system. Let's break this down into our individual steps as previously
    outlined.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，大部分工作将在初始化我们的模糊逻辑系统中完成。让我们将其分解为我们之前概述的各个步骤。
- en: 'First, we prepare the linguistic labels (fuzzy sets) that compose the distances
    we will have. They are `Near`, `Medium`, and `Far`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们准备构成我们将拥有的距离的语言标签（模糊集），它们是`近`、`中`和`远`：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we initialize the linguistic variables we''ll need. The first, `lvRight`,
    will be an input variable for the right distance measurement:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化我们将需要的语言变量。第一个，`lvRight`，将是一个用于右侧距离测量的输入变量：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we do the same for the left distance input measurement:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对左侧距离输入测量也做同样的处理：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our last linguistic variable will be for the front distance measurement:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一个语言变量将用于前距离测量：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now focus on the linguistic labels (fuzzy sets) that compose the angle.
    We need to do this step so that we can create our final linguistic variable:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们专注于构成角度的语言标签（模糊集）。我们需要执行这一步骤，以便我们可以创建我们的最终语言变量：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can create our final linguistic variable for the angle:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建我们的最终语言变量，用于角度：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now move on to creating our fuzzy database. For our application, this
    is an in-memory dictionary of linguistic variables, but there is no reason you
    can''t implement it as a SQL, NoSQL, or any other type of concrete database, should
    you so desire:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续创建我们的模糊数据库。对于我们的应用程序，这是一个内存中的语言变量字典，但如果你愿意，没有理由你不能将其实现为一个SQL、NoSQL或任何其他类型的具体数据库：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we will create the main inference engine. What is most interesting about
    this next line of code is the `CentroidDifuzzifier`. At the end of our inference
    process, we are going to need a numeric value to control other parts of the process.
    In order to obtain this number, a defuzzification method is performed. Let me
    explain it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建主要推理引擎。接下来这一行代码最有趣的地方是 `CentroidDifuzzifier`。在我们推理过程的末尾，我们需要一个数值来控制过程的其它部分。为了获得这个数值，执行去模糊化方法。让我解释一下。
- en: 'The output of our fuzzy inference system is a set of rules with a firing strength
    greater than zero. This firing strength applies a constraint to the consequent
    fuzzy sets of the rules. When we put all those fuzzy sets together, they result
    in a shape that is the linguistic output meaning. The centroid method will calculate
    the center of the area of our shape to obtain the numerical representation of
    the output. It uses numerical approximation, so several intervals will be chosen.
    As the number of intervals increases, so does the precision of our output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模糊推理系统的输出是一组具有大于零的激发强度的规则。这种激发强度对规则的后续模糊集施加约束。当我们把所有这些模糊集放在一起时，它们的结果是一个形状，表示语言输出意义。质心法将计算我们形状区域的中心，以获得输出的数值表示。它使用数值近似，因此将选择几个区间。随着区间数量的增加，我们输出的精度也增加：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we can start adding the rules to our inference system:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以开始向我们的推理系统添加规则：
- en: '![](img/bb9364a6-0fa2-4277-85cd-41b48d8cf5a0.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb9364a6-0fa2-4277-85cd-41b48d8cf5a0.png)'
- en: After all this work, our inference system is ready to go!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些工作之后，我们的推理系统准备就绪！
- en: 'The main code loop for our application will look like this. We will describe
    each function in detail:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的主要代码循环将看起来像这样。我们将详细描述每个函数：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's take a quick look at the `GetMeasures` function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下 `GetMeasures` 函数。
- en: 'After getting the current bitmap as well as the position of our AGV, we call
    the `HandleAGVOnWall` function, which handles the scenario where our AGV is up
    against a wall and has nowhere to move. After this, `DrawAGV` handles drawing
    our AGV within our map. Finally, `RefreshTerrain` does exactly what its name implies:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取当前位图以及我们的 AGV 位置后，我们调用 `HandleAGVOnWall` 函数，该函数处理我们的 AGV 靠墙且无处可移动的情况。之后，`DrawAGV`
    处理在地图中绘制我们的 AGV。最后，`RefreshTerrain` 函数正是其名称所暗示的：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`DrawAGV` gets any obstacles in front of us, to the left and to the right.
    If you have the Show Beams checkbox selected, you will see the front, left, and
    right beam avoidance detectors displayed:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawAGV` 获取我们面前、左侧和右侧的任何障碍物。如果你选中了“显示光束”复选框，你将看到前、左和右光束避障检测器显示：'
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `DoInference` function runs one epoch (instance, generation, and so on)
    of our fuzzy inference system. Ultimately, it is responsible for determining the
    next angle of our AGV.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoInference` 函数运行我们模糊推理系统的一个纪元（实例、生成等）。最终，它负责确定我们 AGV 的下一个角度。'
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `MoveAGV` function is responsible for moving our AGV one step. Approximately
    50% of the code in this function is dedicated to drawing the historical trajectory
    of your AGV if you have Track Path checked:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveAGV` 函数负责将我们的 AGV 移动一步。大约 50% 的代码在这个函数中是专门用于绘制你的 AGV 的历史轨迹，如果你勾选了“跟踪路径”：'
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The main application with Show Beams selected:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“显示光束”的主要应用：
- en: '![](img/fb6a16c0-f7d0-44b8-bc20-4a7ceebe3f0d.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb6a16c0-f7d0-44b8-bc20-4a7ceebe3f0d.png)'
- en: 'With our application running, the AGV is successfully navigating obstacles
    and both the path and the beams are displayed. Angle is the angle that our AGV
    is currently facing, and the sensor readings relate to the front, left, and right
    beam sensors being displayed:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序运行时，AGV 成功地导航障碍物，路径和光束都显示出来。角度是 AGV 当前面对的角度，传感器读数与显示的前、左、右光束传感器相关：
- en: '![](img/87ac468b-2c87-4fe5-a07d-b945909592a1.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87ac468b-2c87-4fe5-a07d-b945909592a1.png)'
- en: 'Our AGV is making a successful complete pass through the obstacle course and
    continuing on:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 AGV 正在成功完成障碍课程并通过：
- en: '![](img/7d199b8f-9732-4772-8656-66974d25dfd1.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d199b8f-9732-4772-8656-66974d25dfd1.png)'
- en: 'Track Path and Show Beams can be separately selected:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可以分别选择“跟踪路径”和“显示光束”：
- en: '![](img/8de50b78-3434-4fc5-98ad-1ecb5f4fb606.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8de50b78-3434-4fc5-98ad-1ecb5f4fb606.png)'
- en: 'This shows how, using the left and right mouse buttons, we can add obstacles
    and gateways to obstruct and allow the AGV to pass through, respectively:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了如何使用左右鼠标按钮添加障碍物和通道，分别阻止和允许 AGV 通过：
- en: '![](img/9f480da2-fa75-4d2c-b1e5-8725c66c4193.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f480da2-fa75-4d2c-b1e5-8725c66c4193.png)'
- en: Summary
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we learned about various types of fuzzy logic implementation
    and saw exactly how easy it was to add this logic to our application using AForge.NET.
    In our next chapter, we will embark on a journey deep into self-organizing maps,
    taking our machine learning repertoire to the next level. If you remember your
    art classes from elementary school, this chapter is sure to bring back memories!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了各种模糊逻辑的实现方式，并亲眼见证了使用 AForge.NET 将这种逻辑添加到我们的应用程序是多么简单。在下一章中，我们将深入探索自组织图，将我们的机器学习技能提升到新的水平。如果你还记得你小学时的美术课，那么这一章一定会唤起你的回忆！
- en: References
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'AForge.NET: Copyright © AForge.NET, 2006-2013'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'AForge.NET: 版权所有 © AForge.NET, 2006-2013'
