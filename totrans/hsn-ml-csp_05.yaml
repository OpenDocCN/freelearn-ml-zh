- en: Fuzzy Logic – Navigating the Obstacle Course
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Fuzzy logic**. Another one of those buzzword-compliant terms you hear all
    the time. But what does it really mean, and could it mean more than one thing?
    We are about to find out just that. We will use fuzzy logic to help guide an autonomous
    vehicle around an obstacle course, and if we do it correctly, we will avoid obstacles
    along the way. Our **automated guided vehicle** (**AGV**) will navigate its way
    around the obstacle course, sensing for obstacles in its path. It will use an
    inference system to help guide it along. You, the user, will be able to create
    obstacles or throughways, which the AGV either must avoid or can utilize. You
    can watch the tracking beams work as well as track the path of the AGV along its
    course. Each step the AGV takes will be updated on the user interface so that
    you can see what is going on.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In Boolean logic, things are either true or false, on or off, black or white.
    What many people do not know is that there is also what is known as **many-valued
    logic**, where the truth lies somewhere between 1 and 0\. Fuzzy logic is a conceptual
    implementation of many-valued logic that handles partial truth. What many people
    also do not know is that the famous sigmoid function, which you will hear of later,
    in our chapter on activation functions, is a fuzzification method.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Wikipedia has a great visual of this, as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dda03ae2-295a-4898-9fd4-7d78c8312853.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: 'According to Wikipedia:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '"In this image, the meanings of the expressions cold, warm, and hot are represented
    by functions mapping a temperature scale. A point on that scale has three "truth
    values"-one for each of the three functions. The vertical line in the image represents
    a particular temperature that the three arrows (truth values) gauge. Since the
    red arrow points to zero, this temperature may be interpreted as "not hot". The
    orange arrow (pointing at 0.2) may describe it as "slightly warm" and the blue
    arrow (pointing at 0.8) "fairly cold"."'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: This diagram and description are a very accurate representation of what we are
    about to delve into. Why do we show this? Because our first example is going to
    show exactly this. To illustrate fuzzy logic, we will be using the AForge.NET
    open source machine learning framework. For a user, it is an excellent framework
    to show how easy it is to use the inference engine to accomplish tasks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzy logic
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autonomously guided vehicles
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obstacle avoidance and recognition
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzy logic
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application will have two simple buttons, one for running the fuzzy set
    test and the other for running the linguistic variable test. Here is a quick snapshot
    of what our example application will look like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a95d0ce8-a83f-4978-8825-bb0041f0d2ba.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: 'The code to create this sample is relatively small and simple. Here is what
    it looks like when we click on the Run Fuzzy Set Test button. We will create two
    fuzzy sets (one for Cool and one for Warm), add some membership data values for
    each, and then plot them:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code for running the linguistic variable test is as follows. Again, we
    create fuzzy sets, but this time we create four instead of two. As with our first
    test, we add membership data and then plot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And finally we chart the values:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Linguistic variable shape:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78d3c1c5-8a9c-4fb8-a2ec-4e76a08f8d62.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: As you can see, we were able to easily show the exact visual definition and
    clarity that the Wikipedia definition presented.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzy AGV
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we are going to go more in depth than we did for our first
    example. Before we go any further, let me show you what our application will look
    like, and then a brief explanation of an inference engine is in order:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6462a37e-0518-402b-aa89-d3c38ae894bd.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'Although AForge.NET makes it very easy and transparent for us to create an
    `InferenceSystem` object, we should probably start first by telling you a little
    bit about what such a system is. A fuzzy inference system is a model capable of
    executing fuzzy computing. This is accomplished using a database, linguistic variables
    and a rule base, all of which can be in memory. The typical operation of a fuzzy
    inference system is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Get the numeric inputs
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize the database with the linguistic variables to obtain linguistic meaning
    for each numerical input
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify which rules from the rule base are activated by the input
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine the results of the activated rules to obtain a fuzzy output
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For us, the part where most of the work will be performed is in initializing
    our fuzzy logic system. Let's break this down into our individual steps as previously
    outlined.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we prepare the linguistic labels (fuzzy sets) that compose the distances
    we will have. They are `Near`, `Medium`, and `Far`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we initialize the linguistic variables we''ll need. The first, `lvRight`,
    will be an input variable for the right distance measurement:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we do the same for the left distance input measurement:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our last linguistic variable will be for the front distance measurement:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now focus on the linguistic labels (fuzzy sets) that compose the angle.
    We need to do this step so that we can create our final linguistic variable:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can create our final linguistic variable for the angle:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now move on to creating our fuzzy database. For our application, this
    is an in-memory dictionary of linguistic variables, but there is no reason you
    can''t implement it as a SQL, NoSQL, or any other type of concrete database, should
    you so desire:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we will create the main inference engine. What is most interesting about
    this next line of code is the `CentroidDifuzzifier`. At the end of our inference
    process, we are going to need a numeric value to control other parts of the process.
    In order to obtain this number, a defuzzification method is performed. Let me
    explain it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of our fuzzy inference system is a set of rules with a firing strength
    greater than zero. This firing strength applies a constraint to the consequent
    fuzzy sets of the rules. When we put all those fuzzy sets together, they result
    in a shape that is the linguistic output meaning. The centroid method will calculate
    the center of the area of our shape to obtain the numerical representation of
    the output. It uses numerical approximation, so several intervals will be chosen.
    As the number of intervals increases, so does the precision of our output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we can start adding the rules to our inference system:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb9364a6-0fa2-4277-85cd-41b48d8cf5a0.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: After all this work, our inference system is ready to go!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'The main code loop for our application will look like this. We will describe
    each function in detail:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's take a quick look at the `GetMeasures` function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'After getting the current bitmap as well as the position of our AGV, we call
    the `HandleAGVOnWall` function, which handles the scenario where our AGV is up
    against a wall and has nowhere to move. After this, `DrawAGV` handles drawing
    our AGV within our map. Finally, `RefreshTerrain` does exactly what its name implies:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`DrawAGV` gets any obstacles in front of us, to the left and to the right.
    If you have the Show Beams checkbox selected, you will see the front, left, and
    right beam avoidance detectors displayed:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `DoInference` function runs one epoch (instance, generation, and so on)
    of our fuzzy inference system. Ultimately, it is responsible for determining the
    next angle of our AGV.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `MoveAGV` function is responsible for moving our AGV one step. Approximately
    50% of the code in this function is dedicated to drawing the historical trajectory
    of your AGV if you have Track Path checked:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The main application with Show Beams selected:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb6a16c0-f7d0-44b8-bc20-4a7ceebe3f0d.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: 'With our application running, the AGV is successfully navigating obstacles
    and both the path and the beams are displayed. Angle is the angle that our AGV
    is currently facing, and the sensor readings relate to the front, left, and right
    beam sensors being displayed:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87ac468b-2c87-4fe5-a07d-b945909592a1.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: 'Our AGV is making a successful complete pass through the obstacle course and
    continuing on:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d199b8f-9732-4772-8656-66974d25dfd1.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: 'Track Path and Show Beams can be separately selected:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8de50b78-3434-4fc5-98ad-1ecb5f4fb606.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'This shows how, using the left and right mouse buttons, we can add obstacles
    and gateways to obstruct and allow the AGV to pass through, respectively:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f480da2-fa75-4d2c-b1e5-8725c66c4193.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned about various types of fuzzy logic implementation
    and saw exactly how easy it was to add this logic to our application using AForge.NET.
    In our next chapter, we will embark on a journey deep into self-organizing maps,
    taking our machine learning repertoire to the next level. If you remember your
    art classes from elementary school, this chapter is sure to bring back memories!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了各种模糊逻辑的实现方式，并亲眼见证了使用 AForge.NET 将这种逻辑添加到我们的应用程序是多么简单。在下一章中，我们将深入探索自组织图，将我们的机器学习技能提升到新的水平。如果你还记得你小学时的美术课，那么这一章一定会唤起你的回忆！
- en: References
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'AForge.NET: Copyright © AForge.NET, 2006-2013'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'AForge.NET: 版权所有 © AForge.NET, 2006-2013'
