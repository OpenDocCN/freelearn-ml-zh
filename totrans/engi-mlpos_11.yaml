- en: 'Chapter 9: Testing and Securing Your ML Solution'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：测试和确保你的机器学习解决方案安全
- en: In this chapter, we will delve into **Machine Learning** (**ML**) solution testing
    and security aspects. You can expect to get a primer on various types of tests
    to test the robustness and scalability of your ML solution, as well as the knowledge
    required to secure your ML solution. We will look into multiple attacks on ML
    solutions and ways to defend your ML solution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨**机器学习**（**ML**）解决方案的测试和安全方面。您可以期待获得关于测试您机器学习解决方案的鲁棒性和可扩展性的各种测试类型的入门知识，以及确保您的机器学习解决方案所需的知识。我们将探讨对机器学习解决方案的多种攻击以及防御您的机器学习解决方案的方法。
- en: 'In this chapter, we will be learning with examples as we perform load testing
    and security testing for the business use case of weather prediction we have been
    previously working on. We will start by reflecting on the need for testing and
    securing your ML solution and go on to explore the other following topics in the
    chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过执行我们之前一直在工作的天气预测业务用例的负载测试和安全测试来通过示例学习。我们将从反思测试和确保你的机器学习解决方案的需求开始，然后继续探索本章中的其他以下主题：
- en: Understanding the need for testing and securing your ML application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试和确保你的机器学习应用程序的需求
- en: Testing your ML solution by design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设计测试你的机器学习解决方案
- en: Securing your ML solution by design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设计确保你的机器学习解决方案安全
- en: Understanding the need for testing and securing your ML application
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试和确保你的机器学习应用程序的需求
- en: The growing adoption of data-driven and ML-based solutions is causing businesses
    to have to handle growing workloads, exposing them to extra levels of complexities
    and vulnerabilities.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 数据驱动和基于机器学习的解决方案的日益普及导致企业必须处理不断增长的工作负载，使它们面临额外的复杂性和漏洞。
- en: Cybersecurity is the most alarming risk for AI developers and adopters. According
    to a survey released by Deloitte ([https://www2.deloitte.com/us/en/insights/focus/cognitive-technologies/state-of-ai-and-intelligent-automation-in-business-survey.html](https://www2.deloitte.com/us/en/insights/focus/cognitive-technologies/state-of-ai-and-intelligent-automation-in-business-survey.html)),
    in July 2020, 62% of adopters saw cybersecurity risks as a significant or extreme
    threat, but only 39% said they felt prepared to address those risks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全是AI开发者和采用者面临的最令人担忧的风险。根据德勤发布的调查（[https://www2.deloitte.com/us/en/insights/focus/cognitive-technologies/state-of-ai-and-intelligent-automation-in-business-survey.html](https://www2.deloitte.com/us/en/insights/focus/cognitive-technologies/state-of-ai-and-intelligent-automation-in-business-survey.html)），2020年7月，62%的采用者认为网络安全风险是一个重大或极端威胁，但只有39%的人表示他们认为自己有准备应对这些风险。
- en: In this section, we will look into the need for securing ML-based systems and
    solutions. We will reflect on some of the broader challenges of ML systems such
    as bias, ethics, and explainability. We will also study some of the challenges
    present at each stage of the ML life cycle relating to confidentiality, integrity,
    and availability using the guidelines for ML testing and security by design.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨确保基于机器学习的系统和解决方案安全的需求。我们将反思一些机器学习系统更广泛面临的挑战，如偏差、伦理和可解释性。我们还将研究在机器学习生命周期的每个阶段与机密性、完整性和可用性相关的挑战，这些挑战将使用机器学习测试和设计安全的指南来研究。
- en: Testing your ML solution by design
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过设计测试你的机器学习解决方案
- en: On top of performing regular software development tests, such as unit tests,
    integration tests, system testing, and acceptance testing, ML solutions need additional
    tests because data and ML models are involved. Both the data and models change
    dynamically over time. Here are some concepts for testing by design; applying
    them to your use cases can ensure robust ML solutions are produced as a result.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '除了执行常规的软件开发测试，如单元测试、集成测试、系统测试和验收测试之外，机器学习解决方案还需要额外的测试，因为数据与机器学习模型都随时间动态变化。以下是一些设计测试的概念；将这些概念应用于您的用例可以确保产生健壮的机器学习解决方案。 '
- en: Data testing
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据测试
- en: 'The goal of testing data is to ensure that the data is of a high enough quality
    for ML model training. The better the quality of the data, the better the models
    trained for the given tasks. So how do we assess the quality of data? It can be
    done by inspecting the following five factors of the data:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 测试数据的目的是确保数据对于机器学习模型训练来说质量足够高。数据质量越好，为给定任务训练的模型就越好。那么我们如何评估数据的质量呢？可以通过检查以下五个数据因素来完成：
- en: Accuracy
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准确性
- en: Completeness (no missing values)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整性（无缺失值）
- en: Consistency (in terms of expected data format and volume)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性（在预期的数据格式和数量方面）
- en: Relevance (data should meet the intended need and requirements)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关性（数据应满足预期的需求和需求）
- en: Timeliness (the latest or up-to-date data)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 及时性（最新或最新数据）
- en: 'Based on these factors, if a company can manage each dataset''s data quality
    when received or created, the data quality is guaranteed. Here are some steps
    that your team or company can use as quality assurance measures for your data:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些因素，如果一家公司能够在接收或创建每个数据集时管理其数据质量，则数据质量得到保证。以下是一些您的团队或公司可以用来作为数据质量保证措施的数据步骤：
- en: '**Meticulous data cataloging and control of incoming data**: A combination
    of data cataloging (to document and store data in the required format or pattern)
    and control functions can ensure a high quality of incoming data. Data cataloging
    and control can be done by monitoring data factors such as data formats and patterns,
    value distributions and anomalies, completeness, and consistency can help to provide
    good incoming data quality.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**细致的数据目录和输入数据的控制**：数据目录（以所需格式或模式记录和存储数据）和控制功能的组合可以确保输入数据的高质量。数据目录和控制可以通过监控数据因素，如数据格式和模式、值分布和异常、完整性和一致性来实现，这有助于提供良好的输入数据质量。'
- en: '**Curating data pipelines carefully to avoid duplicate data**: When duplicated
    data is manufactured from the same data source and using the same logic by different
    people, it can get complicated to manage lineages, authenticity, and data integrity.
    This can produce cascading effects throughout multiple systems or databases. It
    is better to avoid duplicating data as much as possible.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**精心管理数据管道以避免重复数据**：当重复数据由相同的数据源生成，并且由不同的人使用相同的逻辑时，管理血缘、真实性和数据完整性可能会变得复杂。这可能会在多个系统或数据库中产生级联效应。尽可能避免重复数据会更好。'
- en: '**Data governance with enforced integrity**: In today''s world, maintaining
    data integrity has become crucial. Not having the mindset of enforcing data integrity
    can be costly for an organization. The data could eventually become incomplete,
    delayed, or out of date, leading to serious data quality issues.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**强制执行数据治理的完整性**：在当今世界，维护数据完整性变得至关重要。没有强制执行数据完整性的心态可能会对一个组织造成损失。数据最终可能会变得不完整、延迟或过时，导致严重的数据质量问题。'
- en: '**Maintaining end-to-end traceability and lineage**: Data lineage and traceability
    can be achieved by the smart use of metadata and the data itself. Using both,
    we can document critical information such as unique keys for each dataset, adding
    a timestamp to each record, and logging data changes. Making sure data lineage
    and end-to-end traceability is enabled can give us the possibility to reproduce
    models and debug errors and pipelines.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**维护端到端的可追溯性和血缘关系**：通过智能使用元数据和数据本身，可以实现数据血缘和可追溯性。使用两者，我们可以记录关键信息，如每个数据集的唯一键、为每条记录添加时间戳以及记录数据变更。确保数据血缘和端到端可追溯性被启用，可以给我们提供重现模型和调试错误和管道的可能性。'
- en: Model testing
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型测试
- en: 'Model tests need to cover server issues such as the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 模型测试需要涵盖以下服务器问题：
- en: Evaluating the accuracy or key metric of the ML model
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估机器学习模型的准确性或关键指标
- en: Testing on random data points
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在随机数据点上测试
- en: Testing for acceptable loss or performance on your task
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试任务的可接受损失或性能
- en: Unit tests for model robustness using real data
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用真实数据进行模型鲁棒性的单元测试
- en: 'These tests can be orchestrated in two phases: pre-training and post-training.
    Having these tests facilitated in the workflow can produce robust models for production.
    Let''s look at what pre-train and post-train tests can be done by design.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试可以分为两个阶段：预训练和后训练。在流程中实施这些测试可以产生适合生产的稳健模型。让我们看看预先设计和后训练测试可以做什么。
- en: Pre-training tests
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预训练测试
- en: 'Tests can be performed to catch flaws before we proceed to the training stage.
    These flaws could be in the data, pipelines, or parameters. *Figure 9.1* suggests
    running pre-training and post-training tests as part of a proposed workflow for
    developing high-quality models:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入训练阶段之前，可以通过测试来捕捉缺陷。这些缺陷可能存在于数据、管道或参数中。*图9.1*建议将预训练和后训练测试作为开发高质量模型所提出的流程的一部分：
- en: '![Figure 9.1 – Proposed workflow for developing high-quality models'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 开发高质量模型所提出的流程'
- en: '](img/B16572_09_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16572_09_01.jpg)'
- en: Figure 9.1 – Proposed workflow for developing high-quality models
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 开发高质量模型所提出的流程
- en: 'Here are some ways to detect and avoid pre-training flaws using pre-training
    tests:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用预训练测试来检测和避免预训练缺陷的方法：
- en: Eliminating data pipeline debt by handling any data leakage, edge cases, and
    optimizing to make the pipeline time- and resource-efficient
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过处理任何数据泄漏、边缘情况和优化以使管道时间效率和资源效率来消除数据管道债务
- en: Making sure the shape of your model output matches the labels in your dataset
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的模型输出形状与数据集中的标签匹配
- en: Examining the output ranges to make sure they match our expectations (such as
    checking that the output of a classification model is a distribution with class
    probabilities that sum to 1)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查输出范围以确保它们符合我们的预期（例如，检查分类模型的输出是一个分布，其类概率之和为1）
- en: Examining your training and validation datasets for label leakage
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查您的训练和验证数据集是否存在标签泄漏
- en: Making sure the ETL pipeline outputs or fetches data in the required format
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保ETL管道以所需格式输出或获取数据
- en: Pre-training tests do not need parameters to run, but they can be quite useful
    in catching bugs before running the model training.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 预训练测试不需要参数运行，但它们在运行模型训练之前捕捉错误非常有用。
- en: Post-training tests
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 训练后测试
- en: 'Post-training tests enable us to investigate model performance and the logic
    behind model predictions and foresee any possible flaws in the model before deploying
    the model to production. Post-training tests enable us to detect flaws in model
    performance and functionality. Post-training tests involve a model performance
    evaluation test, invariance test, and minimum functionality test. Here is a recommended
    read for more insights on post-training tests: *Beyond Accuracy: Behavioral Testing
    of NLP Models with CheckList* ([https://homes.cs.washington.edu/~marcotcr/acl20_checklist.pdf](https://homes.cs.washington.edu/~marcotcr/acl20_checklist.pdf))'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 训练后测试使我们能够调查模型性能和模型预测背后的逻辑，并在将模型部署到生产之前预见模型中可能存在的任何缺陷。训练后测试使我们能够检测模型性能和功能中的缺陷。训练后测试包括模型性能评估测试、不变性测试和最小功能测试。以下是一篇推荐的阅读材料，以了解更多关于训练后测试的信息：*超越准确性：使用CheckList对NLP模型进行行为测试*
    ([https://homes.cs.washington.edu/~marcotcr/acl20_checklist.pdf](https://homes.cs.washington.edu/~marcotcr/acl20_checklist.pdf))
- en: Deployment and inference testing
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 部署和推理测试
- en: Deployment testing involves testing **Continuous Integration/Continuous Delivery**
    (**CI/CD**) pipeline delivery, integration tests, and testing that deployment
    is successful. It is critical to test the deployed model and that is where inference
    testing comes in to stress- or load-test the deployed model and test its performance
    on real-time data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 部署测试包括测试**持续集成/持续交付**（**CI/CD**）管道交付、集成测试以及测试部署是否成功。测试已部署的模型至关重要，这就是推理测试介入以压力或负载测试已部署模型并测试其在实时数据上的性能的原因。
- en: In the next section, we will load test a previously deployed model (for a use
    case).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将对之前部署的模型进行负载测试（针对一个用例）。
- en: Hands-on deployment and inference testing (a business use case)
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践部署和推理测试（一个业务用例）
- en: When you have your service (either API or ML) ready and you are about to serve
    it to the users but you don't have any clue about how many users it can actually
    handle and how it will react when many users access it simultaneously, that's
    where load testing is useful to benchmark how many users your service can serve
    and to validate whether the service can cater to the business requirements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的服务（无论是API还是ML）准备就绪，您即将向用户提供服务，但您对它实际上可以处理多少用户以及当许多用户同时访问时它将如何反应没有任何头绪时，这就是负载测试有用之处，可以基准测试您的服务可以服务多少用户，并验证该服务是否能够满足业务需求。
- en: 'We will perform load testing for the service we deployed previously (in [*Chapter
    7*](B16572_07_Final_JM_ePub.xhtml#_idTextAnchor143), *Building Robust CI and CD
    Pipelines*). `Locust.io` will be used for load testing. `locust.io` is an open
    source load-testing tool. For this, we will install `locust` (using `pip`) and
    curate a Python script using the locust.io SDK to test an endpoint. Let''s get
    started by installing `locust`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对之前部署的服务进行负载测试（在[*第7章*](B16572_07_Final_JM_ePub.xhtml#_idTextAnchor143)，*构建健壮的CI和CD管道*）。将使用`Locust.io`进行负载测试。`locust.io`是一个开源的负载测试工具。为此，我们将使用`pip`安装`locust`，并使用locust.io
    SDK编写一个Python脚本来测试一个端点。让我们从安装`locust`开始：
- en: 'Install `locust`: Go to your terminal and execute the following command:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`locust`：转到您的终端并执行以下命令：
- en: '[PRE0]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Curate the `load_test.py` script: Go to your favorite IDE and start curating
    the script or follow the steps in the premade script. To access the premade script
    go to the *Engineering MLOps* repository cloned previously, access the `09_Testing_Security`
    folder, and go to the `load_test.py` file. Let''s demystify the code in `load_test.py`
    – firstly, the needed libraries are imported as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 精炼 `load_test.py` 脚本：前往您的首选 IDE 并开始精炼脚本，或者遵循预先制作脚本中的步骤。要访问预先制作的脚本，请前往之前克隆的 *Engineering
    MLOps* 仓库，访问 `09_Testing_Security` 文件夹，然后转到 `load_test.py` 文件。让我们揭开 `load_test.py`
    中的代码之谜——首先，所需的库如下导入：
- en: '[PRE1]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We imported the `time`, `json`, and `locust` libraries, and then from `locust`
    we import the following required functions: `HttpUser` (a user agent that can
    visit different endpoints), `task`, and `between`.'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们导入了 `time`、`json` 和 `locust` 库，然后从 `locust` 中导入了以下所需的功能：`HttpUser`（一个可以访问不同端点的用户代理）、`task`
    和 `between`。
- en: 'Create a `test_data` variable with sample test data to infer the ML model during
    the load test. Define `headers` we will use for the API calls in our load test:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `test_data` 变量，包含用于负载测试中推断机器学习模型的样本测试数据。定义我们将在负载测试中使用的 `headers`：
- en: '[PRE2]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we will implement the core functionality of the load test as part of
    the `MLServiceUser` class (you can name it whatever you want) by extending `HttpUser`.
    `HttpUser` is the user agent that can visit different endpoints:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过扩展 `HttpUser` 来实现负载测试的核心功能，作为 `MLServiceUser` 类（您可以取任何名字）的一部分。`HttpUser`
    是一个用户代理，可以访问不同的端点：
- en: '[PRE3]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We created a `wait_time` variable using the `between()` function, which specifies
    the time it takes between finishing testing one endpoint and switching to test
    the next endpoint. So, we specify `wait_time` as `1` to `5` seconds in the `between(1,5)`
    function. The next part is the crux of defining a task that tests an endpoint.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `between()` 函数创建了一个 `wait_time` 变量，该变量指定了完成测试一个端点后切换到测试下一个端点所需的时间。因此，我们在
    `between(1,5)` 函数中将 `wait_time` 指定为 `1` 到 `5` 秒。下一个部分是定义测试端点的任务的核心。
- en: For this, we use a `@task` wrapper or decorator to start defining our task to
    test an endpoint of our choice using a custom function. Define a custom function,
    `def` `test_weather_predictions()`, and make a `post` request to the endpoint
    using `test_data` and the headers defined previously. Now, we are set to run the
    load testing!
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于此，我们使用 `@task` 包装器或装饰器来开始定义我们的任务，以使用自定义函数测试我们选择的端点。定义一个自定义函数 `def test_weather_predictions()`，并使用之前定义的
    `test_data` 和 `headers` 向端点发送 `post` 请求。现在，我们已经准备好运行负载测试了！
- en: 'Run the `locust.io` server: Go to your terminal and change to the location
    where you have the `load_test.py` file (such as in the `09_Testing_Security` folder
    of the cloned repository used in this book), then run the following command to
    spin up a `locust.io` server:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `locust.io` 服务器：前往您的终端并切换到您有 `load_test.py` 文件的位置（例如，在本书中使用的克隆仓库的 `09_Testing_Security`
    文件夹中），然后运行以下命令来启动一个 `locust.io` 服务器：
- en: '[PRE4]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The execution of the previous command will spin up the `locust` server at port
    `8089`. We can perform load tests on the web interface rendered by `locust.io`.
    To access the web service, open a browser of your choice and go to the following
    web address: `http://0.0.0.0:8089/`, as shown in *Figure 9.2*:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行上一条命令将在端口 `8089` 启动 `locust` 服务器。我们可以在由 `locust.io` 渲染的 Web 界面上执行负载测试。要访问
    Web 服务，打开您选择的浏览器并访问以下 Web 地址：`http://0.0.0.0:8089/`，如图 *图 9.2* 所示：
- en: '![Figure 9.2 – Access the Locust.io web service'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.2 – 访问 Locust.io Web 服务'
- en: '](img/B16572_09_02.jpg)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16572_09_02.jpg)'
- en: Figure 9.2 – Access the Locust.io web service
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.2 – 访问 Locust.io Web 服务
- en: 'Run the load test: Opening the web service will prompt you to specify options
    such as the number of users, spawn rate, and host (the endpoint to test). Specify
    the number of users to simulate, and the spawn rate (how many users will be spawned
    per second) as per your requirements, to validate whether your endpoint is capable
    of serving your business/user needs, for example, 50 users and a spawn rate of
    50.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行负载测试：打开 Web 服务将提示您指定选项，如用户数量、生成速率和主机（要测试的端点）。根据您的需求指定要模拟的用户数量和生成速率（每秒将生成多少用户），以验证您的端点是否能够满足您的业务/用户需求，例如，50
    个用户和 50 的生成速率。
- en: Lastly, enter the endpoint or host you would like to load test and hit **Start
    swarming** to start performing the load test. In [*Chapter 7*](B16572_07_Final_JM_ePub.xhtml#_idTextAnchor143),
    *Building Robust CI and CD Pipelines*, we deployed an endpoint. It is recommended
    to test the deployed endpoint.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，输入您想要进行负载测试的端点或主机，并点击**开始swarming**以开始执行负载测试。在[*第7章*](B16572_07_Final_JM_ePub.xhtml#_idTextAnchor143)
    *构建健壮的CI/CD管道*中，我们部署了一个端点。建议测试已部署的端点。
- en: Go to your Azure ML workspace, access the **Endpoints** section, access the
    deployed endpoint named **dev-webservice**, and copy and paste the endpoint web
    address into the host textbox.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您的Azure ML工作区，访问**端点**部分，访问名为**dev-webservice**的已部署端点，并将端点Web地址复制并粘贴到主机文本框中。
- en: Next, click **Start** **swarming** to start load testing the endpoint. This
    will start the load test and open a new page where you can monitor your load tests
    in real time as shown in *Figure 9.3*:![Figure 9.3 – Monitor the load test in
    real time
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击**开始** **swarming**以开始对端点进行负载测试。这将启动负载测试并打开一个新页面，您可以在其中实时监控您的负载测试，如图*图9.3*所示：![图9.3
    – 实时监控负载测试
- en: '](img/B16572_09_03.jpg)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16572_09_03.jpg)'
- en: Figure 9.3 – Monitor the load test in real time
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.3 – 实时监控负载测试
- en: 'Analyzing load testing results: You can monitor statistics, charts, failures,
    and exceptions in real time. For instance, in *Figure 9.3* we are monitoring the
    load test for the `POST` request with test data. The number of requests made (**77459**),
    the number of fails (**0**), the average response time (**75ms**), and other information
    can be monitored. It is important to check that there are no failures and that
    the average response time is within the range to serve your business/user needs
    with efficiency or no major speed breaker.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析负载测试结果：您可以在实时监控统计数据、图表、故障和异常。例如，在*图9.3*中，我们正在监控带有测试数据的`POST`请求的负载测试。监控的项目包括请求数量（**77459**）、失败次数（**0**）、平均响应时间（**75ms**）以及其他信息。检查是否存在故障以及平均响应时间是否在满足您的业务/用户需求的有效范围内或没有速度瓶颈是很重要的。
- en: 'If you have no failed requests and the average response time is within the
    range required, then your endpoint has passed the load test and is ready to be
    served to users. After or during the load testing, you can view charts of the
    load-testing performance with critical information such as total requests per
    second, response times, and the number of users with the progression of time.
    We can view this information in real time as shown in *Figure 9.4* and *Figure
    9.5*:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您没有失败的请求，并且平均响应时间在所需范围内，则您的端点已通过负载测试并准备好供用户使用。在负载测试之后或期间，您可以通过图表查看负载测试性能，包括每秒总请求数、响应时间和随时间推移的用户数量等关键信息。我们可以在*图9.4*和*图9.5*中实时查看这些信息：
- en: '![Figure 9.4 – Charts showing the total requests per second and response times'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – 显示每秒总请求数和响应时间的图表'
- en: '](img/B16572_09_04.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16572_09_04.jpg)'
- en: Figure 9.4 – Charts showing the total requests per second and response times
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 显示每秒总请求数和响应时间的图表
- en: In *Figure 9.4* we can notice that the number of requests per second is in the
    range of 18-22 as the simulated users of `locust.io` make requests, and the response
    time in milliseconds varies from 70 to 500 in some cases, with a 430ms variance
    between the minimum and maximum. The average request time is 75ms (as seen in
    *Figure 9.3*).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.4*中，我们可以注意到，当`locust.io`的模拟用户发起请求时，每秒请求数量在18-22之间，某些情况下响应时间在70到500毫秒之间变化，最小和最大响应时间之间的差异为430毫秒。平均请求时间为75毫秒（如图*图9.3*所示）。
- en: 'Please note that this kind of performance may or may not be ideal for a given
    use case, depending on your business or user needs. A more stable response time
    is desirable; for instance, a response time variance of no more than 50ms between
    the minimum and maximum response times may be preferable for a stable performance.
    To achieve such performance it is recommended to deploy your models on higher-end
    infrastructure as appropriate, for example, a GPU or a high-end CPU, unlike the
    deployment on a CPU in an Azure container instance. Similarly, in *Figure 9.5*
    we can see the response times versus the number of users:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种性能可能或可能不适合特定的用例，这取决于您的业务或用户需求。更稳定的响应时间更可取；例如，最小和最大响应时间之间的响应时间变化不超过50ms可能更适合稳定性能。为了实现这种性能，建议根据需要部署到高端基础设施上，例如GPU或高端CPU，而不是在Azure容器实例上的CPU上部署。同样，在*图9.5*中，我们可以看到响应时间与用户数量的关系：
- en: '![Figure 9.5 – Charts showing the total requests per second and the number
    of users'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5 – 显示每秒总请求次数和用户数量的图表'
- en: '](img/B16572_09_05.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16572_09_05.jpg]'
- en: Figure 9.5 – Charts showing the total requests per second and the number of
    users
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 显示每秒总请求次数和用户数量的图表
- en: We can see that the number of users spawned per second is 50, as mentioned (in
    *Figure 9.2*). As time progresses, the spawn rate is constant and response times
    vary between 70-500ms, with 75ms as the average response time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，每秒产生的用户数量为50，如（*图9.2*）中所述。随着时间的推移，产生率保持恒定，响应时间在70-500ms之间变化，平均响应时间为75ms。
- en: 'Document or download results: After the load test has been executed successfully
    you can document or present the results of the load test to the relevant stakeholders
    (QA/product manager) using a test report. To download or access the test report,
    go to the `.csv` files, as shown in *Figure 9.6*:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档或下载结果：负载测试成功执行后，您可以使用测试报告记录或向相关利益相关者（QA/产品经理）展示负载测试的结果。要下载或访问测试报告，请访问如图*图9.6*所示的`.csv`文件：
- en: '![Figure 9.6 – Download the test results'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 – 下载测试结果'
- en: '](img/B16572_09_06.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16572_09_06.jpg]'
- en: Figure 9.6 – Download the test results
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 下载测试结果
- en: 'Download the statistics or failure reports required for further inspection
    as per your needs, and note that you can access the full test report by clicking
    **Download the Report**, as shown in *Figure 9.7*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的需求下载所需的统计数据或故障报告，并请注意，您可以通过点击**下载报告**来访问完整的测试报告，如图*图9.7*所示：
- en: '![Figure 9.7 – Download the test results'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 – 下载测试结果'
- en: '](img/B16572_09_07.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16572_09_07.jpg]'
- en: Figure 9.7 – Download the test results
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 下载测试结果
- en: A comprehensive test report is presented with critical information, such as
    the endpoint inferred average request time and the minimum and maximum request
    times, and this information is also presented in the form of visualized charts
    as seen in *Figure 9.7*. You can also download this full report to present to
    your respective stakeholders.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了包含关键信息的全面测试报告，例如端点推断的平均请求时间和最小/最大请求时间，这些信息也以可视化的图表形式呈现，如图*图9.7*所示。您还可以下载此完整报告以向您的相关利益相关者展示。
- en: Congratulations, you have performed a hands-on load test to validate your endpoint
    and check whether your ML service is able to serve your business or user needs
    with efficiency.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您，您已经进行了手动负载测试以验证您的端点，并检查您的机器学习服务是否能够以高效的方式满足您的业务或用户需求。
- en: Securing your ML solution by design
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过设计确保机器学习解决方案的安全
- en: Securing your ML applications is more important than ever due to the growing
    adoption of AI to provide smart applications. Designing and developing ML systems
    without keeping security in mind can be costly in terms of exposing the system
    to hackers, leading to manipulation, data breaches, and non-compliance. Robustness
    and security play an important role in ensuring an AI system is trustworthy. To
    build trustworthy ML applications, keeping security in mind is vital to not leave
    any stones unturned.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于人工智能在提供智能应用方面的日益普及，确保您的机器学习应用安全比以往任何时候都更重要。在设计和发展机器学习系统时，如果不考虑安全性，可能会因暴露系统给黑客而造成损失，导致操纵、数据泄露和不合规。鲁棒性和安全性在确保人工智能系统值得信赖方面发挥着重要作用。为了构建值得信赖的机器学习应用，考虑安全性是至关重要的，以确保不留任何遗漏。
- en: '*Figure 9.8* shows a framework for creating secure ML applications by design.
    The framework addresses key areas in the ML life cycle, ensuring confidentiality,
    integrity, and availability within those specific stages. Let''s reflect upon
    each area of the ML life cycle and address the issues of confidentiality, integrity,
    and availability in each area:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.8* 展示了一个通过设计创建安全机器学习应用的框架。该框架针对机器学习生命周期的关键区域，确保在这些特定阶段中的机密性、完整性和可用性。让我们反思机器学习生命周期的每个区域，并针对每个区域解决机密性、完整性和可用性问题：'
- en: '![Figure 9.8 – Framework for securing the ML life cycle by design'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 – 通过设计确保机器学习生命周期的框架'
- en: '](img/B16572_09_08.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16572_09_08.jpg]'
- en: Figure 9.8 – Framework for securing the ML life cycle by design
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 通过设计确保机器学习生命周期的框架
- en: Let's reflect upon each area of the ML life cycle and address confidentiality,
    integrity, and availability in each area while looking at the different types
    of attacks.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看不同类型的攻击的同时，让我们反思机器学习生命周期的每个区域，并解决每个区域的机密性、完整性和可用性问题。
- en: Types of attacks
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 攻击类型
- en: 'We will explore some of the most common attacks on ML systems. At a high level,
    attacks by hackers can be broken down into four categories: poisoning, input attacks
    and evasion, reverse engineering, and backdoor attacks. Let''s see how attackers
    manage to infiltrate ML systems via these attacks.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一些最常见针对机器学习系统的攻击。从高层次来看，黑客的攻击可以分为四个类别：中毒、输入攻击和规避、逆向工程和后门攻击。让我们看看攻击者是如何通过这些攻击渗透机器学习系统的。
- en: Poisoning
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中毒
- en: 'A hacker or attacker seeks to compromise an AI model in a poisoning attack.
    Poisoning attacks can happen at any stage (training, deployment, or real-time
    inference). They occur typically in training and inference. Let''s see how poisoning
    attacks are implemented in three typical ways:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在中毒攻击中，黑客或攻击者试图破坏AI模型。中毒攻击可以在任何阶段发生（训练、部署或实时推理）。它们通常发生在训练和推理阶段。让我们看看中毒攻击是如何以三种典型方式实施的：
- en: '**Dataset poisoning**: Training datasets contain the knowledge on which the
    model is trained. An attacker can manipulate this knowledge by infiltrating the
    training dataset. Here, the attacker introduces wrongly labeled or incorrect data
    into the training dataset, and with this the entire learning process is distorted.
    This is a direct way to poison a model. Training datasets can be poisoned during
    the data collection and curation phases, and it can be hard to notice or detect
    it as the training datasets can come from multiple sources, can be large, and
    also as the attacker can infiltrate within data distributions.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据集中毒**：训练数据集包含模型训练所依据的知识。攻击者可以通过渗透训练数据集来操纵这种知识。在这里，攻击者将错误标记或错误的数据引入训练数据集，从而扭曲整个学习过程。这是直接中毒模型的一种方式。训练数据集可以在数据收集和整理阶段中毒，由于训练数据集可能来自多个来源，可能很大，而且攻击者可以在数据分布中渗透，因此可能很难注意到或检测到它。'
- en: '**Algorithm poisoning** happens when an attacker meddles with the algorithm
    used to train the model. It can be as simple as infiltrating hyperparameters or
    fiddling with the architecture of the algorithm. For example, let''s take federated
    learning (which aims to preserve the privacy of individuals'' data) where model
    training is done on multiple subsets of private data (such as healthcare data
    from multiple hospitals while preserving patients'' confidential information).
    Multiple models are derived from each subset and then combined to form a final
    model. During this, an attacker can manipulate any subset of the data and influence
    the final resulting model. The attacker can also create a fake model from fake
    data and concatenate it with models produced from training on multiple subsets
    of private data to produce a final model that deviates from performing the task
    efficiently, or serves the attacker''s motives.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法中毒**发生在攻击者干预用于训练模型的算法时。这可以简单到渗透超参数或篡改算法架构。例如，让我们以联邦学习（旨在保护个人数据的隐私）为例，在多个私有数据子集（如来自多家医院的医疗数据，同时保护患者的机密信息）上完成模型训练。从每个子集中衍生出多个模型，然后组合成一个最终模型。在这个过程中，攻击者可以操纵任何数据子集并影响最终生成的模型。攻击者还可以从伪造数据创建一个假模型，并将其与从多个私有数据子集的训练中产生的模型连接起来，以生成一个偏离高效执行任务或服务于攻击者动机的最终模型。'
- en: '**Model poisoning** occurs when an attacker replaces a deployed model with
    an alternative model. This kind of attack is identical to a typical cyber-attack
    where the electronic files containing the model could be modified or replaced.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型中毒**发生在攻击者用替代模型替换已部署模型时。这种攻击与典型的网络攻击相同，其中包含模型的电子文件可能被修改或替换。'
- en: Input attack and evasion
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入攻击和规避
- en: An input or evasion attack happens when the attacker modifies input to the ML
    system in such a manner that it causes the system to malfunction (or give a wrong
    prediction). These perturbations or changes can be hard to detect as these changes
    are very subtle or small.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击者以某种方式修改输入到机器学习系统，导致系统故障（或给出错误预测）时，就会发生输入或规避攻击。这些扰动或变化可能很难检测，因为这些变化非常微妙或微小。
- en: For example, input attacks are popular for computer vision algorithms. This
    can be done by just changing a few pixels in the input image. As a result, the
    system might identify an image in a way that it is not supposed to or make a wrong
    prediction. Such small changes can effectively manipulate the prediction resulting
    in wrong actions being taken by the system. As a result, the ML system behaves
    as it should, while the output is manipulated.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，输入攻击在计算机视觉算法中很受欢迎。这可以通过仅更改输入图像中的几个像素来实现。结果，系统可能会以它不应该的方式识别图像，或者做出错误的预测。这种微小的变化可以有效地操纵预测，导致系统采取错误的行为。因此，ML系统表现得像它应该的那样，而输出被操纵。
- en: ML systems are highly prone to input attacks. Hence, having an anomaly detector
    to monitor incoming data can be quite handy to avoid such perturbations in the
    incoming data. Irrespective of input data, the majority of classification models
    choose a valid class from their training. Another way of protecting the ML system
    is by preprocessing the inputs with a proxy binary model that tells you, for example,
    whether an input image is of a person or an animal before sending this image to
    the final image classifier.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ML系统高度容易受到输入攻击。因此，拥有一个异常检测器来监控传入数据可以非常方便，以避免传入数据中的这种扰动。无论输入数据如何，大多数分类模型都会从它们的训练中选择一个有效类别。保护ML系统的另一种方法是在将图像发送到最终图像分类器之前，使用代理二进制模型对输入进行预处理，该模型告诉你，例如，输入图像是人的图像还是动物的图像。
- en: Reverse engineering
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逆向工程
- en: For a user of an AI system, it can be a black box or opaque. It is common in
    AI systems to accept inputs to generate outputs without revealing what is going
    on inside (in terms of both the logic and algorithm). Training datasets, which
    effectively contain all the trained system's knowledge, are also usually kept
    confidential. This, in theory, makes it impossible for an outsider to predict
    why particular outputs are produced or what is going on inside the AI system in
    terms of the algorithm, training data, or logic. However, in some cases, these
    systems can be prone to reverse engineering. The attacker or hackers' goal in
    reverse engineering attacks is to replicate the original model deployed as a service
    and use it to their advantage.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个AI系统的用户来说，它可能是一个黑盒或是不透明的。在AI系统中，接受输入以生成输出而不透露内部情况（无论是逻辑还是算法）是很常见的。训练数据集，它实际上包含了所有训练系统的知识，通常也保持机密。从理论上讲，这使得外部人士无法预测特定输出产生的原因或AI系统在算法、训练数据或逻辑方面的内部情况。然而，在某些情况下，这些系统可能容易受到逆向工程的影响。逆向工程攻击的攻击者或黑客的目标是复制作为服务部署的原始模型，并利用它为自己谋利。
- en: In a paper titled *Model Extraction Attacks against Recurrent Neural Networks*
    ([https://arxiv.org/pdf/2002.00123.pdf](https://arxiv.org/pdf/2002.00123.pdf)),
    published in February 2020, researchers conducted experiments on model extraction
    attacks against an RNN and an LSTM trained with publicly available academic datasets.
    The researchers effectively reproduce the functionality of an ML system via a
    model extraction attack. They demonstrate that a model extraction attack with
    high accuracy can be extracted efficiently, primarily by replicating or configuring
    a loss function or architecture from the target model.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在一篇题为《针对循环神经网络的后门提取攻击》的论文中（[https://arxiv.org/pdf/2002.00123.pdf](https://arxiv.org/pdf/2002.00123.pdf)），该论文于2020年2月发表，研究人员对使用公开可用的学术数据集训练的RNN和LSTM进行了模型提取攻击实验。研究人员通过模型提取攻击有效地复制了ML系统的功能。他们证明，高精度的模型提取攻击可以有效地提取，主要是通过复制或配置目标模型中的损失函数或架构。
- en: In another instance, researchers from the Max Planck Institute for Informatics
    showed in 2018 how they were able to infer information from opaque models by using
    a sequence of input-output queries.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个例子中，2018年，马克斯·普朗克信息学研究所的研究人员展示了他们如何通过一系列输入-输出查询从不可见模型中推断信息。
- en: Backdoor attacks
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后门攻击
- en: In backdoor attacks, the attacks can embed patterns of their choice in the model
    in the training or inference stages and infer the deployed model using pre-curated
    inputs to produce unexpected outputs or triggers to the ML system. Therefore,
    backdoor attacks can happen both in the training and inference phases, whereas
    evasion and poisoning attacks can occur in a single phase during training or inference.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在后门攻击中，攻击者可以在训练或推理阶段将他们选择的模式嵌入到模型中，并使用预先准备好的输入来推断部署的模型，从而产生意外的输出或触发ML系统。因此，后门攻击可以在训练和推理阶段发生，而逃避和中毒攻击可以在训练或推理的单个阶段发生。
- en: Poison attacks can be used as part of the attack in backdoor attacks, and in
    some instances, the student model can learn to hack some backdoors from the teacher
    model using transfer learning.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 毒化攻击可以用作后门攻击的一部分，在某些情况下，学生模型可以通过迁移学习从教师模型中学习到一些后门。
- en: Backdoor attacks can cause integrity challenges, especially in the training
    stage, if the attacker manages to use a poison attack to infiltrate training data
    and trigger an update to the model or system. Also, backdoor attacks can be aimed
    to degrade performance, exhaust or redirect resources that can lead to the system's
    failure, or attempt to introduce peculiar behavior and outputs from the AI system.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 后门攻击可能会引起完整性挑战，尤其是在训练阶段，如果攻击者成功利用毒化攻击渗透训练数据并触发模型或系统的更新。此外，后门攻击可能旨在降低性能，耗尽或重定向可能导致系统故障的资源，或者尝试从人工智能系统中引入特殊的行为和输出。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned the key principles of testing and security
    by design. We explored the various methods to test ML solutions in order to secure
    them. For a comprehensive understanding and hands-on experience, implementation
    was done to load test our previously deployed ML model (from [*Chapter 7*](B16572_07_Final_JM_ePub.xhtml#_idTextAnchor143),
    *Building Robust CI and CD Pipelines*) to predict the weather. With this, you
    are ready to handle the diverse testing and security scenarios that will be channeled
    your way.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过设计测试和安全性的关键原则进行了学习。我们探讨了测试机器学习解决方案的各种方法以确保其安全性。为了获得全面的理解和动手经验，我们实施了对之前部署的机器学习模型（来自[*第7章*](B16572_07_Final_JM_ePub.xhtml#_idTextAnchor143)，*构建健壮的CI/CD管道*）进行负载测试，以预测天气。有了这个，您就准备好应对各种测试和安全场景，这些场景将会出现在您的面前。
- en: In the next chapter, we will delve into the secrets of deploying and maintaining
    robust ML services in production. This will enable you to deploy robust ML solutions
    in production. Let's delve into it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨在生产环境中部署和维护健壮的机器学习服务的秘密。这将使您能够在生产环境中部署健壮的机器学习解决方案。让我们深入探讨。
