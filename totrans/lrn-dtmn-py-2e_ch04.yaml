- en: Recommending Movies Using Affinity Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at **affinity analysis** which determines when
    objects occur frequently together. This is also colloquially called market basket
    analysis, after one of the common use cases - determining when items are purchased
    together frequently in a store.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](lrn-dtmn-py-2e_ch03.html)*, Predicting Sports Winners with Decision
    Trees*, we looked at an object as a focus and used features to describe that object.
    In this chapter, the data has a different form. We have transactions where the
    objects of interest (movies, in this chapter) are used within those transactions
    in some way. The aim is to discover when objects occur simultaneously. In a case
    where we wish to work out when two movies are recommended by the same reviewers,
    we can use affinity analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key concepts of this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Affinity analysis for product recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature association mining using the Apriori algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendation Systems and the inherent challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sparse data formats and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Affinity analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Affinity analysis is the task of determining when objects are used in similar
    ways. In the previous chapter, we focused on whether the objects themselves are
    similar - in our case whether the games were similar in nature. The data for affinity
    analysis is often described in the form of a transaction. Intuitively, this comes
    from a transaction at a store—determining when objects are purchased together
    as a way to recommend products to users that they might purchase.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, affinity analysis can be applied to many processes that do not use
    transactions in this sense:'
  prefs: []
  type: TYPE_NORMAL
- en: Fraud detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer segmentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Affinity analysis is usually much more exploratory than classification. At the
    very least, we often simply rank the results and choose the top five recommendations
    (or some other number), rather than expect the algorithm to give us a specific
    answer.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we often don't have the complete dataset we expect for many classification
    tasks. For instance, in movie recommendation, we have reviews from different people
    on different movies. However, it is highly unlikely we have each reviewer review
    all of the movies in our dataset. This leaves an important and difficult question
    in affinity analysis. If a reviewer hasn't reviewed a movie, is that an indication
    that they aren't interested in the movie (and therefore wouldn't recommend it)
    or simply that they haven't reviewed it yet?
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about gaps in your datasets can lead to questions like this. In turn,
    that can lead to answers that may help improve the efficacy of your approach.
    As a budding data miner, knowing where your models and methodologies need improvement
    is key to creating great results.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms for affinity analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We introduced a basic method for affinity analysis in [Chapter 1](lrn-dtmn-py-2e_ch04.html)*,
    Getting Started with Data Mining*, which tested all of the possible rule combinations.
    We computed the confidence and support for each rule, which in turn allowed us
    to rank them to find the best rules.
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach is not efficient. Our dataset in [Chapter 1](lrn-dtmn-py-2e_ch04.html)*,
    Getting Started with Data Mining*, had just five items for sale. We could expect
    even a small store to have hundreds of items for sale, while many online stores
    would have thousands (or millions!). With a naive rule creation, such as our previous
    algorithm from [Chapter 1](lrn-dtmn-py-2e_ch04.html)*, Getting Started with Data
    Mining*, the growth in the time needed to compute these rules increases exponentially.
    As we add more items, the time it takes to compute all rules increases significantly
    faster. Specifically, the total possible number of rules is *2n - 1*. For our
    five-item dataset, there are 31 possible rules. For 10 items, it is 1023\. For
    just 100 items, the number has 30 digits. Even the drastic increase in computing
    power couldn't possibly keep up with the increases in the number of items stored
    online. Therefore, we need algorithms that work smarter, as opposed to computers
    that work harder.
  prefs: []
  type: TYPE_NORMAL
- en: The classic algorithm for affinity analysis is called the **Apriori algorithm**.
    It addresses the exponential problem of creating sets of items that occur frequently
    within a database, called **frequent itemsets**. Once these frequent itemsets
    are discovered, creating association rules is straightforward, which we will see
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The intuition behind Apriori is both simple and clever. First, we ensure that
    a rule has sufficient support within the dataset. Defining a minimum support level
    is the key parameter for Apriori. To build a frequent itemset we combine smaller
    frequent itemsets. For itemset (A, B) to have a support of at least 30, both A
    and B must occur at least 30 times in the database. This property extends to larger
    sets as well. For an itemset (A, B, C, D) to be considered frequent, the set (A,
    B, C) must also be frequent (as must D).
  prefs: []
  type: TYPE_NORMAL
- en: These frequent itemsets can be built and possible itemsets that are not frequent
    (of which there are many) will never be tested. This saves significant time in
    testing new rules, as the number of frequent itemsets is expected to be significantly
    fewer than the total number of possible itemsets.
  prefs: []
  type: TYPE_NORMAL
- en: Other example algorithms for affinity analysis build on this, or similar concepts,
    including the **Eclat** and **FP-growth** algorithms. There are many improvements
    to these algorithms in the data mining literature that further improve the efficiency
    of the method. In this chapter, we will focus on the basic Apriori algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Overall methodology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To perform association rule mining for affinity analysis, we first use the Apriori
    algorithm to generate frequent itemsets. Next, we create association rules (for
    example, *if a person recommended movie X, they would also recommend movie Y*)
    by testing combinations of premises and conclusions within those frequent itemsets.
  prefs: []
  type: TYPE_NORMAL
- en: For the first stage, the Apriori algorithm needs a value for the minimum support
    that an itemset needs to be considered frequent. Any itemsets with less support
    will not be considered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting this minimum support too low will cause Apriori to test a larger number
    of itemsets, slowing the algorithm down. Setting it too high will result in fewer
    itemsets being considered frequent.
  prefs: []
  type: TYPE_NORMAL
- en: In the second stage, after the frequent itemsets have been discovered, association
    rules are tested based on their confidence. We could choose a minimum confidence
    level, a number of rules to return, or simply return all of them and let the user
    decide what to do with them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we will return only rules above a given confidence level. Therefore,
    we need to set our minimum confidence level. Setting this too low will result
    in rules that have a high support, but are not very accurate. Setting this higher
    will result in only more accurate rules being returned, but with fewer rules being
    discovered overall.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with the movie recommendation problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Product recommendation is a big business. Online stores use it to up-sell to
    customers by recommending other products that they could buy. Making better recommendations
    leads to better sales. When online shopping is selling to millions of customers
    every year, there is a lot of potential money to be made by selling more items
    to these customers.
  prefs: []
  type: TYPE_NORMAL
- en: Product recommendations, including movie and books, have been researched for
    many years; however, the field gained a significant boost when Netflix ran their
    Netflix Prize between 2007 and 2009\. This competition aimed to determine if anyone
    can predict a user's rating of a film better than Netflix was currently doing.
    The prize went to a team that was just over 10 percent better than the current
    solution. While this may not seem like a large improvement, such an improvement
    would net millions to Netflix in revenue from better movie recommendations over
    the following years.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the inception of the Netflix Prize, Grouplens, a research group at the
    University of Minnesota, has released several datasets that are often used for
    testing algorithms in this area. They have released several versions of a movie
    rating dataset, which have different sizes. There is a version with 100,000 reviews,
    one with 1 million reviews and one with 10 million reviews.
  prefs: []
  type: TYPE_NORMAL
- en: 'The datasets are available from [http://grouplens.org/datasets/movielens/](http://grouplens.org/datasets/movielens/)
    and the dataset we are going to use in this chapter is the *MovieLens 100K dataset*
    (with 100,000 reviews). Download this dataset and unzip it in your data folder.
    Start a new Jupyter Notebook and type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that `ratings_filename` points to the u.data file in the unzipped folder.
  prefs: []
  type: TYPE_NORMAL
- en: Loading with pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MovieLens` dataset is in a good shape; however, there are some changes
    from the default options in `pandas.read_csv` that we need to make. To start with,
    the data is separated by tabs, not commas. Next, there is no heading line. This
    means the first line in the file is actually data and we need to manually set
    the column names.
  prefs: []
  type: TYPE_NORMAL
- en: 'When loading the file, we set the delimiter parameter to the tab character,
    tell pandas not to read the first row as the header (with `header=None`) and to
    set the column names with given values. Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While we won't use it in this chapter, you can properly parse the date timestamp
    using the following line. Dates for reviews can be an important feature in recommendation
    prediction, as movies that are rated together often have more similar rankings
    than movies ranked separately. Accounting for this can improve models significantly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view the first few records by running the following in a new cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will come out looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | UserID | MovieID | Rating | Datetime |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 196 | 242 | 3 | 1997-12-04 15:55:49 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 186 | 302 | 3 | 1998-04-04 19:22:22 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 22 | 377 | 1 | 1997-11-07 07:18:36 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 244 | 51 | 2 | 1997-11-27 05:02:03 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 166 | 346 | 1 | 1998-02-02 05:33:16 |'
  prefs: []
  type: TYPE_TB
- en: Sparse data formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This dataset is in a sparse format. Each row can be thought of as a cell in
    a large feature matrix of the type used in previous chapters, where rows are users
    and columns are individual movies. The first column would be each user's review of
    the first movie, the second column would be each user's review of the second movie,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There are around 1,000 users and 1,700 movies in this dataset, which means that
    the full matrix would be quite large (nearly 2 million entries). We may run into
    issues storing the whole matrix in memory and computing on it would be troublesome.
    However, this matrix has the property that most cells are empty, that is, there
    is no review for most movies for most users. There is no review of movie number 675
    for user number 213 though, and not for most other combinations of user and movie.
  prefs: []
  type: TYPE_NORMAL
- en: The format given here represents the full matrix, but in a more compact way.
    The first row indicates that user  number 196 reviewed movie number 242, giving
    it a ranking of 3 (out of five) on December 4, 1997.
  prefs: []
  type: TYPE_NORMAL
- en: Any combination of user and movie that isn't in this database is assumed to
    not exist. This saves significant space, as opposed to storing a bunch of zeroes
    in memory. This type of format is called a sparse matrix format. As a rule of
    thumb, if you expect about 60 percent or more of your dataset to be empty or zero,
    a sparse format will take less space to store.
  prefs: []
  type: TYPE_NORMAL
- en: When computing on sparse matrices, the focus isn't usually on the data we don't
    have—comparing all of the zeroes. We usually focus on the data we have and compare
    those.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Apriori algorithm and its implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The goal of this chapter is to produce rules of the following form: *if a person
    recommends this set of movies, they will also recommend this movie*. We will also
    discuss extensions where a person who recommends a set of movies, is likely to
    recommend another particular movie.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we first need to determine if a person recommends a movie. We can
    do this by creating a new feature Favorable, which is True if the person gave
    a favorable review to a movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the new feature by viewing the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|  | UserID | MovieID | Rating | Datetime | Favorable |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 62 | 257 | 2 | 1997-11-12 22:07:14 | False |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 286 | 1014 | 5 | 1997-11-17 15:38:45 | True |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 200 | 222 | 5 | 1997-10-05 09:05:40 | True |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | 210 | 40 | 3 | 1998-03-27 21:59:54 | False |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | 224 | 29 | 3 | 1998-02-21 23:40:57 | False |'
  prefs: []
  type: TYPE_TB
- en: 'We will sample our dataset to form training data. This also helps reduce the
    size of the dataset that will be searched, making the Apriori algorithm run faster.
    We obtain all reviews from the first 200 users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can create a dataset of only the favorable reviews in our sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be searching the user''s favorable reviews for our itemsets. So, the
    next thing we need is the movies which each user has given a favorable rating.
    We can compute this by grouping the dataset by the `UserID` and iterating over
    the movies in each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we stored the values as a `frozenset`, allowing us to
    quickly check if a movie has been rated by a user.
  prefs: []
  type: TYPE_NORMAL
- en: Sets are much faster than lists for this type of operation, and we will use
    them in later code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can create a `DataFrame` that tells us how frequently each movie
    has been given a favorable review:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the top five movies by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's see the top five movies list. We only have IDs now, and will get their
    titles later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '| Movie ID | Favorable |'
  prefs: []
  type: TYPE_TB
- en: '| 50 | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 89 |'
  prefs: []
  type: TYPE_TB
- en: '| 258 | 83 |'
  prefs: []
  type: TYPE_TB
- en: '| 181 | 79 |'
  prefs: []
  type: TYPE_TB
- en: '| 174 | 74 |'
  prefs: []
  type: TYPE_TB
- en: Looking into the basics of the Apriori algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Apriori algorithm is part of our affinity analysis methodology and deals
    specifically with finding frequent itemsets within the data. The basic procedure
    of Apriori builds up new candidate itemsets from previously discovered frequent
    itemsets. These candidates are tested to see if they are frequent, and then the
    algorithm iterates as explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: Create initial frequent itemsets by placing each item in its own itemset. Only
    items with at least the minimum support are used in this step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: New candidate itemsets are created from the most recently discovered frequent
    itemsets by finding supersets of the existing frequent itemsets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All candidate itemsets are tested to see if they are frequent. If a candidate
    is not frequent then it is discarded. If there are no new frequent itemsets from
    this step, go to the last step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the newly discovered frequent itemsets and go to the second step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return all of the discovered frequent itemsets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This process is outlined in the following workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06162_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the Apriori algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the first iteration of Apriori, the newly discovered itemsets will have a
    length of 2, as they will be supersets of the initial itemsets created in the
    first step. On the second iteration (after applying the fourth step and going
    back to step 2), the newly discovered itemsets will have a length of 3\. This
    allows us to quickly identify the newly discovered itemsets, as needed in the second
    step.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can store our discovered frequent itemsets in a dictionary, where the key
    is the length of the itemsets. This allows us to quickly access the itemsets of
    a given length, and therefore the most recently discovered frequent itemsets,
    with the help of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to define the minimum support needed for an itemset to be considered
    frequent. This value is chosen based on the dataset but try different values to
    see how that affects the result. I recommend only changing it by 10 percent at
    a time though, as the time the algorithm takes to run will be significantly different!
    Let''s set a minimum support value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To implement the first step of the Apriori algorithm, we create an itemset with
    each movie individually and test if the itemset is frequent. We use `frozenset`**,**
    as they allow us to perform faster set-based operations later on, and they can
    also be used as keys in our counting dictionary (normal sets cannot).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example of `frozenset` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement the second and third steps together for efficiency by creating
    a function that takes the newly discovered frequent itemsets, creates the supersets,
    and then tests if they are frequent. First, we set up the function to perform
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In keeping with our rule of thumb of reading through the data as little as possible,
    we iterate over the dataset once per call to this function. While this doesn't
    matter too much in this implementation (our dataset is relatively small compared
    to the average computer), **single-pass** is a good practice to get into for larger
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the core of this function in detail. We iterate through
    each user, and each of the previously discovered itemsets, and then check if it
    is a subset of the current set of reviews, which are stored in `k_1_itemsets`
    (note that here, k_1 means *k-1*). If it is, this means that the user has reviewed
    each movie in the itemset. This is done by the `itemset.issubset(reviews)` line.
  prefs: []
  type: TYPE_NORMAL
- en: We can then go through each individual movie that the user has reviewed (that
    is not already in the itemset), create a superset by combining the itemset with
    the new movie and record that we saw this superset in our counting dictionary.
    These are the candidate frequent itemsets for this value of *k*.
  prefs: []
  type: TYPE_NORMAL
- en: We end our function by testing which of the candidate itemsets have enough support
    to be considered frequent and return only those that have a support more than
    our `min_support` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function forms the heart of our Apriori implementation and we now create
    a loop that iterates over the steps of the larger algorithm, storing the new itemsets
    as we increase *k* from 1 to a maximum value. In this loop, k represents the length
    of the soon-to-be discovered frequent itemsets, allowing us to access the previously
    most discovered ones by looking in our frequent_itemsets dictionary using the
    key *k - 1*. We create the frequent itemsets and store them in our dictionary
    by their length. Let''s look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If we do find frequent itemsets, we print out a message to let us know the loop
    will be running again. If we don't, we stop iterating, as there cannot be frequent
    itemsets for *k+1* if there are no frequent itemsets for the current value of
    *k*, therefore we finish the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: We use `sys.stdout.flush()` to ensure that the printouts happen while the code
    is still running. Sometimes, in large loops in particular cells, the printouts
    will not happen until the code has completed. Flushing the output in this way
    ensures that the printout happens when we want, rather than when the interface
    decides it can allocate the time to print. Don't flush too frequently though—the
    flush operation carries a computational cost (as does normal printing) and this
    will slow down the program.
  prefs: []
  type: TYPE_NORMAL
- en: You can now run the above code.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code returns about 2000 frequent itemsets of varying lengths.
    You'll notice that the number of itemsets grows as the length increases before
    it shrinks. It grows because of the increasing number of possible rules. After
    a while, the large number of combinations no longer has the support necessary
    to be considered frequent. This results in the number shrinking. This shrinking
    is the benefit of the Apriori algorithm. If we search all possible itemsets (not
    just the supersets of frequent ones), we would be searching thousands of times
    more itemsets to see if they are frequent.
  prefs: []
  type: TYPE_NORMAL
- en: Even if this shrinking didn't occur, the algorithm meets an absolute end when
    rules for a combination of all movies together is discovered. Therefore the Apriori
    algorithm will always terminate.
  prefs: []
  type: TYPE_NORMAL
- en: It may take a few minutes for this code to run, more if you have older hardware.
    If you find you are having trouble running any of the code samples, take a look
    at using an online cloud provider for additional speed. Details about using the
    cloud to do the work are given in Appendix, Next Steps.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting association rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the Apriori algorithm has completed, we have a list of frequent itemsets.
    These aren't exactly association rules, but they can easily be converted into
    these rules. A frequent itemset is a set of items with a minimum support, while
    an association rule has a premise and a conclusion. The data is the same for the
    two.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make an *association rule from a frequent itemset* by taking one of
    the movies in the itemset and denoting it as the conclusion. The other movies
    in the itemset will be the premise. This will form rules of the following form:
    *if a reviewer recommends all of the movies in the premise, they will also recommend
    the conclusion movie*.'
  prefs: []
  type: TYPE_NORMAL
- en: For each itemset, we can generate a number of association rules by setting each
    movie to be the conclusion and the remaining movies as the premise.
  prefs: []
  type: TYPE_NORMAL
- en: In code, we first generate a list of all of the rules from each of the frequent
    itemsets, by iterating over each of the discovered frequent itemsets of each length.
    We then iterate over every movie in the itemset, as the conclusion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a very large number of candidate rules. We can see some by printing
    out the first few rules in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output shows the rules that were obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In these rules, the first part (the `frozenset`[) is the list of movies in the
    premise, while the number after it is the conclusion. In the first case, if a
    reviewer recommends movie 79, they are also likely to recommend movie 258.](lrn-dtmn-py-2e_ch04.html)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we compute the confidence of each of these rules. This is performed much
    like in [Chapter 1](lrn-dtmn-py-2e_ch04.html)*, Getting Started with Data Mining*,
    with the only changes being those necessary for computing using the new data format.
  prefs: []
  type: TYPE_NORMAL
- en: The process of computing confidence starts by creating dictionaries to store
    how many times we see the premise leading to the conclusion (a correct example
    of the rule) and how many times it doesn't (an incorrect example). We then iterate
    over all reviews and rules, working out whether the premise of the rule applies
    and, if it does, whether the conclusion is accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We then compute the confidence for each rule by dividing the correct count
    by the total number of times the rule was seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can print the top five rules by sorting this confidence dictionary and
    printing the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The resulting printout shows only the movie IDs, which isn't very helpful without
    the names of the movies also. The dataset came with a file called u.items, which
    stores the movie names and their corresponding MovieID (as well as other information,
    such as the genre).
  prefs: []
  type: TYPE_NORMAL
- en: We can load the titles from this file using pandas. Additional information about
    the file and categories is available in the README file that came with the dataset.
    The data in the files is in CSV format, but with data separated by the | symbol;
    it has no header
  prefs: []
  type: TYPE_NORMAL
- en: and the encoding is important to set. The column names were found in the README
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the movie title is an important and frequently used step, therefore
    it makes sense to turn it into a function. We will create a function that will
    return a movie''s title from its MovieID, saving us the trouble of looking it
    up each time. Let''s look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In a new Jupyter Notebook cell, we adjust our previous code for printing out
    the top rules to also include the titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is much more readable (there are still some issues, but we can ignore
    them for now):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating the association rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a broad sense, we can evaluate the association rules using the same concept
    as for classification. We use a test set of data that was not used for training,
    and evaluate our discovered rules based on their performance in this test set.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will compute the test set confidence, that is, the confidence
    of each rule on the testing set. We won't apply a formal evaluation metric in
    this case; we simply examine the rules and look for good examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Formal evaluation could include a classification accuracy by determining the
    accuracy of predicting whether a user rates a given movie as favorable. In this
    case, as described below, we will informally look at the rules to find those that
    are more reliable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we extract the test dataset, which is all of the records that we didn''t
    use in the training set. We used the first 200 users (by ID value) for the training
    set, and we will use all of the rest for the testing dataset. As with the training
    set, we will also get the favorable reviews for each of the users in this dataset
    as well. Let''s look at the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We then count the correct instances where the premise leads to the conclusion,
    in the same way that we did before. The only change here is the use of the test
    data instead of the training data. Let''s look at the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we compute the confidence of each rule from the correct counts and sort
    them. Let''s look at the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we print out the best association rules with the titles instead of
    the movie IDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now see which rules are most applicable in new unseen data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The second rule, for instance, has a perfect confidence in the training data,
    but it is only accurate in 60 percent of cases for the test data. Many of the
    other rules in the top 10 have high confidences in test data, making them good
    rules for making recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: You may also notice that these movies tend to be very popular and good films.
    This gives us a baseline algorithm that we could compare against, i.e. instead
    of trying to do personalized recommendations, just recommend the most liked movies
    overall. Have a shot at implementing this algorithm - does the Apriori algorithm
    outperform it and by how much? Another baseline could be to simply recommend movies
    at random from the same genre.
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking through the rest of the rules, some will have a test confidence
    of -1\. Confidence values are always between 0 and 1\. This value indicates that
    the particular rule wasn't found in the test dataset at all.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we performed affinity analysis in order to recommend movies
    based on a large set of reviewers. We did this in two stages. First, we found
    frequent itemsets in the data using the Apriori algorithm. Then, we created association
    rules from those itemsets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of the Apriori algorithm was necessary due to the size of the dataset.
    In [Chapter 1](lrn-dtmn-py-2e_ch01.html)*, Getting Started With Data Mining*,
    we used a brute-force approach, which has exponential growth in the time needed
    to compute those rules required for a smarter approach. This is a common pattern
    for data mining: we can solve many problems in a brute force manner for small
    datasets, but smarter algorithms are required to apply the concepts to larger
    datasets.'
  prefs: []
  type: TYPE_NORMAL
- en: We performed training on a subset of our data in order to find the association
    rules, and then tested those rules on the rest of the data—a testing set. From
    what we discussed in the previous chapters, we could extend this concept to use
    cross-fold validation to better evaluate the rules. This would lead to a more
    robust evaluation of the quality of each rule.
  prefs: []
  type: TYPE_NORMAL
- en: To take the concepts in this chapter further, investigate which movies obtain
    high overall scores (i.e. lots of recommendations), but do not have adequate rules
    to recommend them to new users. How would you alter the algorithm to recommend
    these movies?
  prefs: []
  type: TYPE_NORMAL
- en: So far, all of our datasets have been described in terms of features. However,
    not all datasets are *pre-defined* in this way. In the next chapter, we will look
    at scikit-learn's transformers (they were introduced in *Chapter 3, Predicting
    Sports Winners with Decision Trees*) as a way to extract features from data. We
    will discuss how to implement our own transformers, extend existing ones, and
    concepts we can implement using them.
  prefs: []
  type: TYPE_NORMAL
