<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Modeling the Differential Drive Robot</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modeling the Differential Drive Robot</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will look at how to model the differential drive robot and create the URDF model of this robot in ROS. The main use case of the robot that we are going to design in this chapter is to serve food and drinks in hotels and restaurants. The robot is named <em>Chefbot.</em> We will cover the complete modeling of this robot in this chapter.</p>
<p>We will look at the CAD design of various mechanical components used in this robot and how to assemble them. We will look at the 2D and 3D CAD design of this robot and will discuss how to create the URDF model of the robot.</p>
<p>The actual robot model deployed in hotels may be big in size, but here we intend to build a miniature version for testing our software. If you are interested in building a robot from scratch, this chapter is for you. If you are not interested in building the robot, you can choose some robotic platforms, such as Turtlebot, which are already available on the market, to work with this book.</p>
<p>To build the robot hardware, first we need to get the requirements of the robot. After getting the requirements, we can design it and draw the model in 2D CAD tools to manufacture the robot parts. The 3D modeling of the robot will give us more idea about the looks of the robot. After the 3D modeling, we can convert the design into a URDF model that can be used along with ROS.</p>
<p>The following topics will be covered in the chapter:</p>
<ul>
<li>Designing robot parameters from the given specification</li>
<li>Designing robot body parts in 2D using LibreCAD</li>
<li>Designing a 3D robot model using Blender and Python</li>
<li>Creating a URDF model for Chefbot</li>
<li>Visualizing the Chefbot model in Rviz</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To test the application and code in this chapter, you need an Ubuntu 16.04 LTS PC/laptop with ROS Kinetic installed</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Requirements of a service robot</h1>
                </header>
            
            <article>
                
<p>Before designing any robotic system, the first procedure is to identify the requirements of the system. The following are the set of robot design requirements to be met by this robot. This includes hardware and software requirements:</p>
<ul>
<li>The robot should have a provision to carry food</li>
<li>The robot should carry a maximum payload of 2 kg</li>
<li>The robot should move at a speed between 0.25 m/s and 0.35 m/s</li>
<li>The ground clearance of the robot should be greater than 3 cm</li>
<li>The robot has to work for 2 hours continuously</li>
<li>The robot should be able to move and supply food to any table, avoiding obstacles</li>
<li>The robot height can be between 80 cm and 100 cm.</li>
<li>The robot should be of low cost (less than 500 USD)</li>
</ul>
<p>Now we have the design requirements, such as payload, speed, ground clearance, robot height, cost of the robot, and the capabilities to be implemented in the robot, we can design a robot body and select components that are matching the aforementioned requirements. Let's discuss the robot mechanism we can use to match these requirements.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Robot drive mechanism</h1>
                </header>
            
            <article>
                
<p>One of the cost-effective solutions for mobile robot navigation is the differential drive system. It's one of the simplest drive mechanisms for a mobile robot and is mainly indented for indoor navigation. The <strong>differential drive robot</strong> consists of two wheels mounted on a common axis controlled by two separate motors. There are two supporting wheels called caster wheels. This ensures stability and weight distribution of the robot. The following diagram shows a typical differential drive system:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/77e74c2b-f427-4faf-9627-e7d2f86925ab.png" style="width:34.50em;height:25.33em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Differential drive system</div>
<p>The next step is to select the mechanical components of this robot drive system, that is, mainly motors, wheels, and robot chassis. Based on the requirements, we will first discuss how to select the motor.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Selection of motors and wheels</h1>
                </header>
            
            <article>
                
<p>Motors are selected after a look at the specifications. Some of the important parameters for motor selection are torque and RPM. We can compute these values from the given requirements.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Calculation of RPM of motors</h1>
                </header>
            
            <article>
                
<p>The range of speed required for this robot is from 0.25 to 0.35m/s. We can take the maximum speed of this robot as 0.35 m/s for the design. Take the diameter of the wheel as 9 cm, because according to the requirement, the ground clearance should be greater than 3 cm and we will fix the robot body in same level as the motor shaft. In that case, we will get more ground clearance.</p>
<p>Using the following equation, we can calculate the RPM of the motors:</p>
<p><em>RPM = ((60 * Speed /(3.14 * Diameter of Wheel)</em></p>
<p><em>RPM = (60 * 0.35)/(3.14 * 0.09) = 21 / 0.2826 = 74 RPM</em></p>
<div class="packt_tip">You can also take a look at <a href="http://www.robotshop.com/blog/en/vehicle-speed-rpm-and-wheel-diameter-finder-9786"><span class="URLPACKT">http://www.robotshop.com/blog/en/vehicle-speed-rpm-and-wheel-diameter-finder-9786</span></a> for the computation.</div>
<p>The calculated RPM with a 9 cm diameter wheel and 0.35 m/s speed is 74 RPM. We can consider 80 RPM as the standard value.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Calculation of motor torque</h1>
                </header>
            
            <article>
                
<p>Let's calculate the torque required to move the robot:</p>
<ol>
<li>Number of wheels = Four wheels including two caster wheels.</li>
<li>Number of motors = Two.</li>
<li>Let's assume the coefficient of friction is 0.6 and radius of the wheel is 4.5 cm.</li>
<li>Take the total weight of robot = weight of robot + payload = (W = mg) = (~100 N + ~20 N) W= ~ 150 N, whereas total mass = 12 Kg.</li>
<li>The weight acting on the four wheels can be written as <em>2 * N1 + 2 * N2 = W</em>; that is, <em>N1</em> is the weight acting on each caster wheel and <em>N2</em> on motor wheels.</li>
<li>Assume that the robot is stationary. The maximum torque is required when the robot starts moving. It should also overcome friction.</li>
<li>We can write the frictional force as robot torque = 0 until the robot moves. If we get the robot torque in this condition, we get the maximum torque as follows:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li class="packt_nosymbol"><em>µ * N * r - T = 0</em>, where <em>µ</em> is the coefficient of friction, <em>N</em> is the average weight acting on each wheel, <em>r</em> is the radius of wheels, and <em>T</em> is the torque.</li>
<li class="packt_nosymbol"><em>N = W/2</em> (in the robot, actuation is only for two wheels, so we are taking W/2 for computing the maximum torque).</li>
<li class="packt_nosymbol">Therefore, we get:&#160;<em>0.6 * (120/2) * 0.045 - T = 0</em></li>
<li class="packt_nosymbol">Hence, <strong>T = 1.62 N-m or 16.51 Kg-cm</strong></li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The design summary</h1>
                </header>
            
            <article>
                
<p>After the design, we calculate the following values and rounding to standard motor specifications that are available in the market:</p>
<ul>
<li>Motor RPM = 80 (rounding to standard value)</li>
<li>Motor torque = 18 kg-cm</li>
<li>Wheel diameter = 9 cm</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The robot chassis design</h1>
                </header>
            
            <article>
                
<p>After computing the robot's motors and wheels parameters, we can design the robot chassis or robot body. As required, the robot chassis should have a provision to hold food, it should be able to withstand up to 5 kg payload, the ground clearance of the robot should be greater than 3 cm, and it should be low in cost. Apart from this, the robot should have a provision to place electronics components, such as a <strong>personal computer</strong> (<strong>PC</strong>), sensors, and a battery.</p>
<p>One of the easiest designs to satisfy these requirements is a multi-layered architecture such as Turtlebot 2 (<span class="URLPACKT">http://www.turtlebot.com/</span>). It has three layers in the chassis. The robot platform called <strong>Kobuki</strong> (<span class="URLPACKT">http://kobuki.yujinrobot.com/about2/</span>) is the primary drive mechanism of this platform. The Roomba platform has motors and sensors inbuilt, so there is no need to worry about designing the robot drive system. The following image shows the <strong>TurtleBot 2</strong> robot chassis design:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/c92d9887-5210-4ed3-9e3d-12a3201ce345.png" style="width:13.08em;height:17.67em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">TurtleBot 2 robot (http://robots.ros.org/turtlebot/)</div>
<p>We will design a robot similar to TurtleBot 2 with our own moving platform and components. Our design also has a three-layer architecture. Let's identify all the tools that we need before we start designing.</p>
<p>Before we start designing the robot chassis, we need <strong>computer-aided design</strong> (<strong>CAD</strong>) tools. The popular tools available for CAD are:</p>
<ul>
<li>SolidWorks (<a href="http://www.solidworks.com/default.html"><span class="URLPACKT">http://www.solidworks.com/default.html</span></a>)</li>
<li>AutoCAD (<a href="http://www.autodesk.com/products/autocad/overview"><span class="URLPACKT">http://www.autodesk.com/products/autocad/overview</span></a>)</li>
<li>Maya (<a href="http://www.autodesk.com/products/maya/overview"><span class="URLPACKT">http://www.autodesk.com/products/maya/overview</span></a>)</li>
<li>Inventor (<a href="http://www.autodesk.com/products/inventor/overview"><span class="URLPACKT">http://www.autodesk.com/products/inventor/overview</span></a>)</li>
<li>SketchUp (<a href="http://www.sketchup.com/"><span class="URLPACKT">http://www.sketchup.com/</span></a>)</li>
<li>Blender (<a href="http://www.blender.org/download/"><span class="URLPACKT">http://www.blender.org/download/</span></a>)</li>
<li>LibreCAD (<a href="http://librecad.org/cms/home.html"><span class="URLPACKT">http://librecad.org/cms/home.html</span></a>)</li>
</ul>
<p>The chassis design can be designed in any software you are comfortable with. Here, we will demonstrate the 2D model in <strong>LibreCAD</strong> and 3D model in <strong>Blender</strong>. One of the highlights of these applications is that they are free and available for all OS platforms. We will use a 3D mesh viewing tool called <strong>MeshLab</strong> to view and check the 3D model design and use Ubuntu as the main operating system. Also, we can see the installation procedures of these applications in Ubuntu 16.04 to start the designing process. We will provide tutorial links to install applications in other platforms too.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing LibreCAD, Blender, and MeshLab</h1>
                </header>
            
            <article>
                
<p><strong>LibreCAD</strong> is a free, open source 2D CAD application for Windows, OS X, and Linux. <strong>Blender</strong> is a free, open source 3D computer graphics software used to create 3D models, animation, and video games. It comes with a GPL license, allowing users to share, modify, and distribute the application. <strong>MeshLab</strong> is an open source, portable, and extensible system to process and edit unstructured 3D triangular meshes.</p>
<p>The following are the links to install LibreCAD in Windows, Linux, and OS X:</p>
<ul>
<li>Visit <a href="http://librecad.org/cms/home.htmlhttp:/librecad.org/cms/home.html"><span class="URLPACKT">http://librecad.org/cms/home.html</span></a> to download LibreCAD</li>
<li>Visit <a href="http://librecad.org/cms/home/from-source/linux.html"><span class="URLPACKT">http://librecad.org/cms/home/from-source/linux.html</span></a><span class="URLPACKT">&#160;</span><a href="http://librecad.org/cms/home/from-source/linux.html">to build LibreCAD from source</a></li>
<li>Visit <span class="URLPACKT"><a href="http://librecad.org/cms/home/installation/linux.html">http://librecad.org/cms/home/installation/linux.html</a>&#160;</span>to install LibreCAD in Debian/Ubuntu</li>
<li>Visit <a href="http://librecad.org/cms/home/installation/rpm-packages.html"><span class="URLPACKT">http://librecad.org/cms/home/installation/rpm-packages.html</span></a> to install LibreCAD in Fedora</li>
<li>Visit <a href="http://librecad.org/cms/home/installation/osx.html"><span class="URLPACKT">http://librecad.org/cms/home/installation/osx.html</span></a> to install LibreCAD in OS X</li>
<li>Visit <a href="http://librecad.org/cms/home/installation/windows.html"><span class="URLPACKT">http://librecad.org/cms/home/installation/windows.html</span></a> to install LibreCAD in Windows</li>
</ul>
<div class="packt_infobox">You can find the documentation on LibreCAD at the following link:<br/>
<a href="http://wiki.librecad.org/index.php/Main_Page"><span class="URLPACKT">http://wiki.librecad.org/index.php/Main_Page</span></a>.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing LibreCAD</h1>
                </header>
            
            <article>
                
<p>The installation procedure for all operating systems is provided. If you are an Ubuntu user, you can simply install it from the Ubuntu Software Center as well.</p>
<p>Here are the commands to install LibreCAD if you are using Ubuntu:</p>
<pre>    <strong>$ sudo add-apt-repository ppa:librecad-dev/librecad-stable</strong>
    <strong>$ sudo apt-get update</strong>
    <strong>$ sudo apt-get install librecad</strong>
  </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Blender</h1>
                </header>
            
            <article>
                
<p>Visit the following download page to install Blender for your OS platform: <a href="http://www.blender.org/download/"><span class="URLPACKT">http://www.blender.org/download/</span></a>.You can find the latest version of Blender here. Also, you can find the latest documentation on Blender at <a href="http://wiki.blender.org/"><span class="URLPACKT">http://wiki.blender.org/</span></a>.</p>
<p>If you are using Ubuntu/Linux, you can simply install Blender via the Ubuntu Software Center or use following command:</p>
<pre>    <strong>$ sudo apt-get install blender</strong>  </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing MeshLab</h1>
                </header>
            
            <article>
                
<p><strong>MeshLab</strong> is available for all OS platforms. The following link will provide you with the download links of prebuilt binaries and the source code of MeshLab:&#160;<a href="http://meshlab.sourceforge.net/"><span class="URLPACKT">http://meshlab.sourceforge.net/</span></a></p>
<p>If you are an Ubuntu user, you can install <strong>MeshLab</strong> from an apt package manager using the following command:</p>
<pre>    <strong>$sudo apt-get install meshlab</strong>  </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating 2D CAD drawing of a robot using LibreCAD</h1>
                </header>
            
            <article>
                
<p>We will take a look at the basic interface of LibreCAD. The following screenshot shows the interface of LibreCAD:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/4cdc331b-5c04-46eb-b1b3-d6f38612a98e.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">LibreCAD tool</div>
<p>A CAD toolbar has the necessary components to draw a model. The following diagram shows the detailed overview of the CAD toolbar:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/15792b40-facc-47f1-98e6-f8c093d7bd1d.png" style="width:26.33em;height:23.17em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref"><a href="http://wiki.librecad.org/"><span class="URLPACKT">http://wiki.librecad.org/</span></a></div>
<p>A detailed description of LibreCAD tools is available at the following link:<a href="http://wiki.librecad.org/index.php/LibreCAD_users_Manual"><br/>
<span class="URLPACKT">http://wiki.librecad.org/index.php/LibreCAD_users_Manual</span><br/></a></p>
<p>Here is a short explanation of each tool:</p>
<ul>
<li><strong>Command Box</strong>: This is used to draw figures by only using commands. We can draw diagrams without touching any toolbar. A detail explanation about the usage of the Command Box can be found at:</li>
<li><strong>Layer List</strong>: This will have layers used in the current drawing. A basic concept in computer-aided drafting is the use of layers to organize a drawing. A detailed explanation of layers can be found at: <a href="http://wiki.librecad.org/index.php/Layers"><span class="URLPACKT">http://wiki.librecad.org/index.php/Layers</span></a><span>.</span></li>
<li><strong>Blocks</strong>: This is a group of entities and can be inserted in the same drawing more than once with different attributes at different locations, different scales, and rotation angles. A detailed explanation of Blocks can be found at the following link: <a href="http://wiki.librecad.org/index.php/Blocks">http://wiki.librecad.org/index.php/Blocks</a><span>.</span></li>
<li><strong>Absolute Zero</strong>: This is the origin of the drawing (0,0).</li>
</ul>
<p>Now, start sketching by setting the unit of drawing. Set the drawing unit to centimeters. Open LibreCAD, and navigate to <span class="packt_screen">Edit</span> | <span class="packt_screen">Application Preference</span>. Set <span class="packt_screen">Unit</span> as <span class="packt_screen">Centimeter</span>, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/32e23b0b-cfe8-468f-968e-02726e89e1c1.png" style="width:23.42em;height:28.42em;"/></div>
<p>Let's start with the base plate design of the robot. The base plate has provisions to connect motors, place a battery, and a control board.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The base plate designs</h1>
                </header>
            
            <article>
                
<p>The following diagram shows the robot's base plate. This plate provides provisions for two motors for the differential drive and each caster wheel on the front and back of the base plate. Motors are mentioned as <strong>M1</strong> and <strong>M2</strong> in the diagram and caster wheels are represented as <strong>C1</strong> and <strong>C2</strong>. It also holds four poles to connect to the next plates. Poles are represented as <strong>P1-1</strong>, <strong>P1-2</strong>, <strong>P1-3</strong>, and <strong>P1-4</strong>. The screws are indicated as <strong>S</strong> and we will use the same screws here. There is a hole at the center to bring the wires from the motor to the top of the plate. The plate is cut on the left-hand side and the right-hand side so that the wheels can be attached to the motor. The distance from the center to the caster wheels is mentioned as <strong>12.5</strong> cm and the distance from the center to motors is mentioned as <strong>5.5</strong> cm. The center of poles is at <strong>9</strong> cm in length and <strong>9</strong> cm in height from the center. The holes of all the plates follow the same dimensions:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/910fe464-2213-46b3-a2a7-671da42cb1f6.png" style="width:28.83em;height:22.33em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Design of base plate</div>
<p>The dimensions are not marked in the diagram; instead, they are listed in the following table:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p><strong>Parts</strong></p>
</td>
<td>
<p><strong>Dimension(cm) (Length x Height) ( radius)</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>M1</strong> and <strong>M2</strong></p>
</td>
<td>
<p>5 x 4</p>
</td>
</tr>
<tr>
<td>
<p><strong>C1</strong> and <strong>C2</strong></p>
</td>
<td>
<p>Radius = 1.5</p>
</td>
</tr>
<tr>
<td>
<p><strong>S</strong> (Screw) (not shown in diagram)</p>
</td>
<td>
<p>0.15</p>
</td>
</tr>
<tr>
<td>
<p><strong>P1-1</strong>,<strong>P1-2</strong>,<strong>P1-3</strong>,<strong>P1-4</strong></p>
</td>
<td>
<p>Outer radius 0.7, Height 3.5cm</p>
</td>
</tr>
<tr>
<td>
<p>Left and right wheel sections</p>
</td>
<td>
<p>2.5 x 10</p>
</td>
</tr>
<tr>
<td>
<p>Base plate</p>
</td>
<td>
<p>Radius = 15</p>
</td>
</tr>
</tbody>
</table>
<p>&#160;</p>
<p>We will discuss the motor dimensions and clamp dimensions in more detail later.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Base plate pole design</h1>
                </header>
            
            <article>
                
<p>The base plate has four poles to extend to the next layer. The poles are <strong>3.5</strong> cm in length with a radius of <strong>0.7</strong> cm. We can extend to the next plate by attaching hollow tubes to the poles. At the top of the hollow tube, we will insert a hard plastic to make a screw hole. This hole will be useful for extending to the top layer. The base plate pole and hollow tubes on each pole are shown in the following diagram. The hollow tube has a radius of <strong>0.75</strong> cm and length of <strong>15</strong> cm:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/78ca83f3-10db-4e9e-9750-51da05d5e477.png" style="width:42.83em;height:13.58em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Design of hollow tube 15 cm</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Wheel, motor, and motor clamp design</h1>
                </header>
            
            <article>
                
<p>We have to decide the diameter of the wheel and compute motor requirements. Here, we are giving a typical motor and wheel that we can use if the design is successful:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/1afa7fb9-bdb0-4923-b804-ccffc987a3c9.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Motor design of robot</div>
<p>The motor design can vary according to the motor selection; if necessary, this motor can be taken as the design and can change after simulation. The <strong>L&#160;</strong>value in the motor diagram can vary according to the speed and torque of the motors. This is the gear assembly of the motor.</p>
<p>The following diagram shows a typical wheel that we can use with a diameter of <strong>90</strong> cm. The wheel with a diameter of <strong>86.5</strong> mm will become <strong>90</strong> mm after placing the grip:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/c19a13cb-861e-4147-a323-2ad6f47dd814.png" style="width:48.92em;height:36.17em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Wheel design of robot</div>
<p>The motors need to be mounted on the base plate. To mount, we need a clamp that can be screwed onto the plate and also connect the motor to the clamp. The following diagram shows a typical clamp that we can use for this purpose. It's an L-shaped clamp with which we can mount the motor on one side and fit another side to the plate:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/9217af88-b741-448a-a614-00a0a0d0d1ae.png" style="width:48.08em;height:37.58em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Typical clamp design of robot</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Caster wheel design</h1>
                </header>
            
            <article>
                
<p>Caster wheels need not have a special design; we can use any caster wheel that can touch the ground similar to the wheels. The following link has a collection of caster wheels that we can use for this design:&#160;<a href="http://www.pololu.com/category/45/pololu-ball-casters"><span class="URLPACKT">http://www.pololu.com/category/45/pololu-ball-casters</span></a><span class="URLPACKT">.</span><a href="http://www.pololu.com/category/45/pololu-ball-casters"></a></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Middle plate design</h1>
                </header>
            
            <article>
                
<p>The dimension of this plate is same as the base plate and the screw size is also similar:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/286755cb-0148-45d9-a978-8092c6850b00.png" style="width:32.67em;height:25.00em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Design of middle plate of robot</div>
<p>The middle plate can be held above the hollow tubes from the base plate. This arrangement is connected using another hollow tube that extends from the middle plate. The tube from the middle plate will have a screw at the bottom to fix the tube from the base plate and the middle plate and a hollow end to connect the top plate. The top and side view of the tube extending from the middle plate is shown in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/ad0087ef-9ad1-4645-be2f-8591b1d6b0ca.png" style="width:37.00em;height:11.17em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Design of hollow tube 20 cm</div>
<p>This tube will connect the middle plate to the base plate and at the same time provide a connect the top plate.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Top plate design</h1>
                </header>
            
            <article>
                
<p>The top plate is similar to the&#160;other plates; it has four small poles of 3 cm, similar to the base plate. The poles can be placed on the hollow tubes from the middle plate. The four poles are connected to the plate itself:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/c4c20270-1e8f-4660-b8ee-d11a193ccd4b.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Design of top plate</div>
<p>After the top plate design, the robot chassis design is almost finished. Let's look at the 3D model building of this robot using Blender. The 3D model is built for simulation purposes and the 2D design we build is mainly for manufacturing purposes.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with a 3D model of the robot using Blender</h1>
                </header>
            
            <article>
                
<p>In this section, we will design the 3D model of the robot. The 3D model is mainly used for simulation purposes. The modeling will be done using Blender. The version must be greater than 2.6 because we only tested the tutorials on these versions.</p>
<p>The following screenshot shows the Blender workspace and tools that can be used to work with 3D models:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/e0365757-7ac5-49e6-a1ed-cfc6b7d7757d.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Blender 3D CAD tools</div>
<p>The main reason why we are using Blender here is that we can model the robot using Python scripts. Blender has an inbuilt Python interpreter and a Python script editor for coding purposes. We will not discuss the user interface of Blender here. You can find a good tutorial of Blender on its website. Refer to the following link to learn about Blender's user interface:<a href="http://www.blender.org/support/tutorials/"><br/>
<span class="URLPACKT">http://www.blender.org/support/tutorials/</span></a><span class="URLPACKT">.</span><a href="http://www.blender.org/support/tutorials/"><br/></a></p>
<p>Let's start coding in Blender using Python.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Python scripting in Blender</h1>
                </header>
            
            <article>
                
<p><strong>Blender</strong> is mainly written in C, C++, and Python. Users can write their own Python script and access all the functionalities of Blender. If you are an expert in Blender Python APIs, you can model the entire robot using a Python script instead of manual modeling.</p>
<p>Blender uses Python 3.x. Blender. The Python APIs are generally stable, but some areas are still added and improved. Refer to <a href="http://www.blender.org/documentation/blender_python_api_2_69_7/"><span class="URLPACKT">http://www.blender.org/documentation/blender_python_api_2_69_7/</span></a> for the documentation on the Blender Python APIs.</p>
<p>Let's give a quick overview of the Blender Python APIs that we will use in our robot model script.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction to Blender Python APIs</h1>
                </header>
            
            <article>
                
<p>Python APIs in Blender can do most of the functionalities of Blender. The main jobs that can be done by the APIs are as follows:</p>
<ul>
<li>Edit any data inside Blender, such as scenes, meshes, particles, and so on</li>
<li>Modify user preferences, key maps, and themes</li>
<li>Create new Blender tools</li>
<li>Draw the 3D view using OpenGL commands from Python</li>
</ul>
<p>Blender provides the <strong>bpy</strong> module to the Python interpreter. This module can be imported in a script and gives access to Blender data, classes, and functions; scripts that deal with Blender data will need to import this module. The main Python modules we will use in bpy are:</p>
<ul>
<li><strong>Context access</strong>: This provides access to Blender user interface functions from the (<kbd>bpy.context</kbd>) script</li>
<li><strong>Data access</strong>: This provides access to the Blender internal data (<kbd>bpy.data</kbd>)</li>
<li><strong>Operators</strong>: This provides Python access to calling operators, which includes operators written in C, Python, or Macros (<kbd>bpy.ops</kbd>)</li>
</ul>
<p>For switching to scripting in Blender, we need to change the screen layout of Blender. The following screenshot shows the option that helps you to switch to the <span class="packt_screen">Scripting</span> layout:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/bacef5a3-2e89-4c8d-9328-593898a5fcce.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Blender Scripting option</div>
<p>After selecting the <span class="packt_screen">Scripting</span> tab, we can see a text editor and Python console window in Blender. In the text editor, we can code using Blender APIs and also try Python commands via the Python console. Click on the <span class="packt_screen">New</span> button to create a new Python script and name it <kbd>robot.py</kbd>. Now, we can design the 3D model of the robot using only Python scripts. The upcoming section has the complete script to design our robot model. We can discuss the code before running it. Hopefully, you have read the Python APIs of Blender from their site. The code in the upcoming section is split into six Python functions to draw three robot plates, draw motors and wheels, draw four support tubes, and export into the <strong>STereoLithography</strong> (<strong>STL</strong>) 3D file format for simulation.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Python script of the robot model</h1>
                </header>
            
            <article>
                
<p>The following is the Python script of the robot model that we will design:</p>
<ol>
<li>Before starting the Python script in Blender, we must import the <kbd>bpy</kbd> module. The <kbd>bpy</kbd> module contains all the functionalities of Blender and it can only be accessed from inside the Blender application:</li>
</ol>
<pre style="padding-left: 60px">import bpy </pre>
<ol start="2">
<li>The following function will draw the base plate of the robot. This function will draw a cylinder with a radius of 5 cm and cut a portion from the opposite sides so that motors can be connected using the <kbd>Boolean</kbd> modifier inside Blender:</li>
</ol>
<pre style="padding-left: 60px">#This function will draw base plate 
def Draw_Base_Plate(): </pre>
<ol start="3">
<li>The following two commands will create two cubes with a radius of 0.05 meters on either side of the base plate. The purpose of these cubes is to create a modifier that subtracts the cubes from the base plate. So in effect, we will get a base plate with two cuts. After cutting the two sides, we will delete the cubes:</li>
</ol>
<pre style="padding-left: 60px">bpy.ops.mesh.primitive_cube_add(radius=0.05, <br/>       location=(0.175,0,0.09))bpy.ops.mesh.primitive_cube_add(radius=0.05, <br/>       location=(-0.175,0,0.09)) 
 
    #################################################### 
    #################################################### 
 
    #Adding base plate 
bpy.ops.mesh.primitive_cylinder_add(radius=0.15, <br/>       depth=0.005, location=(0,0,0.09)) 
 
    #Adding boolean difference modifier from first cube 
 
bpy.ops.object.modifier_add(type='BOOLEAN') 
bpy.context.object.modifiers["Boolean"].operation = <br/>       'DIFFERENCE'bpy.context.object.modifiers["Boolean"].object = <br/> bpy.data.objects["Cube"] 
bpy.ops.object.modifier_apply(modifier="Boolean") 
 
    ###################################################### 
    ###################################################### 
 
    #Adding boolean difference modifier from second cube 
 
bpy.ops.object.modifier_add(type='BOOLEAN') 
bpy.context.object.modifiers["Boolean"].operation = <br/>       'DIFFERENCE'bpy.context.object.modifiers["Boolean"].object = <br/> bpy.data.objects["Cube.001"] 
bpy.ops.object.modifier_apply(modifier="Boolean") 
 
    #######################################################<br/>     ####################################################### 
 
    #Deselect cylinder and delete cubes 
bpy.ops.object.select_pattern(pattern="Cube") 
bpy.ops.object.select_pattern(pattern="Cube.001") 
bpy.data.objects['Cylinder'].select = False 
bpy.ops.object.delete(use_global=False) 
 </pre>
<ol start="4">
<li>The following function will draw motors and wheels attached to the base plate:</li>
</ol>
<pre style="padding-left: 60px">#This function will draw motors and wheels 
def Draw_Motors_Wheels():  </pre>
<ol start="5">
<li>The following commands will draw a cylinder with a radius of 0.045 and 0.01 meters in depth for the wheels. After creating the wheels, it will be rotated and translated into the cut portion of the base plate:</li>
</ol>
<pre style="padding-left: 60px">    #Create first Wheel 
 
bpy.ops.mesh.primitive_cylinder_add(radius=0.045, <br/>       depth=0.01, location=(0,0,0.07)) 
    #Rotate 
bpy.context.object.rotation_euler[1] = 1.5708 
    #Transalation 
bpy.context.object.location[0] = 0.135 
 
    #Create second wheel 
bpy.ops.mesh.primitive_cylinder_add(radius=0.045, <br/>       depth=0.01, location=(0,0,0.07)) 
    #Rotate 
bpy.context.object.rotation_euler[1] = 1.5708 
    #Transalation 
bpy.context.object.location[0] = -0.135</pre>
<ol start="6">
<li>The following code will add two dummy motors to the base plate. The dimensions of the motors are mentioned in the 2D design. The motor is basically a cylinder and it will be rotated and placed in the base plate:</li>
</ol>
<pre style="padding-left: 60px">    #Adding motors 
 
bpy.ops.mesh.primitive_cylinder_add(radius=0.018,<br/> depth=0.06, location=(0.075,0,0.075)) 
bpy.context.object.rotation_euler[1] = 1.5708 
 
bpy.ops.mesh.primitive_cylinder_add(radius=0.018,<br/> depth=0.06, location=(-0.075,0,0.075)) 
bpy.context.object.rotation_euler[1] = 1.5708 
 </pre>
<ol start="7">
<li>The following code will add a shaft to the motors, similar to the motor model. The shaft is also a cylinder and it will be rotated and inserted into the motor model:</li>
</ol>
<pre style="padding-left: 60px">    #Adding motor shaft 
bpy.ops.mesh.primitive_cylinder_add(radius=0.006,<br/> depth=0.04, location=(0.12,0,0.075)) 
bpy.context.object.rotation_euler[1] = 1.5708 
 
bpy.ops.mesh.primitive_cylinder_add(radius=0.006,<br/> depth=0.04, location=(-0.12,0,0.075)) 
bpy.context.object.rotation_euler[1] = 1.5708 
 
    #######################################################<br/> #######################################################</pre>
<ol start="8">
<li>The following code will add two caster wheels on the base plate. Currently, we are adding a cylinder as a wheel. In the simulation, we can assign it as a wheel:</li>
</ol>
<pre style="padding-left: 60px">    #Adding Caster Wheel 
 
bpy.ops.mesh.primitive_cylinder_add(radius=0.015, <br/>       depth=0.05, location=(0,0.125,0.065))bpy.ops.mesh.primitive_cylinder_add(radius=0.015, <br/>       depth=0.05, location=(0,-0.125,0.065))</pre>
<ol start="9">
<li>The following code will add a dummy Kinect sensor:</li>
</ol>
<pre style="padding-left: 60px">    #Adding Kinect 
 
bpy.ops.mesh.primitive_cube_add(radius=0.04, <br/>       location=(0,0,0.26))</pre>
<ol start="10">
<li>This function will draw the middle plate of the robot:</li>
</ol>
<pre style="padding-left: 60px">#Draw middle plate 
def Draw_Middle_Plate(): 
bpy.ops.mesh.primitive_cylinder_add(radius=0.15, <br/>       depth=0.005, location=(0,0,0.22)) 
 
#Adding top plate 
def Draw_Top_Plate(): 
bpy.ops.mesh.primitive_cylinder_add(radius=0.15, <br/>       depth=0.005, location=(0,0,0.37))</pre>
<ol start="11">
<li>This function will draw all the four supporting hollow tubes for all the three plates:</li>
</ol>
<pre style="padding-left: 60px">#Adding support tubes 
def Draw_Support_Tubes(): 
############################################################################################# 
 
    #Cylinders 
bpy.ops.mesh.primitive_cylinder_add(radius=0.007, <br/>       depth=0.30, location=(0.09,0.09,0.23))bpy.ops.mesh.primitive_cylinder_add(radius=0.007, <br/>       depth=0.30, location=(-0.09,0.09,0.23))bpy.ops.mesh.primitive_cylinder_add(radius=0.007, <br/>       depth=0.30, location=(-0.09,-0.09,0.23))bpy.ops.mesh.primitive_cylinder_add(radius=0.007, <br/>       depth=0.30, location=(0.09,-0.09,0.23))</pre>
<ol start="12">
<li>This function will export the designed robot to STL. We have to change the STL filepath before executing the script:</li>
</ol>
<pre style="padding-left: 60px">#Exporting into STL     
def Save_to_STL(): 
bpy.ops.object.select_all(action='SELECT') 
#    bpy.ops.mesh.select_all(action='TOGGLE') 
bpy.ops.export_mesh.stl(check_existing=True, <br/> filepath="/home/lentin/Desktop/exported.stl", <br/> filter_glob="*.stl", ascii=False, <br/> use_mesh_modifiers=True, axis_forward='Y', <br/> axis_up='Z', global_scale=1.0) 
 
 
#Main code 
 
if __name__ == "__main__": 
Draw_Base_Plate() 
Draw_Motors_Wheels() 
Draw_Middle_Plate() 
Draw_Top_Plate() 
Draw_Support_Tubes() 
Save_to_STL() </pre>
<ol start="13">
<li>After entering the code in the text editor, execute the script by pressing the <span class="packt_screen">Run Script</span> button, as shown in the following screenshot. The output 3D model will be shown on the 3D view of Blender. Also, if we check the desktop, we can see the <kbd>exported.stl</kbd> file for the simulation purpose:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/45f6226a-3e5c-4a58-b153-9603b79dcdc6.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Running Python script in Blender</div>
<ol start="14">
<li class="packt_nosymbol">The <kbd>exported.stl</kbd> file can be opened with MeshLab and the following is a screenshot of MeshLab:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/82c5e5d2-5009-4be1-8acf-8786fc2403d7.png" style="width:25.00em;height:23.92em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">3D model of Chefbot in MeshLab</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a URDF model of the robot</h1>
                </header>
            
            <article>
                
<p>The <strong>robot model</strong> in ROS contains packages to model the various aspects of the robot, which is specified in the XML Robot Description Format. The core package of this stack is URDF, which parses URDF files and constructs an object model of the robot.</p>
<p><strong>Unified Robot Description Format</strong> (<strong>URDF</strong>) is an XML specification to describe the model of a robot. We can represent the following features of the robot using URDF:</p>
<ul>
<li>The kinematic and dynamic description of the robot</li>
<li>The visual representation of the robot</li>
<li>The collision model of the robot</li>
</ul>
<p>The description of the robot consists of a set of <strong>links</strong> (parts), elements, and a set of <strong>joint</strong> elements, which connect these links together. A typical robot description is shown in the following code:</p>
<pre> 
&lt;robot name="chefbot"&gt; 
&lt;link&gt; ... &lt;/link&gt; 
&lt;link&gt; ... &lt;/link&gt; 
&lt;link&gt; ... &lt;/link&gt; 
 
&lt;joint&gt;  ....  &lt;/joint&gt; 
&lt;joint&gt;  ....  &lt;/joint&gt; 
&lt;joint&gt;  ....  &lt;/joint&gt; 
&lt;/robot&gt; </pre>
<div class="packt_infobox">It would be good if you refer to the following links for more information on URDF:<br/>
<a href="http://wiki.ros.org/urdf"><span class="URLPACKT">http://wiki.ros.org/urdf<br/></span></a><a href="http://wiki.ros.org/urdf/Tutorials"><span class="URLPACKT">http://wiki.ros.org/urdf/Tutorials</span></a></div>
<p><strong>Xacro</strong> (XML Macros) is an XML macro language. With xacro, we can create shorter and more readable XML files. We can use xacro along with URDF to simplify the URDF file. If we add xacro to URDF, we have to call the additional parser program to convert xacro to URDF.</p>
<div class="packt_infobox">The following link will give you further details about xacro:<br/>
<a href="http://wiki.ros.org/xacro"><span class="URLPACKT">http://wiki.ros.org/xacro</span></a></div>
<p><strong>robot_state_publisher</strong> allows you to publish the state of the robot to <strong>tf</strong> (<a href="http://wiki.ros.org/tf"><span class="URLPACKT">http://wiki.ros.org/tf</span></a>). This node read the URDF parameter called <strong>robot_description</strong> and reads the joint angles of the robot from a topic called <strong>joint_states</strong> as input and publishes the 3D poses of the robot links using the kinematic tree model of the robot. The package can be used as a library and as an ROS node. This package has been well tested and the code is stable.</p>
<ul>
<li><strong>World files</strong>: These represent the environment of Gazebo, which has to be loaded along with the robot model. <em>empty.world</em> and <em>playground.world</em> are some examples of Gazebo world files. <em>empty.world</em> contains just an empty space. In <em>playground.world</em>, there will be some static objects in the environment. We can create our own <kbd>*.world</kbd> file using Gazebo. We will cover Gazebo world files further in the next chapter.</li>
<li><strong>CMakeList.txt and package.xml</strong>: These files are created during the creation of the package. The <kbd>CmakeList.txt</kbd> file helps to build the ROS C++ nodes or libraries within a package and the <kbd>package.xml</kbd> file holds the list of all the dependencies of this package.</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a Chefbot description ROS package</h1>
                </header>
            
            <article>
                
<p>The <kbd>chefbot_description</kbd> package contains the URDF model of our robot. Before creating this package by yourself, you can go through the downloaded packages of Chefbot from <kbd>chapter3_codes</kbd>. It will help you to speed up the process.</p>
<p>Let's check how to create the <kbd>chefbot_description</kbd> package. The following procedure will guide you in creating this package:</p>
<ol>
<li>First, we need to switch to the <kbd>chefbot</kbd> folder in the <kbd>src</kbd> folder:</li>
</ol>
<pre style="padding-left: 60px">    <strong>$ cd ~/catkin_ws/src/</strong>  </pre>
<ol start="2">
<li>The following command will create the robot description package along with dependencies, such as <kbd>urdf</kbd> and <kbd>xacro</kbd>. This will create the <kbd>chefbot_description</kbd> package in the <kbd>catkin_ws/src</kbd> folder:</li>
</ol>
<pre style="padding-left: 60px">    <strong>$ catkin_create_pkgchefbot_descriptioncatkinxacro</strong>  </pre>
<ol start="3">
<li>Copy all the folders from the downloaded <kbd>chefbot_description</kbd>&#160;package to the new package folder. The <kbd>meshes</kbd> folder holds the 3D parts of the robot and the <kbd>urdf</kbd> folder contains the URDF files that have the kinematics and dynamics model of the robot. The robot model is split into several xacro files, which enables easier debugging and better readability.</li>
</ol>
<p>Let's look at the functionality of each file inside this package. You can check each of the files inside <kbd>chefbot_description</kbd>. The following diagram shows the files inside this package:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/902c33d6-de00-4fcc-a863-6c56f9a3e31c.png" style="width:35.75em;height:17.67em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref"><em>Chefbot description package</em></div>
<p>The functionalities of each file in the package are as follows:</p>
<ul>
<li><kbd>urdf/chefbot.xacro</kbd>: This is the main xacro file that has kinematic and dynamic parameters of the robot.</li>
<li><kbd>urdf/common_properties.xacro</kbd>: This xacro file consists of some properties and its values used inside the robot model. For example, different color definitions of robot links and some constants.</li>
<li><kbd>gazebo/chefbot.gazebo.xacro</kbd>: This file consists of simulation parameters of the robot. It mainly has Gazebo parameters and plugins for performing simulations. These parameters will only be active when we start the simulation using this model.</li>
<li><kbd>launch/upload_model.launch</kbd>: This launch file has a node that basically parses the robot xacro file and uploads the parsed data to a ROS parameter called <kbd>robot_description</kbd>. The <kbd>robot_description</kbd>&#160;parameter is then used in Rviz for visualization and used in Gazebo for simulation. If our xacro model is wrong, then this launch file will throw an error.</li>
<li><kbd>launch/view_model.launch</kbd>: This launch file will upload the robot URDF model and view the model in Rviz.</li>
<li><kbd>launch/view_navigation.launch</kbd>: The will show the URDF model and navigation-related display types in Rviz.</li>
<li><kbd>launch/view_robot_gazebo.launch</kbd>: This will launch the URDF model in Gazebo and start all Gazebo plugins.</li>
<li><kbd>meshes/</kbd>: This folder contains the necessary meshes for the robot model.</li>
<li>You can build the workspace using the <em>catkin_make</em> command.</li>
</ul>
<p>After building the packages, we can launch the Chefbot model in Rviz using the following command:</p>
<pre>    <strong>$ roslaunch chefbot_descriptionview_robot.launch</strong>  </pre>
<p>The robot model in Rviz is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/060447dc-471a-4ba0-ac05-4ae76553b7e1.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Chefbot URDF model in Rviz</div>
<p>Here is the <kbd>view_robot.launch</kbd> file that visualizes the robot in Rviz:</p>
<pre>&lt;launch&gt; 
 
&lt;!-- This launch file will parse the URDF model and create robot_description parameter  - -&gt; 
 
&lt;include file="$(find chefbot_description)/launch/upload_model.launch" /&gt; 
 
&lt;!-Publish TF from joint states -- &gt; 
 
&lt;node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher" /&gt; 
 
 
&lt;!-Start slider GUI for controlling the robot joints -- &gt; 
&lt;node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher" args="_use_gui:=True" /&gt; 
 
 
&lt;!-Start Rviz with a specific configuration -- &gt; 
 
&lt;node name="rviz" pkg="rviz" type="rviz" args="-d $(find chefbot_description)/rviz/robot.rviz" /&gt; 
 
&lt;/launch&gt; </pre>
<p>Here is the definition of <kbd>upload_model. launch</kbd>. The <kbd>xacro</kbd> command is to parse the <kbd>chefbot.xacro</kbd> file and store to <kbd>robot_description</kbd>:</p>
<pre>&lt;launch&gt; 
 
&lt;!-- Robot description --&gt; 
&lt;param name="robot_description" command="$(find xacro)/xacro --inorder '$(find chefbot_description)/urdf/chefbot.xacro'" /&gt; 
 
&lt;/launch&gt; </pre>
<p>We can have a look at the <kbd>udf/chefbot.xacro</kbd>, which is the main URDF model file. We can see how the links and joints are defined inside the xacro file.</p>
<p>The following code snippet shows the header of the robot xacro model. It has an XML version, robot name, and it includes some other xacro files, such as <kbd>common_properties.xacro</kbd> and <kbd>chefbot.gazebo.xacro.</kbd> After that, we can see some camera properties that are defined in the header:</p>
<pre>&lt;?xml version="1.0"?&gt; 
 
&lt;robot name="chefbot" xmlns:xacro="http://ros.org/wiki/xacro"&gt; 
 
 
&lt;xacro:include filename="$(find chefbot_description)/urdf/common_properties.xacro" /&gt; 
 
&lt;xacro:include filename="$(find chefbot_description)/gazebo/chefbot.gazebo.xacro" /&gt; 
 
&lt;xacro:property name="astra_cam_py" value="-0.0125"/&gt; 
&lt;xacro:property name="astra_depth_rel_rgb_py" value="0.0250" /&gt; 
&lt;xacro:property name="astra_cam_rel_rgb_py"   value="-0.0125" /&gt; 
&lt;xacro:property name="astra_dae_display_scale"   value="0.8" /&gt; </pre>
<p>The following code snippet shows the definition of links and joints in the model:</p>
<pre>&lt;link name="base_footprint"/&gt; 
 
&lt;joint name="base_joint" type="fixed"&gt; 
&lt;origin xyz="0 0 0.0102" rpy="0 0 0" /&gt; 
&lt;parent link="base_footprint"/&gt; 
&lt;child link="base_link" /&gt; 
&lt;/joint&gt; 
&lt;link name="base_link"&gt; 
&lt;visual&gt; 
&lt;geometry&gt; 
&lt;!-- new mesh --&gt; 
&lt;mesh filename="package://chefbot_description/meshes/base_plate.dae" /&gt; 
&lt;material name="white"/&gt; 
&lt;/geometry&gt; 
 
 
   &lt;origin xyz="0.001 0 -0.034" rpy="0 0 ${M_PI/2}"/&gt; 
&lt;/visual&gt; 
&lt;collision&gt; 
&lt;geometry&gt; 
&lt;cylinder length="0.10938" radius="0.178"/&gt; 
&lt;/geometry&gt; 
&lt;origin xyz="0.0 0 0.05949" rpy="0 0 0"/&gt; 
&lt;/collision&gt; 
&lt;inertial&gt; 
&lt;!-- COM experimentally determined --&gt; 
&lt;origin xyz="0.01 0 0"/&gt; 
&lt;mass value="2.4"/&gt;&lt;!-- 2.4/2.6 kg for small/big battery pack --&gt; 
 
&lt;inertia ixx="0.019995" ixy="0.0" ixz="0.0" 
iyy="0.019995" iyz="0.0"  
izz="0.03675" /&gt; 
&lt;/inertial&gt; 
&lt;/link&gt; </pre>
<p>In this code, we can see the definition of two links called <kbd>base_footprint</kbd>&#160;and <kbd>base_link</kbd>. The <kbd>base_footprint</kbd> link is a dummy link, meaning it has any properties; it is just for showing the origin of the robot. The <kbd>base_link</kbd> is the origin of the robot and it has visual and collision properties. We can also see that the link is visualized as a mesh file. We can also see the inertial parameters of the link in the definition. The joint is the combination of two link. We can define a joint in URDF by mentioning two links and the type of the joint. There are different types of joints available in URDF, such as fixed, revolute, continuous, and prismatic. In this snippet, we are creating a fixed joint because there is no movement between these frames.</p>
<p>This chapter has been all about the basics of the Chefbot URDF. We will learn more about Chefbot simulation and give an explanation of the parameters in the next chapter.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed the modeling of the Chefbot robot. The modeling involves 2D and 3D designing of the robot hardware and ends up in as URDF model, which can be used in ROS. The chapter started with the various requirements to be satisfied by the robot and we have seen how to calculate various design parameters. After calculating the design parameters, we started to design the 2D sketches of the robot hardware. The designing was done using LibreCAD, a free CAD tool. After that, we worked on the 3D model in Blender using Python scripting. We have created the mesh model from Blender and created the URDF model of the robot. After the creation of the URDF model, we looked at how to visualize the robot in Rviz.</p>
<p>In the next chapter, we will discuss how to simulate this robot and perform mapping and localization.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is robot modeling and what are its uses?</li>
<li>What is the aim of a 2D robot model?</li>
<li>What is the aim of a 3D robot model?</li>
<li>What is the advantage of Python scripting over manual modeling?</li>
<li>What is a URDF file and what are its uses?</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>To learn more about URDF and Xacro and Gazebo you can refer book: <em>Mastering ROS for Robotics Programming - Second&#160;Edition</em> (<a href="https://www.packtpub.com/hardware-and-creative/mastering-ros-robotics-programming-second-edition">https://www.packtpub.com/hardware-and-creative/mastering-ros-robotics-programming-second-edition</a>)</p>


            </article>

            
        </section>
    </div>
</body>
</html>