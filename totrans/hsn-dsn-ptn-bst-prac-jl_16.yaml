- en: Inheritance and Variance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we had to choose the most important thing to learn in Julia, or in any programming
    language, then it has to be the concept of the data type. Abstract types and concrete
    types work together, providing the programmer with a powerful tool to model solutions
    to solve real-world problems. Multiple dispatch rely on well-defined data types
    to invoke the right functions. Parametric types are used so that we can reuse
    the basic structure of an object with a specific physical representation of the
    underlying data. As you can see, having a well-thought-out design for data types
    is of the utmost importance in software engineering practice.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules, Packages,
    and Data Type Concepts*, we learned about the basics of abstract and concrete
    types and how to build a type hierarchy based upon an inheritance relationship
    between the types. In [Chapter 3](6c453014-3590-4a63-9d39-9bdd735185d5.xhtml), *Designing
    Functions and Interfaces,* and [Chapter 5](962e7c27-570f-498e-89b9-d9075c58cd45.xhtml),
    *Reusability Patterns*, we also touched on the subject of parametric types and
    parametric methods. In order to utilize these concepts and language features effectively,
    we need a good understanding of how *subtyping* works. It may sound similar to
    inheritance, but it is fundamentally different.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go deeper and explore the meaning of subtyping and
    related topics, which includes the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation inheritance and behavior subtyping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covariance, contravariance, and invariance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parametric methods and diagonal rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good understanding of subtyping
    in Julia. You will be more equipped to design your own data type hierarchy and
    utilize multiple dispatch more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample source code is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: The code is tested in a Julia 1.3.0 environment.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing inheritance and behavior subtyping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we learned about inheritance, we realized that abstract types can be used
    to describe real-world concepts. We can say quite confidently that we already
    know how to classify concepts with parent–child relationships. With this knowledge,
    we can build a type hierarchy around those concepts. For example, the personal
    asset type hierarchy from [Chapter 2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules,
    Packages, and Data Type Concepts*, looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc754bd8-c903-4a4a-96e7-76ff9b6dfb2f.png)'
  prefs: []
  type: TYPE_IMG
- en: All data types shown in the preceding diagram are abstract types. Going from
    the bottom up, we know that both **House** and **Apartment** are subtypes of **Property**,
    and we know that both **Property** and **Investment** are a subtype of **Asset**.
    These are all reasonable interpretations based on how we speak about these concepts
    in our daily life.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also talked about concrete types that are the physical realization of abstract
    concepts. For this same example, we ended up having `Stock` as a subtype of `Equity`
    and `Bond` as a subtype of `FixedIncome`. As you may recall, the `Stock` type
    can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Back then, we did not emphasize the fact that we cannot declare any field inside
    abstract types, which is something that is given in some **object-oriented programming**
    (**OOP**) languages, such as Java. If you come from an OOP background, then you
    may mistakenly feel that this is a huge constraint in Julia's inheritance system. Why
    is Julia designed the way it is? In this section, we will try to analyze inheritance
    in greater depth and answer this very question.
  prefs: []
  type: TYPE_NORMAL
- en: There are two important concepts related to inheritance that are very similar,
    but fundamentally different—implementation inheritance and behavior subtyping.
    We will discuss both in the next few sections. Let's start with implementation
    inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding implementation inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementation inheritance allows a subclass to inherit *both* fields and methods
    from its superclass. As Julia does not support implementation inheritance, we
    will switch language for a moment and present the following example in Java. Here
    is a class that provides a container for holding any number of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Bag` class basically maintains a list of objects in the `items` field and
    provides two convenient functions, `add` and `addMany`, for adding a single object
    or an array of objects to the bag.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate code reuse, we can develop a new `CountingBag` class that inherits
    from `Bag` and provides additional functionality for keep tracking of how many
    items are stored in the bag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `CountingBag` class, we have a new field called `count` to keep track
    of the bag size. Whenever a new item is added to the bag, the `count` variable
    is incremented. The `size` function is used to report the size of the bag. So
    what is the situation with `CountingBag`? Let''s quickly summarize:'
  prefs: []
  type: TYPE_NORMAL
- en: The `count` field is available as defined here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `items` field is available as inherited from `Bag`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `add` method overrides the parent's implementation, but it also reuses the
    parent's method via `super.add`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `addMany` method is available as inherited from `Bag`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `size` method is available as defined here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As both fields and methods are inherited, this is called implementation inheritance.
    The effect is almost the same as if the code from the superclass was copied into
    the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's talk about behavior subtyping.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding behavior subtyping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavior subtyping is sometimes called interface inheritance. In order to avoid
    confusion with the overloaded word *inheritance*, we will avoid using the term
    interface inheritance here. Behavior subtyping says that a subtype only inherits
    behaviors from the supertype.
  prefs: []
  type: TYPE_NORMAL
- en: As we switch the language back to Julia, we will refer to *types* rather than
    *classes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia supports behavior subtyping. Every data type inherits functions that
    are defined for its supertype. Let''s try a quick and fun exercise in the Julia
    REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96050300-8545-44fa-8d6e-c5203674b49d.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, an abstract type, `Vehicle`, is defined with a subtype of `Car`. We have
    also defined a `move` function for `Vehicle`. When we pass a `Car` object to the
    `move` function, it still works properly because `Car` is a subtype of `Vehicle`.
    This is consistent with the Liskov substitution principle, which says that a program
    accepting type T can also accept any subtype of T and continue to work properly
    without any unintended outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the inheritance of a method can travel quite far over multiple levels.
    Let''s create another level of abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f69026c-ab52-4d4e-a7b4-5cf07ad3ed9b.png)'
  prefs: []
  type: TYPE_IMG
- en: We just defined a new `FlyingVehicle` abstract type and a `Helicopter` struct.
    The `move` function is available for a helicopter as inherited from `Vehicle`,
    and the `liftoff` function is also available, as inherited from `FlyingVehicle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional methods can be defined for more specific types, and the most specific
    one would be chosen for dispatch. Doing this essentially has the same effect as
    method overrides in implementation inheritance. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1656f588-ca10-4176-b729-89c4be8ecf13.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, we have defined two `liftoff` methods—one accepting `FlyingVehicle`
    and another for `Helicopter`. When a `Helicopter` object is passed to the function,
    it is dispatched to the one defined for `Helicopter`, because it is the most specific
    method that works with helicopters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relationship can be summarized in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5949296-b354-4bc5-8cdf-62454a8696ea.png)'
  prefs: []
  type: TYPE_IMG
- en: According to behavior subtyping, a car should behave like a vehicle, a flying
    vehicle should behave like a vehicle, and a helicopter should behave like a flying
    vehicle and also like a vehicle. Behavior subtyping allows us to reuse the behavior
    already defined for a supertype.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, behavior subtyping can be achieved using interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know about implementation inheritance and behavior subtyping, we
    can revisit our earlier question: why does Julia not support implementation inheritance?
    What are the reasons for not following other mainstream OOP languages? In order
    to understand this, we can review some of the well-known issues with implementation
    inheritance. Let''s start with the square-rectangle problem.'
  prefs: []
  type: TYPE_NORMAL
- en: The square-rectangle problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Julia does not support implementation inheritance. Let''s list the reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: All concrete types are final, so there is no way to create new subtypes from
    another concrete type. Therefore, it is not possible to inherit object fields
    from anywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot declare any field in an abstract type because otherwise, it would
    be concrete rather than abstract.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core developers of the Julia programming language made a very early design
    decision to avoid implementation inheritance for a number of reasons. One of them
    is the so-called *square-rectangle problem*, also sometimes called the circle-ellipse
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The square-rectangle problem presents a clear challenge for implementation
    inheritance. As we know by common sense, every square is a rectangle with an additional
    constraint that the length of both sides is equal. In order to model these concepts
    in a class-based, object-oriented language, we may attempt to create a `Rectangle`
    class and a `Square` subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddda9d4a-64a2-4579-9d76-39de1690d6fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Very quickly, we realize that we have already gotten ourselves into trouble.
    If a `Square` has to inherit all fields from its parent class, then it would have
    inherited both `width` and `height`. But we really want to have a single field
    called `length` instead.
  prefs: []
  type: TYPE_NORMAL
- en: The exact same issue is sometimes presented as the circle–ellipse problem. In
    that case, a circle is an ellipse, but there is only one radius rather than major
    and minor axis lengths.
  prefs: []
  type: TYPE_NORMAL
- en: How do we solve this kind of problem? Well, one way is to ignore the issue and
    create a `Square` subclass without any field defined. Then, when a `Square` is
    instantiated with a particular length, both `width` and `height` fields are populated
    with the same value. Is that good enough? The answer is no. Given that `Square`
    also inherits the methods of `Rectangle`, we probably need to provide override
    methods for the mutating methods, such as `setWidth` and `setHeight`, so that
    we can keep both fields with the same value. In the end, we have a solution that
    seems to work functionally but is terrible in performance and memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: But how did we get into trouble in the first place? To analyze this further,
    we should realize that a square, while it can be classified as a rectangle, is
    a more restrictive version of a rectangle in nature. This is already starting
    to sound unintuitive—typically, when we create subclasses, we extend the parent
    class and *add* more fields and functionalities. When do we want to remove fields
    or functionality in subclasses? It already seems to be logically backward. Maybe
    we should make `Rectangle` a subclass of `Square`? That does not sound very logical
    either.
  prefs: []
  type: TYPE_NORMAL
- en: We end up with a conundrum. On one hand, we would like to model real-world concepts
    properly in code. On the other hand, the code does not really fit without causing
    maintenance or performance issues. By now, we cannot help but ask ourselves whether
    we really want to write code to work around problems with implementation inheritance.
    We don't.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps you are not yet 100% convinced that implementation inheritance is more
    evil than good. Let's look at another problem.
  prefs: []
  type: TYPE_NORMAL
- en: The fragile base class problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another problem with implementation inheritance is that changes to the base
    class (parent class) can possibly break functionalities of its subclasses. From
    the earlier Java example, we have a `CountingBag` class that extends from the
    `Bag` class. Let''s look at the complete source code, including the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e281b138-70b8-4936-b9a9-c09558b5868e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The program simply creates a `CountingBag` object. Then it adds `apple` using
    the `add` method and adds `banana` and `orange` using the `addMany` method. Finally,
    it prints out the items in the bag and the size of the bag. The output is shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70e7db7a-c377-4e93-b16d-4b0f4387d178.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Everything looks fine at the moment. But let''s say that the original author
    of `Bag` realizes that the `addMany` method can be improved by directly adding
    objects into the `items` array list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd1de7db-5bd9-4fe7-bd7b-109a478b90f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unfortunately, this seemingly safe change in the parent class ends up in a
    disaster for `CountingBag`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5f402ab-e3d6-4d02-b68a-1994cd3f2cb4.png)'
  prefs: []
  type: TYPE_IMG
- en: What happened? When `CountingBag` was designed, it was assumed that the `add`
    method would always be called when new items are added to the bag. When the `addMany`
    method stops calling the `add` method, the assumption no longer applies.
  prefs: []
  type: TYPE_NORMAL
- en: Whose fault is this? Of course, the designer of the `Bag` class cannot foresee
    who will inherit the class. The change in the `addMany` method did not violate
    any contract; the same functionality is provided, only with a different implementation
    under the hood. The designer of the `CountingBag` class thought it was wise to
    *tag along* and leverage the fact that `addMany` was already calling the `add`
    method, and so only the `add` method needed to be overridden to make `counting`
    work.
  prefs: []
  type: TYPE_NORMAL
- en: This poses a second issue with implementation inheritance. The subclass developer
    has too much knowledge about the implementation of the parent class. The ability
    to override the parent class's `add` method has also violated the principle of
    encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does OOP solve this problem? In Java, there are multiple facilities to
    prevent the problem presented in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: A method can be annotated with the `final` keyword to prevent the subclass from
    overriding the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A field can be annotated with the `private` keyword to prevent the subclass
    from accessing the field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The trouble is that the developer must *anticipate* how classes are going to
    be inherited *in the future*. Methods must be carefully examined to determine
    whether it is safe to allow subclasses to access or override. Likewise for fields.
    As you can see, the problem is called the fragile base class problem for a good
    reason.
  prefs: []
  type: TYPE_NORMAL
- en: I hope we have shown you that implementation inheritance does more harm than
    good. For reference, in the GoF design patterns book, it was also suggested that
    composition is preferred over inheritance. Julia took a more radical approach
    by just disallowing implementation inheritance altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go a little further and look at a specific kind of behavior subtyping
    called duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting duck typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to implement behavior subtyping: **nominal subtyping** and
    **structural subtyping**:'
  prefs: []
  type: TYPE_NORMAL
- en: With nominal subtyping, you must explicitly define the relationship between
    a type and its supertype. Julia uses nominal subtyping, where types are explicitly
    annotated in function arguments. That is why a type hierarchy needs to be built
    to express type relationships.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With structural subtyping, the relationship is implicitly derived as long as
    the subtype implements the required functions from the supertype. Julia supports
    structural subtyping when functions are defined with arguments and not annotated
    with any type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Julia supports structural subtyping via **duck typing***. *We first mentioned
    duck typing in [Chapter 3](6c453014-3590-4a63-9d39-9bdd735185d5.xhtml), *Designing
    Functions and Interfaces*. The saying is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"If it walks like a duck and quacks like a duck, then it is a duck."'
  prefs: []
  type: TYPE_NORMAL
- en: In a dynamic type language, we sometimes care less about the exact type as long
    as we get the behavior we want. If we just want to hear a quack sound, who cares
    if we get a frog? As long as it makes that quack sound, we will be happy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we want duck typing for good reasons. For example, we do not normally
    consider horses as vehicles; however, think about the old days when horses were
    used for transport. In our definition, anything that implements the `move` function
    can be considered a vehicle. So, if we have any algorithm that needs something
    that moves, then there is no reason why we cannot pass a `horse` object to the
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8335a797-ae4f-41cc-8199-e198d79355a3.png)'
  prefs: []
  type: TYPE_IMG
- en: For some people, duck typing is a little loose because you cannot easily figure
    out whether a type supports an interface (such as `move`). The general remedy
    is to use the Holy Trait pattern as described in [Chapter 5](962e7c27-570f-498e-89b9-d9075c58cd45.xhtml),
    *Reusability Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at an important concept called variance.
  prefs: []
  type: TYPE_NORMAL
- en: Covariance, invariance, and contravariance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it turns out, the rules for subtyping are not very straightforward. When
    you look at a simple type hierarchy, you can immediately tell whether one type
    is a subtype of another by tracing the relationships of the data types in the
    hierarchy. The situation becomes more complex when parametric types are involved.
    In this section, we will take a look at how Julia is designed with respect to
    **variance**, a concept that explains subtyping relationships for parametric types.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first review the different kinds of variance.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding different kinds of variance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are four different kinds of variance as described in computer science
    literature. We will first describe them in a formal manner first and then come
    back to do more hands-on exercises to reinforce our understanding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that `S` is a subtype of `T`, there are four different ways to reason
    about the relationship between parametric types `P{S}` and `P{T}`:'
  prefs: []
  type: TYPE_NORMAL
- en: Covariant: `P{S}` is a subtype of `P{T}` (`co` here means the same direction)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contravariant: `P{T}` is a subtype of `P{S}` (`contra` here means the opposite
    direction)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Invariant: neither covariant nor contravariant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bivariant: both covariant and contravariant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When do we find variance useful? Perhaps not too surprisingly, variance is a
    key ingredient whenever multiple dispatch come into action. Based on the Liskov
    substitution principle, the language runtime must figure out whether the object
    being passed is a subtype of the method argument before dispatching to the method.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, variance is one thing that often diverges between different programming
    languages. Sometimes, there are historical reasons for this, and sometimes it
    depends on the target use cases for the language. In the next few sections, we
    will explore the topic from several angles. We will start with parametric types.
  prefs: []
  type: TYPE_NORMAL
- en: Parametric types are invariant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the purposes of illustration, we will consider a popular type hierarchy
    that is used by some of the OOP literature— the animal kingdom! Everyone loves cats and dogs.
    I have also included crocodiles here to explain related concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0d31151-e2ba-40a1-83ec-577dc147b3c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The corresponding code to build such a hierarchy is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, we can also define the `show` function for these new types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Given such a type hierarchy, we can verify how subtypes are handled with the
    following `adopt` function. As nobody wants to adopt crocodiles (well, not me
    at least), we are restricting the function argument to subtypes of `Mammal` only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we can adopt only cats and dogs, but not crocodiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08975459-70fb-4a06-8959-06e12fc51f84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What if we want to adopt many pets at the same time? Intuitively, we can just
    define a new function that takes an array of mammals, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, it already failed our very first test for adopting Felix and
    Garfield:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01812bf9-c675-4bed-824f-2e5a69590859.png)'
  prefs: []
  type: TYPE_IMG
- en: What is going on? We know cats are mammals, so why would an array of cats not
    be passed to the method that takes an array of mammals? The answer is simple—parametric
    types are invariant. Here comes the very first surprise for people coming from
    an OOP background, for which parametric types are often covariant.
  prefs: []
  type: TYPE_NORMAL
- en: By invariance, even though `Cat` is a subtype of `Mammal`, we cannot say that `Array{Cat,1}`
    is a subtype of `Array{Mammal,1}`. In addition, an `Array{Mammal,1}` actually
    represents a one-dimensional array of `Mammal` objects, for which each object
    can be any subtype of `Mammal`. As each concrete type may have different memory
    layout requirements, this array must store pointers rather than actual values.
    Another way to say this is that the objects are *boxed*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to dispatch to this method, we must create an `Array{Mammal,1}`. This
    can be achieved by prefixing the array constructor with `Mammal`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice, this happens a lot more often when we have to handle an array
    of objects of the same type. In Julia, we can express such a homogeneous array
    using the type expression `Array{T,1} where T`. This means that we can define
    a new `adopt` method that can accept multiple mammals as long as they are the
    same kind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test the new `adopt` method now. The results are shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc685976-7a59-424d-92c3-19f7172e0ca1.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, the new `adopt` method was dispatched accordingly, depending on
    whether the array contains `Mammal` pointers or physical values of cats or dogs.
  prefs: []
  type: TYPE_NORMAL
- en: In Julia, the choice of making parametric types invariant is a conscious design
    decision for practical reasons. When an array contains concrete type objects,
    the memory can be allocated to store these objects in a very compact manner. On
    the other hand, when an array contains boxed objects, every reference to an element
    would involve dereferencing a pointer to find the object, and performance would
    suffer as a result.
  prefs: []
  type: TYPE_NORMAL
- en: There is indeed one place where Julia uses covariance, that is, method arguments.
    We will discuss these next.
  prefs: []
  type: TYPE_NORMAL
- en: Method arguments are covariant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It should be quite intuitive that method arguments are covariant because that
    is how multiple dispatch work today. Consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In Julia, method arguments are formally represented as a tuple. In the preceding
    example, the method argument is just `Tuple{Mammal,Mammal}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call this function with two arguments that have type `S` and `T` respectively,
    then it will only be dispatched if `S <: Mammal` and `T <: Mammal`. In this case,
    we should be able to pass any combination of mammals—dog/dog, dog/cat, cat/dog,
    and cat/cat. The following screenshot proves this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9aeb3a9-4749-4f57-9803-ef6dd7eb3113.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s also check whether a crocodile can join the party:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0679c679-a85a-4ff3-a6e7-d24c44bf0e07.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, `Tuple{Cat,Crocodile}` is not a subtype of `Tuple{Mammal,Mammal}`
    since `Crocodile` is not a `Mammal`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's move on to a more complex scenario. As we know, functions are first-class
    citizens in Julia. How do we determine whether a function is a subtype of another
    function during dispatch?
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting function types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Julia, functions are first class. This means that functions can be passed
    around as variables and can appear in method arguments. Since we have learned
    about the covariance property of method arguments, how do we handle the situation
    where functions are passed as arguments?
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to understand this is to see how functions are typically passed.
    Let''s pick a simple example from Base:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a999d78-16eb-42bc-8a5f-e2a539f5f27d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `all` function can be used to check whether a certain condition is evaluated
    as `true` for all elements in an array. To make it more flexible, it can accept
    a custom predicate function. For example, we can check whether all numbers are
    odd in an array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4209a799-e7c9-4217-b5b7-1a398fb71426.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Although we know it was dispatched correctly, we can also confirm that the
    type of `isodd` is a subtype of `Function` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4434e2fa-6ca2-498d-96cf-267eaa01f707.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It turns out that all Julia functions have their own unique type, displayed
    as `typeof(isodd)` in the following code, and they all have a supertype of `Function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa1c951e-48d1-424e-ad85-ad844d47db9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Because the `all` method was defined to accept any `Function` objects, we can
    actually pass any function and Julia will gladly dispatch to the method. Unfortunately,
    this can potentially lead to undesirable results, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6ff550d-00ed-4735-bbe0-918983883945.png)'
  prefs: []
  type: TYPE_IMG
- en: We are getting an error here because the function being passed to `all` is supposed
    to take an element and return a Boolean value. Since `println` always returns
    `nothing`, the `all` function just raised an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case that a stronger type is demanded, the specific function type can
    be enforced as such. Here is how we can create a safer `all` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SignFunctions` constant is a union type that consists of only the types
    for the `isodd` and `iseven` functions. As such, the `myall` method will only
    be dispatched when the first argument is `isodd` or `iseven`; otherwise, a method
    error will be raised, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ee0ccdd-170d-4e0b-a259-be37bb21ef1a.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, doing this severely limits the usefulness of the function. We must
    also enumerate all possible functions that may be passed, and that is not always
    feasible. So it seems that the means to handle function arguments is somewhat
    limited.
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to the topic of variance, there is really nothing to talk about
    when all functions are final and there is only one supertype for all of them.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, when we design software, we do care about the types of functions.
    As shown in the preceding example, the `all` function can only work with functions
    that take a single argument and return a Boolean value. That should be the interface
    contract. How do we enforce that contract, though? At the end of the day, we need
    to have a better understanding of functions and the contractual agreement between
    the caller and callee. The contract can be seen as a combination of method arguments
    and return types. Let's figure out whether there is a better way to handle this
    issue in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the variance of the function type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will attempt to understand how to reason about function
    types. While Julia does not provide too much help in formalizing function types,
    it does not stop us from doing the analysis ourselves. In some strongly typed,
    static OOP languages, function types are more formally defined as the combination
    of method arguments and return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that a function takes three arguments and returns a single value. Then
    we can describe the function with the following notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20adb83e-9cde-434f-b3b8-cca09921e542.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s continue the animal kingdom example and define some new variables and
    functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined two arrays—one for female dogs and another for female
    cats. The `select` function can be used to randomly select a dog or cat. Next,
    let''s consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `match` function takes a `Mammal` and returns an object of the same type.
    Here''s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/636f421a-423d-4475-9149-328b536b2dae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Given that the `match` function can only return `Dog` or `Cat`, we can reason
    the function type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23c279b7-77fd-4332-9e6d-763ad4ead096.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Suppose that we define two more functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `meet_partner` function takes a `finder` function as the first argument.
    Then, it calls the `finder` function to find a partner and finally `kiss` the
    partner. By design, we are going to pass the `match` function that we defined
    in the preceding code. Let''s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cdec294-de8f-4039-abad-3fc372949b12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, so good. From the perspective of the `meet_partner` function, it expects
    the `finder` function to accept a `Mammal` argument and returns a `Mammal` object.
    That is exactly how the `match` function was designed. Now, let''s see if we can
    mess it up by defining a function that does not return a mammal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the `neighbor` function can take a mammal as an argument, it returns
    a crocodile, which is a reptile rather than a mammal. If we try to pass it to
    the `meet_partner` function, we are met with disaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc5086ca-29d5-48d9-85d4-a55d3de7b023.png)'
  prefs: []
  type: TYPE_IMG
- en: What we have just proven is quite intuitive. As the return type of the `finder`
    function is expected to be a `Mammal`, any other `finder` function that returns
    any subtype of `Mammal` would also work. So the return type of function types
    is covariant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what about the arguments of function types? Again, the `meet_partner`
    function is expected to pass any mammal to the `finder` function. The `finder`
    function must be able to accept either a `dog` or `cat` object. It would not work
    if the `finder` function only takes a cat or dog. Let''s see what happens if we
    have a more restrictive `finder` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `buddy` function takes a cat and returns a mammal. If we passed it
    to the `meet_partner` function, then it would not work when we want to find a
    partner for our dog `Chef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a9c5a6d-ae0e-4d50-87f6-32fca6864979.png)'
  prefs: []
  type: TYPE_IMG
- en: So the arguments of function types are not covariant. Could it be contravariant?
    Well, to be contravariant, the `finder` function must accept a supertype of `Mammal`.
    In our animal kingdom, the only supertype is `Vertebrate`; however, `Vertebrate`
    is an abstract type and it cannot be constructed. If we instantiate any other
    concrete type that is a subtype of `Vertebrate`, it would not be a mammal (otherwise,
    it would be considered a mammal already). Therefore, function arguments are invariant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stated more formally, this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25775332-7f88-4142-be84-4d0791240019.png)'
  prefs: []
  type: TYPE_IMG
- en: Function `g` is a subtype of function `f`, as long as `T` is `Mammal` and `S`
    is a subtype of `Mammal`. There is a saying about this: *"Be liberal in what you
    accept and conservative in what you produce."*
  prefs: []
  type: TYPE_NORMAL
- en: While it is fun doing this kind of analysis, do we gain anything, given that
    the Julia runtime does not support function types as granular as those we have
    seen? It seems to be possible to simulate a type-checking effect on our own, which
    is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our own function type dispatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen earlier in this section, Julia creates a unique function type
    for every function, and they are all subtypes of the `Function` abstract type.
    We seem to be missing an opportunity for multiple dispatch. Taking the `all` function
    from `Base` as an example, it would be very nice if we could design a type that
    represents predicate functions rather than letting `all` fail miserably when an
    incompatible function is passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to work around this limitation, let''s define a parametric type called
    `PredicateFunction` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PredicateFunction` parametric type just wraps a function `f`. The type
    parameters `T` and `S` are used to represent the types of function arguments and
    return a type of `f` respectively. As an example, the `iseven` function can be
    wrapped as follows, because we know the function can take a number and return
    a Boolean value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Conveniently, since Julia supports callable structs, we can make it so that
    the `PredicateFunction` struct can be invoked as if it was a function itself.
    To enable this, we can define the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this function merely forwards the call to the `pred.f` wrapped
    function. Once it is defined, we can do some small experiments to see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f65f6b0-84cf-4ddf-bbf5-cdf415369319.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That looks pretty good. Let''s define our own *safe* version of the `all` function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `safe_all` function takes a `PredicteFunction{T,S}` as the first argument,
    with the constraint that `T` is a subtype of `Any` and `S` is a subtype of `Bool`.
    It''s exactly the function type signature we want for predicate functions. Knowing
    that `Number <: Any` and `Bool <: Bool`, we can definitely pass the `iseven` function
    to `safe_all`. Let''s test it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2b7aeac-02a3-426b-a30e-e4a187c0720f.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Bravo! *We have created a safe version of the `all` function. The first argument
    must be a predicate function that takes anything and returns a Boolean value.
    Rather than taking a generic `Function` argument, we can now enforce strict type
    matching and participate in multiple dispatch.'
  prefs: []
  type: TYPE_NORMAL
- en: That is enough about variance. Next, we will move on and revisit the rules for
    the parametric method dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: Parametric methods revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to dispatch to various methods based upon subtyping relationships
    is a key feature of the Julia language. We initially introduced the concept of
    parametric methods in [Chapter 3](6c453014-3590-4a63-9d39-9bdd735185d5.xhtml),
    *Designing Functions and Interfaces*. In this section, we will go a little deeper
    and examine some subtle situations about how methods are selected for dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the basics: how do we specify type variables for parametric
    methods?'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying type variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we define a parametric method, we use the `where` clause to introduce
    type variables. Let''s go over a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `triple` function takes an `Array{T}`, where `T` is any subtype of `Real`.
    This code is very readable, and it is the format that most Julia developers choose
    to specify type parameters. So what could the value of `T` be? Could it be a concrete
    type, abstract type, or both?
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer this question, we can test it out from the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b23463f-010e-4d58-870c-eea21f73d9ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So the method does get dispatched on both the abstract type (`Real`) and concrete
    type (`Int64`). It is worth mentioning that the `where` clause can also be placed
    right next to the method argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: From a functional perspective, it is the same as before, whether the `where`
    clause is placed inside or outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some subtle differences, however. When the `where` clause is placed
    outside, you gain two additional benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: The type variable `T` is accessible inside the method body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type variable `T` can be used to enforce the same values if it is used for
    multiple method arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It turns out that the second point leads to an interesting feature in Julia's
    dispatch system. We will go over this next.
  prefs: []
  type: TYPE_NORMAL
- en: Matching type variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever a type variable occurs more than once in a method signature, it is
    used to enforce the same type as determined across all positions where it occurs.
    Consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add` function takes an `Array{T}` and a value of type `T`. It returns
    a tuple of `T` and the result of adding the value to the array. Intuitively, we
    want the type `T` to be consistent across both arguments. In other words, we would
    want the function to be specialized in each of the realizations of `T` when the
    function is called. Obviously, the function works great when the type agrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/425d6c47-b5ed-4bde-9c90-4703c762df47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the first case, `T` is determined to be `Int64`, and in the second case,
    `T` is determined to be `Float64`. Perhaps not too surprisingly, we may get a
    method error when the types do not match:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13eb7095-6142-4e56-8a4b-7c0f52f4b414.png)'
  prefs: []
  type: TYPE_IMG
- en: Since we said that `T` could be an abstract type, could we dispatch to this
    method, as `T` could be considered `Real`? The answer is no, because parametric
    types are *invariant*! An array of `Real` objects is not the same as an array
    of `Int64` values. More formally, `Array{Int}` is not a subtype of `Array{Real}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It gets a little more interesting when `T` is an abstract type in the array.
    Let''s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11d6d02b-b849-4917-b436-c1bec7a8b75d.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, `T` is unambiguously set to `Signed`, and because `Int8` is a subtype
    of `Signed`, the method is dispatched properly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look into another unique typing feature called the diagonal rule.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the diagonal rule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned earlier, it is a nice feature to be able to match type variables
    and keep them consistent across method arguments. In practice, there are situations
    where we want to be even more specific when determining the right type for each
    type variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `diagonal` function takes two arguments with the same type, where the type
    `T` must be a subtype of `Number`. The type variable `T` is simply returned to
    the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `T` is concrete, it is easy to reason that the types are consistent. For
    example, we can pass a pair of `Int64` values or a pair of `Float64` values to
    the function and expect to see the respective concrete type returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb4f34ea-85fb-44ff-b0e1-e30a14afc601.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Intuitively, we also expect this to fail when the types are not consistent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/665bf3a1-62f1-4a40-b749-948d3f666838.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While it seems to work intuitively, we could have argued that the type variable
    `T` is an abstract type, such as `Real`. Since the value of `1` is `Int64` and
    `Int64` is a subtype of `Real`, and the value of `2.0` is `Float64` and `Float64`
    is a subtype of `Real`, shouldn''t the method still get dispatched anyway? To
    make this point more clear, we can even annotate the argument as such when calling
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4868de6b-d615-4a27-ab78-349d3f8e8586.png)'
  prefs: []
  type: TYPE_IMG
- en: It turns out that Julia is designed to give us more intuitive behavior. It is
    also the very reason why the** diagonal rule** was introduced. The diagonal rule
    says that when a type variable occurs more than once in the covariant position
    (that is, the method arguments), then the type variable will be restricted to
    match with concrete types only.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the type variable `T` is considered a diagonal variable, so `T`
    must be a concrete type.
  prefs: []
  type: TYPE_NORMAL
- en: There is an exception to the diagonal rule, though. We will discuss this next.
  prefs: []
  type: TYPE_NORMAL
- en: An exception to the diagonal rule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The diagonal rule says that when a type variable occurs more than once in the
    covariant position (that is, the method arguments), then the type variable will
    be restricted to match with concrete types only; however, there is an exception
    to that rule—when the type variable is unambiguously determined from an invariant
    position, then it is allowed to be an abstract type rather than a concrete type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the `diagonal` function from the previous section, this one allows `T`
    to be abstract. We can prove it as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49fbfd9a-7135-4306-8a5b-98c38072504c.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason is that `T` appears in the first argument in a parametric type. As
    we know that parametric types are invariant, we have already determined that `T` is `Signed`.
    Because `Int64` is a subtype of `Signed`, everything matched.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will go over the availability of type variables.
  prefs: []
  type: TYPE_NORMAL
- en: The availability of type variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important feature of the parametric method is that the type variable specified
    in the `where` clause is also accessible from the method body. Contrary to what
    you might think, this is not always true. Here, we will present a case where the
    type variable is not available at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `mytypes1` and `mytypes2` functions to experiment with what
    type variables are derived by the Julia runtime. Let''s start with the happy case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a2c4782-0e8c-4852-a4d4-9eadfcfa28bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, the picture is not always rosy. In other situations, it may not work
    100% of the time. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec77e83f-612b-423b-bac8-5226a4d5e997.png)'
  prefs: []
  type: TYPE_IMG
- en: Why is `S` not defined here? First of all, we already know that `T` is `Signed`
    because the parametric type is invariant. As part of the `where` clause, we also
    know that `T` is a subtype of `S`. As such, `S` could be `Integer`, `Real`, `Number`,
    or even `Any`. As there are too many possible answers, the Julia runtime decided
    not to assign any value to `S`.
  prefs: []
  type: TYPE_NORMAL
- en: The moral of the story is don't assume that a type variable is always defined
    and accessible from the method, especially for a more complex situation like this.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about various topics related to subtyping, variance,
    and dispatch. These concepts are the fundamental building blocks for creating
    larger, more complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: We first went over the topic of implementation inheritance and behavior subtyping
    and the differences between them. We reasoned that implementation inheritance
    is not a great design pattern because of various issues. We came to an understanding
    that Julia's type system is designed to avoid the flaws that we have seen in other
    programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we reviewed different kinds of variance, which are nothing but ways to
    explain the subtyping relationship between parametric types. We walked through
    in great details how parametric types are invariant and method arguments are covariant.
    We then went even further to discuss the variance of function types and how we
    can build our own data type that wraps a function for dispatch purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we revisited parametric methods and looked at how type variables are
    specified and matched during dispatch. We learned about the diagonal rule, which
    is a key design feature in the Julia language that allows us to enforce type consistency
    across method arguments in an intuitive manner.
  prefs: []
  type: TYPE_NORMAL
- en: We are now finished with the chapter and the book. Thank you for reading it!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How is implementation inheritance different from behavior subtyping?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some major issues with implementation inheritance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is duck typing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the variance of method arguments and why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are parametric types invariant in Julia?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When does the diagonal rule apply?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
