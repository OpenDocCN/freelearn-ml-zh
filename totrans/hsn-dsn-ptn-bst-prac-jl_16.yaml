- en: Inheritance and Variance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和可变性
- en: If we had to choose the most important thing to learn in Julia, or in any programming
    language, then it has to be the concept of the data type. Abstract types and concrete
    types work together, providing the programmer with a powerful tool to model solutions
    to solve real-world problems. Multiple dispatch rely on well-defined data types
    to invoke the right functions. Parametric types are used so that we can reuse
    the basic structure of an object with a specific physical representation of the
    underlying data. As you can see, having a well-thought-out design for data types
    is of the utmost importance in software engineering practice.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不得不选择在 Julia 或任何编程语言中最重要的学习内容，那么它必定是数据类型的概念。抽象类型和具体类型协同工作，为程序员提供了一种强大的工具来模拟解决方案，以解决现实世界的问题。多重分派依赖于定义良好的数据类型来调用正确的函数。参数化类型被用来使我们能够重用具有特定物理数据表示的对象的基本结构。正如你所看到的，在软件工程实践中，对数据类型进行周密的设计至关重要。
- en: In [Chapter 2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules, Packages,
    and Data Type Concepts*, we learned about the basics of abstract and concrete
    types and how to build a type hierarchy based upon an inheritance relationship
    between the types. In [Chapter 3](6c453014-3590-4a63-9d39-9bdd735185d5.xhtml), *Designing
    Functions and Interfaces,* and [Chapter 5](962e7c27-570f-498e-89b9-d9075c58cd45.xhtml),
    *Reusability Patterns*, we also touched on the subject of parametric types and
    parametric methods. In order to utilize these concepts and language features effectively,
    we need a good understanding of how *subtyping* works. It may sound similar to
    inheritance, but it is fundamentally different.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2 章](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml)，*模块、包和数据类型概念*中，我们学习了抽象类型和具体类型的基础知识以及如何基于类型之间的继承关系构建类型层次结构。在第
    3 章*设计函数和接口*和第 5 章*重用模式*中，我们也简要提到了参数化类型和参数化方法。为了有效地利用这些概念和语言特性，我们需要很好地理解子类型是如何工作的。它听起来可能类似于继承，但它在本质上是有区别的。
- en: 'In this chapter, we will go deeper and explore the meaning of subtyping and
    related topics, which includes the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨子类型及其相关主题的含义，包括以下主题：
- en: Implementation inheritance and behavior subtyping
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现继承和行为子类型
- en: Covariance, contravariance, and invariance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协方差、反协方差和不变性
- en: Parametric methods and diagonal rule
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化方法和对角线规则
- en: By the end of this chapter, you will have a good understanding of subtyping
    in Julia. You will be more equipped to design your own data type hierarchy and
    utilize multiple dispatch more effectively.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对 Julia 中的子类型有很好的理解。你将更有能力设计自己的数据类型层次结构，并更有效地利用多重分派。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample source code is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter12).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 示例源代码位于[https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter12)。
- en: The code is tested in a Julia 1.3.0 environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在 Julia 1.3.0 环境中进行了测试。
- en: Implementing inheritance and behavior subtyping
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现继承和行为子类型
- en: 'When we learned about inheritance, we realized that abstract types can be used
    to describe real-world concepts. We can say quite confidently that we already
    know how to classify concepts with parent–child relationships. With this knowledge,
    we can build a type hierarchy around those concepts. For example, the personal
    asset type hierarchy from [Chapter 2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules,
    Packages, and Data Type Concepts*, looks like the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们学习继承时，我们意识到抽象类型可以用来描述现实世界概念。我们可以相当自信地说，我们已经知道如何通过父子关系来分类概念。有了这些知识，我们可以在这些概念周围构建类型层次结构。例如，来自[第
    2 章](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml)，*模块、包和数据类型概念*的个人资产类型层次结构看起来如下：
- en: '![](img/bc754bd8-c903-4a4a-96e7-76ff9b6dfb2f.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc754bd8-c903-4a4a-96e7-76ff9b6dfb2f.png)'
- en: All data types shown in the preceding diagram are abstract types. Going from
    the bottom up, we know that both **House** and **Apartment** are subtypes of **Property**,
    and we know that both **Property** and **Investment** are a subtype of **Asset**.
    These are all reasonable interpretations based on how we speak about these concepts
    in our daily life.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中展示的所有数据类型都是抽象类型。从下往上，我们知道**House**和**Apartment**都是**Property**的子类型，我们也知道**Property**和**Investment**都是**Asset**的子类型。这些都是基于我们日常生活中对这些概念的讨论的合理解释。
- en: 'We also talked about concrete types that are the physical realization of abstract
    concepts. For this same example, we ended up having `Stock` as a subtype of `Equity`
    and `Bond` as a subtype of `FixedIncome`. As you may recall, the `Stock` type
    can be defined as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了具体类型，它们是抽象概念的物理实现。对于这个相同的例子，我们最终得到`Stock`作为`Equity`的子类型，`Bond`作为`FixedIncome`的子类型。如您所回忆的那样，`Stock`类型可以定义为以下内容：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Back then, we did not emphasize the fact that we cannot declare any field inside
    abstract types, which is something that is given in some **object-oriented programming**
    (**OOP**) languages, such as Java. If you come from an OOP background, then you
    may mistakenly feel that this is a huge constraint in Julia's inheritance system. Why
    is Julia designed the way it is? In this section, we will try to analyze inheritance
    in greater depth and answer this very question.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在那时，我们没有强调不能在抽象类型中声明任何字段的事实，这是某些面向对象编程（**OOP**）语言（如Java）中固有的。如果您来自OOP背景，那么您可能会错误地感觉到这是Julia继承系统中的一个巨大限制。Julia为什么被设计成这样？在本节中，我们将尝试更深入地分析继承并回答这个问题。
- en: There are two important concepts related to inheritance that are very similar,
    but fundamentally different—implementation inheritance and behavior subtyping.
    We will discuss both in the next few sections. Let's start with implementation
    inheritance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与继承相关联的两个重要概念非常相似，但本质上不同——实现继承和行为子类型。我们将在接下来的几节中讨论这两个概念。让我们从实现继承开始。
- en: Understanding implementation inheritance
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解实现继承
- en: 'Implementation inheritance allows a subclass to inherit *both* fields and methods
    from its superclass. As Julia does not support implementation inheritance, we
    will switch language for a moment and present the following example in Java. Here
    is a class that provides a container for holding any number of objects:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实现继承允许子类从其超类继承**字段**和**方法**。由于Julia不支持实现继承，我们将暂时改变语言，以下是用Java提供的示例。这是一个提供容器以容纳任意数量对象的类：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Bag` class basically maintains a list of objects in the `items` field and
    provides two convenient functions, `add` and `addMany`, for adding a single object
    or an array of objects to the bag.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bag`类基本上维护了一个对象列表在`items`字段中，并提供两个方便的函数，`add`和`addMany`，用于向包中添加单个对象或对象数组。'
- en: 'To demonstrate code reuse, we can develop a new `CountingBag` class that inherits
    from `Bag` and provides additional functionality for keep tracking of how many
    items are stored in the bag:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示代码重用，我们可以开发一个新的`CountingBag`类，它从`Bag`继承并提供了跟踪包中存储了多少项的附加功能：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this `CountingBag` class, we have a new field called `count` to keep track
    of the bag size. Whenever a new item is added to the bag, the `count` variable
    is incremented. The `size` function is used to report the size of the bag. So
    what is the situation with `CountingBag`? Let''s quickly summarize:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`CountingBag`类中，我们有一个新的字段`count`，用于跟踪包的大小。每当向包中添加新项目时，`count`变量就会增加。`size`函数用于报告包的大小。那么`CountingBag`的情况如何？让我们快速总结：
- en: The `count` field is available as defined here.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`字段在此处定义可用。'
- en: The `items` field is available as inherited from `Bag`.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`items`字段作为从`Bag`继承而来是可用的。'
- en: The `add` method overrides the parent's implementation, but it also reuses the
    parent's method via `super.add`.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`方法覆盖了父类的实现，但它也通过`super.add`重用了父类的方法。'
- en: The `addMany` method is available as inherited from `Bag`.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addMany`方法作为从`Bag`继承而来是可用的。'
- en: The `size` method is available as defined here.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`方法在此处定义可用。'
- en: As both fields and methods are inherited, this is called implementation inheritance.
    The effect is almost the same as if the code from the superclass was copied into
    the subclass.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字段和方法都是继承的，这被称为实现继承。其效果几乎等同于将超类中的代码复制到子类中。
- en: Next, let's talk about behavior subtyping.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈行为子类型。
- en: Understanding behavior subtyping
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解行为子类型
- en: Behavior subtyping is sometimes called interface inheritance. In order to avoid
    confusion with the overloaded word *inheritance*, we will avoid using the term
    interface inheritance here. Behavior subtyping says that a subtype only inherits
    behaviors from the supertype.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 行为子类型有时被称为接口继承。为了避免与重载的单词*继承*混淆，我们在这里将避免使用接口继承这个术语。行为子类型表示子类型仅从超类型继承行为。
- en: As we switch the language back to Julia, we will refer to *types* rather than
    *classes*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将语言切换回Julia时，我们将引用*类型*而不是*类*。
- en: 'Julia supports behavior subtyping. Every data type inherits functions that
    are defined for its supertype. Let''s try a quick and fun exercise in the Julia
    REPL:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Julia支持行为子类型。每个数据类型都继承为其超类型定义的函数。让我们在Julia的REPL中进行一个快速有趣的练习：
- en: '![](img/96050300-8545-44fa-8d6e-c5203674b49d.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96050300-8545-44fa-8d6e-c5203674b49d.png)'
- en: Here, an abstract type, `Vehicle`, is defined with a subtype of `Car`. We have
    also defined a `move` function for `Vehicle`. When we pass a `Car` object to the
    `move` function, it still works properly because `Car` is a subtype of `Vehicle`.
    This is consistent with the Liskov substitution principle, which says that a program
    accepting type T can also accept any subtype of T and continue to work properly
    without any unintended outcome.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，定义了一个抽象类型`Vehicle`及其子类型`Car`。我们还为`Vehicle`定义了一个`move`函数。当我们向`move`函数传递一个`Car`对象时，它仍然可以正常工作，因为`Car`是`Vehicle`的子类型。这与Liskov替换原则一致，该原则表示接受类型T的程序也可以接受T的任何子类型，并且可以继续正常工作，而不会出现任何意外的结果。
- en: 'Now, the inheritance of a method can travel quite far over multiple levels.
    Let''s create another level of abstraction:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，方法的继承可以在多个级别上传播得很远。让我们创建另一个抽象级别：
- en: '![](img/1f69026c-ab52-4d4e-a7b4-5cf07ad3ed9b.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f69026c-ab52-4d4e-a7b4-5cf07ad3ed9b.png)'
- en: We just defined a new `FlyingVehicle` abstract type and a `Helicopter` struct.
    The `move` function is available for a helicopter as inherited from `Vehicle`,
    and the `liftoff` function is also available, as inherited from `FlyingVehicle`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了一个新的`FlyingVehicle`抽象类型和一个`Helicopter`结构体。`move`函数可以通过从`Vehicle`继承而来在直升机中使用，`liftoff`函数也可以使用，因为它是从`FlyingVehicle`继承而来的。
- en: 'Additional methods can be defined for more specific types, and the most specific
    one would be chosen for dispatch. Doing this essentially has the same effect as
    method overrides in implementation inheritance. Here''s an example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为更具体的类型定义额外的方法，并且会选择最具体的方法进行调度。这样做本质上与实现继承中的方法覆盖具有相同的效果。以下是一个例子：
- en: '![](img/1656f588-ca10-4176-b729-89c4be8ecf13.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1656f588-ca10-4176-b729-89c4be8ecf13.png)'
- en: So far, we have defined two `liftoff` methods—one accepting `FlyingVehicle`
    and another for `Helicopter`. When a `Helicopter` object is passed to the function,
    it is dispatched to the one defined for `Helicopter`, because it is the most specific
    method that works with helicopters.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了两种`起飞`方法——一种接受`FlyingVehicle`，另一种用于`Helicopter`。当将`Helicopter`对象传递给函数时，它会被分配到为`Helicopter`定义的方法，因为它是最具体的方法，适用于直升机。
- en: 'The relationship can be summarized in the following diagram:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系可以用以下图表来总结：
- en: '![](img/c5949296-b354-4bc5-8cdf-62454a8696ea.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5949296-b354-4bc5-8cdf-62454a8696ea.png)'
- en: According to behavior subtyping, a car should behave like a vehicle, a flying
    vehicle should behave like a vehicle, and a helicopter should behave like a flying
    vehicle and also like a vehicle. Behavior subtyping allows us to reuse the behavior
    already defined for a supertype.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据行为子类型，汽车应该像车辆一样行为，飞行车辆应该像车辆一样行为，直升机应该像飞行车辆一样行为，也像车辆一样行为。行为子类型允许我们重用为超类型已定义的行为。
- en: In Java, behavior subtyping can be achieved using interfaces.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，可以使用接口实现行为子类型。
- en: 'Now that we know about implementation inheritance and behavior subtyping, we
    can revisit our earlier question: why does Julia not support implementation inheritance?
    What are the reasons for not following other mainstream OOP languages? In order
    to understand this, we can review some of the well-known issues with implementation
    inheritance. Let''s start with the square-rectangle problem.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了实现继承和行为子类型，我们可以回顾我们之前的问题：为什么Julia不支持实现继承？不遵循其他主流面向对象编程语言的原因是什么？为了理解这一点，我们可以回顾一些与实现继承相关的一些知名问题。让我们从正方形-矩形问题开始。
- en: The square-rectangle problem
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正方形-矩形问题
- en: 'Julia does not support implementation inheritance. Let''s list the reasons:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Julia不支持实现继承。让我们列出不支持实现继承的原因：
- en: All concrete types are final, so there is no way to create new subtypes from
    another concrete type. Therefore, it is not possible to inherit object fields
    from anywhere.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有具体类型都是最终的，因此无法从另一个具体类型创建新的子类型。因此，不可能从任何地方继承对象字段。
- en: You cannot declare any field in an abstract type because otherwise, it would
    be concrete rather than abstract.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在抽象类型中，你不能声明任何字段，否则它将不再是抽象的，而是具体的。
- en: The core developers of the Julia programming language made a very early design
    decision to avoid implementation inheritance for a number of reasons. One of them
    is the so-called *square-rectangle problem*, also sometimes called the circle-ellipse
    problem.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Julia编程语言的核心开发者出于多个原因，在早期设计决策中决定避免实现继承。其中之一就是所谓的*正方形-矩形问题*，有时也称为圆-椭圆问题。
- en: 'The square-rectangle problem presents a clear challenge for implementation
    inheritance. As we know by common sense, every square is a rectangle with an additional
    constraint that the length of both sides is equal. In order to model these concepts
    in a class-based, object-oriented language, we may attempt to create a `Rectangle`
    class and a `Square` subclass:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正方形-矩形问题对实现继承提出了一个明显的挑战。正如常识所知，每个正方形都是一个矩形，它有一个额外的约束，即两边的长度相等。为了在面向对象的语言中通过类来建模这些概念，我们可能会尝试创建一个`Rectangle`类和一个`Square`子类：
- en: '![](img/ddda9d4a-64a2-4579-9d76-39de1690d6fe.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ddda9d4a-64a2-4579-9d76-39de1690d6fe.png)'
- en: Very quickly, we realize that we have already gotten ourselves into trouble.
    If a `Square` has to inherit all fields from its parent class, then it would have
    inherited both `width` and `height`. But we really want to have a single field
    called `length` instead.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们就意识到我们已经使自己陷入了麻烦。如果`Square`必须从其父类继承所有字段，那么它就会继承`width`和`height`。但我们真正想要的是一个名为`length`的单个字段。
- en: The exact same issue is sometimes presented as the circle–ellipse problem. In
    that case, a circle is an ellipse, but there is only one radius rather than major
    and minor axis lengths.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，完全相同的问题被表述为圆-椭圆问题。在这种情况下，圆是椭圆，但只有一个半径而不是主轴和副轴长度。
- en: How do we solve this kind of problem? Well, one way is to ignore the issue and
    create a `Square` subclass without any field defined. Then, when a `Square` is
    instantiated with a particular length, both `width` and `height` fields are populated
    with the same value. Is that good enough? The answer is no. Given that `Square`
    also inherits the methods of `Rectangle`, we probably need to provide override
    methods for the mutating methods, such as `setWidth` and `setHeight`, so that
    we can keep both fields with the same value. In the end, we have a solution that
    seems to work functionally but is terrible in performance and memory usage.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？好吧，一种方法是不理会这个问题，创建一个没有任何字段定义的`Square`子类。然后，当用特定的长度实例化`Square`时，`width`和`height`字段都填充了相同的值。这足够好吗？答案是不足够的。鉴于`Square`还继承了`Rectangle`的方法，我们可能需要提供覆盖方法，例如`setWidth`和`setHeight`，以便我们可以保持两个字段具有相同的值。最终，我们得到了一个似乎在功能上可行但性能和内存使用都很差的解决方案。
- en: But how did we get into trouble in the first place? To analyze this further,
    we should realize that a square, while it can be classified as a rectangle, is
    a more restrictive version of a rectangle in nature. This is already starting
    to sound unintuitive—typically, when we create subclasses, we extend the parent
    class and *add* more fields and functionalities. When do we want to remove fields
    or functionality in subclasses? It already seems to be logically backward. Maybe
    we should make `Rectangle` a subclass of `Square`? That does not sound very logical
    either.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们最初是如何陷入麻烦的呢？为了进一步分析，我们应该意识到，虽然正方形可以被归类为矩形，但在本质上它是一个更严格的矩形版本。这已经开始听起来不太直观了——通常，当我们创建子类时，我们会扩展父类并*添加*更多的字段和功能。我们什么时候想在子类中删除字段或功能？这似乎在逻辑上是倒退的。也许我们应该让`Rectangle`成为`Square`的子类？这听起来也不太合理。
- en: We end up with a conundrum. On one hand, we would like to model real-world concepts
    properly in code. On the other hand, the code does not really fit without causing
    maintenance or performance issues. By now, we cannot help but ask ourselves whether
    we really want to write code to work around problems with implementation inheritance.
    We don't.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们陷入了一个困境。一方面，我们希望在代码中正确地建模现实世界概念。另一方面，代码并不适合，不会引起维护或性能问题。到目前为止，我们不禁要问自己，我们是否真的想编写绕过实现继承问题的代码。我们不想。
- en: Perhaps you are not yet 100% convinced that implementation inheritance is more
    evil than good. Let's look at another problem.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你还没有100%确信实现继承比抽象继承更糟糕。让我们看看另一个问题。
- en: The fragile base class problem
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不稳定的基类问题
- en: 'Another problem with implementation inheritance is that changes to the base
    class (parent class) can possibly break functionalities of its subclasses. From
    the earlier Java example, we have a `CountingBag` class that extends from the
    `Bag` class. Let''s look at the complete source code, including the `main` function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 实现继承的另一个问题是，对基类（父类）的更改可能会破坏其子类的功能。从早期的Java示例中，我们有一个从`Bag`类扩展的`CountingBag`类。让我们看看完整的源代码，包括`main`函数：
- en: '![](img/e281b138-70b8-4936-b9a9-c09558b5868e.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e281b138-70b8-4936-b9a9-c09558b5868e.png)'
- en: 'The program simply creates a `CountingBag` object. Then it adds `apple` using
    the `add` method and adds `banana` and `orange` using the `addMany` method. Finally,
    it prints out the items in the bag and the size of the bag. The output is shown
    in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 程序简单地创建了一个`CountingBag`对象。然后使用`add`方法添加`apple`，并使用`addMany`方法添加`banana`和`orange`。最后，它打印出包中的项目和包的大小。输出如下代码所示：
- en: '![](img/70e7db7a-c377-4e93-b16d-4b0f4387d178.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/70e7db7a-c377-4e93-b16d-4b0f4387d178.png)'
- en: 'Everything looks fine at the moment. But let''s say that the original author
    of `Bag` realizes that the `addMany` method can be improved by directly adding
    objects into the `items` array list:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 目前一切看起来都很正常。但假设`Bag`类的原始作者意识到可以通过直接向`items`数组列表中添加对象来改进`addMany`方法：
- en: '![](img/bd1de7db-5bd9-4fe7-bd7b-109a478b90f2.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd1de7db-5bd9-4fe7-bd7b-109a478b90f2.png)'
- en: 'Unfortunately, this seemingly safe change in the parent class ends up in a
    disaster for `CountingBag`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个看似安全的父类更改最终导致了`CountingBag`的灾难：
- en: '![](img/f5f402ab-e3d6-4d02-b68a-1994cd3f2cb4.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f5f402ab-e3d6-4d02-b68a-1994cd3f2cb4.png)'
- en: What happened? When `CountingBag` was designed, it was assumed that the `add`
    method would always be called when new items are added to the bag. When the `addMany`
    method stops calling the `add` method, the assumption no longer applies.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？当设计`CountingBag`时，假设在向包中添加新项目时总是会调用`add`方法。当`addMany`方法停止调用`add`方法时，这个假设就不再适用了。
- en: Whose fault is this? Of course, the designer of the `Bag` class cannot foresee
    who will inherit the class. The change in the `addMany` method did not violate
    any contract; the same functionality is provided, only with a different implementation
    under the hood. The designer of the `CountingBag` class thought it was wise to
    *tag along* and leverage the fact that `addMany` was already calling the `add`
    method, and so only the `add` method needed to be overridden to make `counting`
    work.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是谁的错？当然，`Bag`类的开发者无法预见谁会继承这个类。`addMany`方法的变化并没有违反任何契约；提供的功能相同，只是在底层有不同的实现。`CountingBag`类的开发者认为跟随并利用`addMany`已经调用`add`方法的事实是明智的，因此只需要覆盖`add`方法以使计数工作。
- en: This poses a second issue with implementation inheritance. The subclass developer
    has too much knowledge about the implementation of the parent class. The ability
    to override the parent class's `add` method has also violated the principle of
    encapsulation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这提出了实现继承的第二个问题。子类开发者对父类的实现了解得太多。覆盖父类`add`方法的能力也违反了封装原则。
- en: 'How does OOP solve this problem? In Java, there are multiple facilities to
    prevent the problem presented in the preceding example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是如何解决这个问题呢？在Java中，有多种设施可以防止前面示例中提出的问题：
- en: A method can be annotated with the `final` keyword to prevent the subclass from
    overriding the method.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`final`关键字注解方法以防止子类覆盖该方法。
- en: A field can be annotated with the `private` keyword to prevent the subclass
    from accessing the field.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`private`关键字注解字段以防止子类访问该字段。
- en: The trouble is that the developer must *anticipate* how classes are going to
    be inherited *in the future*. Methods must be carefully examined to determine
    whether it is safe to allow subclasses to access or override. Likewise for fields.
    As you can see, the problem is called the fragile base class problem for a good
    reason.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，开发者必须*预测*类将如何在未来被继承。必须仔细检查方法，以确定是否允许子类访问或覆盖它。同样适用于字段。正如你所见，这个问题之所以被称为不稳定的基类问题，是有充分的理由的。
- en: I hope we have shown you that implementation inheritance does more harm than
    good. For reference, in the GoF design patterns book, it was also suggested that
    composition is preferred over inheritance. Julia took a more radical approach
    by just disallowing implementation inheritance altogether.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 希望我们已经向您展示了实现继承弊大于利。为了参考，在GoF设计模式书中，也建议优先使用组合而非继承。Julia采取了更为激进的策略，完全禁止了实现继承。
- en: Next, we will go a little further and look at a specific kind of behavior subtyping
    called duck typing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进一步探讨一种特定的行为子类型，称为鸭子类型。
- en: Revisiting duck typing
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾鸭子类型
- en: 'There are two ways to implement behavior subtyping: **nominal subtyping** and
    **structural subtyping**:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实现行为子类型有两种方式：**名义子类型**和**结构子类型**：
- en: With nominal subtyping, you must explicitly define the relationship between
    a type and its supertype. Julia uses nominal subtyping, where types are explicitly
    annotated in function arguments. That is why a type hierarchy needs to be built
    to express type relationships.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在名义子类型中，你必须明确定义类型与其超类型之间的关系。Julia使用名义子类型，其中类型在函数参数中明确标注。这就是为什么需要构建类型层次结构来表达类型关系。
- en: With structural subtyping, the relationship is implicitly derived as long as
    the subtype implements the required functions from the supertype. Julia supports
    structural subtyping when functions are defined with arguments and not annotated
    with any type.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在结构子类型中，只要子类型实现了超类型所需的功能，关系就隐式地推导出来。当函数使用参数定义而没有标注任何类型时，Julia支持结构子类型。
- en: 'Julia supports structural subtyping via **duck typing***. *We first mentioned
    duck typing in [Chapter 3](6c453014-3590-4a63-9d39-9bdd735185d5.xhtml), *Designing
    Functions and Interfaces*. The saying is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Julia通过**鸭子类型**支持结构子类型。我们首次在第3章中提到了鸭子类型，*设计函数和接口*。说法如下：
- en: '"If it walks like a duck and quacks like a duck, then it is a duck."'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: “如果它走路像鸭子，叫起来也像鸭子，那么它就是一只鸭子。”
- en: In a dynamic type language, we sometimes care less about the exact type as long
    as we get the behavior we want. If we just want to hear a quack sound, who cares
    if we get a frog? As long as it makes that quack sound, we will be happy.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态类型语言中，我们有时更关注我们是否得到了想要的行为，而不是确切的类型。如果我们只想听到嘎嘎声，谁会在意我们得到的是青蛙？只要它能发出嘎嘎声，我们就会满意。
- en: 'Sometimes, we want duck typing for good reasons. For example, we do not normally
    consider horses as vehicles; however, think about the old days when horses were
    used for transport. In our definition, anything that implements the `move` function
    can be considered a vehicle. So, if we have any algorithm that needs something
    that moves, then there is no reason why we cannot pass a `horse` object to the
    algorithm:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们出于良好原因想要使用鸭子类型。例如，我们通常不会把马视为交通工具；然而，想想过去马被用于运输的日子。在我们的定义中，任何实现了`move`函数的东西都可以被视为交通工具。所以，如果我们有任何需要移动对象的算法，就没有理由不能将`horse`对象传递给该算法：
- en: '![](img/8335a797-ae4f-41cc-8199-e198d79355a3.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8335a797-ae4f-41cc-8199-e198d79355a3.png)'
- en: For some people, duck typing is a little loose because you cannot easily figure
    out whether a type supports an interface (such as `move`). The general remedy
    is to use the Holy Trait pattern as described in [Chapter 5](962e7c27-570f-498e-89b9-d9075c58cd45.xhtml),
    *Reusability Patterns*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些人来说，鸭子类型有点宽松，因为你不能轻易地判断一个类型是否支持接口（如`move`）。一般的补救方法是使用第5章中描述的圣物特质模式，*可重用性模式*。
- en: Next, we will look at an important concept called variance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一个重要的概念，称为可变性。
- en: Covariance, invariance, and contravariance
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协变、不变性和逆变
- en: As it turns out, the rules for subtyping are not very straightforward. When
    you look at a simple type hierarchy, you can immediately tell whether one type
    is a subtype of another by tracing the relationships of the data types in the
    hierarchy. The situation becomes more complex when parametric types are involved.
    In this section, we will take a look at how Julia is designed with respect to
    **variance**, a concept that explains subtyping relationships for parametric types.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，子类型的规则并不非常直接。当你查看一个简单的类型层次结构时，你可以立即通过追踪层次结构中数据类型之间的关系来判断一个类型是否是另一个类型的子类型。当涉及到参数化类型时，情况变得更加复杂。在本节中，我们将探讨Julia是如何设计以**可变性**为依据的，这是一个解释参数化类型子类型关系的概念。
- en: Let's first review the different kinds of variance.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一下不同类型的可变性。
- en: Understanding different kinds of variance
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解不同类型的可变性
- en: There are four different kinds of variance as described in computer science
    literature. We will first describe them in a formal manner first and then come
    back to do more hands-on exercises to reinforce our understanding.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学文献中描述了四种不同的方差类型。我们首先将它们以正式的方式描述，然后回来进行更多的动手练习，以加强我们的理解。
- en: 'Given that `S` is a subtype of `T`, there are four different ways to reason
    about the relationship between parametric types `P{S}` and `P{T}`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `S` 是 `T` 的子类型，那么有四种不同的方式来推理参数化类型 `P{S}` 和 `P{T}` 之间的关系：
- en: Covariant: `P{S}` is a subtype of `P{T}` (`co` here means the same direction)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协变：`P{S}` 是 `P{T}` 的子类型 (`co` 这里表示相同方向)
- en: Contravariant: `P{T}` is a subtype of `P{S}` (`contra` here means the opposite
    direction)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反协变：`P{T}` 是 `P{S}` 的子类型 (`contra` 这里表示相反方向)
- en: 'Invariant: neither covariant nor contravariant'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变量：既不是协变的也不是反协变的
- en: 'Bivariant: both covariant and contravariant'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双协变：既协变又反协变
- en: When do we find variance useful? Perhaps not too surprisingly, variance is a
    key ingredient whenever multiple dispatch come into action. Based on the Liskov
    substitution principle, the language runtime must figure out whether the object
    being passed is a subtype of the method argument before dispatching to the method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在什么时候会发现方差有用？也许不会太令人惊讶，方差是当多态发生作用时的关键成分。根据Liskov替换原则，语言运行时必须在分派到方法之前确定传递的对象是否是方法参数的子类型。
- en: Interestingly, variance is one thing that often diverges between different programming
    languages. Sometimes, there are historical reasons for this, and sometimes it
    depends on the target use cases for the language. In the next few sections, we
    will explore the topic from several angles. We will start with parametric types.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，方差是不同编程语言之间经常存在差异的东西。有时，这有历史原因，有时则取决于语言的目标用例。在接下来的几节中，我们将从几个角度探讨这个主题。我们将从参数化类型开始。
- en: Parametric types are invariant
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化类型是不变的
- en: 'For the purposes of illustration, we will consider a popular type hierarchy
    that is used by some of the OOP literature— the animal kingdom! Everyone loves cats and dogs.
    I have also included crocodiles here to explain related concepts:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，我们将考虑一些面向对象文献中使用的流行类型层次结构——动物王国！每个人都喜欢猫和狗。我还包括鳄鱼来解释相关概念：
- en: '![](img/d0d31151-e2ba-40a1-83ec-577dc147b3c3.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0d31151-e2ba-40a1-83ec-577dc147b3c3.png)'
- en: 'The corresponding code to build such a hierarchy is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 构建此类层次结构的相应代码如下：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For convenience, we can also define the `show` function for these new types:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们也可以为这些新类型定义 `show` 函数：
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Given such a type hierarchy, we can verify how subtypes are handled with the
    following `adopt` function. As nobody wants to adopt crocodiles (well, not me
    at least), we are restricting the function argument to subtypes of `Mammal` only:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这样的类型层次结构，我们可以通过以下 `adopt` 函数验证子类型是如何处理的。由于没有人想领养鳄鱼（至少我不这么认为），我们限制函数参数只接受
    `Mammal` 的子类型：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As expected, we can adopt only cats and dogs, but not crocodiles:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们只能采用猫和狗，但不能采用鳄鱼：
- en: '![](img/08975459-70fb-4a06-8959-06e12fc51f84.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/08975459-70fb-4a06-8959-06e12fc51f84.png)'
- en: 'What if we want to adopt many pets at the same time? Intuitively, we can just
    define a new function that takes an array of mammals, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想同时采用许多宠物呢？直观上，我们可以定义一个新的函数，它接受一个哺乳动物数组，如下所示：
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Unfortunately, it already failed our very first test for adopting Felix and
    Garfield:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，它已经未能通过我们为采用费利克斯和加菲尔德所做的第一次测试：
- en: '![](img/01812bf9-c675-4bed-824f-2e5a69590859.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/01812bf9-c675-4bed-824f-2e5a69590859.png)'
- en: What is going on? We know cats are mammals, so why would an array of cats not
    be passed to the method that takes an array of mammals? The answer is simple—parametric
    types are invariant. Here comes the very first surprise for people coming from
    an OOP background, for which parametric types are often covariant.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么事？我们知道猫是哺乳动物，那么为什么一个猫的数组不能传递给接受哺乳动物数组的函数呢？答案是简单的——参数化类型是不变的。这对于来自面向对象背景的人来说是一个非常大的惊喜，因为参数化类型通常是协变的。
- en: By invariance, even though `Cat` is a subtype of `Mammal`, we cannot say that `Array{Cat,1}`
    is a subtype of `Array{Mammal,1}`. In addition, an `Array{Mammal,1}` actually
    represents a one-dimensional array of `Mammal` objects, for which each object
    can be any subtype of `Mammal`. As each concrete type may have different memory
    layout requirements, this array must store pointers rather than actual values.
    Another way to say this is that the objects are *boxed*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不变性，尽管 `Cat` 是 `Mammal` 的子类型，但我们不能说 `Array{Cat,1}` 是 `Array{Mammal,1}` 的子类型。此外，`Array{Mammal,1}`
    实际上代表一个 `Mammal` 对象的一维数组，其中每个对象可以是 `Mammal` 的任何子类型。由于每个具体类型可能有不同的内存布局要求，这个数组必须存储指针而不是实际值。另一种说法是，对象是
    *装箱* 的。
- en: 'In order to dispatch to this method, we must create an `Array{Mammal,1}`. This
    can be achieved by prefixing the array constructor with `Mammal`, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调度到这个方法，我们必须创建一个 `Array{Mammal,1}`。这可以通过在数组构造函数前加上 `Mammal` 来实现，如下所示：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In practice, this happens a lot more often when we have to handle an array
    of objects of the same type. In Julia, we can express such a homogeneous array
    using the type expression `Array{T,1} where T`. This means that we can define
    a new `adopt` method that can accept multiple mammals as long as they are the
    same kind:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，当我们必须处理同一类型的对象数组时，这种情况更为常见。在 Julia 中，我们可以使用类型表达式 `Array{T,1} where T` 来表达这样的同质数组。这意味着我们可以定义一个新的
    `adopt` 方法，只要它们是同一类型的哺乳动物，就可以接受多个哺乳动物：
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s test the new `adopt` method now. The results are shown in the following
    code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试新的 `adopt` 方法。结果如下所示：
- en: '![](img/fc685976-7a59-424d-92c3-19f7172e0ca1.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc685976-7a59-424d-92c3-19f7172e0ca1.png)'
- en: As expected, the new `adopt` method was dispatched accordingly, depending on
    whether the array contains `Mammal` pointers or physical values of cats or dogs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，新的 `adopt` 方法根据数组是否包含 `Mammal` 指针或猫或狗的实际值相应地调度。
- en: In Julia, the choice of making parametric types invariant is a conscious design
    decision for practical reasons. When an array contains concrete type objects,
    the memory can be allocated to store these objects in a very compact manner. On
    the other hand, when an array contains boxed objects, every reference to an element
    would involve dereferencing a pointer to find the object, and performance would
    suffer as a result.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，选择使参数化类型不变是一个出于实际考虑的自觉设计决策。当一个数组包含具体的类型对象时，内存可以以非常紧凑的方式分配来存储这些对象。另一方面，当一个数组包含装箱对象时，每个元素的引用都会涉及解引用一个指向对象的指针，因此性能会受到影响。
- en: There is indeed one place where Julia uses covariance, that is, method arguments.
    We will discuss these next.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 确实有一个地方 Julia 使用了协变，那就是方法参数。我们将在下面讨论这些。
- en: Method arguments are covariant
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法参数是协变的
- en: 'It should be quite intuitive that method arguments are covariant because that
    is how multiple dispatch work today. Consider the following function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 方法参数是协变的应该是相当直观的，因为这就是今天多态工作的方式。考虑以下函数：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Julia, method arguments are formally represented as a tuple. In the preceding
    example, the method argument is just `Tuple{Mammal,Mammal}`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，方法参数正式表示为一个元组。在上面的例子中，方法参数仅仅是 `Tuple{Mammal,Mammal}`。
- en: 'When we call this function with two arguments that have type `S` and `T` respectively,
    then it will only be dispatched if `S <: Mammal` and `T <: Mammal`. In this case,
    we should be able to pass any combination of mammals—dog/dog, dog/cat, cat/dog,
    and cat/cat. The following screenshot proves this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们用类型为 `S` 和 `T` 的两个参数调用此函数时，它只有在 `S <: Mammal` 和 `T <: Mammal` 的情况下才会被调度。在这种情况下，我们应该能够传递任何哺乳动物的组合——狗/狗、狗/猫、猫/狗和猫/猫。以下截图证明了这一点：'
- en: '![](img/a9aeb3a9-4749-4f57-9803-ef6dd7eb3113.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9aeb3a9-4749-4f57-9803-ef6dd7eb3113.png)'
- en: 'Let''s also check whether a crocodile can join the party:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也检查鳄鱼是否能参加派对：
- en: '![](img/0679c679-a85a-4ff3-a6e7-d24c44bf0e07.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0679c679-a85a-4ff3-a6e7-d24c44bf0e07.png)'
- en: As expected, `Tuple{Cat,Crocodile}` is not a subtype of `Tuple{Mammal,Mammal}`
    since `Crocodile` is not a `Mammal`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`Tuple{Cat,Crocodile}` 不是 `Tuple{Mammal,Mammal}` 的子类型，因为 `Crocodile`
    不是 `Mammal`。
- en: Next, let's move on to a more complex scenario. As we know, functions are first-class
    citizens in Julia. How do we determine whether a function is a subtype of another
    function during dispatch?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们转向一个更复杂的场景。众所周知，函数是 Julia 中的第一公民。我们在调度期间如何确定一个函数是否是另一个函数的子类型？
- en: Dissecting function types
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型的剖析
- en: In Julia, functions are first class. This means that functions can be passed
    around as variables and can appear in method arguments. Since we have learned
    about the covariance property of method arguments, how do we handle the situation
    where functions are passed as arguments?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，函数是一等公民。这意味着函数可以作为变量传递，并且可以出现在方法参数中。由于我们已经学习了方法参数的协变属性，那么当函数作为参数传递时，我们该如何处理这种情况呢？
- en: 'The best way to understand this is to see how functions are typically passed.
    Let''s pick a simple example from Base:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这个问题的最好方法就是看看函数通常是如何传递的。让我们从一个简单的 Base 示例中挑选一个：
- en: '![](img/9a999d78-16eb-42bc-8a5f-e2a539f5f27d.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a999d78-16eb-42bc-8a5f-e2a539f5f27d.png)'
- en: 'The `all` function can be used to check whether a certain condition is evaluated
    as `true` for all elements in an array. To make it more flexible, it can accept
    a custom predicate function. For example, we can check whether all numbers are
    odd in an array as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`all` 函数可以用来检查数组中所有元素是否都评估为 `true` 的条件。为了使其更加灵活，它可以接受一个自定义谓词函数。例如，我们可以检查数组中所有数字是否都是奇数，如下所示：'
- en: '![](img/4209a799-e7c9-4217-b5b7-1a398fb71426.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4209a799-e7c9-4217-b5b7-1a398fb71426.png)'
- en: 'Although we know it was dispatched correctly, we can also confirm that the
    type of `isodd` is a subtype of `Function` as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们知道它被正确调度了，但我们也可以确认 `isodd` 的类型是 `Function` 的子类型，如下所示：
- en: '![](img/4434e2fa-6ca2-498d-96cf-267eaa01f707.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4434e2fa-6ca2-498d-96cf-267eaa01f707.png)'
- en: 'It turns out that all Julia functions have their own unique type, displayed
    as `typeof(isodd)` in the following code, and they all have a supertype of `Function`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，所有 Julia 函数都有它们自己的唯一类型，如下面的代码中显示的 `typeof(isodd)`，并且它们都有一个超类型 `Function`：
- en: '![](img/fa1c951e-48d1-424e-ad85-ad844d47db9a.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa1c951e-48d1-424e-ad85-ad844d47db9a.png)'
- en: 'Because the `all` method was defined to accept any `Function` objects, we can
    actually pass any function and Julia will gladly dispatch to the method. Unfortunately,
    this can potentially lead to undesirable results, as shown in the following screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `all` 方法被定义为接受任何 `Function` 对象，我们实际上可以传递任何函数，Julia 会乐意调度到该方法。不幸的是，这可能会导致不希望的结果，如下面的截图所示：
- en: '![](img/d6ff550d-00ed-4735-bbe0-918983883945.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d6ff550d-00ed-4735-bbe0-918983883945.png)'
- en: We are getting an error here because the function being passed to `all` is supposed
    to take an element and return a Boolean value. Since `println` always returns
    `nothing`, the `all` function just raised an exception.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里遇到了错误，因为传递给 `all` 函数的函数应该接受一个元素并返回一个布尔值。由于 `println` 总是返回 `nothing`，所以
    `all` 函数只是抛出了一个异常。
- en: 'In the case that a stronger type is demanded, the specific function type can
    be enforced as such. Here is how we can create a safer `all` function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要更强类型的情况下，可以强制指定特定的函数类型。以下是如何创建一个更安全的 `all` 函数的方法：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `SignFunctions` constant is a union type that consists of only the types
    for the `isodd` and `iseven` functions. As such, the `myall` method will only
    be dispatched when the first argument is `isodd` or `iseven`; otherwise, a method
    error will be raised, as shown in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`SignFunctions` 常量是一个联合类型，仅由 `isodd` 和 `iseven` 函数的类型组成。因此，`myall` 方法只有在第一个参数是
    `isodd` 或 `iseven` 时才会被调度；否则，将抛出一个方法错误，如下面的截图所示：'
- en: '![](img/3ee0ccdd-170d-4e0b-a259-be37bb21ef1a.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ee0ccdd-170d-4e0b-a259-be37bb21ef1a.png)'
- en: Of course, doing this severely limits the usefulness of the function. We must
    also enumerate all possible functions that may be passed, and that is not always
    feasible. So it seems that the means to handle function arguments is somewhat
    limited.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这样做严重限制了函数的实用性。我们还必须枚举所有可能传递的函数，而这并不总是可行的。因此，处理函数参数的手段似乎有些有限。
- en: Coming back to the topic of variance, there is really nothing to talk about
    when all functions are final and there is only one supertype for all of them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 回到方差的话题，当所有函数都是最终的，并且它们只有一个超类型时，实际上真的没有什么可说的。
- en: In practice, when we design software, we do care about the types of functions.
    As shown in the preceding example, the `all` function can only work with functions
    that take a single argument and return a Boolean value. That should be the interface
    contract. How do we enforce that contract, though? At the end of the day, we need
    to have a better understanding of functions and the contractual agreement between
    the caller and callee. The contract can be seen as a combination of method arguments
    and return types. Let's figure out whether there is a better way to handle this
    issue in the next section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，当我们设计软件时，我们确实关心函数的类型。正如前一个例子所示，`all`函数只能与接受单个参数并返回布尔值的函数一起工作。这应该是接口合同。然而，我们如何强制执行这个合同呢？最终，我们需要对函数和调用者与被调用者之间的合同有更好的理解。合同可以被视为方法参数和返回类型的组合。让我们在下一节中找出是否有更好的方法来处理这个问题。
- en: Determining the variance of the function type
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定函数类型的变异性
- en: In this section, we will attempt to understand how to reason about function
    types. While Julia does not provide too much help in formalizing function types,
    it does not stop us from doing the analysis ourselves. In some strongly typed,
    static OOP languages, function types are more formally defined as the combination
    of method arguments and return type.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试理解如何推理函数类型。虽然Julia在形式化函数类型方面没有提供太多帮助，但它并没有阻止我们自行进行分析。在一些强类型、静态OOP语言中，函数类型被更正式地定义为方法参数和返回类型的组合。
- en: 'Suppose that a function takes three arguments and returns a single value. Then
    we can describe the function with the following notation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个函数接受三个参数并返回一个单一值。然后我们可以用以下符号来描述该函数：
- en: '![](img/20adb83e-9cde-434f-b3b8-cca09921e542.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20adb83e-9cde-434f-b3b8-cca09921e542.png)'
- en: 'Let''s continue the animal kingdom example and define some new variables and
    functions, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续动物王国的例子，并定义一些新的变量和函数，如下所示：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we have defined two arrays—one for female dogs and another for female
    cats. The `select` function can be used to randomly select a dog or cat. Next,
    let''s consider the following function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个数组——一个用于母狗，另一个用于母猫。`select`函数可以用来随机选择一只狗或猫。接下来，让我们考虑以下函数：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `match` function takes a `Mammal` and returns an object of the same type.
    Here''s how it works:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`函数接受一个`Mammal`并返回相同类型的对象。这是它的工作方式：'
- en: '![](img/636f421a-423d-4475-9149-328b536b2dae.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/636f421a-423d-4475-9149-328b536b2dae.png)'
- en: 'Given that the `match` function can only return `Dog` or `Cat`, we can reason
    the function type as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`match`函数只能返回`Dog`或`Cat`，我们可以这样推理函数类型：
- en: '![](img/23c279b7-77fd-4332-9e6d-763ad4ead096.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23c279b7-77fd-4332-9e6d-763ad4ead096.png)'
- en: 'Suppose that we define two more functions, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们定义了两个额外的函数，如下所示：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `meet_partner` function takes a `finder` function as the first argument.
    Then, it calls the `finder` function to find a partner and finally `kiss` the
    partner. By design, we are going to pass the `match` function that we defined
    in the preceding code. Let''s see how it works:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`meet_partner`函数接受一个`finder`函数作为第一个参数。然后，它调用`finder`函数来找到一个伴侣，并最终与伴侣`kiss`。按照设计，我们将传递之前代码中定义的`match`函数。让我们看看它是如何工作的：'
- en: '![](img/5cdec294-de8f-4039-abad-3fc372949b12.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cdec294-de8f-4039-abad-3fc372949b12.png)'
- en: 'So far, so good. From the perspective of the `meet_partner` function, it expects
    the `finder` function to accept a `Mammal` argument and returns a `Mammal` object.
    That is exactly how the `match` function was designed. Now, let''s see if we can
    mess it up by defining a function that does not return a mammal:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。从`meet_partner`函数的角度来看，它期望`finder`函数接受一个`Mammal`参数并返回一个`Mammal`对象。这正是`match`函数的设计方式。现在，让我们看看我们能否通过定义一个不返回哺乳动物的函数来搞砸它：
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Although the `neighbor` function can take a mammal as an argument, it returns
    a crocodile, which is a reptile rather than a mammal. If we try to pass it to
    the `meet_partner` function, we are met with disaster:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`neighbor`函数可以接受一个哺乳动物作为参数，但它返回的是鳄鱼，而鳄鱼是一种爬行动物，不是哺乳动物。如果我们尝试将其传递给`meet_partner`函数，我们就会遇到灾难：
- en: '![](img/bc5086ca-29d5-48d9-85d4-a55d3de7b023.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc5086ca-29d5-48d9-85d4-a55d3de7b023.png)'
- en: What we have just proven is quite intuitive. As the return type of the `finder`
    function is expected to be a `Mammal`, any other `finder` function that returns
    any subtype of `Mammal` would also work. So the return type of function types
    is covariant.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚证明的内容相当直观。由于`finder`函数的返回类型预期为`Mammal`，任何返回`Mammal`任何子类型的其他`finder`函数也会起作用。因此，函数类型的返回类型是协变的。
- en: 'Now, what about the arguments of function types? Again, the `meet_partner`
    function is expected to pass any mammal to the `finder` function. The `finder`
    function must be able to accept either a `dog` or `cat` object. It would not work
    if the `finder` function only takes a cat or dog. Let''s see what happens if we
    have a more restrictive `finder` function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于函数类型的参数是什么？再次，`meet_partner`函数预期将任何哺乳动物传递给`finder`函数。`finder`函数必须能够接受`dog`或`cat`对象。如果`finder`函数只接受猫或狗，那么它将不起作用。让我们看看如果有一个更限制性的`finder`函数会发生什么：
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, the `buddy` function takes a cat and returns a mammal. If we passed it
    to the `meet_partner` function, then it would not work when we want to find a
    partner for our dog `Chef`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`buddy`函数接受一只猫并返回一个哺乳动物。如果我们将其传递给`meet_partner`函数，那么当我们想要为我们的狗`Chef`找到一个伴侣时，它将不起作用：
- en: '![](img/4a9c5a6d-ae0e-4d50-87f6-32fca6864979.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a9c5a6d-ae0e-4d50-87f6-32fca6864979.png)'
- en: So the arguments of function types are not covariant. Could it be contravariant?
    Well, to be contravariant, the `finder` function must accept a supertype of `Mammal`.
    In our animal kingdom, the only supertype is `Vertebrate`; however, `Vertebrate`
    is an abstract type and it cannot be constructed. If we instantiate any other
    concrete type that is a subtype of `Vertebrate`, it would not be a mammal (otherwise,
    it would be considered a mammal already). Therefore, function arguments are invariant.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数类型的参数不是协变的。它们可能是反协变的吗？嗯，为了是反协变的，`finder`函数必须接受`Mammal`的超类型。在我们的动物王国中，唯一的超类型是`Vertebrate`；然而，`Vertebrate`是一个抽象类型，不能被实例化。如果我们实例化任何其他是`Vertebrate`子类型的具体类型，它就不会是哺乳动物（否则，它已经被认为是哺乳动物了）。因此，函数参数是不变的。
- en: 'Stated more formally, this looks as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，这看起来如下所示：
- en: '![](img/25775332-7f88-4142-be84-4d0791240019.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25775332-7f88-4142-be84-4d0791240019.png)'
- en: Function `g` is a subtype of function `f`, as long as `T` is `Mammal` and `S`
    is a subtype of `Mammal`. There is a saying about this: *"Be liberal in what you
    accept and conservative in what you produce."*
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '函数`g`是函数`f`的子类型，只要`T`是`Mammal`，且`S`是`Mammal`的子类型。关于这一点有一句话："在接受方面要宽容，在产生方面要保守。" '
- en: While it is fun doing this kind of analysis, do we gain anything, given that
    the Julia runtime does not support function types as granular as those we have
    seen? It seems to be possible to simulate a type-checking effect on our own, which
    is the topic of the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然做这种分析很有趣，但考虑到Julia运行时不支持像我们所见的那样细粒度的函数类型，我们是否真的获得了什么？似乎我们可以自己模拟一个类型检查的效果，这是下一节的主题。
- en: Implementing our own function type dispatch
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们自己的函数类型分派
- en: As we have seen earlier in this section, Julia creates a unique function type
    for every function, and they are all subtypes of the `Function` abstract type.
    We seem to be missing an opportunity for multiple dispatch. Taking the `all` function
    from `Base` as an example, it would be very nice if we could design a type that
    represents predicate functions rather than letting `all` fail miserably when an
    incompatible function is passed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节前面所看到的，Julia为每个函数创建一个唯一的函数类型，它们都是`Function`抽象类型的子类型。我们似乎错过了一个多态的机会。以`Base`中的`all`函数为例，如果我们能够设计一个表示谓词函数的类型，而不是让`all`在传递不兼容的函数时失败，那将会非常棒。
- en: 'In order to work around this limitation, let''s define a parametric type called
    `PredicateFunction` as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个限制，让我们定义一个名为`PredicateFunction`的参数化类型，如下所示：
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `PredicateFunction` parametric type just wraps a function `f`. The type
    parameters `T` and `S` are used to represent the types of function arguments and
    return a type of `f` respectively. As an example, the `iseven` function can be
    wrapped as follows, because we know the function can take a number and return
    a Boolean value:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`PredicateFunction`参数化类型只是包装了一个函数`f`。类型参数`T`和`S`用于表示函数参数的类型，并分别返回`f`的类型。例如，`iseven`函数可以被包装如下，因为我们知道该函数可以接受一个数字并返回一个布尔值：'
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Conveniently, since Julia supports callable structs, we can make it so that
    the `PredicateFunction` struct can be invoked as if it was a function itself.
    To enable this, we can define the following function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 便利的是，由于Julia支持可调用的结构体，我们可以使`PredicateFunction`结构体可以被调用，就像它本身是一个函数一样。为了实现这一点，我们可以定义以下函数：
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, this function merely forwards the call to the `pred.f` wrapped
    function. Once it is defined, we can do some small experiments to see how it works:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个函数只是将调用转发到包装的`pred.f`函数。一旦定义了它，我们就可以做一些小实验来看看它是如何工作的：
- en: '![](img/1f65f6b0-84cf-4ddf-bbf5-cdf415369319.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f65f6b0-84cf-4ddf-bbf5-cdf415369319.png)'
- en: 'That looks pretty good. Let''s define our own *safe* version of the `all` function
    as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来相当不错。让我们定义我们自己的 *safe* 版本的 `all` 函数，如下所示：
- en: '[PRE19]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `safe_all` function takes a `PredicteFunction{T,S}` as the first argument,
    with the constraint that `T` is a subtype of `Any` and `S` is a subtype of `Bool`.
    It''s exactly the function type signature we want for predicate functions. Knowing
    that `Number <: Any` and `Bool <: Bool`, we can definitely pass the `iseven` function
    to `safe_all`. Let''s test it now:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`safe_all` 函数接受一个 `PredicteFunction{T,S}` 作为第一个参数，约束条件是 `T` 是 `Any` 的子类型，而
    `S` 是 `Bool` 的子类型。这正是我们想要的谓词函数的类型签名。知道 `Number <: Any` 和 `Bool <: Bool`，我们可以肯定地将
    `iseven` 函数传递给 `safe_all`。现在让我们测试一下：'
- en: '![](img/d2b7aeac-02a3-426b-a30e-e4a187c0720f.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2b7aeac-02a3-426b-a30e-e4a187c0720f.png)'
- en: '*Bravo! *We have created a safe version of the `all` function. The first argument
    must be a predicate function that takes anything and returns a Boolean value.
    Rather than taking a generic `Function` argument, we can now enforce strict type
    matching and participate in multiple dispatch.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bravo!* 我们已经创建了一个安全的 `all` 函数版本。第一个参数必须是一个接受任何内容并返回布尔值的谓词函数。我们不再需要接受一个通用的
    `Function` 参数，现在我们可以强制严格的类型匹配并参与多重分发。'
- en: That is enough about variance. Next, we will move on and revisit the rules for
    the parametric method dispatch.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 关于变异性就讲这么多。接下来，我们将继续并重新审视参数化方法调用的规则。
- en: Parametric methods revisited
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化方法重新审视
- en: The ability to dispatch to various methods based upon subtyping relationships
    is a key feature of the Julia language. We initially introduced the concept of
    parametric methods in [Chapter 3](6c453014-3590-4a63-9d39-9bdd735185d5.xhtml),
    *Designing Functions and Interfaces*. In this section, we will go a little deeper
    and examine some subtle situations about how methods are selected for dispatch.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 根据子类型关系进行分发的功能是 Julia 语言的一个关键特性。我们最初在 [第 3 章](6c453014-3590-4a63-9d39-9bdd735185d5.xhtml)
    *设计函数和接口* 中介绍了参数化方法的概念。在本节中，我们将更深入地探讨一些关于方法选择分发的微妙情况。
- en: 'Let''s start with the basics: how do we specify type variables for parametric
    methods?'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础开始：我们如何为参数化方法指定类型变量？
- en: Specifying type variables
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定类型变量
- en: 'When we define a parametric method, we use the `where` clause to introduce
    type variables. Let''s go over a simple example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个参数化方法时，我们使用 `where` 子句来引入类型变量。让我们来看一个简单的例子：
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `triple` function takes an `Array{T}`, where `T` is any subtype of `Real`.
    This code is very readable, and it is the format that most Julia developers choose
    to specify type parameters. So what could the value of `T` be? Could it be a concrete
    type, abstract type, or both?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`triple` 函数接受一个 `Array{T}`，其中 `T` 是 `Real` 的任何子类型。这段代码非常易于阅读，这是大多数 Julia 开发者选择来指定类型参数的格式。那么
    `T` 的值可能是什么？它可以是具体类型、抽象类型，或者两者都是？'
- en: 'To answer this question, we can test it out from the REPL:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们可以在 REPL 中测试它：
- en: '![](img/4b23463f-010e-4d58-870c-eea21f73d9ec.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b23463f-010e-4d58-870c-eea21f73d9ec.png)'
- en: 'So the method does get dispatched on both the abstract type (`Real`) and concrete
    type (`Int64`). It is worth mentioning that the `where` clause can also be placed
    right next to the method argument:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该方法确实在抽象类型（`Real`）和具体类型（`Int64`）上进行了分发。值得一提的是，`where` 子句也可以放在方法参数旁边：
- en: '[PRE21]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: From a functional perspective, it is the same as before, whether the `where`
    clause is placed inside or outside.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数式编程的角度来看，无论 `where` 子句是放在内部还是外部，都是相同的。
- en: 'There are some subtle differences, however. When the `where` clause is placed
    outside, you gain two additional benefits:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些细微的差别。当 `where` 子句放在外部时，你将获得两个额外的优势：
- en: The type variable `T` is accessible inside the method body.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型变量 `T` 在方法体内部是可访问的。
- en: The type variable `T` can be used to enforce the same values if it is used for
    multiple method arguments.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型变量 `T` 可以用来强制多个方法参数具有相同的值。
- en: It turns out that the second point leads to an interesting feature in Julia's
    dispatch system. We will go over this next.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，第二点导致了 Julia 分发系统中一个有趣的功能。我们将在下一节中介绍这一点。
- en: Matching type variables
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配类型变量
- en: 'Whenever a type variable occurs more than once in a method signature, it is
    used to enforce the same type as determined across all positions where it occurs.
    Consider the following function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类型变量在方法签名中多次出现时，它被用来强制所有出现位置具有相同的类型。考虑以下函数：
- en: '[PRE22]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `add` function takes an `Array{T}` and a value of type `T`. It returns
    a tuple of `T` and the result of adding the value to the array. Intuitively, we
    want the type `T` to be consistent across both arguments. In other words, we would
    want the function to be specialized in each of the realizations of `T` when the
    function is called. Obviously, the function works great when the type agrees:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 函数接受一个 `Array{T}` 和一个类型为 `T` 的值。它返回一个包含 `T` 和将值添加到数组后的结果的元组。直观上，我们希望
    `T` 在两个参数中保持一致。换句话说，我们希望函数在调用时针对 `T` 的每个实现进行特殊化。显然，当类型一致时，函数工作得很好：'
- en: '![](img/425d6c47-b5ed-4bde-9c90-4703c762df47.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/425d6c47-b5ed-4bde-9c90-4703c762df47.png)'
- en: 'In the first case, `T` is determined to be `Int64`, and in the second case,
    `T` is determined to be `Float64`. Perhaps not too surprisingly, we may get a
    method error when the types do not match:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，`T` 被确定为 `Int64`，而在第二种情况下，`T` 被确定为 `Float64`。也许并不令人意外，当类型不匹配时，我们可能会得到一个方法错误：
- en: '![](img/13eb7095-6142-4e56-8a4b-7c0f52f4b414.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13eb7095-6142-4e56-8a4b-7c0f52f4b414.png)'
- en: Since we said that `T` could be an abstract type, could we dispatch to this
    method, as `T` could be considered `Real`? The answer is no, because parametric
    types are *invariant*! An array of `Real` objects is not the same as an array
    of `Int64` values. More formally, `Array{Int}` is not a subtype of `Array{Real}`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们说 `T` 可以是一个抽象类型，我们能否将方法分派到这个方法上，因为 `T` 可以被认为是 `Real`？答案是不了，因为参数化类型是 *不变的*！一个
    `Real` 对象的数组不等于一个 `Int64` 值的数组。更正式地说，`Array{Int}` 不是 `Array{Real}` 的子类型。
- en: 'It gets a little more interesting when `T` is an abstract type in the array.
    Let''s try this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `T` 是数组中的抽象类型时，事情会变得更有趣。让我们试试这个：
- en: '![](img/11d6d02b-b849-4917-b436-c1bec7a8b75d.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11d6d02b-b849-4917-b436-c1bec7a8b75d.png)'
- en: Here, `T` is unambiguously set to `Signed`, and because `Int8` is a subtype
    of `Signed`, the method is dispatched properly.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`T` 明确设置为 `Signed`，并且由于 `Int8` 是 `Signed` 的子类型，方法被正确分派。
- en: Next, we will look into another unique typing feature called the diagonal rule.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨另一个独特的类型特性，称为对角线规则。
- en: Understanding the diagonal rule
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解对角线规则
- en: As we learned earlier, it is a nice feature to be able to match type variables
    and keep them consistent across method arguments. In practice, there are situations
    where we want to be even more specific when determining the right type for each
    type variable.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所学的，能够匹配类型变量并在方法参数中保持一致性是一个很好的特性。在实践中，有些情况下我们希望在确定每个类型变量的正确类型时更加具体。
- en: 'Consider this function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个函数：
- en: '[PRE23]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `diagonal` function takes two arguments with the same type, where the type
    `T` must be a subtype of `Number`. The type variable `T` is simply returned to
    the caller.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`diagonal` 函数接受两个相同类型的参数，其中类型 `T` 必须是 `Number` 的子类型。类型变量 `T` 简单地返回给调用者。'
- en: 'When `T` is concrete, it is easy to reason that the types are consistent. For
    example, we can pass a pair of `Int64` values or a pair of `Float64` values to
    the function and expect to see the respective concrete type returned:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `T` 是具体类型时，很容易推理出类型是一致的。例如，我们可以传递一对 `Int64` 值或一对 `Float64` 值给函数，并期望看到相应的具体类型返回：
- en: '![](img/cb4f34ea-85fb-44ff-b0e1-e30a14afc601.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cb4f34ea-85fb-44ff-b0e1-e30a14afc601.png)'
- en: 'Intuitively, we also expect this to fail when the types are not consistent:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 直观上，我们也期望当类型不一致时这会失败：
- en: '![](img/665bf3a1-62f1-4a40-b749-948d3f666838.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/665bf3a1-62f1-4a40-b749-948d3f666838.png)'
- en: 'While it seems to work intuitively, we could have argued that the type variable
    `T` is an abstract type, such as `Real`. Since the value of `1` is `Int64` and
    `Int64` is a subtype of `Real`, and the value of `2.0` is `Float64` and `Float64`
    is a subtype of `Real`, shouldn''t the method still get dispatched anyway? To
    make this point more clear, we can even annotate the argument as such when calling
    the function:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来直观，但我们可能会争辩说类型变量 `T` 是一个抽象类型，比如 `Real`。由于 `1` 的值是 `Int64` 且 `Int64` 是 `Real`
    的子类型，以及 `2.0` 的值是 `Float64` 且 `Float64` 是 `Real` 的子类型，那么方法是否仍然应该被分派？为了使这一点更加清晰，我们甚至可以在调用函数时将参数注释为如下：
- en: '![](img/4868de6b-d615-4a27-ab78-349d3f8e8586.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4868de6b-d615-4a27-ab78-349d3f8e8586.png)'
- en: It turns out that Julia is designed to give us more intuitive behavior. It is
    also the very reason why the** diagonal rule** was introduced. The diagonal rule
    says that when a type variable occurs more than once in the covariant position
    (that is, the method arguments), then the type variable will be restricted to
    match with concrete types only.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the type variable `T` is considered a diagonal variable, so `T`
    must be a concrete type.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: There is an exception to the diagonal rule, though. We will discuss this next.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: An exception to the diagonal rule
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The diagonal rule says that when a type variable occurs more than once in the
    covariant position (that is, the method arguments), then the type variable will
    be restricted to match with concrete types only; however, there is an exception
    to that rule—when the type variable is unambiguously determined from an invariant
    position, then it is allowed to be an abstract type rather than a concrete type.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Unlike the `diagonal` function from the previous section, this one allows `T`
    to be abstract. We can prove it as such:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49fbfd9a-7135-4306-8a5b-98c38072504c.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: The reason is that `T` appears in the first argument in a parametric type. As
    we know that parametric types are invariant, we have already determined that `T` is `Signed`.
    Because `Int64` is a subtype of `Signed`, everything matched.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will go over the availability of type variables.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The availability of type variables
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important feature of the parametric method is that the type variable specified
    in the `where` clause is also accessible from the method body. Contrary to what
    you might think, this is not always true. Here, we will present a case where the
    type variable is not available at runtime.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following functions:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can use the `mytypes1` and `mytypes2` functions to experiment with what
    type variables are derived by the Julia runtime. Let''s start with the happy case:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a2c4782-0e8c-4852-a4d4-9eadfcfa28bc.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: 'However, the picture is not always rosy. In other situations, it may not work
    100% of the time. Here''s an example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec77e83f-612b-423b-bac8-5226a4d5e997.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: Why is `S` not defined here? First of all, we already know that `T` is `Signed`
    because the parametric type is invariant. As part of the `where` clause, we also
    know that `T` is a subtype of `S`. As such, `S` could be `Integer`, `Real`, `Number`,
    or even `Any`. As there are too many possible answers, the Julia runtime decided
    not to assign any value to `S`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The moral of the story is don't assume that a type variable is always defined
    and accessible from the method, especially for a more complex situation like this.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about various topics related to subtyping, variance,
    and dispatch. These concepts are the fundamental building blocks for creating
    larger, more complex applications.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: We first went over the topic of implementation inheritance and behavior subtyping
    and the differences between them. We reasoned that implementation inheritance
    is not a great design pattern because of various issues. We came to an understanding
    that Julia's type system is designed to avoid the flaws that we have seen in other
    programming languages.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论了实现继承和行为子类型化以及它们之间的区别。我们推理出，由于各种问题，实现继承不是一个很好的设计模式。我们得出结论，Julia的类型系统是为了避免我们在其他编程语言中看到的问题而设计的。
- en: Then, we reviewed different kinds of variance, which are nothing but ways to
    explain the subtyping relationship between parametric types. We walked through
    in great details how parametric types are invariant and method arguments are covariant.
    We then went even further to discuss the variance of function types and how we
    can build our own data type that wraps a function for dispatch purpose.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们回顾了不同种类的变异性，这些不过是解释参数化类型之间子类型关系的方法。我们详细地解释了参数化类型是如何不变的，方法参数是如何协变的。然后我们更进一步讨论了函数类型的变异性以及我们如何可以构建自己的数据类型来封装函数以实现分派目的。
- en: Finally, we revisited parametric methods and looked at how type variables are
    specified and matched during dispatch. We learned about the diagonal rule, which
    is a key design feature in the Julia language that allows us to enforce type consistency
    across method arguments in an intuitive manner.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重新审视了参数化方法，并探讨了在分派过程中类型变量是如何指定和匹配的。我们了解了对角线规则，这是Julia语言中的一个关键设计特性，它允许我们以直观的方式强制方法参数的类型一致性。
- en: We are now finished with the chapter and the book. Thank you for reading it!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了这一章节和整本书。感谢您阅读它！
- en: Questions
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How is implementation inheritance different from behavior subtyping?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现继承和行为子类型化有何不同？
- en: What are some major issues with implementation inheritance?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现继承有哪些主要问题？
- en: What is duck typing?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是鸭子类型？
- en: What is the variance of method arguments and why?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法参数的变异性是什么，为什么？
- en: Why are parametric types invariant in Julia?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在Julia中参数化类型是不变的？
- en: When does the diagonal rule apply?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对角线规则何时适用？
