["```py\nGumbo@v0.5.1\nHTTP@v0.7.1\nIJulia@v1.14.1\nOrderedCollections@v1.0.2\n```", "```py\npkg> add PackageName@vX.Y.Z \n```", "```py\npkg> add IJulia@v1.14.1\n```", "```py\njulia> download(\"https://raw.githubusercontent.com/PacktPublishing/Julia-Programming-Projects/master/Chapter03/Project.toml\", \"Project.toml\")\npkg> activate . \npkg> instantiate\n```", "```py\n<h1>Julia (programming language)</h1> \n```", "```py\n<div> \n    <h2>Language features</h2> \n    <p>According to the official website, the main features of the language are:</p> \n    <ul> \n           <li>Multiple dispatch</li> \n           <li>Dynamic type sytem</li> \n           <li>Good performance</li> \n    </ul> \n</div> \n<h2>), a paragraph of text (<p>), and an unordered list (<ul>), with three list items (<li>), all within a page section (<div>):\n```", "```py\n<a href=\"https://julialang.org/\">This is a link to Julia's home page</a>\n```", "```py\n<a href=\"https://julialang.org/\" id=\"julia_link\" class=\"external_link\">This is a link to Julia's home page</a>\n```", "```py\njulia> HTTP.get(\"https://en.wikipedia.org/wiki/Julia_(programming_language)\") \n```", "```py\njulia> resp = ans \n```", "```py\njulia> fieldnames(typeof(resp)) \n(:version, :status, :headers, :body, :request) \n```", "```py\njulia> resp.status 200 \n```", "```py\njulia> resp.headers \n```", "```py\njulia> resp.body \n193324-element Array{UInt8,1}: \n 0x3c \n 0x21 \n 0x44  \n# ... output truncated ...  \n```", "```py\njulia> resp_body = String(resp.body) \n```", "```py\njulia> resp_body[1:500] \n```", "```py\njulia> resp.headers \n25-element Array{Pair{SubString{String},SubString{String}},1} \n```", "```py\njulia> Pair(:foo, \"bar\") \n:foo => \"bar\" \n```", "```py\njulia> typeof(Pair(:foo, \"bar\")) \nPair{Symbol,String} \n```", "```py\njulia> 3 => 'C' \n3 => 'C' \n\njulia> typeof(3 => 'C') \nPair{Int64,Char} \n\n```", "```py\n\"Content-Type\" => \"text/html; charset=UTF-8\"\n```", "```py\njulia> p = \"one\" => 1 \n\"one\" => 1 \n\njulia> p[1] \n\"one\" \n\njulia> p[2] \n1 \n\n```", "```py\njulia> p.first \n\"one\" \n\njulia> p.second \n1 \n```", "```py\njulia> p.first = \"two\" \nERROR: type Pair is immutable \n\njulia> p[1] = \"two\" \nERROR: MethodError: no method matching setindex!(::Pair{String,Int64} \n```", "```py\njulia> d = Dict() \nDict{Any,Any} with 0 entries \n```", "```py\njulia> setindex!(d, \"World\", \"Hello\") \nDict{Any,Any} with 1 entry: \n  \"Hello\" => \"World\" \n```", "```py\njulia> d[\"Hola\"] = \"Mundo\" \n\"Mundo\"  \n```", "```py\njulia> d[:speed] = 6.4 \n6.4 \n```", "```py\njulia> d \nDict{Any,Any} with 3 entries: \n  \"Hello\" => \"World\" \n  :speed  => 6.4 \n  \"Hola\"  => \"Mundo\" \n```", "```py\njulia> d[\"Hello\"] = \"Earth\" \"Earth\" \n```", "```py\njulia> d \nDict{Any,Any} with 3 entries: \n  \"Hello\" => \"Earth\" \n  :speed  => 6.4 \n  \"Hola\"  => \"Mundo\"   \n```", "```py\njulia> dt = Dict(\"age\" => 12) \nDict{String,Int64} with 1 entry: \n  \"age\" => 12 \n```", "```py\njulia> dt[:price] = 9.99 \nMethodError: Cannot `convert` an object of type Symbol to an object of type String \n```", "```py\njulia> dx = Dict(1 => 11) \nDict{Int64,Int64} with 1 entry: \n  1 => 11 \njulia> dx[2.0] = 12 \n12\n\n```", "```py\njulia> dx \nDict{Int64,Int64} with 2 entries: \n  2 => 12 \n  1 => 11 \n```", "```py\njulia> dx[2.4] = 12 \nInexactError: Int64(Int64, 2.4) \n```", "```py\n julia> clients_purchases = Dict( \n       \"John Roche\" => [\"soap\", \"wine\", \"apples\", \"bread\"], \n       \"Merry Lou\"  => [\"bottled water\", \"apples\", \"cereals\", \"milk\"] \n       ) \nDict{String,Array{String,1}} with 2 entries: \n  \"John Roche\" => [\"soap\", \"wine\", \"apples\", \"bread\"] \n  \"Merry Lou\"  => [\"bottled water\", \"apples\", \"cereals\", \"milk\"] \n```", "```py\njulia> dd = Dict{String,Int}(\"\" => 2.0) \nDict{String,Int64} with 1 entry: \n  \"x\" => 2 \n```", "```py\njulia> p1 = \"a\" => 1 \n\"a\"=>1 \njulia> p2 = Pair(\"b\", 2) \n\"b\"=>2 \njulia> Dict(p1, p2) \nDict{String,Int64} with 2 entries: \n  \"b\" => 2 \n  \"a\" => 1 \n```", "```py\njulia> Dict([p1, p2]) \nDict{String,Int64} with 2 entries: \n  \"b\" => 2 \n  \"a\" => 1 \n```", "```py\njulia> Dict([(\"a\", 5), (\"b\", 10)]) \nDict{String,Int64} with 2 entries: \n  \"b\" => 10 \n  \"a\" => 5 \n```", "```py\njulia> using Dates \njulia> Dict([x => Dates.dayname(x) for x = (1:7)]) \nDict{Int64,String} with 7 entries: \n  7 => \"Sunday\" \n  4 => \"Thursday\" \n  2 => \"Tuesday\" \n  3 => \"Wednesday\" \n  5 => \"Friday\" \n  6 => \"Saturday\" \n  1 => \"Monday\" \n```", "```py\npkg> add OrderedCollections \njulia> using OrderedCollections, Dates \njulia> OrderedDict(x => Dates.monthname(x) for x = (1:12)) \nDataStructures.OrderedDict{Any,Any} with 12 entries: \n  1  => \"January\" \n  2  => \"February\" \n  3  => \"March\" \n  4  => \"April\" \n  5  => \"May\" \n  6  => \"June\" \n  7  => \"July\" \n  8  => \"August\" \n  9  => \"September\" \n  10 => \"October\" \n  11 => \"November\" \n  12 => \"December\" \n```", "```py\njulia> d = Dict(:foo => 1, :bar => 2) \nDict{Symbol,Int64} with 2 entries: \n  :bar => 2 \n  :foo => 1 \n\njulia> d[:bar] \n2 \n```", "```py\njulia> d[:baz] \nERROR: KeyError: key :baz not found \n```", "```py\njulia> haskey(d, :baz) \nfalse \n```", "```py\njulia> get(d, :baz, 0) \n0 \n```", "```py\njulia> d \nDict{Symbol,Int64} with 2 entries: \n  :bar => 2 \n  :foo => 1 \n\njulia> get!(d, :baz, 100) \n100 \n\njulia> d \nDict{Symbol,Int64} with 3 entries: \n  :baz => 100 \n  :bar => 2 \n  :foo => 1 \n\njulia> haskey(d, :baz) \ntrue  \n```", "```py\njulia> delete!(d, :baz) \nDict{Symbol,Int64} with 2 entries: \n  :bar => 2 \n  :foo => 1 \n\njulia> haskey(d, :baz) \nfalse \n```", "```py\njulia> keys(d) \nBase.KeySet for a Dict{Symbol,Int64} with 2 entries. Keys: \n  :bar \n  :foo \n\njulia> values(d) \nBase.ValueIterator for a Dict{Symbol,Int64} with 2 entries. Values: \n  2 \n  1 \n```", "```py\njulia> collect(keys(d)) \n2-element Array{Symbol,1}: \n :bar \n :foo \n\njulia> collect(values(d)) \n2-element Array{Int64,1}: \n 2 \n 1 \n```", "```py\njulia> d2 = Dict(:baz => 3) \nDict{Symbol,Int64} with 1 entry: \n  :baz => 3 \n\njulia> d3 = merge(d, d2) \nDict{Symbol,Int64} with 3 entries: \n  :baz => 3 \n  :bar => 2 \n  :foo => 1 \n```", "```py\njulia> merge(d3, Dict(:baz => 10)) \nDict{Symbol,Int64} with 3 entries: \n  :baz => 10 \n  :bar => 2 \n  :foo => 1 \n```", "```py\njulia> headers = Dict(resp.headers) \nDict{SubString{String},SubString{String}} with 23 entries: \n\"Connection\"     => \"keep-alive\" \n  \"Via\"          => \"1.1 varnish (Varnish/5.1), 1.1 varnish (Varni... \n  \"X-Analytics\"  => \"ns=0;page_id=38455554;https=1;nocookies=1\" \n#... output truncated... #\n```", "```py\njulia> headers[\"Content-Length\"] \n\"193324\" \n```", "```py\njulia> headers[\"Content-Length\"] > 0 \nERROR: MethodError: no method matching isless(::Int64, ::String) \n```", "```py\njulia> parse(Int, headers[\"Content-Length\"]) > 0 \ntrue \n```", "```py\npkg> add Gumbo \njulia> using Gumbo  \n```", "```py\njulia> dom = parsehtml(resp_body)\n HTML Document\n```", "```py\njulia> fieldnames(typeof(dom)) \n(:doctype, :root)  \n```", "```py\njulia> dom.doctype \n\"html\" \n```", "```py\njulia> dom.root.attributes \nDict{AbstractString,AbstractString} with 3 entries: \n  \"class\" => \"client-nojs\" \n  \"lang\"  => \"en\" \n  \"dir\"   => \"ltr\" \n```", "```py\njulia> attrs(dom.root) \nDict{AbstractString,AbstractString} with 3 entries: \n  \"class\" => \"client-nojs\" \n  \"lang\"  => \"en\" \n  \"dir\"   => \"ltr\" \n```", "```py\njulia> tag(dom.root) \n:HTML \n```", "```py\njulia> for c in children(dom.root) \n           @show tag(c) \n       end \ntag(c) = :head \ntag(c) = :body \n```", "```py\njulia> body = children(dom.root)[2]; \n```", "```py\nHTMLElement{:body}: \n<body class=\"mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Julia_programming_language rootpage-Julia_programming_language skin-vector action-view\"> \n# ... output truncated ...\n```", "```py\njulia> getattr(dom.root, \"class\") \n\"client-nojs\" \n\njulia> getattr(dom.root, \"href\") # oops! \nERROR: KeyError: key \"href\" not found \n```", "```py\njulia> in(\"href\", collect(keys(attrs(dom.root)))) \nfalse \n```", "```py\njulia> collect(keys(attrs(dom.root))) \n3-element Array{AbstractString,1}: \n \"class\" \n \"lang\" \n \"dir\"\n```", "```py\njulia> dom.root |> attrs |> keys |> collect \n3-element Array{AbstractString,1}: \n \"class\" \n \"lang\" \n \"dir\" \n```", "```py\njulia> try \n    getattr(dom.root, \"href\") \ncatch \n    println(\"The $(tag(dom.root)) tag doesn't have a 'href' attribute.\") \nend \nThe HTML tag doesn't have a 'href' attribute. \n```", "```py\njulia> try \n    getattr(dom.root, \"href\") \n    println(\"I'm here too\") \ncatch \n    println(\"The $(tag(dom.root)) tag doesn't have a 'href' attribute.\") \nend \nThe HTML tag doesn't have a 'href' attribute. \n```", "```py\njulia> try \ngetattr(dom.root, \"class\") \n    println(\"I'm here too\") \ncatch \n    println(\"The $(tag(dom.root)) tag doesn't have a 'href' attribute.\") \nend \nI'm here too \n```", "```py\njulia> try \n     getattr(dom.root, \"href\") \ncatch ex \n    if isa(ex, KeyError)  \n            println(\"The $(tag(dom.root)) tag doesn't have a '$(ex.key)' attribute.\") \n    else  \n           println(\"Some other exception has occurred\") \n    end \nend \nThe HTML tag doesn't have a 'href' attribute. \n```", "```py\njulia> try \n     error(\"Oh my!\") \ncatch ex \n    if isa(ex, KeyError)  \n            println(\"The $(tag(dom.root)) tag doesn't have a '$(ex.key)' attribute.\") \n    else  \n           println(\"Some exception has occurred\") \n    end \nend \nSome exception has occurred \n```", "```py\njulia> try \n    getattr(dom.root, \"href\") \ncatch ex \n    println(\"The $(tag(dom.root)) tag doesn't have a '$(ex.key)' attribute.\") \nfinally \n    println(\"I always get called\") \nend \nThe HTML tag doesn't have a 'href' attribute. \nI always get called \n```", "```py\njulia> try getattr(dom.root, \"href\") end syntax: try without catch or finally \n```", "```py\njulia> result = try \n           error(\"Oh no!\") \n       catch ex \n           \"Everything is under control\" \n        end \n\"Everything is under control\" \n\njulia> result \n\"Everything is under control\" \n```", "```py\njulia> throw(KeyError(\"href\")) \nERROR: KeyError: key \"href\" not found \n```", "```py\njulia> ex = ErrorException(\"To err is human, but to really foul things up you need a computer.\") \nErrorException(\"To err is human, but to really foul things up you need a computer.\") \n\njulia> throw(ex) \nERROR: To err is human, but to really foul things up you need a computer. \n\njulia> ex.msg \n\"To err is human, but to really foul things up you need a computer.\" \n```", "```py\njulia> error(\"To err is human - to blame it on a computer is even more so.\") \nERROR: To err is human - to blame it on a computer is even more so. \n```", "```py\njulia> try \n           Dict()[:foo] \n       catch ex \n           \"nothing to see here\" \n       end \n\"nothing to see here\" \n```", "```py\njulia> try \n           Dict()[:foo] \n       catch ex \n           throw(ex) \n       end \nERROR: KeyError: key :foo not found \nStacktrace: \n [1] top-level scope at REPL \n```", "```py\njulia> try \n           Dict()[:foo] \n       catch ex \n            rethrow(ex) \n       end \nERROR: KeyError: key :foo not found \nStacktrace: \n [1] getindex(::Dict{Any,Any}, ::Symbol) at ./dict.jl:474 \n [2] top-level scope at REPL[140]\n```", "```py\njulia> function add(x, y) \n           x + y \n       end \nadd (generic function with 1 method) \n```", "```py\njulia> add(x, y) = x + y \nadd (generic function with 1 method) \n```", "```py\njulia> add(1, 2) \n3 \n```", "```py\njulia> function add(x, y) \n           return \"I don't feel like doing math today\" \n           x + y \n       end \nadd (generic function with 1 method) \n\njulia> add(1, 2) \n\"I don't feel like doing math today\" \n```", "```py\njulia> function addremove(x, y) \n           x+y, x-y \n       end \naddremove (generic function with 1 method) \n\njulia> a, b = addremove(10, 5) \n(15, 5) \n\njulia> a \n15 \n\njulia> b \n5 \n```", "```py\njulia> function addremove(x=100, y=10) \n           x+y, x-y \n       end \naddremove (generic function with 3 methods) \n```", "```py\njulia> addremove() \n(110, 90) \n```", "```py\njulia> addremove(5) \n(15, -5) \n```", "```py\njulia> addremove(5, 1) \n(6, 4) \n```", "```py\nplot(iris, x=:SepalLength, y=:PetalLength, color=:Species) \n```", "```py\nfunction thermal_confort(temperature, humidity; scale = :celsius, age = 35) \n```", "```py\nthermal_confort(27, 56, age = 72, scale = :fahrenheit)\n```", "```py\nfunction thermal_confort(temperature, humidity; scale = :celsius, age = 35, health_risk = age/100) \n```", "```py\n\"\"\" \n        thermal_confort(temperature, humidity; <keyword arguments>) \nCompute the thermal comfort index based on temperature and humidity. It can optionally take into account the age of the patient. Works for both Celsius and Fahrenheit.  \n# Examples: \n```", "```py \n# Arguments \n- temperature: the current air temperature \n- humidity: the current air humidity \n- scale: whether :celsius or :fahrenheit, defaults to :celsius \n- age: the age of the patient \n\"\"\" \nfunction thermal_confort(temperature, humidity; scale = :celsius, age = 35)\n```", "```py\nhelp?> thermal_confort \n```", "```py\njulia> mkdir(\"WebCrawler\") \n\"WebCrawler\" \n\njulia> cd(\"WebCrawler/\") \n```", "```py\npkg> activate .\n```", "```py\n(WebCrawler) pkg> \n```", "```py\n(v1.0) pkg> \n```", "```py\n(WebCrawler) pkg> st \n    Status `Project.toml` \n```", "```py\n(WebCrawler) pkg> add HTTP \n(WebCrawler) pkg> add Gumbo \n```", "```py\njulia> touch(\"webcrawler.jl\") \n\"webcrawler.jl\" \n```", "```py\nusing HTTP, Gumbo \n```", "```py\nconst PAGE_URL = \"https://en.wikipedia.org/wiki/Julia_(programming_language)\" \n```", "```py\nconst LINKS = String[] \n```", "```py\nfunction fetchpage(url)\n    response = HTTP.get(url)\n    if response.status == 200 && parse(Int, Dict(response.headers)[\"Content-Length\"]) > 0\n        String(response.body)\n    else\n        \"\"\n    end\nend   \n```", "```py\njulia> x = 5 \n5 \n\njulia> if x < 0 \n           println(\"x is a negative number\") \n      elseif x > 0 \n           println(\"x is a positive number greater than 0\") \n      else  \n           println(\"x is 0\") \n      end \nx is a positive number greater than 0 \n```", "```py\njulia> status = if x < 0 \n                         \"x is a negative number\" \n                  elseif x > 0 \n                         \"x is a positive number greater than 0\" \n                   else  \n                         \"x is 0\" \n                   end \n\"x is a positive number greater than 0\" \n\njulia> status \n\"x is a positive number greater than 0\" \n```", "```py\njulia> status = if x < 0 \n            \"x is a negative number\" \n       elseif x > 0 \n            y = 20 \n            \"x is a positive number greater than 0\" \n       else  \n            \"x is 0\" \n       end \n\"x is a positive number greater than 0\" \n\njulia> y \n20 \n```", "```py\njulia> status = if x < 0 \n            \"x is a negative number\" \n       elseif x > 0 \n            local z = 20 \n            \"x is a positive number greater than 0\" \n       else  \n            \"x is 0\" \n       end \n\"x is a positive number greater than 0\" \n\njulia> z \nUndefVarError: z not defined\n```", "```py\nx ? y : z \n```", "```py\njulia> x = 10 \n10 \n\njulia> x < 0 ? \"negative\" : \"positive\" \n\"positive\" \n```", "```py\njulia> x = 10 \n10 \n\njulia> x > 5 && \"bigger than 5\" \"bigger than 5\"\n```", "```py\njulia> x > 15 && \"bigger than 15\" \nfalse \n```", "```py\njulia> x < 5 || \"greater than 5\"\n\"greater than 5\"\n```", "```py\njulia> x > 5 || \"less than 5\" \ntrue \n```", "```py\njulia> x > 15 || message = \"That's a lot\" \n```", "```py\njulia> x > 15 || (message = \"That's a lot\") \n\"That's a lot\" \n```", "```py\nusing HTTP, Gumbo \n\nconst PAGE_URL = \"https://en.wikipedia.org/wiki/Julia_(programming_language)\" \nconst LINKS = String[] \n\nfunction fetchpage(url) \n  response = HTTP.get(url) \n  if response.status == 200 && parse(Int, Dict(response.headers)[\"Content-Length\"]) > 0 \n    String(response.body) \n  else \n    \"\" \n  end \nend \n```", "```py\ncontent = fetchpage(PAGE_URL)  \n```", "```py\nif ! isempty(content) \n  dom = Gumbo.parsehtml(content) \n  extractlinks(dom.root) \nend\n```", "```py\nfunction extractlinks(elem) \n  if  isa(elem, HTMLElement) &&  \n      tag(elem) == :a && in(\"href\", collect(keys(attrs(elem)))) \n        url = getattr(elem, \"href\") \n        startswith(url, \"/wiki/\") && push!(LINKS, url) \n  end \n\n  for child in children(elem) \n    extractlinks(child) \n  end \nend \n```", "```py\ndisplay(unique(LINKS))  \n```", "```py\n $ julia webcrawler.jl \n440-element Array{String,1}: \n \"/wiki/Programming_paradigm\" \n \"/wiki/Multi-paradigm_programming_language\" \n \"/wiki/Multiple_dispatch\" \n \"/wiki/Object-oriented_programming\" \n \"/wiki/Procedural_programming\" \n# ... output truncated ... \n```", "```py\nstartswith(url, \"/wiki/\") && push!(LINKS, url)\n```", "```py\nstartswith(url, \"/wiki/\") && ! occursin(\":\", url) && push!(LINKS, url) \n```", "```py\nusing HTTP, Gumbo \n\nconst PAGE_URL = \"https://en.wikipedia.org/wiki/Julia_(programming_language)\" \nconst LINKS = String[] \n\nfunction fetchpage(url) \n  response = HTTP.get(url) \n  if response.status == 200 && parse(Int, Dict(response.headers)[\"Content-Length\"]) > 0 \n    String(response.body) \n  else \n    \"\" \n  end \nend \n\nfunction extractlinks(elem) \n  if  isa(elem, HTMLElement) && tag(elem) == :a && in(\"href\", collect(keys(attrs(elem)))) \n        url = getattr(elem, \"href\") \n        startswith(url, \"/wiki/\") && ! occursin(\":\", url) && push!(LINKS, url) \n  end \n\n  for child in children(elem) \n    extractlinks(child) \n  end \nend \n\ncontent = fetchpage(PAGE_URL) \n\nif ! isempty(content) \n  dom = Gumbo.parsehtml(content)\n  extractlinks(dom.root) \nend\n\ndisplay(unique(LINKS)) \n```"]