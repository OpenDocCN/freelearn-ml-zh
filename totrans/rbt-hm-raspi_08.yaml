- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sensing Distances to Detect Objects with Pico
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our robot is starting to move around independently. We spent the last chapter
    preparing mount points to add sensors, including distance sensors. We can use
    these sensors to detect how far objects are from the robot, and by adding more
    than one, we can see which direction is closest. This sense will allow the robot
    to respond to the real world and drive around a room without much manual control.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn more about these sensors and their limitations.
    Then, we will attach the sensors to the robot and learn more about the communication
    protocol used to talk to them. Next, we will wire the sensors into Raspberry Pi
    Pico and get data. Finally, we will tie multiple sensors together with motor control
    to make the robot avoid obstacles while driving.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How distance sensing works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soldering headers and attaching them to the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to I2C communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating with a single distance sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting two distance sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a wall avoider with Raspberry Pi Pico
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The robot build from previous chapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x Pimoroni VL53L1X distance sensor modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x five-way single row 2.54-mm (included with the modules)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 x male-to-female jump wires with a 2.54-mm DuPont connector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x M2 nuts and M2 x 6-mm bolts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A suitable screwdriver for driving the bolts, and a spanner for holding the
    nuts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A soldering station with a soldering iron, solder, tip-cleaning brass, and soldering
    stand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flat work area with good lighting, free of interruptions or being nudged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code from previous chapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Raspberry Pi Pico code editor such as Mu or Thonny
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB micro cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-08](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-08).
  prefs: []
  type: TYPE_NORMAL
- en: How distance sensing works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into connecting and programming distance sensors, we should examine
    how they operate. [*Chapter 7*](B18001_07.xhtml#_idTextAnchor139), *Planning and
    Shopping for More Devices*, evaluated options and chose optical (light-based)
    distance sensors. We will be focusing on this type for the remainder of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many distance sensors operate using a principle known as **time of flight**.
    The following diagram demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Optical distance sensor operation ](img/Figure_8.01_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Optical distance sensor operation
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows pictures of robots with sensors and the returned
    light. On the top left, a single beam is emitted (shown as a cone), hits an object,
    and its reflection (shown as a dashed line) hits the sensor (the blue box), which
    detects it. The time between emitting the beam and receiving the response is the
    time of flight used to calculate the distance. At the top right of the diagram,
    both sensors are active. However, the left sensor detects a closer object in its
    beam, returning a lower value than the right sensor, which only detects the wall
    behind the object.
  prefs: []
  type: TYPE_NORMAL
- en: For most materials, the light beams make a diffuse reflection in all directions,
    as the bottom-left part of the diagram shows, and these time-of-flight sensors
    will detect their return. However, like the mirror shown in the bottom right of
    the diagram, some materials do not diffuse their reflected light and reflect away
    at the incident angle. Therefore, these objects may not be detected or will confuse
    the system. It may even detect objects reflected in a mirror as behind the mirror.
  prefs: []
  type: TYPE_NORMAL
- en: Note that these sensors have a slight instability in their readings, so they
    will take several readings and combine them to produce a more accurate reading.
    The sensors use a timing budget to take several readings. The VL53L1X device does
    this sampling and averaging.
  prefs: []
  type: TYPE_NORMAL
- en: Ambient light conditions can affect these sensors, with very bright light potentially
    washing out the beam. However, these work in most conditions, losing accuracy
    and a little distance but not becoming unusable. In our context, a robot mainly
    needs to detect an oncoming obstacle, so a loss of accuracy is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: We now understand how the sensors operate. In the next section, let’s attach
    them to the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Soldering headers and attaching them to the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can start to use or wire the sensors, we will need to solder headers
    onto them and then bolt them so they face forward on the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Soldering headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I recommend using a spare breadboard for soldering these, as you did with Raspberry
    Pi Pico and the motor controller earlier in [*Chapter 4*](B18001_04.xhtml#_idTextAnchor080),
    *Building a Robot around Pico*. The following photo shows me soldering them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Soldering the distance sensor headers ](img/Figure_8.02_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Soldering the distance sensor headers
  prefs: []
  type: TYPE_NORMAL
- en: The photo on the left of the preceding figure shows the sensors, the headers,
    and a breadboard to aid soldering. Place the headers long pins in the breadboard
    holes and the sensors on top. Pimoroni designed these sensor modules to hold the
    board on the header for easy soldering.
  prefs: []
  type: TYPE_NORMAL
- en: In the right photo, one sensor has had the header soldered in, and I am soldering
    the other. The headers should be facing back from the sensor so that the wiring
    will not be in the sensor beam.
  prefs: []
  type: TYPE_NORMAL
- en: With the headers soldered, you are ready to fit the sensors onto the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting the sensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We put a lot of groundwork into mounting the sensors in previous chapters and
    created brackets to mount them onto. The following photo shows these sensors bolted
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Optical distance sensors mounted ](img/Figure_8.03_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Optical distance sensors mounted
  prefs: []
  type: TYPE_NORMAL
- en: On the left of the preceding photo are the robot’s front, the sensors, and the
    M2 nuts and bolts. We push the sensor’s headers through the slot and bolt them
    in place. Note that there might be a slight tightness around the slot. If so,
    file the header space up and out a little to accommodate this. Wipe or blow away
    any dust after filing. The right shows the sensors bolted onto the front of the
    robot.
  prefs: []
  type: TYPE_NORMAL
- en: We will wire these sensors in via I2C. But, first, let’s take a closer look
    at how I2C is used to talk to sensors like this.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to I2C communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You encountered I2C communication in earlier chapters. [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015),
    discussed how I2C is a data bus that carries address information, allowing a primary
    device such as Raspberry Pi Pico to reach multiple devices on a single bus. We
    learned then that Raspberry Pi Pico has two hardware I2C buses. **I2C** (or **I**2**C**)
    is an acronym for **Inter-Integrated Circuit**.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B18001_07.xhtml#_idTextAnchor139), *Planning and Shopping for
    More Devices*, we saw how we would be using I2C devices both for VL53L1X distance
    sensors along with an IMU.
  prefs: []
  type: TYPE_NORMAL
- en: 'How exactly does this bus work? [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015),
    also mentioned that I2C has two wires – a **Serial Clock** line (**SCL**) and
    a **Serial Data** line (**SDA**). The following picture shows how devices send
    signals through them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – I2C signals on the wire ](img/Figure_8.04_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – I2C signals on the wire
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows two graphs representing I2C signals. The horizontal
    axis is time, and the vertical axis when high is logic one, with low being logic
    zero. As shown in the top diagram, the clock produces a stream of pulses, a square
    wave. The accompanying data line sends data synchronized with the clock pulses.
    This clock means that devices on the bus are synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: The lines are usually held high (logic high) and pulled down when a device wishes
    to communicate. Devices leave the line high when they have stopped communicating
    so another can control the bus. In most cases, the central controller will send
    a request to a device, and the device will respond.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015), devices on
    an I2C bus have an address. However, these VL53L1X devices both have the same
    addresses. Luckily, there are two I2C buses we can use on Raspberry Pi Pico.
  prefs: []
  type: TYPE_NORMAL
- en: The good thing is that we don’t need to control much of this manually. CircuitPython
    has a `busio` (bus input-output) library for handling I/O operations on a data
    bus, which we’ll use to control these devices.
  prefs: []
  type: TYPE_NORMAL
- en: We need to wire both SDA and SCL for each sensor and then write code connecting
    them. In the next section, we will discuss how to wire and talk to a single sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with a single distance sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each distance sensor requires only four wires; however, we will also improve
    the power system. We will then get into the code needed to read data from a system.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the distance sensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start our wiring by looking at a block diagram of our robot, as we saw previously
    in [*Chapter 7*](B18001_07.xhtml#_idTextAnchor139). Look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The robot block diagram with distance sensors ](img/Figure_8.05_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – The robot block diagram with distance sensors
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the robot block diagram with the additional VL53L1x
    distance sensors connected via I2C to Raspberry Pi Pico. The new parts have a
    thick double outline.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the schematic to get into the details of the connections, as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – The schematic with distance sensors ](img/Figure_8.06_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – The schematic with distance sensors
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, I’ve shown a close-up schematic of the distance sensors
    connected to Raspberry Pi Pico. We connect a sensor to each I2C bus, along with
    3v3 power and ground connections.
  prefs: []
  type: TYPE_NORMAL
- en: The right sensor has its SDA connected to `GPIO0` and its SCL connected to `GPIO1`.
    The left sensor connects SDA to `GPIO2` and SCL to `GPIO3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following photo shows the sensor wiring:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Distance sensors wired into the robot ](img/Figure_8.07_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Distance sensors wired into the robot
  prefs: []
  type: TYPE_NORMAL
- en: The preceding photo shows the robot with the sensors wired in using male-to-female
    jumper wires. Remember that you are not connecting the `INT` pin from the sensor
    to anything, so expect a gap here. Also, double-check power and ground connections,
    as reversing these may damage the device. It is also a common troubleshooting
    problem with I2C to have accidentally swapped SDA and SCL lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the wiring is complete, please carefully remove the protective cover from
    the sensor, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Removing the protective tape ](img/Figure_8.08_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Removing the protective tape
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding photo shows, if your sensors still have protective cover tape,
    carefully use a fingernail or tweezers to remove this cover before use. After
    removing this, take care not to touch the optical parts of the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: With this wired in, let’s look at how the sensor operates in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: VL53LX theory of operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These sensors have a particular operation cycle. We can use this as a guide
    for writing our code. The following diagram shows the states of the VL53L1X:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – VL53L1X operating states ](img/Figure_8.09_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – VL53L1X operating states
  prefs: []
  type: TYPE_NORMAL
- en: The preceding state diagram is a simplified view of the states of this device.
    The nodes are the states, and the lines between them are events/signals that cause
    the state to change. First, the sensor starts on the left in an idle mode. This
    mode saves power until we want to measure distances. Then, the host (Pico) sends
    a start-ranging signal, and the device enters ranging mode, where it takes active
    measurements. Next, the device enters a data-ready state when it has taken enough
    measurements, as set by the timing budget. In this state, the host can read the
    distance measured.
  prefs: []
  type: TYPE_NORMAL
- en: However, the device will not make fresh measurements until the host sends a
    clear interrupt signal, putting it back in the ranging state.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when we no longer need ranging, the host should send the stop-ranging
    signal, which puts the device back into an idle state and uses less power.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to account for these state changes in our code, which we will cover
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a single distance sensor in CircuitPython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When reading a sensor, we will use the Adafruit VL53L1X library. Copy `adafruit_vl53l1x.mpy`
    from the Adafruit CircuitPython library into the `lib` folder on the `CIRCUITPY`
    volume. We can also write code inspired by their documentation examples. When
    communicating with any new device, using the example code for the related library
    is always a good start. We will adapt it a little for Raspberry Pi Pico.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start the code in the `read_1_sensor.py` file with imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We’ve two new imports here. Alongside the vl53l1x library, the `busio` library
    uses Pico pins to form data buses such as `I2C`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to set up the `I2C` bus and device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This first line forms the `I2C` bus using GP0 and GP1 pins, corresponding with
    the left sensor. Pico is a little fussy about which pins you can use for the SDA
    and SCL lines of an `I2C` bus. We then create the VL53L1X device with this `I2C`
    bus. In the next section of code, we send some settings to the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The device has multiple distance modes; distance mode 1 is short-range – for
    close objects. We set a timing budget of 100 milliseconds, controlling how long
    the sensor is allowed to take for measuring. It limits the maximum distance and
    the number of measurements used to smooth data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now moved the device from the idle state into the ranging state. We
    can now wait for the measurements to be ready. We can now write the code for the
    `main` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This loop starts by checking whether the device has data ready to read. When
    it has `data_ready`, we can read data with `vl53.distance` and print it. This
    distance is in centimeters.
  prefs: []
  type: TYPE_NORMAL
- en: After reading the data, we need to send a `clear_interrupt` signal, so the sensor
    goes back into its ranging mode for a new reading.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether there is data, the system will wait 50 milliseconds before
    looping around and checking again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upload this file to Pico and update `code.py` to import `read_1_sensor.py`.
    Then, when you run it and connect the REPL, you should see output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let’s check a few things to ensure everything’s all working before we carry
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If this example code doesn’t work, the following troubleshooting steps will
    help:'
  prefs: []
  type: TYPE_NORMAL
- en: If you receive the `No pull up found on SDA or SCL; check your wiring` warning,
    this indicates the wiring may be incorrect or that wires may be loose. Power down
    and check the wiring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `No I2C device at address: 29` warning likely means you have reversed SDA
    and SCL. Swap them and try again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There must be no heat in any part of the circuit including the wires, the batteries,
    the sensor, or Pico – this will cause damage, and should be powered down then
    the wiring checked carefully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, sensors can get stuck between test runs, resulting in slow or erratic
    results or sensors showing no errors but never having data ready. I advise powering
    the whole robot down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try adding lines such `print("i2c set up")` between stages to see where the
    problem is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you see `unsupported operation` or `unknown distance mode`, check the power
    wiring to ensure each sensor is well connected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that powering down means turning off battery power (if you’ve turned that
    on) and unplugging the computer. Never leave the computer plugged in during rewiring.
  prefs: []
  type: TYPE_NORMAL
- en: We should have data being read reliably from a single sensor. Our robot has
    two sensors, though, so let’s read data from both in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting two distance sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have wired in two sensors, each on a separate set of pins. Create the `read_2_sensors.py`
    file. The imports look identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we come to set up the sensors, we first need to set up two `I2C` buses
    on the different pins and then use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also apply the same configuration settings for both sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The main loop starts in the same way, with both sensors going into ranging
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And in this case, we will check for ready data from both sensors before printing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When uploaded and run on Pico, this code will now output both sensors’ data,
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’ll troubleshoot any problems here before we use two sensors for smarter behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding a second sensor can still cause odd behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the wiring considerations in the single sensor apply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have used the same I2C bus twice in code, you will get some odd behavior
    or the same reading from both sensors. Check the code for this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have data from two sensors, and in the next section, we’ll use this data
    to make the robot avoid objects.
  prefs: []
  type: TYPE_NORMAL
- en: Building a wall avoider with Raspberry Pi Pico
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two distance sensors and independent motor control with some code are the ingredients
    needed to avoid obstacles. Let’s start by putting the distance sensors in the
    shared robot library.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the robot library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like we have with other aspects of the robot, we’ll start by building the distance
    sensors set up in the `robot.py` file. At the top of this file, the imports now
    include `busio` and `adafruit_vl53l1x` libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then set up our left and right distance sensors. Insert the following
    below the encoder setup and above the `stop` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Save this file and be sure to upload it to the `CIRCUITPY` volume.
  prefs: []
  type: TYPE_NORMAL
- en: We will use `robot.py` in the avoider code. We must next consider how avoiding
    behaviors operate.
  prefs: []
  type: TYPE_NORMAL
- en: Wall-avoiding theory of operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to consider data from both sensors to avoid walls. The following diagram
    shows how we will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Avoiding walls with two sensors ](img/Figure_8.10_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Avoiding walls with two sensors
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, a sketched robot is facing a wall. It has sensed the
    wall, but the object is closer to the left sensor than the right; dashed arrows
    show reflections coming from the object. That means the robot should turn right
    to avoid this object, shown by the curved arrow to the robot’s left. We will make
    the turn by reversing the right motor until it is clear of the obstacle.
  prefs: []
  type: TYPE_NORMAL
- en: There is a special edge case where the two sensors detect the wall as equally
    close. To ensure the robot decides to avoid the flat obstacle, we will slightly
    bias (weight one side) by checking one sensor first and making a turn based on
    that.
  prefs: []
  type: TYPE_NORMAL
- en: We have all the parts we need. So, let’s start writing this code.
  prefs: []
  type: TYPE_NORMAL
- en: Distance sensor wall avoider code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code for this uses the distance sensors from the robot library. Put this
    in `avoid_walls.py`. Let’s start with familiar imports and by setting the sensor
    config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll leave sensors on the default timing budget. We then have some configurations
    for our avoider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `too_close_cm` variable has a threshold for when the robot should turn
    to avoid a wall. We can set the overall robot speed for this behavior in the `speed`
    variable. We can tune these two variables to ensure the robot avoids a wall in
    time. Let’s start the sensors ranging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to start the robot moving; however, we want to ensure that the
    robot stops moving and stops the sensors ranging if there are any problems, so
    we wrap the main loop in `try`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A `finally` statement to accompany that `try` will come below the main loop.
    Next, we check whether there is sensor data ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We store the read distances so that we can use them throughout the handling.
    Note that while `robot.left_distance.distance` looks like a variable, it is a
    property that actively reads the sensor when we use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have two values, we should check if one side is too close. Note that
    a timeout will result in a `0` value, so we should check values are above this
    too. By favoring a side, we slightly bias the robot to that side, and this should
    stop the robot from being *indecisive* if both sensors detect a close obstacle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We check whether the distance on the right sensor is closer than the threshold.
    If so, we print a line of debug, showing that we’ve detected an obstacle and the
    two sensor readings. We then set the left motor to go backward, which will cause
    the robot to swerve left, away from the obstacle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now handle what happens otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If we’ve not turned left, we ensure the left motor is going forward. We then
    check the left distance sensor, and if this is too close, we turn right. Finally,
    we set the right motor forward, so both motors will be going forward if it detects
    nothing too close.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the left distance check in the `else` means that the robot will not
    set both motors backward and will favor turning left in front of an obstacle directly
    in front.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then need to finish the loop by clearing the interrupts (so that the sensors
    are ranging again), and we leave a little time for them to sense again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to handle any errors that happened. If you recall, we wrapped
    this code in a `try` block. The `finally` block stops and cleans everything up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do here is to stop the motors. If anything goes wrong, such
    as errors from sensors or the code, we don’t want the robot to drive into a wall.
    We then clear the sensor interrupts and stop the sensors, putting them back into
    idle mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is complete, and you can send it to the robot along with the updated
    `robot.py`. Keep the battery power turned off initially and test that it detects
    obstacles. You should see output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve seen it working and detecting, you can turn the battery power on,
    which will enable the motors and let drive along – either using a long USB cable
    or independently if it’s working well. Let’s check whether we have any problems
    with some troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps should get you up and running if you have any problems:'
  prefs: []
  type: TYPE_NORMAL
- en: If the robot complains about importing modules, ensure you have uploaded the
    code and libraries for this chapter and previous ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the robot is getting too close before turning, try increasing the `too_close`
    variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With any behavior using motors, ensure the batteries are fresh. Low power can
    cause stalling motors and malfunctioning sensors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sensors will not detect obstacles that are above or below them. This limitation
    means the robot will drive into and get stuck on low obstacles or under high ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your robot now avoids walls and objects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about distance sensors. We looked at how the sensors
    operate and how to attach them.
  prefs: []
  type: TYPE_NORMAL
- en: We learned more about the `I2C` bus and then saw how to electrically connect
    these VL53L1X distance sensors.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at the operating modes of the VL53L1X sensor and wrote code to
    get readings from one. Finally, we finished with a behavior to avoid walls using
    this sensor.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will gain remote control of our robot by adding Bluetooth.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use these exercises to practice more of the concepts learned in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Could you write code to follow an object at a fixed distance? If it’s further
    away, could you drive it forward, and if it’s too close, back it up a little?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try different materials in front of the robot, such as glass, black fabric,
    thin paper, and thick paper. Observe which are detected and how they affect the
    distance detected. For example, what happens if you aim the robot at a mirror?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try observing the distance measurements in different light conditions, such
    as room light, darkness, and full sunlight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following sources of additional reading can deepen your understanding of
    these sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/adafruit/Adafruit_CircuitPython_VL53L1X](https://github.com/adafruit/Adafruit_CircuitPython_VL53L1X)
    has the library and sample code for driving a device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.ti.com/lit/an/sbau305b/sbau305b.pdf](https://www.ti.com/lit/an/sbau305b/sbau305b.pdf)
    is a datasheet for a different brand of optical sensors. However, it has excellent
    information on reflectance and how materials affect distance sensing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.st.com/en/imaging-and-photonics-solutions/vl53l1x.html#documentation](https://www.st.com/en/imaging-and-photonics-solutions/vl53l1x.html#documentation)
    contains the complete product documentation. Of particular interest are the product
    specifications and API user manual.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an alternative technique using ultrasonic distance sensors, refer to *Learn
    Robotics Programming – Second Edition* by *Danny Staple*.
  prefs: []
  type: TYPE_NORMAL
