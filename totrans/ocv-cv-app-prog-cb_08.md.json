["```py\n   // Detect Harris Corners\n   cv::Mat cornerStrength;\n   cv::cornerHarris(image,      // input image\n                cornerStrength, // image of cornerness\n                3,              // neighborhood size\n                3,              // aperture size\n                0.01);          // Harris parameter\n\n   // threshold the corner strengths\n   cv::Mat harrisCorners;\n   double threshold= 0.0001; \n   cv::threshold(cornerStrength,harrisCorners,\n                 threshold,255,cv::THRESH_BINARY);\n```", "```py\nclass HarrisDetector {\n\n  private:\n\n     // 32-bit float image of corner strength\n     cv::Mat cornerStrength;\n     // 32-bit float image of thresholded corners\n     cv::Mat cornerTh;\n     // image of local maxima (internal)\n     cv::Mat localMax;\n     // size of neighborhood for derivatives smoothing\n     int neighbourhood; \n     // aperture for gradient computation\n     int aperture; \n     // Harris parameter\n     double k;\n     // maximum strength for threshold computation\n     double maxStrength;\n     // calculated threshold (internal)\n     double threshold;\n     // size of neighborhood for non-max suppression\n     int nonMaxSize; \n     // kernel for non-max suppression\n     cv::Mat kernel;\n\n  public:\n\n     HarrisDetector() : neighbourhood(3), aperture(3), \n                        k(0.01), maxStrength(0.0), \n                        threshold(0.01), nonMaxSize(3) {\n\n        // create kernel used in non-maxima suppression\n        setLocalMaxWindowSize(nonMaxSize);\n     }\n```", "```py\n     // Compute Harris corners\n     void detect(const cv::Mat& image) {\n\n        // Harris computation\n        cv::cornerHarris(image,cornerStrength,\n                neighbourhood,// neighborhood size\n                aperture,     // aperture size\n                k);           // Harris parameter\n\n        // internal threshold computation \n        cv::minMaxLoc(cornerStrength,\n             0&maxStrength);\n\n        // local maxima detection\n        cv::Mat dilated;  // temporary image\n        cv::dilate(cornerStrength,dilated,cv::Mat());\n        cv::compare(cornerStrength,dilated,\n                    localMax,cv::CMP_EQ);\n     }\n```", "```py\n     // Get the corner map from the computed Harris values\n     cv::Mat getCornerMap(double qualityLevel) {\n\n        cv::Mat cornerMap;\n\n        // thresholding the corner strength\n        threshold= qualityLevel*maxStrength;\n        cv::threshold(cornerStrength,cornerTh,\n                      threshold,255,cv::THRESH_BINARY);\n\n        // convert to 8-bit image\n        cornerTh.convertTo(cornerMap,CV_8U);\n\n        // non-maxima suppression\n        cv::bitwise_and(cornerMap,localMax,cornerMap);\n\n        return cornerMap;\n     }\n```", "```py\n     // Get the feature points from the computed Harris values\n     void getCorners(std::vector<cv::Point> &points, \n                     double qualityLevel) {\n\n        // Get the corner map\n        cv::Mat cornerMap= getCornerMap(qualityLevel);\n        // Get the corners\n        getCorners(points, cornerMap);\n     }\n\n     // Get the feature points from the computed corner map\n     void getCorners(std::vector<cv::Point> &points, \n                     const cv::Mat& cornerMap) {\n\n        // Iterate over the pixels to obtain all features\n        for( int y = 0; y < cornerMap.rows; y++ ) {\n\n           const uchar* rowPtr = cornerMap.ptr<uchar>(y);\n\n           for( int x = 0; x < cornerMap.cols; x++ ) {\n\n              // if it is a feature point\n              if (rowPtr[x]) {\n\n                 points.push_back(cv::Point(x,y));\n              }\n           } \n        }\n     }\n```", "```py\n     // Draw circles at feature point locations on an image\n     void drawOnImage(cv::Mat &image, \n        const std::vector<cv::Point> &points, \n        cv::Scalar color= cv::Scalar(255,255,255), \n        int radius=3, int thickness=1) {\n        std::vector<cv::Point>::const_iterator it= \n                                       points.begin();\n\n        // for all corners\n        while (it!=points.end()) {\n\n           // draw a circle at each corner location\n           cv::circle(image,*it,radius,color,thickness);\n           ++it;\n        }\n     }\n```", "```py\n   // Create Harris detector instance\n   HarrisDetector harris;\n   // Compute Harris values\n   harris.detect(image);\n   // Detect Harris corners\n   std::vector<cv::Point> pts;\n   harris.getCorners(pts,0.02);\n   // Draw Harris corners\n   harris.drawOnImage(image,pts);\n```", "```py\n        cv::dilate(cornerStrength,dilated,cv::Mat());\n```", "```py\n        cv::compare(cornerStrength,dilated, \n                    localMax,cv::CMP_EQ);\n```", "```py\n   // Compute good features to track\n   std::vector<cv::Point2f> corners;\n   cv::goodFeaturesToTrack(image,  // input image\n      corners, // corner image\n      500,     // maximum number of corners to be returned\n      0.01,    // quality level\n      10);     // minimum allowed distance between points\n```", "```py\n   void detect( const Mat& image, vector<KeyPoint>& keypoints,\n                const Mat& mask=Mat() ) const;\n\n   void detect( const vector<Mat>& images,\n                vector<vector<KeyPoint> >& keypoints,\n                const vector<Mat>& masks=\n                                   vector<Mat>() ) const;\n```", "```py\n   // vector of keypoints\n   std::vector<cv::KeyPoint> keypoints;\n   // Construction of the Good Feature to Track detector \n  cv::Ptr<cv::FeatureDetector> gftt= \n     new cv::GoodFeaturesToTrackDetector(\n     500,  // maximum number of corners to be returned\n     0.01, // quality level\n     10);  // minimum allowed distance between points\n  // point detection using FeatureDetector method\n  gftt->detect(image,keypoints);\n```", "```py\n   // vector of keypoints\n   std::vector<cv::KeyPoint> keypoints;\n   // Construction of the Fast feature detector object \n   cv::Ptr<cv::FeatureDetector> fast= \n   new cv::FastFeatureDetector(\n     40); // threshold for detection\n   // feature point detection \n   fast->detect(image,keypoints);\n```", "```py\n   cv::drawKeypoints(image,    // original image\n      keypoints,               // vector of keypoints\n      image,                   // the output image\n      cv::Scalar(255,255,255), // keypoint color\n      cv::DrawMatchesFlags::DRAW_OVER_OUTIMG); //drawing flag\n```", "```py\n  cv::FAST(image,     // input image \n         keypoints,   // output vector of keypoints\n         40,          // threshold\n         false);      // non-max suppression? (or not)\n```", "```py\n  cv::DynamicAdaptedFeatureDetector fastD(\n    new cv::FastAdjuster(40), // the feature detector\n    150,   // min number of features\n    200,   // max number of features\n    50);   // max number of iterations\n  fastD.detect(image,keypoints); // detect points\n```", "```py\n  cv::GridAdaptedFeatureDetector fastG(\n    new cv::FastFeatureDetector(10), // the feature detector\n    1200,  // max total number of keypoints\n    5,     // number of rows in grid\n    2);    // number of cols in grid\n  fastG.detect(image,keypoints);\n```", "```py\n  cv::PyramidAdaptedFeatureDetector fastP(\n    new cv::FastFeatureDetector(60), // the feature detector\n    3);    // number of levels in the pyramid\n  fastP.detect(image,keypoints);\n```", "```py\n  // Construct the SURF feature detector object\n  cv::Ptr<cv::FeatureDetector> detector = new cv::SURF(2000.); // threshold\n  // Detect the SURF features\n  detector->detect(image,keypoints);\n```", "```py\n   // Draw the keypoints with scale and orientation information\n   cv::drawKeypoints(image,      // original image\n      keypoints,                 // vector of keypoints\n      featureImage,              // the resulting image\n      cv::Scalar(255,255,255),   // color of the points\n      cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS); //flag\n```", "```py\n  // Construct the SIFT feature detector object\n  detector = new cv::SIFT();\n  // Detect the SIFT features\n  detector->detect(image,keypoints);\n```", "```py\n  // Construct the BRISK feature detector object\n  detector = new cv::BRISK();\n  // Detect the BRISK features\n  detector->detect(image,keypoints);\n```", "```py\n  // Construct another BRISK feature detector object\n  detector = new cv::BRISK(\n    20,  // threshold for FAST points to be accepted\n    5);  // number of octaves\n```", "```py\n  // Construct the ORB feature detector object\n  detector = new cv::ORB(200, // total number of keypoints\n                        1.2, // scale factor between layers\n                   8);  // number of layers in pyramid\n  // Detect the ORB features\n  detector->detect(image,keypoints);\n```"]