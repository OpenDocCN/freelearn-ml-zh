- en: <st c="0">9</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Extracting Features from Relational Data with Featuretools</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="60">In previous chapters, we worked with data organized in rows and columns,
    where the columns are the variables, the rows are the observations, and each observation
    is independent.</st> <st c="239">In this chapter, we will focus on creating features
    from relational datasets.</st> <st c="317">In relational datasets, data is structured
    across various tables, which can be joined together via unique identifiers.</st>
    <st c="436">These unique identifiers indicate relationships that exist between
    the</st> <st c="507">different tables.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="524">A classic example of relational data is that held by retail companies.</st>
    <st c="596">One table contains information about customers, such as names and
    addresses.</st> <st c="673">A second table has information about the purchases
    made by the customers, such as the type and number of items bought per purchase.</st>
    <st c="805">A third table contains information about the customers’ interactions
    with the company’s website, variables such as session duration, the mobile device
    used, and pages visited.</st> <st c="981">Customers, purchases, and sessions are
    identified with unique identifiers.</st> <st c="1056">These unique identifiers
    allow us to put these tables together, and in this way, we can get information
    about customers’ purchases</st> <st c="1187">or sessions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1199">If we want to know more about the types of customers we have (that
    is, customer segmentation) or make predictions about whether they would buy a
    product, we can create features that aggregate or summarize information across
    different tables at the customer level.</st> <st c="1464">For example, we can
    create features that capture the maximum amount spent by a customer on a purchase,
    the number of purchases they have made, the time between sessions, or the average
    session duration.</st> <st c="1667">The number of features we can create and the
    various ways we can aggregate data across tables are abundant.</st> <st c="1775">In
    this chapter, we will discuss some common ways of creating aggregated views of
    relational data utilizing the</st> `<st c="1887">featuretools</st>` <st c="1899">Python
    library.</st> <st c="1916">We will begin by setting up various data tables and
    their relationships and automatically creating features, and next, we will follow
    up with more detail on the different features we</st> <st c="2099">can create.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2110">In this chapter, we will cover the</st> <st c="2146">following
    recipes:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2164">Setting up an entity set and creating</st> <st c="2203">features
    automatically</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2225">Creating features with general and</st> <st c="2261">cumulative
    operations</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2282">Combining</st> <st c="2293">numerical features</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2311">Extracting features from date</st> <st c="2342">and time</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2350">Extracting features</st> <st c="2371">from text</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2380">Creating features with</st> <st c="2404">aggregation primitives</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2426">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2449">In this chapter, we will use</st> `<st c="2479">pandas</st>`<st
    c="2485">,</st> `<st c="2487">matplotlib</st>`<st c="2497">, and</st> `<st c="2503">featuretools</st>`
    <st c="2515">open source Python libraries.</st> <st c="2546">You can install</st>
    `<st c="2562">featuretools</st>` <st c="2574">with</st> `<st c="2580">pip</st>`<st
    c="2583">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="2610">Additionally, you can do so</st> <st c="2639">with</st> `<st c="2644">conda</st>`<st
    c="2649">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="2693">These commands install the basic</st> `<st c="2727">featuretools</st>`
    <st c="2739">functionality, but we can install add-ons for</st> <st c="2786">creating
    features with</st> `<st c="2857">dask</st>` <st c="2861">as the backend instead
    of</st> `<st c="2888">pandas</st>`<st c="2894">. For more information on how to
    install</st> `<st c="2935">featuretools</st>` <st c="2947">add-ons, including</st>
    `<st c="2967">graphviz</st>`<st c="2975">, check out their documentation</st>
    <st c="3007">here:</st> [<st c="3013">https://docs.featuretools.com/en/v0.16.0/getting_started/install.html</st>](https://docs.featuretools.com/en/v0.16.0/getting_started/install.html)<st
    c="3082">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3083">We</st> <st c="3087">wil</st><st c="3090">l work with the</st>
    *<st c="3107">Online Retail II</st>* <st c="3123">dataset from the UCI Machine
    Learning Repository, which is available at</st> [<st c="3196">https://archive.ics.uci.edu/ml/datasets/Online+Retail+II</st>](https://archive.ics.uci.edu/ml/datasets/Online+Retail+II)
    <st c="3252">and licensed under a</st> **<st c="3274">Creative Commons Attribution
    4.0 International</st>** <st c="3320">(</st>**<st c="3322">CC BY 4.0</st>**<st
    c="3331">) license:</st> [<st c="3343">https://creativecommons.org/licenses/by/4.0/legalcode</st>](https://creativecommons.org/licenses/by/4.0/legalcode)<st
    c="3396">. The corresponding citation for this data is provided here:</st> *<st
    c="3457">Chen, Daqing</st>* <st c="3469">(</st>*<st c="3471">2019</st>*<st c="3475">).</st>
    *<st c="3479">Online Retail II</st>*<st c="3495">.</st> *<st c="3497">UCI Machine
    Learning</st>* *<st c="3518">Repository</st>* <st c="3528">(</st>[<st c="3530">https://doi.org/10.24432/C5CG6D</st>](https://doi.org/10.24432/C5CG6D)<st
    c="3561">)</st><st c="3563">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3564">I downloaded and modified the data as shown in this</st> <st c="3617">notebook:</st>
    [<st c="3627">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/prepare-retail-dataset.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/prepare-retail-dataset.ipynb)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3768">You’ll find a copy of the modified dataset in the accompanying
    GitHub</st> <st c="3839">repository:</st> [<st c="3851">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/retail.csv</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/retail.csv)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3974">Setting up an entity set and creating features automatically</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="4035">Relationa</st><st c="4045">l datasets or databases contain data
    spread across multiple tables</st><st c="4112">, and the relationships</st> <st
    c="4136">between tables are dictated by a unique identifier</st> <st c="4187">that
    tells us how we can join those tables.</st> <st c="4231">To automate feature creation
    with</st> `<st c="4265">featuretools</st>`<st c="4277">, we first need to enter
    the different data tables and establish their relationships within what is called
    an</st> `<st c="4427">featuretools</st>` <st c="4439">how these tables are connected
    so that the library can automatically create features based on</st> <st c="4534">those
    relationships.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4554">We will w</st><st c="4564">ork with a dataset containing information
    about customers, invoices, and products.</st> <st c="4648">First, we will set
    up an entity set highlighting the relationsh</st><st c="4711">ips between these
    three items.</st> <st c="4743">This entity set will be the starting point for
    the remaining recipes in this chapter.</st> <st c="4829">Next, we will create
    features automatically by aggregating the data at the customer, invoice, and product
    levels, utilizing the default parameters</st> <st c="4976">from</st> `<st c="4981">featuretools</st>`<st
    c="4993">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4994">In this recipe, you will learn how to correctly set up an entity
    set and extract a bunch of features automatically for each entity.</st> <st c="5127">In
    the upcoming recipes, we will dig deeper into the different types of features
    that we can create</st> <st c="5227">with</st> `<st c="5232">featuretoo</st><st
    c="5242">ls</st>`<st c="5245">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5246">Getting ready</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="5260">In this recipe, we will use the</st> *<st c="5293">Online Retail
    II</st>* <st c="5309">dataset from the UCI Machine Learning Repository.</st> <st
    c="5360">In this table, there are customers, which are businesses that buy in
    bulk from the retail company.</st> <st c="5459">Customers are identified with
    a</st> `<st c="5491">customer_id</st>` <st c="5502">unique identifier.</st> <st
    c="5522">Each customer makes one or more purchases, which are flagged by an</st>
    `<st c="5589">invoice</st>` <st c="5596">unique identifier, containing the invoice
    number.</st> <st c="5647">In each invoice, there are one or more items that have
    been bought by the customer.</st> <st c="5731">Each item or product sold by the
    company is also identified with a unique</st> <st c="5805">stock code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5816">Thus, the data has the</st> <st c="5840">following relation</st><st
    c="5858">s:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Diagram showing the relationships in the data](img/B22396_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="5960">Figure 9.1 – Diagram showing the relationships in the data</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6018">Ea</st><st c="6021">ch customer made one or more purchases, identified
    by the invoice number.</st> <st c="6096">Each invoice contains one or more items,
    identifi</st><st c="6145">ed by the stock code.</st> <st c="6168">Each item can
    be bought by one or more customers and is therefore present in several invoices.</st>
    <st c="6263">With these relationships in mind, let’s proceed to</st> <st c="6314">the
    recip</st><st c="6323">e.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6326">How to do it...</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="6342">In this recipe, we will</st> <st c="6367">set up an entity set
    with the data, and then</st> <st c="6412">highlight the different relationships
    in the dataset.</st> <st c="6466">Finally, we will create features by aggregating
    information in the dataset at the customer, invoice, and</st> <st c="6571">product
    levels:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6586">Let’s import the</st> <st c="6604">required libraries:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="6716">Let’s load the retail dataset described in the</st> *<st c="6764">Getting
    ready</st>* <st c="6777">section and display its first</st> <st c="6808">five
    rows:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="6890">In the</st> <st c="6898">following screenshot, we see the unique
    identifiers</st> <st c="6950">for customers (</st>`<st c="6965">customer_id</st>`<st
    c="6977">) and invoices (</st>`<st c="6994">invoice</st>`<st c="7002">), and additional
    information about the</st> <st c="7042">items bought in each invoice, s</st><st
    c="7074">uch as the item’s code (</st>`<st c="7099">stock_code</st>`<st c="7110">),
    description, quantity, and unit price, as well as the date of</st> <st c="7176">the
    inv</st><st c="7183">oice:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Online Retail II dataset](img/B22396_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="7652">Figure 9.2 – Online Retail II dataset</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7689">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7694">Use</st> `<st c="7699">pandas</st>`<st c="7705">’</st> `<st c="7708">unique()</st>`
    <st c="7716">function</st> <st c="7726">to identify the number of unique items,
    customers, and invoices – for example, by</st> <st c="7808">executing</st> `<st
    c="7818">df["customer_id"].nunique()</st>`<st c="7845">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7846">Let’s initialize an entity set with an arbitrary name, such</st>
    <st c="7907">as</st> `<st c="7910">data</st>`<st c="7914">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="7945">Let’s add a DataFrame to the entity set; we give the DataFrame
    a name (</st>`<st c="8017">data</st>`<st c="8022">).</st> <st c="8026">We need
    to add a unique identifier for each row, which we call</st> `<st c="8089">rows</st>`<st
    c="8093">, and since we do not have a unique row identifier in this dataset, we
    will create it as an additional column by setting</st> `<st c="8214">make_index=True</st>`<st
    c="8229">. Finally, we indicate that</st> `<st c="8257">invoice_date</st>` <st
    c="8269">is of the</st> `<st c="8280">datetime</st>` <st c="8288">type and</st>
    `<st c="8298">customer_id</st>` <st c="8309">should be handled</st> <st c="8328">as</st>
    `<st c="8331">Categorical</st>`<st c="8342">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="8509">Ne</st><st c="8512">xt, we add</st> <st c="8524">the relationship
    between the original</st> `<st c="8562">data</st>` <st c="8566">DataFrame</st>
    <st c="8577">and</st> `<st c="8581">invoices</st>`<st c="8589">. To do this, we
    indicate the original or base DataFram</st><st c="8644">e, which we called</st>
    `<st c="8664">data</st>` <st c="8668">in</st> *<st c="8672">step 4</st>*<st c="8678">,
    we give the new DataFrame a name,</st> `<st c="8714">invoices</st>`<st c="8722">,
    we add the unique identifier for invoices, and we add the column containing</st>
    `<st c="8800">customer_id</st>` <st c="8811">to</st> <st c="8815">this DataFrame:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="8962">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8967">We copy the</st> `<st c="8980">customer_id</st>` <st c="8991">variable
    to the</st> `<st c="9008">invoices</st>` <st c="9016">data because we want to
    create a subsequent relationship between customers</st> <st c="9092">and invoices.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9105">Now, we add a second relationship, which is between customers and
    invoices.</st> <st c="9182">To do this, we indicate the base DataFrame, which
    we named</st> `<st c="9241">invoices</st>` <st c="9249">in</st> *<st c="9253">step
    5</st>*<st c="9259">, then we give the new DataFrame a name,</st> `<st c="9300">customers</st>`<st
    c="9309">, and add the unique</st> <st c="9330">customer identifier:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="9461">We can</st> <st c="9468">add a third rel</st><st c="9483">ationship
    between the original</st> <st c="9515">data and</st> <st c="9524">the products:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="9639">Let’s display the information in the</st> <st c="9677">entity set:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '<st c="9691">In the following output, we see that the entity set contains four
    DataFrames: the original data, the</st> `<st c="9793">invoices</st>` <st c="9801">DataFrame,
    the</st> `<st c="9817">customers</st>` <st c="9826">DataFrame, and the product
    or</st> `<st c="9857">items</st>` <st c="9862">DataFrame.</st> <st c="9874">The
    entity also contains the relationships between invoices or items with the original
    data, as well as between customers</st> <st c="9996">and invoices:</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: es["invoices"].head()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 9.3 – DataFrame with information at the invoice level](img/B22396_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="10830">Figure 9.3 – DataFrame with information at the invoice level</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10890">Let’s now display the</st> `<st c="10913">customers</st>` <st
    c="10922">DataFrame:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="10956">We can see in the following output that</st> `<st c="10997">featuretools</st>`
    <st c="11009">automatically created a DataFrame containing the customer’s unique
    identifier, followed by the date of the first invoice for</st> <st c="11135">this</st>
    <st c="11139">customer:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.4 – DataFrame with information at the customer level](img/B22396_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="11362">Figure 9.4 – DataFrame with information at the customer level</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11423">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11428">Go ahead and display the DataFrame containing the products by
    executing</st> `<st c="11501">es["items"].head()</st>`<st c="11519">. You can
    also evaluate the size of the different DataFrames using</st> `<st c="11586">pandas</st>`<st
    c="11592">’</st> `<st c="11595">shape</st>` <st c="11600">function.</st> <st c="11611">You
    will notice that the number of rows in each DataFrame coincides with the number
    of unique invoices, customers,</st> <st c="11726">and produc</st><st c="11736">ts.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11740">We can</st> <st c="11748">also display the re</st><st c="11767">lationships
    between these data</st> <st c="11799">tables</st> <st c="11806">as follows:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="11827">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11832">To visualize the data relationships, you need to have</st> `<st
    c="11887">graphviz</st>` <st c="11895">installed.</st> <st c="11907">If you don’t,
    follow the</st> <st c="11932">instructions in the</st> `<st c="11952">featuretools</st>`
    <st c="11964">documentation to install</st> <st c="11990">it:</st> [<st c="11994">https://featuretools.alteryx.com/en/stable/install.html#installing-graphviz</st>](https://featuretools.alteryx.com/en/stable/install.html#installing-graphviz)<st
    c="12069">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12070">In the following output, we can see the relational datasets and</st>
    <st c="12135">their re</st><st c="12143">lationships:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Relationships between the tables containing invoices, customers,
    and products](img/B22396_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="12733">Figure 9.5 – Relationships between the tables containing invoices,
    customers, and products</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12823">Af</st><st c="12826">ter entering</st> <st c="12840">the data
    and their relationships,</st> <st c="12873">we can start</st> <st c="12887">automatically
    creating features for each one of our new DataFrames – that is, customers, invoices,
    and products – using the default parameters</st> <st c="13030">from</st> `<st
    c="13035">featuretools</st>`<st c="13047">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13048">Let’s create</st> <st c="13062">features by aggregating the data
    at the customer level.</st> <st c="13118">To do this, we set up the</st> `<st
    c="13185">featuretools</st>`<st c="13197">, indicating</st> `<st c="13210">customers</st>`
    <st c="13219">as the target DataFrame.</st> <st c="13245">When creating features,
    we want to ignore the two columns with</st> <st c="13308">unique identifiers:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="13488">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13493">The command from</st> *<st c="13511">step 12</st>* <st c="13518">triggered
    the creation of 114 features with different aggregations of data at the customer
    level.</st> <st c="13617">The</st> `<st c="13621">feature_matrix</st>` <st c="13635">variable
    is a DataFrame with the feature values, and</st> `<st c="13689">feature_defs</st>`
    <st c="13701">is a list with the names of the new features.</st> <st c="13748">Go
    ahead and execute</st> `<st c="13769">feature_defs</st>` <st c="13781">or visit
    our accompanying GitHub repository (</st>[<st c="13827">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe1-Setting-up-an-entitity-set.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe1-Setting-up-an-entitity-set.ipynb)<st
    c="13981">) to check the names of the created features.</st> <st c="14028">You
    will find more details about these features in the</st> *<st c="14083">How it</st>*
    *<st c="14090">works…</st>* <st c="14096">section.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14105">For reasons</st> <st c="14118">of space, we can’t print out all
    the features</st> <st c="14164">in the</st> <st c="14171">book, so instead, let’s
    display the nam</st><st c="14210">es of five of the</st> <st c="14229">created
    features:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="14265">In the following output, we see 5 of the 114 features created</st>
    <st c="14328">by</st> `<st c="14331">featuretools</st>`<st c="14343">:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="14511">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14516">The</st> `<st c="14521">featuretools</st>` <st c="14533">library
    names the new features with the function used to create them, followed by the
    DataFrame that was used to perform the aggregation, followed by the aggregated
    variable name.</st> <st c="14714">Thus,</st> `<st c="14720">MIN(data.quantity)</st>`
    <st c="14738">is equivalent to</st> `<st c="14756">df.groupby(["customer_id"])["quantity"].min()</st>`<st
    c="14801">, if you are familiar with</st> `<st c="14828">pandas</st>`<st c="14834">.
    We will give more details in the</st> *<st c="14869">How it</st>* *<st c="14876">works…</st>*
    <st c="14882">secti</st><st c="14888">on.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14892">Let’s display the first five rows of the Dat</st><st c="14937">aFrame
    containing five of the</st> <st c="14968">created features:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="15037">In the</st> <st c="15045">following output, we can see the first
    five rows</st> <st c="15094">containing the values of the</st> <st c="15123">five</st>
    <st c="15128">new features:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.6 – DataFrame with five features created by aggregating the data
    at the customer level](img/B22396_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="15542">Figure 9.6 – DataFrame with five features created by aggregating
    the data at the customer level</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15637">Similarly, we can create features automatically by aggregating
    information at the</st> <st c="15720">invoice level:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="15882">The previous step returns 24 features – let’s display</st> <st
    c="15937">their names:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="15962">We can see the names of the features in the</st> <st c="16007">following
    output:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="16700">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16705">Go ahead and display the DataFrame containing the new features
    by executing</st> `<st c="16782">feature_matrix.head()</st>` <st c="16803">or
    check our accompanying GitHub repository for</st> <st c="16852">the result.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16863">To</st> <st c="16866">wrap up, by using the code from</st> *<st
    c="16899">step 1</st><st c="16905">6</st>* <st c="16907">and changing the target
    DataFrame name from</st> `<st c="16952">invoices</st>` <st c="16960">to</st> `<st
    c="16964">items</st>`<st c="16969">, go ahead and create features automatically
    at</st> <st c="17017">the</st> <st c="17021">product level.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17035">How it works...</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="17051">In this recipe, we set up an entity set containing the data and
    the relationships between some of</st> <st c="17150">its variables (unique identifiers).</st>
    <st c="17186">After that, we automatically</st> <st c="17215">created features
    by aggregating the information in the dataset for each of the unique identifiers.</st>
    <st c="17314">We used two main classes from</st> `<st c="17344">featuretools</st>`<st
    c="17356">,</st> `<st c="17358">EntitySet</st>` <st c="17367">and</st> `<st c="17372">dfs</st>`<st
    c="17375">, to create the features.</st> <st c="17401">Let’s discuss each of these
    in</st> <st c="17432">more detail.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17444">The</st> `<st c="17449">EntitySet</st>` <st c="17458">class stores</st>
    <st c="17472">the data, the logical types of the variables, and the relationships
    between the variables.</st> <st c="17563">The variable types (whether numeric
    or categorical) are automatically assigned by</st> `<st c="17645">featuretools</st>`<st
    c="17657">. We can also set up specific variable types when adding a DataFrame
    to the entity set.</st> <st c="17745">In</st> *<st c="17748">step 4</st>*<st c="17754">,
    we added the data to the entity set and set the logical type of</st> `<st c="17820">customer_id</st>`
    <st c="17831">to</st> `<st c="17835">Categorical</st>`<st c="17846">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17847">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17852">To inspect the datatypes inferred by</st> `<st c="17890">featuretools</st>`<st
    c="17902">, you can execute</st> `<st c="17920">es["data"].ww</st>`<st c="17933">,
    where</st> `<st c="17941">es</st>` <st c="17943">is the entity set and</st> `<st
    c="17966">data</st>` <st c="17970">is the name of</st> <st c="17986">the DataFrame.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18000">The</st> `<st c="18005">EntitySet</st>` <st c="18014">class has
    the</st> `<st c="18029">add_dataframe</st>` <st c="18042">method, which we used
    in</st> *<st c="18068">step 4</st>* <st c="18074">to add a new DataFrame.</st>
    <st c="18099">When using this method, we need to specify the unique identifier,
    and if there is none, then we need to create one, as we did in</st> *<st c="18228">step
    4</st>*<st c="18234">, by setting</st> `<st c="18247">make_index</st>` <st c="18257">to</st>
    `<st c="18261">True</st>`<st c="18265">. Note that in the</st> `<st c="18284">index</st>`
    <st c="18289">parameter from</st> `<st c="18305">add_dataframe</st>`<st c="18318">,
    we passed the</st> `<st c="18334">"rows"</st>` <st c="18340">string.</st> <st
    c="18349">With this configuration,</st> `<st c="18374">EntitySet</st>` <st c="18383">added
    a</st> `<st c="18392">rows</st>` <st c="18396">column containing the unique identifier
    for each row to the DataFrame, which is a new sequence of integers starting</st>
    <st c="18513">at 0.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18518">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18523">Instead of using the</st> `<st c="18545">add_dataframe</st>` <st
    c="18558">method to add a DataFrame to an entity set, we can add it by executing</st>
    `<st c="18630">es["df_name"]=df</st>`<st c="18646">, where</st> `<st c="18654">"df_name"</st>`
    <st c="18663">is the name we want to give to the DataFrame and</st> `<st c="18713">df</st>`
    <st c="18715">is the DataFrame we want</st> <st c="18741">to add.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18748">The</st> `<st c="18753">EntitySet</st>` <st c="18762">class has
    the</st> `<st c="18777">normalize_dataframe</st>` <st c="18796">method, which
    is used to create a new DataFrame and relationship from the unique values of an
    existing column.</st> <st c="18907">The method takes the name of the DataFrame
    to which the new DataFrame will be related and</st> <st c="18998">a name for the
    new DataFrame.</st> <st c="19028">We</st> <st c="19030">also need to indicate
    the</st> <st c="19057">unique identifier for the new DataFrame in the</st> `<st
    c="19104">index</st>` <st c="19109">parameter.</st> <st c="19121">By default,
    this method creates a new DataFrame containing the unique identifier, followed
    by a</st> `<st c="19217">datetime</st>` <st c="19225">column containing the first
    date each unique identifier was registered.</st> <st c="19298">We can add more
    columns to this DataFrame by using the</st> `<st c="19353">copy_columns</st>`
    <st c="19365">parameters, as we did in</st> *<st c="19391">step 5</st>*<st c="19397">.
    Adding more columns to the new DataFrame is useful if we want to follow up with
    relationships to this new DataFrame, as we did in</st> *<st c="19529">step 6</st>*<st
    c="19535">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19536">The</st> `<st c="19541">EntitySet</st>` <st c="19550">class also
    has the</st> `<st c="19570">plot()</st>` <st c="19576">method, which displays
    existing relationships in the entity set.</st> <st c="19642">In</st> *<st c="19645">Figure
    9</st>**<st c="19653">.5</st>*<st c="19655">, we saw the relationships between
    our data tables; the</st> `<st c="19711">invoices</st>` <st c="19719">and</st>
    `<st c="19724">items</st>` <st c="19729">(products) tables were related to the
    original data, whereas the</st> `<st c="19795">customers</st>` <st c="19804">table
    was related to the</st> `<st c="19830">invoices</st>` <st c="19838">table, which
    was, in turn, related to the</st> <st c="19881">original data.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19895">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19900">The relationship between the tables dictates how features will
    be created.</st> <st c="19976">The</st> `<st c="19980">invoices</st>` <st c="19988">and</st>
    `<st c="19993">items</st>` <st c="19998">tables are related to the original data.</st>
    <st c="20040">Thus, we can only create features with depth 1\.</st> <st c="20088">The</st>
    `<st c="20092">customers</st>` <st c="20101">table is, on the other hand, related
    to invoices, which is related to data.</st> <st c="20178">Thus, we can create
    features with depth 2\.</st> <st c="20221">That means that new features will consist
    of aggregations from the entire dataset or aggregations for invoices first, which
    will then be subsequently aggregated for customers.</st> <st c="20397">We can
    regulate the features to create with the</st> `<st c="20445">max_depth</st>` <st
    c="20454">parameter</st> <st c="20465">in</st> `<st c="20468">dfs</st>`<st c="20471">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20472">After setting up the data and the relationships, we used</st>
    `<st c="20530">dfs</st>` <st c="20533">from</st> `<st c="20539">featuretools</st>`
    <st c="20551">to automatically create features.</st> <st c="20586">When creating
    features with</st> `<st c="20614">dfs</st>`<st c="20617">, we need to set the
    target DataFrame – that is, the data table for which the features should be created.</st>
    <st c="20723">The</st> `<st c="20727">dfs</st>` <st c="20730">class creates features
    by</st> *<st c="20757">transforming</st>* <st c="20769">and</st> *<st c="20774">aggregating</st>*
    <st c="20785">existing variables, through what are called</st> **<st c="20830">transform</st>**
    <st c="20839">and</st> **<st c="20844">aggregate</st> <st c="20854">primitives</st>**<st
    c="20864">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20865">A transform</st> <st c="20878">primitive transforms variables.</st>
    <st c="20910">For example, from datetime variables, using a transform primitive,</st>
    `<st c="20977">dfs</st>` <st c="20980">extracts the</st> `<st c="20994">month</st>`<st
    c="20999">,</st> `<st c="21001">year</st>`<st c="21005">,</st> `<st c="21007">day</st>`<st
    c="21010">, and</st> `<st c="21016">week</st>` <st c="21020">values</st><st c="21027">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21028">An aggregate</st> <st c="21042">primitive aggregates information
    for a unique identifier.</st> <st c="21100">It uses mathematical operations such
    as the mean, standard deviation, maximum and minimum values, the sum, and the
    skew coefficient for numerical variables.</st> <st c="21257">For categorical variables,
    aggregate primitives u</st><st c="21306">se the mode and the count of</st> <st
    c="21335">unique items.</st> <st c="21350">For unique identifiers, they count
    the number</st> <st c="21396">of occurrences.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21411">With the functionality of transform and aggregate primitives in
    mind, let’s try to understand the features that we created in this recipe.</st>
    <st c="21551">We used the default parameters of</st> `<st c="21585">dfs</st>`
    <st c="21588">to create the</st> <st c="21603">default features.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21620">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21625">For more details on the default features returned by</st> `<st
    c="21679">featuretools</st>`<st c="21691">,</st> <st c="21693">visit</st> [<st
    c="21699">https://featuretools.alteryx.com/en/stable/generated/featuretools.dfs.html#featuretools.dfs</st>](https://featuretools.alteryx.com/en/stable/generated/featuretools.dfs.html#featuretools.dfs)<st
    c="21790">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21791">We first</st> <st c="21801">created features for each customer.</st>
    `<st c="21837">featuretools</st>` <st c="21849">returned 114 features for each
    customer.</st> <st c="21891">Because the</st> `<st c="21903">customers</st>` <st
    c="21912">data is related to the</st> `<st c="21936">invoices</st>` <st c="21944">data,
    which is related to the entire dataset, the</st> <st c="21995">features were created
    by aggregating data at two levels.</st> <st c="22052">First, the data was aggregated
    for each customer using the entire dataset.</st> <st c="22127">Next, it was aggregated
    for each invoice first, and then the pre-aggregated data was aggregated again
    for</st> <st c="22233">each customer.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22247">The</st> `<st c="22252">featuretools</st>` <st c="22264">library
    names the new features with the function used to aggregate the data – for example,</st>
    `<st c="22356">COUNT</st>`<st c="22361">,</st> `<st c="22363">MEAN</st>`<st c="22367">,</st>
    `<st c="22369">STD</st>`<st c="22372">, and</st> `<st c="22378">SKEW</st>`<st
    c="22382">, among others.</st> <st c="22398">Next, it uses the data that was used
    for the aggregation and follows it with the variable that was aggregated.</st>
    <st c="22509">For example, the</st> `<st c="22526">MEAN(data.quantity)</st>` <st
    c="22545">feature contains the mean quantity of items bought by the customer calculated
    from the entire dataset, which is the equivalent of</st> `<st c="22676">df.groupby("customer_id"])["quantity"].mean()</st>`<st
    c="22721">, if you are familiar with</st> `<st c="22748">pandas</st>`<st c="22754">.
    On the other hand, the</st> `<st c="22779">MEAN(invoices.MEAN(data.quantity))</st>`
    <st c="22813">feature first takes the mean quantity of items for each invoice
    – that is,</st> `<st c="22889">df.groupby("invoice"])["quantity"].mean()</st>`
    <st c="22930">– and from the resulting series, it takes the mean value, considering
    the invoices for a</st> <st c="23020">particular customer.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23040">For categorical</st> <st c="23057">features,</st> `<st c="23067">featuretools</st>`
    <st c="23079">determines the mode and</st> <st c="23104">the unique values.</st>
    <st c="23123">For example, from the</st> `<st c="23145">description</st>` <st
    c="23156">variable, we’ve got the</st> `<st c="23181">NUM_UNIQUE(data.description)</st>`
    <st c="23209">and</st> `<st c="23214">MODE(data.descripti</st><st c="23233">on)</st>`
    <st c="23237">features.</st> <st c="23248">The description is just the name of
    the item.</st> <st c="23294">Thus, these features highlight the number of unique
    item</st><st c="23350">s the customer bought and the item the customer bought
    the</st> <st c="23410">most times.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23421">Note something interesting</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23448">The</st> `<st c="23453">NUM_UNIQUE(data.description)</st>` <st
    c="23481">and</st> `<st c="23486">MODE(data.description)</st>` <st c="23508">variables
    are numeric after the aggregation of the categorical features.</st> <st c="23582">The</st>
    `<st c="23586">featuretools</st>` <st c="23598">library creates more features
    by using numerical aggregations of these newly created variables.</st> <st c="23695">In
    this way, the</st> `<st c="23712">MAX(invoices.NUM_UNIQUE(data.description)</st>`
    <st c="23753">feature first finds the number of unique items per invoice and then
    returns the maximum from those values for a particular customer, considering all
    the</st> <st c="23907">customer’s invoices.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23927">From datetime features,</st> `<st c="23952">featuretools</st>`
    <st c="23964">extracts date components by default.</st> <st c="24002">Remember
    that the</st> `<st c="24020">customers</st>` <st c="24029">DataFrame contains
    the</st> `<st c="24053">customer_id</st>` <st c="24064">variable and the date
    of the first invoice for each customer, as we saw in the output of</st> *<st c="24154">step
    10</st>*<st c="24161">. From this datetime feature,</st> `<st c="24191">featuretools</st>`
    <st c="24203">created</st> `<st c="24212">DAY(first_invoices_time)</st>`<st c="24236">,</st>
    `<st c="24238">MONTH(first_invoices_time)</st>`<st c="24264">,</st> `<st c="24266">WEEKDAY(first_invoices_time)</st>`<st
    c="24294">, and</st> `<st c="24300">YEAR(first_invoices_time)</st>` <st c="24325">features
    containing the different</st> <st c="24360">date parts.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24371">Finally,</st> `<st c="24381">featuretools</st>` <st c="24393">also
    returned the total number of invoices per customer (</st>`<st c="24451">COUNT(invoices)</st>`<st
    c="24467">) and the total number of row</st><st c="24497">s (</st>`<st c="24501">COUNT(data)</st>`<st
    c="24513">)</st> <st c="24516">per customer.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24529">See also</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '<st c="24538">For more details into what inspired</st> `<st c="24575">featuretools</st>`<st
    c="24587">, check the original article</st> *<st c="24616">Deep Feature Synthesis:
    Towards Automating Data Science Endeavors</st>* <st c="24681">by Kanter and Veeramachaneni</st>
    <st c="24711">at</st> [<st c="24714">https://www.jmaxkanter.</st><st c="24737">com/papers/DSAA_DSM_2015.pdf</st>](https://www.jmaxkanter.com/papers/DSAA_DSM_2015.pdf)<st
    c="24766">.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24767">Creating features with general and cumulative operations</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="24824">The</st> `<st c="24829">f</st><st c="24830">eaturetools</st>`
    <st c="24841">library uses</st> <st c="24855">what are called</st> **<st c="24871">transform
    primitives</st>** <st c="24891">to create features.</st> <st c="24912">Transform
    primitives take one or more columns</st> <st c="24958">i</st><st c="24959">n a
    dataset as input and</st> <st c="24984">return one or more columns as output.</st>
    <st c="25022">They are applied to a</st> *<st c="25044">single</st>* <st c="25050">DataFrame.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25061">The</st> `<st c="25066">featuretools</st>` <st c="25078">library
    divides its transform primitives into various categories de</st><st c="25146">pending</st>
    <st c="25155">on the type of operation they perform or the type of variable they
    modify.</st> <st c="25230">For example,</st> **<st c="25243">general transform
    primitives</st>** <st c="25271">apply mathematical operations, such as the square
    root, the sine, and the cosine.</st> **<st c="25354">Cumul</st><st c="25359">ative
    transform primitives</st>** <st c="25386">create new features by comparing a row’s
    value to the</st> <st c="25441">previous row’s value.</st> <st c="25463">For example,
    the cumulative sum, cumulative mean, and cumulative minimum and maximum values
    belong to this category, as well as the difference between row v</st><st c="25619">alues.</st>
    <st c="25627">There is another cumulative transformation that can be applied to
    datetime variables, which is the</st> **<st c="25726">time since previous</st>**
    <st c="25745">transformation, which determines the time passed between two</st>
    <st c="25807">consecutive timestamps.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25830">In this recipe, we will create features using the general and
    cumulative trans</st><st c="25909">form primitives</st> <st c="25926">from</st>
    `<st c="25931">featuretools</st>`<st c="25943">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25944">Getting ready</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="25958">Variable transformations such as the square root or the logarithm
    are useful when we want to change the distribution of a variable, as we saw in</st>
    [*<st c="26104">Chapter 3</st>*](B22396_03.xhtml#_idTextAnchor351)<st c="26113">,</st>
    *<st c="26115">Transforming Numerical Variables</st>*<st c="26147">. Other mathematical
    derivations such as the sine and cosine help to capture underlying data patterns,
    as we described in the</st> *<st c="26273">Creating periodic features from cyclical
    variables</st>* <st c="26323">recipe in</st> [*<st c="26334">Chapter 8</st>*](B22396_08.xhtml#_idTextAnchor987)<st
    c="26343">,</st> *<st c="26345">Creating New Features</st>*<st c="26366">. From
    the transformations described in those chapters,</st> `<st c="26422">featuretools</st>`
    <st c="26434">supports the square root and the logarithm transformation and the
    sine and cosine (but without the normalization between 0</st> <st c="26558">and
    2π).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26566">With a cumulative transformation, we can, for example, get the
    total number of items bought per invoice by adding up the item’s quantity on each
    row at the invoice level.</st> <st c="26738">To understand the features that we
    will create in this recipe, let’s create them with</st> `<st c="26824">pandas</st>`
    <st c="26830">first:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26837">Let’s import</st> `<st c="26851">pandas</st>` <st c="26857">and</st>
    `<st c="26862">numpy</st>`<st c="26867">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="26908">Let’s load the retail dataset described in the</st> *<st c="26956">Technical</st>*
    *<st c="26966">requirements</st>* <st c="26978">section:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="27049">Let’s</st> <st c="27056">capture the two numerical variables,</st>
    `<st c="27093">price</st>` <st c="27098">and</st> `<st c="27103">quantity</st>`<st
    c="27111">, in</st> <st c="27116">a list:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="27160">Let’s</st> <st c="27167">capture the names of the cumulative functions
    in</st> <st c="27216">a list:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="27260">Let’s create a list with new names for the variables that we</st>
    <st c="27322">will create:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="27414">Let’s create new variables using the cumulative functions from</st>
    *<st c="27478">step 4</st>*<st c="27484">, applied to the variables from</st>
    *<st c="27516">step 3</st>*<st c="27522">, and add them to</st> <st c="27540">the
    DataFrame:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="27617">The previous step returns the cumulative sum, cumulative maximum
    value, and the difference between rows, within each invoice.</st> <st c="27744">As
    soon as it encounters a new invoice number, it</st> <st c="27794">starts afresh.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27808">Let’s display the original and new features for one</st> <st c="27861">particular
    invoice:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="27938">In the following output, we can see that</st> `<st c="27980">quantity_cumsum</st>`
    <st c="27995">is the cumulative sum for the variable quantity and</st> `<st c="28048">price_diff</st>`
    <st c="28058">is the price difference row</st> <st c="28087">after row:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.7 – DataFrame showing cumulative functions applied to numerical
    features in a single entity (invoice)](img/B22396_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="28371">Figure 9.7 – DataFrame showing cumulative functions applied to
    numerical features in a single entity (invoice)</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28481">Let’s now</st> <st c="28492">apply the sine</st> <st c="28507">and
    cosine transformation to the</st> <st c="28540">entire DataFrame.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28557">Let’s create a list with names for the</st> <st c="28597">new
    variables:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="28701">Let’s transform the price and quantity with the sine</st> <st
    c="28755">and cosine:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="28822">The transformation in</st> *<st c="28845">step 9</st>* <st c="28851">was
    applied to the entire dataset, irrespective of the invoice number, which is fine
    because it maps from o</st><st c="28959">ne row to the same row, as opposed to
    from one row to the next, as with cumulative functions.</st> <st c="29054">You
    can inspect the result by</st> <st c="29084">executing</st> `<st c="29094">df[new_names].head()</st>`<st
    c="29114">.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29115">Now that we understand the types of features we want to create,
    let’s au</st><st c="29188">tomate the process</st> <st c="29208">with</st> `<st
    c="29213">featuretools</st>`<st c="29225">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29226">How to do it...</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="29242">We</st> <st c="29246">will</st> <st c="29251">apply cumulative
    transformations</st> <st c="29284">for each invoice and general transformations
    to the</st> <st c="29336">entire dataset:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29351">First, we’ll import</st> `<st c="29372">pandas</st>`<st c="29378">,</st>
    `<st c="29380">featuretools</st>`<st c="29392">, and the</st> `<st c="29402">Categorical</st>`
    <st c="29413">logical type:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="29520">Let’s load the dataset described in the</st> *<st c="29561">Technical</st>*
    *<st c="29571">requirements</st>* <st c="29583">section:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="29654">Let’s set up an</st> <st c="29671">entity set:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="29711">Let’s add the DataFrame to the</st> <st c="29743">entity set:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="29944">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29949">By default,</st> `<st c="29962">featuretools</st>` <st c="29974">only
    retains categorical, numeric, and Boolean features in the feature matrix that
    is generated</st> *<st c="30071">after</st>* <st c="30076">creating new features.</st>
    <st c="30100">The type of the</st> `<st c="30116">invoice</st>` <st c="30123">variable
    is not accurately inferred, so we need to enforce it as categorical by setting
    its logical type as we do in</st> *<st c="30241">step 4</st>*<st c="30247">, if
    we want</st> `<st c="30260">featuretools</st>` <st c="30272">to retain it in the
    dataset containing the new features.</st> <st c="30330">To learn the datatypes
    inferred by</st> `<st c="30365">featuretools</st>`<st c="30377">, you</st> <st
    c="30383">can</st> <st c="30387">execute</st> `<st c="30395">es["data"].</st><st
    c="30406">ww</st>`<st c="30409">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30410">Let’s create</st> <st c="30424">a new DataFrame with</st> <st
    c="30445">a relationship to the DataFrame from</st> *<st c="30482">step 4</st>*<st
    c="30488">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="30622">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30627">For more details about</st> *<st c="30651">steps 4</st>* <st c="30658">and</st>
    *<st c="30663">5</st>*<st c="30664">, visit the</st> *<st c="30676">Setting up
    an entity set and creating features</st>* *<st c="30723">automatically</st>* <st
    c="30736">recipe.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30744">Let’s make a list with the cumulative transformations that we’ll
    use to</st> <st c="30817">create features:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="30905">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30910">You can find</st> `<st c="30924">featuretools</st>`<st c="30936">-supported
    cumulative transformations at this</st> <st c="30983">link:</st> [<st c="30989">https://featuretools.alteryx.com/en/stable/api_reference.html#cumulative-transform-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#cumulative-transform-primitives)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31082">Let’s make</st> <st c="31094">a list of the general transformations
    to</st> <st c="31135">carry out:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="31188">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31193">You can find</st> `<st c="31207">featuretools</st>`<st c="31219">-supported
    general transformations at this</st> <st c="31263">link:</st> [<st c="31269">https://featuretools.alteryx.com/en/stable/api_reference.html#g</st><st
    c="31332">eneral-transform-primiti</st><st c="31357">ves</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#general-transform-primitives)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31361">Finally, let’s</st> <st c="31377">create the features.</st> <st
    c="31398">We use the</st> `<st c="31409">dfs</st>` <st c="31412">class, setting
    the original DataFrame as the target DataFrame – that is, the one whose variables
    we’ll use as a template for the new features.</st> <st c="31556">Note that we
    pass an empty list to the</st> `<st c="31595">agg_primitives</st>` <st c="31609">parameter;
    this is to avoid returning the default aggregation primitives.</st> <st c="31684">We
    pass the general primitives from</st> *<st c="31720">step 7</st>* <st c="31726">to
    the</st> `<st c="31734">trans_primitives</st>` <st c="31750">parameter and the
    cumulative primitives from</st> *<st c="31796">step 6</st>* <st c="31802">to the</st>
    `<st c="31810">groupby_trans_primitives</st>` <st c="31834">parameter:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="32063">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="32068">Step 8</st>* <st c="32075">triggers the creation of features,
    which may take some time depending on how big the data is, how many aggregation
    levels it has, and the number of features to create.</st> <st c="32244">You can
    check out the output features</st> *<st c="32282">before</st>* <st c="32288">creating
    them, by setting the</st> `<st c="32319">features_only</st>` <st c="32332">parameter
    to</st> `<st c="32346">True</st>`<st c="32350">. This will return just the feature
    names; you can check them out, make sure they show what you need, and only then
    trigger the feature synthesis by setting that parameter back</st> <st c="32527">to</st>
    `<st c="32530">False</st>`<st c="32535">.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32536">Let’s now</st> <st c="32547">display the names</st> <st c="32565">of
    the</st> <st c="32572">created features:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="32603">In the following output, we see the names of the features that
    we created, including the sine and cosine of the price and quantity, and the cumulative
    transformations of these variables after grouping them by</st> <st c="32813">invoice
    number:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="33338">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33343">The sine</st> <st c="33353">and cosine transformation of price
    and quantity will probably</st> <st c="33415">not add much value because these
    are not cyclical features.</st> <st c="33475">I kept these transformations in
    the recipe to show you how to apply transformation primitives in general, if you
    ever</st> <st c="33593">need them.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33603">As you</st> <st c="33611">can see from the</st> <st c="33628">previous
    list, the new features were appended as new colum</st><st c="33686">ns to the
    original DataFrame.</st> <st c="33717">You can display the fin</st><st c="33740">al
    DataFrame by</st> <st c="33757">executing</st> `<st c="33767">feature_matrix.head()</st>`<st
    c="33788">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.8 – DataFrame resulting from the deep feature synthesis, containing\
    \ the \uFEFForiginal variables and the new features](img/B22396_09_08.jpg)"
  prefs: []
  type: TYPE_IMG
- en: <st c="34802">Figure 9.8 – DataFrame resulting from the deep feature synthesis,
    containing the</st> <st c="34883">original variables and the new features</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34922">For more details about the cr</st><st c="34952">eated features,
    check the</st> *<st c="34979">How it</st>* *<st c="34986">works…</st>* <st c="34992">section.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35001">How it works...</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="35017">To create</st> <st c="35028">features using general and</st> <st
    c="35055">cumulative transformations with</st> `<st c="35087">featuretools</st>`<st
    c="35099">, we first need to set up an entity set with the data and define the
    relationships between its variables.</st> <st c="35205">We described how to set
    up an entity set in the</st> *<st c="35253">Setting up an entity set and creating
    features</st>* *<st c="35300">automatically</st>* <st c="35313">recipe.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35321">To apply cumulative and general transforms, we used the</st> `<st
    c="35378">dfs</st>` <st c="35381">class from</st> `<st c="35393">featuretools</st>`<st
    c="35405">. General transformations are applied to the entire DataFrame without
    grouping by a specific variable.</st> <st c="35508">To perform general transformations,
    we passed a list of strings with the transformation names to t</st><st c="35606">he</st>
    `<st c="35610">trans_primitives</st>` <st c="35626">parameter</st> <st c="35637">fr</st><st
    c="35639">om</st> `<st c="35643">dfs</st>`<st c="35646">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35647">We applied cumulative transformation after grouping by</st> `<st
    c="35703">invoice</st>`<st c="35710">. To do this, we passed a list of strings
    with the names of the cumulative transformation to the</st> `<st c="35807">groupby_trans_primitives</st>`
    <st c="35831">parameter from</st> `<st c="35847">dfs</st>`<st c="35850">. The</st>
    `<st c="35856">featuretools</st>` <st c="35868">library knows it should group
    by invoice because we established this unique identifier by using the</st> `<st
    c="35969">normalize_dataframe</st>` <st c="35988">method from</st> `<st c="36001">EntitySet</st>`
    <st c="36010">in</st> *<st c="36014">step 5</st>*<st c="36020">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36021">Finally, we did not want features created from the variables in
    the</st> `<st c="36090">invoices</st>` <st c="36098">DataFrame; thus, we set</st>
    `<st c="36123">dfs</st>` <st c="36126">to ignore this DataFrame by setting</st>
    `<st c="36163">ignore_dataframes = ["</st>``<st c="36185">invoices"]</st>`<st
    c="36196">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36197">The</st> `<st c="36202">dfs</st>` <st c="36205">class returned
    two variables, the DataFrame with the original and new features, and the name
    of the features in a list.</st> <st c="36326">The new features are named with
    the operations</st> <st c="36373">applied to create them, such as</st> `<st c="36405">SINE</st>`<st
    c="36409">,</st> `<st c="36411">COSINE</st>`<st c="36417">,</st> `<st c="36419">CUM_MAX</st>`<st
    c="36426">, or</st> `<st c="36431">DIFF</st>`<st c="36435">, followed by the variable
    to which the</st> <st c="36475">transformation was applied and, when corresponding,
    the variable that was used</st> <st c="36554">for grouping.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36567">Note that</st> `<st c="36578">featuretools</st>` <st c="36590">automatically
    recognizes and selects the variables over which the transformations should be
    applied.</st> <st c="36692">The sine, cosine, cumulative sum, maximum, and difference
    were applied to numerical variables, whereas the</st> `<st c="36799">time_since_previous</st>`
    <st c="36818">transformation was applied to the</st> <st c="36853">datetime variable.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36871">Combining numerical features</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="36900">In</st> [*<st c="36904">Chapter 8</st>*](B22396_08.xhtml#_idTextAnchor987)<st
    c="36913">,</st> *<st c="36915">Creating New Features</st>*<st c="36936">, we
    saw th</st><st c="36947">at we can create new features by combining</st> <st c="36991">variables
    with mathematical operations.</st> <st c="37031">The</st> `<st c="37035">featuretools</st>`
    <st c="37047">library supports several operations for combining variables, including
    addition, division, modulo, and multiplication.</st> <st c="37167">In this recipe,
    we will l</st><st c="37192">earn how to combine these features</st> <st c="37228">with</st>
    `<st c="37233">featuretools</st>`<st c="37245">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37246">How to do it...</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="37262">Let’s begin by importing the libraries and getting the</st> <st
    c="37318">dataset ready:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37332">First, we’ll import</st> `<st c="37353">pandas</st>`<st c="37359">,</st>
    `<st c="37361">featuretools</st>`<st c="37373">, and the</st> `<st c="37383">Categorical</st>`
    <st c="37394">logical type:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="37501">Let’s load the dataset that described in the</st> *<st c="37547">Technical</st>*
    *<st c="37557">requirements</st>* <st c="37569">section:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="37640">Let’s set up an</st> <st c="37657">entity set:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="37697">Let’s add</st> <st c="37708">the DataFrame to the</st> <st c="37729">entity
    set:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="37904">Let’s create a new DataFrame with a relationship to the DataFrame
    from</st> *<st c="37976">step 4</st>*<st c="37982">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="38116">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38121">For more details about</st> *<st c="38145">steps 4</st>* <st c="38152">and</st>
    *<st c="38157">5</st>*<st c="38158">, visit the</st> *<st c="38170">Setting up
    an entity set and creating features</st>* *<st c="38217">automatically</st>* <st
    c="38230">recipe.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38238">We will multiply the</st> `<st c="38260">quantity</st>` <st c="38268">and</st>
    `<st c="38273">price</st>` <st c="38278">variables, which reflect the number of
    items bought and the unit price, respectively, to obtain the total</st> <st c="38385">amount
    paid:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="38674">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38679">We set</st> `<st c="38687">agg_primitives</st>` <st c="38701">to
    an empty list to avoid the creation of</st> <st c="38744">default primitives.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38763">Let’s now</st> <st c="38774">display the name of the</st> <st
    c="38798">new features:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="38824">In the following output, we see the feature names, the last one
    of which corresponds to the combination of the</st> `<st c="38936">price</st>`
    <st c="38941">and</st> `<st c="38946">quantity</st>` <st c="38954">variables:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="39101">To finish off, let’s inspect the new Da</st><st c="39141">taFrame
    created in</st> *<st c="39161">step 6</st>*<st c="39167">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="39191">In the</st> <st c="39199">following output, we can see that the
    new featu</st><st c="39246">re was appended to the right of the</st> <st c="39283">original
    DataFrame:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.9 – DataFrame with the new feature resulting from the product of
    price with quantity](img/B22396_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="39658">Figure 9.9 – DataFrame with the new feature resulting from the
    product of price with quantity</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39751">Combining features with</st> `<st c="39776">featuretools</st>`
    <st c="39788">may seem like a lot of work compared to the</st> `<st c="39833">df["price"].mul(df["quantity"])</st>`
    `<st c="39864">pandas</st>` <st c="39871">functionality.</st> <st c="39887">The
    real power comes in when we create new features in this way and follow it up with
    aggregations at the invoice or customer level.</st> <st c="40020">We will discuss
    aggregation functions in th</st><st c="40063">e</st> *<st c="40066">Creating features
    with aggregation</st>* *<st c="40101">primitives</st>* <st c="40111">recipe.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40119">How it works...</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="40135">To multiply features, we used the</st> `<st c="40170">MultiplyNumeric</st>`
    <st c="40185">primitive from</st> `<st c="40201">featuretools</st>`<st c="40213">,
    which can be accessed from</st> `<st c="40242">dfs</st>` <st c="40245">using the</st>
    `<st c="40256">multiply_numeric</st>` <st c="40272">string.</st> <st c="40281">We
    passed the former string to the</st> `<st c="40316">trans_primitive</st>` <st
    c="40331">parameter and then used the</st> `<st c="40360">primitive_options</st>`
    <st c="40377">parameter to specify which variables to multiply.</st> <st c="40428">Note
    that in addition, we passed an empty list to the</st> `<st c="40482">agg_primitives</st>`
    <st c="40496">parameter to avoid returning the default aggregation primitives,
    and we ignored the features coming from the</st> `<st c="40606">invoices</st>`
    <st c="40614">DataFrame.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40625">To check out other functions that allow you to combine variables,
    visit</st> [<st c="40698">https://featuretools.alteryx.com/en/stable/api_reference.html#binary-transform-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#binary-transform-primitives)<st
    c="40787">. At the time of writing, I noticed that</st> `<st c="40828">MultiplyNumeric</st>`
    <st c="40843">and</st> `<st c="40848">DivideNumeric</st>` <st c="40861">are not
    in the documentation.</st> <st c="40892">You can always double-check which functions
    are supported by inspecting the source code:</st> [<st c="40981">https://github.com/alteryx/featuretools/tree/main/featuretools/primitives/standard/transform/binary</st>](https://github.com/alteryx/featuretools/tree/main/featuretools/primitives/standard/transform/binary)<st
    c="41080">. You can</st> <st c="41090">also check out which operations you can
    perform on your data by running the following command after you set up the entity
    set and its relationships:</st> `<st c="41239">ft.get_valid_primitives(es, target_dataframe_name="data",
    max_dep</st><st c="41304">th=2)</st>`<st c="41310">. Here,</st> `<st c="41318">es</st>`
    <st c="41320">is the entity set resulting from</st> *<st c="41354">step 5</st>*<st
    c="41360">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41361">Extracting features from date and time</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="41400">In</st> [*<st c="41404">Chapter 6</st>*](B22396_06.xhtml#_idTextAnchor748)<st
    c="41413">,</st> *<st c="41415">Extracting Features from Date and Time</st>* *<st
    c="41453">Variables</st>*<st c="41463">, we discussed how we</st> <st c="41484">can
    enrich our</st> <st c="41500">datasets by extracting features from the date and
    time parts of datetime variables, such as the year, the month, the day of the
    week, the hour, and much more.</st> <st c="41659">We can extract those features
    automatically</st> <st c="41703">u</st><st c="41704">tilizing</st> `<st c="41713">featuretools</st>`<st
    c="41725">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41726">The</st> `<st c="41731">featuretools</st>` <st c="41743">library
    supports the creation of various features from datetime variables</st> <st c="41818">using
    its</st> **<st c="41828">datetime transform primitives</st>**<st c="41857">. These
    primitives include common variables such as year, month, and day, and other features
    such as</st> *<st c="41958">is it lunch time</st>* <st c="41974">or</st> *<st
    c="41978">is it weekday</st>*<st c="41991">. In addition, we can extract features
    indicating if the date was a federal or bank holiday (as they call it in the UK)
    or features that determine the distance in time to a certain date.</st> <st c="42178">For
    a retail company, the proximity to dates such as Boxing Day, Black Fridays, or
    Christmas normally signals an increase in sales, and if they are forecasting demand,
    these will make</st> <st c="42362">useful variables.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42379">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42384">For more details on the features that can be created from datetime
    variables,</st> <st c="42463">visit</st> [<st c="42469">https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives)<st
    c="42560">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42561">In this recipe, we will automatically create mul</st><st c="42610">tiple
    features from a datetime variable</st> <st c="42651">with</st> `<st c="42656">featuretools</st>`<st
    c="42668">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42669">How to do it...</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="42685">Let’s begin</st> <st c="42698">by importing the libraries and
    getting the</st> <st c="42741">dataset ready:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42755">First, we’ll import</st> `<st c="42776">pandas</st>`<st c="42782">,</st>
    `<st c="42784">featuretools</st>`<st c="42796">, and some special</st> <st c="42815">datetime
    primitives:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="43003">Let’s load the dataset described in the</st> *<st c="43044">Technical</st>*
    *<st c="43054">requirements</st>* <st c="43066">section:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="43137">Let</st><st c="43141">’s set up an</st> <st c="43155">entity set:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="43195">Let’s add the DataFrame to the</st> <st c="43227">entity set:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="43402">Let’s create a new DataFrame with a relationship to the DataFrame
    from</st> *<st c="43474">step 4</st>*<st c="43480">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="43614">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43619">For more details about</st> *<st c="43643">steps 4</st>* <st c="43650">and</st>
    *<st c="43655">5</st>*<st c="43656">, visit the</st> *<st c="43668">Setting up
    an entity set and creating features</st>* *<st c="43715">automatically</st>* <st
    c="43728">recipe.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43736">Let’s create</st> <st c="43750">a primitive that returns a Boolean
    vector indicating if the date coincides with a UK bank holiday (that is, a</st>
    <st c="43860">non-working day):</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="43922">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43927">When setting up the primitive to determine bank holidays, it is
    important to choose the right country.</st> <st c="44031">For a list of supported
    countries,</st> <st c="44066">visit</st> [<st c="44072">https://github.com/dr-prodigy/python-holidays#available-countries</st>](https://github.com/dr-prodigy/python-holidays#available-countries)<st
    c="44137">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44138">Let’s check out which bank holidays are included in</st> <st c="44191">this
    primitive:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="44296">If we</st> <st c="44303">execute</st> `<st c="44311">available_hols</st>`<st
    c="44325">, we’ll see a list of bank holidays supported for</st> <st c="44375">the
    UK:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="44865">Let’s create another primitive that determines the days to a certain
    date – in this case, the distance to</st> <st c="44972">Boxing Day:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="45055">Now, let’s make a list containing strings that identify common
    features that we can get from</st> `<st c="45149">datetime</st>` <st c="45157">and
    include the primitives from</st> *<st c="45190">steps 6</st>* <st c="45197">and</st>
    *<st c="45202">8</st>*<st c="45203">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="45340">Let’s now</st> <st c="45351">create date and time features from</st>
    *<st c="45386">step 9</st>* <st c="45392">based on the</st> `<st c="45406">invoice_date</st>`
    <st c="45418">date variable:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="45575">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45580">In</st> *<st c="45584">step 4</st>*<st c="45590">, we entered
    the</st> `<st c="45607">invoice_date</st>` <st c="45619">variable as a time variable.</st>
    <st c="45649">Thus,</st> `<st c="45655">featuretools</st>` <st c="45667">will
    use this variable to create date- and</st> <st c="45711">time-related features.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45733">Let’s display the names of the</st> <st c="45765">created features:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="45795">In the following output, we see the names of the original and</st>
    <st c="45858">time features:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="46561">Let’s display the resulting DataFrame containing three of the</st>
    <st c="46624">new features:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="46830">In the</st> <st c="46837">following output, we see the DataFrame
    with the</st> <st c="46886">new features:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figure 9.10 – DataF\uFEFFrame with some of the features derived from datetime](img/B22396_09_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: <st c="47148">Figure 9.10 – DataF</st><st c="47167">rame with some of the features
    derived from datetime</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47220">Note that</st> <st c="47231">some of the created features are
    numeric, such as</st> `<st c="47281">HOUR</st>` <st c="47285">or</st> `<st c="47289">DAY</st>`<st
    c="47292">, some are Booleans, such as</st> `<st c="47321">IS_FEDERAL_HOLIDAY</st>`<st
    c="47339">, and some are categorical, such as</st> `<st c="47375">PART_OF_DAY</st>`<st
    c="47386">. To take a look at the values of</st> `<st c="47420">PART_OF_DAY</st>`<st
    c="47431">,</st> <st c="47433">e</st><st c="47434">xecute</st> `<st c="47441">feature_matrix["PAR</st><st
    c="47460">T_OF_DAY(first_data_time)"].unique()</st>`<st c="47497">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47498">How it works...</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="47514">To create features from datetime variables, we used datetime transform
    primitives from</st> `<st c="47602">featuretools</st>` <st c="47615">(</st>[<st
    c="47616">https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives)<st
    c="47707">).</st> <st c="47711">These primitives can be accessed from</st> `<st
    c="47749">dfs</st>` <st c="47752">using the strings and functions we specified
    in</st> *<st c="47801">steps 6</st>* <st c="47808">to</st> *<st c="47811">9</st>*
    <st c="47813">through the</st> `<st c="47826">trans_primitive</st>` <st c="47841">parameter.</st>
    <st c="47853">Note that in addition, we passed an empty list to the</st> `<st
    c="47907">agg_primitives</st>` <st c="47921">parameter not to return the default
    aggregation primitives that would have been otherwise applied to our datetime
    features.</st> <st c="48046">We also ignored the features coming from the</st>
    `<st c="48091">invoices</st>` <st c="48099">DataFrame.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48110">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48115">We set</st> `<st c="48123">agg_primitives</st>` <st c="48137">to
    an empty list and ignored the</st> `<st c="48171">invoices</st>` <st c="48179">DataFrame
    to keep the outputs simple and be able to focus on datetime features.</st> <st
    c="48260">However, note that the real power of</st> `<st c="48297">featuretools</st>`
    <st c="48309">consists in creating primitives from</st> `<st c="48347">datetim</st><st
    c="48354">e</st>` <st c="48356">and then aggregating them further at different</st>
    <st c="48404">entity levels.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48418">Extracting features from text</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="48448">In</st> [*<st c="48452">Chapter 11</st>*](B22396_11.xhtml#_idTextAnchor1459)<st
    c="48462">,</st> *<st c="48464">Extracting Feat</st><st c="48479">ures from Text
    Variables</st>*<st c="48504">, we will discuss various features that</st> <st
    c="48544">we can extract from text pieces utilizing</st> `<st c="48586">pandas</st>`
    <st c="48592">and</st> `<st c="48597">scikit-learn</st>`<st c="48609">. We can
    also extract multiple features from text automatically by</st> <st c="48676">utilizing</st>
    `<st c="48686">featuretools</st>`<st c="48698">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48699">The</st> `<st c="48704">featuretools</st>` <st c="48716">library
    supports the creation of several basic features from text as part of its default
    functionality, such as the number of characters, the number of words, the mean
    character count per word, and the median word length in a piece of text,</st>
    <st c="48958">among others.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48971">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48976">For a full list</st> <st c="48993">of the default text primitives,</st>
    <st c="49025">visit</st> [<st c="49031">https://featuretools.alteryx.com/en/stable/api_reference.html#naturallanguage-transform-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#naturallanguage-transform-primitives)<st
    c="49129">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49130">In addition, there is an accompanying Python library,</st> `<st
    c="49185">nlp_primitives</st>`<st c="49199">, which contains additional primitives
    to create more advanced features based on NLP.</st> <st c="49285">Among these
    functions, we find primitives for determining the diversity score, the polarity
    score, or the count of</st> <st c="49400">stop words.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49411">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49416">There is no documentation at the time of writing to learn more
    about the primitives supported</st> <st c="49511">by the</st> `<st c="49518">nlp_primitives</st>`
    <st c="49532">library, so to find out more, you need to check the source</st>
    <st c="49592">code:</st> [<st c="49598">https://github.com/alteryx/nlp_primitives/tree/6243ef2379501bfec2c3f19e35a30b5954605e57/nlp_primitives</st>](https://github.com/alteryx/nlp_primitives/tree/6243ef2379501bfec2c3f19e35a30b5954605e57/nlp_primitives)<st
    c="49700">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49701">In this recipe, we will first create multiple features from a
    text variable utilizing</st> `<st c="49788">featuretools</st>`<st c="49800">’
    default functionality and the</st><st c="49832">n highlight how to use p</st><st
    c="49857">rimitives from the</st> `<st c="49877">nlp_primitives</st>` <st c="49891">library.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49900">Getting ready</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="49914">To follow along with this recipe, you need to install the</st>
    `<st c="49973">nlp_primitives</st>` <st c="49987">library, which you can do</st>
    <st c="50014">with</st> `<st c="50019">pip</st>`<st c="50022">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: <st c="50051">Otherwise, you can</st> <st c="50071">use</st> `<st c="50075">conda</st>`<st
    c="50080">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: <st c="50126">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50131">For more details, visit the</st> `<st c="50160">nlp_primi</st><st
    c="50169">tives</st>` <st c="50175">GitHub</st> <st c="50183">repository:</st>
    [<st c="50195">https://github.com/alteryx/nlp_primitives</st>](https://github.com/alteryx/nlp_primitives)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50236">How to do it...</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="50252">Let’s begin</st> <st c="50265">by importing the libraries and
    getting the</st> <st c="50308">dataset ready:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50322">First, we’ll import</st> `<st c="50343">pandas</st>`<st c="50349">,</st>
    `<st c="50351">featuretools</st>`<st c="50363">, and the</st> <st c="50373">logical
    types:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="50500">Let’s load the dataset described in the</st> *<st c="50541">Technical</st>*
    *<st c="50551">requirements</st>* <st c="50563">section:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="50634">Let’s set up an</st> <st c="50651">entity set:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="50691">Let’s add the DataFrame to the entity set, highlighting that the</st>
    `<st c="50757">description</st>` <st c="50768">variable is a</st> <st c="50783">text
    variable:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="51019">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51024">For the</st> `<st c="51033">featuretools</st>` <st c="51045">library‘s
    text primitives to work, we need to indicate which variables are text by using
    the</st> `<st c="51139">NaturalLanguage</st>` <st c="51154">logical type.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51168">Let’s create</st> <st c="51182">a new DataFrame with a relationship
    to the DataFrame from</st> *<st c="51240">step 4</st>*<st c="51246">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="51380">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51385">For more details about</st> *<st c="51409">steps 4</st>* <st c="51416">and</st>
    *<st c="51421">5</st>*<st c="51422">, visit the</st> *<st c="51434">Setting up</st>
    <st c="51445">an entity set and creating features</st>* *<st c="51481">automatically</st>*
    <st c="51494">recipe.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51502">Let’s make a list with strings corresponding to the text features
    we want</st> <st c="51577">to create:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="51684">Let’s now</st> <st c="51695">extract the text features from the</st>
    `<st c="51730">description</st>` <st c="51741">variable:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="51921">Let’s display the names of the</st> <st c="51953">created features:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="51983">In the following output, we see the names of the original features,
    followed by those created from the</st> `<st c="52087">description</st>` <st c="52098">variable:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="52444">Let’s display</st> <st c="52459">a slice of the DataFrame containing
    the</st> <st c="52499">text-derived features:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="52654">In the followin</st><st c="52670">g output, we see a DataFrame
    with the features created from</st> <st c="52731">the text:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.11 – DataFrame with the features created from text](img/B22396_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="52874">Figure 9.11 – DataFrame with the features created from text</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52933">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52938">The</st> `<st c="52943">featuretools</st>` <st c="52955">library
    removes the original text variable,</st> `<st c="53000">description</st>`<st c="53011">,
    and in its place, it returns the</st> <st c="53046">new features.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53059">To create features using the primitives from the</st> `<st c="53109">nlp_primitives</st>`
    <st c="53123">package, you need to import them first – for example, by executing
    from</st> `<st c="53196">nlp_primitives import DiversityScore</st>` <st c="53232">–
    and then add the primitives to the text primitive list that we created in</st>
    *<st c="53309">step 6</st>*<st c="53315">. Note that these are</st> <st c="53336">complex
    functions, so they</st> <st c="53363">may take some time to create</st> <st c="53393">the
    features.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53406">How it works...</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="53422">To create</st> <st c="53433">features from text variables, we
    used the default text primitives from</st> `<st c="53504">featuretools</st>`<st
    c="53516">. These primitives can be accessed from</st> `<st c="53556">dfs</st>`
    <st c="53559">by passing a list with strings corresponding to the primitive names,
    such as those from</st> *<st c="53648">step 6</st>*<st c="53654">, to the</st>
    `<st c="53663">trans_primitives</st>` <st c="53679">parameter.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53690">For more advanced primitives, you need to import the primitive
    functions from the</st> `<st c="53773">nlp_primitives</st>` <st c="53787">library
    and then pass them on to the</st> `<st c="53825">trans_primitives</st>` <st c="53841">parameter
    from</st> `<st c="53857">dfs</st>`<st c="53860">. With this,</st> `<st c="53873">dfs</st>`
    <st c="53876">can tap into the functionality of these primitives to create new
    features from the text.</st> <st c="53966">T</st><st c="53967">he</st> `<st c="53970">nlp_primitives</st>`
    <st c="53984">library uses the</st> `<st c="54002">nltk</st>` <st c="54006">Python
    library un</st><st c="54024">der</st> <st c="54029">the hood.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54038">Creating features with aggregation primitives</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="54084">Throughout this chapter, we’ve created features automatically
    by mapping existing variables into</st> <st c="54182">new features through various
    functions.</st> <st c="54222">For example, we extracted date and time parts from
    datetime variables, counted the number of words,</st> <st c="54321">characters,
    and punctuation in texts, combined numerical features into new variables, and
    transformed features with functions such as sine and cosine.</st> <st c="54473">To
    create these features, we worked with</st> <st c="54514">transform primitives.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54535">The</st> `<st c="54540">featuretools</st>` <st c="54552">library
    also</st> <st c="54566">supports</st> `<st c="54773">price</st>`<st c="54778">,
    related to an invoice, an aggregation primitive would take all the price observations
    for a single invoice and return a single value, such as the mean price or the
    sum (that is, the total amount paid), for</st> <st c="54986">that invoice.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54999">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55004">The</st> `<st c="55009">featuretools</st>` <st c="55021">aggregation
    functionality is the equivalent of</st> `<st c="55069">groupby</st>` <st c="55076">in</st>
    `<st c="55080">pandas</st>`<st c="55086">, followed by</st> `<st c="55100">pandas</st>`
    <st c="55106">fun</st><st c="55110">ctions such as</st> `<st c="55126">mean</st>`<st
    c="55130">,</st> `<st c="55132">sum</st>`<st c="55135">,</st> `<st c="55137">std</st>`<st
    c="55140">, and</st> `<st c="55146">count</st>`<st c="55151">,</st> <st c="55153">among
    others.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55166">Some aggregation primitives work with numerical variables, such
    as the mean, sum, or maximum</st> <st c="55260">and minimum values.</st> <st c="55280">Other
    aggregation primitives are specific to categorical variables, such as the number</st>
    <st c="55366">of unique values and the most frequent</st> <st c="55406">value
    (mode).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55419">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55424">For a</st> <st c="55431">complete list of supported aggregation
    primitives,</st> <st c="55482">visit</st> [<st c="55488">https://featuretools.alteryx.com/en/stable/api_reference.html#aggregation-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#aggregation-primitives)<st
    c="55572">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55573">In this recipe, we will first create multiple features by aggregating
    existing variables.</st> <st c="55664">After that, we will combine the use of
    transfo</st><st c="55710">rm and aggregation primitives to highlight the true
    power</st> <st c="55769">of</st> `<st c="55772">featuretools</st>`<st c="55784">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55785">Getting ready</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="55799">In this recipe, we will use the</st> *<st c="55832">Online Retail
    II</st>* <st c="55848">dataset from the UCI Machine Learning Repository.</st>
    <st c="55899">This dataset has information about products (items), invoices, and
    customers.</st> <st c="55977">To follow along with this recipe, it is important
    to understand the nature of and the relationships between these entities and how
    to correctly set up an entity set with</st> `<st c="56147">featuretools</st>`<st
    c="56159">, which we described in the</st> *<st c="56187">Setting up an entity
    set and creating features automatically</st>* <st c="56247">recipe.</st> <st c="56256">Make</st>
    <st c="56260">sure you checked that recip</st><st c="56288">e out before proceeding
    with the</st> <st c="56322">next section.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56335">How to do it...</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="56351">Let’s begin by importing the libraries and getting the</st> <st
    c="56407">dataset ready:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56421">First, we’ll import</st> `<st c="56442">pandas</st>`<st c="56448">,</st>
    `<st c="56450">featuretools</st>`<st c="56462">, and the</st> <st c="56472">logical
    types:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="56599">Let’s load</st> <st c="56611">the dataset described in the</st>
    *<st c="56640">Technical</st>* *<st c="56650">requirements</st>* <st c="56662">section:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="56733">Let’s set up an</st> <st c="56750">entity set:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="56790">Let’s add the DataFrame to the entity set, highlighting that the</st>
    `<st c="56856">description</st>` <st c="56867">variable is a text variable,</st>
    `<st c="56897">customer_id</st>` <st c="56908">is categorical, and</st> `<st c="56929">invoice_date</st>`
    <st c="56941">is a</st> <st c="56947">datetime feature:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="57162">Let’s create a new DataFrame with a relationship to the DataFrame
    from</st> *<st c="57234">step 4</st>*<st c="57240">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="57375">Now, we add</st> <st c="57388">the second relationship, which
    is between customers and invoices.</st> <st c="57454">To do this, we indicate
    the base DataFrame, which we called</st> `<st c="57514">invoices</st>` <st c="57522">in</st>
    *<st c="57526">step 5</st>*<st c="57532">, we give the new DataFrame a name,</st>
    `<st c="57568">customers</st>`<st c="57577">, and we add a unique</st> <st c="57599">customer
    identifier:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="57730">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57735">For more details about</st> *<st c="57759">steps 4</st>* <st c="57766">to</st>
    *<st c="57770">5</st>*<st c="57771">, visit the</st> *<st c="57783">Setting up
    an entity set and creating features</st>* *<st c="57830">automatically</st>* <st
    c="57843">recipe.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57851">Let’s make a list with string names that identify the aggregation
    primitives we want</st> <st c="57937">to use:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="57991">Let’s create features by aggregating the data at the customer
    level.</st> <st c="58061">To do this, we set up the</st> `<st c="58087">dfs</st>`
    <st c="58090">class from</st> `<st c="58102">featuretools</st>`<st c="58114">,
    indicating</st> `<st c="58127">customers</st>` <st c="58136">as the target DataFrame
    and passing the aggregation primitives from</st> *<st c="58205">step 7</st>* <st
    c="58211">and an empty list to the</st> `<st c="58237">trans_primitives</st>`
    <st c="58253">parameter to prevent</st> `<st c="58275">dfs</st>` <st c="58278">from
    returning the</st> <st c="58298">default transformations:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="58465">Let’s display</st> <st c="58480">the names of the</st> <st c="58497">created
    features:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="58527">In the following output, we see the name features that were aggregated
    at the</st> <st c="58606">customer level:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="59975">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59980">Remember that</st> `<st c="59995">featuretools</st>` <st c="60007">names
    features with the function used to create them, followed by the DataFrame that
    was used in the computation, followed by the variable that was used in the computation.</st>
    <st c="60181">Thus,</st> `<st c="60187">MAX(data.price)</st>` <st c="60202">is
    the maximum price seen in the dataset for each customer.</st> <st c="60263">On
    the other hand,</st> `<st c="60282">MEAN(invoices.MAX(data.price))</st>` <st c="60312">is
    the mean value of all maximum prices observed in each invoice for a particular
    customer.</st> <st c="60405">That is, if a customer has six invoices, we first
    find the maximum price for</st> <st c="60482">each of the six invoices and then
    take the average of</st> <st c="60536">those values.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60549">Let’s now</st> <st c="60560">display the resulting DataFrame containing
    the original data and</st> <st c="60625">new features:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="60660">In the fol</st><st c="60671">lowing output, we see</st> *<st c="60694">some</st>*
    <st c="60698">of the variables in the DataFrame returned</st> <st c="60742">by</st>
    `<st c="60745">dfs</st>`<st c="60748">:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.12 – DataFrame with some of the features resulting from aggregations
    at the customer level](img/B22396_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="61524">Figure 9.12 – DataFrame with some of the features resulting from
    aggregations at the customer level</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61623">Due to space limitations, we can’t display the entire output of</st>
    *<st c="61688">step 10</st>*<st c="61695">, so make sure you execute it on your
    computer or visit our accompanying GitHub repository for more</st> <st c="61795">details:</st>
    [<st c="61804">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe6-Creating-features-with-aggregation-primitives.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe6-Creating-features-with-aggregation-primitives.ipynb)<st
    c="61976">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61977">To follow up, let’s combine what we learned from the recipes using
    transform primitives with the aggregation</st> <st c="62086">functions from this
    recipe.</st> <st c="62115">First, we will create new features from existing datetime
    and text variables; then, we will aggregate those features along with the numerical
    variables, at the</st> <st c="62275">customer level.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62290">Let’s make lists with date and</st> <st c="62322">text primitives:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="62391">Let’s make a list with an</st> <st c="62418">aggregation primitive:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="62466">Let’s now</st> <st c="62477">automatically create features by
    transforming and then</st> <st c="62532">aggregating variables:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="62723">The code from</st> *<st c="62738">step 13</st>* <st c="62745">triggers
    the creation of the features and their subsequent aggregation at the</st> <st
    c="62824">customer level.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="62839">Let’s display the names of the</st> <st c="62871">new features:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="62897">In the following output, we see the names of the</st> <st c="62947">created
    variables:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="63324">Note that in our recipes, we keep the creation of features to
    a minimum due to space limitations, but you can create as many features as you
    want and enr</st><st c="63478">ich your datasets dramatically with the functionality
    built</st> <st c="63539">into</st> `<st c="63544">featuretools</st>`<st c="63556">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="63557">How it works...</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="63573">In this recipe, we brought together the creation of features using
    transform primitives, which we</st> <st c="63672">discussed throughout the chapter,
    with the creation of features using</st> <st c="63742">aggregation primitives.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="63765">To create features with</st> `<st c="63790">featuretools</st>`
    <st c="63802">automatically, we first need to enter the data into an entity set
    and establish the relationships between the data.</st> <st c="63919">We discussed
    how to set up an entity set in the</st> *<st c="63967">Setting up an entity set
    and creating features</st>* *<st c="64014">automatically</st>* <st c="64027">recipe.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64035">To aggregate existing features, we used the</st> `<st c="64080">dfs</st>`
    <st c="64083">class.</st> <st c="64091">We created a list with a string corresponding
    to the aggregation primitives and passed it to the</st> `<st c="64188">agg_primitives</st>`
    <st c="64202">parameter from</st> `<st c="64218">dfs</st>`<st c="64221">. To aggregate
    existing variables without creating new features, we passed an empty list to the</st>
    `<st c="64317">trans_primitives</st>` <st c="64333">parameter</st> <st c="64344">of</st>
    `<st c="64347">dfs</st>`<st c="64350">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64351">The</st> `<st c="64356">customers</st>` <st c="64365">DataFrame
    is the child of the</st> `<st c="64396">invoice</st>` <st c="64403">DataFrame,
    which is, in turn, the child of the original data.</st> <st c="64466">Thus,</st>
    `<st c="64472">dfs</st>` <st c="64475">created aggregations from the original
    data and the pre-aggregated data for each invoice.</st> <st c="64566">Thus, the</st>
    `<st c="64576">MEAN(data.price)</st>` <st c="64592">feature consists of the mean
    price for an item bought by a customer calculated from the entire data, whereas</st>
    `<st c="64702">MEAN(invoices.MEAN(data.price))</st>` <st c="64733">calculates
    the mean price per invoice first and then takes the mean of those values for a
    customer.</st> <st c="64834">Thus, if a customer has five invoices,</st> `<st
    c="64873">featuretools</st>` <st c="64885">first calculates the mean price paid
    for each of those invoices and then takes the mean of those values.</st> <st c="64991">As
    such,</st> `<st c="65000">MEAN(data.price)</st>` <st c="65016">and</st> `<st c="65021">MEAN(invoices.MEAN(data.price))</st>`
    <st c="65052">are not the</st> <st c="65065">same feature.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65078">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65083">An aggregate primitive aggregates information for a unique identifier.</st>
    <st c="65155">Aggregate primitives use mathematical operations such as the mean,
    standard deviation, maximum and minimum values, the sum, and the skew coefficient
    for numerical variables.</st> <st c="65329">For categorical variables, aggregate
    primitives use the mode and the count of unique items.</st> <st c="65421">For
    unique ident</st><st c="65437">ifiers, aggregate primitives count the number</st>
    <st c="65484">of occurrences.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65499">Next, we combined</st> <st c="65518">the creation of new features
    from date and text variables with aggregation.</st> <st c="65594">To do this,
    we passed a list of strings corresponding to the transform primitives to the</st>
    `<st c="65683">trans_primitives</st>` <st c="65699">parameter, and another list
    of strings corresponding to the aggregation primitives to the</st> `<st c="65790">agg_primitives</st>`
    <st c="65804">parameter</st> <st c="65815">of</st> `<st c="65818">dfs</st>`<st
    c="65821">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65822">One of the outputs of</st> *<st c="65845">step 13</st>* <st c="65852">is
    a list of the new features.</st> <st c="65884">From these, we can identify features
    created from the first invoice date for each customer, such as</st> `<st c="65984">MONTH(first_invoices_time)</st>`
    <st c="66010">and</st> `<st c="66015">WEEKDAY(first_invoices_time)</st>`<st c="66043">.
    We can also see features that were aggregated from features created from text,
    such as</st> `<st c="66132">MEAN(data.NUM_WORDS(description))</st>` <st c="66165">and</st>
    `<st c="66170">MEAN(invoices.MEAN(data.NUM_WORDS(description)))</st>`<st c="66218">.
    Finally, we can see the aggregations of existing n</st><st c="66270">umerical
    variables, such as</st> `<st c="66299">MEAN(data.price)</st>` <st c="66315">and</st>
    `<st c="66320">MEAN(invoices.MEAN(data.price))</st>`<st c="66351">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66352">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66357">If you want to apply transform and aggregation primitives to specific
    variables, you can do so by specifying the primitive options as discussed</st>
    <st c="66502">here:</st> [<st c="66508">https://docs.featuretools.com/en/stable/guides/specifying_primitive_options.html</st>](https://docs.featuretools.com/en/stable/guides/specifying_primitive_options.html)<st
    c="66588">.</st>
  prefs: []
  type: TYPE_NORMAL
