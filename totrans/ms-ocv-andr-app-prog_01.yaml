- en: Chapter 1. Applying Effects to Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, an image contains more information than required for any particular
    task. For this reason, we need to preprocess the images so that they contain only
    as much information as required for the application, thereby reducing the computing
    time needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the different preprocessing operations,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Blurring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: De-noising
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharpening
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erosion and dilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thresholding and adaptive thresholding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, we will see how you can integrate OpenCV into your
    existing Android applications.
  prefs: []
  type: TYPE_NORMAL
- en: Before we take a look at the various feature detection algorithms and their
    implementations, let's first build a basic Android application to which we will
    keep adding feature detection algorithms, as we go through this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we see an image, we perceive it as colors and objects. However, a computer
    vision system sees it as a matrix of numbers (see the following image). These
    numbers are interpreted differently, depending on the color model used. The computer
    cannot directly detect patterns or objects in the image. The aim of computer vision
    systems is to interpret this matrix of numbers as an object of a particular type.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](img/B02052_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Representation of a binary image
  prefs: []
  type: TYPE_NORMAL
- en: Setting up OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV is the short form of Open Source Computer Vision library. It is the most
    widely used computer vision library. It is a collection of commonly used functions
    that perform operations related to computer vision. OpenCV has been natively written
    in C/C++, but has wrappers for Python, Java, and any JVM language, which is designed
    to create the Java byte code, such as Scala and Clojure. Since most of the Android
    app development is done in C++/Java, OpenCV has also been ported as an SDK that
    developers can use to implement it in their apps and make them vision enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now take a look at how to get started with setting up OpenCV for the
    Android platform, and start our journey. We will use Android Studio as our IDE
    of choice, but any other IDE should work just as well with slight modifications.
    Follow these steps in order to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Download Android Studio from [https://developer.android.com/sdk/](https://developer.android.com/sdk/)
    and OpenCV4Android SDK from [http://sourceforge.net/projects/opencvlibrary/files/opencv-android/](http://sourceforge.net/projects/opencvlibrary/files/opencv-android/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the two files to a known location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a normal Android Project and name it `FirstOpenCVApp`. Navigate to **File**
    | **Import**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `OpenCV_SDK_location/sdk/java/` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Build** | **Rebuild Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **File** | **Project Structure**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the OpenCV module to your app by selecting the **app** module in the left
    column. Click on the green in the dependencies tab, and finally, select the OpenCV
    module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You are now ready to use OpenCV in your Android project. It should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Setting up OpenCV](img/B02052_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Storing images in OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV stores images as a custom object called **Mat**. This object stores the
    information such as rows, columns, data, and so on that can be used to uniquely
    identify and recreate the image when required. Different images contain different
    amounts of data. For example, a colored image contains more data than a grayscale
    version of the same image. This is because a colored image is a 3-channel image
    when using the RGB model, and a grayscale image is a 1-channel image. The following
    figures show how 1-channel and multichannel (here, RGB) images are stored (these
    images are taken from [docs.opencv.org](http://docs.opencv.org)).
  prefs: []
  type: TYPE_NORMAL
- en: 'A 1-channel representation of an image is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing images in OpenCV](img/B02052_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A grayscale (1-channel) image representation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A more elaborate form of an image is the RGB representation, which is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing images in OpenCV](img/B02052_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A RGB (3-channel) image representation
  prefs: []
  type: TYPE_NORMAL
- en: 'In the grayscale image, the numbers represent the intensity of that particular
    color. They are represented on a scale of 0-255 when using integer representations,
    with 0 being pure black and 255 being pure white. If we use a floating point representation,
    the pixels are represented on a scale of 0-1, with 0 being pure black and 1 being
    pure white. In an RGB image in OpenCV, the first channel corresponds to blue color,
    second channel corresponds to green color, and the third channel corresponds to
    red color. Thus, each channel represents the intensity of any particular color.
    As we know that red, green, and blue are primary colors, they can be combined
    in different proportions to generate any color visible to the human eye. The following
    figure shows the different colors and their respective RGB equivalents in an integer
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing images in OpenCV](img/B02052_01_05.jpg)![Storing images in OpenCV](img/B02052_01_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have seen how an image is represented in computing terms, we will
    see how we can modify the pixel values so that they need less computation time
    when using them for the actual task at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Linear filters in OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all like sharp images. Who doesn't, right? However, there is a trade-off
    that needs to be made. More information means that the image will require more
    computation time to complete the same task as compared to an image which has less
    information. So, to solve this problem, we apply blurring operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the linear filtering algorithms make use of an array of numbers called
    a kernel. A kernel can be thought of as a sliding window that passes over each
    pixel and calculates the output value for that pixel. This can be understood more
    clearly by taking a look at the following figure (this image of linear filtering/convolution
    is taken from [http://test.virtual-labs.ac.in/labs/cse19/neigh/convolution.jpg](http://test.virtual-labs.ac.in/labs/cse19/neigh/convolution.jpg)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linear filters in OpenCV](img/B02052_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, a 3 x 3 kernel is used on a 10 x 10 image.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most general operations used for linear filtering is convolution.
    The values in a kernel are coefficients for multiplication of the corresponding
    pixels. The final result is stored in the anchor point, generally, the center
    of the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linear filters in OpenCV](img/B02052_01_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linear filtering operations are generally not in-place operations, as for each
    pixel we use the values present in the original image, and not the modified values.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common uses of linear filtering is to remove the noise. Noise
    is the random variation in brightness or color information in images. We use blurring
    operations to reduce the noise in images.
  prefs: []
  type: TYPE_NORMAL
- en: The mean blur method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A mean filter is the simplest form of blurring. It calculates the mean of all
    the pixels that the given kernel superimposes. The kernel that is used for this
    kind of operation is a simple Mat that has all its values as 1, that is, each
    neighboring pixel is given the same weightage.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we will pick an image from the gallery and apply the respective
    image transformations. For this, we will add basic code. We are assuming that
    OpenCV4Android SDK has been set up and is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the first OpenCV app that we created at the start of the chapter
    for the purpose of this chapter. At the time of creating the project, the default
    names will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The mean blur method](img/B02052_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a new activity by right-clicking on the Java folder and navigate to **New**
    | **Activity**. Then, select **Blank Activity**. Name the activity `MainActivity.java`
    and the XML file `activity_main.xml`. Go to `res/menu/menu_main.xml`. Add an item
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `MainActivity` is the activity that we will be using to perform our OpenCV
    specific tasks, we need to instantiate OpenCV. Add this as a global member of
    `MainActivity.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is a callback, which checks whether the OpenCV manager is installed. We
    need the OpenCV manager app to be installed on the device because it has all of
    the OpenCV functions defined. If we do not wish to use the OpenCV manager, we
    can have the functions present natively, but the APK size then increases significantly.
    If the OpenCV manager is not present, the app redirects the user to the Play Store
    to download it. The function call in `onResume` loads OpenCV for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we will add a button to `activity_home.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `HomeActivity.java`, we will instantiate this button, and set an `onClickListener`
    to this button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, `MEAN_BLUR` is a constant with value `1` that specifies
    the type of operation that we want to perform.
  prefs: []
  type: TYPE_NORMAL
- en: Here we have added extra to the activity bundle. This is to differentiate which
    operation we will be performing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `activity_main.xml`. Replace everything with this code snippet. This snippet
    adds two `ImageView` items: one for the original image and one for the processed
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to programmatically link these `ImageView` items to the `ImageView`
    items in Java in our `MainActivity.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, the Mat and ImageViews have been made global to the class so that we can
    use them in other functions, without passing them as parameters. We will use the
    `ACTION_MODE` variable to identify the required operation to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will add the code to load an image from the gallery. For this, we will
    use the menu button we created earlier. We will load the `menu_main.xml` file,
    when you click on the menu button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will add the listener that will perform the desired action when an
    action item is selected. We will use `Intent.ACTION_PICK` to get an image from
    the gallery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have used `startActivityForResult()`. This will send the
    selected image to `onActivityResult()`. We will use this to get the Bitmap and
    convert it to an OpenCV Mat. Once the operation is complete, we want to get the
    image back from the other activity. For this, we make a new function `onActivityResult()`
    that gets called when the activity has completed its work, and is returned to
    the calling activity. Add the following code to `onActivityResult()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply mean blur to an image, we use the OpenCV provided function `blur()`.
    We have used a 3 x 3 kernel for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will set this image in an ImageView to see the results of the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![The mean blur method](img/B02052_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Original Image (Left) and Image after applying Mean Blur (Right)
  prefs: []
  type: TYPE_NORMAL
- en: The Gaussian blur method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Gaussian blur is the most commonly used method of blurring. The Gaussian
    kernel is obtained using the Gaussian function given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Gaussian blur method](img/B02052_01_23.jpg)![The Gaussian blur method](img/B02052_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Gaussian Function in one and two dimensions
  prefs: []
  type: TYPE_NORMAL
- en: 'The anchor pixel is considered to be at (0, 0). As we can see, the pixels closer
    to the anchor pixel are given a higher weightage than those further away from
    it. This is generally the ideal scenario, as the nearby pixels should influence
    the result of a particular pixel more than those further away. The Gaussian kernels
    of size 3, 5, and 7 are shown in the following figure (image of ''Gaussian kernels''
    taken from [http://www1.adept.com/main/KE/DATA/ACE/AdeptSight_User/ImageProcessing_Operations.html](http://www1.adept.com/main/KE/DATA/ACE/AdeptSight_User/ImageProcessing_Operations.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Gaussian blur method](img/B02052_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These are the Gaussian kernels of size 3 x 3, 5 x 5 and 7 x 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the Gaussian blur in your application, OpenCV provides a built-in function
    called **GaussianBlur**. We will use this and get the following resulting image.
    We will add a new case to the same switch block we used earlier. For this code,
    declare a constant `GAUSSIAN_BLUR` with value 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![The Gaussian blur method](img/B02052_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Image after applying Gaussian blur on the original image
  prefs: []
  type: TYPE_NORMAL
- en: The median blur method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the common types of noise present in images is called salt-and-pepper
    noise. In this kind of noise, sparsely occurring black and white pixels are distributed
    over the image. To remove this type of noise, we use median blur. In this kind
    of blur, we arrange the pixels covered by our kernel in ascending/descending order,
    and set the value of the middle element as the final value of the anchor pixel.
    The advantage of using this type of filtering is that salt-and-pepper noise is
    sparsely occurring, and so its influence is only over a small number of pixels
    when averaging their values. Thus, over a bigger area, the number of noise pixels
    is fewer than the number of pixels that are useful, as shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The median blur method](img/B02052_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Example of salt-and-pepper noise
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply median blur in OpenCV, we use the built-in function `medianBlur`.
    As in the previous cases, we have to add a button and add the `OnClickListener`
    functions. We will add another case condition for this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![The median blur method](img/B02052_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Resulting image after applying median blur
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Median blur does not use convolution.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom kernels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how different types of kernels affect the image. What if we want
    to create our own kernels for different applications that aren't natively offered
    by OpenCV? In this section, we will see how we can achieve just that. We will
    try to form a sharper image from a given input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sharpening can be thought of as a linear filtering operation where the anchor
    pixel has a high weightage and the surrounding pixels have a low weightage. A
    kernel satisfying this constraint is shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 | -1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| -1 | 5 | -1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | -1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'We will use this kernel to perform the convolution on our image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here we have given the image depth as `16SC1`. This means that each pixel in
    our image contains a 16-bit signed integer (16S) and the image has 1 channel (C1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will use the `filter2D()`function, which performs the actual convolution
    when given the input image and a kernel. We will show the image in an ImageView.
    We will add another case to the switch block created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating custom kernels](img/B02052_01_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Original image (left) and sharpened image (right)
  prefs: []
  type: TYPE_NORMAL
- en: Morphological operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Morphological operations are a set of operations that process an image based
    on the features of the image and a structuring element. These generally work on
    binary or grayscale images. We will take a look at some basic morphological operations
    before moving on to more advance ones.
  prefs: []
  type: TYPE_NORMAL
- en: Dilation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dilation is a method by which the bright regions of an image are expanded. To
    achieve this, we take a kernel of the desired size and replace the anchor pixel
    with the maximum value overlapped by the kernel. Dilation can be used to merge
    objects that might have been broken off.
  prefs: []
  type: TYPE_NORMAL
- en: '![Dilation](img/B02052_01_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A binary image (left) and the result after applying dilation (right)
  prefs: []
  type: TYPE_NORMAL
- en: To apply this operation, we use the `dilate()`function. We need to use a kernel
    to perform dilation. We use the `getStructuringElement()` OpenCV function to get
    the required kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenCV provides `MORPH_RECT`, `MORPH_CROSS`, and `MORPH_ELLIPSE` as options
    to create our required kernels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Dilation](img/B02052_01_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Original image (left) and dilated image (right)
  prefs: []
  type: TYPE_NORMAL
- en: If we use a rectangular structuring element, the image grows in the shape of
    a rectangle. Similarly, if we use an elliptical structuring element, the image
    grows in the shape of an ellipse.
  prefs: []
  type: TYPE_NORMAL
- en: Erosion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similarly, erosion is a method by which the dark regions of an image are expanded.
    To achieve this, we take a kernel of the desired size and replace the anchor pixel
    by the minimum value overlapped by the kernel. Erosion can be used to remove the
    noise from images.
  prefs: []
  type: TYPE_NORMAL
- en: '![Erosion](img/B02052_01_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A binary image (left) and the result after applying erosion (right)
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply this operation, we use the `erode()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![Erosion](img/B02052_01_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Original image (left) and eroded image (right)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Erosion and dilation are not inverse operations.
  prefs: []
  type: TYPE_NORMAL
- en: Thresholding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thresholding is the method of segmenting out sections of an image that we would
    like to analyze. The value of each pixel is compared to a predefined threshold
    value and based on this result, we modify the value of the pixel. OpenCV provides
    five types of thresholding operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform thresholding, we will use the following code as a template and change
    the parameters as per the kind of thresholding required. We need to replace `THRESH_CONSTANT`
    with the constant for the required method of thresholding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, `100` is the threshold value and `255` is the maximum value (the value
    of pure white).
  prefs: []
  type: TYPE_NORMAL
- en: 'The constants are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Thresholding Method Name | Thresholding Function | Constant |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Binary threshold | ![Thresholding](img/B02052_01_24_a.jpg) | `THRESH_BINARY`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Threshold to zero | ![Thresholding](img/B02052_01_24_b.jpg) | `THRESH_TOZERO`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Truncate | ![Thresholding](img/B02052_01_24_c.jpg) | `THRESH_TRUNC` |'
  prefs: []
  type: TYPE_TB
- en: '| Binary threshold, inverted | ![Thresholding](img/B02052_01_24_d.jpg) | `THRESH_BINARY_INV`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Threshold to zero, inverted | ![Thresholding](img/B02052_01_24_e.jpg) | `THRESH_TOZERO_INV`
    |'
  prefs: []
  type: TYPE_TB
- en: 'The following image for thresholding results is taken from [http://docs.opencv.org/trunk/d7/d4d/tutorial_py_thresholding.html](http://docs.opencv.org/trunk/d7/d4d/tutorial_py_thresholding.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Thresholding](img/B02052_01_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adaptive thresholding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting a global threshold value may not be the best option when performing
    segmentation. Lighting conditions affect the intensity of pixels. So, to overcome
    this limitation, we will try to calculate the threshold value for any pixel based
    on its neighboring pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use three parameters to calculate the adaptive threshold of an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adaptive method**: The following are the two methods we will use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ADAPTIVE_THRESH_MEAN_C`: The threshold value is the mean of the neighboring
    pixels'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADAPTIVE_THRESH_GAUSSIAN_C`: The threshold value is the weighted sum of the
    neighboring pixel values, where weights are Gaussian kernels'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block Size**: This is the size of the neighborhood'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**C**: This is the constant that has to be subtracted from the mean/weighted
    mean calculated for each pixel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Adaptive thresholding](img/B02052_01_20.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Original image (left) and image after applying Adaptive thresholding (right)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, the resulting image has a lot of noise present. This can be avoided by
    applying a blurring operation before applying adaptive thresholding, so as to
    smooth the image.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learnt how to get started with using OpenCV in your
    Android project. Then we looked at different filters in image processing, especially
    linear filters, and how they can be implemented on an Android device. These filters
    will later form the basis of any computer vision application that you try to build.
    In the following chapters, we will look at more complex image filters, and also
    see how to extract information from the images in the form of edges, corners,
    and the like.
  prefs: []
  type: TYPE_NORMAL
