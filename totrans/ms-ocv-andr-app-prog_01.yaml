- en: Chapter 1. Applying Effects to Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 将效果应用于图像
- en: Generally, an image contains more information than required for any particular
    task. For this reason, we need to preprocess the images so that they contain only
    as much information as required for the application, thereby reducing the computing
    time needed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，图像包含的信息比任何特定任务所需的信息要多。因此，我们需要预处理图像，以便它们只包含应用程序所需的信息，从而减少所需的计算时间。
- en: 'In this chapter, we will learn about the different preprocessing operations,
    which are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习不同的预处理操作，具体如下：
- en: Blurring
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊
- en: De-noising
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去噪
- en: Sharpening
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锐化
- en: Erosion and dilation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 腐蚀和膨胀
- en: Thresholding and adaptive thresholding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阈值和自适应阈值
- en: At the end of this chapter, we will see how you can integrate OpenCV into your
    existing Android applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将看到如何将OpenCV集成到现有的Android应用程序中。
- en: Before we take a look at the various feature detection algorithms and their
    implementations, let's first build a basic Android application to which we will
    keep adding feature detection algorithms, as we go through this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看各种特征检测算法及其实现之前，让我们首先构建一个基本的Android应用程序，我们将在此章中逐步添加特征检测算法。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用
- en: When we see an image, we perceive it as colors and objects. However, a computer
    vision system sees it as a matrix of numbers (see the following image). These
    numbers are interpreted differently, depending on the color model used. The computer
    cannot directly detect patterns or objects in the image. The aim of computer vision
    systems is to interpret this matrix of numbers as an object of a particular type.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到一张图片时，我们将其感知为颜色和物体。然而，计算机视觉系统将其视为一个数字矩阵（见以下图片）。这些数字根据所使用的颜色模型被不同地解释。计算机不能直接在图像中检测模式或物体。计算机视觉系统的目标是解释这个数字矩阵为特定类型的物体。
- en: '![Getting started](img/B02052_01_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用](img/B02052_01_01.jpg)'
- en: Representation of a binary image
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 二值图像的表示
- en: Setting up OpenCV
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置OpenCV
- en: OpenCV is the short form of Open Source Computer Vision library. It is the most
    widely used computer vision library. It is a collection of commonly used functions
    that perform operations related to computer vision. OpenCV has been natively written
    in C/C++, but has wrappers for Python, Java, and any JVM language, which is designed
    to create the Java byte code, such as Scala and Clojure. Since most of the Android
    app development is done in C++/Java, OpenCV has also been ported as an SDK that
    developers can use to implement it in their apps and make them vision enabled.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV是开源计算机视觉库的简称。它是使用最广泛的计算机视觉库。它是一组常用的函数，执行与计算机视觉相关的操作。OpenCV是用C/C++原生编写的，但提供了Python、Java以及任何JVM语言的包装器，这些包装器旨在创建Java字节码，例如Scala和Clojure。由于大多数Android应用程序开发都是在C++/Java中进行的，因此OpenCV也被移植为SDK，开发者可以使用它在其应用程序中实现，并使它们具有视觉功能。
- en: 'We will now take a look at how to get started with setting up OpenCV for the
    Android platform, and start our journey. We will use Android Studio as our IDE
    of choice, but any other IDE should work just as well with slight modifications.
    Follow these steps in order to get started:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何开始设置Android平台的OpenCV，并开始我们的旅程。我们将使用Android Studio作为我们的首选IDE，但任何其他IDE经过轻微修改后也应该可以工作。按照以下步骤开始：
- en: Download Android Studio from [https://developer.android.com/sdk/](https://developer.android.com/sdk/)
    and OpenCV4Android SDK from [http://sourceforge.net/projects/opencvlibrary/files/opencv-android/](http://sourceforge.net/projects/opencvlibrary/files/opencv-android/).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://developer.android.com/sdk/](https://developer.android.com/sdk/)下载Android
    Studio，从[http://sourceforge.net/projects/opencvlibrary/files/opencv-android/](http://sourceforge.net/projects/opencvlibrary/files/opencv-android/)下载OpenCV4Android
    SDK。
- en: Extract the two files to a known location.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个文件提取到已知位置。
- en: Create a normal Android Project and name it `FirstOpenCVApp`. Navigate to **File**
    | **Import**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个普通的Android项目，并将其命名为`FirstOpenCVApp`。导航到**文件** | **导入**。
- en: Select the `OpenCV_SDK_location/sdk/java/` directory.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`OpenCV_SDK_location/sdk/java/`目录。
- en: Navigate to **Build** | **Rebuild Project**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**构建** | **重建项目**。
- en: Navigate to **File** | **Project Structure**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**文件** | **项目结构**。
- en: Add the OpenCV module to your app by selecting the **app** module in the left
    column. Click on the green in the dependencies tab, and finally, select the OpenCV
    module.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在左侧列中选择**app**模块，将OpenCV模块添加到您的应用程序中。在依赖项选项卡中点击绿色按钮，最后选择OpenCV模块。
- en: 'You are now ready to use OpenCV in your Android project. It should look like
    this:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你已经准备好在你的Android项目中使用OpenCV了。它应该看起来像这样：
- en: '![Setting up OpenCV](img/B02052_01_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![设置OpenCV](img/B02052_01_02.jpg)'
- en: Storing images in OpenCV
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCV中的图像存储
- en: OpenCV stores images as a custom object called **Mat**. This object stores the
    information such as rows, columns, data, and so on that can be used to uniquely
    identify and recreate the image when required. Different images contain different
    amounts of data. For example, a colored image contains more data than a grayscale
    version of the same image. This is because a colored image is a 3-channel image
    when using the RGB model, and a grayscale image is a 1-channel image. The following
    figures show how 1-channel and multichannel (here, RGB) images are stored (these
    images are taken from [docs.opencv.org](http://docs.opencv.org)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV将图像存储为称为**Mat**的自定义对象。该对象存储有关行、列、数据等信息，这些信息可用于在需要时唯一识别和重新创建图像。不同的图像包含不同数量的数据。例如，彩色图像比相同图像的灰度版本包含更多的数据。这是因为使用RGB模型时，彩色图像是3通道图像，而灰度图像是1通道图像。以下图显示了如何存储1通道和多通道（此处为RGB）图像（这些图像来自[docs.opencv.org](http://docs.opencv.org))：
- en: 'A 1-channel representation of an image is shown as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的1通道表示如下：
- en: '![Storing images in OpenCV](img/B02052_01_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![OpenCV中的图像存储](img/B02052_01_03.jpg)'
- en: 'A grayscale (1-channel) image representation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度（1通道）图像表示：
- en: 'A more elaborate form of an image is the RGB representation, which is shown
    as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的一种更详细的形式是RGB表示，如下所示：
- en: '![Storing images in OpenCV](img/B02052_01_04.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![OpenCV中的图像存储](img/B02052_01_04.jpg)'
- en: A RGB (3-channel) image representation
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: RGB（3通道）图像表示
- en: 'In the grayscale image, the numbers represent the intensity of that particular
    color. They are represented on a scale of 0-255 when using integer representations,
    with 0 being pure black and 255 being pure white. If we use a floating point representation,
    the pixels are represented on a scale of 0-1, with 0 being pure black and 1 being
    pure white. In an RGB image in OpenCV, the first channel corresponds to blue color,
    second channel corresponds to green color, and the third channel corresponds to
    red color. Thus, each channel represents the intensity of any particular color.
    As we know that red, green, and blue are primary colors, they can be combined
    in different proportions to generate any color visible to the human eye. The following
    figure shows the different colors and their respective RGB equivalents in an integer
    format:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在灰度图像中，数字代表该特定颜色的强度。当使用整数表示时，它们在0-255的范围内表示，其中0是纯黑色，255是纯白色。如果我们使用浮点表示，像素在0-1的范围内表示，其中0是纯黑色，1是纯白色。在OpenCV中的RGB图像中，第一个通道对应蓝色，第二个通道对应绿色，第三个通道对应红色。因此，每个通道代表任何特定颜色的强度。正如我们所知，红色、绿色和蓝色是原色，它们可以以不同的比例组合以生成人类眼睛可见的任何颜色。以下图显示了不同颜色及其相应的整数格式下的RGB等效值：
- en: '![Storing images in OpenCV](img/B02052_01_05.jpg)![Storing images in OpenCV](img/B02052_01_21.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![OpenCV中的图像存储](img/B02052_01_05.jpg)![OpenCV中的图像存储](img/B02052_01_21.jpg)'
- en: Now that we have seen how an image is represented in computing terms, we will
    see how we can modify the pixel values so that they need less computation time
    when using them for the actual task at hand.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了图像在计算术语中的表示方式，我们将看到如何修改像素值，以便在执行实际任务时需要更少的计算时间。
- en: Linear filters in OpenCV
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCV中的线性滤波器
- en: We all like sharp images. Who doesn't, right? However, there is a trade-off
    that needs to be made. More information means that the image will require more
    computation time to complete the same task as compared to an image which has less
    information. So, to solve this problem, we apply blurring operations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都喜欢清晰的图像。谁不喜欢呢？然而，这里需要做出权衡。更多信息意味着图像在完成相同任务时需要比信息较少的图像更多的计算时间。因此，为了解决这个问题，我们应用模糊操作。
- en: 'Many of the linear filtering algorithms make use of an array of numbers called
    a kernel. A kernel can be thought of as a sliding window that passes over each
    pixel and calculates the output value for that pixel. This can be understood more
    clearly by taking a look at the following figure (this image of linear filtering/convolution
    is taken from [http://test.virtual-labs.ac.in/labs/cse19/neigh/convolution.jpg](http://test.virtual-labs.ac.in/labs/cse19/neigh/convolution.jpg)):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '许多线性滤波算法都使用一个称为核的数字数组。核可以被视为一个滑动的窗口，它遍历每个像素并计算该像素的输出值。通过查看以下图示可以更清楚地理解这一点（此线性滤波/卷积图像取自[http://test.virtual-labs.ac.in/labs/cse19/neigh/convolution.jpg](http://test.virtual-labs.ac.in/labs/cse19/neigh/convolution.jpg)):'
- en: '![Linear filters in OpenCV](img/B02052_01_06.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![OpenCV中的线性滤波器](img/B02052_01_06.jpg)'
- en: In the preceding figure, a 3 x 3 kernel is used on a 10 x 10 image.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，一个3 x 3的核被应用于一个10 x 10的图像。
- en: 'One of the most general operations used for linear filtering is convolution.
    The values in a kernel are coefficients for multiplication of the corresponding
    pixels. The final result is stored in the anchor point, generally, the center
    of the kernel:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 用于线性滤波的最通用操作之一是卷积。核中的值是对应像素乘法系数。最终结果存储在锚点，通常是核的中心：
- en: '![Linear filters in OpenCV](img/B02052_01_22.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![OpenCV中的线性滤波器](img/B02052_01_22.jpg)'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Linear filtering operations are generally not in-place operations, as for each
    pixel we use the values present in the original image, and not the modified values.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 线性滤波操作通常不是就地操作，因为对于每个像素，我们使用原始图像中的值，而不是修改后的值。
- en: One of the most common uses of linear filtering is to remove the noise. Noise
    is the random variation in brightness or color information in images. We use blurring
    operations to reduce the noise in images.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 线性滤波最常见的一种用途是去除噪声。噪声是图像中亮度或颜色信息的随机变化。我们使用模糊操作来减少图像中的噪声。
- en: The mean blur method
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 均值模糊方法
- en: A mean filter is the simplest form of blurring. It calculates the mean of all
    the pixels that the given kernel superimposes. The kernel that is used for this
    kind of operation is a simple Mat that has all its values as 1, that is, each
    neighboring pixel is given the same weightage.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 均值滤波是最简单的模糊形式。它计算给定核覆盖的所有像素的平均值。用于此类操作的核是一个简单的Mat，其所有值均为1，即每个相邻像素具有相同的权重。
- en: For this chapter, we will pick an image from the gallery and apply the respective
    image transformations. For this, we will add basic code. We are assuming that
    OpenCV4Android SDK has been set up and is running.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将从图库中选择一张图片并应用相应的图像变换。为此，我们将添加基本代码。我们假设OpenCV4Android SDK已设置并正在运行。
- en: 'We can use the first OpenCV app that we created at the start of the chapter
    for the purpose of this chapter. At the time of creating the project, the default
    names will be as shown in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用本章开头创建的第一个OpenCV应用程序来完成本章的目的。在创建项目时，默认名称将如下所示：
- en: '![The mean blur method](img/B02052_01_07.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![均值模糊方法](img/B02052_01_07.jpg)'
- en: 'Add a new activity by right-clicking on the Java folder and navigate to **New**
    | **Activity**. Then, select **Blank Activity**. Name the activity `MainActivity.java`
    and the XML file `activity_main.xml`. Go to `res/menu/menu_main.xml`. Add an item
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Java文件夹上右键单击并导航到**新建** | **活动**来添加一个新的活动。然后，选择**空白活动**。将活动命名为`MainActivity.java`，XML文件命名为`activity_main.xml`。转到`res/menu/menu_main.xml`。添加如下项：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since `MainActivity` is the activity that we will be using to perform our OpenCV
    specific tasks, we need to instantiate OpenCV. Add this as a global member of
    `MainActivity.java`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`MainActivity`是我们将用于执行OpenCV特定任务的活动，我们需要实例化OpenCV。将其添加为`MainActivity.java`的全局成员：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a callback, which checks whether the OpenCV manager is installed. We
    need the OpenCV manager app to be installed on the device because it has all of
    the OpenCV functions defined. If we do not wish to use the OpenCV manager, we
    can have the functions present natively, but the APK size then increases significantly.
    If the OpenCV manager is not present, the app redirects the user to the Play Store
    to download it. The function call in `onResume` loads OpenCV for use.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个回调，它检查OpenCV管理器是否已安装。我们需要在设备上安装OpenCV管理器应用程序，因为它定义了所有OpenCV函数。如果我们不希望使用OpenCV管理器，我们可以将函数以本地方式提供，但这样APK的大小会显著增加。如果OpenCV管理器不存在，应用程序将重定向用户到Play
    Store下载它。`onResume`中的函数调用加载OpenCV以供使用。
- en: 'Next we will add a button to `activity_home.xml`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向`activity_home.xml`添加一个按钮：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, in `HomeActivity.java`, we will instantiate this button, and set an `onClickListener`
    to this button:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`HomeActivity.java`中，我们将实例化这个按钮，并为此按钮设置一个`onClickListener`：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)下载您购买的所有Packt Publishing书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: In the preceding code, `MEAN_BLUR` is a constant with value `1` that specifies
    the type of operation that we want to perform.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`MEAN_BLUR`是一个值为`1`的常量，它指定了我们想要执行的操作类型。
- en: Here we have added extra to the activity bundle. This is to differentiate which
    operation we will be performing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在活动包中添加了额外的信息。这是为了区分我们将执行哪种操作。
- en: 'Open `activity_main.xml`. Replace everything with this code snippet. This snippet
    adds two `ImageView` items: one for the original image and one for the processed
    image:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`。将所有内容替换为以下代码片段。此片段添加了两个`ImageView`项目：一个用于原始图像，一个用于处理后的图像：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to programmatically link these `ImageView` items to the `ImageView`
    items in Java in our `MainActivity.java`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以编程方式将这些`ImageView`项目链接到我们的`MainActivity.java`中的`ImageView`项目：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the Mat and ImageViews have been made global to the class so that we can
    use them in other functions, without passing them as parameters. We will use the
    `ACTION_MODE` variable to identify the required operation to be performed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Mat和ImageView已经被设置为类的全局变量，这样我们就可以在其他函数中使用它们，而无需将它们作为参数传递。我们将使用`ACTION_MODE`变量来识别要执行的操作。
- en: 'Now we will add the code to load an image from the gallery. For this, we will
    use the menu button we created earlier. We will load the `menu_main.xml` file,
    when you click on the menu button:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加从图库加载图像的代码。为此，我们将使用我们之前创建的菜单按钮。当您点击菜单按钮时，我们将加载`menu_main.xml`文件：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then we will add the listener that will perform the desired action when an
    action item is selected. We will use `Intent.ACTION_PICK` to get an image from
    the gallery:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个监听器，当选择操作项时执行所需操作。我们将使用`Intent.ACTION_PICK`从图库中获取图像：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, we have used `startActivityForResult()`. This will send the
    selected image to `onActivityResult()`. We will use this to get the Bitmap and
    convert it to an OpenCV Mat. Once the operation is complete, we want to get the
    image back from the other activity. For this, we make a new function `onActivityResult()`
    that gets called when the activity has completed its work, and is returned to
    the calling activity. Add the following code to `onActivityResult()`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了`startActivityForResult()`。这将发送选定的图像到`onActivityResult()`。我们将使用这个方法来获取Bitmap并将其转换为OpenCV
    Mat。一旦操作完成，我们希望从其他活动获取图像。为此，我们创建了一个新的函数`onActivityResult()`，当活动完成其工作并返回调用活动时会被调用。将以下代码添加到`onActivityResult()`中：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To apply mean blur to an image, we use the OpenCV provided function `blur()`.
    We have used a 3 x 3 kernel for this purpose:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要对图像应用均值模糊，我们使用OpenCV提供的`blur()`函数。我们为此目的使用了一个3 x 3的核：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we will set this image in an ImageView to see the results of the operation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将此图像设置在ImageView中，以查看操作的结果：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![The mean blur method](img/B02052_01_08.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![均值模糊方法](img/B02052_01_08.jpg)'
- en: Original Image (Left) and Image after applying Mean Blur (Right)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 原始图像（左侧）和应用均值模糊后的图像（右侧）
- en: The Gaussian blur method
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高斯模糊方法
- en: 'The Gaussian blur is the most commonly used method of blurring. The Gaussian
    kernel is obtained using the Gaussian function given as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯模糊是最常用的模糊方法。高斯核是通过以下给出的高斯函数获得的：
- en: '![The Gaussian blur method](img/B02052_01_23.jpg)![The Gaussian blur method](img/B02052_01_09.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![高斯模糊方法](img/B02052_01_23.jpg)![高斯模糊方法](img/B02052_01_09.jpg)'
- en: The Gaussian Function in one and two dimensions
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一维和二维的高斯函数
- en: 'The anchor pixel is considered to be at (0, 0). As we can see, the pixels closer
    to the anchor pixel are given a higher weightage than those further away from
    it. This is generally the ideal scenario, as the nearby pixels should influence
    the result of a particular pixel more than those further away. The Gaussian kernels
    of size 3, 5, and 7 are shown in the following figure (image of ''Gaussian kernels''
    taken from [http://www1.adept.com/main/KE/DATA/ACE/AdeptSight_User/ImageProcessing_Operations.html](http://www1.adept.com/main/KE/DATA/ACE/AdeptSight_User/ImageProcessing_Operations.html)):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点像素被认为是位于（0，0）。正如我们所见，靠近锚点像素的像素比远离它的像素赋予更高的权重。这通常是理想的情况，因为附近的像素应该比远离的像素对特定像素的结果有更大的影响。以下图中显示了大小为3、5和7的高斯核（“高斯核”图像取自[http://www1.adept.com/main/KE/DATA/ACE/AdeptSight_User/ImageProcessing_Operations.html](http://www1.adept.com/main/KE/DATA/ACE/AdeptSight_User/ImageProcessing_Operations.html)）：
- en: '![The Gaussian blur method](img/B02052_01_10.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![高斯模糊方法](img/B02052_01_10.jpg)'
- en: These are the Gaussian kernels of size 3 x 3, 5 x 5 and 7 x 7.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是大小为3 x 3、5 x 5和7 x 7的高斯核。
- en: 'To use the Gaussian blur in your application, OpenCV provides a built-in function
    called **GaussianBlur**. We will use this and get the following resulting image.
    We will add a new case to the same switch block we used earlier. For this code,
    declare a constant `GAUSSIAN_BLUR` with value 2:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的应用程序中使用高斯模糊，OpenCV提供了一个名为**GaussianBlur**的内置函数。我们将使用此函数并得到以下结果图像。我们将向之前使用的相同switch块添加一个新情况。对于此代码，声明一个常量`GAUSSIAN_BLUR`，其值为2：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![The Gaussian blur method](img/B02052_01_11.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![高斯模糊方法](img/B02052_01_11.jpg)'
- en: Image after applying Gaussian blur on the original image
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对原始图像应用高斯模糊后的图像
- en: The median blur method
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中值模糊方法
- en: 'One of the common types of noise present in images is called salt-and-pepper
    noise. In this kind of noise, sparsely occurring black and white pixels are distributed
    over the image. To remove this type of noise, we use median blur. In this kind
    of blur, we arrange the pixels covered by our kernel in ascending/descending order,
    and set the value of the middle element as the final value of the anchor pixel.
    The advantage of using this type of filtering is that salt-and-pepper noise is
    sparsely occurring, and so its influence is only over a small number of pixels
    when averaging their values. Thus, over a bigger area, the number of noise pixels
    is fewer than the number of pixels that are useful, as shown in the following
    image:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图像中常见的一种噪声类型被称为盐和胡椒噪声。在这种噪声中，稀疏出现的黑白像素分布在图像上。为了去除这种类型的噪声，我们使用中值模糊。在这种模糊中，我们按升序/降序排列我们的核覆盖的像素，并将中间元素的值设置为锚点像素的最终值。使用这种类型过滤的优势在于，盐和胡椒噪声是稀疏出现的，因此当平均它们的值时，其影响仅限于少数像素。因此，在更大的区域内，噪声像素的数量少于有用像素的数量，如下面的图像所示：
- en: '![The median blur method](img/B02052_01_12.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![中值模糊方法](img/B02052_01_12.jpg)'
- en: Example of salt-and-pepper noise
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 盐和胡椒噪声的示例
- en: 'To apply median blur in OpenCV, we use the built-in function `medianBlur`.
    As in the previous cases, we have to add a button and add the `OnClickListener`
    functions. We will add another case condition for this operation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要在OpenCV中应用中值模糊，我们使用内置函数`medianBlur`。与之前的情况一样，我们必须添加一个按钮并添加`OnClickListener`函数。我们将为此操作添加另一个情况条件：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![The median blur method](img/B02052_01_13.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![中值模糊方法](img/B02052_01_13.jpg)'
- en: Resulting image after applying median blur
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 应用中值模糊后的结果图像
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Median blur does not use convolution.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 中值模糊不使用卷积。
- en: Creating custom kernels
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义核
- en: We have seen how different types of kernels affect the image. What if we want
    to create our own kernels for different applications that aren't natively offered
    by OpenCV? In this section, we will see how we can achieve just that. We will
    try to form a sharper image from a given input.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了不同类型的核如何影响图像。如果我们想为OpenCV未原生提供的不同应用创建自己的核，会怎样呢？在本节中，我们将看到如何实现这一点。我们将尝试从给定的输入中形成更清晰的图像。
- en: 'Sharpening can be thought of as a linear filtering operation where the anchor
    pixel has a high weightage and the surrounding pixels have a low weightage. A
    kernel satisfying this constraint is shown in the following table:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 锐化可以被视为一种线性滤波操作，其中锚点像素具有高权重，而周围的像素具有低权重。满足此约束条件的核如下表所示：
- en: '| 0 | -1 | 0 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 0 | -1 | 0 |'
- en: '| -1 | 5 | -1 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| -1 | 5 | -1 |'
- en: '| 0 | -1 | 0 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 0 | -1 | 0 |'
- en: 'We will use this kernel to perform the convolution on our image:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此核对我们的图像进行卷积：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we have given the image depth as `16SC1`. This means that each pixel in
    our image contains a 16-bit signed integer (16S) and the image has 1 channel (C1).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们已将图像深度设置为 `16SC1`。这意味着我们的图像中的每个像素包含一个 16 位有符号整数（16S），并且图像有 1 个通道（C1）。
- en: 'Now we will use the `filter2D()`function, which performs the actual convolution
    when given the input image and a kernel. We will show the image in an ImageView.
    We will add another case to the switch block created earlier:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用 `filter2D()` 函数，该函数在给定输入图像和核时执行实际的卷积。我们将在 ImageView 中显示图像。我们将在之前创建的
    switch 块中添加另一个情况：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Creating custom kernels](img/B02052_01_14.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义核](img/B02052_01_14.jpg)'
- en: Original image (left) and sharpened image (right)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 原始图像（左）和锐化图像（右）
- en: Morphological operations
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形态学操作
- en: Morphological operations are a set of operations that process an image based
    on the features of the image and a structuring element. These generally work on
    binary or grayscale images. We will take a look at some basic morphological operations
    before moving on to more advance ones.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 形态学操作是一组基于图像特征和结构元素的图像处理操作。这些操作通常在二值或灰度图像上工作。在继续探讨更高级的形态学操作之前，我们将先看看一些基本的形态学操作。
- en: Dilation
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 膨胀
- en: Dilation is a method by which the bright regions of an image are expanded. To
    achieve this, we take a kernel of the desired size and replace the anchor pixel
    with the maximum value overlapped by the kernel. Dilation can be used to merge
    objects that might have been broken off.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 膨胀是一种通过扩展图像的亮区来实现的操作。为了实现这一点，我们取一个所需大小的核，并用核重叠的最大值替换锚点像素。膨胀可以用来合并可能已经断裂的对象。
- en: '![Dilation](img/B02052_01_15.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![膨胀](img/B02052_01_15.jpg)'
- en: A binary image (left) and the result after applying dilation (right)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 二值图像（左）和应用膨胀操作后的结果（右）
- en: To apply this operation, we use the `dilate()`function. We need to use a kernel
    to perform dilation. We use the `getStructuringElement()` OpenCV function to get
    the required kernel.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用此操作，我们使用 `dilate()` 函数。我们需要使用一个核来进行膨胀。我们使用 `getStructuringElement()` OpenCV
    函数来获取所需的核。
- en: 'OpenCV provides `MORPH_RECT`, `MORPH_CROSS`, and `MORPH_ELLIPSE` as options
    to create our required kernels:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 提供 `MORPH_RECT`、`MORPH_CROSS` 和 `MORPH_ELLIPSE` 作为创建所需核的选项：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Dilation](img/B02052_01_16.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![膨胀](img/B02052_01_16.jpg)'
- en: Original image (left) and dilated image (right)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 原始图像（左）和膨胀图像（右）
- en: If we use a rectangular structuring element, the image grows in the shape of
    a rectangle. Similarly, if we use an elliptical structuring element, the image
    grows in the shape of an ellipse.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用矩形结构元素，图像将呈矩形增长。同样，如果我们使用椭圆形结构元素，图像将呈椭圆形增长。
- en: Erosion
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 腐蚀
- en: Similarly, erosion is a method by which the dark regions of an image are expanded.
    To achieve this, we take a kernel of the desired size and replace the anchor pixel
    by the minimum value overlapped by the kernel. Erosion can be used to remove the
    noise from images.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，腐蚀是一种通过扩展图像的暗区来实现的操作。为了实现这一点，我们取一个所需大小的核，并用核重叠的最小值替换锚点像素。腐蚀可以用来从图像中去除噪声。
- en: '![Erosion](img/B02052_01_17.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![腐蚀](img/B02052_01_17.jpg)'
- en: A binary image (left) and the result after applying erosion (right)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 二值图像（左）和应用腐蚀操作后的结果（右）
- en: 'To apply this operation, we use the `erode()` function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用此操作，我们使用 `erode()` 函数：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Erosion](img/B02052_01_18.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![腐蚀](img/B02052_01_18.jpg)'
- en: Original image (left) and eroded image (right)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 原始图像（左）和腐蚀图像（右）
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Erosion and dilation are not inverse operations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 腐蚀和膨胀不是逆操作。
- en: Thresholding
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阈值化
- en: Thresholding is the method of segmenting out sections of an image that we would
    like to analyze. The value of each pixel is compared to a predefined threshold
    value and based on this result, we modify the value of the pixel. OpenCV provides
    five types of thresholding operations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值化是将我们希望分析的图像部分分割出来的方法。每个像素的值与预定义的阈值值进行比较，并根据此结果修改像素的值。OpenCV 提供了五种类型的阈值化操作。
- en: 'To perform thresholding, we will use the following code as a template and change
    the parameters as per the kind of thresholding required. We need to replace `THRESH_CONSTANT`
    with the constant for the required method of thresholding:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行阈值化，我们将使用以下代码作为模板，并根据所需的阈值化类型更改参数。我们需要将 `THRESH_CONSTANT` 替换为所需的阈值化方法的常数：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, `100` is the threshold value and `255` is the maximum value (the value
    of pure white).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`100` 是阈值值，`255` 是最大值（纯白色的值）。
- en: 'The constants are listed in the following table:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 常数列在以下表中：
- en: '| Thresholding Method Name | Thresholding Function | Constant |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 阈值方法名称 | 阈值函数 | 常数 |'
- en: '| --- | --- | --- |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Binary threshold | ![Thresholding](img/B02052_01_24_a.jpg) | `THRESH_BINARY`
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 二值阈值 | ![阈值](img/B02052_01_24_a.jpg) | `THRESH_BINARY` |'
- en: '| Threshold to zero | ![Thresholding](img/B02052_01_24_b.jpg) | `THRESH_TOZERO`
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 阈值置零 | ![阈值](img/B02052_01_24_b.jpg) | `THRESH_TOZERO` |'
- en: '| Truncate | ![Thresholding](img/B02052_01_24_c.jpg) | `THRESH_TRUNC` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 截断 | ![阈值](img/B02052_01_24_c.jpg) | `THRESH_TRUNC` |'
- en: '| Binary threshold, inverted | ![Thresholding](img/B02052_01_24_d.jpg) | `THRESH_BINARY_INV`
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 二值阈值，反转 | ![阈值](img/B02052_01_24_d.jpg) | `THRESH_BINARY_INV` |'
- en: '| Threshold to zero, inverted | ![Thresholding](img/B02052_01_24_e.jpg) | `THRESH_TOZERO_INV`
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 阈值置零，反转 | ![阈值](img/B02052_01_24_e.jpg) | `THRESH_TOZERO_INV` |'
- en: 'The following image for thresholding results is taken from [http://docs.opencv.org/trunk/d7/d4d/tutorial_py_thresholding.html](http://docs.opencv.org/trunk/d7/d4d/tutorial_py_thresholding.html):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '以下用于阈值结果的图像取自[http://docs.opencv.org/trunk/d7/d4d/tutorial_py_thresholding.html](http://docs.opencv.org/trunk/d7/d4d/tutorial_py_thresholding.html):'
- en: '![Thresholding](img/B02052_01_19.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![阈值](img/B02052_01_19.jpg)'
- en: Adaptive thresholding
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自适应阈值
- en: Setting a global threshold value may not be the best option when performing
    segmentation. Lighting conditions affect the intensity of pixels. So, to overcome
    this limitation, we will try to calculate the threshold value for any pixel based
    on its neighboring pixels.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行分割时设置全局阈值值可能不是最佳选择。光照条件影响像素的强度。因此，为了克服这一限制，我们将尝试根据每个像素的相邻像素计算阈值值。
- en: 'We will use three parameters to calculate the adaptive threshold of an image:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用三个参数来计算图像的自适应阈值：
- en: '**Adaptive method**: The following are the two methods we will use:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自适应方法**：以下是我们将使用的两种方法：'
- en: '`ADAPTIVE_THRESH_MEAN_C`: The threshold value is the mean of the neighboring
    pixels'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADAPTIVE_THRESH_MEAN_C`: 阈值值是相邻像素的平均值'
- en: '`ADAPTIVE_THRESH_GAUSSIAN_C`: The threshold value is the weighted sum of the
    neighboring pixel values, where weights are Gaussian kernels'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADAPTIVE_THRESH_GAUSSIAN_C`: 阈值值是相邻像素值的加权总和，其中权重是高斯核'
- en: '**Block Size**: This is the size of the neighborhood'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**块大小**：这是邻域的大小'
- en: '**C**: This is the constant that has to be subtracted from the mean/weighted
    mean calculated for each pixel:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**C**：这是从每个像素计算出的均值/加权均值中减去的常数：'
- en: '[PRE18]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Adaptive thresholding](img/B02052_01_20.jpg)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![自适应阈值](img/B02052_01_20.jpg)'
- en: Original image (left) and image after applying Adaptive thresholding (right)
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原始图像（左）和应用自适应阈值后的图像（右）
- en: Here, the resulting image has a lot of noise present. This can be avoided by
    applying a blurring operation before applying adaptive thresholding, so as to
    smooth the image.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，结果图像中存在很多噪声。这可以通过在应用自适应阈值之前应用模糊操作来避免，以平滑图像。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learnt how to get started with using OpenCV in your
    Android project. Then we looked at different filters in image processing, especially
    linear filters, and how they can be implemented on an Android device. These filters
    will later form the basis of any computer vision application that you try to build.
    In the following chapters, we will look at more complex image filters, and also
    see how to extract information from the images in the form of edges, corners,
    and the like.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在Android项目中开始使用OpenCV。然后我们探讨了图像处理中的不同过滤器，特别是线性过滤器，以及它们如何在Android设备上实现。这些过滤器将构成您尝试构建的任何计算机视觉应用的基础。在接下来的章节中，我们将探讨更复杂的图像过滤器，并了解如何从图像中提取边缘、角点等信息。
