["```py\nimport pycuda.autoinit\nimport pycuda.driver as drv\nimport numpy\nimport matplotlib.pyplot as plt\nfrom pycuda.compiler import SourceModule\nmod = SourceModule(\"\"\"          \n__global__ void atomic_hist(int *d_b, int *d_a, int SIZE)\n{\n int tid = threadIdx.x + blockDim.x * blockIdx.x;\n int item = d_a[tid];\n if (tid < SIZE)\n {\n  atomicAdd(&(d_b[item]), 1);\n }\n}\n\"\"\")\n```", "```py\natomic_hist = mod.get_function(\"atomic_hist\")\nimport cv2\nh_img = cv2.imread(\"cameraman.tif\",0)\n\nh_a=h_img.flatten()\nh_a=h_a.astype(numpy.int)\nh_result = numpy.zeros(256).astype(numpy.int)\nSIZE = h_img.size\nNUM_BIN=256\nn_threads= int(numpy.ceil((SIZE+NUM_BIN-1) / NUM_BIN))\nstart = drv.Event()\nend=drv.Event()\nstart.record()\natomic_hist(\n    drv.Out(h_result), drv.In(h_a), numpy.uint32(SIZE),\n    block=(n_threads,1,1), grid=(NUM_BIN,1))\n\nend.record()\nend.synchronize()\nsecs = start.time_till(end)*1e-3\nprint(\"Time for Calculating Histogram on GPU with shared memory\")\nprint(\"%fs\" % (secs)) \nplt.stem(h_result)\nplt.xlim([0,256])\nplt.title(\"Histogram on GPU\")\n```", "```py\n$pip install opencv-python\n```", "```py\nimport pycuda.autoinit\nimport pycuda.driver as drv\nimport numpy\nimport matplotlib.pyplot as plt\nfrom pycuda.compiler import SourceModule\n\nmod1 = SourceModule(\"\"\"\n__global__ void atomic_hist(int *d_b, int *d_a, int SIZE)\n{\n int tid = threadIdx.x + blockDim.x * blockIdx.x;\n int offset = blockDim.x * gridDim.x;\n __shared__ int cache[256];\n cache[threadIdx.x] = 0;\n __syncthreads();\n\n while (tid < SIZE)\n {\n  atomicAdd(&(cache[d_a[tid]]), 1);\n  tid += offset;\n }\n __syncthreads();\n atomicAdd(&(d_b[threadIdx.x]), cache[threadIdx.x]);\n}\n\"\"\")\n```", "```py\natomic_hist = mod.get_function(\"atomic_hist\")\n\nimport cv2\nh_img = cv2.imread(\"cameraman.tif\",0)\n\nh_a=h_img.flatten()\nh_a=h_a.astype(numpy.int)\nh_result = numpy.zeros(256).astype(numpy.int)\nSIZE = h_img.size\nNUM_BIN=256\nn_threads= int(numpy.ceil((SIZE+NUM_BIN-1) / NUM_BIN))\nstart = drv.Event()\nend=drv.Event()\nstart.record()\natomic_hist(\n drv.Out(h_result), drv.In(h_a), numpy.uint32(SIZE),\n block=(n_threads,1,1), grid=(NUM_BIN,1),shared= 256*4)\n\nend.record()\nend.synchronize()\nsecs = start.time_till(end)*1e-3\nprint(\"Time for Calculating Histogram on GPU with shared memory\")\nprint(\"%fs\" % (secs)) \nplt.stem(h_result)\nplt.xlim([0,256])\nplt.title(\"Histogram on GPU\")\n```", "```py\nstart = cv2.getTickCount()\nhist = cv2.calcHist([h_img],[0],None,[256],[0,256])\nend = cv2.getTickCount()\ntime = (end - start)/ cv2.getTickFrequency()\nprint(\"Time for Calculating Histogram on CPU\")\nprint(\"%fs\" % (secs))\n```", "```py\ngray = 0.299*r+0.587*g+0.114*b Where r,g,b are color intensities of red, green and blue channel at a particular location\n```", "```py\nimport pycuda.driver as drv\nfrom pycuda.compiler import SourceModule\nimport numpy as np\nimport cv2\nmod = SourceModule \\\n  (\n    \"\"\"\n#include<stdio.h>\n#define INDEX(a, b) a*256+b\n\n__global__ void bgr2gray(float *d_result,float *b_img, float *g_img, float *r_img)\n{\n unsigned int idx = threadIdx.x+(blockIdx.x*(blockDim.x*blockDim.y));\n unsigned int a = idx/256;\n unsigned int b = idx%256;\n d_result[INDEX(a, b)] = (0.299*r_img[INDEX(a, b)]+0.587*g_img[INDEX(a, b)]+0.114*b_img[INDEX(a, b)]);\n\n}\n \"\"\"\n)\n```", "```py\nh_img = cv2.imread('lena_color.tif',1)\nh_gray=cv2.cvtColor(h_img,cv2.COLOR_BGR2GRAY)\n#print a\nb_img = h_img[:, :, 0].reshape(65536).astype(np.float32)\ng_img = h_img[:, :, 1].reshape(65536).astype(np.float32)\nr_img = h_img[:, :, 2].reshape(65536).astype(np.float32)\nh_result=r_img\nbgr2gray = mod.get_function(\"bgr2gray\")\nbgr2gray(drv.Out(h_result), drv.In(b_img), drv.In(g_img),drv.In(r_img),block=(1024, 1, 1), grid=(64, 1, 1))\n\nh_result=np.reshape(h_result,(256,256)).astype(np.uint8)\ncv2.imshow(\"Grayscale Image\",h_result)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n```", "```py\ncap = cv2.VideoCapture(0)\nbgr2gray = mod.get_function(\"bgr2gray\")\nwhile(True):\n  # Capture frame-by-frame\n  ret, h_img = cap.read()\n  h_img = cv2.resize(h_img,(256,256),interpolation = cv2.INTER_CUBIC)\n\n  b_img = h_img[:, :, 0].reshape(65536).astype(np.float32)\n  g_img = h_img[:, :, 1].reshape(65536).astype(np.float32)\n  r_img = h_img[:, :, 2].reshape(65536).astype(np.float32)\n  h_result=r_img\n\n  bgr2gray(drv.Out(h_result), drv.In(b_img), drv.In(g_img),drv.In(r_img),block=(1024, 1, 1), grid=(64, 1, 1))\n\n  h_result=np.reshape(h_result,(256,256)).astype(np.uint8)\n  cv2.imshow(\"Grayscale Image\",h_result)\n\n  # Display the resulting frame\n  cv2.imshow('Original frame',h_img)\n  if cv2.waitKey(50) & 0xFF == ord('q'):\n    break\n\n# When everything done, release the capture\ncap.release()\ncv2.destroyAllWindows()\n```", "```py\nresult = img1 + img2 \n```", "```py\nimport pycuda.driver as drv\nfrom pycuda.compiler import SourceModule\nimport numpy as np\nimport cv2\nmod = SourceModule \\\n (\n\"\"\"\n __global__ void add_num(float *d_result, float *d_a, float *d_b,int N)\n{\n int tid = threadIdx.x + blockIdx.x * blockDim.x; \n while (tid < N)\n  {\n d_result[tid] = d_a[tid] + d_b[tid];\n if(d_result[tid]>255)\n {\n d_result[tid]=255;\n }\n tid = tid + blockDim.x * gridDim.x;\n}\n}\n\"\"\"\n)\nimg1 = cv2.imread('cameraman.tif',0)\nimg2 = cv2.imread('circles.png',0)\nh_img1 = img1.reshape(65536).astype(np.float32)\nh_img2 = img2.reshape(65536).astype(np.float32)\nN = h_img1.size\nh_result=h_img1\nadd_img = mod.get_function(\"add_num\")\nadd_img(drv.Out(h_result), drv.In(h_img1), drv.In(h_img2),np.uint32(N),block=(1024, 1, 1), grid=(64, 1, 1))\nh_result=np.reshape(h_result,(256,256)).astype(np.uint8)\ncv2.imshow(\"Image after addition\",h_result)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n```", "```py\nresult_image = 255 - input_image\n```", "```py\nimport pycuda.driver as drv\nimport numpy as np\nimport cv2\nimport pycuda.gpuarray as gpuarray\nimport pycuda.autoinit\n\nimg = cv2.imread('circles.png',0)\nh_img = img.reshape(65536).astype(np.float32)\nd_img = gpuarray.to_gpu(h_img)\nd_result = 255- d_img\nh_result = d_result.get()\nh_result=np.reshape(h_result,(256,256)).astype(np.uint8)\ncv2.imshow(\"Image after addition\",h_result)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n```"]