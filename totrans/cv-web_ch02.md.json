["```py\n<script src=\"img/tracking.js\"></script>\n```", "```py\nvar imageData = context.getImageData(0, 0, cols, rows);\n```", "```py\nvar gray = tracking.Image.grayscale(imageData.data, cols, rows, true);\n```", "```py\ncontext.putImageData(new ImageData(gray, cols, rows), 0, 0);\n```", "```py\nvar dataBuffer = new jsfeat.data_t(cols * rows, imageData.data.buffer);\nvar mat = new jsfeat.matrix_t(cols, rows, jsfeat.U8C4_t, dataBuffer);\nvar gray = tracking.Image.grayscale(mat.data, cols, rows, true);\n```", "```py\nvar buf = new Array(gray.length / 4);\nfor (var i = 0, j = 0; i < gray.length; i += 4, ++j) {\n    buf[j] = gray[i];\n}\nvar matGray = new jsfeat.matrix_t(cols, rows, jsfeat.U8C1_t,\n        new jsfeat.data_t(cols * rows, buf));\n```", "```py\n[0.25]                       [0.0625, 0.125,  0.0625]\n[0.5 ] X [0.25, 0.5, 0.25] = [0.125,  0.0625, 0.125 ]\n[0.25]                       [0.0625, 0.125,  0.25  ]\n```", "```py\nvar kernelSize = 3, sigma = 0, kernelArray = [], dataType = jsfeat.F32_t;\njsfeat.math.get_gaussian_kernel(kernelSize, sigma, kernelArray, dataType);\n```", "```py\n[0.25, 0.5, 0.25]\n```", "```py\nvar gaussianKernel = new jsfeat.data_t(kernelArray.length, kernelArray);\nvar A = new jsfeat.matrix_t(1, kernelSize, jsfeat.F32C1_t, gaussianKernel),\n        B = new jsfeat.matrix_t(kernelSize, 1, jsfeat.F32C1_t, gaussianKernel),\n        C = new jsfeat.matrix_t(kernelSize, kernelSize, jsfeat.F32C1_t);\njsfeat.matmath.multiply(C, A, B);\n```", "```py\nvar buf = tracking.Image.horizontalConvolve(gray, cols, rows, kernelArray, true);\nbuf = tracking.Image.verticalConvolve(buf, cols, rows, kernelArray, true);\n```", "```py\njsfeat.imgproc.gaussian_blur(matGray, matBlurred, kernelSize);\n```", "```py\nvar blurred = tracking.Image.blur(gray, cols, rows, kernelSize);\n```", "```py\n[1/9, 1/9, 1/9]\n[1/9, 1/9, 1/9]\n[1/9, 1/9, 1/9]\n```", "```py\n[1/n, 1/n, ..., 1/n]\n[1/n, 1/n, ..., 1/n]\n[..., ..., ..., ...]\n[1/n, 1/n  ..., 1/n]\n```", "```py\njsfeat.imgproc.box_blur_gray(matGray, blurred, kernelRadius);\n```", "```py\n[1/3, 1/3, 1/3]\n```", "```py\nvar matCopy1 = new jsfeat.matrix_t(matGray.cols + 1, matGray.rows + 1, jsfeat.F32C1_t);\nvar matCopy2 = new jsfeat.matrix_t(matGray.cols + 1, matGray.rows + 1, jsfeat.F32C1_t);\nvar matCopy3 = new jsfeat.matrix_t(matGray.cols + 1, matGray.rows + 1, jsfeat.F32C1_t);\n\njsfeat.imgproc.compute_integral_image(matGray, matCopy1.data, matCopy2.data, matCopy3.data);\n```", "```py\n[-1, 0, 1]   [1]                [-1, -2, -1]   [-1]\n[-2, 0, 2] = [2] X [-1, 0, 1]   [ 0,  0,  0] = [ 0] X [1, 2, 1]\n[-1, 0, 1]   [1]                [ 1,  2,  1]   [ 1]\n```", "```py\nvar sobelSignVector = [-1, 0, 1];\nvar sobelScaleVector = [1, 2, 1];\nvar horizontal = tracking.Image.separableConvolve(gray, cols, rows, sobelScaleVector, sobelSignVector, true);\nvar vertical = tracking.Image.separableConvolve(gray, cols, rows, sobelSignVector, sobelScaleVector, true);\n```", "```py\njsfeat.imgproc.sobel_derivatives(matGray, imgGxGy);\n```", "```py\nvar value = Math.sqrt(h * h + v * v);\n```", "```py\nvar sobelImg = tracking.Image.sobel(gray, cols, rows);\n```", "```py\n[-1, 0, 1]   [1]                 [-1, -1, -1]   [-1]\n[-1, 0, 1] = [1] X [-1, 0, 1]   [ 0,  0,  0] = [ 0] X [1, 1, 1]\n[-1, 0, 1]   [1]                 [ 1,  1,  1]   [ 1]\n```", "```py\n[ -3, 0,  3]   [ 3]                [-3, -10, -3]   [-1]\n[-10, 0, 10] = [10] X [-1, 0, 1]   [ 0,   0,  0] = [ 0] X [3, 10, 3]\n[ -3, 0,  3]   [ 3]                [ 3,  10,  3]   [ 1]\n```", "```py\nfor (var i = 0; i < arr.length; i++)\n    arr[i] = arr[i] > threshold ? 255 : 0;\n```", "```py\nvar canny = new jsfeat.matrix_t(cols, rows, jsfeat.U8C1_t);\njsfeat.imgproc.gaussian_blur(matGray, canny, kernelSize);\njsfeat.imgproc.canny(canny, canny, lowThresh, highThresh);\n```", "```py\nvar arr = [30, 100, 10, 30, 30, 100, 50, 255];\n```", "```py\nvar matGray = new jsfeat.matrix_t(arr.length, 1, jsfeat.U8C1_t,\n        new jsfeat.data_t(arr.length, arr));\nvar equalized = new jsfeat.matrix_t(arr.length, 1, jsfeat.U8C1_t);\njsfeat.imgproc.equalize_histogram(matGray, equalized);\n```", "```py\n[128, 223, 32, 128, 128, 223, 159, 255]\n```", "```py\n 10: 1      32: 1\n 30: 3     128: 3\n 50: 1     159: 1\n100: 2     223: 2\n255: 1     255: 1\n```"]