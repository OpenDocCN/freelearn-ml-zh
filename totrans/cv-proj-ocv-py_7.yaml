- en: Deep Learning Image Classification with TensorFlow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TensorFlow进行深度学习图像分类
- en: In this chapter, we will learn how to classify images using TensorFlow. First,
    we will use a pre-trained model, and then we'll proceed with training our own
    model using custom images.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用TensorFlow进行图像分类。首先，我们将使用预训练模型，然后我们将使用自定义图像进行模型训练。
- en: Toward the end of the chapter, we will make use of the GPU to help us speed
    up our computations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，我们将利用GPU来帮助我们加速计算。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: A deep introduction to TensorFlow
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TensorFlow的深度介绍
- en: Using a pre-trained model (Inception) for image classification
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预训练模型（Inception）进行图像分类
- en: Retraining with our own images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的自定义图像进行再训练
- en: Speeding up computation with the GPU
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GPU加速计算
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Along with knowledge of Python and the basics of image processing and computer
    vision, you will need the following libraries:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Python知识和图像处理及计算机视觉的基础知识外，你还需要以下库：
- en: TensorFlow
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TensorFlow
- en: NVIDIA CUDA® Deep Neural Network
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NVIDIA CUDA®深度神经网络
- en: 'The code used in the chapter has been added to the following GitHub repository:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码已添加到以下GitHub仓库中：
- en: '[https://github.com/PacktPublishing/Computer-Vision-Projects-with-OpenCV-and-Python-3](https://github.com/PacktPublishing/Computer-Vision-Projects-with-OpenCV-and-Python-3)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Computer-Vision-Projects-with-OpenCV-and-Python-3](https://github.com/PacktPublishing/Computer-Vision-Projects-with-OpenCV-and-Python-3)'
- en: An introduction to TensorFlow
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TensorFlow简介
- en: In this chapter, we'll go deeper into TensorFlow and see how we can build a
    general-purpose image classifier using its deep learning method.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地了解TensorFlow，并看看我们如何可以使用其深度学习方法构建一个通用的图像分类器。
- en: This will be an extension of what we learned in Chapter 2, *Handwritten Digit
    Recognition with scikit-learn and TensorFlow,* where we learned how to classify
    handwritten digits. However, this method is quite a bit more powerful, as it will
    work on general images of people, animals, food, everyday objects, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们在第2章“使用scikit-learn和TensorFlow进行手写数字识别”中学到的内容的扩展，在那里我们学习了如何对手写数字进行分类。然而，这种方法要强大得多，因为它将适用于人们的通用图像、动物、食物、日常物品等等。
- en: To start, let's talk a little bit about what TensorFlow does, and the general
    workflow of TensorFlow.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们简单谈谈TensorFlow做什么，以及TensorFlow的一般工作流程。
- en: 'To begin, what is a tensor? Wikipedia states this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是张量？维基百科这样描述：
- en: '*"In mathematics, tensors are geometric objects that describe linear relations
    between geometric vectors, scalars, and other tensors... Given a reference basis
    of vectors, a tensor can be represented as an organized multi-dimensional array
    of numerical values."*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*"在数学中，张量是描述几何向量、标量和其他张量之间线性关系的几何对象...给定一个参考向量基，张量可以表示为一个有组织的多维数值数组。"*'
- en: However, according to Google, the makers of TensorFlow, a tensor is any multi-dimensional
    array with any data type. Essentially, according to Google, a tensor can mean
    basically anything.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，根据TensorFlow的制作者谷歌的说法，张量是任何多维数组，无论数据类型如何。本质上，根据谷歌的说法，张量基本上可以指任何东西。
- en: Google has generalized the word so much that it doesn't really mean a lot, and
    personally I don't like that (coming from an engineering and physics background).
    However, TensorFlow is so powerful and useful that I'm going to get over it. Just
    be aware that if you're ever worried about misusing the word *tensor*, don't be,
    because Google completely misuses it anyway.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌将这个词泛化得如此之广，以至于它实际上并没有太多意义，我个人也不喜欢这样（来自工程和物理背景）。然而，TensorFlow如此强大且有用，我打算克服这一点。只是要注意，如果你对误用单词*tensor*感到担忧，请不要担心，因为谷歌无论如何都在滥用这个词。
- en: For now, all we need to know is that within TensorFlow, a tensor is some sort
    of data; usually a multi-dimensional array, but it could be basically anything,
    such as images or text. With that in mind, TensorFlow is, in general, a high-performance
    numerical library. It is primarily geared toward machine learning, but that doesn't
    mean that it's exclusively made for machine learning.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需要知道在TensorFlow中，张量是一种数据；通常是多维数组，但它可以是基本上任何东西，例如图像或文本。考虑到这一点，TensorFlow通常是一个高性能数值库。它主要面向机器学习，但这并不意味着它仅用于机器学习。
- en: TensorFlow can also be used for simulations, solving complex partial differential
    equations, and just about anything numerical. We're only concerned with machine
    learning and, in particular, deep learning in this chapter. We are going to be
    using it for its main purpose, but just be aware that it's generally used for
    constructing and analyzing complex numerical models.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow也可以用于模拟、解决复杂的偏微分方程以及几乎所有数值问题。我们只关注机器学习，特别是本章中的深度学习。我们将用它来实现其主要目的，但请注意，它通常用于构建和分析复杂的数值模型。
- en: 'Before we go into building a classifier, I want to share a little bit about
    how we would generally use TensorFlow for very basic usage. Start as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建分类器之前，我想分享一下我们通常如何使用TensorFlow进行非常基础的用法。如下开始：
- en: 'We''re going to change directories, and make sure that we can load key libraries
    and display images and so forth, using the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要更改目录，并确保我们可以使用以下代码加载关键库和显示图像等：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we import `tensorflow` and `numpy`, using the standard convention:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用标准惯例导入`tensorflow`和`numpy`：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since we performed `pylab inline`, we don't explicitly need to import `numpy`,
    but it's a good practice in general. If we want to copy some of this code out
    to other scripts, we need to make sure that `numpy` is imported.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们执行了`pylab inline`，所以我们不需要显式地导入`numpy`，但通常来说这是一个好习惯。如果我们想将一些代码复制到其他脚本中，我们需要确保已经导入了`numpy`。
- en: 'Let''s start with a simple TensorFlow example. We''re just going to perform
    some really basic arithmetic. Define some constants within TensorFlow, as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从简单的TensorFlow示例开始。我们只是将要执行一些非常基础的算术。在TensorFlow中定义一些常量，如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These constants can be just scalars, as we defined, or they could be vectors
    or matrices. We're just going to add them together. When we do that, we can define
    our constants.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量可以是标量，就像我们定义的那样，也可以是向量或矩阵。我们只是将它们相加。当我们这样做时，我们可以定义我们的常量。
- en: 'We define constants, and then we create a TensorFlow session using the `with`
    clause. When it goes outside the `with` clause, we''ll close the TensorFlow session,
    as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了常量，然后我们使用`with`子句创建了一个TensorFlow会话。当它离开`with`子句时，我们会关闭TensorFlow会话，如下所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Session` can be important depending on what resources we''re using, for example,
    if we''re using a GPU and we want to release it, but in this section, we''re just
    going to be talking about the `Session` using the CPU.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Session`的重要性取决于我们使用的资源，例如，如果我们使用GPU并希望释放它，但在这个部分，我们只是将讨论使用CPU的`Session`。'
- en: Within our `Session`, TensorFlow has operator overloading where it makes sense.
    It understands what is meant by `a+b`, where `a` and `b` are both TensorFlow constants. It
    also understands arithmetic operations such as multiply (`*`), minus (`-`), divide
    (`/`), and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Session`中，TensorFlow在合理的地方进行了操作符重载。它理解`a+b`的含义，其中`a`和`b`都是TensorFlow常量。它还理解乘法（`*`）、减法（`-`）、除法（`/`）等算术运算。
- en: 'Now, we''re going to do the same thing using a different method, by creating `placeholder`
    variables, as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用不同的方法做同样的事情，通过创建`placeholder`变量，如下所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Often, we need to construct our model. That's what TensorFlow is based on, it's
    basically an input-output model. So, we have our input, which could be numbers,
    images, words, or whatever. We generally need to find placeholders before we input
    our data, and then define and construct our model.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要构建我们的模型。这就是TensorFlow的基础，它基本上是一个输入-输出模型。因此，我们有输入，这可能是一组数字、图像、单词或任何东西。我们通常需要在输入数据之前找到占位符，然后定义和构建我们的模型。
- en: 'In our case, we''re just defining addition, just as we would normally define
    it, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们只是定义了加法，就像我们通常定义的那样，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This could be something more complex such as building a neural network, a **convolutional
    neural network** (**CNN**), and so on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一些更复杂的事情，比如构建一个神经网络，一个**卷积神经网络**（**CNN**）等等。
- en: We'll see a bit of that momentarily, but for now we define our inputs, our model,
    our operations, and so on, and we create what is called a *graph*, which will
    take our inputs and map them to the desired outputs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍后看到一些例子，但现在我们定义我们的输入、我们的模型、我们的操作等，并创建一个所谓的*图*，它将我们的输入映射到所需的输出。
- en: 'Similarly, we''re going to create a `session`, and then we''re going to run
    our operations:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们将创建一个`session`，然后我们将运行我们的操作：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this case, we have to tell it what the values are, and then it does exactly
    what we expect, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须告诉它值是什么，然后它就会按照我们预期的那样执行，如下所示：
- en: '![](img/c00971ea-14ad-4385-8110-bc8d991bd7a4.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c00971ea-14ad-4385-8110-bc8d991bd7a4.png)'
- en: Nothing too exciting—this is just so we understand a little bit about what TensorFlow
    is doing. We'll take advantage of some higher-level libraries for this chapter,
    but this is important if we want to go further in the future.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么特别激动人心的——这只是让我们对TensorFlow正在做什么有一个基本的了解。我们将利用一些高级库来完成本章，但如果我们想要在未来更进一步，这是很重要的。
- en: 'Similarly, we''re going to do matrix multiplication. As mentioned earlier,
    the constants can be more than just scalars. In this case, we''re defining matrices, a
    2 by 2 matrix and a 2 by 1 matrix, using the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将进行矩阵乘法。如前所述，常数可以不仅仅是标量。在这种情况下，我们定义矩阵，一个2x2的矩阵和一个2x1的矩阵，按照以下步骤：
- en: 'We define our matrices as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义我们的矩阵如下：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we tell it to multiply matrices, as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们告诉它进行矩阵乘法，如下所示：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We create our session:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的会话：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we run it, and then print the results. The output is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行它，然后打印结果。输出如下：
- en: '![](img/5d42cb84-37b0-4191-9e76-247f5a004f9a.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d42cb84-37b0-4191-9e76-247f5a004f9a.png)'
- en: Again, very basic, but very important in the future. We're not going to define
    our full network in this lesson, because that's very complex and very time-consuming
    to execute, but just mention the general steps for creating our own CNN.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这非常基础，但在未来非常重要。我们不会在本课中定义我们的完整网络，因为这非常复杂，执行起来也非常耗时，但只是简要提及创建我们自己的CNN的一般步骤。
- en: We're going to create what is known as layers, define our input, and then we
    create a bunch of layers and stack them together and define how they're connected.
    We then find the output layer and then we have to define some other things like
    how we're going to train and how we're going to evaluate it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建所谓的层，定义我们的输入，然后创建一系列层并将它们堆叠起来，定义它们是如何连接的。然后我们找到输出层，然后我们必须定义一些其他事情，比如我们如何训练以及我们如何评估它。
- en: 'The code for this is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码如下：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, this is just for our knowledge. Deep learning is a difficult subject,
    figuring out the necessary architecture and exactly how to train, which is beyond
    the scope of this chapter (although I would invite you to learn more about it).
    Here, we're just going to see how we can utilize what's already done—but if you
    want to go further, this is where you would start.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这只是为了我们的知识。深度学习是一个困难的课题，确定必要的架构以及如何精确训练，这超出了本章的范围（尽管我会邀请你了解更多关于它的内容）。在这里，我们只是看看我们如何利用已经完成的工作——但如果你想要更进一步，这就是你开始的地方。
- en: In the next section, we're going to see how to use a pre-trained model, Inception,
    to perform our image classification.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何使用预训练的模型Inception来执行图像分类。
- en: Using Inception for image classification
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Inception进行图像分类
- en: In this section, we're going to use a pre-trained model, Inception, from Google
    to perform image classification. We'll then move on and build our own model—or,
    at least do some retraining on the model in order to train on our own images and
    classify our own objects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用来自Google的预训练模型Inception来执行图像分类。然后我们将继续构建我们自己的模型——或者至少对模型进行一些再训练，以便在我们的图像上进行训练并对我们的物体进行分类。
- en: For now, we want to see what we can do with a model that's already trained,
    which would take a lot of time to reproduce from scratch. Let's get started with
    the code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想看看我们如何使用已经训练好的模型，从头开始重新生成将花费很多时间。让我们从代码开始。
- en: Let's go back to Jupyter Notebook. The Notebook file can be found at [https://github.com/PacktPublishing/Computer-Vision-Projects-with-OpenCV-and-Python-3/Chapter04](https://github.com/PacktPublishing/Computer-Vision-Projects-with-OpenCV-and-Python-3/Chapter04).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到Jupyter Notebook。Notebook文件可以在以下链接找到：[https://github.com/PacktPublishing/Computer-Vision-Projects-with-OpenCV-and-Python-3/Chapter04](https://github.com/PacktPublishing/Computer-Vision-Projects-with-OpenCV-and-Python-3/Chapter04)。
- en: In order to run the code, we're going to need to download a file from TensorFlow's
    website, from the following link: [http://download.tensorflow.org/models/image/imagenet/inception-2015-12-05.tgz](http://download.tensorflow.org/models/image/imagenet/inception-2015-12-05.tgz).
    This is the Inception model.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行代码，我们需要从TensorFlow的网站上下载一个文件，如下链接所示：[http://download.tensorflow.org/models/image/imagenet/inception-2015-12-05.tgz](http://download.tensorflow.org/models/image/imagenet/inception-2015-12-05.tgz)。这是Inception模型。
- en: The model was trained in 2015\. It contains a couple of files that define the
    model, the *graph* as it is called, defining the input-output relation between
    the input images that we provide it and the output classification.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型是在 2015 年训练的。它包含几个定义模型的文件，称为 *graph*，它定义了输入图像和输出分类之间的输入输出关系。
- en: It also contains some labeling data because the output isn't class names; it
    is numbers. This is modified from Google own TensorFlow's example, to make it
    easier to understand and run in Jupyter Notebook and reduce the amount of code.
    However, we need to change that.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包含一些标签数据，因为输出不是类别名称；它是数字。这是从谷歌自己的 TensorFlow 示例中修改的，以便更容易理解和在 Jupyter Notebook
    中运行，并减少代码量。然而，我们需要进行更改。
- en: Get the file and completely unzip it. On Windows, readers might use 7-Zip, which
    will give a TGZ file. Make sure to then untar the TGZ file to get the TXT, PBTXT,
    and PB files, particularly the PB file, as that is the one that actually contains
    the trained model.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下载文件并完全解压。在 Windows 上，读者可能会使用 7-Zip，这将生成一个 TGZ 文件。确保然后解压缩 TGZ 文件以获取 TXT、PBTXT
    和 PB 文件，特别是 PB 文件，因为它是实际包含训练模型的文件。
- en: We create a file called `inceptiondict`, rather than using Google's own convoluted
    file for mapping the class numbers to the class name.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `inceptiondict` 的文件，而不是使用谷歌自己复杂的文件来映射类别数字到类别名称。
- en: 'Let''s take a look at the `inceptiondict` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `inceptiondict` 文件：
- en: '![](img/496f7a1f-36c0-41db-8c62-cfb74534d5dc.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/496f7a1f-36c0-41db-8c62-cfb74534d5dc.png)'
- en: This file has a thousand classes. It would take a very long time to train this
    yourself, but we don't have to; we can take advantage of this and build off it,
    as we'll see later.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件有千个类别。自己训练这个模型将花费非常长的时间，但我们不必这样做；我们可以利用这一点，并在后面构建在此基础上。
- en: This file is interesting to look at if we want to know what kinds of images
    we'll be able to recognize within this pre-built model. There are a lot of animals
    in the file, some common items, fruits, musical instruments, different kinds of
    fish; it even recognizes the Japanese game *shoji*, apparently.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想知道在这个预构建模型中我们能够识别哪些类型的图像，这个文件很有趣。文件中有很多动物，一些常见物品，水果，乐器，不同种类的鱼；它甚至能够识别日本的游戏
    *shoji*。
- en: We're going to import this file as a dictionary called `inceptiondict`, which
    will map numbers to their corresponding class descriptions; for example, class
    `1` maps to the description `"goldfish, Carassius auratus"`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个文件导入为一个名为 `inceptiondict` 的字典，它将数字映射到相应的类别描述；例如，类别 `1` 映射到描述 `"goldfish,
    Carassius auratus"`。
- en: 'Let''s explore the main code. Firstly, we import the file as `inceptiondict`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索主要代码。首先，我们将文件导入为 `inceptiondict`：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we have our `run_inference_on_image` function, where `image` is a filename.
    It is not the file data—we haven't loaded that yet—just the filename for the image
    that we want to classify.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了 `run_inference_on_image` 函数，其中 `image` 是一个文件名。它不是文件数据——我们还没有加载它——只是我们想要分类的图像的文件名。
- en: 'Then, we check to make sure that filename exists, and create an error if it
    doesn''t. If it does exist, then we use TensorFlow''s own loading mechanism in
    order to read that filename, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查文件名是否存在，如果不存在则创建一个错误。如果存在，我们将使用 TensorFlow 自身的加载机制来读取该文件名，如下所示：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We were talking about the graph file before. Unzip the the crucial `classify_image_graph_def.pb` file
    from the TGZ file to the current directory. Open that as a binary by using TensorFlow''s
    own file loading mechanism, and then we''re going to create our graph definition
    from that, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过图文件。将 `classify_image_graph_def.pb` 这个关键的文件从 TGZ 文件解压到当前目录。使用 TensorFlow
    自身的文件加载机制以二进制方式打开它，然后我们将从这个文件创建我们的图定义，如下所示：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we are just loading the pre-trained model. Google already did the hard
    work for us, and we're going to read from that.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是加载预训练模型。谷歌已经为我们完成了艰苦的工作，我们将从那里读取。
- en: 'Then, as we did previously, we need to create our TensorFlow session. We do
    that with the `with` clause, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像我们之前做的那样，我们需要创建我们的 TensorFlow 会话。我们通过以下 `with` 语句来完成：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This model already has multiple layers called tensors. We need to extract the
    `softmax` layer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型已经具有多个称为张量的层。我们需要提取 `softmax` 层。
- en: The output of our model isn't just going to be that something was detected 100%;
    what it does is give a probability for each one. We might have, for example, a
    90% probability that our image is some sort of cat, a 20% probability that it's
    a squirrel, and 0.01% that it's a chair or something. Yes, you do get some wild
    classifications sometimes, although typically those probabilities are very small.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模型的输出不仅仅是检测到 100% 的东西；它为每一个东西都给出一个概率。例如，我们可能会有 90% 的概率认为我们的图像是某种猫，20% 的概率认为它是一只松鼠，0.01%
    的概率是椅子或其他东西。是的，有时你确实会得到一些非常离谱的分类，尽管通常这些概率都非常小。
- en: Some fraction of probability is calculated for each one of the thousand classes. Of
    course, the vast majority of them are going to be zero or very, very close to
    zero.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为每一千个类别中的每一个都计算了一部分概率。当然，其中绝大多数都是零或非常非常接近零。
- en: We want to extract the next-to-last layer, containing 2048 close descriptions
    of the image and the input image that provides the JPEG encoding of the image.
    Note that we didn't load the raw image data in a two-dimensional or three-dimensional
    vector (or tensor as they call it)—we still have it in JPEG encoding. We're just
    defining our variables to extract the outputs and find the inputs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要提取倒数第二层，其中包含 2048 个对图像和输入图像的JPEG编码的详细描述。请注意，我们没有以二维或三维向量（或他们称之为张量）的形式加载原始图像数据——我们仍然以JPEG编码的形式拥有它。我们只是在定义变量以提取输出和找到输入。
- en: NumPy's `squeeze` gets rid of all singleton dimensions. So, if we have a 1 by
    1000, this will convert it to a 1000 by 1.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的 `squeeze` 函数可以去除所有单维。所以，如果我们有一个 1 行 1000 列的矩阵，这将把它转换成 1000 行 1 列。
- en: 'Okay, so, we understand the inputs and outputs within our session. Just for
    understanding''s sake, we only want to extract the top five predictions, and we''re
    going to filter out predictions that have a probability of less than 10%. At most,
    we''re going to get five predictions, but it usually will be less as we disregard
    anything below 10%, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以，我们理解了会话中的输入和输出。仅仅为了理解，我们只想提取前五个预测，并且我们将过滤掉概率小于 10% 的预测。最多我们只能得到五个预测，但通常会更少，因为我们忽略了低于
    10% 的任何东西，如下所示：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We run the model and get the output of the image, and then we sort by our top
    five. We then iterate over those top predictions and convert to a human string
    by running the output's `node_id` through our `inceptiondict` dictionary. We read
    the `score`, and then we only print the output if the `score` is greater than
    10%.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行模型并得到图像的输出，然后按我们的前五个排序。然后我们遍历这些顶级预测，通过运行输出的 `node_id` 通过我们的 `inceptiondict`
    字典将其转换为人类字符串。我们读取 `score`，然后只有当 `score` 大于 10% 时才打印输出。
- en: We're just defining the function, we're not running it, so this should be instantaneous
    to run.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是在定义函数，我们并没有运行它，所以这应该运行得非常快。
- en: 'Now, we''re going to run this on some images. There are some sample images
    in a `sample_imgs` subdirectory. What we want do is test this, so just uncomment
    out one of these following lines to define our `image` variable:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对这个图像运行这个程序。在 `sample_imgs` 子目录中有一些样本图像。我们想要测试这个，所以只需取消注释以下这些行中的一行来定义我们的
    `image` 变量：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then, we're going to create a figure, look at what we see using the `imshow` function,
    and then use the `run_inference_on_image` function, which will output the results.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个图形，使用 `imshow` 函数查看我们看到的内容，然后使用 `run_inference_on_image` 函数，该函数将输出结果。
- en: 'To run the preceding block of code with our `cropped_panda.jpg` picture, uncomment
    the panda picture line. We can see the picture in the following output. It has
    classified it with about 90% probability as a `panda`, `giant panda`, or other
    synonym, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行前面的代码块并使用 `cropped_panda.jpg` 图片，取消注释熊猫图片行。我们可以在以下输出中看到图片。它以大约 90% 的概率将其分类为
    `panda`、`giant panda` 或其他同义词，如下所示：
- en: '![](img/3e0d0533-7f24-4ce6-b682-6ba2cfd74dea.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e0d0533-7f24-4ce6-b682-6ba2cfd74dea.png)'
- en: 'Let''s try it on something else. How about our `bicycle2.jpg` file? Uncomment
    the `bicycle2.jpg` line while commenting back the `cropped_panda.jpg` line, and
    we get the following output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在其他东西上试一试。比如我们的 `bicycle2.jpg` 文件？在取消注释 `bicycle2.jpg` 行的同时，注释掉 `cropped_panda.jpg`
    行，我们得到以下输出：
- en: '![](img/d65a051f-efee-4c1e-9858-8828f8245b18.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d65a051f-efee-4c1e-9858-8828f8245b18.png)'
- en: It has classified the picture with 91% probability as a `mountain bike`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它以 91% 的概率将图片分类为 `mountain bike`。
- en: 'We are getting a little specific here. Let''s try now with the `garbagecan.jpg`
    file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里变得有点具体了。现在让我们用 `garbagecan.jpg` 文件来试一试：
- en: '![](img/dfa410be-077c-4300-9284-bc03611180a3.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dfa410be-077c-4300-9284-bc03611180a3.png)'
- en: It wasn't as confident here, only about 67% probability in its classification.
    Sometimes that's the best we can do, but that's not too bad. That was the most
    likely result.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里它的置信度并不高，只有大约67%的概率被分类。有时这就是我们能做的最好了，但这并不太糟糕。这是最可能的结果。
- en: 'Let''s try the `bunny.jpg` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试`bunny.jpg`文件：
- en: '![](img/39d8e0ef-3a4f-4f22-846c-c5eedff42afd.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39d8e0ef-3a4f-4f22-846c-c5eedff42afd.png)'
- en: Alright, 87% probability that we have a rabbit. Looks pretty good.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们有87%的把握认为这是一只兔子。看起来相当不错。
- en: 'Now, let''s try the `trombone.jpg` file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试`trombone.jpg`文件：
- en: '![](img/df167616-f3f9-46de-97fb-0c58d795e430.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df167616-f3f9-46de-97fb-0c58d795e430.png)'
- en: Wow, very certain. Over 99% probability that the picture is of a `trombone`—very
    good.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，非常确定。这张图片是长号的可能性超过99%——非常好。
- en: 'If you''re a fan of a certain popular TV show, you might be wondering whether
    the classifier can recognize a hot dog. The answer to that is yes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个热门电视剧的粉丝，你可能想知道分类器是否能识别出热狗。答案是肯定的：
- en: '![](img/7085af23-dd09-4e00-b4b7-6d2dfa96cb8a.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7085af23-dd09-4e00-b4b7-6d2dfa96cb8a.png)'
- en: It does recognize a `hotdog`, with 97% confidence.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实识别出了一个`热狗`，置信度为97%。
- en: 'Finally, we''re going to run our classifier on `dog.jpg`, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们的分类器运行在`dog.jpg`图片上，如下所示：
- en: '![](img/cdd42cb6-d6ac-418f-bfc9-9c791a2ec34d.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cdd42cb6-d6ac-418f-bfc9-9c791a2ec34d.png)'
- en: Whoever trained this model was apparently a dog lover, so they defined a bunch
    of different dog classes. We get `Irish wolfhound`, `Russian wolfhound`, `gazelle
    hound`, and others returned. It seems to think that it's one of those!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，训练这个模型的人是一个狗爱好者，所以他们定义了多个不同的狗类。我们得到了`爱尔兰猎狼犬`、`俄罗斯猎狼犬`、`瞪羚猎犬`和其他一些返回的结果。它似乎认为它属于那些类别之一！
- en: This is working pretty well. If what we need happens to fall within those 1,000
    classes, then we're in good shape here. You should be able to adapt the code in
    the Jupyter Notebook to your needs. Hopefully, deep learning and image classification
    don't seem quite as intimidating as they did before.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得相当好。如果我们需要的恰好是那些1000个类别之一，那么我们在这里就做得很好。你应该能够将Jupyter Notebook中的代码适应你的需求。希望深度学习和图像分类不再像以前那样令人生畏。
- en: So, with that, we're going to move on to the next section, where we do some
    retraining with our own images and classify objects that are not already in Google's
    training database.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将继续到下一部分，我们将使用我们自己的图片进行一些重新训练，并分类那些尚未在谷歌训练数据库中的对象。
- en: Retraining with our own images
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我们自己的图片重新训练
- en: In this section, we're going to go beyond what we did with the pre-built classifier
    and use our own images with our own labels.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将超越我们使用预构建分类器所做的工作，并使用我们自己的图片和标签。
- en: 'The first thing I should mention is that this isn''t really training from scratch
    with deep learning—there are multiple layers and algorithms for training the whole
    thing, which are very time-consuming—but we can take advantage of something called
    *transfer learning*, where we take the first few layers that were trained with
    a very large number of images, as illustrated in the following diagram:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先应该提到的是，这并不是真正从头开始用深度学习进行训练——训练整个系统需要多个层次和算法，这非常耗时——但我们可以利用一种叫做**迁移学习**的技术，其中我们使用与大量图像训练的前几层，如下面的图所示：
- en: '![](img/0e63aeb4-46f6-4056-9ebb-35158efdabb3.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e63aeb4-46f6-4056-9ebb-35158efdabb3.png)'
- en: It's one of the caveats of deep learning that having a few hundred or a few
    thousand images isn't enough. You need hundreds of thousands or even millions
    of samples in order to get good results, and gathering that much data is very
    time-consuming. Also, running it on a personal computer, which I expect most people
    are using, is not computationally feasible.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习的一个注意事项是，拥有几百或几千张图片是不够的。你需要数十万甚至数百万个样本才能得到好的结果，而收集这么多数据是非常耗时的。此外，在个人电脑上运行它，我预计大多数人都在使用，在计算上是不切实际的。
- en: But the good news is that we can take layers from our pre-existing model and
    just do some tweaking at the end, and get some very good results. We're taking
    advantage of the pre-training by using input features that were trained on hundreds
    of thousands or millions of images, and transferring them to image types that
    the model has never seen before.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但好消息是，我们可以从我们的现有模型中提取层，并在最后进行一些调整，从而得到非常好的结果。我们通过使用在数十万或数百万张图片上训练的输入特征来利用预训练，并将它们转移到模型以前从未见过的图像类型。
- en: To do this, we borrow some code from TensorFlow Hub ([https://www.tensorflow.org/hub/](https://www.tensorflow.org/hub/)). But
    we have to make some tweaks to make it run more easily with reduced code and make
    it so that we can just drop it into our Jupyter Notebook and run it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们从 TensorFlow Hub ([https://www.tensorflow.org/hub/](https://www.tensorflow.org/hub/))
    借用了一些代码。但是，我们必须做一些调整，以便它能够以更少的代码运行，并且可以轻松地将其放入我们的 Jupyter Notebook 中并运行。
- en: In order to get started, we need some images on which to train, and different
    ways of doing that. Google has kindly provided a sample called `flower_photos` at
    the following link: [http://download.tensorflow.org/example_images/flower_photos.tgz](http://download.tensorflow.org/example_images/flower_photos.tgz).
    Once again, it's a TGZ file, so download the file and thoroughly unzip it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们需要一些用于训练的图片，以及不同的训练方法。谷歌很友好地提供了一个名为 `flower_photos` 的样本，链接如下：[http://download.tensorflow.org/example_images/flower_photos.tgz](http://download.tensorflow.org/example_images/flower_photos.tgz)。再次强调，它是一个
    TGZ 文件，所以请下载文件并彻底解压。
- en: You'll get a `flower_photos` directory, which will contain some subdirectories
    of different kinds of flowers such as tulips, dandelions, and so on, which were
    not among the 1,000 original classes. Those directory names will serve as the
    labels for those images. All we have to do is unzip them and then input flower
    photos in the our code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个 `flower_photos` 目录，其中将包含不同种类花朵的子目录，如郁金香、蒲公英等，这些种类并未包含在最初的 1,000 个类别中。这些目录名将作为这些图片的标签。我们只需要解压它们，然后在我们的代码中输入花朵照片。
- en: A cheap method to get a whole lot of photos is to use the Fatkun Batch Download
    plugin for Chrome ([https://chrome.google.com/webstore/detail/fatkun-batch-download-ima/nnjjahlikiabnchcpehcpkdeckfgnohf?hl=en](https://chrome.google.com/webstore/detail/fatkun-batch-download-ima/nnjjahlikiabnchcpehcpkdeckfgnohf?hl=en)).
    Using this, we can go somewhere like Google Image Search and search for whatever
    kind of object we want—animal, food, and so on—and grab hundreds of images pretty
    quickly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 获取大量照片的一个便宜方法是使用 Chrome 的 Fatkun 批量下载插件 ([https://chrome.google.com/webstore/detail/fatkun-batch-download-ima/nnjjahlikiabnchcpehcpkdeckfgnohf?hl=en](https://chrome.google.com/webstore/detail/fatkun-batch-download-ima/nnjjahlikiabnchcpehcpkdeckfgnohf?hl=en))。使用这个插件，我们可以去像
    Google 图片搜索这样的地方，搜索我们想要的任何类型的对象——动物、食物等等——并且可以快速地抓取数百张图片。
- en: There are similar plugins for Firefox, or whatever web browser you are using.
    As long as you don't mind using those kinds of images, if they will suit your
    needs then this is a good way to do it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox 或你使用的任何网络浏览器都有类似的插件。只要你不介意使用这类图片，如果它们能满足你的需求，那么这是一种很好的做法。
- en: After you're finished with the flower photos, I would suggest grabbing your
    own images. Think of something that you'd like to train on, something that you
    think would be useful. Try to get at least 100 images of each class and grab multiple
    classes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成花朵照片的处理后，我建议你抓取自己的图片。想想你想要训练的内容，想想你认为会有用的内容。尽量获取每个类别的至少 100 张图片，并抓取多个类别。
- en: For illustration purposes, I decided to classify some toys. Maybe you're running
    a toy store and you're taking inventory, or you're a collector and you want to
    know what exactly is in there—you just have a bunch of photos, and you want to
    classify them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明目的，我决定对一些玩具进行分类。也许你正在经营一家玩具店，正在清点库存，或者你是一位收藏家，想要了解里面具体有什么——你只是有一堆照片，想要对它们进行分类。
- en: 'I created four subfolders called `barbie`, `gi joe`, `my little pony`, and
    `transformers`, shown as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了四个子文件夹，分别命名为 `barbie`、`gi joe`、`my little pony` 和 `transformers`，如下所示：
- en: '![](img/2cc11a67-080f-4674-90a6-1854428df2cc.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2cc11a67-080f-4674-90a6-1854428df2cc.png)'
- en: Each folder contains over 100 images of each type. The filenames are not important—just
    the directory names are going to be used for the labeling.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件夹都包含每种类型超过 100 张的图片。文件名并不重要——只是目录名将被用于标签。
- en: So you can test whether or not it's working, you need to separate out some images.
    If you test on images that you trained on, then you're kind of cheating—you don't
    really know whether or not your model has generalized. So, make sure to pull out
    some images from that directory and put them in a separate directory for now.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以测试它是否工作，你需要将一些图片分离出来。如果你在训练过的图片上进行测试，那么你就是在作弊——你实际上不知道你的模型是否已经泛化。所以，请确保从该目录中提取一些图片，并将它们暂时放入一个单独的目录中。
- en: The code for retraining is introduced in the Jupyter Notebook file itself, so
    we're not going to go through the whole thing. We've created a file called `retrained.py`,
    which is based on the TensorFlow Hub version, but is more easily dropped into
    existing code and a lot of the variables are already taken care of.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 重新训练的代码在Jupyter Notebook文件中本身就有介绍，所以我们不会从头到尾讲解。我们创建了一个名为`retrained.py`的文件，它是基于TensorFlow
    Hub版本，但更容易集成到现有代码中，并且许多变量已经处理好了。
- en: 'All we need to do is import the `retrain` function, and then we retrain on
    our `toy_images` folder, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是导入`retrain`函数，然后在我们`toy_images`文件夹上重新训练，如下所示：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This generally takes a while. If you run the code on the `flower_photos` directory,
    that will take about half an hour, especially if doing it on a CPU and not a GPU.
    The `toy_images` example will take a little less time, because there aren't as
    many images.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常需要一段时间。如果你在`flower_photos`目录上运行代码，那可能需要半小时，尤其是在CPU上而不是GPU上。`toy_images`示例将花费更少的时间，因为图像数量较少。
- en: Training in general with machine learning is the time-consuming portion; that's
    what's going to tie up your computer for long periods. Running images through
    a classifier is quick, as we saw before, but training can take minutes, hours,
    days, or possibly even longer. In this case, we're looking at up to half an hour,
    depending on how many images are present.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中进行训练通常是耗时最多的部分；这就是为什么你的电脑会长时间占用。将图像通过分类器运行是很快的，就像我们之前看到的，但训练可能需要几分钟、几小时、几天，甚至可能更长。在这种情况下，我们可能需要半小时，这取决于有多少图像。
- en: 'After a couple of minutes, our `retrained` function has run successfully, with
    the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，我们的`retrained`函数成功运行，输出如下：
- en: '![](img/8d731320-2415-4076-af7c-1d63c38173bf.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d731320-2415-4076-af7c-1d63c38173bf.png)'
- en: I've turned down some of the verbosity in the `retrain` function, as otherwise
    it spits out a lot of messages that don't mean much. You can go into the code
    if you want and turn that up, if you're concerned it's not running successfully,
    but it should run just fine as long as everything's set up correctly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经降低了`retrain`函数的一些详细程度，否则它会输出很多没有太多意义的消息。如果你想检查代码是否成功运行，可以进入代码中将其调高，但只要一切设置正确，它应该会正常运行。
- en: 'Let''s confirm that it works:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认它是否工作：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We're going to look for that `.pb` file (Python binary file), which will be
    the output of what we did. So, that's the model, the input-output model, or graph
    as it's typically called in TensorFlow.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将寻找那个`.pb`（Python二进制文件）文件，它将是我们所做工作的输出。所以，那就是模型，输入输出模型，或者通常在TensorFlow中称为图。
- en: 'After running the code, we should get the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码后，我们应该得到以下输出：
- en: '![](img/0a5d97b2-603e-48c0-8898-c115bd18620b.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a5d97b2-603e-48c0-8898-c115bd18620b.png)'
- en: We have this file called `output_graph.pb`. That's the one we just created; you
    should see this file in your directory.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`output_graph.pb`的文件。那就是我们刚刚创建的；你应该能在你的目录中看到这个文件。
- en: 'The code for running your images isn''t quite as complicated. Loading our `output_graph.pb` graph
    file is similar to what we did before when we loaded the Inception model, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的图像的代码并不那么复杂。加载我们的`output_graph.pb`图文件与我们之前加载Inception模型时所做的类似，如下所示：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `read_tensor_from_image_file` function helps in reading data from the image
    file, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_tensor_from_image_file`函数有助于从图像文件中读取数据，如下所示：'
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are some defaults here, but they don't matter. Images don't necessarily
    need to be `299` by `299`. We're just dealing with JPEGs here, but if we have
    files in PNG, GIF, or BMP formats, the model can handle that. We just decode the
    images, put them into our variable, and store and return them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些默认值，但它们并不重要。图像不一定需要是`299`乘以`299`。我们这里只处理JPEG文件，但如果我们有PNG、GIF或BMP格式的文件，模型也能处理。我们只需解码图像，将它们放入我们的变量中，并存储和返回它们。
- en: 'As said before, the labels come from the directories. The following code will
    load the created `output_labels.txt` it''s going to load it from `output_labels.txt`,
    and that''s going to be our dictionary of sorts, as defined by our subdirectory
    names:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，标签来自目录。以下代码将加载创建的`output_labels.txt`，它将从`output_labels.txt`中加载，这将是我们的一种字典，由我们的子目录名称定义：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following code shows the `label_image` function. To find an image you know,
    give the correct filename, but there is a default just in case:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`label_image`函数。为了找到你已知的图像，给出正确的文件名，但有一个默认值以防万一：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I have hardcoded these in for simplicity. If you want to change stuff, you can,
    but I think that having it written there makes things easy to read and understand.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我为了简单起见硬编码了这些。如果你想改变东西，你可以，但我认为把它写在那里会让事情更容易阅读和理解。
- en: 'We load our graph file, read our data from the image file, and read layer names
    from the new model that we created, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们加载我们的图文件，从图像文件中读取数据，并从我们创建的新模型中读取层名称，如下所示：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We're just going to read the input and output layers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只读取输入和输出层。
- en: 'We define our session and get our results from `output_operation`. Again, we
    sort it to the `top_k` variable, and print the results:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了我们的会话，并从`output_operation`获取结果。再次，我们将它排序到`top_k`变量中，并打印结果：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are a lot of classes, but we're actually going to see it's always just
    going to be one result here.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 课程种类繁多，但实际上我们将会看到这里始终只有一个结果。
- en: Let's try our code again. As discussed, we separated a couple of images out
    into a separate directory, because we don't want to test on our training images,
    as that proves nothing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试我们的代码。正如讨论的那样，我们将一些图像分离到一个单独的目录中，因为我们不想在训练图像上测试，那样证明不了什么。
- en: 'Let''s test the retrained model on our first `transformers1.jpg` image. The
    model is to display the image and tell us what the classification results were:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的第一个`transformers1.jpg`图像上测试重新训练的模型。模型将显示图像并告诉我们分类结果：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/dcae58c2-27dc-481e-91d7-0ae2a5777014.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dcae58c2-27dc-481e-91d7-0ae2a5777014.png)'
- en: The model classified the image with a very high probability that this was a
    `transformers`. Since our images are distinct enough, and there are fewer classes,
    it's going to work very nicely. We see there is a 99.9% probability the picture
    is of a Transformer, a small probability that it is a GI Joe, and it's most definitely
    not a Barbie or a My Little Pony.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 模型以非常高的概率将图像分类为`transformers`。由于我们的图像足够独特，并且类别较少，它将工作得非常好。我们看到有99.9%的概率这张照片是变形金刚，有很小概率是G.I.
    Joe，而且肯定不是芭比或小马宝莉。
- en: 'We can use *Ctrl + /* to comment and uncomment lines in the code in Jupyter
    Notebook, and press *Ctrl + Enter* to run the code again with the `transformer2.jpg`
    picture:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*Ctrl + */*来在Jupyter Notebook中注释和取消注释代码行，并按*Ctrl + Enter*再次使用`transformer2.jpg`图片运行代码：
- en: '![](img/3adb0534-4ca0-41d6-8677-fa47e1374330.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3adb0534-4ca0-41d6-8677-fa47e1374330.png)'
- en: The output is `transformers` again. This time the model thinks it is slightly
    more likely to be a Barbie than a GI Joe, but the probability is insignificant.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 输出再次是`transformers`。这次模型认为它比G.I. Joe稍微更有可能是芭比，但概率微不足道。
- en: 'Let''s try again with the `mylittlepony1.jpg` picture:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试使用`mylittlepony1.jpg`图片：
- en: '![](img/db308670-2a26-4ff4-8e9f-cd2a92732552.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db308670-2a26-4ff4-8e9f-cd2a92732552.png)'
- en: And yes, it definitely looks like other images in the `my little pony` subfolder.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它确实看起来像`my little pony`子文件夹中的其他图片。
- en: 'Let''s take another picture, `mylittlepony3.jpg`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再拍一张照片，`mylittlepony3.jpg`：
- en: '![](img/1908b3b8-7218-43e2-bd3d-a0693597ea7f.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1908b3b8-7218-43e2-bd3d-a0693597ea7f.png)'
- en: 'Again, no problem classifying the image. Let''s take a look at `gijoe2.jpg`
    too:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，没有问题对图像进行分类。让我们也看看`gijoe2.jpg`：
- en: '![](img/d080b044-e64e-46fc-a8f9-9a0c5102b643.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d080b044-e64e-46fc-a8f9-9a0c5102b643.png)'
- en: There's a high probability of it being a `gi joe`, `transformers` and `barbie` are
    more likely than `my little pony`, but again all those probabilities are insignificant—it's
    definitely a `gi joe`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有很高的概率是`gi joe`，`transformers`和`barbie`比`my little pony`更可能，但再次，所有这些概率都是微不足道的——它肯定是一个`gi
    joe`。
- en: 'Finally, let''s try it on `barbie1.jpg`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在`barbie1.jpg`上尝试：
- en: '![](img/2074a3ed-55c3-4e38-beb4-419eb189c6eb.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2074a3ed-55c3-4e38-beb4-419eb189c6eb.png)'
- en: Again, definitely classified as a `barbie`, and `my little pony` was the second
    most likely, perhaps because of the colors; there tends to be more pink and purple
    on Barbie and My Little Pony toys.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，肯定被分类为`barbie`，`my little pony`是第二可能的选择，可能是因为颜色；芭比和小马宝莉玩具上通常有更多的粉色和紫色。
- en: Now we know how we can use our own images to retrain a pre-existing model. With
    not a lot of coding or CPU time, we can create a custom image classifier for our
    own purposes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用我们自己的图像来重新训练一个现有的模型。不需要太多的编码或CPU时间，我们可以为我们的目的创建一个定制的图像分类器。
- en: In the next section, we're going to talk about speeding up the computations
    with the help of your GPU.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何在你的GPU的帮助下加速计算。
- en: Speeding up computation with your GPU
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GPU加速计算
- en: In this section, we'll talk briefly about speeding up computations with your
    GPU. The good news is that TensorFlow is actually very smart about using the GPU,
    so if you have everything set up, then it's pretty simple.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要讨论如何使用GPU加速计算。好消息是TensorFlow实际上在利用GPU方面非常聪明，所以如果你已经设置好了一切，那么这相当简单。
- en: 'Let''s see what things look like if we have the GPU properly set up. First,
    import TensorFlow as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果GPU设置正确，事物看起来会是什么样子。首先，按照以下方式导入TensorFlow：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we print `tensorflow.Session()`. This just gives us information about
    our CPU and GPU (if it is properly set up):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们打印`tensorflow.Session()`。这仅仅给我们提供了关于我们的CPU和GPU（如果它已正确设置）的信息：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/d1703197-abb0-4678-a930-ad0f6aee9785.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1703197-abb0-4678-a930-ad0f6aee9785.png)'
- en: As we can see from the output, we're using a laptop with a GeForce GTX 970M,
    which is CUDA-compatible. This is needed in order to run TensorFlow with the GPU.
    If everything is set up properly, you will see a message very similar to the preceding
    output for your GPU, your card model, and details about it such as its memory
    and so forth.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从输出中可以看到，我们使用的是一块配备GeForce GTX 970M的笔记本电脑，它是CUDA兼容的。这是运行带有GPU的TensorFlow所必需的。如果一切设置正确，你将看到与前面输出非常相似的消息，包括你的GPU，你的卡型号以及它的内存等详细信息。
- en: TensorFlow is smart about it. We can override it ourselves, but that's only
    a good idea if we know what we're doing and we're willing to put in the extra
    work. Unless we know what we're doing, we're not going to get improved performance,
    so just leave the default settings.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow在这方面很聪明。我们可以自己覆盖它，但只有当我们知道自己在做什么，并且愿意投入额外的工作时，这才有好主意。除非我们知道自己在做什么，否则我们不会获得改进的性能，所以还是保留默认设置。
- en: Subsequent sections will run just fine on a CPU, just not quite as fast.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节在CPU上运行良好，只是速度不是特别快。
- en: The bad news about TensorFlow using the GPU is that setting it up isn't quite
    as straightforward. We previously covered the `pip` command, for example, `pip
    install tensorflow` and `pip install tensorflow-gpu`, which is a starting point,
    but we'll still need CUDA to be installed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关于TensorFlow使用GPU的坏消息是，设置它并不完全直接。例如，我们之前介绍了`pip`命令，比如`pip install tensorflow`和`pip
    install tensorflow-gpu`，这是一个起点，但我们仍然需要安装CUDA。
- en: I have version 9.0 installed. If you have a Quadro GPU or some sort of workstation,
    Tesla, or one of those specialized cards, you should use CUDA version 9.1\. It's
    platform-dependent, depending on what kind of GPU you have and, more particularly,
    what kind of operating system, so we can't go into full details here.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我已安装版本9.0。如果你有一块Quadro GPU或某种工作站，Tesla，或者那些专用卡，你应该使用CUDA版本9.1。它是平台相关的，取决于你有什么样的GPU，以及更具体地说，你有什么样的操作系统，所以我们不能在这里详细介绍。
- en: What's important to know is that we can't just install `tensorflow-gpu`; we
    have to install CUDA. Download and install CUDA for your operating system from
    the NVIDIA website ([https://developer.nvidia.com/cuda-toolkit](https://developer.nvidia.com/cuda-toolkit)).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 需要知道的重要一点是，我们不仅需要安装`tensorflow-gpu`，我们还需要安装CUDA。从NVIDIA网站下载并安装适用于您的操作系统的CUDA（[https://developer.nvidia.com/cuda-toolkit](https://developer.nvidia.com/cuda-toolkit)）。
- en: In addition to that, TensorFlow requires the **NVIDIA CUDA® Deep Neural Network**
    (**cuDNN**) library, which is a big DLL file for Windows, or a shared object (`.SO`)
    file for Linux. It's similar for macOS as well. It's just one file, which needs
    to be in your path. I generally copy it over to my `CUDA` directory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，TensorFlow还需要**NVIDIA CUDA®深度神经网络**（**cuDNN**）库，这是一个Windows的大DLL文件，或Linux的共享对象（`.SO`）文件。macOS的情况也类似。它只是一个文件，需要放在你的路径中。我通常将其复制到我的`CUDA`目录中。
- en: If you do have one, try to install CUDA, do try to install cuDNN, and try to
    get TensorFlow working. Hopefully, that will speed up computations for you.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实有一块，尝试安装CUDA，尝试安装cuDNN，并尝试让TensorFlow运行起来。希望这能加速你的计算。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to classify images using a pre-trained model
    based on TensorFlow. We then retrained our model to work with custom images.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用基于TensorFlow的预训练模型来分类图像。然后我们重新训练我们的模型以处理自定义图像。
- en: Finally, we had a brief overview of how to speed up the classification process
    by carrying out the computation on a GPU.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要概述了如何通过在GPU上执行计算来加速分类过程。
- en: Using the examples covered in this book, you will be able to carry your our
    custom projects using Python, OpenCV, and TensorFlow.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本书中涵盖的示例，你将能够使用Python、OpenCV和TensorFlow来执行你的自定义项目。
