- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reusable IA Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll discuss four **reusable IA components**. These reusable
    logic pieces are short, making them easy to add to existing IA Processes. They’re
    built by combining core BP functionality, such as Environment Variables, Session
    Variables, and Credentials, making them simple to implement. Their purpose is
    to provide functionality that’s useful to every IA solution, without requiring
    major rework.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, we’ll look at the implementation of four components:'
  prefs: []
  type: TYPE_NORMAL
- en: IA session control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ML prediction kill switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ML model versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New ML model evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download and import the two `.bprelease` files from the `ch6` folder on GitHub:
    [https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch6](https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch6).'
  prefs: []
  type: TYPE_NORMAL
- en: IA session control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Session Variables** are used when the Controller needs to change how execution
    behaves during an active session. In the context of IA, the most common reasons
    for wanting to change execution behavior are to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Force items to undergo HITL review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable HITL review temporarily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Force shared data used for reviews to be recreated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing HITL review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There may be a need to force all items in a running Session to undergo HITL
    review, disable HITL completely, and revert to the default behavior. Forcing all
    items in a Session to be reviewed can be useful for debugging and model validation
    purposes. Disabling HITL temporarily could be used when there’s a shortage of
    reviewers or when the need to meet SLAs takes priority over the need for review.
  prefs: []
  type: TYPE_NORMAL
- en: In the design examples that we’ve seen in previous chapters, the data used to
    specify the thresholds or random sampling rates were stored in Environment Variables.
    Changing Environment Variables *won’t* affect Sessions that are already running.
    However, they’ll affect *all* Sessions moving forward, which might not be desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing a way to force HITL reviews to happen in a currently running Session
    is simple. Create a Data Item with **Exposure** set to **Session**. Set **Data
    Type** to **Flag**, with **Initial Value** set to **False**. If the value is **False**,
    we continue with the random sampling or thresholding logic. If the value is **True**,
    we mark the Item as requiring HITL review. The best place to locate a check for
    this Flag is just before we tag or update the status of the Item to indicate that
    it requires manual review:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – A Session variable to force HITL review](img/B18416_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – A Session variable to force HITL review
  prefs: []
  type: TYPE_NORMAL
- en: Disabling HITL review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, we can create a new Session variable to disable HITL. Create a Data
    Item, set **Data Type** to **Flag**, **Exposure** to **Session**, and **Initial
    Value** to **False**. When the value is **False**, the original review logic is
    respected. When the value is **True**, HITL review is skipped, and automated processing
    continues with the original predicted value. This Flag should be checked just
    before we update the Item’s Tags or Status to indicate that HITL review is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – A Session variable to disable HITL review](img/B18416_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – A Session variable to disable HITL review
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if both the **Force HITL Review** and **Disable HITL Review**
    Session Variables’ Values are set to **True**? **Disable HITL Review** “overrides”
    **Force HITL Review**, since it’s checked later. The following table summarizes
    what happens for different combinations of the two Flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Force** **HITL Review** | **Disable** **HITL Review** | **Behavior** |'
  prefs: []
  type: TYPE_TB
- en: '| False | False | Use the Process’s original logic (this is the default behavior)
    |'
  prefs: []
  type: TYPE_TB
- en: '| False | True | All items in the Session will continue automated processing
    *without* HITL review |'
  prefs: []
  type: TYPE_TB
- en: '| True | False | All Items in the Session *will* require review |'
  prefs: []
  type: TYPE_TB
- en: '| True | True | All Items in the Session will continue automated processing
    *without* HITL review |'
  prefs: []
  type: TYPE_TB
- en: Table 6.1 – Force HITL Review and Disable HITL Review Session variable behavior
  prefs: []
  type: TYPE_NORMAL
- en: Forcing review data recreation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A potentially brittle part of an IA solution lies in the data-sharing interface
    between BP and the reviewers. There are numerous possible scenarios where a record
    could go missing, leading to a prediction that cannot be reviewed. This Item ends
    up stuck unless the Controller manually edits its Status from the `Flag` Session
    variable as well, similar to **Force HITL Review** and **Disable** **HITL Review**.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve discussed three Session Variables that are unique to IA and how they can
    be set up. Next, let’s go through an example where the three Session Variables,
    including modifications to the Process logic, are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – three IA Session Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we’ll look at a modified version of the *three* Processes,
    *three* Work Queue design from [*Chapter 5*](B18416_05.xhtml#_idTextAnchor075),
    and see exactly where in the Process diagram the three Session Variables have
    been added. Then we’ll test the Session Variables to ensure that they function
    as expected. Our goal is to understand how and where we should check for the Session
    Variables in the Process. This example has seven high-level steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify the Release contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine the logic for the `Force HITL Review` Session variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test `Force HITL Review` from the Control Room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine the logic for the `Force Create Review Data` Session variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test `Force Create Review Data` from the Control Room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine the logic for the `Disable HITL Review` Session variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test `Disable HITL Review` from the Control Room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the release contents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let’s get familiar with the contents of the Release file for this example.
    Verify that *three* Processes, *three* Work Queues, and *three* Environment Variables
    have been imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Example 1’s Release contents](img/B18416_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Example 1’s Release contents
  prefs: []
  type: TYPE_NORMAL
- en: The first Process, named **Example 1A – Three IA Session Variables**, only performs
    the standard business logic and isn’t affected by the three Session Variables
    described in this section. Process 2, **Example 1B – Force HITL Review**, has
    one of the Session Variables. Let’s look at it next.
  prefs: []
  type: TYPE_NORMAL
- en: Examine the Force HITL Review Session variable logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Force HITL Review** Session variable controls whether we want all ML
    predictions to undergo human review. This belongs in Process 2, which is where
    ML prediction is made and the thresholding or random sampling logic is checked.
    Let’s find the Decision Stage logic in Process 2 that checks for our Session variable:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Example 1B – Three IA Session Variables** Process in the *Ch6* Group
    in the Process Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See that a global Session variable has been added to the `Main Page`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The Session Variable is saved on the Main Page of Process 2](img/B18416_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The Session Variable is saved on the Main Page of Process 2
  prefs: []
  type: TYPE_NORMAL
- en: Open the `02 Check for Manual` `Review` Page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the *Require Manual Review?* Decision Stage. See that we’ve added a check
    for the Session Variable as an `OR` condition in the Expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The Session Variable has been added to the Decision Stage](img/B18416_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The Session Variable has been added to the Decision Stage
  prefs: []
  type: TYPE_NORMAL
- en: Test the Force HITL Review Session Variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we know how the Session Variable is checked, let’s test it in the
    Control Room. This Process adds 10 items to [*Chapter 6*](B18416_06.xhtml#_idTextAnchor093)
    *Example 1* *Queue 1*:'
  prefs: []
  type: TYPE_NORMAL
- en: Run **Example 1A – Three IA Session Variables** in the Control Room. Wait for
    the Session to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open **Control** | **Session Management**. Click on **Show Session Variables**
    to ensure that the **Session Variables** panel is open:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Ensure that the Session Variables panel is opened](img/B18416_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Ensure that the Session Variables panel is opened
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the panel open will allow us to quickly change the value of the `Force
    HITL Review` Session Variable in *step 4*.
  prefs: []
  type: TYPE_NORMAL
- en: Run **Example 1B – Force HITL Review** in the Control Room. Do *not* wait for
    the Session to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Force HITL Review** Session Variable to **True** in the **Session
    Variables** panel. Every ML prediction that’s made from this point forward will
    be marked as needing HITL review:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Set the Force HITL Review Session Variable to True](img/B18416_06_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Set the Force HITL Review Session Variable to True
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Session is complete, view the contents of [*Chapter 6*](B18416_06.xhtml#_idTextAnchor093)
    *Example 1 Queue 1*. Depending on how quickly you changed the Session Variable,
    you should see all, or almost all, of the Queue Items as needing manual review:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Almost every Item in Work Queue 1 should require a manual review](img/B18416_06_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Almost every Item in Work Queue 1 should require a manual review
  prefs: []
  type: TYPE_NORMAL
- en: We’ve confirmed that the `Force HITL Review` Session variable is working. Now,
    let’s look at the Session variable that forces the re-creation of review data.
  prefs: []
  type: TYPE_NORMAL
- en: Examine the Force Create Review Data Session Variable logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall that the third Process contains the logic to write review data to disk
    and checks to see whether the review has been completed. Here, we’ll examine Process
    3 to see how the file recreation Session Variable logic has been implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Example 1C - Disable HITL Review and Force Create Review Data** Process
    in the *Ch6* Group in the Process Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See that two global Session Variables are on the `Main Page`. The `Force Create
    Review Data` Session Variable is what we’re interested in here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Two Session Variables are saved on the Main Page of Process
    3](img/B18416_06_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Two Session Variables are saved on the Main Page of Process 3
  prefs: []
  type: TYPE_NORMAL
- en: Open the `01 Write Shared Review` `Data` Page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the Block named **Session Variable Logic**. This Block is newly added to
    this Page compared to the original example in the previous chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the *Force Create Review Data?* Decision Stage. We’ll check to see whether
    **Force Create Review Data** is **True**. If it is, we’ll try to delete the existing
    file and remove references to it from our Item Data. Then we’ll proceed to create
    a new review file as if it never existed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.10 – The logic that allows for review files to be forcibly created](img/B18416_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – The logic that allows for review files to be forcibly created
  prefs: []
  type: TYPE_NORMAL
- en: Test the Force Create Review Data Session Variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let’s test to see whether the Session Variable works. We will be running
    Process 3 a total of three times. The first run creates all of the review files
    once. The second run confirms that the review files don’t get recreated by default.
    For the third run, we’ll change the Session Variable and see that the previous
    review files are being deleted, with newer ones being created in their place.
  prefs: []
  type: TYPE_NORMAL
- en: Run **Example 1C - Disable HITL Review and Force Create Review Data** in the
    Control Room. This Process also has a sleep Stage between items to make it easier
    to edit Session Variables. Wait for the Session to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the folder defined by the `Ch6 Example 1 To Review Folder Path` Environment
    Variable in Windows Explorer. Verify that the number of files present in the folder
    is equal to the number of items that are waiting for manual review. Keep note
    of the timestamps of when these files were created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the deferral times of the Items in [*Chapter 6*](B18416_06.xhtml#_idTextAnchor093)
    *Example 1 Queue 3* to pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run **Example 1C - Disable HITL Review and Force Create Review Data** in the
    Control Room for a second time. Wait for the Session to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the folder defined by the `Ch6 Example 1 To Review Folder Path` Environment
    Variable. Verify that the timestamps of the files have not changed. This indicates
    that the review files haven’t been recreated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the deferral times of the items in [*Chapter 6*](B18416_06.xhtml#_idTextAnchor093)
    *Example 1 Queue 3* to pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run **Example 1C - Disable HITL Review and Force Create Review Data** in the
    Control Room for a third time. Do *not* wait for the Session to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Force Create Review Data** Session Variable to **True** in the **Session
    Variables** panel. Every Item from this point forward will have its review data
    recreated. Wait for the Session to complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Set the Force Create Review Data Session Variable to True](img/B18416_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Set the Force Create Review Data Session Variable to True
  prefs: []
  type: TYPE_NORMAL
- en: Return to the folder defined by the **Ch6 Example 1 To Review Folder Path**
    Environment Variable. Verify that the date-modified timestamps of the files have
    changed, indicating that they’ve been recreated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, we’ve tested two of our Session Variables. Let’s proceed and
    look at the third, which is used to disable HITL review checking.
  prefs: []
  type: TYPE_NORMAL
- en: Examine the Disable HITL Review Session variable logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our final Session Variable is also in the third Process. Let’s see how it’s
    implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Main Page` of this Process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `02 Check for Reviewed` `Predictions` Page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See that a Decision Stage named **Disable HITL Review** has been added, which
    skips to the Stages that should run after an Item has been reviewed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.12 – A Decision Stage has been added to Disable HITL Review](img/B18416_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – A Decision Stage has been added to Disable HITL Review
  prefs: []
  type: TYPE_NORMAL
- en: Test the Disable HITL Review Session Variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the last section of this example, we will run the third Process again, set
    the **Disable HITL Review** Session Variable to **True**, and verify that the
    Items have had their Status and Tags removed in [*Chapter 6*](B18416_06.xhtml#_idTextAnchor093)
    *Example 1* *Queue 1*:'
  prefs: []
  type: TYPE_NORMAL
- en: Run **Example 1C – Disable HITL Review and Force Create Review Data** in the
    Control Room. Do *not* wait for the Session to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Disable HITL Review** Session Variable to **True** in the **Session
    Variables** panel. Every Item from this point forward will no longer require HITL
    review. Wait for the Session to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'View the contents of the [*Chapter 6*](B18416_06.xhtml#_idTextAnchor093) *Example
    1 Queue 1* Work Queue. The Status of the Items that were previously **Manual Review
    Required** should now be **Manual Review Complete** with their Tags removed. The
    Items in Queue 1 are ready to continue their automated Processing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.13 – The Items in Queue 1 have skipped the HITL review](img/B18416_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – The Items in Queue 1 have skipped the HITL review
  prefs: []
  type: TYPE_NORMAL
- en: We’ve completed the example in which we implemented a reusable design snippet
    containing three Session Variables. These Session Variables enable us to control
    IA-specific behaviors while the Session is still running. Now, let’s move on from
    looking at Session-specific design controls to a design component that can work
    across multiple Sessions.
  prefs: []
  type: TYPE_NORMAL
- en: ML prediction kill switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that a significant flaw is discovered in an ML algorithm after it’s
    already running in production. We’d like to stop *all Sessions* that are already
    in flight from making predictions with the model. One option is to disable the
    ML model from its source – for instance, by turning off the cloud service or internal
    web server. However, it’s fairly unlikely that this could be done by a member
    of the IA team and achieved in a short period of time.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious option available to the IA controller team is to use *Request
    Stop*, but based on the standard BP Process template, the check for *Stop* only
    happens after an Item has finished executing. Adding a *Session Variable* to stop
    ML predictions is also an option if the number of concurrent running Sessions
    is low enough. But what if we have dozens, or even hundreds of Sessions underway?
  prefs: []
  type: TYPE_NORMAL
- en: The design component that can be used to prevent an ML prediction from running
    across *all Sessions* here is a **kill switch**. The purpose of the kill switch
    is to allow an IA controller to stop all currently running Sessions from starting
    an ML prediction, in a controlled manner. Implementing a kill switch is simple;
    however, it uses a BP feature – the *Credential*, in an unintended fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2 – kill switch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since implementing a kill switch is simple, let’s build one from scratch and
    see how it works. The kill switch uses a Credential and its *Marked as invalid*
    property. At a high level, we will be going through seven steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the Credential and grant it Permissions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Process that uses the Credential.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Exception handling to the Process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finalize the kill switch logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the Process with an *inactive* kill switch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate the kill switch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the Process with an *active* kill switch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Credential and grant Permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step of implementing the kill switch is to create a new credential:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Credential from the **System** | **Security** | **Credentials**
    area of BP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the credential **Kill Switch**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Name the Credential “Kill Switch”](img/B18416_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Name the Credential “Kill Switch”
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Access** **Rights** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Security Roles** sub-tab and select the **All Roles** checkbox.
    Note that this isn’t best practice, but we’re doing it to simplify the example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Processes (legacy)** sub-tab and check the **All** **Processes**
    checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Resources (legacy)** sub-tab and check the **All** **Resources**
    checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the Credential.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the Process and kill switch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let’s create a BP Process that uses this Credential:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Process named **Example 2 – Test Kill Switch** in the *Ch6* Group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **Example 2 – Test Kill Switch** Process in the Process Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an Action Stage to the diagram.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Action Stage, then set the `"Kill Switch"` as **Credentials Name**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Add a Credentials::Get Action to the diagram](img/B18416_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Add a Credentials::Get Action to the diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Outputs** tab. Create a Data Item named **Status** to store
    the Status Output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Store the Status Output of the Credentials::Get action](img/B18416_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – Store the Status Output of the Credentials::Get action
  prefs: []
  type: TYPE_NORMAL
- en: Save the Action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Link** *Start* to the Action.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Exception handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next part of the kill switch is to add some simple Exception handling.
    This IA component needs to handle Exceptions if the Credential has been accidentally
    deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a Block around the `Kill Switch`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Recover Stage inside the Block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Link** the Recover Stage to a Resume Stage. The Resume Stage should be outside
    of the Block.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an Exception Stage. Fill in the details as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Create an Exception](img/B18416_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – Create an Exception
  prefs: []
  type: TYPE_NORMAL
- en: '**Link** the Resume Stage to the Exception Stage. The diagram so far should
    look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.18 – The kill switch Process diagram so far](img/B18416_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – The kill switch Process diagram so far
  prefs: []
  type: TYPE_NORMAL
- en: The kill switch structure is almost complete. Next, we need to add logic to
    check the status of the Credential.
  prefs: []
  type: TYPE_NORMAL
- en: Finalize the kill switch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The kill switch makes use of the Credential’s *Marked as invalid* property.
    Let’s add a Decision Stage to check for it:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a Decision Stage to the diagram inside the *Kill* *Switch* Block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the Decision Stage’s name to `Status = Invalid?` and the Expression to
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 6.19 – The Decision Stage setup](img/B18416_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – The Decision Stage setup
  prefs: []
  type: TYPE_NORMAL
- en: Copy and paste the Exception Stage named *SE – Kill Switch Triggered* into the
    diagram again so that it appears twice. Ensure that this new Exception is located
    inside the *Kill* *Switch* Block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Link** the **Credentials::Get** Action to the *Status = Invalid?* Decision
    Stage.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Link** the Decision Stage’s *Yes* path to the newly-pasted Exception and
    the *No* path to *End*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the Process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that the diagram looks similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.20 – The final kill switch test Process](img/B18416_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – The final kill switch test Process
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now completed the kill switch. It checks to see whether a Credential is
    *Marked as invalid*. If it is, an Exception is thrown. If not, we can continue
    to the Stages that follow. When using this kill switch in a real IA Process, the
    Decision Stage should link directly to the ML prediction calling Stages instead
    of to *End*.
  prefs: []
  type: TYPE_NORMAL
- en: Run the Process from the Process Studio with the kill switch inactive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s run the Process as-is, with a dormant kill switch. This is the default
    behavior, or what will happen when we want our IA Process to make ML predictions:'
  prefs: []
  type: TYPE_NORMAL
- en: Run **Example 2 – Test Kill Switch** from the Process Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See that it simply goes from **Start** to **End**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve seen the uneventful case where the kill switch is inactive. Next, we’ll
    activate the ML kill switch.
  prefs: []
  type: TYPE_NORMAL
- en: Activate the kill switch by marking the Credential as invalid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To activate the kill switch, we mark the Credential as invalid. When the kill
    switch is active, execution will be prevented from continuing past the *Kill Switch*
    Block. Under normal circumstances, we would activate the kill switch while a Session
    is still running. However, we’re triggering it outside of a Session run for the
    benefit of readers who are using the Trial and Learning editions of BP.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **System** | **Security** | **Credentials** and open the Credential
    named **Kill Switch**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the **Marked as invalid** checkbox and save the Credential:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Check the Credential’s Marked as invalid box](img/B18416_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – Check the Credential’s Marked as invalid box
  prefs: []
  type: TYPE_NORMAL
- en: With the Credential marked as invalid, our kill switch is *active*, and all
    current and future Session runs of the *Test Kill Switch* Process will throw the
    Exception when execution reaches the *Status = Invalid?* Decision Stage.
  prefs: []
  type: TYPE_NORMAL
- en: Run the Process from the Process Studio with the kill switch active
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the kill switch active, let’s run our Process again. This should throw
    an exception, preventing us from reaching the area of the Process past the *Kill*
    *Switch* block:'
  prefs: []
  type: TYPE_NORMAL
- en: Run **Example 2 – Test Kill Switch** from the Process Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See that the Exception is thrown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An Exception is thrown when the Process tries to obtain an invalidated Credential.
    Work stops on the current item, and subsequent items, across *all Sessions* using
    this particular Credential. This lasts until the Credential is marked as valid
    again. This kill switch is best paired with Item Statuses and a Choice Stage that
    allows execution to be skipped right before the kill switch logic is called.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Users who want to mark a Credential as invalid might need additional Permissions
    in BP. Using a kill switch in production may require a review of the Logical Access
    Model, which defines which Users should have which User Roles, and which User
    Roles should have which Permissions in BP.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting the Credential (not recommended) can also be done to trigger the kill
    switch, but you must remember to recreate the Credential with the exact same name.
    Creating and deleting Encryption Schemes and Environment Variables could also
    be used to implement kill switches, but using Credentials is a cleaner implementation.
    Checking the **Marked as invalid** checkbox is simpler to do and undo.
  prefs: []
  type: TYPE_NORMAL
- en: You’d generally have one kill switch for each ML model in production. The same
    kill switch Credential can be used across different Processes if multiple Processes
    use the same ML model.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve finished discussing the kill switch. Let’s move on to the third IA component
    of this chapter, which discusses the need to version ML models for auditing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: ML model versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ML programs, like all software, should receive regular updates. Updates are
    needed for many reasons – there could be new data, changes in the ML framework,
    improvements to the model tuning, security fixes, and so on. Regardless of why
    an update has occurred, the IA team should be notified when they happen as they
    can affect how predictions are made.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, production-facing ML models will be **versioned** by the vendor. Updates
    to the model should result in new documentation and a *new URL endpoint*. Having
    a new endpoint allows the IA team to consciously choose when to use an updated
    model and revert to an older model if necessary. In reality, the ML vendor might
    simply reuse the same endpoint with an updated model and not actively notify customers
    of changes.
  prefs: []
  type: TYPE_NORMAL
- en: If the IA team isn’t actively notified of changes to the ML model, it should
    *manually* keep track of when updates occur *for debugging and auditing purposes*.
    Otherwise, when we look at our Session Logs, we won’t know which version of the
    model was actually being used! Our goal is to know *which version of an ML model
    was used by looking only at the Session Logs*. But since there are multiple ways
    to trigger an ML prediction, it isn’t immediately obvious how this can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of versioning is not to ensure determinism. A deterministic model
    is one where the same set of inputs always results in the same prediction. Many
    models introduce randomness; for example, generative AI gives you different outputs
    even if you provide the same prompt multiple times. For versioning, we’re not
    looking for determinism, but we want to be confident that the model was created
    using the same data, underlying algorithms, libraries, hyperparameters, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Two different ways of calling web APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web APIs are by far the most common way to deploy an ML model. In BP, we connect
    to web APIs either through *Objects* or *Web API Services* (potentially downloaded
    from the DX). The URL of the API will either be embedded as a Data Item, in the
    case of an Object, or directly saved in the Web API Services configuration. This
    leads to *four* different scenarios that we need to consider when thinking about
    how ML models can be versioned in BP. The Object case is also applicable to Code
    Stages and CLI scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '| **BP** **calling method** | **Do new models have** **separate endpoints?**
    | **What** **to do** |'
  prefs: []
  type: TYPE_TB
- en: '| Object | Yes | Enable logging in the Object Stage to show which URL is being
    used |'
  prefs: []
  type: TYPE_TB
- en: '| Object | No | Keep track of versions manually |'
  prefs: []
  type: TYPE_TB
- en: '| Web API Services | Yes | Keep track of versions manually |'
  prefs: []
  type: TYPE_TB
- en: '| Web API Services | No | Keep track of versions manually |'
  prefs: []
  type: TYPE_TB
- en: Table 6.2 – Four ways to version ML models for debugging and auditing
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we’ll go through each of the four web API calling scenarios
    outlined in *Table 6.2*.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a web API using an Object when a new endpoint is provided
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say that the ML vendor has updated its model and has also provided us
    with a new URL endpoint. If we’re calling this URL using an Object, we can tie
    a Session run to which model is being used by simply logging the URL. In the Object,
    the URL will either be stored as a Data Item or an Environment Variable, or directly
    typed in as an Input to an Action. Regardless of how the URL is input into the
    Object, all we need to do is enable logging in the appropriate Stage. Note that
    **Stage logging** in Objects is disabled by default, so we must explicitly turn
    logging on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Enable Stage logging in the Object to log the URL endpoint](img/B18416_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.22 – Enable Stage logging in the Object to log the URL endpoint
  prefs: []
  type: TYPE_NORMAL
- en: Calling a web API using an Object when the vendor reuses an existing endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the vendor doesn’t provide a new endpoint when the model is updated, we need
    to create our own versioning scheme and explicitly log that in the Session Logs
    just prior to the API call. I recommend using `Date Time`, which stores the date
    of when we know for certain that a model was updated as the versioning scheme.
    Let’s implement this IA component together in an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3 – versioning ML endpoints manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Environment Variables* are the most suitable place to store our API version,
    since we’d like to update its value outside of the Process and Object diagrams.
    However, changes to Environment Variables show up in *Audit Logs*, not *Session
    Logs*. Therefore, we can’t tell which ML model version is used by a particular
    Session run just by looking at Session Logs. You’d need to cross-reference the
    *dates of the Session Logs* with the *Audit Logs* to find out when that Environment
    Variable was modified and what the value has been changed to. Needing to look
    at two different types of logs is not ideal.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – Changes to Environment Variables appear in the audit log](img/B18416_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.23 – Changes to Environment Variables appear in the audit log
  prefs: []
  type: TYPE_NORMAL
- en: A better solution is to always log the value of the Environment Variable in
    the Session Logs right before our API call. This makes it easy to find out which
    API version is being used to make a prediction. To achieve this, we add a “dummy”
    Calculation Stage right before our API call, with logging enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’ll demonstrate how to implement ML versioning that results
    in the ML version appearing in the Session Logs. We’ll go through five high-level
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Environment Variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a test Process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Process in the Control Room and view the Session Logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the Environment Variable with a new API model version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Process again in the Control Room and view the Session Logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Environment Variable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, we need to create an Environment Variable and populate it with a `DateTime`
    value – this will be the “version” of the API that is currently in use:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **System** | **Processes** | **Environment Variables**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new Environment Variable named `DateTime`, and the Value to your current
    DateTime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Apply**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a test Process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, let’s create a test Process that calls a dummy API Object. The dummy
    Object takes the place of a real ML API call:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Process named **Example 3 – ML Versioning** in the *Ch6* Group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **Example 3 – ML Versioning** in the Process Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Ch6 Example 3 ML API Version` Environment Variable to the diagram as
    a Data Item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a Calculation Stage under `Temp` Data Item and set **Stage logging** to
    **Enabled**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.24 – Create a Calculation Stage to log the Environment Variable
    value](img/B18416_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.24 – Create a Calculation Stage to log the Environment Variable value
  prefs: []
  type: TYPE_NORMAL
- en: What we’re doing is logging the Environment Variable’s value to the Session
    logs by saving it to a throwaway Data Item named `Temp`.
  prefs: []
  type: TYPE_NORMAL
- en: Add an `"www.testapi.com"`. Set **Stage logging** to **Enabled**. We will use
    this **Set Clipboard** Action as a stand-in for actually calling an API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Link** **Start** to the Calculation Stage, the Calculation Stage to the Action,
    and the Action to **End**. The completed diagram should look like the following
    figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.25 – A simple test Process](img/B18416_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.25 – A simple test Process
  prefs: []
  type: TYPE_NORMAL
- en: Publish and save the Process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test Process and view the Session logs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s run the Process once in the Control Room and see what the Session Logs
    show:'
  prefs: []
  type: TYPE_NORMAL
- en: Run **Example 3 – ML Versioning** in the Control Room and wait for the Session
    to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Session Log for that Session run. Make a note of the Value of the
    **Log API Version** Calculation Stage and the URL of our “fake API call,” **Set
    Clipboard**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.26 – View the Session Logs and take note of the ML API version and
    URL](img/B18416_06_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.26 – View the Session Logs and take note of the ML API version and
    URL
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose that the ML vendor has updated the ML model while *keeping the
    URL endpoint the same*. Logging the values of the “URL” in **Set Clipboard** won’t
    let us know that the model has changed based on the Session Logs. We will need
    to update our Environment Variable to a new model version value.
  prefs: []
  type: TYPE_NORMAL
- en: Update the Environment Variable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we don’t need to update the URL, let’s update the Environment Variable
    to a new `DateTime` value. This along with our Calculation Stage will record the
    fact that the underlying ML model has been updated, despite the URL staying the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **System** | **Processes** | **Environment Variables**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `Ch6 Example 3 ML API Version` to your current DateTime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Apply**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test Process and view the Session Logs again
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s run the Process again and verify that changing the Environment Variable
    is reflected in the Session Logs:'
  prefs: []
  type: TYPE_NORMAL
- en: Run **Example 3 – ML Versioning** in the Control Room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Session Log for the latest Session run. See that the updated Environment
    Value has been reflected in our logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.27 – The updated Environment Variable is reflected in the Session
    Logs](img/B18416_06_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.27 – The updated Environment Variable is reflected in the Session Logs
  prefs: []
  type: TYPE_NORMAL
- en: In this third example, we discussed a component that includes an Environment
    Variable and a Calculation Stage. The purpose of this component is to enable the
    manual versioning of ML models for debugging and auditing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not completely necessary to use the Calculation Stage, as changes to the
    Environment Variable are reflected in the Audit Logs. This could be cross-referenced
    with the Session Logs to determine which version of an ML model was used during
    a Session run. However, it’s simpler to have the ML model version saved directly
    in the Session Logs and avoid potential issues in obtaining the Audit Logs, such
    as user access restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Web API Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a web API is used instead of an Object, the base endpoint will be saved
    directly somewhere in the configuration. In the following figure, it’s saved in
    each individual Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.28 – The URL is saved in the Web API Services configuration](img/B18416_06_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.28 – The URL is saved in the Web API Services configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that the API version changes from *v1* in the preceding figure to
    *v2*. The *Audit Logs* will show that the Web API Service has been modified, but
    the new and previous URLs *can’t be seen*. This doesn’t allow us to know exactly
    which URL (and thus model) was used during a Session run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.29 – The previous and new URLs can’t be found in the Audit Logs](img/B18416_06_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.29 – The previous and new URLs can’t be found in the Audit Logs
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if we’re using Web API Services to make our ML prediction, it doesn’t
    matter whether a new endpoint is provided or not – *historic changes to the URLs
    can’t be found in any of the BP logs.* We have to use the same scheme devised
    in *Example 3*, involving a Calculation Stage and an Environment Variable, if
    we want to know which endpoint is being used for Web API Services.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve finished discussing how to log ML model versions in the Session Logs.
    Next, let’s look at the final reusable IA component, which is used to evaluate
    new ML models in sequence with the current one running in production.
  prefs: []
  type: TYPE_NORMAL
- en: New ML model evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prediction models are expected to change for many reasons, including updates
    to the training data, hyperparameter tuning, or switching to a completely new
    algorithm. When an ML model is changed, it needs to be evaluated against a *validation*
    dataset – but that may not be enough. The purpose of this component is to allow
    us to evaluate a proposed model against *production* data. The goal is to gather
    data on how the proposed model behaves against production data so that the data
    science or IA team can determine whether it’s acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The IA component described in this section is implemented through a Process
    template. When used in an IA Process, this template allows us to predict against
    a second ML model using live data. The principles underlying the design of this
    component include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Being simple enough to integrate into an existing IA Process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting logging to a single Stage to facilitate extracting Session Log information
    for data scientists’ consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resuming any Exceptions that occur in the template so that they don’t affect
    the primary production Process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having short and simple logic to avoid increasing the Item’s Total Work Time
    by too much
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see how we can implement this through an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4 – new ML model evaluation Process template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we’ll go through an already-developed Process template and
    explain how it works. We’ll also discuss the steps needed to incorporate the template
    into an existing IA Process. Our example contains three high-level steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify the Release contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understand the template logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understand how to integrate it into an existing IA Process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the Release contents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Release should have been imported in the *Technical requirements* section.
    Verify that *one* Process, *one* Work Queue, and *two* Environment Variables have
    been imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.30 – The Release file contents](img/B18416_06_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.30 – The Release file contents
  prefs: []
  type: TYPE_NORMAL
- en: The `Ch6 Example 4 Enable Model Evaluation` Environment Variable determines
    whether this template is active or not. The `Ch6 Example 4 Evaluation Model ID`
    Environment Variable is a self-defined ID for the ML model that we want to test.
    This is to help us keep track of which model we’re testing in production. Next,
    let’s open the Process and understand the template contents.
  prefs: []
  type: TYPE_NORMAL
- en: Understand the template logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Process template logic is simple, with only two Pages. There’s a placeholder
    Page where you’re expected to provide the logic that makes the ML prediction.
    Complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Example 4 – New Model Evaluation Process Template** in the *Ch6* Group
    in the Process Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click on the `Main Page`. See that we’re supposed to pass in two Collections.
    The `Input Data` Collection stores the prediction Input Data required by the ML
    model that we want to evaluate. The `Original Prediction Result` Collection (optional)
    can be passed in if we want to log the result of the actual production prediction
    alongside the prediction of the model that’s being evaluated. This makes it easier
    to compare the two results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.31 – The Input parameters of the Start Stage](img/B18416_06_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.31 – The Input parameters of the Start Stage
  prefs: []
  type: TYPE_NORMAL
- en: Look at the *Enable Model Evaluation?* Decision Stage that’s connected to `Ch6
    Example 4 Enable Model Evaluation` Environment Variable to see whether to use
    this template or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look at the `Input Data` into a new Queue (specified by `Queue Name`), and
    immediately lock that Item for Processing using `Queue Name` should be different
    from the calling Process’s Work Queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.32 – Add an item into a new queue](img/B18416_06_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.32 – Add an item into a new queue
  prefs: []
  type: TYPE_NORMAL
- en: The reason for creating an Item in a new queue is to make it easy to find the
    evaluation prediction for individual Items from the Control Room.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the `Ch6 Example 4 Evaluation Model ID` Environment Variable. This provides
    a way for you to version or identify what model is being evaluated. This will
    be logged in the Session Logs for reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at the **Recover1** Stage. Exception handling is added to ensure that exceptions
    aren’t bubbled up to the calling Process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Call Prediction` Page. This Page is mostly a placeholder for you
    to insert the actual Stages needed to make predictions using the evaluation ML
    model. The prediction output must be added into the **Output Data** Collection
    for writing into the Session Logs. When adding your logic, make sure to only turn
    on Stage Logging for the Stages that you want to record the start and end times
    of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.33 – The Call Prediction Page](img/B18416_06_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.33 – The Call Prediction Page
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the `Log New Model Evaluation Results` Multi Calc Stage. This logs
    all of the information that’s relevant to data scientists so that it’s easy to
    retrieve in a single Session Log entry: `Ch6 Example 4 Evaluation Model ID`, `Input
    Data`, `Original Prediction Result`, and `Output Data`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integration with an existing Process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we’ve seen the template’s logic, we’ll discuss what steps are needed
    to implement it into an existing IA Process:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the template in the Process Studio and use **Save As** to create a new
    Process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Work Queue under `Main Page` to match it. The **Key Name** field
    of the Work Queue should be set based on the input data of the ML call, or it
    can be left blank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two new Environment Variables to replace `Ch6 Example 4 Evaluation Model
    ID` and `Ch6 Example 4 Enable Model Evaluation`. Set their values and replace
    the two Environment Variables on the `Main Page` with the newly created ones.
    This also results in needing to change the *Enable Model Evaluation?* Decision
    Stage on the `Main Page`, and the *Log New Model Evaluation Results* Calculation
    Stage on the `Call` `Prediction` Page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Call Prediction` Page. Insert the logic to make the evaluation ML
    model prediction using data from the `Input Data` Collection. The prediction output
    should be formatted into the `Output` `Data` Collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable Stage Logging on the specific action or web API that makes the ML prediction.
    Otherwise, set the logging of the Stages that have been added to *Errors only*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the existing IA Process, add a *Process* Stage after the live prediction
    results have been obtained. Configure this to use the Process template that was
    just saved. On the `Input Data` needed by the evaluation model to make its prediction,
    and optionally, `Original Prediction Result` if you’d like to log it alongside
    the evaluation model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this component, we can make live predictions against an evaluation ML model
    with very few changes to an existing IA Process. The only modification to the
    original Process that’s needed is to call the sub-Process.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the results of these evaluation predictions is simplified since all
    of the Session Logging occurs in a single Stage. Session Logs can be exported
    and filtered by the name of the *Multi Calc* Stage. This gives data scientists
    all the information that they need to further evaluate their model, including
    the model ID, the input data, the production prediction result, and the evaluation
    prediction result.
  prefs: []
  type: TYPE_NORMAL
- en: Reusable IA components review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve covered four different reusable components that can be used across many
    different IA Processes. A summary of the purpose of each component and what BP
    features were used to create them is shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Major BP** **features used** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| IA Session control | Session Variables and Decision Stages | Session-based
    control of whether:Items must forcibly undergo HITL review.Review checking is
    disabled.Shared data used for reviews should be recreated. |'
  prefs: []
  type: TYPE_TB
- en: '| ML prediction kill switch | Credential (marked as invalid), Decision Stage,
    and Exception handling | Allow for ML predictions to be prevented across all current
    and future Sessions that use a particular model |'
  prefs: []
  type: TYPE_TB
- en: '| ML model versioning | Calculation Stage (with logging enabled) and Environment
    Variable | Create Session Logs that specify which ML model version was used to
    make a prediction, even if the API endpoint stays the same |'
  prefs: []
  type: TYPE_TB
- en: '| New ML model evaluation | Work Queue, Environment Variables, Exception handling,
    and Multi Calc Stage (for logging) | Run an evaluation ML model alongside the
    primary ML model in a way that makes the extraction of prediction results simple
    |'
  prefs: []
  type: TYPE_TB
- en: Table 6.3 – A summary of the four reusable IA components
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed four reusable IA components that provide additional
    functionality that’s specifically relevant to ML operations. These components
    can be easily integrated into existing IA Processes.
  prefs: []
  type: TYPE_NORMAL
- en: Our first component was a set of three Session Variables. These Session Variables
    allow Control Room operators to exercise more control over HITL prediction validation
    according to real-time needs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discussed a kill switch, which can be used easily to disable and re-enable
    ML prediction across all present and future Sessions. This can be used if there
    is an urgent need to stop all ML predictions used in IA by a certain model.
  prefs: []
  type: TYPE_NORMAL
- en: The third component, ML model versioning, addresses a problem caused by imperfect
    audit logging (as of version 7.1.2) in BP. Updating a URL in Web API Services
    doesn’t show the specific URLs that have been changed in Audit Logs. This means
    that we don’t know exactly which API URL or version has been used to make a prediction,
    even if we look at both the Session Logs and Audit Logs. This third component
    rectifies this issue through the manual versioning of ML models. This allows us
    to know which version of a model was used by viewing only the Session Logs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our fourth component was a Process template that can be used to extend
    existing IA Processes. This component allows us to run an additional ML prediction
    alongside the production one for evaluation purposes against live data.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of creating reusable templates is extremely important to both RPA
    and IA development. It allows for standardization, simpler maintenance, and faster
    development time. In the next chapter, we’ll combine all that has been covered,
    starting from [*Chapter 1*](B18416_01.xhtml#_idTextAnchor015) until now, into
    standardized, reusable IA Process and Object templates. These can be used to kickstart
    an IA solution design and serve as a base for creating IA templates in your organization.
  prefs: []
  type: TYPE_NORMAL
