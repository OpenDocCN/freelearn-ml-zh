- en: '*Chapter 13*: Support Vector Machine Classification'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some similarities between support vector classification models and
    k-nearest neighbors models. They are both intuitive and flexible. However, support
    vector classification, due to the nature of the algorithm, scales better than
    k-nearest neighbor. Unlike logistic regression, it can handle nonlinear models
    rather easily. The strategies and issues with using support vector machines for
    classification are similar to those we discussed in [*Chapter 8*](B17978_08_ePub.xhtml#_idTextAnchor106),
    *Support Vector Regression*, when we used support vector machines for regression.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key advantages of **support vector classification** (**SVC**) is
    the ability it gives us to reduce model complexity without increasing our feature
    space. But it also provides multiple levers we can adjust to limit the possibility
    of overfitting. We can choose a linear model or select from several nonlinear
    kernels. We can use a regularization parameter, much as we did for logistic regression.
    With extensions, we can also use these same techniques to construct multiclass
    models.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Key concepts for SVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear SVC models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonlinear SVM classification models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SVMs for multiclass classification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will stick to the pandas, NumPy, and scikit-learn libraries in this chapter.
    All code in this chapter was tested with scikit-learn versions 0.24.2 and 1.0.2\.
    The code that displays the decision boundaries needs scikit-learn version 1.1.1
    or later.
  prefs: []
  type: TYPE_NORMAL
- en: Key concepts for SVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use **support vector machines** (**SVMs**) to find a line or curve to
    separate instances by class. When classes can be discriminated by a line, they
    are said to be **linearly separable**.
  prefs: []
  type: TYPE_NORMAL
- en: There may, however, be many possible linear classifiers, as we can see in *Figure
    13.1*. Each line successfully discriminates between the two classes, represented
    by dots and squares, using the two features x1 and x2\. The key difference is
    in how the lines would classify new instances, represented by the transparent
    rectangle. Using the line closest to the squares would cause the transparent rectanglez
    to be classified as a dot. Using either of the other two lines would classify
    it as a square.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Three possible linear classifiers ](img/B17978_13_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Three possible linear classifiers
  prefs: []
  type: TYPE_NORMAL
- en: 'When a linear discriminant is very close to training instances, as is the case
    with two of the lines in *Figure 13.2*, there is a greater risk of misclassifying
    new instances. We want a line that gives us the maximum margin between classes;
    one that is furthest away from border data points for each class. That is the
    middle line in *Figure 13.1*, but it can be seen more clearly in *Figure 13.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – SVM classification and maximum margin ](img/B17978_13_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – SVM classification and maximum margin
  prefs: []
  type: TYPE_NORMAL
- en: The bold line splits the maximum margin and is referred to as the decision boundary.
    The border data points for each class are known as the support vectors.
  prefs: []
  type: TYPE_NORMAL
- en: We use SVM to find the linear discriminant with the maximum margin between classes.  It
    does this by finding an equation representing a margin that can be maximized,
    where the margin is the distance between a data point and the separating hyperplane.
    With two features, as in *Figure 13.2*, that hyperplane is just a line. However,
    this can be generalized to feature spaces with more dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: With data points such as those in *Figure 13.2*, we can use what is known as
    **hard margin classification** without problems; that is, we can be strict about
    all observations for each class being on the correct side of the decision boundary.
    But what if our data points look like those in *Figure 13.3*? Here, there is a
    square very close to the dots. The hard margin classifier is the left line, giving
    us quite tiny margins.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – SVMs with hard and soft margins ](img/B17978_13_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – SVMs with hard and soft margins
  prefs: []
  type: TYPE_NORMAL
- en: If we use **soft margin classification** instead, we get the line to the right.
    Soft margin classification relaxes the constraint that all instances have to be
    correctly separated. As is the case with the data in *Figure 13.3*, allowing for
    a small number of misclassifications in the training data can give us a larger
    margin. We ignore the wayward square and get a decision boundary represented by
    the soft margin line.
  prefs: []
  type: TYPE_NORMAL
- en: The amount of relaxation of the constraint is determined by the *C* hyperparameter.
    The larger the value of *C*, the greater the penalty for margin violations. Not
    surprisingly, models with larger *C* values are more prone to overfitting. *Figure
    13.4* illustrates how the margin changes with values of *C*. At *C = 1*, the penalty
    for misclassification is low, giving us a much greater margin than when *C* is
    100\. Even at a *C* of 100, however, some margin violation still happens.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Soft margins at different C values ](img/B17978_13_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – Soft margins at different C values
  prefs: []
  type: TYPE_NORMAL
- en: As a practical matter, we almost always build our SVC models with soft margins.
    The default value for *C* in scikit-learn is 1.
  prefs: []
  type: TYPE_NORMAL
- en: Nonlinear SVM and the kernel trick
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have not yet fully addressed the issue of linear separability with SVC. For
    simplicity, it is helpful to return to a classification problem involving two
    features. Let’s say a plot of two features against a categorical target looks
    like the illustration in *Figure 13.5*. The target has two possible values, represented
    by the dots and squares. x1 and x2 are numeric and have negative values.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Class labels not linearly separable with two features ](img/B17978_13_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Class labels not linearly separable with two features
  prefs: []
  type: TYPE_NORMAL
- en: 'What can we do in a case like this to identify a margin between the classes?
    It is often the case that a margin can be identified at a higher dimension. In
    this example, we can use a polynomial transformation, as illustrated in *Figure
    13.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Using polynomial transformation to establish the margin ](img/B17978_13_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Using polynomial transformation to establish the margin
  prefs: []
  type: TYPE_NORMAL
- en: There is now a third dimension, which is the sum of the squares of x1 and x2\.
    The dots are all higher than the squares. This is similar to how we used polynomial
    transformation with linear regression.
  prefs: []
  type: TYPE_NORMAL
- en: One drawback of this approach is that we can quickly end up with too many features
    for our model to perform well. This is where the **kernel trick** comes in very
    handy. SVC can use a kernel function to expand the feature space implicitly without
    actually creating more features. This is done by creating a vector of values that
    can be used to fit a nonlinear margin.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this allows us to fit a polynomial transformation like the hypothetical
    one illustrated in *Figure 13.6*, the most frequently used kernel function with
    SVC is the **radial basis function** (**RBF**). RBF is popular because it is faster
    than other common kernel functions and because it can be used with the gamma hyperparameter
    for additional flexibility. The equation for the RBF kernel is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17978_13_0011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, ![](img/B17978_13_002.png) and ![](img/B17978_13_003.png) are data points.
    Gamma, ![](img/B17978_13_004.png), determines the amount of influence of each
    point. With high values of gamma, points have to be very close to each other to
    be grouped together. At very high values of gamma, we start to see islands of
    points.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, what is a high value for gamma, or of *C*, depends partly on our
    data. A good approach is to create visualizations of decision boundaries at different
    values for gamma and *C* before doing much modeling. This will give us a sense
    of whether or not we are underfitting or overfitting at different hyperparameter
    values. We will plot decision boundaries at different values of gamma and *C*
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Multiclass classification with SVC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of our discussion about SVC so far has centered on binary classification.
    Fortunately, all of the key concepts that apply to SVMs for binary classification
    also apply to classification when our target has more than two possible values.
    We transform the multiclass problem into a binary classification problem by modeling
    it as a **one-versus-one**, or a **one-versus-rest** problem.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Multiclass SVC options ](img/B17978_13_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – Multiclass SVC options
  prefs: []
  type: TYPE_NORMAL
- en: One-versus-one classification is easy to illustrate in a three-class example,
    as shown on the left side of *Figure 13.7*. A decision boundary is estimated between
    each class and each of the other classes. For example, the dotted line is the
    decision boundary for the dot class versus the square class. The solid line is
    the decision boundary between the dots and the ovals.
  prefs: []
  type: TYPE_NORMAL
- en: With one-versus-rest classification, a decision boundary is constructed between
    each class and those instances that are not of that class. This is illustrated
    on the right side of *Figure 13.7*. The solid line is the decision boundary between
    the dots and the instances that are not dots (those that are squares or ovals).
    The dotted and double lines are the decision boundaries for the squares versus
    the rest and the ovals versus the rest of the instances, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We can construct both linear and nonlinear SVC models using either one-versus-one
    or one-versus-rest classification. We can also specify values for *C* to construct
    soft margins. However, the construction of more decision boundaries with each
    of these techniques claims greater computational resources than SVC for binary
    classification. If we have a large number of observations, many features, and
    more than a couple of parameters to tune, we will likely need very good system
    resources to get timely results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three-class example hides one thing that is different about one-versus-one
    and one-versus-rest classifiers. With three classes, they use the same number
    of classifiers (three), but the number of classifiers increases relatively rapidly
    with one-versus-one. The number of classifiers will always be equal to the number
    of class values with one-versus-rest, whereas, with one-versus-one, it is equal
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17978_13_0051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *S* is the number of classifiers and *N* is the cardinality (the number
    of class values) of the target. So, with a cardinality of 4, one-versus-rest needs
    4 classifiers, and one-versus-one uses 6.
  prefs: []
  type: TYPE_NORMAL
- en: We explore multiclass SVC models in the last section of this chapter, but let’s
    start with a relatively straightforward linear model to see SVC in action. There
    are two things to keep in mind when doing the preprocessing for an SVC model.
    First, SVC is sensitive to the scale of features, so we will need to address that
    before fitting our model. Second, if we are using hard margins or high values
    for *C*, outliers might have a large effect on our model.
  prefs: []
  type: TYPE_NORMAL
- en: Linear SVC models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can often get good results by using a linear SVC model. When we have more
    than two features, there is no easy way to visualize whether our data is linearly
    separable or not. We often decide on linear or nonlinear based on hyperparameter
    tuning. For this section, we will assume we can get good performance with a linear
    model and soft margins.
  prefs: []
  type: TYPE_NORMAL
- en: We will work with data on **National Basketball Association** (**NBA**) games
    in this section. The dataset has statistics from each NBA game from the 2017/2018
    season through the 2020/2021 season. This includes the home team, whether the
    home team won, the visiting team, shooting percentages for visiting and home teams,
    turnovers, rebounds, and assists by both teams, and a number of other measures.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: NBA game data is available for download for the public at [https://www.kaggle.com/datasets/wyattowalsh/basketball](https://www.kaggle.com/datasets/wyattowalsh/basketball).
    This dataset has game data starting with the 1946/1947 NBA season. It uses `nba_api`
    to pull stats from [nba.com](http://nba.com). That API is available at [https://github.com/swar/nba_api](https://github.com/swar/nba_api).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build a linear SVC model:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by loading the familiar libraries. The only new modules are `LinearSVC`
    and `DecisionBoundaryDisplay`. We will use `DecisionBoundaryDisplay` to show the
    boundaries of a linear model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are ready to load the NBA game data. We just have a little cleaning to do.
    A small number of observations have missing values for our target, `WL_HOME`,
    whether the home team won. We remove those observations. We convert the `WL_HOME`
    feature to a `0` and `1` feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is not much of a problem with a class imbalance here. This will save
    us some time later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s organize our features by data type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s look at some descriptive statistics. (I have omitted some features from
    the printout to save space.) We will need to scale these features since they have
    very different ranges. There are no missing values but we will generate some when
    we assign missings to extreme values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should also review the correlations of the features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This produces the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Heat map of NBA game statistics correlations ](img/B17978_13_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – Heat map of NBA game statistics correlations
  prefs: []
  type: TYPE_NORMAL
- en: Several features are correlated with the target, including the field goal percentage
    of the home team (`FG_PCT_HOME`) and defensive rebounds of the home team (`DREB_HOME`).
  prefs: []
  type: TYPE_NORMAL
- en: There is also correlation among the features. For example, the field goal percentage
    of the home team (`FG_PCT_HOME`) and the 3-point field goal percentage of the
    home team (`FG3_PCT_HOME`) are positively correlated, not surprisingly. Also,
    rebounds of the home team (`REB_HOME`) and defensive rebounds of the home team
    (`DREB_HOME`) are likely too closely correlated for any model to disentangle their
    impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create training and testing DataFrames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to set up our column transformations. For the numeric columns, we check
    for outliers and scale the data. We one-hot encode the one categorical feature,
    `SEASON`. We will use these transformations later with the pipeline for our grid
    search:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before constructing our model, let’s look at a decision boundary from a linear
    SVC model. We base the boundary on two features correlated with the target: the
    field goal percentage of the home team (`FG_PCT_HOME`) and defensive rebounds
    of the home team (`DREB_HOME`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create a function, `dispbound`, which will use the `DecisionBoundaryDisplay`
    module to show the boundary. This module is available with scikit-learn versions
    1.1.1 or later. `DecisionBoundaryDisplay` needs a model to fit, two features,
    and target values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – Decision boundary for a two-feature linear SVC model ](img/B17978_13_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – Decision boundary for a two-feature linear SVC model
  prefs: []
  type: TYPE_NORMAL
- en: We get a pretty decent linear boundary with just the two features. That is great
    news, but let’s do a more carefully constructed model.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build our model, we first instantiate a linear SVC object and set up recursive
    feature elimination. We then add the column transformation, the feature selection,
    and the linear SVC to a pipeline and fit it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s see what features were selected from our recursive feature elimination.
    We need to first get the column names after the one-hot encoding. We can then
    use the `get_support` method of the `rfecv` object to get the features that were
    selected. (You will get a deprecated warning regarding `get_feature_names` if
    you are using scikit-learn versions 1 or later. You can use `get_feature_names_out`
    instead, though that will not work with earlier versions of scikit-learn.):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should look at the coefficients. Coefficients for each of the selected columns
    can be accessed with the `coef_` attribute of the `linearsvc` object. Perhaps
    not surprisingly, the shooting percentages of the home team (`FG_PCT_HOME`) and
    the away team (`FG_PCT_AWAY`) are the most important positive and negative predictors
    of the home team winning. The next most important features are the number of turnovers
    of the away and home teams:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s take a look at the predictions. Our model predicts the home team winning
    very well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should confirm that these metrics are not a fluke by doing some cross-validation.
    We use repeated stratified k folds for our validation, indicating that we want
    seven folds and 10 iterations. We get pretty much the same results as we did during
    the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have been using the default value of `C` of `1` so far. We can try to identify
    a better value for `C` with a randomized grid search:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The best `C` value is 2.02 and the best accuracy score is 0.9316.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the scores for each of the 20 times we ran the
    grid search. Each score is the average accuracy score across 10 folds. We actually
    get pretty much the same score regardless of the `C` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now look at some of the predictions. Our model does well across the board,
    but not any better than the initial model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s also look at a confusion matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This produces the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Confusion matrix for wins by the home team ](img/B17978_13_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.10 – Confusion matrix for wins by the home team
  prefs: []
  type: TYPE_NORMAL
- en: Our model largely predicts home team wins and losses correctly. Tuning the value
    of `C` did not make much of a difference, as we get pretty much the same accuracy
    regardless of the `C` value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we are using the accuracy metric more often with the
    NBA games data than with the heart disease and machine failure data that we have
    worked with in previous chapters. We focused more on sensitivity with that data.
    There are two reasons for that. First, accuracy is a more compelling measure when
    classes are closer to being balanced for reasons we discussed in detail in [*Chapter
    6*](B17978_06_ePub.xhtml#_idTextAnchor078), *Preparing for Model Evaluation*.
    Second, in predicting heart disease and machine power failure, we are biased towards
    sensitivity, as the cost of a false negative is higher than that of a false positive
    in those domains. For predicting NBA games, there is no such bias.
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of linear SVC models is how easy they are to interpret. We are
    able to look at coefficients, which helps us make sense of the model and communicate
    the basis of our predictions to others. It nonetheless can be helpful to confirm
    that we do not get better results with a nonlinear model. We will do that in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Nonlinear SVM classification models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although nonlinear SVC is more complicated conceptually than linear SVC, as
    we saw in the first section of this chapter, running a nonlinear model with scikit-learn
    is relatively straightforward. The main difference from a linear model is that
    we need to do a fair bit more hyperparameter tuning. We have to specify values
    for `C`, for `gamma`, and for the kernel we want to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are theoretical reasons for hypothesizing that some hyperparameter
    values might work better than others for a given modeling challenge, we usually
    resolve those values empirically, that is, with hyperparameter tuning. We try
    that in this section with the same NBA games data that we used in the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We load the same libraries that we used in the previous section. We also import
    the `LogisticRegression` module. We will use that with a feature selection wrapper
    method later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We import the `nbagames` module, which has the code that loads and preprocesses
    the NBA games data. This is just a copy of the code that we ran in the previous
    section to prepare the data for modeling. There is no need to repeat those steps
    here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also import the `dispbound` function we used in the previous section to
    display decision boundaries. We copied that code into a file called `displayfunc.py`
    in the `helperfunctions` subfolder of the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `nbagames` module to get the training and testing data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before constructing a model, let’s look at the decision boundaries for a couple
    of different kernels with two features: the field goal percentage of the home
    team (`FG_PCT_HOME`) and defensive rebounds of the home team (`DREB_HOME`). We
    start with the `rbf` kernel, using different values for `gamma` and `C`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this a few different ways produces the following plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11 – Decision boundaries with the rbf kernel and different gamma
    and C values ](img/B17978_13_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.11 – Decision boundaries with the rbf kernel and different gamma and
    C values
  prefs: []
  type: TYPE_NORMAL
- en: At values for `gamma` and `C` near the default, we see some bending of the decision
    boundary to accommodate a few wayward points in the loss class. These are instances
    where the home team lost despite having very high defensive rebound totals. With
    the `rbf` kernel, two of these instances are now correctly classified. There are
    also a couple of instances with a high home team field goal percentage but low
    home team defensive rebounds, which are now correctly classified. However, there
    is not much change overall in our predictions compared with the linear model from
    the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: But this changes significantly if we increase values for `C` or `gamma`. Recall
    that higher values of `C` increase the penalty for misclassification. This leads
    to boundaries that wind around instances more.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing `gamma` to `30` causes substantial overfitting. High values of `gamma`
    mean that data points have to be very close to each other to be grouped together.
    This results in decision boundaries closely tied to small numbers of instances,
    sometimes just one instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also show the boundaries for a polynomial kernel. We will keep the `C`
    value at the default to focus on the effect of changing the number of degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this a couple of different ways produces the following plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12 – Decision boundaries with polynomial kernel and different degrees
    ](img/B17978_13_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.12 – Decision boundaries with polynomial kernel and different degrees
  prefs: []
  type: TYPE_NORMAL
- en: We can see some bending of the decision boundary at higher degree levels to
    handle a couple of unusual instances. There is not much overfitting here, but
    not really much improvement in our predictions either.
  prefs: []
  type: TYPE_NORMAL
- en: This at least hints at what to expect when we construct the model. We should
    try some nonlinear models but there is a good chance that they will not lead to
    much improvement over the linear model we used in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to set up the pipeline that we will use for our nonlinear
    SVC. Our pipeline will do the column transformation and a recursive feature elimination.
    We use logistic regression for the feature selection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a dictionary to use for our hyperparameter tuning. This dictionary
    is structured somewhat differently from other dictionaries we have used for this
    purpose. That is because certain hyperparameters only work with certain other
    hyperparameters. For example, `gamma` does not work with a linear kernel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You may have noticed that one of the kernels we will be using is linear, and
    wonder how this is different from the linear SVC module we used in the previous
    section. `LinearSVC` will often converge faster, particularly with large datasets.
    It does not use the kernel trick. We will also likely get different results as
    the optimization is different in several ways.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we are ready to fit an SVC model. The best model is actually one with a
    linear kernel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s take a closer look at the hyperparameters selected and the associated
    accuracy scores. We can get the 20 randomly chosen hyperparameter combinations
    from the `params` list from the grid object’s `cv_results_` dictionary. We can
    get the mean test score from that same dictionary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We sort by accuracy score in descending order. Linear kernels outperform polynomial
    and `rbf` kernels, though not substantially better than polynomial at `3`, `4`,
    and `5` degrees. `rbf` kernels perform particularly poorly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We use the pandas `json_nomalize` method to handle the somewhat messy hyperparameter
    combinations we pull from the `params` list. It is messy because different hyperparameters
    are available depending on the kernel used. This means that the 20 dictionaries
    in the `params` list will have different keys. For example, the polynomial kernels
    will have values for degrees. The linear and `rbf` kernels will not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the support vectors via the `best_estimator_` attribute. There
    are 625 support vectors *holding up* the decision boundary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can take a look at the predictions. Not surprisingly, we do not
    get better results than we got with the linear SVC model that we ran in the last
    section. I say not surprisingly because the best model was found to be a model
    with a linear kernel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although we have not improved upon our model from the previous section, it was
    still a worthwhile exercise to experiment with some nonlinear models. Indeed,
    this is often how we discover whether we have data that can be successfully separated
    linearly. This is typically difficult to visualize and so we rely on hyperparameter
    tuning to tell us which kernel classifies our data best.
  prefs: []
  type: TYPE_NORMAL
- en: This section and the previous one demonstrate the key techniques for using SVMs
    for binary classification. Much of what we have done so far applies to multiclass
    classification as well. We will take a look at SVC modeling strategies when our
    target has more than two values in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: SVMs for multiclass classification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the same concerns that we had when we used SVC for binary classification
    apply when we are doing multiclass classification. We need to determine whether
    the classes are linearly separable, and if not, which kernel will yield the best
    results. As discussed in the first section of this chapter, we also need to decide
    whether that classification is best modeled as one-versus-one or one-versus-rest.
    One-versus-one finds decision boundaries that separate each class from each of
    the other classes. One-versus-rest finds decision boundaries that distinguish
    each class from all other instances. We try both approaches in this section.
  prefs: []
  type: TYPE_NORMAL
- en: We will work with the machine failure data that we worked with in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This dataset on machine failure is available for public use at [https://www.kaggle.com/datasets/shivamb/machine-predictive-maintenance-classification](https://www.kaggle.com/datasets/shivamb/machine-predictive-maintenance-classification).
    There are 10,000 observations, 12 features, and two possible targets. One is binary:
    the machine failed or did not. The other has types of failure. The instances in
    this dataset are synthetic, generated by a process designed to mimic machine failure
    rates and causes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build a multiclass SVC model:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by loading the same libraries that we have been using in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will load the machine failure type dataset and take a look at its structure.
    There is a mixture of character and numeric data. There are no missing values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s look at a few observations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s also look at the distribution of the target. We have a significant class
    imbalance, so we will need to deal with that in some way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can save ourselves some trouble later by creating a numeric code for failure
    type, which we will use rather than the character value. We do not need to put
    this into a pipeline since we are not introducing any data leakage in the conversion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should also look at some descriptive statistics. We will need to scale the
    features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now create training and testing DataFrames. We should also use the `stratify`
    parameter to ensure an equal distribution of target values in our training and
    testing data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set up the column transformations we need to run. For the numeric columns,
    we set outliers to the median and then scale the values. We do one-hot-encoding
    of the one categorical feature, `machinetype`. It has `H`, `M`, and `L` values
    for high, medium, and low quality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we set up a pipeline with the column transformation and the SVC instance.
    We set the `class_weight` parameter to `balanced` to deal with class imbalance.
    This applies a weight that is inversely related to the frequency of the target
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We only have a handful of features in this case so we will not worry about feature
    selection. (We might still be concerned about features that are highly correlated,
    but that is not an issue with this dataset.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a dictionary with the hyperparameter combinations to use with a grid
    search. This is largely the same as the dictionary we used in the previous section,
    except we have added a decision function shape key. This will cause the grid search
    to try both one-versus-one (`ovo`) and one-versus-rest (`ovr`) classification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we are ready to run the randomized grid search. We will base our scoring
    on the area under the ROC curve. The best hyperparameters include the one-versus-one
    decision function and the `rbf` kernel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s see the score for each iteration. In addition to the best model that
    we saw in the previous step, there are several other hyperparameter combinations
    that have scores that are nearly as high. One-versus-rest with a linear kernel
    does nearly as well as the best-performing model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should take a look at the confusion matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This produces the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13 – Confusion matrix for machine failure type prediction ](img/B17978_13_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.13 – Confusion matrix for machine failure type prediction
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also do a classification report. We do not get great scores for sensitivity
    for most classes, though our model does predict heat and overstrain failures pretty
    well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When modeling targets such as machine failure types that have a high class imbalance,
    we are often more concerned with metrics other than accuracy. This is partly determined
    by our domain knowledge. Avoiding false negatives may be more important than avoiding
    false positives. Doing a thorough check on a machine too early is definitely preferable
    to doing it too late.
  prefs: []
  type: TYPE_NORMAL
- en: The 96 to 97 percent weighted precision, recall (sensitivity), and f1 scores
    do not provide a good sense of the performance of our model. They mainly reflect
    the large class imbalance and the fact that it is very easy to predict no machine
    failure. The much lower macro averages (which are just simple averages across
    classes) indicate that our model struggles to predict some types of machine failure.
  prefs: []
  type: TYPE_NORMAL
- en: This example illustrates that it is relatively easy to extend SVC to models
    that have targets with more than two values. We can specify whether we want to
    use one-versus-one or one-versus-rest classification. The one-versus-rest approach
    can be faster when the number of classes is above three since there will be fewer
    classifiers trained.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the different strategies for implementing SVC.
    We used linear SVC (which does not use kernels), which can perform very well when
    our classes are linearly separable. We then examined how to use the kernel trick
    to extend SVC to cases where the classes are not linearly separable. Finally,
    we used one-versus-one and one-versus-rest classification to handle targets with
    more than two values.
  prefs: []
  type: TYPE_NORMAL
- en: SVC is an exceptionally useful technique for binary and multiclass classification.
    It can handle both straightforward and complicated relationships between features
    and the target. There are few supervised learning problems for which SVMs should
    not at least be considered. However, it is not very efficient with very large
    datasets.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore another popular and flexible classification
    algorithm, Naive Bayes.
  prefs: []
  type: TYPE_NORMAL
