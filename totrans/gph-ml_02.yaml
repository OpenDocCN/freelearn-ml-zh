- en: 'Chapter 1: Getting Started with Graphs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphs are mathematical structures that are used for describing relations between
    entities and are used almost everywhere. For example, social networks are graphs,
    where users are connected depending on whether one user "*follows*" the updates
    of another user. They can be used for representing maps, where cities are linked
    through streets. Graphs can describe biological structures, web pages, and even
    the progression of neurodegenerative diseases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '**Graph theory**, the study of graphs, has received major interest for years,
    leading people to develop algorithms, identify properties, and define mathematical
    models to better understand complex behaviors.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will review some of the concepts behind graph-structured data.
    Theoretical notions will be presented, together with examples to help you understand
    some of the more general concepts and put them into practice. In this chapter,
    we will introduce and use some of the most widely used libraries for the creation,
    manipulation, and study of the structure dynamics and functions of complex networks,
    specifically looking at the Python `networkx` library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to graphs with `networkx`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting graphs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph properties
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarks and repositories
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with large graphs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using Jupyter Notebooks with *Python 3.8* for all of our exercises.
    In the following code snippet, we show a list of Python libraries that will be
    installed for this chapter using `pip` (for example, run `pip install networkx==2.5`
    on the command line, and so on):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this book, the following Python commands will be referred to:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '`import networkx as nx`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import pandas as pd`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import numpy as np`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more complex data visualization tasks, Gephi ([https://gephi.org/](https://gephi.org/))
    is also required. The installation manual is available here: [https://gephi.org/users/install/](https://gephi.org/users/install/).
    All code files relevant to this chapter are available at [https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter01](https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter01).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to graphs with networkx
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will give a general introduction to graph theory. Moreover,
    in order to merge theoretical concepts with their practical implementation, we
    will enrich our explanation with code snippets in Python, using `networkx`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: A **simple undirected graph** (or simply, a graph) *G* is defined as a couple
    *G=(V,E)* , where *V={*![](img/Formula_01_001.png)*, ..,* ![](img/Formula_01_002.png)*}*
    is a set of nodes (also called **vertices**) and *E={{*![](img/Formula_01_003.png)*,*![](img/Formula_01_004.png)
    *.., {*![](img/Formula_01_005.png)*,*![](img/Formula_01_006.png)*}}* is a set
    of two-sets (set of two elements) of edges (also called **links**), representing
    the connection between two nodes belonging to *V*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: It is important to underline that since each element of *E* is a two-set, there
    is no order between each edge. To provide more detail, *{*![](img/Formula_01_007.png)*,*![](img/Formula_01_008.png)
    and *{*![](img/Formula_01_009.png)*,*![](img/Formula_01_010.png) represent the
    same edge.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'We now provide definitions for some basic properties of graphs and nodes, as
    follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The **order** of a graph is the number of its vertices *|V|*. The **size** of
    a graph is the number of its edges *|E|*.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **degree** of a vertex is the number of edges that are adjacent to it. The
    **neighbors** of a vertex *v* in a graph *G* is a subset of vertex ![](img/Formula_01_011.png)
    induced by all vertices adjacent to *v*.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **neighborhood graph** (also known as an ego graph) of a vertex *v* in a
    graph *G* is a subgraph of *G*, composed of the vertices adjacent to *v* and all
    edges connecting vertices adjacent to *v*.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of what a graph looks like can be seen in the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Example of a graph'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_01_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – Example of a graph
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'According to this representation, since there is no direction, an edge from
    `4` (there are, in total, four vertices and four edges). The `2`, `3`, and `1`.
    The neighbors for each node are shown in the following list:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '`Paris` = {`Milan`, `Dublin`}'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Milan` = {`Paris`, `Dublin`, `Rome`}'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dublin` = {`Paris`, `Milan`}'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rome` = {`Milan`}'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The same graph can be represented in `networkx`, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since by default, the `nx.Graph()` command generates an undirected graph, we
    do not need to specify both directions of each edge. In `networkx`, nodes can
    be any hashable object: strings, classes, or even other `networkx` graphs. Let''s
    now compute some properties of the graph we previously generated.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'All the nodes and edges of the graph can be obtained by running the following
    code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the output of the previous commands:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also compute the graph order, the graph size, and the degree and neighbors
    for each of the nodes, using the following commands:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result will be the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we can also compute an ego graph of a specific node for the graph
    `G`, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result will be the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The original graph can be also modified by adding new nodes and/or edges, as
    follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This would output the following lines:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Removal of nodes can be done by running the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is the result of the preceding commands:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As expected, all the edges that contain the removed nodes are automatically
    deleted from the edge list.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, edges can be removed by running the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The final result will be as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `networkx` library also allows us to remove a single node or a single edge
    from a graph `G` by using the following commands: `G. remove_node(''Dublin'')`
    and `G.remove_edge(''Dublin'', ''Paris'')`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Types of graphs
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we described how to create and modify simple undirected
    graphs. Here, we will show how we can extend this basic data structure in order
    to encapsulate more information, thanks to the introduction of **directed graphs**
    (**digraphs**), weighted graphs, and multigraphs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们描述了如何创建和修改简单的无向图。在这里，我们将展示如何通过引入 **有向图**（**有向图**）、加权图和多重图来扩展这种基本数据结构，以封装更多信息。
- en: Digraphs
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有向图
- en: A digraph *G* is defined as a couple *G=(V, E)*, where *V={*![](img/Formula_01_012.png)*,
    ..,* ![](img/Formula_01_013.png)*}* is a set of nodes and *E={(*![](img/Formula_01_014.png)*,*![](img/Formula_01_015.png)
    *.., (*![](img/Formula_01_016.png)*,*![](img/Formula_01_017.png)*)}* is a set
    of ordered couples representing the connection between two nodes belonging to
    *V*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有向图 *G* 定义为一个对 *G=(V, E)*，其中 *V={*![](img/Formula_01_012.png)*, ..,* ![](img/Formula_01_013.png)*}*
    是节点集合，*E={(*![](img/Formula_01_014.png)*,*![](img/Formula_01_015.png) *.., (*![](img/Formula_01_016.png)*,*![](img/Formula_01_017.png)*)}*
    是表示属于 *V* 的两个节点之间连接的有序对集合。
- en: Since each element of *E* is an ordered couple, it enforces the direction of
    the connection. The edge ![](img/Formula_01_018.png)*,*![](img/Formula_01_019.png)
    means *the node* ![](img/Formula_01_020.png) *goes into* ![](img/Formula_01_021.png).
    This is different from ![](img/Formula_01_022.png)*,*![](img/Formula_01_023.png)
    since it means *the node* ![](img/Formula_01_024.png) *goes to* ![](img/Formula_01_025.png).The
    starting node ![](img/Formula_01_026.png) is called the *head*, while the ending
    node is called the *tail*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *E* 的每个元素都是一个有序对，它强制了连接的方向。边 ![](img/Formula_01_018.png)*,*![](img/Formula_01_019.png)
    表示 *节点* ![](img/Formula_01_020.png) *进入* ![](img/Formula_01_021.png)。这与 ![](img/Formula_01_022.png)*,*![](img/Formula_01_023.png)
    不同，因为它表示 *节点* ![](img/Formula_01_024.png) *到达* ![](img/Formula_01_025.png)。起始节点
    ![](img/Formula_01_026.png) 被称为 *头节点*，而结束节点被称为 *尾节点*。
- en: Due to the presence of edge direction, the definition of node degree needs to
    be extended.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在边方向，节点度数的定义需要扩展。
- en: Indegree and outdegree
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 入度和出度
- en: For a vertex *v*, the number of head ends adjacent to *v* is called the **indegree**
    (indicated by ![](img/Formula_01_027.png) of *v*, while the number of tail ends
    adjacent to *v* is its **outdegree** (indicated by ![](img/Formula_01_028.png)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个顶点 *v*，与 *v* 相邻的头节点数量称为 **入度**（用 *v* 的 ![](img/Formula_01_027.png) 表示），而与
    *v* 相邻的尾节点数量称为其 **出度**（用 ![](img/Formula_01_028.png) 表示）。
- en: 'An example of what a digraph looks like is available in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了有向图的一个示例：
- en: '![Figure 1.2 – Example of a digraph'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – 有向图的示例'
- en: '](img/B16069_01_02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16069_01_02.jpg)'
- en: Figure 1.2 – Example of a digraph
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 有向图的示例
- en: The direction of the edge is visible from the arrow—for example, **Milan** ->
    **Dublin** means from **Milan** to **Dublin**. **Dublin** has ![](img/Formula_01_029.png)
    *= 2* and ![](img/Formula_01_030.png) *= 0*, **Paris** has ![](img/Formula_01_031.png)
    *= 0* and ![](img/Formula_01_032.png) *= 2*, **Milan** has ![](img/Formula_01_033.png)
    *= 1* and ![](img/Formula_01_034.png) *= 2*, and **Rome** has ![](img/Formula_01_035.png)
    *= 1* and ![](img/Formula_01_036.png) *= 0*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 边的方向从箭头中可见——例如，**米兰** -> **都柏林**表示从 **米兰** 到 **都柏林**。**都柏林**有 ![](img/Formula_01_029.png)
    *= 2* 和 ![](img/Formula_01_030.png) *= 0*，**巴黎**有 ![](img/Formula_01_031.png)
    *= 0* 和 ![](img/Formula_01_032.png) *= 2*，**米兰**有 ![](img/Formula_01_033.png)
    *= 1* 和 ![](img/Formula_01_034.png) *= 2*，而 **罗马**有 ![](img/Formula_01_035.png)
    *= 1* 和 ![](img/Formula_01_036.png) *= 0*。
- en: 'The same graph can be represented in `networkx`, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个图可以用 `networkx` 表示，如下所示：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The definition is the same as that used for simple undirected graphs; the only
    difference is in the `networkx` classes that are used to instantiate the object.
    For digraphs, the `nx.DiGraph()`class is used.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 定义与用于简单无向图的定义相同；唯一的区别在于用于实例化对象的 `networkx` 类。对于有向图，使用 `nx.DiGraph()` 类。
- en: '`Indegree` and `Outdegree` can be computed using the following commands:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令计算 **入度** 和 **出度**：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The results will be as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As for the undirected graphs, `G.add_nodes_from()`, `G.add_edges_from()`, `G.remove_nodes_from()`,
    and `G.remove_edges_from()` functions can be used to modify a given graph `G`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无向图，可以使用 `G.add_nodes_from()`、`G.add_edges_from()`、`G.remove_nodes_from()`
    和 `G.remove_edges_from()` 函数来修改给定的图 `G`。
- en: Multigraph
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多重图
- en: We will now introduce the multigraph object, which is a generalization of the
    graph definition that allows multiple edges to have the same pair of start and
    end nodes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍多重图对象，它是图定义的推广，允许有多个边具有相同的起始和结束节点对。
- en: A **multigraph G** is defined as *G=(V, E)*, where *V* is a set of nodes and
    *E* is a multi-set (a set allowing multiple instances for each of its elements)
    of edges.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**多重图 G** 定义为 *G=(V, E)* ，其中 *V* 是节点集，*E* 是边的多重集（允许其元素有多个实例的集合）。'
- en: A multigraph is called a **directed multigraph** if *E* is a multi-set of ordered
    couples; otherwise, if *E* is a multi-set of two-sets, then it is called an **undirected
    multigraph**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *E* 是有序对的有序多重集，则多重图被称为**有向多重图**；否则，如果 *E* 是两个集合的有序多重集，则称为**无向多重图**。
- en: 'An example of a directed multigraph is available in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了有向多重图的示例：
- en: '![Figure 1.3 – Example of a multigraph'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3 – 多重图的示例'
- en: '](img/B16069_01_03.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16069_01_03.jpg)'
- en: Figure 1.3 – Example of a multigraph
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 多重图的示例
- en: 'In the following code snippet, we show how to use `networkx` in order to create
    a directed or an undirected multigraph:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们展示了如何使用`networkx`来创建有向或无向多重图：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The only difference between a directed and an undirected multigraph is in the
    first two lines, where two different objects are created: `nx.MultiDiGraph()`
    is used to create a directed multigraph, while `nx.MultiGraph()` is used to build
    an undirected multigraph. The function used to add nodes and edges is the same
    for both objects.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有向多重图和无向多重图之间的唯一区别在于前两行，其中创建了两个不同的对象：使用`nx.MultiDiGraph()`创建有向多重图，而使用`nx.MultiGraph()`构建无向多重图。添加节点和边所使用的函数对这两个对象都是相同的。
- en: Weighted graphs
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加权图
- en: We will now introduce directed, undirected, and multi-weighted graphs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍有向、无向和多权重图。
- en: An **edge-weighted graph** (or simply, a weighted graph) *G* is defined as *G=(V,
    E ,w)* where *V* is a set of nodes, *E* is a set of edges, and ![](img/Formula_01_037.png)
    is the weighted function that assigns at each edge ![](img/Formula_01_038.png)
    a weight expressed as a real number.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**边加权图**（或简称为加权图） *G* 定义为 *G=(V, E ,w)* ，其中 *V* 是节点集，*E* 是边集，而 ![](img/Formula_01_037.png)
    是将权重函数分配给每个边 ![](img/Formula_01_038.png) 的权重，该权重以实数表示。'
- en: A **node-weighted graph** *G* is defined as *G=*(*V, E ,w*) ,where *V* is a
    set of nodes, *E* is a set of edges, and ![](img/Formula_01_039.png) is the weighted
    function that assigns at each node ![](img/Formula_01_040.png) a weight expressed
    as a real number.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**节点加权图** *G* 定义为 *G=*(*V, E ,w*) ，其中 *V* 是节点集，*E* 是边集，而 ![](img/Formula_01_039.png)
    是将权重函数分配给每个节点 ![](img/Formula_01_040.png) 的权重，该权重以实数表示。'
- en: 'Please keep the following points in mind:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下要点：
- en: If *E* is a set of ordered couples, then we call it a **directed weighted graph**.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *E* 是有序对的集合，则我们称之为**有向加权图**。
- en: If *E* is a set of two-sets, then we call it an **undirected weighted graph**.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *E* 是两个集合的集合，则我们称之为**无向加权图**。
- en: If *E* is a multi-set, we will call it a **weighted multigraph** (**directed
    weighted multigraph**).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *E* 是多重集，我们将称之为**加权多重图**（**有向加权多重图**）。
- en: If *E* is a multi-set of ordered couples, it is an **undirected weighted multigraph**.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*E*是有序对的有序多重集，则它是一个**无向加权多重图**。
- en: 'An example of a directed edge-weighted graph is available in the following
    screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了有向边加权图的示例：
- en: '![Figure 1.4 – Example of a directed edge-weighted graph'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4 – 有向边加权图的示例'
- en: '](img/B16069_01_04.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16069_01_04.jpg)'
- en: Figure 1.4 – Example of a directed edge-weighted graph
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 有向边加权图的示例
- en: From *Figure 1.4*, it is easy to see how the presence of weights on graphs helps
    to add useful information to the data structures. Indeed, we can imagine the edge
    weight as a "cost" to reach a node from another node. For example, reaching `19`,
    while reaching `11`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *图1.4* 中，很容易看出图上权重的存在如何有助于向数据结构添加有用的信息。确实，我们可以将边权重想象为从一个节点到达另一个节点的“成本”。例如，到达`19`，而到达`11`。
- en: 'In `networkx`, a directed weighted graph can be generated as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`networkx`中，可以通过以下方式生成有向加权图：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Bipartite graphs
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二部图
- en: 'We will now introduce another type of graph that will be used in this section:
    multipartite graphs. Bi- and tripartite graphs—and, more generally, kth-partite
    graphs—are graphs whose vertices can be partitioned in two, three, or more k-th
    sets of nodes, respectively. Edges are only allowed across different sets and
    are not allowed within nodes belonging to the same set. In most cases, nodes belonging
    to different sets are also characterized by particular node types. In *Chapters
    7, Text Analytics and Natural Language Processing Using Graphs,* and [*Chapter
    8*](B16069_08_Final_JM_ePub.xhtml#_idTextAnchor129), *Graphs Analysis for Credit
    Cards Transaction*, we will deal with some practical examples of graph-based applications
    and you will see how multipartite graphs can indeed arise in several contexts—for
    example, in the following scenarios:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将介绍本节中将使用的一种图形类型：多部分图。二部分图和三分图——以及更一般地，第k部分图——是顶点可以被划分为两个、三个或更多k个节点集合的图的统称。边只允许在不同集合之间，不允许在同一集合内的节点之间。在大多数情况下，属于不同集合的节点也由特定的节点类型来表征。在*第7章，使用图形进行文本分析和自然语言处理*和[*第8章*](B16069_08_Final_JM_ePub.xhtml#_idTextAnchor129)，*信用卡交易图分析*中，我们将处理一些基于图形应用的实际例子，你将看到多部分图确实可以在几个场景中产生——例如，在以下场景中：
- en: When processing documents and structuring the information in a bipartite graph
    of documents and entities that appear in the documents
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理文档并将文档中出现的实体信息以二部分图的形式结构化时
- en: When dealing with transactional data, in order to encode the relations between
    the buyers and the merchants
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理交易数据时，为了编码买家和商家之间的关系
- en: 'A bipartite graph can be easily created in `networkx` with the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`networkx`中，可以使用以下代码轻松创建一个二部分图：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The network can also be conveniently plotted using the `bipartite_layout` utility
    function of `networkx`, as illustrated in the following code snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该网络也可以方便地使用`networkx`的`bipartite_layout`实用函数绘制，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `bipatite_layout` function produces a graph, as shown in the following
    screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`bipatite_layout`函数生成一个图，如下面的屏幕截图所示：'
- en: '![Figure 1.5 – Example of a bipartite graph'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.5 – 二部分图的示例'
- en: '](img/B16069_01_05.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_01_05.jpg](img/B16069_01_05.jpg)'
- en: Figure 1.5 – Example of a bipartite graph
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.5 – 二部分图的示例
- en: Graph representations
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图表示
- en: As described in the previous sections, with `networkx`, we can actually define
    and manipulate a graph by using node and edge objects. In different use cases,
    such a representation would not be as easy to handle. In this section, we will
    show two ways to perform a compact representation of a graph data structure—namely,
    an adjacency matrix and an edge list.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，使用`networkx`，我们实际上可以通过使用节点和边对象来定义和操作一个图。在不同的用例中，这种表示可能不太容易处理。在本节中，我们将展示两种执行图数据结构紧凑表示的方法——即邻接矩阵和边列表。
- en: Adjacency matrix
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 邻接矩阵
- en: 'The **adjacency matrix** *M* of a graph *G=(V,E)* is a square matrix *(|V|
    × |V|*) matrix such that its element ![](img/Formula_01_041.png) is 1 when there
    is an edge from node *i* to node *j*, and 0 when there is no edge. In the following
    screenshot, we show a simple example where the adjacency matrix of different types
    of graphs is displayed:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图G=(V,E)的**邻接矩阵**M是一个方阵(|V| × |V|)，其元素![img/Formula_01_041.png](img/Formula_01_041.png)在节点i到节点j之间存在边时为1，不存在边时为0。在下面的屏幕截图中，我们展示了不同类型图的邻接矩阵的简单示例：
- en: '![Figure 1.6 – Adjacency matrix for an undirected graph, a digraph, a multigraph,
    and a weighted graph'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.6 – 无向图、有向图、多重图和加权图的邻接矩阵'
- en: '](img/B16069_01_006.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_01_006.jpg](img/B16069_01_006.jpg)'
- en: Figure 1.6 – Adjacency matrix for an undirected graph, a digraph, a multigraph,
    and a weighted graph
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.6 – 无向图、有向图、多重图和加权图的邻接矩阵
- en: It is easy to see that adjacency matrices for undirected graphs are always symmetric,
    since no direction is defined for the edge. The symmetry instead is not guaranteed
    for the adjacency matrix of a digraph due to the presence of constraints in the
    direction of the edges. For a multigraph, we can instead have values greater than
    1 since multiple edges can be used to connect the same couple of nodes. For a
    weighted graph, the value in a specific cell is equal to the weight of the edge
    connecting the two nodes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，无向图的邻接矩阵总是对称的，因为边没有定义方向。由于边方向的约束存在，有向图的邻接矩阵的对称性不能保证。对于多重图，我们可以有大于 1 的值，因为可以使用多条边连接相同的节点对。对于加权图，特定单元格的值等于连接两个节点的边的权重。
- en: 'In `networkx`, the adjacency matrix for a given graph can be computed in two
    different ways. If `G` is the `networkx` of *Figure 1.6*, we can compute its adjacency
    matrix as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `networkx` 中，给定图的邻接矩阵可以通过两种不同的方式计算。如果 `G` 是 *图 1.6* 中的 `networkx`，我们可以按照以下方式计算其邻接矩阵：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For the first and second line, we get the following results respectively:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一行和第二行，我们分别得到以下结果：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since a `numpy` matrix cannot represent the name of the nodes, the order of
    the element in the adjacency matrix is the one defined in the `G.nodes` list.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `numpy` 矩阵不能表示节点的名称，邻接矩阵中元素的位置是 `G.nodes` 列表中定义的。
- en: Edge list
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边列表
- en: As well as an adjacency matrix, an edge list is another compact way to represent
    graphs. The idea behind this format is to represent a graph as a list of edges.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了邻接矩阵之外，边列表也是表示图的一种紧凑方式。这种格式的思想是将图表示为边的列表。
- en: 'The **edge list** *L* of a graph *G=(V,E)* is a list of size *|E|* matrix such
    that its element ![](img/Formula_01_042.png) is a couple representing the tail
    and the end node of the edge *i*. An example of the edge list for each type of
    graph is available in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 *G=(V,E)* 的 **边列表** *L* 是一个大小为 *|E|* 的矩阵，其元素 ![](img/Formula_01_042.png) 是一个表示边
    *i* 的尾节点和终节点的对。每种类型图的边列表的示例可以在以下屏幕截图找到：
- en: '![Figure 1.7 – Edge list for an undirected graph, a digraph, a multigraph,
    and a weighted graph'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – 无向图、有向图、多重图和加权图的边列表'
- en: '](img/B16069_01_007.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16069_01_007.jpg)'
- en: Figure 1.7 – Edge list for an undirected graph, a digraph, a multigraph, and
    a weighted graph
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 无向图、有向图、多重图和加权图的边列表
- en: 'In the following code snippet, we show how to compute in `networkx` the edge
    list of the simple undirected graph *G* available in *Figure 1.7*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们展示了如何在 `networkx` 中计算 *图 1.7* 中可用的简单无向图 *G* 的边列表：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By running the preceding command, we get the following result:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行前面的命令，我们得到以下结果：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Other representation methods, which we will not discuss in detail, are also
    available in `networkx`. Some examples are `nx.to_dict_of_dicts(G)` and `nx.to_numpy_array(G)`,
    among others.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`networkx` 中还有其他一些我们不会详细讨论的表示方法。其中一些例子包括 `nx.to_dict_of_dicts(G)` 和 `nx.to_numpy_array(G)`
    等。'
- en: Plotting graphs
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制图形
- en: As we have seen in previous sections, graphs are intuitive data structures represented
    graphically. Nodes can be plotted as simple circles, while edges are lines connecting
    two nodes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，图是直观的图形数据结构。节点可以绘制为简单的圆圈，而边是连接两个节点的线条。
- en: Despite their simplicity, it could be quite difficult to make a clear representation
    when the number of edges and nodes increases. The source of this complexity is
    mainly related to the position (space/Cartesian coordinates) to assign to each
    node in the final plot. Indeed, it could be unfeasible to manually assign to a
    graph with hundreds of nodes the specific position of each node in the final plot.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们很简单，但当边和节点的数量增加时，可能很难清楚地表示。这种复杂性的来源主要是与在最终绘图中将每个节点分配到位置（空间/笛卡尔坐标）有关。实际上，手动将数百个节点的特定位置分配到最终绘图可能是不可行的。
- en: 'In this section, we will see how we can plot graphs without specifying coordinates
    for each node. We will exploit two different solutions: `networkx` and Gephi.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何在不指定每个节点的坐标的情况下绘制图形。我们将利用两种不同的解决方案：`networkx` 和 Gephi。
- en: networkx
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: networkx
- en: '`networkx` offers a simple interface to plot graph objects through the `nx.draw`
    library. In the following code snippet, we show how to use the library in order
    to plot graphs:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`networkx` 通过 `nx.draw` 库提供了一个简单的接口来绘制图形对象。在以下代码片段中，我们展示了如何使用该库来绘制图形：'
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, `nodes_position` is a dictionary where the keys are the nodes and the
    value assigned to each key is an array of length 2, with the Cartesian coordinate
    used for plotting the specific node.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The `nx.draw` function will plot the whole graph by putting its nodes in the
    given positions. The `with_labels` option will plot its name on top of each node
    with the specific `font_size` value. `node_size` and `edge_color` will respectively
    specify the size of the circle, representing the node and the color of the edges.
    Finally, `arrowsize` will define the size of the arrow for directed edges. This
    option will be used when the graph to be plotted is a digraph.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we show how to use the `draw_graph` function
    previously defined in order to plot a graph:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result of the plot is available to view in the following screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Result of the plotting function'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_01_08.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.8 – Result of the plotting function
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The method previously described is simple but unfeasible to use in a real scenario
    since the `node_position` value could be difficult to decide. In order to solve
    this issue, `networkx` offers a different function to automatically compute the
    position of each node according to different layouts. In *Figure 1.9*, we show
    a series of plots of an undirected graph, obtained using the different layouts
    available in `networkx`. In order to use them in the function we proposed, we
    simply need to assign `node_position` to the result of the layout we want to use—for
    example, `node_position = nx.circular_layout(G)`. The plots can be seen in the
    following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Plots of the same undirected graph with different layouts'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_01_009.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.9 – Plots of the same undirected graph with different layouts
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '`networkx` is a great tool for easily manipulating and analyzing graphs, but
    it does not offer good functionalities in order to perform complex and good-looking
    plots of graphs. In the next section, we will investigate another tool to perform
    complex graph visualization: Gephi.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Gephi
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will show how `Les Miserables.gexf` sample (a weighted undirected
    graph), which can be selected in the **Welcome** window when the application starts.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'The main interface of Gephi is shown in *Figure 1.10*. It can be divided into
    four main areas, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**Graph**: This section shows the final plot of the graph. The image is automatically
    updated each time a filter or a specific layout is applied.'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Appearance**: Here, it is possible to specify the appearance of nodes and
    edges.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`networkx`) to adjust the node position in the graph. Different algorithms,
    from a simple random position generator to a more complex Yifan Hu algorithm,
    are available.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Filters & Statistics**: In this set area, two main functions are available,
    outlined as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a. **Filters**: In this tab, it is possible to filter and visualize specific
    subregions of the graph according to a set property computed using the **Statistics**
    tab.'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. **过滤器**：在此选项卡中，可以根据使用 **统计信息** 选项卡计算的一组属性过滤和可视化图形的特定子区域。
- en: 'b. **Statistics**: This tab contains a list of available graph metrics that
    can be computed on the graph using the **Run** button. Once metrics are computed,
    they can be used as properties to specify the edges'' and nodes'' appearance (such
    as node and edge size and color) or to filter a specific subregion of the graph.'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. **统计信息**：此选项卡包含可以在图形上使用 **运行** 按钮计算的可用图形度量。一旦计算了度量，它们可以用作属性来指定边和节点的外观（例如节点和边的大小和颜色）或用于过滤图形的特定子区域。
- en: 'You can see the main interface of Gephi in the following screenshot:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在下面的屏幕截图中看到 Gephi 的主界面：
- en: '![Figure 1.10 – Gephi main window'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.10 – Gephi 主窗口'
- en: '](img/B16069_01_010.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_01_010.jpg](img/B16069_01_010.jpg)'
- en: Figure 1.10 – Gephi main window
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.10 – Gephi 主窗口
- en: Our exploration of Gephi starts with the application of different layouts to
    the graph. As previously described, in `networkx` the layouts allow us to assign
    to each node a specific position in the final plot. In Gephi 1.2, different layouts
    are available. In order to apply a specific layout, we have to select from the
    **Layout** area one of the available layouts, and then click on the **Run** button
    that appears after the selection.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 Gephi 的探索从将不同的布局应用于图形开始。如前所述，在 `networkx` 中，布局允许我们为每个节点在最终绘制中分配一个特定的位置。在
    Gephi 1.2 中，有多个布局可供选择。为了应用特定的布局，我们必须从 **布局** 区域中选择一个可用的布局，然后点击选择后出现的 **运行** 按钮。
- en: 'The graph representation, visible in the **Graph** area, will be automatically
    updated according to the new coordinates defined by the layout. It should be noted
    that some layouts are parametric, hence the final graph plot can significantly
    change according to the parameters used. In the following screenshot, we propose
    several examples for the application of three different layouts:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 可在 **图形** 区域中看到的图形表示，将根据布局定义的新坐标自动更新。需要注意的是，某些布局是参数化的，因此最终的图形绘制可以根据所使用的参数显著改变。在下面的屏幕截图中，我们提出了三个不同布局的应用示例：
- en: '![Figure 1.11 – Plot of the same graph with different layout'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.11 – 不同布局下的同一图形'
- en: '](img/B16069_01_011.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_01_011.jpg](img/B16069_01_011.jpg)'
- en: Figure 1.11 – Plot of the same graph with different layout
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 不同布局下的同一图形
- en: We will now introduce the available options in the **Appearance** menu visible
    in *Figure 1.10*. In this section, it is possible to specify the style to be applied
    to edges and nodes. The style to be applied can be static or can be dynamically
    defined by specific properties of the nodes/edges. We can change the color and
    the size of the nodes by selecting the **Nodes** option in the menu.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍在 *图 1.10* 中可见的 **外观** 菜单中的可用选项。在本节中，可以指定要应用于边和节点的样式。要应用的样式可以是静态的，也可以由节点/边的特定属性动态定义。我们可以通过在菜单中选择
    **节点** 选项来更改节点的大小和颜色。
- en: In order to change the color, we have to select the color palette icon and decide,
    using the specific button, if we want to assign a **Unique** color, a **Partition**
    (discrete values), or a **Ranking** (range of values) of colors. For **Partition**
    and **Ranking**, it is possible to select from the drop-down menu a specific **Graph**
    property to use as reference for the color range. Only the properties computed
    by clicking **Run** in the **Statistics** area are available in the drop-down
    menu. The same procedure can be used in order to set the size of the nodes. By
    selecting the concentric circles icon, it is possible to set a **Unique** size
    to all the nodes or to specify a **Ranking** of size according to a specific property.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更改颜色，我们必须选择调色板图标，并使用特定的按钮决定我们想要分配一个 **唯一** 的颜色、一个 **分区**（离散值）或一个 **排名**（值范围）。对于
    **分区** 和 **排名**，可以从下拉菜单中选择一个特定的 **图形** 属性作为颜色范围的参考。只有通过在 **统计信息** 区域中点击 **运行**
    计算的属性才在下拉菜单中可用。相同的程序可以用来设置节点的大小。通过选择同心圆图标，可以设置所有节点的 **唯一** 大小或根据特定属性指定大小的一个 **排名**。
- en: As for the nodes, it is also possible to change the style of the edges by selecting
    the **Edges** option in the menu. We can then select to assign a **Unique** color,
    a **Partition** (discrete values), or a **Ranking** (range of values) of colors.
    For **Partition** and **Ranking**, the reference value to build the color scale
    is defined by a specific **Graph** property that can be selected from the drop-down
    menu.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to remember that in order to apply a specific style to the
    graph, the **Apply** button should be clicked. As a result, the graph plot will
    be updated according to the style defined. In the following screenshot, we show
    an example where the color of the nodes is given by the **Modularity Class** value
    and the size of each node is given by its degree, while the color of each edge
    is defined by the edge weight:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12 – Example of graph plot changing nodes’ and edges’ appearance'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_01_012.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.12 – Example of graph plot changing nodes' and edges' appearance
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Another important section that needs to be described is **Filters & Statistics**.
    In this menu, it is possible to compute some statistics based on graph metrics.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we conclude our discussion on Gephi by introducing the functionalities
    available in the **Statistics** menu, visible in the right panel in *Figure 1.10*.
    Through this menu, it is possible to compute different statistics on the input
    graph. Those statistics can be easily used to set some properties of the final
    plot, such as nodes'/edges' color and size, or to filter the original graph to
    plot just a specific subset of it. In order to compute a specific statistic, the
    user then needs to explicitly select one of the metrics available in the menu
    and click on the **Run** button (*Figure 1.10*, right panel).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the user can select a subregion of the graph, using the options available
    in the **Filters** tab of the **Statistics** menu, visible in the right panel
    in *Figure 1.10*. An example of filtering a graph can be seen in *Figure 1.13*.
    To provide more details of this, we build and apply to the graph a filter, using
    the **Degree** property. The result of the filters is a subset of the original
    graph, where only the nodes (and their edges) having the specific range of values
    for the degree property are visible.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'This is illustrated in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – Example of a graph filtered according to a range of values
    for Degree'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_01_013.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.13 – Example of a graph filtered according to a range of values for
    Degree
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Of course, Gephi allows us to perform more complex visualization tasks and contains
    a lot of functionalities that cannot be fully covered in this book. Some good
    references to better investigate all the features available in Gephi are the official
    Gephi guide ([https://gephi.org/users/](https://gephi.org/users/)) or the *Gephi
    Cookbook* book by Packt Publishing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Graph properties
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already learned, a *graph* is a mathematical model that is used for
    describing relations between entities. However, each complex network presents
    intrinsic properties. Such properties can be measured by particular metrics, and
    each measure may characterize one or several local and global aspects of the graph.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: In a graph for a social network such as Twitter, for example, users (represented
    by the *nodes* of the graph) are connected to each other. However, there are users
    that are more connected than others (influencers). On the Reddit social graph,
    users with similar characteristics tend to group into communities.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already mentioned some of the *basic features* of graphs, such as the
    *number of nodes and edges* in a graph, which constitute the size of the graph
    itself. Those properties already provide a good description of the structure of
    a network. Think about the Facebook graph, for example: it can be described in
    terms of the number of nodes and edges. Such numbers easily allow it to be distinguished
    from a much smaller network (for example, the social structure of an office) but
    fail to characterize more complex dynamics (for example, how *similar* nodes are
    connected). To this end, more advanced graph-derived **metrics** can be considered,
    which can be grouped into four main categories, outlined as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration metrics**: These measure how nodes tend to be interconnected
    with each other.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Segregation metrics**: These quantify the presence of groups of interconnected
    nodes, known as communities or modules, within a network.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Centrality metrics**: These assess the importance of individual nodes inside
    a network.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilience metrics**: These can be thought of as a measure of how much a
    network is able to maintain and adapt its operational performance when facing
    failures or other adverse conditions.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those metrics are defined as **global** when expressing a measure of an overall
    network. On the other hand, **local** metrics measure values of individual network
    elements (nodes or edges). In weighted graphs, each property may or may not account
    for the *edge weights*, leading to **weighted and unweighted metrics**.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we describe some of the most commonly used metrics
    that measure global and local properties. For simplicity, unless specified differently
    in the text, we illustrate the global unweighted version of the metric. In several
    cases, this is obtained by averaging the local unweighted properties of the node.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Integration metrics
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, some of the most frequently used integration metrics will be
    described.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Distance, path, and shortest path
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of **distance** in a graph is often related to the number of edges
    to traverse in order to reach a target node from a given source node.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In particular, consider a source node ![](img/Formula_01_043.png) and a target
    node ![](img/Formula_01_044.png). The set of edges connecting node ![](img/Formula_01_045.png)
    to node![](img/Formula_01_046.png) is called a **path**. When studying complex
    networks, we are often interested in finding the **shortest path** between two
    nodes. A shortest path between a source node ![](img/Formula_01_047.png) and a
    target node ![](img/Formula_01_048.png) is the path having the lowest number of
    edges compared to all the possible paths between ![](img/Formula_01_049.png) and
    ![](img/Formula_01_050.png). The **diameter** of a network is the number of edges
    contained in the longest shortest path among all possible shortest paths.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot. There are different paths to reach
    **Tokyo** from **Dublin**. However, one of them is the shortest (the edges on
    the shortest path are highlighted):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14 – The shortest path between two nodes'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_01_014.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.14 – The shortest path between two nodes
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shortest_path` function of the `networkx` Python library enables users
    to quickly compute the shortest path between two nodes in a graph. Consider the
    following code, in which a seven-node graph is created by using `networkx`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The shortest path between a source node (for example, `''Dublin''`, identified
    by the key 1) and a target node (for example, `''Tokyo''`, identified by the key
    7) can be obtained as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This should output the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, `[1,3,4,5,7]` are the nodes contained in the shortest path between `'Tokyo'`
    and `'Dublin'`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Characteristic path length
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **characteristic path length** is defined as the average of all the shortest
    path lengths between all possible pair of nodes. If ![](img/Formula_01_051.png)
    is the average path length between the node![](img/Formula_01_052.png) and all
    the other nodes, the characteristic path length is computed as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_01_053.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: 'Here, ![](img/Formula_01_054.png) is the set of nodes in the graph and ![](img/Formula_01_055.png)
    represents its *order*. This is one of the most commonly used measures of how
    efficiently information is spread across a network. Networks having shorter characteristic
    path lengths promote the quick transfer of information and reduce costs. Characteristic
    path length can be computed through `networkx` using the following function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This should give us the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, this metric cannot be always defined since it is not possible to compute
    a path among all the nodes in *disconnected graphs*. For this reason, **network
    efficiency** is also widely used.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Global and local efficiency
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Global efficiency** is the average of the inverse shortest path length for
    all pairs of nodes. Such a metric can be seen as a measure of how efficiently
    information is exchanged across a network. Consider that ![](img/Formula_01_056.png)
    is the shortest path between a node ![](img/Formula_01_057.png) and a node ![](img/Formula_01_058.png).
    The network efficiency is defined as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_01_059.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Efficiency is at a maximum when a graph is fully connected, while it is minimal
    for completely disconnected graphs. Intuitively, the shorter the path, the lower
    the measure.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'The `networkx` using the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output should be as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Average local efficiency is computed in `networkx` using the following command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output should be as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the following screenshot, two examples of graphs are depicted. As observed,
    a fully connected graph on the left presents a higher level of efficiency compared
    to a circular graph on the right. In a fully connected graph, each node can be
    reached from any other node in the graph, and information is exchanged rapidly
    across the network. However, in a circular graph, several nodes should instead
    be traversed to reach the target node, making it less efficient:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15 – Global efficiency of a fully connected graph (left) and a circular
    graph (right)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_01_015.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.15 – Global efficiency of a fully connected graph (left) and a circular
    graph (right)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Integration metrics well describe the connection among nodes. However, more
    information about the presence of groups can be extracted by considering segregation
    metrics.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Segregation metrics
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, some of the most common segregation metrics will be described.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Clustering coefficient
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `networkx` using the following command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This should output the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The local clustering coefficient is computed in `networkx` using the following
    command:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This should output the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is a Python dictionary containing, for each node (identified by
    the respective key), the corresponding value. In the graph represented in *Figure
    1.16*, two clusters of nodes can be easily identified. By computing the clustering
    coefficient for each single node, it can be observed that **Rome** has the lowest
    value. **Tokyo** and **Moscow**, as well as **Paris** and **Dublin**, are instead
    very well connected within their respective groups (notice the size of each node
    is drawn proportionally to each node''s clustering coefficient). The graph can
    be seen in the following screenshot:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.16 – Local clustering coefficient representation'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_01_16.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.16 – Local clustering coefficient representation
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Transitivity
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common variant of the clustering coefficient is known as `networkx`, as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output should be as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Modularity
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Modularity** was designed to quantify the division of a network in aggregated
    sets of highly interconnected nodes, commonly known as **modules**, **communities**,
    **groups**, or **clusters**. The main idea is that networks having high modularity
    will show dense connections within the module and sparse connections between modules.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a social network such as Reddit: members of communities related to
    video games tend to interact much more with other users in the same community,
    talking about recent news, favorite consoles, and so on. However, they will probably
    interact less with users talking about fashion. Differently from many other graph
    metrics, modularity is often computed by means of optimization algorithms.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Modularity in `networkx` is computed using the `modularity` function of the
    `networkx.algorithms.community` module, as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, the second argument—`communities`—is a list of sets, each representing
    a partition of the graph. The output should be as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Segregation metrics help to understand the presence of groups. However, each
    node in a graph has its own *importance*. To quantify it, we can use centrality
    metrics.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Centrality metrics
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, some of the most common centrality metrics will be described.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Degree centrality
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most common and simple centrality metrics is the **degree centrality**
    metric. This is directly connected with the *degree* of a node, measuring the
    number of *incident* edges on a certain node ![](img/Formula_01_060.png).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Intuitively, the more a node is connected to an other node, the more its degree
    centrality will assume high values. Note that, if a graph is *directed*, the `networkx`
    by using the following command:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output should be as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Closeness centrality
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **closeness centrality** metric attempts to quantify how much a node is
    close (well connected) to other nodes. More formally, it refers to the average
    distance of a node ![](img/Formula_01_061.png) to all other nodes in the network.
    If ![](img/Formula_01_062.png) is the shortest path between node ![](img/Formula_01_063.png)
    and node ![](img/Formula_01_064.png), the closeness centrality is defined as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_01_065.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
- en: 'Here, *V* is the set of nodes in the graph. Closeness centrality can be computed
    in `networkx` using the following command:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output should be as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Betweenness centrality
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **betweenness centrality** metric evaluates how much a node acts as a **bridge**
    between other nodes. Even if poorly connected, a node can be strategically connected,
    helping to keep the whole network connected.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'If ![](img/Formula_01_066.png) is the total number of shortest paths between
    node ![](img/Formula_01_067.png) and node ![](img/Formula_01_068.png) and ![](img/Formula_01_069.png)
    is the total number of shortest paths between ![](img/Formula_01_070.png) and
    ![](img/Formula_01_071.png) passing through node ![](img/Formula_01_072.png),
    then the betweenness centrality is defined as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_01_073.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: 'If we observe the formula, we can notice that the higher the number of shortest
    paths passing through node ![](img/Formula_01_074.png), the higher the value of
    the betweenness centrality. Betweenness centrality is computed in `networkx` by
    using the following command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output should be as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In *Figure 1.17*, we illustrate the difference between *degree centrality*,
    *closeness centrality*, and *betweenness centrality*. **Milan** and **Naples**
    have the highest degree centrality. **Rome** has the highest closeness centrality
    since it is the closest to any other node. It also shows the highest betweenness
    centrality because of its crucial role in connecting the two visible clusters
    and keeping the whole network connected.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the differences here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.17 – Degree centrality (left), closeness centrality (center), and
    betweenness centrality (right)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_01_017.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.17 – Degree centrality (left), closeness centrality (center), and betweenness
    centrality (right)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Centrality metrics allow us to measure the importance of a node inside the network.
    Finally, we will mention resilience metrics, which enable us to measure the vulnerability
    of a graph.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Resilience metrics
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several metrics that measure a network's resilience. Assortativity
    is one of the most used.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Assortativity coefficient
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`networkx` by using the following command:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output should be as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Social networks are mostly assortative. However, the so-called *influencers*
    (famous singers, football players, fashion bloggers) tend to be *followed* (incoming
    edges) by several standard users, while tending to be connected with each other
    and showing a disassortative behavior.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remark that the previously presented properties are a subset
    of all the possible metrics used to describe graphs. A wider set of metrics and
    algorithms can be found at [https://networkx.org/documentation/stable/reference/algorithms/](https://networkx.org/documentation/stable/reference/algorithms/).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarks and repositories
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have understood the basic concepts and notions about graphs and
    network analysis, it is now time to dive into some practical examples that will
    help us to start to put into practice the general concepts we have learned so
    far. In this section, we will present some examples and toy problems that are
    generally used to study the properties of networks, as well as benchmark performances
    and effectiveness of networks' algorithms. We will also provide some useful links
    of repositories where network datasets can be found and downloaded, together with
    some tips on how to parse and process them.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Examples of simple graphs
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by looking at some very simple examples of networks. Fortunately,
    `networkx` already comes with a number of graphs already implemented, ready to
    be used and played with. Let''s start by creating a **fully connected undirected
    graph**, as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This has ![](img/Formula_01_075.png) edges and a clustering coefficient *C=1*.
    Although fully connected graphs are not very interesting on their own, they represent
    a fundamental building block that may arise within larger graphs. A fully connected
    subgraph of *n* nodes within a larger graph is generally referred to as a **clique**
    of size *n*.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Definition
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: A **clique**, *C*, in an undirected graph is defined a subset of its vertices, *C *![](img/Formula_01_077.png)* V*,
    such that every two distinct vertices in the subset are adjacent. This is equivalent
    to the condition that the induced subgraph of *G* induced by *C* is a fully connected
    graph.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Cliques represent one of the basic concepts in graph theory and are often also
    used in mathematical problems where relations need to be encoded. Besides, they
    also represent the simplest unit when constructing more complex graphs. On the
    other hand, the task of finding cliques of a given size *n* in larger graphs (clique
    problem) is of great interest and it can be shown that it is a **nondeterministic
    polynomial-time complete** (**NP-complete**) problem often studied in computer
    science.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Some simple examples of `networkx` graphs can be seen in the following screenshot:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.18 – Simple examples of graphs with networkx. (left) fully connected
    graph; (center) lollipop graph; (right) barbell graph](img/B16069_01_18.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.18 – Simple examples of graphs with networkx: (left) fully connected
    graph; (center) lollipop graph; (right) barbell graph'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 1.18*, we showed a complete graph along with two other simple examples
    containing cliques that can be easily generated with `networkx`, outlined as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'A **lollipop graph** formed by a clique of size *n* and a branch of *m* nodes,
    as shown in the following code snippet:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A **barbell graph** formed by two cliques of size *m1* and *m2* joined by a
    branch of nodes, which resembles the sample graph we used previously to characterize
    some of the global and local properties. The code to generate this is shown in
    the following snippet:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Such simple graphs are basic building blocks that can be used to generate more
    complex networks by combining them. Merging subgraphs is very easy with `networkx`
    and can be done with just a few lines of code, as shown in the following code
    snippet, where the three graphs are merged together into a single graph and some
    random edges are placed to connect them:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Other very simple graphs (that can then be merged and played around with) can
    be found at [https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.classic](https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.classic).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Generative graph models
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although creating simple subgraphs and merging them is a way to generate new
    graphs of increasing complexity, networks may also be generated by means of **probabilistic
    models** and/or **generative models** that let a graph grow by itself. Such graphs
    usually share interesting properties with real networks and have long been used
    to create benchmarks and synthetic graphs, especially in times when the amount
    of data available was not as overwhelming as today. Here, we present some examples
    of random generated graphs, briefly describing the models that underlie them.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Watts and Strogatz (1998)
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This model was used by the authors to study the behavior of **small-world networks**—that
    is to say, networks that resemble, to some extent, common social networks. The
    graph is generated by first displacing *n* nodes in a ring and connecting each
    node with its *k* neighbors. Each edge of such a graph then has a probability
    *p* of being rewired to a randomly chosen node. By ranging *p*, the Watts and
    Strogatz model allows a shift from a regular network (*p=0*) to a completely random
    network (*p=1*). In between, graphs exhibit small-world features; that is, they
    tend to bring this model closer to social network graphs. These kinds of graphs
    can be easily created with the following command:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Barabási-Albert (1999)
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The model proposed by Albert and Barabási is based on a generative model that
    allows the creation of random scale-free networks by using a **preferential attachment**
    schema, where a network is created by progressively adding new nodes and attaching
    them to already existing nodes, with a preference for nodes that have more neighbors.
    Mathematically speaking, the underlying idea of this model is that the probability
    for a new node to be attached to an existing node *i* depends on the degree of
    the *i*-th node, according to the following formula:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_01_076.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
- en: Thus, nodes with a large number of edges (hubs) tend to develop even more edges,
    whereas nodes with few links will not develop other links (periphery). Networks
    generated by this model exhibit a *power-law distribution* for the connectivity
    (that is, degree) between nodes. Such a behavior is also found in real networks
    (for example, the `networkx`) to also allow the preferential attachment of new
    edges or rewiring of existing edges.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'The Barabási-Albert model is illustrated in the following screenshot:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19 – Barabási-Albert model (left) with 20 nodes (right) distribution
    of connectivity with n=100.000 nodes, showing the scale-free power law distribution](img/B16069_01_19.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
- en: Figure 1.19 – Barabási-Albert model (left) with 20 nodes (right) distribution
    of connectivity with n=100.000 nodes, showing the scale-free power law distribution
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 1.19*, we showed an example of the Barabasi-Albert model for a small
    network, where you can already observe the emergence of hubs (on the left), as
    well as the probability distribution of the degree of the nodes, which exhibits
    a scale-free power-law behavior (on the right). The preceding distribution can
    easily be replicated in `networkx`, as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Benchmarks
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Digitalization has profoundly changed our lives, and today, any activity, person,
    or process generates data, providing a huge amount of information to be drilled,
    analyzed, and used to promote data-driven decision making. A few decades ago,
    it was hard to find datasets ready to be used to develop or test new algorithms.
    On the other hand, there exist today plenty of repositories that provide us with
    datasets, even of fairly large dimensions, to be downloaded and analyzed. These
    repositories, where people can share datasets, also provide a benchmark where
    algorithms can be applied, validated, and compared with each other.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will briefly go through some of the main repositories and
    file formats used in network science, in order to provide you with all the tools
    needed to import datasets—of different sizes—to analyze and play around with.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: In such repositories, you will find network datasets coming from some of the
    common areas of network science, such as social networks, biochemistry, dynamic
    networks, documents, co-authoring and citations networks, and networks arising
    from financial transactions. In *Part 3*, *Advanced Applications of Graph Machine
    Learning*, we will discuss some of the most common type of networks (social networks,
    graphs arising when processing corpus documents, and financial networks) and analyze
    them more thoroughly by applying the techniques and algorithms described in *Part
    2*, *Machine Learning on Graphs*.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Also, `networkx` already comes with some basic (and very small) networks that
    are generally used to explain algorithms and basic measures, which can be found
    at [https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.social](https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.social).
    These datasets are, however, generally quite small. For larger datasets, refer
    to the repositories we present next.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Network Data Repository
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Network Data Repository** is surely one of the largest repositories of
    network data ([http://networkrepository.com/](http://networkrepository.com/))
    with several thousand different networks, featuring users and donations from all
    over the world and top-tier academic institutions. If a network dataset is freely
    available, chances are that you will find it there. Datasets are classified in
    about *30 domains*, including biology, economics, citations, social network data,
    industrial applications (energy, road), and many others. Besides providing the
    data, the website also provides a tool for interactive visualization, exploration,
    and comparison of datasets, and we suggest you check it out and explore it.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The data in the Network Data Repository is generally available under the **Matrix
    Market Exchange Format** (**MTX**) file format. The MTX file format is basically
    a file format for specifying dense or sparse matrices, real or complex, via readable
    text files (**American Standard Code for Information Interchange**, or **ASCII**).
    For more details, please refer to [http://math.nist.gov/MatrixMarket/formats.html#MMformat](http://math.nist.gov/MatrixMarket/formats.html#MMformat).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'A file in MTX format can be easily read in Python using `scipy`. Some of the
    files we downloaded from the Network Data Repository seemed slightly corrupted
    and required a minimal fix on a 10.15.2 OSX system. In order to fix them, just
    make sure the header of the file is compliant with the format specifications;
    that is, with a double `%` and no spaces at the beginning of the line, as in the
    following line:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Matrices should be in coordinate format. In this case, the specification points
    also to an unweighted, undirected graph (as understood by `pattern` and `symmetric`).
    Some of the files have some comments after the first header line, which are preceded
    by a single `%`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we consider the **Astro Physics** (**ASTRO-PH**) collaboration
    network. The graph is generated using all the scientific papers available from
    the e-print *arXiv* repository published in the *Astrophysics* category in the
    period from January 1993 to April 2003\. The network is built by connecting (via
    undirected edges) all the authors that co-authored a publication, thus resulting
    in a clique that includes all authors of a given paper. The code to generate the
    graph can be seen here:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The dataset has 17,903 nodes, connected by 196,072 edges. Visualizing so many
    nodes cannot be done easily, and even if we were to do it, it might not be very
    informative, as understanding the underlying structure would not be very easy
    with so much information. However, we can get some insights by looking at specific
    subgraphs, as we will do next.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can start by computing some basic properties we described earlier
    and put them into a pandas `DataFrame` for our convenience to later use, sort,
    and analyze. The code to accomplish this is illustrated in the following snippet:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can easily find out that the node with the largest `6933`, which has 503
    neighbors (surely a very popular and important scientist in astrophysics!), as
    illustrated in the following code snippet:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Of course, also plotting its `C_i` values. The code to accomplish this is shown
    in the following code snippet:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can then define a simple function for extracting and plotting a subgraph
    that includes only the nodes related to certain indices, as shown in the following
    code snippet:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Using the preceding function, we can plot the different subgraphs, obtained
    by filtering the ego network using the three different criteria, based on random
    sampling, centrality, and the clustering coefficient we presented previously.
    An example is provided here:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In *Figure 1.20*, we compare these results where the other networks have been
    obtained by changing the key value to `centrality` and `C_i`. The random representation
    seems to show some emerging structure with separated communities. The graph with
    the most central nodes clearly shows an almost fully connected network, possibly
    made up of all full professors and influential figures in astrophysics science,
    publishing on multiple topics and collaborating frequently with each other. Finally,
    the last representation, on the other hand, highlights some specific communities,
    possibly connected with a specific topic, by selecting the nodes that have a higher
    clustering coefficient. These nodes might not have a large degree of centrality,
    but they very well represent specific topics. You can see examples of the ego
    subgraph here:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.20 – Examples of the ego subgraph for the node that has largest
    degree in the ASTRO-PH dataset. Neighbors are sampled with a ratio=0.1\. (left)
    random sampling; (center) nodes with largest betweenness centrality; (right) nodes
    with largest clustering coefficient](img/B16069_01_20.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
- en: Figure 1.20 – Examples of the ego subgraph for the node that has largest degree
    in the ASTRO-PH dataset. Neighbors are sampled with a ratio=0.1\. (left) random
    sampling; (center) nodes with largest betweenness centrality; (right) nodes with
    largest clustering coefficient
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option to visualize this in `networkx` could also be to use the *Gephi*
    software that allows for fast filtering and visualizations of graphs. In order
    to do so, we need to first export the data as **Graph Exchange XML Format** (**GEXF**)
    (which is a file format that can be imported in Gephi), as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Once data is imported in Gephi, with few filters (by centrality or degree) and
    some computations (modularity), you can easily do plots as nice as the one shown
    in *Figure 1.21*, where nodes have been colored using modularity in order to highlight
    clusters. Coloring also allows us to easily spot nodes that connect the different
    communities and that therefore have large betweenness.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Some of the datasets in the Network Data Repository may also be available in
    the `networkx` is to convert them by simply rewriting its header. Take, for instance,
    the **Digital Bibliography and Library** (**DBLP**) citation network.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample plot can be seen in the following screenshot:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.21 – Example of the visualization ASTRO-PH dataset with Gephi. Nodes
    are filtered by degree centrality and colored by modularity class; node sizes
    are proportional to the value of the degree](img/B16069_01_21.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
- en: Figure 1.21 – Example of the visualization ASTRO-PH dataset with Gephi. Nodes
    are filtered by degree centrality and colored by modularity class; node sizes
    are proportional to the value of the degree
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the header of the file:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This can be easily converted to comply with the MTX file format by replacing
    these lines with the following code:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Then, you can use the import functions described previously.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Stanford Large Network Dataset Collection
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another valuable source of network datasets is the website of the **Stanford
    Network Analysis Platform** (**SNAP**) ([https://snap.stanford.edu/index.html](https://snap.stanford.edu/index.html)),
    which is a general-purpose network analysis library that was written in order
    to handle even fairly large graphs, with hundreds of millions of nodes and billions
    of edges. It is written in *C++* to achieve top computational performance, but
    it also features interfaces with Python in order to be imported and used in native
    Python applications.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Although `networkx` is currently the main library to study `networkx`, SNAP
    or other libraries (more on this shortly) can be orders of magnitude faster than
    `networkx`, and they may be used in place of `networkx` for tasks that require
    higher performance. In the SNAP website, you will find a specific web page for
    **Biomedical Network Datasets** ([https://snap.stanford.edu/biodata/index.html](https://snap.stanford.edu/biodata/index.html)),
    besides other more general networks ([https://snap.stanford.edu/data/index.html](https://snap.stanford.edu/data/index.html)),
    covering similar domains and datasets as the Network Data Repository described
    previously.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'Data is generally provided in a `networkx` in one code line, using the following
    command:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Some graphs might have extra information, other than about edges. Extra information
    is included in the archive of the dataset as a separated file—for example, where
    some metadata of the nodes is provided and is related to the graph via the *id*
    node.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'Graphs can also be read directly using the SNAP library and its interface via
    Python. If you have a working version of SNAP on your local machine, you can easily
    read the data as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Keep in mind that at this point, you will have an instance of a `PNGraph` object
    of the SNAP library, and you can''t directly use `networkx` functionalities on
    this object. If you want to use some `networkx` functions, you first need to convert
    the `PNGraph` object to a `networkx` object. To make this process simpler, in
    the supplementary material for this book (available at [https://github.com/PacktPublishing/Graph-Machine-Learning](https://github.com/PacktPublishing/Graph-Machine-Learning)),
    we have written some functions that will allow you to seamlessly swap back and
    forth between `networkx` and SNAP, as illustrated in the following code snippet:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Open Graph Benchmark
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the most recent update (dated May 2020) in the graph benchmark landscape,
    and this repository is expected to gain increasing importance and support in the
    coming years. The **Open Graph Benchmark** (**OGB**) has been created to address
    one specific issue: current benchmarks are actually too small compared to real
    applications to be useful for **machine learning** (**ML**) advances. On one hand,
    some of the models developed on small datasets turn out to not be able to scale
    to large datasets, proving them unsuitable in real-world applications. On the
    other hand, large datasets also allow us to increase the capacity (complexity)
    of the models used in ML tasks and explore new algorithmic solutions (such as
    neural networks) that can benefit from a large sample size to be efficiently trained,
    allowing us to achieve very high performance. The datasets belong to diverse domains
    and they have been ranked on three different dataset sizes (small, medium, and
    large) where the small-size graphs, despite their name, already have more than
    100,000 nodes and/or more than 1 million edges. On the other hand, large graphs
    feature networks with more than 100 million nodes and more than 1 billion edges,
    facilitating the development of scalable models.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Beside the datasets, the OGB also provides, in a *Kaggle fashion*, an end-to-end
    ML pipeline that standardizes the data loading, experimental setup, and model
    evaluation. OGB creates a platform to compare and evaluate models against each
    other, publishing a *leaderboard* that allows tracking of the performance evolution
    and advancements on specific tasks of node, edge, and graph property prediction.
    For more details on the datasets and on the OGB project, please refer to [https://arxiv.org/pdf/2005.00687.pdf](https://arxiv.org/pdf/2005.00687.pdf).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with large graphs
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When approaching a use case or an analysis, it is very important to understand
    how large the data we focus on is or will be in the future, as the dimension of
    the datasets may very well impact both the technologies we use and the analysis
    that we can do. As already mentioned, some of the approaches that have been developed
    on small datasets hardly scale to real-world applications and larger datasets,
    making them useless in practice.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with (possibly) large graphs, it is crucial to understand potential
    bottlenecks and limitation of the tools, technologies, and/or algorithms we use,
    assessing which part of our application/analysis may not scale when increasing
    the number of nodes or edges. Even more importantly, it is crucial to structure
    a data-driven application, however simple or at early **proof of concept** (**POC**)
    stages, in a way that would allow its scaling out in the future when data/users
    would increase, without rewriting the whole application.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Creating a data-driven application that resorts to graphical representation/modeling
    is a challenging task that requires a design and implementation that is a lot
    more complicated than simply importing `networkx`. In particular, it is often
    useful to decouple the component that processes the graph—named **graph processing
    engine**—from the one that allows querying and traversing the graph—the **graph
    storage layer**. We will further discuss these concepts in [*Chapter 9*](B16069_09_Final_JM_ePub.xhtml#_idTextAnchor141),
    *Building a Data-Driven Draft-Powered Application*. Nevertheless, given the focus
    of the book on ML and analytical techniques, it makes sense to focus more on graph
    processing engines than on graph storage layers. We therefore find it useful to
    provide you already at this stage with some of the technologies that are used
    for graph processing engines to deal with large graphs, crucial when scaling out
    an application.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: In this respect, it is important to classify graph processing engines into two
    categories (that impact the tools/libraries/algorithms to be used), depending
    whether the graph can fit a *shared memory machine* or requires *distributed architectures*
    to be processed and analyzed.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is no absolute definition of large and small graphs, but it
    also depends on the chosen architecture. Nowadays, thanks to the vertical scaling
    of infrastructures, you can find servers with **random-access memory** (**RAM**)
    larger than 1 **terabyte** (**TB**) (usually called *fat nodes*), and with tens
    of thousands of **central processing units** (**CPUs**) for multithreading in
    most cloud-provider offerings, although these infrastructures might not be economically
    viable. Even without scaling out to such extreme architectures, graphs with millions
    of nodes and tens of millions of edges can nevertheless be easily handled in single
    servers with ~100 **gigabytes** (**GB**) of RAM and ~50 CPUs.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'Although `networkx` is a very popular, user-friendly, and intuitive library,
    when scaling out to such reasonably large graphs it may not be the best available
    choice. `networkx`, being natively written in pure Python, which is an interpreted
    language, can be substantially outperformed by other graph engines fully or partly
    written in more performant programming languages (such as C++ and Julia) and that
    make use of multithreading, such as the following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '**SNAP** ([http://snap.stanford.edu/](http://snap.stanford.edu/)), which we
    have already seen in the previous section, is a graph engine developed at Stanford
    and is written in C++ with available bindings in Python.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**igraph** ([https://igraph.org/](https://igraph.org/)) is a C library and
    features bindings in Python, R, and Mathematica.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**graph-tool** ([https://graph-tool.skewed.de/](https://graph-tool.skewed.de/)),
    despite being a Python module, has core algorithms and data-structures written
    in C++ and uses OpenMP parallelization to scale on multi-core architectures.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NetworKit** ([https://networkit.github.io/](https://networkit.github.io/))
    is also written in C++ with OpenMP boost for parallelization for its core functionalities,
    integrated in a Python module.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`networkx` functionalities in a more performant and robust library.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the preceding libraries are valid alternatives to `networkx` when achieving
    better performance becomes an issue. Improvements can be very substantial, with
    speed-ups varying from 30 to 300 times faster, with the best performance generally
    achieved by LightGraphs.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: In the forthcoming chapters, we will mostly focus on `networkx` in order to
    provide a consistent presentation and provide the user with basic concepts on
    network analysis. We want you to be aware that other options are available, as
    this becomes extremely relevant when pushing the edge from a performance standpoint.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we refreshed concepts such as graphs, nodes, and edges. We
    reviewed graph *representation* methods and explored how to *visualize* graphs.
    We also defined *properties* that are used to characterize networks, or parts
    of them.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: We went through a well-known Python library to deal with graphs, `networkx`,
    and learned how to use it to apply theoretical concepts in practice.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: We then ran examples and toy problems that are generally used to study the properties
    of networks, as well as benchmark performance and effectiveness of network algorithms.
    We also provided you with some useful links of repositories where network datasets
    can be found and downloaded, together with some tips on how to parse and process
    them.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go beyond defining notions of ML on graphs. We
    will learn how more advanced and latent properties can be automatically found
    by specific ML algorithms.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
