- en: '4'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: Creating a Chatbot with Natural Language
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自然语言创建聊天机器人
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够：
- en: Define the basics of chatbots and chatbot design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义聊天机器人和聊天机器人设计的基本概念
- en: Set up the Amazon Lex service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Amazon Lex服务
- en: Create a custom chatbot to look up different share prices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个自定义聊天机器人来查询不同的股价
- en: This chapter describes the designing of chatbot using Amazon Lex.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了使用Amazon Lex设计聊天机器人的过程。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引言
- en: In the last chapter, you learned how to extract and analyze common themes through
    topic modeling with **Amazon Comprehend**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了如何通过**Amazon Comprehend**的主题建模提取和分析常见主题。
- en: In this chapter, you will learn how to build a chatbot using **Amazon Lex**.
    First, we'll talk about how to design a chatbot. Then, we will dive into exploring
    the Amazon Lex service by creating a sample chatbot.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用**Amazon Lex**构建聊天机器人。首先，我们将讨论如何设计聊天机器人。然后，我们将通过创建一个示例聊天机器人来深入了解Amazon
    Lex服务。
- en: Next, we will create our own custom chatbot, which will query an for PIzza ordering. Finally,
    you will integrate, your chatbot with a text interface in order to interact with it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建自己的定制聊天机器人，用于查询披萨订购。最后，您将集成您的聊天机器人，以便通过文本界面与之交互。
- en: What is a Chatbot?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是聊天机器人？
- en: A **chatbot** is an application that simulates intelligent conversations using
    rules and an AI inference. When interacting with the chatbot, the goal is to be
    able to hold a conversation with the user to the extent required in order to resolve
    customer queries or suggest a way to move forward from them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**聊天机器人**是一个使用规则和人工智能推理模拟智能对话的应用程序。与聊天机器人互动时，目标是能够与用户进行对话，以达到解决客户查询或从他们那里提出前进方式的程度。'
- en: As in normal conversation, the means by which we interact with the Bot can be
    written text or speech. Often, the chatbots are integrated with messaging platforms,
    such as Slack, Facebook, Kik, WeChat, and so on. This can also be integrated with
    a custom web or mobile interface.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如正常对话一样，我们与机器人互动的方式可以是书面文字或语音。通常，聊天机器人会集成到消息平台中，如Slack、Facebook、Kik、微信等。这也可以集成到自定义的网页或移动界面中。
- en: It is easier, of course, to integrate within an existing messaging platform,
    since the user is likely to be familiar with the interface. Moreover, these platforms
    provide support to the chatbot developers with infrastructure and development
    tools.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在现有的消息平台上进行集成更容易，因为用户可能已经熟悉该界面。此外，这些平台为聊天机器人开发者提供基础设施和开发工具的支持。
- en: Some examples of chatbots include systems for ordering products, reporting,
    internal communication, and scheduling.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天机器人的例子包括产品订购系统、报告、内部沟通和调度。
- en: The Business Case for Chatbots
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聊天机器人的商业案例
- en: Traditionally, we used to interact with computers by means of input devices,
    such as keyboards and mice. Today, computational power and efficiency has progressed
    to the point where we can have a conversation with a computer almost as naturally
    as interacting with other people. These conversations seem more human-like, due
    to the ability of the computer to add contextual information and keep track of
    and remember the context for a few separate interactions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，我们通过输入设备，如键盘和鼠标与计算机互动。今天，计算能力和效率已经发展到我们可以几乎像与其他人互动一样自然地与计算机进行对话。这些对话由于计算机能够添加上下文信息，并跟踪和记住几次单独交互的上下文而显得更加人性化。
- en: It is no surprise, then, that the conversational interface is really catching
    on. One study by Gartner estimates that 30% of browsing done by users will turn
    out to be screen less in 2020\. This is a huge number, considering all of the
    interactions between humans and computers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对话界面真正流行开来并不令人惊讶。Gartner的一项研究估计，到2020年，用户进行的30%的浏览将是不带屏幕的。考虑到人类与计算机之间的所有互动，这是一个巨大的数字。
- en: Another study done by BI Intelligence found that the number of global monthly
    active users for the top four messaging apps surpassed those for the top four
    social networks in the first quarter of 2015 and shows no signs of slowing down.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: BI Intelligence进行的一项研究发现，截至2015年第一季度，全球顶级四款消息应用每月活跃用户数量超过了顶级四款社交网络的用户数量，并且没有放缓的迹象。
- en: 'Businesses cannot afford to ignore this trend, and are looking to reach users
    where they are found interacting (via text) the most: the messaging platforms
    such as Facebook, Skype, Slack, WhatsApp, and WeChat, and the list goes on and
    on. Messaging platforms make it easier for users to communicate, and chatbots
    make it easier for users to communicate what they want and to get it more quickly
    than interacting with other people.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 企业无法忽视这一趋势，他们正在寻找在用户互动（通过文本）最频繁的地方接触用户：如Facebook、Skype、Slack、WhatsApp和微信等即时通讯平台，名单还在不断延长。即时通讯平台使用户之间的沟通更加便捷，聊天机器人使用户能够更快地传达他们想要的信息，比与其他人互动更加高效。
- en: In this topic, you will learn about **Natural Language Understanding** **(NLU)**.
    Using this knowledge, you will first explore the AWS Lex service and build your
    first sample chatbot. As the next step, you will build a custom chatbot.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，你将了解**自然语言理解**（NLU）。使用这些知识，你将首先探索AWS Lex服务并构建你的第一个示例聊天机器人。作为下一步，你将构建一个自定义聊天机器人。
- en: What is Natural Language Understanding?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是自然语言理解？
- en: NLP is the general term for a set of technologies that deal with natural language.
    NLU is a focused subset of NLP that deals with actual conversational input.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 自然语言处理（NLP）是处理自然语言的一套技术的总称。自然语言理解（NLU）是NLP的一个专注于处理实际对话输入的子集。
- en: NLU is able to handle unstructured inputs and convert to a structured, machine
    understandable form. Words that the user enters are transformed into intents and
    entities, or Slots. The NLU chatbot is further able to infer intents and Slots
    from user input, which may be similar to – but not the same as – the examples
    it has been trained with.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: NLU能够处理非结构化输入并将其转换为结构化、机器可理解的格式。用户输入的词语被转换成意图和实体，或称为槽位。NLU聊天机器人还能够从用户输入中推断意图和槽位，这些可能与——但并不完全相同于——它所训练的示例。
- en: Core Concepts in a Nutshell
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心概念概述
- en: Before we can get started with building chatbots, you will need to understand
    some concepts first. We will now take a look at the technical meaning of the term
    chatbot and the names of the pieces which make up a chatbot and work together
    to deliver a conversational experience to the user.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建聊天机器人之前，你需要先了解一些概念。现在，我们将探讨“聊天机器人”这一术语的技术含义以及构成聊天机器人并共同为用户提供对话体验的各个组件的名称。
- en: '**Chatbot**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**聊天机器人**'
- en: A chatbot, also known as a `bot`, is a piece of software that can converse using
    natural language with the user. The goal is for the user to believe that they
    can interact freely and naturally with the bot, almost as if speaking with another
    person.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天机器人，也称为`bot`，是一种能够使用自然语言与用户进行对话的软件。目标是让用户相信他们可以自由自然地与聊天机器人互动，几乎就像与另一个人交谈一样。
- en: '**Utterances**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**话语**'
- en: 'Things that the user says to the bot are called **utterances**. The bot regards
    the utterances from the user as input, and is able to parse them into machine-recognizable
    formats. Some examples of utterances are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 用户对聊天机器人说的话被称为**话语**。聊天机器人将用户的话语视为输入，并能够将其解析为机器可识别的格式。以下是一些话语的示例：
- en: I'd like to see the dentist.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想去看牙医。
- en: Can you tell me what the weather is like today?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能告诉我今天的天气怎么样吗？
- en: '**Intent**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**意图**'
- en: An **intent** represents an action that the user wants to perform, based on
    the content of their utterances. The bot infers the intent and supports it based
    on its internal set of business rules or application flow, with the result of
    either a change in its internal state or an action being performed. These also
    typically result in a response being provided to the user as feedback or information.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**意图**代表用户根据其话语内容想要执行的动作。聊天机器人根据其内部业务规则或应用程序流程推断意图并支持它，结果可能是其内部状态的变化或执行一个动作。这些通常也会导致向用户提供反馈或信息的响应。'
- en: 'So, from the preceding utterance examples, a bot might infer intents such as
    the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从先前的对话示例中，一个聊天机器人可能会推断出以下意图：
- en: I'd like to see the dentist => SeeDentist
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想去看牙医 => SeeDentist
- en: Can you tell me what the weather is like today? => GetWeather
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能告诉我今天的天气怎么样吗？ => GetWeather
- en: Inferring intent is a large part of what an NLU platform such as Lex does behind
    the scenes. A number of training examples, in the form of sentences that the user
    might provide,are fed to the platform, and a probabilistic model is built from
    these examples. This means that, in practice, the platform should be able to infer
    the correct intent from input which is similar to, but not necessarily a part
    of, the examples that the system was trained on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 推断意图是Lex这样的NLU平台在幕后执行的重要部分。一些训练示例，以用户可能提供的句子形式，被输入到平台中，并从这些示例中构建一个概率模型。这意味着在实践中，平台应该能够从与系统训练的示例相似但不是其一部分的输入中推断出正确的意图。
- en: '**Prompts**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: When the bot requires more information from the user or is unclear about an
    Intent, it can ask the user follow-up questions, in order to collect more data.
    These are called **prompts**. Prompts typically fill in Slot values that are required,
    although your application logic may attempt to fill in values which are optional
    as well if you desire.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当机器人需要从用户那里获取更多信息或对意图不清楚时，它可以提出后续问题，以收集更多信息。这些被称为**提示**。提示通常用于填写必需的槽位值，尽管您的应用程序逻辑可能尝试填写可选的值，如果您希望的话。
- en: '**Slot**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**槽位**'
- en: A **Slot** is a piece of information, or parameter, that is associated with
    an intent. The information can be provided within the initial user request, and
    Lex will be able to parse out the information and correctly assign it to the corresponding
    Slot correctly. If this information is not provided as a part of the request,
    then the bot should be able to prompt the user for the information separately.
    Slots may be optional or required.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 槽位是与意图相关联的信息或参数。该信息可以包含在初始用户请求中，Lex将能够解析信息并将其正确分配给相应的槽位。如果此信息不是作为请求的一部分提供，那么机器人应该能够单独提示用户提供信息。槽位可以是可选的或必需的。
- en: 'The type of information represented by a **Slot** is known as the Slot type.
    There are a number of built-in Slot types within Lex that represent common types
    of information, such as city or state. The following are a few examples of common
    Slot types that are built into Lex:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**槽位**所表示的信息类型称为槽位类型。Lex中有许多内置槽位类型，代表常见的信息类型，如城市或州。以下是一些Lex内置的常见槽位类型的示例：'
- en: '![Figure 4.1: Table of Slot types built into Lex'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1：Lex 内置的槽类型表](img/IMG_29102018_171212_0.jpg)'
- en: '](img/IMG_29102018_171212_0.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**槽位**'
- en: 'Figure 4.1: Table of Slot types built into Lex'
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.1：Lex 内置的槽类型表
- en: Of course, this is just a very limited subset of examples. There are many more
    built-in types, as well as different types for different languages!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是示例的一个非常有限的子集。Lex中还有许多其他内置类型，以及针对不同语言的类型！
- en: Note
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 备注
- en: 'You can refer to the following link to get a full list of built-in intents
    and Slots: https://docs.aws.amazon.com/lex/latest/dg/howitworks-builtins.html'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下链接以获取内置意图和槽位的完整列表：https://docs.aws.amazon.com/lex/latest/dg/howitworks-builtins.html
- en: Most of the built-in intents and Slots are documented as part of the Alexa Skills
    Kit documentation, with some differences for Lex, which are documented at the
    preceding link. Make sure to keep the link bookmarked and refer to the page often,
    since Amazon keeps updating the service, and things may change.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数内置意图和槽位都作为Alexa技能套件文档的一部分进行记录，Lex有一些差异，这些差异在先前的链接中有记录。请确保将链接添加到书签并经常参考该页面，因为亚马逊不断更新服务，事情可能会发生变化。
- en: If the type of information that you would like your bot to handle is not represented
    by one of these built-in types, you can define your own, along with the actual
    values that the Slot is allowed to take. You will see how this works as part of
    our next  exercise.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望您的机器人处理的信息类型不是这些内置类型之一，您可以定义自己的类型，以及槽位允许的实际值。您将在我们接下来的练习中看到这是如何工作的。
- en: '**Fulfillment**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**履行**'
- en: Note that the bot will not be able to proceed to the next step until it fills
    in all of the required Slot values! Naturally, this does not apply to Slot values
    that are optional.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，机器人只有在填写了所有必需的槽位值后才能继续下一步操作！当然，这并不适用于可选的槽位值。
- en: 'When all of the required Slots for an intent have been filled, Slot is then
    ready for fulfillment. At this stage, the bot is ready to execute the business
    logic required to fulfill the intent. Business logic may be any of the following
    actions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个意图的所有必需槽位都已填写时，槽位就准备好履行了。在这个阶段，机器人准备好执行履行意图所需的企业逻辑。企业逻辑可以是以下任何一种操作：
- en: Change in internal state
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部状态的变化
- en: Running code internally
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部运行代码
- en: Calling an internal or external service, to get information from it
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个内部或外部服务，从中获取信息
- en: Calling an internal or external service to post information to it
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个内部或外部服务以将其信息发布到其中
- en: The fulfillment action can be performed with or without some feedback to the
    user, but as a matter of best practice, it is always better to err on the side
    of more feedback to the user, rather than less.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 完成操作可以带或不带一些用户反馈，但作为最佳实践，总是更好地偏向于提供更多反馈给用户，而不是更少。
- en: Setting Up with Amazon Lex
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Amazon Lex 设置
- en: Introduction
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简介
- en: For this exercise, we will be creating a sample chatbot, which is an option
    provided with **Amazon Lex**. The goal here is to understand the various components
    of the sample chatbot and relate them to the previous topic, where you learned
    about Natural Language Understanding components. After this exercise, you should
    be able to navigate the Lex user interface and easily create intents, Slots, and
    Slot types easily for your next exercise, where you will build a custom chatbot
    based on your own business logic.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个示例聊天机器人，这是**Amazon Lex**提供的一个选项。这里的目的是了解示例聊天机器人的各个组件，并将它们与之前学习到的自然语言理解组件相关联。完成这个练习后，您应该能够轻松地导航
    Lex 用户界面，并为您的下一个练习轻松创建意图、槽位和槽位类型，在下一个练习中，您将根据自己的业务逻辑构建自定义聊天机器人。
- en: 'Exercise 15: Creating a Sample Chatbot to Order Flowers'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 15：创建一个示例聊天机器人来订购鲜花
- en: 'In this exercise, we will create and test the sample chatbot as a means to
    gain familiarity with the **Amazon Lex** console interface. The following are
    the steps for completion for creating a sample chatbot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建并测试示例聊天机器人，以此作为熟悉**Amazon Lex**控制台界面的手段。以下是为创建示例聊天机器人完成所需的步骤：
- en: '![Figure 4.2: Sample chatbot interface'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2：示例聊天机器人界面]'
- en: '](img/image0021.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/image0021.jpg]'
- en: 'Figure 4.2: Sample chatbot interface'
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.2：示例聊天机器人界面
- en: Let's first navigate to the **Amazon Lex** main screen. You can click on the
    Lex service link from the main AWS console screen or navigate directly to https://console.aws.amazon.com/lex.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先导航到**Amazon Lex**主屏幕。您可以从主 AWS 控制台屏幕点击 Lex 服务链接或直接导航到 https://console.aws.amazon.com/lex。
- en: 'If this is your first time using Amazon Lex, you should see the following screen:![Figure
    4.3: Amazon Lex getting started screen'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这是您第一次使用 Amazon Lex，您应该看到以下屏幕：![图 4.3：Amazon Lex 入门屏幕]
- en: '](img/image0032.jpg)'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/image0032.jpg]'
- en: 'Figure 4.3: Amazon Lex Getting Started screen'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.3：Amazon Lex 入门屏幕
- en: You can click on the **Get Started** button in order to proceed.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以点击**开始**按钮以继续。
- en: Note
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'In case you have already built a bot previously, you will be shown a different
    screen, where you can click on the **Create** button, instead:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您之前已经创建了一个机器人，您将看到一个不同的屏幕，您可以在其中点击**创建**按钮，而不是：
- en: '![Figure 4.4: Bots create screen'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.4：创建屏幕]'
- en: '](img/image0041.jpg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/image0041.jpg]'
- en: 'Figure 4.4: Bots create screen'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.4：创建屏幕
- en: 'You will then be presented a list of options for creating bots. This shows
    two options: **CREATE YOUR OWN** and **TRY A SAMPLE**.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您将看到一个用于创建机器人的选项列表。这显示了两个选项：**创建自己的**和**尝试一个示例**。
- en: 'Now, choose the **OrderFlowers** option under the **TRY A SAMPLE** section:![Figure
    4.5: Selecting the Bot'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**尝试一个示例**部分下选择**OrderFlowers**选项：![图 4.5：选择机器人]
- en: '](img/image0052.jpg)'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/image0052.jpg]'
- en: 'Figure 4.5: Selecting the bot'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.5：选择机器人
- en: 'This will then present you with further options to be filled in. You can leave
    the bot name as the default, `OrderFlowers`, and select `COPPA` option. You can
    leave the `IAM` role option as is. It will create a role automatically for the
    sample bot:![Figure 4.6: IAM role and COPPA selection'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将为您提供进一步填写选项。您可以保留机器人名称为默认值，`OrderFlowers`，并选择`COPPA`选项。您可以将`IAM`角色选项保留原样。它将自动为示例机器人创建一个角色：![图
    4.6：IAM 角色和 COPPA 选择]
- en: '](img/image0061.jpg)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/image0061.jpg]'
- en: 'Figure 4.6: IAM role and COPPA selection'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.6：IAM 角色和 COPPA 选择
- en: Click on the **Create** button to bring up the next screen and proceed to the
    next step.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**按钮，进入下一个屏幕并继续下一步。
- en: '**Working with the Chatbot Editor**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用聊天机器人编辑器**'
- en: 'On the `Intents`, `Slots`, `Slot Types`, and `Sample utterances`. You will
    see that there is a single `OrderFlowers`:![Figure 4.7: Chatbot editor screen'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**意图**、**槽位**、**槽位类型**和**样本话语**上。您将看到只有一个`OrderFlowers`：![图 4.7：聊天机器人编辑器屏幕]
- en: '](img/Image_Lesson4_007.jpg)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Image_Lesson4_007.jpg]'
- en: 'Figure 4.7: Chatbot editor screen'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.7：聊天机器人编辑器屏幕
- en: 'The sample utterances that are entered correspond to this Intent:![Figure 4.8:
    Slots types screen'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Image_Lesson4_008.jpg)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.8: Slots types screen'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: There are also three Slots. Two of the Slots (`PickupDate` and `PickupTime`)
    take built-in types. The third one is a custom-defined Slot named `FlowerType`.
    Each Slot has a prompt associated with it, which is generated by the bot in order
    to get the information for the Slot.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is also a `Slot type` named `FlowerTypes`. These values are recognized
    for the `FlowerType` `Slot` when the user is prompted for the type of flower to be ordered:![Figure
    4.9: Slots types screen'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Image_Lesson4_009.jpg)'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.9: Slots types screen'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Click on the `FlowerTypes` link in order to bring up a dialog with the definitions
    of the Slot type and sample values. The following are the steps for selecting
    and editing the Slot type.![Figure 4.10: Selection of flowers types'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0082.jpg)'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.10: Selecting FlowerTypes'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 4.11: Edit Slot type'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/image0092.jpg)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.11: Edit Slot type'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can also click on the **Error Handling** link in the left area to show
    the prompts that the bot will show the user for clarification (**Clarification
    Prompts**) and the phrase used to terminate the interaction (**Hang-up phrase**)
    after the maximum number of retries has been attempted by the user:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.12: Error handling](img/image0101.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Error handling'
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Testing the Chatbot**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test the chatbot in the Test bot area on the right-hand side of the
    screen. You may have to click on an arrow icon in order to expand it, if it is
    not already open:![Figure 4.13: Test Bot screen'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0112.jpg)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.13: Test bot screen'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can have a complete interaction, as shown in the following screenshots:![Figure
    4.14: Chatbot interaction screen'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0121.jpg)'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.14: Chatbot interaction screen'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following screenshot shows the conversation with the bot:![Figure 4.15:
    Chatbot interaction screen'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0132.jpg)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.15: Chatbot interaction screen'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: When all the required `Slots` are filled, the `intent` is said to be ready for
    fulfillment. This means that all of the information required by the intent has
    been provided, and the application logic behind the chatbot can now handle the
    intent appropriately.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Intent can be returned to the calling application in the form of a `JSON` object
    or a `Lambda function` that has been implemented in the `AWS Lambda service.`
    This can be called at this point, with the `JSON` information as a parameter passed
    to it. You will see how this works later:![Figure 4.16: Summary view screen'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0141.jpg)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.16: Summary view screen'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: As for the results displayed in the Dialog State pane, the first one shows a
    text representation of the state of the chatbot. This is the summary view which
    displays information such as the recognized intent, the Slot types, and the values
    that are now available from the Lex NLU system.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Dialog State is `ReadyForFulfillment`, which signifies that the intent
    is ready for fulfillment, as shown in the preceding screenshot:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对话状态是 `ReadyForFulfillment`，这表示意图已准备好实现，如前一个屏幕截图所示：
- en: '![Figure 4.17: dialogState'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.17: dialogState]'
- en: '](img/image0152.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image0152.jpg)'
- en: 'Figure 4.17: DialogState'
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '图4.17: DialogState'
- en: In the detail view, the `JSON` object that would be returned to an application,
    which is interacting with the chatbot, is displayed. Using `JSON` is a structured
    way in which an application can retrieve information from and send information
    to the chatbot system in Lex. You can see that the information being provided
    here is the same as in the Summary view, except in the `JSON` format.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细视图中，将显示返回给与聊天机器人交互的应用程序的 `JSON` 对象。使用 `JSON` 是应用程序从Lex聊天机器人系统中检索信息和向其发送信息的一种结构化方式。您可以看到，这里提供的信息与摘要视图中的信息相同，只是格式为
    `JSON`。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Lex JSON structure for intents, as well as formats for other resources,
    such as Slots and Slot types, are documented here: https://docs.aws.amazon.com/lex/latest/dg/import-export-format.html.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 意图的Lex JSON结构以及其他资源（如槽位和槽位类型）的格式在此处有文档说明：https://docs.aws.amazon.com/lex/latest/dg/import-export-format.html。
- en: Creating a Custom Chatbot
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义聊天机器人
- en: 'In this topic, we will create a custom chatbot to get stock market quotes,
    using `GetQuote`. This signals to the bot that we had, for example to get a stock
    market quote for a given stock ticker symbol, will reside in a Slot named **ticker**.
    The bot will then look up the quote for that ticker symbol from a freely available
    financial API named **IEX**, and will return the information to the user via a
    conversational response:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将使用 `GetQuote` 创建一个自定义聊天机器人来获取股市报价。这表示，例如，为了获取特定股票代码的股市报价，将位于名为 **ticker**
    的槽位中。然后，聊天机器人将从名为 **IEX** 的免费金融API中查找该股票代码的报价，并通过对话式响应将信息返回给用户：
- en: Note
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A stock ticker symbol is the standard way in which stocks that are traded on
    an exchange, such as the New York Stock Exchange or NASDAQ are represented. A
    sequence of alphabetical letters represents the company's stock which is being traded.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 股票代码是表示在交易所（如纽约证券交易所或纳斯达克）交易的股票的标准方式。一系列字母代表正在交易的公司的股票。
- en: '![](img/image0161.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image0161.jpg)'
- en: 'Figure 4.18: The chatbot''s workflow'
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '图4.18: 聊天机器人工作流程'
- en: 'We can create a flowchart for this process, as shown in the following diagram.
    Let''s go over it in some more detail:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为这个过程创建一个流程图，如下所示。让我们更详细地了解一下：
- en: '![Figure 4.19: Flowchart of the chatbot’s workflow'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.19: 聊天机器人工作流程流程图]'
- en: '](img/image0172.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image0172.jpg)'
- en: 'Figure 4.19: Flowchart of the chatbot''s workflow'
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '图4.19: 聊天机器人工作流程流程图'
- en: '**Recognizing the Intent and Filling the Slot Value**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**识别意图和填充槽位值**'
- en: As the first step, the bot waits for the user's input, in order to recognize
    a valid intent. When it extracts the `GetQuote` intent as the intent from an utterance
    posted by the user, it will then try to fill the required Slots. In our case,
    we have only one Slot of the `StockTicker` type (which is a custom Slot type).
    The bot will issue a prompt, asking the user to provide the value of the Slot
    and parse the utterance in response, in order to fill the Slot value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，聊天机器人等待用户的输入，以识别一个有效的意图。当它从用户发布的语句中提取 `GetQuote` 意图作为意图时，它将尝试填充所需的槽位。在我们的例子中，我们只有一个
    `StockTicker` 类型的槽位（这是一个自定义槽位类型）。聊天机器人将发出提示，要求用户提供槽位的值，并解析用户的响应以填充槽位值。
- en: Valid Slots are those that the system recognizes. If the Slot value is not part
    of the list of allowed values, or if the system does not recognize what is entered
    for the Slot value, it is said to be `invalid`, or `not valid`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有效槽位是系统识别的槽位。如果槽位值不是允许值列表的一部分，或者如果系统无法识别输入的槽位值，则称其为 `invalid` 或 `not valid`。
- en: If the Slot value is not valid, it will go back to trying to fill the Slot (at
    least up to the number of times we have specified it should try before giving
    up and going back to the beginning). Once the bot has a Slot filled with a valid
    value, it then proceeds to fulfill the intent.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果槽位值无效，它将回退到尝试填充槽位（至少尝试到我们指定的次数，然后放弃并返回开始）。一旦聊天机器人填充了有效的槽位值，它将继续实现意图。
- en: '**Fulfilling the Intent with a Lambda Function**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Lambda函数实现意图**'
- en: While the default fulfilment action is to return the intent and Slot value to
    the user so that he/she can proceed to work with it within his/her own application,
    we will instead choose to set up a Lambda function on AWS, which can handle the
    intent and run the business logic required to fulfil it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当默认的执行操作是将意图和槽位值返回给用户，以便他/她可以在自己的应用程序中继续处理时，我们将选择在AWS上设置一个Lambda函数，该函数可以处理意图并运行满足它的业务逻辑。
- en: At this point, the bot process running within Lex proceeds to call the Lambda
    function, which we have written and specified for fulfilment.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，Lex中运行的聊天机器人进程将继续调用我们为执行而编写和指定的Lambda函数。
- en: '`Lambda_function.Lambda_handler`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lambda_function.Lambda_handler`'
- en: When Lex calls out to the function for fulfilment, it sends a `JSON` payload
    containing various pieces of information about the sender, as well as the intent
    and Slot value. The `Lambda_handler()` method parses the intent and Slot parameter
    value from the `JSON`, and then dispatches another function call to the method,
    which gets the market quote value that we're looking for from the external API.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当Lex调用执行函数时，它会发送一个包含关于发送者、意图和槽位值的各种信息的`JSON`有效负载。`Lambda_handler()`方法从`JSON`中解析意图和槽位参数值，然后调度另一个函数调用，从外部API获取我们所需的市值报价。
- en: Finally, the `Lambda function` also packages the response as another `JSON`
    string and returns it back to Lex. Lex parses the `JSON` response behind the scenes
    and presents the response message to the user.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Lambda函数`还将响应打包为另一个`JSON`字符串，并将其返回给Lex。Lex在后台解析`JSON`响应，并将响应消息呈现给用户。
- en: We will go through all of these elements in a lot more depth in the next two
    activities. In the first activity, we will set up the new chatbot, and in the
    second one, we will implement our Lambda handler function to return the actual
    value of the market price of the ticker symbol that the user asks the bot for
    back to him or her.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的两个活动中对这些元素进行更深入的探讨。在第一个活动中，我们将设置新的聊天机器人，在第二个活动中，我们将实现我们的Lambda处理函数，以便将用户请求的股票代码的实际市场价格返回给用户。
- en: A Bot Recognizing an Intent and Filling a Slot
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别意图并填充槽位的聊天机器人
- en: In the next exercise, you will create a custom chatbot which recognizes the
    intent, named `GetQuote,` to get a market price quote for a given ticker symbol.
    The bot will prompt the user for the value of the ticker symbol which the user
    is interested in, until the Slot is filled. You will also learn how to state the
    intent and fill the Slot in the same utterance. The chatbot can be tested via
    a conversational interface.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将创建一个自定义聊天机器人，该机器人可以识别名为`GetQuote`的意图，以获取给定股票代码的市场报价。机器人将提示用户输入他/她感兴趣的股票代码值，直到槽位被填满。你还将学习如何在同一句话中声明意图和填充槽位。聊天机器人可以通过对话界面进行测试。
- en: 'Exercise 16: Creating a Bot that will Recognize an Intent and Fill a Slot'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习16：创建一个可以识别意图并填充槽位的聊天机器人
- en: 'In this exercise, we will create and test an Amazon Lex-based bot with a custom
    `intent` and `Slot`. The following are the steps for creating a bot with a custom
    intent and Slot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建并测试一个基于Amazon Lex的聊天机器人，该机器人具有自定义的`意图`和`槽位`。以下是为创建具有自定义意图和槽位的聊天机器人的步骤：
- en: The first step is to navigate to the `Amazon Lex service` within the `AWS console`,
    by clicking on the appropriate links within the AWS console, or navigating to
    https://console.aws.amazon.com/lex.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是导航到AWS控制台中的`Amazon Lex服务`，可以通过点击AWS控制台中的适当链接或导航到https://console.aws.amazon.com/lex。
- en: 'The next step is to click on the **Get Started** button, in order to get to
    the **bot** creation screen:![Figure 4.20: Getting Started screen'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是点击**开始**按钮，以便进入**聊天机器人**创建屏幕：![图4.20：开始屏幕
- en: '](img/image0181.jpg)'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/image0181.jpg]'
- en: 'Figure 4.20: Getting Started screen'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.20：开始屏幕
- en: 'At this point, you can create a Custom bot by clicking on the **Custom bot**
    option button. This reveals the bot''s details, which can be filled out, as shown
    in the following screenshot:![Figure 4.21: Custom Bot option'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，你可以通过点击**自定义聊天机器人**选项按钮来创建一个自定义聊天机器人。这将显示聊天机器人的详细信息，可以填写，如下面的截图所示：![图4.21：自定义聊天机器人选项
- en: '](img/image0192.jpg)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/image0192.jpg]'
- en: 'Figure 4.21: Custom bot option'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.21：自定义聊天机器人选项
- en: The `MarketNanny`. The Output voice field is set to `None. This is only a text
    based application`. This is because we will be interacting with the bot only with
    text in this section, and not with voice just yet.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MarketNanny`。输出语音字段设置为`None`。这仅仅是一个基于文本的应用。这是因为我们将在本节中仅用文本与机器人交互，而暂时不使用语音。'
- en: The session timeout can be set to the default of 5 min. The IAM role field displays
    the name of the IAM role, which is automatically created by Lex for use by bot
    applications.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会话超时可以设置为默认的5分钟。IAM角色字段显示IAM角色的名称，Lex会自动创建该角色以供机器人应用程序使用。
- en: Finally, the `COPPA` field pertains to the **Children's Online Privacy Protection
    Act**, to which online applications must conform. Assuming that no children under
    13 are present in the class, you can click on **No**. If, however, you are a student
    under 13 or intend to have someone under 13 use your chatbot, then you should
    click on the **Yes** option, instead.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`COPPA`字段涉及**儿童在线隐私保护法案**，在线应用程序必须遵守。假设没有13岁以下的儿童在课堂上，您可以点击**否**。然而，如果您是13岁以下的在校学生或打算让13岁以下的人使用您的聊天机器人，那么您应该点击**是**选项。
- en: Note
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A law was passed in 1998 to protect the privacy of children under 13\. It states
    that online sites may not collect personal information from users younger than
    13 years old without parental consent, among other provisions. You can learn more
    about the COPPA act at https://www.ftc.gov/enforcement/rules/rulemaking-regulatory-reform-proceedings/childrens-online-privacy-protection-rule.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1998年通过了一项法律来保护13岁以下儿童的隐私。该法律指出，在线网站在未经父母同意的情况下，不得收集13岁以下用户的个人信息，以及其他规定。您可以在https://www.ftc.gov/enforcement/rules/rulemaking-regulatory-reform-proceedings/childrens-online-privacy-protection-rule了解更多关于COPPA法案的信息。
- en: Finally, clicking on the `Slot` with a custom `Slot type`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击带有自定义`Slot type`的`Slot`。
- en: 'Click on the **Create Intent** button to bring up an **Add** Intent pop-up
    dialog window:![Figure 4.22: MarketNanny Bot Editor'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建意图**按钮，将弹出一个**添加**意图的弹出对话框：![图4.22：MarketNanny机器人编辑器
- en: '](img/image0201.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/image0201.jpg)'
- en: 'Figure 4.22: MarketNanny bot Editor'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.22：MarketNanny机器人编辑器
- en: Conversely, if you already have an intent defined, you can create a new one
    by clicking on the **+** sign next to the Intents heading in the left-hand side
    column on the screen.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，如果您已经定义了一个意图，您可以通过点击屏幕左侧列中意图标题旁边的**+**号来创建一个新的意图。
- en: The Create `ZIP` file containing one or more `JSON` files with intents in the
    Lex format.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含一个或多个Lex格式的`JSON`文件和意图的`ZIP`文件。
- en: The search for existing intents allows you to reuse the intents that you may
    have defined or imported previously, as well as the built-in intents defined by
    **Amazon Lex**.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索现有意图允许您重用您可能之前定义或导入的意图，以及由**Amazon Lex**定义的内置意图。
- en: You should just click on the **Create** intent link, however, to get to the
    following dialog box.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您只需点击**创建**意图链接，即可进入以下对话框。
- en: 'In the `GetQuote`. The bot will recognize this intent when you let it know
    that you are interested in a market quote. Click on the **Add** button to complete
    this step:![Figure 4.23: Create intent screen'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GetQuote`中。当您告诉机器人您对市场报价感兴趣时，机器人将识别这个意图。点击**添加**按钮完成此步骤：![图4.23：创建意图屏幕
- en: '](img/image0212.jpg)'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/image0212.jpg)'
- en: 'Figure 4.23: Create intent screen'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.23：创建意图屏幕
- en: You should be back at the Editor screen at this point, and you should see the
    `GetQuote` intent in the left toolbar portion of the screen. The Editor screen
    also contains a number of fields that are used to define and customize the new intent.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，您应该回到编辑器屏幕，并且应该看到屏幕左侧工具栏部分的`GetQuote`意图。编辑器屏幕还包含一些用于定义和自定义新意图的字段。
- en: 'The first thing to do is fill in some Sample utterances to train the `GetQuote`
    intent:![Figure 4.24: Creation of the Intent'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首件事是填写一些示例语句来训练`GetQuote`意图：![图4.24：创建意图
- en: '](img/image0221.jpg)'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/image0221.jpg)'
- en: 'Figure 4.24: Creation of the Intent'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.24：创建意图
- en: 'After entering some sample utterances, you click on the **Build** button near
    the top of the page, in order to kick off the training process for the bot:![Figure
    4.25: Building the Bot'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入一些示例语句后，您点击页面顶部的**构建**按钮，以启动机器人的训练过程：![图4.25：构建机器人
- en: '](img/image0232.jpg)'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/image0232.jpg)'
- en: 'Figure 4.25: Building the bot'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.25：构建机器人
- en: 'There will be a follow-up dialog box with another **Build** button, which you
    should also click:![Figure 4.26: Build confirmation'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会出现一个带有另一个**构建**按钮的后续对话框，您也应该点击：![图4.26：构建确认
- en: '](img/image0241.jpg)'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/image0241.jpg)'
- en: 'Figure 4.26: Build confirmation'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'After this, you should wait until you see the successful build dialog, which
    might take a few seconds to a couple of minutes:![Figure 4.27: Bot build is successful'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0252.jpg)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.27: Bot build is successful'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You can test your new intent within the bot in the `Test bot` pane, in the upper
    right-hand corner of the screen.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: If the Test bot pane is not visible, you may have to click on an arrow button
    in order to expand it and make it visible.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type utterances into the pane to verify that the bot is able to recognize the
    correct intent from the utterances:![Figure 4.28: Test Bot'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image026.jpg)'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.28: Test bot'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You know that it has recognized the intent correctly when it returns the response:
    Intent `GetQuote` is `ReadyForFulfillment`. Feel free to experiment with different
    utterances, based on your sample utterances, in order to verify that the **NLU**
    engine is working correctly.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, your bot does not do much, other than try to recognize the `GetQuote`
    intent and flag that it is ready for fulfillment. This is because we have not
    added any `Slots` to the `intent`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '**Slot Addition**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Your next step will be to add a Slot, along with a custom Slot type for the
    Slot:![Figure 4.29: Adding a Slot'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0273.jpg)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.29: Adding a Slot'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Add a `Slot type`. This can be done by pressing the `JSON` structure. However,
    before, we will click on the `new Slot` type:![Figure 4.30: Create Slot type](img/image0281.jpg)'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.30: Creating Slot type'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: In the `Description` field and leave the `Expand Values`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the `StockTicker` Slot type. You can add some of your own, as well, if
    you wish:![Figure 4.31: Adding a Slot type](img/image0292.jpg)'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.31: Adding a Slot type'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Finally, click on the **Add** Slot to intent button, in order to add the Slot
    type to the intent, and close the dialog.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could have also clicked on the **Save** Slot type button and added the Slot
    to the intent in a separate step, but using the button is the shortcut to accomplishing
    both actions in a single step.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you close the dialog box, you will find that Lex has added a new Slot entry,
    as well, under the Slots section. It is helpfully prefilled with the `StockTicker`
    Slot type, and you should change the name of the Slot to ticker, under the **Name**
    field for the entry.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the wheel under the **Prompt** field to expand it to a new dialog
    box:![Figure 4.32: Editor dialog box](img/image0301.jpg)'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.32: Editor dialog box'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: The prompts editor dialog box (named ticker Prompts) allows entry of prompts
    for the `Slot`, which the bot will use to store the user `inputs` and corresponding
    sample `utterances` that the user would typically provide to the bot while the
    bot is trying to elicit the information from the user with the prompts.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The placement of the Slot value within the corresponding utterances for the
    Slots is denoted by curly braces `{}` and the name of the Slot within the braces.
    In this case, since the Slot is named ticker, it is denoted by `{ticker}` within
    the sample utterances.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 槽位值在相应话语中的位置由花括号 `{}` 表示，花括号内的槽位名称。在这种情况下，由于槽位被命名为ticker，因此在样本话语中用 `{ticker}`
    表示。
- en: Fill in the prompts (a single prompt is fine – if you add more prompts, the
    bot will use them randomly, for variety) in the Prompts section.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示部分填写提示（一个提示就足够了——如果您添加更多提示，机器人将随机使用它们，以增加多样性）。
- en: Then, add some `utterances` to the Corresponding utterances section, denoting
    the placement of the Slot value, using the placeholder token `{ticker}` in each
    sample statement.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在相应的话语部分添加一些`话语`，表示槽位值的放置，在每个样本语句中使用占位符令牌 `{ticker}`。
- en: 'Leave the Maximum number of retries field as the default value of two. This means
    that it will try to get the value for the Slot twice before signaling an `error`:![Figure
    4.33: Ticker prompt screen](img/image0312.jpg)'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最大重试次数字段保留为默认值两个。这意味着它将尝试获取槽位的值两次，然后才会发出一个`错误`信号：![图4.33：股票提示屏幕](img/image0312.jpg)
- en: 'Figure 4.33: Ticker prompt screen'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.33：股票提示屏幕
- en: Finally, click on the **Save** button to save the Slot prompts and the corresponding
    utterances definitions.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**保存**按钮以保存槽位提示和相应的话语定义。
- en: 'Finally, click on the **Save** Intent button at the bottom of the screen, then
    the **Build** button at the top of the screen, in order to kick off the training
    process with the new Slot and Slot type that we have defined, and wait for the completion
    dialog to display when the training is done:![Figure 4.34: Saving the Intent](img/image0321.jpg)'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击屏幕底部的**保存**意图按钮，然后点击屏幕顶部的**构建**按钮，以便启动使用我们已定义的新槽位和槽位类型的训练过程，并在训练完成后等待完成对话框显示：![图4.34：保存意图](img/image0321.jpg)
- en: 'Figure 4.34: Saving the Intent'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.34：保存意图
- en: 'Your updated intent is now ready to test in the **Test bot** pane:![Figure
    4.35: Updated intent test bot](img/image0332.jpg)'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您更新后的意图现在可以在**测试机器人**面板中测试：![图4.35：更新后的意图测试机器人](img/image0332.jpg)
- en: 'Figure 4.35: Updated intent test bot'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.35：更新后的意图测试机器人
- en: 'At the end of the bot flow, when all of the information it requires is filled,
    it returns the intent in the same format as before. However, it follows this response
    line with another line, containing the name and value of the Slot parameter:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在机器人流程结束时，当所有所需的信息都已填写完毕，它将以之前相同的格式返回意图。然而，它会在这一响应行之后跟随另一行，包含槽位参数的名称和值：
- en: '[PRE0]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This indicates that the ticker Slot has been filled with the value `GOOG`. So,
    that's great; our intent with Slot is working!
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这表明股票槽位已被填充了值为`GOOG`。所以，太好了；我们的槽位意图正在起作用！
- en: 'While you''re having fun playing around with the bot to verify that the intent
    and Slot are working as they should, why not try something a little bit different:
    enter some utterances that are not a part of the sample utterances that you previously
    entered to train the bot.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您在玩机器人以验证意图和槽位是否按预期工作的时候，为什么不尝试点不同的事情：输入一些之前没有用于训练机器人的样本话语。
- en: 'Type **Can I get a market quote?** as your initial utterance, and see if the
    bot can recognize the intent. Bear in mind that the sentence, though similar to
    the sample utterances, is not one of those utterances:![Figure 4.36: Test bot
    screen](img/image0341.jpg)'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的初始话语输入为**我能得到一个市场报价吗？**，并查看机器人是否能识别意图。请注意，尽管这句话与样本话语相似，但它并不是那些话语之一：![图4.36：测试机器人屏幕](img/image0341.jpg)
- en: 'Figure 4.36: Test bot screen'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.36：测试机器人屏幕
- en: As you can see from the testing shown in the preceding screenshot, not only
    does Lex recognize the correct intent from an utterance it has not been trained
    on, but it also recognizes a new symbol which it has not seen before (ADP) correctly
    as the value for the ticker Slot.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，Lex不仅能够从它未训练过的话语中识别出正确的意图，而且还能正确地将它之前未见过的符号（ADP）识别为股票槽位的值。
- en: 'Now, let''s try a conversational form of a corresponding utterance for the
    Slot prompt by inserting a random interjection as a part of the sentence, again
    using a new ticker symbol (**VZ**) that the bot has not previously trained on.
    Again, it is correctly processed and recognized:![Figure 4.37: Test bot screen](img/image0352.jpg)'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过在句子中插入一个随机插入语作为句子的一部分来尝试槽位提示的对话形式，再次使用一个机器人之前未训练过的新股票符号（**VZ**）。同样，它被正确处理和识别：![图4.37：测试机器人屏幕](img/image0352.jpg)
- en: 'Figure 4.37: Test bot screen'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.37：测试机器人屏幕
- en: Clearly, there is quite a bit of flexibility possible between training and real-world
    examples of conversational input with an NLU engine.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显然，在训练和现实世界的对话输入示例之间，使用NLU引擎有很大的灵活性。
- en: Natural Language Understanding Engine
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自然语言理解引擎
- en: NLU demonstrates the advantage of using an NLU engine that has been trained
    on a huge set of conversational sentences and has formed a large inference model.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: NLU展示了使用在大量对话句子上训练并形成大型推理模型的NLU引擎的优势。
- en: It is able to connect sentences that are not the same as the ones it has specifically
    been trained on. In fact, they can be significantly different, but the model is
    large enough to infer that the semantic meanings are similar.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 它能够连接与它专门训练的句子不同的句子。实际上，它们可以非常不同，但模型足够大，可以推断出语义含义是相似的。
- en: 'There is one more trick that you can use to make it easier for the user to
    interact with your bot. You can fill the Slot value in the same utterance as the
    one which establishes intent. This can be accomplished by simply including the
    Slot placeholder token (`{ticker},` in this case) in your sample utterances:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用一个技巧来让用户更容易与你的机器人互动。你可以在建立意图的同一句话中填写槽位值。这可以通过简单地在你提供的示例语句中包含槽位占位符令牌（在这种情况下为`{ticker},`）来实现：
- en: 'Add a new sample utterance to your `GetQuote` intent, as follows:![Figure 4.38:
    GetQuote screen](img/image0361.jpg)'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的示例语句添加到`GetQuote`意图中，如下所示：![图4.38：GetQuote屏幕](img/image0361.jpg)
- en: 'Figure 4.38: GetQuote screen'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.38：GetQuote屏幕
- en: 'The **ticker** placeholder token denotes that that Slot may be filled directly
    within the initial utterance, and, in that case, a prompt doesn''t need to be generated:![Figure
    4.39: Build screen for the bot](img/image0371.jpg)'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ticker**占位符令牌表示该槽位可以直接在初始语句中填写，在这种情况下，不需要生成提示：![图4.39：机器人的构建屏幕](img/image0371.jpg)'
- en: 'Figure 4.39: Build screen for the bot'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.39：机器人的构建屏幕
- en: 'Click on the **Build** buttons to train your updated intent as before, and
    then test it in the Test bot pane, as follows:![Figure 4.40: Test bot screen](img/image038.jpg)'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**构建**按钮，像以前一样训练你的更新意图，然后在测试机器人面板中测试它，如下所示：![图4.40：测试机器人屏幕](img/image038.jpg)
- en: 'Figure 4.40: Test bot screen'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.40：测试机器人屏幕
- en: You can see that the intent is ready for fulfillment and that the Slot value
    is filled appropriately, in a single step.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到意图已经准备好执行，并且槽位值已经适当地填写，只需一个步骤。
- en: We have now gone through the process of defining a custom chatbot, complete
    with a custom intent, Slot type, and Slot, within Amazon Lex. Furthermore, we
    have trained and tested the bot to verify that it is able to classify the correct
    intent and correctly infer the Slot values from conversational input, to a high
    degree of accuracy. Finally, we added a shortcut method to fill in the Slot value
    directly in the initial utterance, by inserting the placeholder token for the
    Slot value in the sample utterance to train the NLU engine behind Lex.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了在Amazon Lex中定义自定义聊天机器人的过程，包括自定义意图、槽位类型和槽位。此外，我们还训练并测试了机器人，以验证它能够以高精度分类正确的意图并从对话输入中正确推断槽位值。最后，我们添加了一种快捷方法，通过在示例语句中插入槽位值的占位符令牌，直接在初始语句中填写槽位值，以训练Lex背后的NLU引擎。
- en: Lambda Function – Implementation of Business Logic
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda函数 – 业务逻辑实现
- en: You can create AWS Lambda functions, so that you can run your code for your
    Amazon Lex bot. You can recongnize Lambda functions to boot up and validating
    the fulfillment, in your intent configuration. Without a Lambda function, your
    bot returns the intent information to the client application for fulfillment.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建AWS Lambda函数，以便运行你的Amazon Lex机器人的代码。你可以在意图配置中识别Lambda函数以启动和验证执行，如果没有Lambda函数，你的机器人将返回意图信息给客户端应用程序以执行。
- en: In the next exercise, you will learn how to implement the business logic behind
    the bot as a Lambda function in AWS and call a real-world REST API to get information
    to return to the user from an external service.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将学习如何将聊天机器人背后的业务逻辑作为 AWS 中的 Lambda 函数实现，并调用真实世界的 REST API 从外部服务获取信息返回给用户。
- en: 'Exercise 17: Creating a Lambda Function to Handle Chatbot Fulfillment'
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 17：创建一个 Lambda 函数来处理聊天机器人满足
- en: 'In this exercise, we will handle chatbot fulfillment business logic with a
    `Lambda function` that is created and deployed on AWS. In the last exercise, we
    created a chatbot with a `GetQuote` intent and ticker Slot. In this exercise,
    we will implement the fulfillment business logic. The following are the steps
    for implementing business logic:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用在 AWS 上创建和部署的 `Lambda 函数`来处理聊天机器人满足业务逻辑。在上一个练习中，我们创建了一个具有 `GetQuote`
    意图和股票槽的聊天机器人。在这个练习中，我们将实现满足业务逻辑。以下是实现业务逻辑的步骤：
- en: 'Navigate to the AWS Lambda screen via the AWS Console, or by navigating directly
    to: https://console.aws.amazon.com/Lambda.'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 AWS 控制台导航到 AWS Lambda 屏幕，或者直接导航到：https://console.aws.amazon.com/Lambda.
- en: 'If you have never used Lambda before, you should be presented with a Welcome
    screen:![Figure 4.41: AWS Lambda start up screen'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你之前从未使用过 Lambda，你应该会看到一个欢迎屏幕：![图 4.41：AWS Lambda 启动屏幕
- en: '](img/image0391.jpg)'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.39：角色选择屏幕](img/image0391.jpg)'
- en: 'Figure 4.41: AWS Lambda start up screen'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.41：AWS Lambda 启动屏幕
- en: Click on the **Create** a function button, in order to get started.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**函数按钮，开始操作。
- en: 'Select the **Author from scratch** option on the next page:![Figure 4.42: Selecting
    an author'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页上选择**从头开始创建作者**选项：![图 4.42：选择作者
- en: '](img/image040.jpg)'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.40：角色选择屏幕](img/image040.jpg)'
- en: 'Figure 4.42: Selecting an author'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.42：选择作者
- en: 'For the runtime, choose `Python 3.6` from the drop-down menu as you will be
    implementing the handler in the Python language for this exercise. In the Name
    field, fill in `marketNannyHandler`:![Figure 4.43: Filling in the values'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于运行时，从下拉菜单中选择 `Python 3.6`，因为你将在这个练习中使用 Python 语言实现处理程序。在名称字段中，填写 `marketNannyHandler`：![图
    4.43：填写值
- en: '](img/image0411.jpg)'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.41：填写值](img/image0411.jpg)'
- en: 'Figure 4.43: Filling in the values'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.43：填写值
- en: 'For the Role field, choose **Create** new role from template(s) from the drop-down
    menu:![Figure 4.44: Role selection screen](img/image042.jpg)'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于角色字段，从下拉菜单中选择**创建**新角色从模板：![图 4.44：角色选择屏幕](img/image042.jpg)
- en: 'Figure 4.44: Role selection screen'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.44：角色选择屏幕
- en: 'Enter the name `marketNannyProcessorRole` in the Role name field. Then, click
    on the **Create function** button to create the Lambda function in AWS. You should
    see a confirmation screen, as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色名称字段中输入名称 `marketNannyProcessorRole`。然后，点击**创建函数**按钮以在 AWS 中创建 Lambda 函数。你应该看到一个确认屏幕，如下所示：
- en: '![Figure 4.45: Confirmation screen'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.45：确认屏幕'
- en: '](img/image0431.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.43：填写值](img/image0431.jpg)'
- en: 'Figure 4.45: Confirmation screen'
  id: totrans-266
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.45：确认屏幕
- en: Implementing the Lambda Function
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现Lambda函数
- en: 'Here, you will use the Lambda Function editor entirely in-line, which means
    that you can enter and modify the code directly, without having to upload any
    files to AWS. The code that you enter will be executed when the Lambda function
    is invoked:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将完全在行内使用 Lambda 函数编辑器，这意味着你可以直接输入和修改代码，而无需将任何文件上传到 AWS。你输入的代码将在 Lambda
    函数被调用时执行：
- en: '![Figure 4.46: Function code screen](img/image044.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.46：函数代码屏幕](img/image044.jpg)'
- en: 'Figure 4.46: Function code screen'
  id: totrans-270
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.46：函数代码屏幕
- en: First, let's look at the structure of the Lambda function.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 Lambda 函数的结构。
- en: 'When you created the function named `marketNannyHandler`, AWS created a folder
    with the same name, with a Python file named `Lambda_function.py` within the folder.
    This file contains a stub for the `Lambda_handler` function, which is the entry
    point of our Lambda function. The entry point takes two parameters as arguments:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建了名为 `marketNannyHandler` 的函数时，AWS 创建了一个具有相同名称的文件夹，并在文件夹中包含一个名为 `Lambda_function.py`
    的 Python 文件。此文件包含 `Lambda_handler` 函数的占位符，它是我们 Lambda 函数的入口点。入口点接受两个参数作为参数：
- en: The event argument provides the value of the payload that is sent to the function
    from the calling process. It typically takes the form of a Python `dict` type,
    although it could also be one of `list`, `str`, `int`, `float`, or `NoneType`.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件参数提供了从调用进程发送到函数的有效负载值。它通常采用 Python `dict` 类型的形式，但也可能是 `list`、`str`、`int`、`float`
    或 `NoneType` 之一。
- en: The context argument is of the type `LambdaContext` and contains runtime information.
    You will not be using this parameter for this exercise.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文参数是`LambdaContext`类型，包含运行时信息。在这个练习中，您将不会使用此参数。
- en: The return value of the function can be of any type that is serializable by
    `JSON`. This value gets returned to the calling application after serializing.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值可以是任何可以被`JSON`序列化的类型。此值在序列化后返回给调用应用程序。
- en: Input Parameter Structure
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入参数结构
- en: 'Now, let''s take a closer look at the structure of the event argument, which
    gets passed to the `Lambda_handler function`. If we are asking for a market quote
    with the ticker value `GOOG`, the `JSON` value of the intent section within the
    parameter will look as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看事件参数的结构，该参数被传递给`Lambda_handler`函数。如果我们请求带有股票值`GOOG`的市场报价，参数中意图部分的`JSON`值将如下所示：
- en: '[PRE1]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The relevant values which we are interested in for processing are `name` and
    the single `ticker` value within the `Slots` section under `currentIntent`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的相关值，用于处理，是`currentIntent`部分下的`Slots`中的`name`和单个`ticker`值。
- en: 'Since our `JSON` input gets converted into a Python dictionary, we can obtain
    these values within the Lambda function simply, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`JSON`输入被转换为Python字典，我们可以在Lambda函数中简单地获取这些值，如下所示：
- en: '[PRE2]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Implementing the High-Level Handler Function
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现高级处理函数
- en: 'The first step in implementing our handler is identifying the intent name and
    calling the corresponding function that implements it. This code looks as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 实现我们的处理器的第一步是识别意图名称并调用实现它的相应函数。此代码如下所示：
- en: '[PRE3]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is complete enough to actually be tested against your chatbot at this point,
    if you so desire, but let's press on with the implementation.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这已经足够用于实际测试您的聊天机器人，如果您愿意的话，但让我们继续进行实现。
- en: Implementing the Function to Retrieve the Market Quote
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现获取市场报价的函数
- en: 'The next step will be to implement the `get_quote` function, which does the
    work of actually getting the market quote information and returning it to the
    calling handler function:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是实现`get_quote`函数，该函数负责获取市场报价信息并将其返回给调用处理函数：
- en: '[PRE4]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that we have named the parameter as request, so the event `object` that
    we send the function to is referred to as a request within this function. It contains
    the same value and structure, just renamed. Therefore, we can get the value of
    the ticker Slot, as mentioned previously, by getting the value of the item with
    the `ticker` key under by using the following code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已将参数命名为request，因此我们发送给函数的事件`object`在此函数中被称为request。它包含相同的值和结构，只是重命名了。因此，我们可以通过获取具有`ticker`键的项的值来获取之前提到的股票槽位值，如下所示：
- en: '[PRE5]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We then call the `call_quote_api()` function to retrieve the value of the market
    quote for the value of the ticker item. We haven't implemented `call_quote_api()`
    yet, so let's do this next.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后调用`call_quote_api()`函数来获取股票条目价值的行情报价。我们尚未实现`call_quote_api()`函数，所以让我们接下来完成这个任务。
- en: 'We will implement the `call_quote_api` function, as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现`call_quote_api`函数，如下所示：
- en: '[PRE6]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Where ticker is the value of the ticker parameter (in this specific example,
    it would be `GOOG`). We use the IEX API, which provides a static endpoint on the
    internet at https://api.iextrading.com, to retrieve a delayed quote, using the
    1.0 version of their REST API.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，股票值是股票参数的值（在这个特定例子中，它将是`GOOG`）。我们使用IEX API，该API在互联网上提供了一个静态端点，即https://api.iextrading.com，以获取延迟报价，使用他们REST
    API的1.0版本。
- en: Since it is implemented as a simple `GET` request, with the ticker parameter
    embedded within the `URL`, and no other special header values such as the API
    key or user information, we can simply use the built-in `urlopen` method in the
    `urllib.request` module (which we will have to remember to import) to receive
    a response from the URL with the ticker embedded within it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它被实现为一个简单的`GET`请求，股票参数嵌入在`URL`中，没有其他特殊头信息，如API密钥或用户信息，我们可以简单地使用`urllib.request`模块中的内置`urlopen`方法（我们将必须记住导入它）来接收包含嵌入股票的URL的响应。
- en: Since the response is also in the `JSON` format, we need to import the `json
    module` and load the response using the `json.load function`. The only field we
    are interested in within the response is `delayedPrice`, so we return that as
    the return value from our function.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于响应也是 `JSON` 格式，我们需要导入 `json 模块` 并使用 `json.load 函数` 加载响应。我们感兴趣的唯一字段是 `delayedPrice`，因此我们将它作为函数的返回值。
- en: Returning the Information to the Calling App (The Chatbot)
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将信息返回给调用应用（聊天机器人）
- en: 'Now that we have the market quote value, we can return it to our calling application,
    which is the chatbot that we implemented. We have to do a couple of small things,
    however, to return this value. First, we need to format it as a conversational
    response, as in the following string:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了市场报价值，我们可以将其返回到我们的调用应用，即我们实现的聊天机器人。然而，我们需要做一些小事情来返回这个值。首先，我们需要将其格式化为对话响应，如下面的字符串所示：
- en: '[PRE7]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This should let the chatbot display the following message:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该让聊天机器人显示以下消息：
- en: '[PRE8]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There is one final step, which is to construct an `JSON` return format, containing
    our message and a couple of other items of information. We will use the helper
    function close to do this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是构建一个包含我们的消息和其他一些信息的 `JSON` 返回格式。我们将使用 helper 函数 close 来完成这项工作：
- en: '[PRE9]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our close function takes a single parameter, which is the string that we wish
    to return to the chatbot (in this case, this is the value of the message variable).
    It generates a `JSON` wrapper around the content, which conforms to the structure,
    which our Lex-based bot is expecting and from which it can extract the content
    and deliver it to the user. The structure of the wrapper is not important at this
    stage, but if you are curious, you can look at the implementation of the close
    function.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 close 函数接受一个参数，即我们希望返回给聊天机器人的字符串（在这种情况下，这是消息变量的值）。它生成一个 `JSON` 包装器，该包装器符合我们的
    Lex 机器人期望的结构，并且可以从其中提取内容并将其交付给用户。包装器的结构在此阶段并不重要，但如果您好奇，可以查看 close 函数的实现。
- en: Connecting to the Chatbot
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到聊天机器人
- en: 'At this point, the only task remaining is to connect the Lambda function to
    the chatbot and test it:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，唯一剩下的任务是将 Lambda 函数连接到聊天机器人并测试它：
- en: 'To do so navigate back to the Amazon Lex dashboard and select the `MarketNanny` bot:![Figure
    4.47: Connecting to the bot ](img/image0451.jpg)'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，请返回到 Amazon Lex 控制台并选择 `MarketNanny` 机器人：![图 4.47：连接到机器人](img/image0451.jpg)
- en: 'Figure 4.47: Connecting to the bot'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.47：连接到机器人
- en: 'Then, scroll down to the Fulfillment section and select the AWS Lambda function
    option. Next, select the `marketNannyHandler` function from the Lambda function
    drop-down menu and leave Version or alias as the default value of **Latest**:![Figure
    4.48: Confirmation prompt](img/image046.jpg)'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向下滚动到满足部分并选择 AWS Lambda 函数选项。接下来，从 Lambda 函数下拉菜单中选择 `marketNannyHandler`
    函数，并将版本或别名保留为默认值 **最新**：![图 4.48：确认提示](img/image046.jpg)
- en: 'Figure 4.48: Confirmation prompt'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.48：确认提示
- en: 'Rebuild the intent by clicking on the **Build** buttons, and test the chatbot
    together with the Lambda handler in the Test Chatbot pane:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **构建** 按钮重建意图，并在测试聊天机器人面板中与 Lambda 处理器一起测试聊天机器人：
- en: '![Figure 4.49: Chatbot updated](img/image0471.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.49：聊天机器人更新](img/image0471.jpg)'
- en: 'Figure 4.49: Chatbot updated'
  id: totrans-313
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.49：聊天机器人更新
- en: 'The following screenshot shows the interaction with bot for knowing the current
    price of AAPL:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了与机器人交互以了解 AAPL 当前价格的过程：
- en: '![Figure 4.50: Chatbot updated](img/image048.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.50：聊天机器人更新](img/image048.jpg)'
- en: 'Figure 4.50: Chatbot updated'
  id: totrans-316
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.50：聊天机器人更新
- en: 'Activity 5: Creating a Custom Bot and Configuring the Bot'
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 5：创建自定义机器人和配置机器人
- en: 'In this activity, we will create a custom bot for `PizzaOrdering`. A bot performs
    the automated task of ordering a pizza. An Amazon Lex bot is powered by **Automatic
    Speech Recognition** (**ASR**) and **Natural Language Understanding** (**NLU**)
    capabilities, the same technology that powers **Amazon Alexa**. For this, we will
    consider the following example: suppose that a user wants to order a pizza; a
    user might say, **Can I order a pizza, please?** or, **I want to order a pizza**.
    You can configure the intent so that Amazon Lex simply returns the information
    back to the client application, to perform the necessary fulfillment. To ensure
    that it happens correctly, you will need to navigate to the Amazon Lex services
    to create the custom bot:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将为`PizzaOrdering`创建一个定制机器人。机器人执行自动订购披萨的任务。一个Amazon Lex机器人由**自动语音识别**（**ASR**）和**自然语言理解**（**NLU**）功能驱动，这些功能与**Amazon
    Alexa**所使用的技术相同。为此，我们将考虑以下示例：假设用户想要订购披萨；用户可能会说，“**我可以订购披萨吗，请？**”或者，“**我想订购披萨**”。你可以配置意图，以便Amazon
    Lex将信息简单地返回给客户端应用程序，以执行必要的履行。为确保其正确执行，你需要导航到Amazon Lex服务以创建定制机器人：
- en: Create a custom bot for `Pizza Ordering`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`比萨订购`创建一个定制机器人。
- en: Create an Intent.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个意图。
- en: Create a Slot type.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个槽类型。
- en: Configure the Intent.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置意图。
- en: Configure the bot.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置机器人。
- en: Note
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: To refer to the detailed steps, go to the *Appendix A* at the end of this book
    on Page no. 217
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要查看详细步骤，请参阅本书末尾的*附录A*，在第217页
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the basic chatbots and chatbot design. You
    also learned how to set up the Amazon Lex services, and how to create a sample
    chatbot. Next, we looked at the Chatbot workflow. We then looked upon the flowchart
    of a Chatbot's workflow. Finally, we dove into creating a custom chatbot that
    shows share prices.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了基本聊天机器人和聊天机器人设计。你还学习了如何设置Amazon Lex服务，以及如何创建一个示例聊天机器人。接下来，我们探讨了聊天机器人的工作流程。然后，我们查看了一个聊天机器人工作流程的流程图。最后，我们深入探讨了创建一个显示股票价格的定制聊天机器人。
- en: In the next chapter, we will look at how to use speech with chatbots.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将语音与聊天机器人结合使用。
