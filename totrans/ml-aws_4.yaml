- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Chatbot with Natural Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the basics of chatbots and chatbot design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the Amazon Lex service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a custom chatbot to look up different share prices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter describes the designing of chatbot using Amazon Lex.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last chapter, you learned how to extract and analyze common themes through
    topic modeling with **Amazon Comprehend**.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to build a chatbot using **Amazon Lex**.
    First, we'll talk about how to design a chatbot. Then, we will dive into exploring
    the Amazon Lex service by creating a sample chatbot.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create our own custom chatbot, which will query an for PIzza ordering. Finally,
    you will integrate, your chatbot with a text interface in order to interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Chatbot?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **chatbot** is an application that simulates intelligent conversations using
    rules and an AI inference. When interacting with the chatbot, the goal is to be
    able to hold a conversation with the user to the extent required in order to resolve
    customer queries or suggest a way to move forward from them.
  prefs: []
  type: TYPE_NORMAL
- en: As in normal conversation, the means by which we interact with the Bot can be
    written text or speech. Often, the chatbots are integrated with messaging platforms,
    such as Slack, Facebook, Kik, WeChat, and so on. This can also be integrated with
    a custom web or mobile interface.
  prefs: []
  type: TYPE_NORMAL
- en: It is easier, of course, to integrate within an existing messaging platform,
    since the user is likely to be familiar with the interface. Moreover, these platforms
    provide support to the chatbot developers with infrastructure and development
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples of chatbots include systems for ordering products, reporting,
    internal communication, and scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: The Business Case for Chatbots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Traditionally, we used to interact with computers by means of input devices,
    such as keyboards and mice. Today, computational power and efficiency has progressed
    to the point where we can have a conversation with a computer almost as naturally
    as interacting with other people. These conversations seem more human-like, due
    to the ability of the computer to add contextual information and keep track of
    and remember the context for a few separate interactions.
  prefs: []
  type: TYPE_NORMAL
- en: It is no surprise, then, that the conversational interface is really catching
    on. One study by Gartner estimates that 30% of browsing done by users will turn
    out to be screen less in 2020\. This is a huge number, considering all of the
    interactions between humans and computers.
  prefs: []
  type: TYPE_NORMAL
- en: Another study done by BI Intelligence found that the number of global monthly
    active users for the top four messaging apps surpassed those for the top four
    social networks in the first quarter of 2015 and shows no signs of slowing down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Businesses cannot afford to ignore this trend, and are looking to reach users
    where they are found interacting (via text) the most: the messaging platforms
    such as Facebook, Skype, Slack, WhatsApp, and WeChat, and the list goes on and
    on. Messaging platforms make it easier for users to communicate, and chatbots
    make it easier for users to communicate what they want and to get it more quickly
    than interacting with other people.'
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, you will learn about **Natural Language Understanding** **(NLU)**.
    Using this knowledge, you will first explore the AWS Lex service and build your
    first sample chatbot. As the next step, you will build a custom chatbot.
  prefs: []
  type: TYPE_NORMAL
- en: What is Natural Language Understanding?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NLP is the general term for a set of technologies that deal with natural language.
    NLU is a focused subset of NLP that deals with actual conversational input.
  prefs: []
  type: TYPE_NORMAL
- en: NLU is able to handle unstructured inputs and convert to a structured, machine
    understandable form. Words that the user enters are transformed into intents and
    entities, or Slots. The NLU chatbot is further able to infer intents and Slots
    from user input, which may be similar to – but not the same as – the examples
    it has been trained with.
  prefs: []
  type: TYPE_NORMAL
- en: Core Concepts in a Nutshell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can get started with building chatbots, you will need to understand
    some concepts first. We will now take a look at the technical meaning of the term
    chatbot and the names of the pieces which make up a chatbot and work together
    to deliver a conversational experience to the user.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chatbot**'
  prefs: []
  type: TYPE_NORMAL
- en: A chatbot, also known as a `bot`, is a piece of software that can converse using
    natural language with the user. The goal is for the user to believe that they
    can interact freely and naturally with the bot, almost as if speaking with another
    person.
  prefs: []
  type: TYPE_NORMAL
- en: '**Utterances**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Things that the user says to the bot are called **utterances**. The bot regards
    the utterances from the user as input, and is able to parse them into machine-recognizable
    formats. Some examples of utterances are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: I'd like to see the dentist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you tell me what the weather is like today?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intent**'
  prefs: []
  type: TYPE_NORMAL
- en: An **intent** represents an action that the user wants to perform, based on
    the content of their utterances. The bot infers the intent and supports it based
    on its internal set of business rules or application flow, with the result of
    either a change in its internal state or an action being performed. These also
    typically result in a response being provided to the user as feedback or information.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, from the preceding utterance examples, a bot might infer intents such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: I'd like to see the dentist => SeeDentist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you tell me what the weather is like today? => GetWeather
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inferring intent is a large part of what an NLU platform such as Lex does behind
    the scenes. A number of training examples, in the form of sentences that the user
    might provide,are fed to the platform, and a probabilistic model is built from
    these examples. This means that, in practice, the platform should be able to infer
    the correct intent from input which is similar to, but not necessarily a part
    of, the examples that the system was trained on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prompts**'
  prefs: []
  type: TYPE_NORMAL
- en: When the bot requires more information from the user or is unclear about an
    Intent, it can ask the user follow-up questions, in order to collect more data.
    These are called **prompts**. Prompts typically fill in Slot values that are required,
    although your application logic may attempt to fill in values which are optional
    as well if you desire.
  prefs: []
  type: TYPE_NORMAL
- en: '**Slot**'
  prefs: []
  type: TYPE_NORMAL
- en: A **Slot** is a piece of information, or parameter, that is associated with
    an intent. The information can be provided within the initial user request, and
    Lex will be able to parse out the information and correctly assign it to the corresponding
    Slot correctly. If this information is not provided as a part of the request,
    then the bot should be able to prompt the user for the information separately.
    Slots may be optional or required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of information represented by a **Slot** is known as the Slot type.
    There are a number of built-in Slot types within Lex that represent common types
    of information, such as city or state. The following are a few examples of common
    Slot types that are built into Lex:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Table of Slot types built into Lex'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/IMG_29102018_171212_0.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.1: Table of Slot types built into Lex'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Of course, this is just a very limited subset of examples. There are many more
    built-in types, as well as different types for different languages!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can refer to the following link to get a full list of built-in intents
    and Slots: https://docs.aws.amazon.com/lex/latest/dg/howitworks-builtins.html'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the built-in intents and Slots are documented as part of the Alexa Skills
    Kit documentation, with some differences for Lex, which are documented at the
    preceding link. Make sure to keep the link bookmarked and refer to the page often,
    since Amazon keeps updating the service, and things may change.
  prefs: []
  type: TYPE_NORMAL
- en: If the type of information that you would like your bot to handle is not represented
    by one of these built-in types, you can define your own, along with the actual
    values that the Slot is allowed to take. You will see how this works as part of
    our next  exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fulfillment**'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the bot will not be able to proceed to the next step until it fills
    in all of the required Slot values! Naturally, this does not apply to Slot values
    that are optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'When all of the required Slots for an intent have been filled, Slot is then
    ready for fulfillment. At this stage, the bot is ready to execute the business
    logic required to fulfill the intent. Business logic may be any of the following
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Change in internal state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running code internally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling an internal or external service, to get information from it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling an internal or external service to post information to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fulfillment action can be performed with or without some feedback to the
    user, but as a matter of best practice, it is always better to err on the side
    of more feedback to the user, rather than less.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up with Amazon Lex
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this exercise, we will be creating a sample chatbot, which is an option
    provided with **Amazon Lex**. The goal here is to understand the various components
    of the sample chatbot and relate them to the previous topic, where you learned
    about Natural Language Understanding components. After this exercise, you should
    be able to navigate the Lex user interface and easily create intents, Slots, and
    Slot types easily for your next exercise, where you will build a custom chatbot
    based on your own business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15: Creating a Sample Chatbot to Order Flowers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will create and test the sample chatbot as a means to
    gain familiarity with the **Amazon Lex** console interface. The following are
    the steps for completion for creating a sample chatbot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Sample chatbot interface'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image0021.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.2: Sample chatbot interface'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let's first navigate to the **Amazon Lex** main screen. You can click on the
    Lex service link from the main AWS console screen or navigate directly to https://console.aws.amazon.com/lex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If this is your first time using Amazon Lex, you should see the following screen:![Figure
    4.3: Amazon Lex getting started screen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0032.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.3: Amazon Lex Getting Started screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You can click on the **Get Started** button in order to proceed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In case you have already built a bot previously, you will be shown a different
    screen, where you can click on the **Create** button, instead:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.4: Bots create screen'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/image0041.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.4: Bots create screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You will then be presented a list of options for creating bots. This shows
    two options: **CREATE YOUR OWN** and **TRY A SAMPLE**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, choose the **OrderFlowers** option under the **TRY A SAMPLE** section:![Figure
    4.5: Selecting the Bot'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0052.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.5: Selecting the bot'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This will then present you with further options to be filled in. You can leave
    the bot name as the default, `OrderFlowers`, and select `COPPA` option. You can
    leave the `IAM` role option as is. It will create a role automatically for the
    sample bot:![Figure 4.6: IAM role and COPPA selection'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0061.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.6: IAM role and COPPA selection'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Click on the **Create** button to bring up the next screen and proceed to the
    next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Working with the Chatbot Editor**'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `Intents`, `Slots`, `Slot Types`, and `Sample utterances`. You will
    see that there is a single `OrderFlowers`:![Figure 4.7: Chatbot editor screen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Image_Lesson4_007.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.7: Chatbot editor screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The sample utterances that are entered correspond to this Intent:![Figure 4.8:
    Slots types screen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Image_Lesson4_008.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.8: Slots types screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: There are also three Slots. Two of the Slots (`PickupDate` and `PickupTime`)
    take built-in types. The third one is a custom-defined Slot named `FlowerType`.
    Each Slot has a prompt associated with it, which is generated by the bot in order
    to get the information for the Slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is also a `Slot type` named `FlowerTypes`. These values are recognized
    for the `FlowerType` `Slot` when the user is prompted for the type of flower to be ordered:![Figure
    4.9: Slots types screen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Image_Lesson4_009.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.9: Slots types screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Click on the `FlowerTypes` link in order to bring up a dialog with the definitions
    of the Slot type and sample values. The following are the steps for selecting
    and editing the Slot type.![Figure 4.10: Selection of flowers types'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0082.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.10: Selecting FlowerTypes'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 4.11: Edit Slot type'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/image0092.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.11: Edit Slot type'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can also click on the **Error Handling** link in the left area to show
    the prompts that the bot will show the user for clarification (**Clarification
    Prompts**) and the phrase used to terminate the interaction (**Hang-up phrase**)
    after the maximum number of retries has been attempted by the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.12: Error handling](img/image0101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Error handling'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Testing the Chatbot**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test the chatbot in the Test bot area on the right-hand side of the
    screen. You may have to click on an arrow icon in order to expand it, if it is
    not already open:![Figure 4.13: Test Bot screen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0112.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.13: Test bot screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can have a complete interaction, as shown in the following screenshots:![Figure
    4.14: Chatbot interaction screen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0121.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.14: Chatbot interaction screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following screenshot shows the conversation with the bot:![Figure 4.15:
    Chatbot interaction screen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0132.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.15: Chatbot interaction screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: When all the required `Slots` are filled, the `intent` is said to be ready for
    fulfillment. This means that all of the information required by the intent has
    been provided, and the application logic behind the chatbot can now handle the
    intent appropriately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Intent can be returned to the calling application in the form of a `JSON` object
    or a `Lambda function` that has been implemented in the `AWS Lambda service.`
    This can be called at this point, with the `JSON` information as a parameter passed
    to it. You will see how this works later:![Figure 4.16: Summary view screen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0141.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.16: Summary view screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: As for the results displayed in the Dialog State pane, the first one shows a
    text representation of the state of the chatbot. This is the summary view which
    displays information such as the recognized intent, the Slot types, and the values
    that are now available from the Lex NLU system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Dialog State is `ReadyForFulfillment`, which signifies that the intent
    is ready for fulfillment, as shown in the preceding screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.17: dialogState'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image0152.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.17: DialogState'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the detail view, the `JSON` object that would be returned to an application,
    which is interacting with the chatbot, is displayed. Using `JSON` is a structured
    way in which an application can retrieve information from and send information
    to the chatbot system in Lex. You can see that the information being provided
    here is the same as in the Summary view, except in the `JSON` format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Lex JSON structure for intents, as well as formats for other resources,
    such as Slots and Slot types, are documented here: https://docs.aws.amazon.com/lex/latest/dg/import-export-format.html.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Custom Chatbot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this topic, we will create a custom chatbot to get stock market quotes,
    using `GetQuote`. This signals to the bot that we had, for example to get a stock
    market quote for a given stock ticker symbol, will reside in a Slot named **ticker**.
    The bot will then look up the quote for that ticker symbol from a freely available
    financial API named **IEX**, and will return the information to the user via a
    conversational response:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A stock ticker symbol is the standard way in which stocks that are traded on
    an exchange, such as the New York Stock Exchange or NASDAQ are represented. A
    sequence of alphabetical letters represents the company's stock which is being traded.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image0161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: The chatbot''s workflow'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can create a flowchart for this process, as shown in the following diagram.
    Let''s go over it in some more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19: Flowchart of the chatbot’s workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image0172.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.19: Flowchart of the chatbot''s workflow'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Recognizing the Intent and Filling the Slot Value**'
  prefs: []
  type: TYPE_NORMAL
- en: As the first step, the bot waits for the user's input, in order to recognize
    a valid intent. When it extracts the `GetQuote` intent as the intent from an utterance
    posted by the user, it will then try to fill the required Slots. In our case,
    we have only one Slot of the `StockTicker` type (which is a custom Slot type).
    The bot will issue a prompt, asking the user to provide the value of the Slot
    and parse the utterance in response, in order to fill the Slot value.
  prefs: []
  type: TYPE_NORMAL
- en: Valid Slots are those that the system recognizes. If the Slot value is not part
    of the list of allowed values, or if the system does not recognize what is entered
    for the Slot value, it is said to be `invalid`, or `not valid`.
  prefs: []
  type: TYPE_NORMAL
- en: If the Slot value is not valid, it will go back to trying to fill the Slot (at
    least up to the number of times we have specified it should try before giving
    up and going back to the beginning). Once the bot has a Slot filled with a valid
    value, it then proceeds to fulfill the intent.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fulfilling the Intent with a Lambda Function**'
  prefs: []
  type: TYPE_NORMAL
- en: While the default fulfilment action is to return the intent and Slot value to
    the user so that he/she can proceed to work with it within his/her own application,
    we will instead choose to set up a Lambda function on AWS, which can handle the
    intent and run the business logic required to fulfil it.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the bot process running within Lex proceeds to call the Lambda
    function, which we have written and specified for fulfilment.
  prefs: []
  type: TYPE_NORMAL
- en: '`Lambda_function.Lambda_handler`'
  prefs: []
  type: TYPE_NORMAL
- en: When Lex calls out to the function for fulfilment, it sends a `JSON` payload
    containing various pieces of information about the sender, as well as the intent
    and Slot value. The `Lambda_handler()` method parses the intent and Slot parameter
    value from the `JSON`, and then dispatches another function call to the method,
    which gets the market quote value that we're looking for from the external API.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `Lambda function` also packages the response as another `JSON`
    string and returns it back to Lex. Lex parses the `JSON` response behind the scenes
    and presents the response message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: We will go through all of these elements in a lot more depth in the next two
    activities. In the first activity, we will set up the new chatbot, and in the
    second one, we will implement our Lambda handler function to return the actual
    value of the market price of the ticker symbol that the user asks the bot for
    back to him or her.
  prefs: []
  type: TYPE_NORMAL
- en: A Bot Recognizing an Intent and Filling a Slot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next exercise, you will create a custom chatbot which recognizes the
    intent, named `GetQuote,` to get a market price quote for a given ticker symbol.
    The bot will prompt the user for the value of the ticker symbol which the user
    is interested in, until the Slot is filled. You will also learn how to state the
    intent and fill the Slot in the same utterance. The chatbot can be tested via
    a conversational interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16: Creating a Bot that will Recognize an Intent and Fill a Slot'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will create and test an Amazon Lex-based bot with a custom
    `intent` and `Slot`. The following are the steps for creating a bot with a custom
    intent and Slot:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to navigate to the `Amazon Lex service` within the `AWS console`,
    by clicking on the appropriate links within the AWS console, or navigating to
    https://console.aws.amazon.com/lex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to click on the **Get Started** button, in order to get to
    the **bot** creation screen:![Figure 4.20: Getting Started screen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0181.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.20: Getting Started screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'At this point, you can create a Custom bot by clicking on the **Custom bot**
    option button. This reveals the bot''s details, which can be filled out, as shown
    in the following screenshot:![Figure 4.21: Custom Bot option'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0192.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.21: Custom bot option'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: The `MarketNanny`. The Output voice field is set to `None. This is only a text
    based application`. This is because we will be interacting with the bot only with
    text in this section, and not with voice just yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The session timeout can be set to the default of 5 min. The IAM role field displays
    the name of the IAM role, which is automatically created by Lex for use by bot
    applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `COPPA` field pertains to the **Children's Online Privacy Protection
    Act**, to which online applications must conform. Assuming that no children under
    13 are present in the class, you can click on **No**. If, however, you are a student
    under 13 or intend to have someone under 13 use your chatbot, then you should
    click on the **Yes** option, instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: A law was passed in 1998 to protect the privacy of children under 13\. It states
    that online sites may not collect personal information from users younger than
    13 years old without parental consent, among other provisions. You can learn more
    about the COPPA act at https://www.ftc.gov/enforcement/rules/rulemaking-regulatory-reform-proceedings/childrens-online-privacy-protection-rule.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, clicking on the `Slot` with a custom `Slot type`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Create Intent** button to bring up an **Add** Intent pop-up
    dialog window:![Figure 4.22: MarketNanny Bot Editor'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0201.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.22: MarketNanny bot Editor'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Conversely, if you already have an intent defined, you can create a new one
    by clicking on the **+** sign next to the Intents heading in the left-hand side
    column on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Create `ZIP` file containing one or more `JSON` files with intents in the
    Lex format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The search for existing intents allows you to reuse the intents that you may
    have defined or imported previously, as well as the built-in intents defined by
    **Amazon Lex**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should just click on the **Create** intent link, however, to get to the
    following dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `GetQuote`. The bot will recognize this intent when you let it know
    that you are interested in a market quote. Click on the **Add** button to complete
    this step:![Figure 4.23: Create intent screen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0212.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.23: Create intent screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You should be back at the Editor screen at this point, and you should see the
    `GetQuote` intent in the left toolbar portion of the screen. The Editor screen
    also contains a number of fields that are used to define and customize the new intent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first thing to do is fill in some Sample utterances to train the `GetQuote`
    intent:![Figure 4.24: Creation of the Intent'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0221.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.24: Creation of the Intent'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'After entering some sample utterances, you click on the **Build** button near
    the top of the page, in order to kick off the training process for the bot:![Figure
    4.25: Building the Bot'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0232.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.25: Building the bot'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There will be a follow-up dialog box with another **Build** button, which you
    should also click:![Figure 4.26: Build confirmation'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0241.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.26: Build confirmation'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'After this, you should wait until you see the successful build dialog, which
    might take a few seconds to a couple of minutes:![Figure 4.27: Bot build is successful'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0252.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.27: Bot build is successful'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You can test your new intent within the bot in the `Test bot` pane, in the upper
    right-hand corner of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: If the Test bot pane is not visible, you may have to click on an arrow button
    in order to expand it and make it visible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type utterances into the pane to verify that the bot is able to recognize the
    correct intent from the utterances:![Figure 4.28: Test Bot'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image026.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.28: Test bot'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You know that it has recognized the intent correctly when it returns the response:
    Intent `GetQuote` is `ReadyForFulfillment`. Feel free to experiment with different
    utterances, based on your sample utterances, in order to verify that the **NLU**
    engine is working correctly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, your bot does not do much, other than try to recognize the `GetQuote`
    intent and flag that it is ready for fulfillment. This is because we have not
    added any `Slots` to the `intent`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Slot Addition**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your next step will be to add a Slot, along with a custom Slot type for the
    Slot:![Figure 4.29: Adding a Slot'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0273.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.29: Adding a Slot'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Add a `Slot type`. This can be done by pressing the `JSON` structure. However,
    before, we will click on the `new Slot` type:![Figure 4.30: Create Slot type](img/image0281.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.30: Creating Slot type'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: In the `Description` field and leave the `Expand Values`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the `StockTicker` Slot type. You can add some of your own, as well, if
    you wish:![Figure 4.31: Adding a Slot type](img/image0292.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.31: Adding a Slot type'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Finally, click on the **Add** Slot to intent button, in order to add the Slot
    type to the intent, and close the dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could have also clicked on the **Save** Slot type button and added the Slot
    to the intent in a separate step, but using the button is the shortcut to accomplishing
    both actions in a single step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you close the dialog box, you will find that Lex has added a new Slot entry,
    as well, under the Slots section. It is helpfully prefilled with the `StockTicker`
    Slot type, and you should change the name of the Slot to ticker, under the **Name**
    field for the entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the wheel under the **Prompt** field to expand it to a new dialog
    box:![Figure 4.32: Editor dialog box](img/image0301.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.32: Editor dialog box'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: The prompts editor dialog box (named ticker Prompts) allows entry of prompts
    for the `Slot`, which the bot will use to store the user `inputs` and corresponding
    sample `utterances` that the user would typically provide to the bot while the
    bot is trying to elicit the information from the user with the prompts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The placement of the Slot value within the corresponding utterances for the
    Slots is denoted by curly braces `{}` and the name of the Slot within the braces.
    In this case, since the Slot is named ticker, it is denoted by `{ticker}` within
    the sample utterances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the prompts (a single prompt is fine – if you add more prompts, the
    bot will use them randomly, for variety) in the Prompts section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, add some `utterances` to the Corresponding utterances section, denoting
    the placement of the Slot value, using the placeholder token `{ticker}` in each
    sample statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Leave the Maximum number of retries field as the default value of two. This means
    that it will try to get the value for the Slot twice before signaling an `error`:![Figure
    4.33: Ticker prompt screen](img/image0312.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.33: Ticker prompt screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Finally, click on the **Save** button to save the Slot prompts and the corresponding
    utterances definitions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, click on the **Save** Intent button at the bottom of the screen, then
    the **Build** button at the top of the screen, in order to kick off the training
    process with the new Slot and Slot type that we have defined, and wait for the completion
    dialog to display when the training is done:![Figure 4.34: Saving the Intent](img/image0321.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.34: Saving the Intent'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Your updated intent is now ready to test in the **Test bot** pane:![Figure
    4.35: Updated intent test bot](img/image0332.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.35: Updated intent test bot'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'At the end of the bot flow, when all of the information it requires is filled,
    it returns the intent in the same format as before. However, it follows this response
    line with another line, containing the name and value of the Slot parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This indicates that the ticker Slot has been filled with the value `GOOG`. So,
    that's great; our intent with Slot is working!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While you''re having fun playing around with the bot to verify that the intent
    and Slot are working as they should, why not try something a little bit different:
    enter some utterances that are not a part of the sample utterances that you previously
    entered to train the bot.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type **Can I get a market quote?** as your initial utterance, and see if the
    bot can recognize the intent. Bear in mind that the sentence, though similar to
    the sample utterances, is not one of those utterances:![Figure 4.36: Test bot
    screen](img/image0341.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.36: Test bot screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see from the testing shown in the preceding screenshot, not only
    does Lex recognize the correct intent from an utterance it has not been trained
    on, but it also recognizes a new symbol which it has not seen before (ADP) correctly
    as the value for the ticker Slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s try a conversational form of a corresponding utterance for the
    Slot prompt by inserting a random interjection as a part of the sentence, again
    using a new ticker symbol (**VZ**) that the bot has not previously trained on.
    Again, it is correctly processed and recognized:![Figure 4.37: Test bot screen](img/image0352.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.37: Test bot screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Clearly, there is quite a bit of flexibility possible between training and real-world
    examples of conversational input with an NLU engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Natural Language Understanding Engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NLU demonstrates the advantage of using an NLU engine that has been trained
    on a huge set of conversational sentences and has formed a large inference model.
  prefs: []
  type: TYPE_NORMAL
- en: It is able to connect sentences that are not the same as the ones it has specifically
    been trained on. In fact, they can be significantly different, but the model is
    large enough to infer that the semantic meanings are similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more trick that you can use to make it easier for the user to
    interact with your bot. You can fill the Slot value in the same utterance as the
    one which establishes intent. This can be accomplished by simply including the
    Slot placeholder token (`{ticker},` in this case) in your sample utterances:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new sample utterance to your `GetQuote` intent, as follows:![Figure 4.38:
    GetQuote screen](img/image0361.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.38: GetQuote screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The **ticker** placeholder token denotes that that Slot may be filled directly
    within the initial utterance, and, in that case, a prompt doesn''t need to be generated:![Figure
    4.39: Build screen for the bot](img/image0371.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.39: Build screen for the bot'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Click on the **Build** buttons to train your updated intent as before, and
    then test it in the Test bot pane, as follows:![Figure 4.40: Test bot screen](img/image038.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.40: Test bot screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You can see that the intent is ready for fulfillment and that the Slot value
    is filled appropriately, in a single step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now gone through the process of defining a custom chatbot, complete
    with a custom intent, Slot type, and Slot, within Amazon Lex. Furthermore, we
    have trained and tested the bot to verify that it is able to classify the correct
    intent and correctly infer the Slot values from conversational input, to a high
    degree of accuracy. Finally, we added a shortcut method to fill in the Slot value
    directly in the initial utterance, by inserting the placeholder token for the
    Slot value in the sample utterance to train the NLU engine behind Lex.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Function – Implementation of Business Logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create AWS Lambda functions, so that you can run your code for your
    Amazon Lex bot. You can recongnize Lambda functions to boot up and validating
    the fulfillment, in your intent configuration. Without a Lambda function, your
    bot returns the intent information to the client application for fulfillment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will learn how to implement the business logic behind
    the bot as a Lambda function in AWS and call a real-world REST API to get information
    to return to the user from an external service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17: Creating a Lambda Function to Handle Chatbot Fulfillment'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will handle chatbot fulfillment business logic with a
    `Lambda function` that is created and deployed on AWS. In the last exercise, we
    created a chatbot with a `GetQuote` intent and ticker Slot. In this exercise,
    we will implement the fulfillment business logic. The following are the steps
    for implementing business logic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the AWS Lambda screen via the AWS Console, or by navigating directly
    to: https://console.aws.amazon.com/Lambda.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you have never used Lambda before, you should be presented with a Welcome
    screen:![Figure 4.41: AWS Lambda start up screen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0391.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.41: AWS Lambda start up screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Click on the **Create** a function button, in order to get started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Author from scratch** option on the next page:![Figure 4.42: Selecting
    an author'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image040.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.42: Selecting an author'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'For the runtime, choose `Python 3.6` from the drop-down menu as you will be
    implementing the handler in the Python language for this exercise. In the Name
    field, fill in `marketNannyHandler`:![Figure 4.43: Filling in the values'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image0411.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.43: Filling in the values'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'For the Role field, choose **Create** new role from template(s) from the drop-down
    menu:![Figure 4.44: Role selection screen](img/image042.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.44: Role selection screen'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Enter the name `marketNannyProcessorRole` in the Role name field. Then, click
    on the **Create function** button to create the Lambda function in AWS. You should
    see a confirmation screen, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.45: Confirmation screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image0431.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.45: Confirmation screen'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Implementing the Lambda Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, you will use the Lambda Function editor entirely in-line, which means
    that you can enter and modify the code directly, without having to upload any
    files to AWS. The code that you enter will be executed when the Lambda function
    is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.46: Function code screen](img/image044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.46: Function code screen'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: First, let's look at the structure of the Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you created the function named `marketNannyHandler`, AWS created a folder
    with the same name, with a Python file named `Lambda_function.py` within the folder.
    This file contains a stub for the `Lambda_handler` function, which is the entry
    point of our Lambda function. The entry point takes two parameters as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The event argument provides the value of the payload that is sent to the function
    from the calling process. It typically takes the form of a Python `dict` type,
    although it could also be one of `list`, `str`, `int`, `float`, or `NoneType`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The context argument is of the type `LambdaContext` and contains runtime information.
    You will not be using this parameter for this exercise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value of the function can be of any type that is serializable by
    `JSON`. This value gets returned to the calling application after serializing.
  prefs: []
  type: TYPE_NORMAL
- en: Input Parameter Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s take a closer look at the structure of the event argument, which
    gets passed to the `Lambda_handler function`. If we are asking for a market quote
    with the ticker value `GOOG`, the `JSON` value of the intent section within the
    parameter will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The relevant values which we are interested in for processing are `name` and
    the single `ticker` value within the `Slots` section under `currentIntent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our `JSON` input gets converted into a Python dictionary, we can obtain
    these values within the Lambda function simply, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the High-Level Handler Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step in implementing our handler is identifying the intent name and
    calling the corresponding function that implements it. This code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is complete enough to actually be tested against your chatbot at this point,
    if you so desire, but let's press on with the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Function to Retrieve the Market Quote
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next step will be to implement the `get_quote` function, which does the
    work of actually getting the market quote information and returning it to the
    calling handler function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have named the parameter as request, so the event `object` that
    we send the function to is referred to as a request within this function. It contains
    the same value and structure, just renamed. Therefore, we can get the value of
    the ticker Slot, as mentioned previously, by getting the value of the item with
    the `ticker` key under by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We then call the `call_quote_api()` function to retrieve the value of the market
    quote for the value of the ticker item. We haven't implemented `call_quote_api()`
    yet, so let's do this next.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement the `call_quote_api` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Where ticker is the value of the ticker parameter (in this specific example,
    it would be `GOOG`). We use the IEX API, which provides a static endpoint on the
    internet at https://api.iextrading.com, to retrieve a delayed quote, using the
    1.0 version of their REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Since it is implemented as a simple `GET` request, with the ticker parameter
    embedded within the `URL`, and no other special header values such as the API
    key or user information, we can simply use the built-in `urlopen` method in the
    `urllib.request` module (which we will have to remember to import) to receive
    a response from the URL with the ticker embedded within it.
  prefs: []
  type: TYPE_NORMAL
- en: Since the response is also in the `JSON` format, we need to import the `json
    module` and load the response using the `json.load function`. The only field we
    are interested in within the response is `delayedPrice`, so we return that as
    the return value from our function.
  prefs: []
  type: TYPE_NORMAL
- en: Returning the Information to the Calling App (The Chatbot)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have the market quote value, we can return it to our calling application,
    which is the chatbot that we implemented. We have to do a couple of small things,
    however, to return this value. First, we need to format it as a conversational
    response, as in the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This should let the chatbot display the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one final step, which is to construct an `JSON` return format, containing
    our message and a couple of other items of information. We will use the helper
    function close to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our close function takes a single parameter, which is the string that we wish
    to return to the chatbot (in this case, this is the value of the message variable).
    It generates a `JSON` wrapper around the content, which conforms to the structure,
    which our Lex-based bot is expecting and from which it can extract the content
    and deliver it to the user. The structure of the wrapper is not important at this
    stage, but if you are curious, you can look at the implementation of the close
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the Chatbot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, the only task remaining is to connect the Lambda function to
    the chatbot and test it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so navigate back to the Amazon Lex dashboard and select the `MarketNanny` bot:![Figure
    4.47: Connecting to the bot ](img/image0451.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.47: Connecting to the bot'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, scroll down to the Fulfillment section and select the AWS Lambda function
    option. Next, select the `marketNannyHandler` function from the Lambda function
    drop-down menu and leave Version or alias as the default value of **Latest**:![Figure
    4.48: Confirmation prompt](img/image046.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.48: Confirmation prompt'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Rebuild the intent by clicking on the **Build** buttons, and test the chatbot
    together with the Lambda handler in the Test Chatbot pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.49: Chatbot updated](img/image0471.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.49: Chatbot updated'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following screenshot shows the interaction with bot for knowing the current
    price of AAPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.50: Chatbot updated](img/image048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.50: Chatbot updated'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Activity 5: Creating a Custom Bot and Configuring the Bot'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will create a custom bot for `PizzaOrdering`. A bot performs
    the automated task of ordering a pizza. An Amazon Lex bot is powered by **Automatic
    Speech Recognition** (**ASR**) and **Natural Language Understanding** (**NLU**)
    capabilities, the same technology that powers **Amazon Alexa**. For this, we will
    consider the following example: suppose that a user wants to order a pizza; a
    user might say, **Can I order a pizza, please?** or, **I want to order a pizza**.
    You can configure the intent so that Amazon Lex simply returns the information
    back to the client application, to perform the necessary fulfillment. To ensure
    that it happens correctly, you will need to navigate to the Amazon Lex services
    to create the custom bot:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a custom bot for `Pizza Ordering`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Intent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Slot type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the Intent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the bot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: To refer to the detailed steps, go to the *Appendix A* at the end of this book
    on Page no. 217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about the basic chatbots and chatbot design. You
    also learned how to set up the Amazon Lex services, and how to create a sample
    chatbot. Next, we looked at the Chatbot workflow. We then looked upon the flowchart
    of a Chatbot's workflow. Finally, we dove into creating a custom chatbot that
    shows share prices.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to use speech with chatbots.
  prefs: []
  type: TYPE_NORMAL
