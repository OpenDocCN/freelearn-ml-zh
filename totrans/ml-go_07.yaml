- en: Time Series and Anomaly Detection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列与异常检测
- en: Most of the models that we have discussed up to this point predict a property
    about something based on other properties related to that something. For example,
    we predicted the species of a flower based on measurements of the flower. We also
    tried to predict the progression of the disease diabetes in a patient based on
    medical attributes about that patient.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止讨论的大多数模型都是基于与某个事物相关的其他属性来预测该事物的某个属性。例如，我们根据花朵的测量值预测了花朵的物种。我们还尝试根据患者的医疗属性来预测患者糖尿病的进展。
- en: The premise of time series modeling is different from these types of property
    prediction problems. Simply put, time series modeling helps us predict the future
    based on attributes about the past. For example, we may want to predict future
    stock prices based on previous values of that stock price, or we may want to predict
    how many users will be on our website at a certain time based on data about how
    many users were on our website at previous times. This is sometimes called **forecasting**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列建模的前提与这些类型的属性预测问题不同。简单来说，时间序列建模帮助我们根据过去的属性来预测未来。例如，我们可能想根据该股票价格的历史值来预测未来的股票价格，或者我们可能想根据之前某个时间点我们网站上用户数量的数据来预测在某个时间点会有多少用户访问我们的网站。这有时被称为**预测**。
- en: The data utilized in time series modeling is typically different from the data
    utilized in classification, regression, or clustering. A time series model operates
    on one or more **time series**, as one might expect. This series is a sequential
    set of properties, attributes, or other numbers paired with their corresponding
    date and time or a corresponding proxy for a date and time (measurement index
    or day number, for example). For stock prices, this series would consist of a
    bunch of (date and time, stock price) pairings.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列建模中使用的数据通常与分类、回归或聚类中使用的数据不同。时间序列模型基于一个或多个**时间序列**，正如人们所期望的那样。这个序列是一系列按顺序排列的属性、属性或其他数字，它们与相应的日期和时间或日期和时间的代理（例如测量索引或天数）配对。对于股票价格，这个序列将包括一系列（日期和时间，股票价格）配对。
- en: This time series data is found everywhere in industry and in academia. It is
    also becoming increasingly important as we explore and develop the **Internet
    of Things** (**IoT**). Fitness trackers, *smart* devices such as refrigerators,
    thermostats, cameras, drones, and many other new devices, are producing a staggering
    amount of time series data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种时间序列数据在工业和学术界无处不在。随着我们探索和发展**物联网**（**IoT**），它也变得越来越重要。健身追踪器、*智能*设备，如冰箱、恒温器、摄像头、无人机以及许多其他新设备，正在产生令人震惊的大量时间序列数据。
- en: Of course, you are not restricted to predicting the future with this type of
    data. There are many other useful things that you can do with time series data
    including anomaly detection, which will be covered later in this chapter. Anomaly
    detection attempts to detect unexpected or out-of-the-ordinary events in a time
    series. These events might correspond to catastrophic weather events, infrastructure
    failures, viral social media behavior, and so on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不必仅限于使用这类数据来预测未来。你可以用时间序列数据做很多其他有用的事情，包括稍后在本章中将要介绍的异常检测。异常检测试图检测时间序列中的意外或非同寻常的事件。这些事件可能对应于灾难性的天气事件、基础设施故障、病毒式社交媒体行为等等。
- en: Representing time series data in Go
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中表示时间序列数据
- en: There are purpose-built systems to store and work with time series data. Some
    of these are even written in Go, including Prometheus and InfluxDB. However, some
    of the tooling that we have already utilized in the book is also suitable to handle
    time series. Specifically, `github.com/kniren/gota/dataframe`, `gonum.org/v1/gonum/floats`,
    and `gonum.org/v1/gonum/mat` can help us as we are working with time series data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 存在专门用于存储和处理时间序列数据的系统。其中一些甚至是用Go编写的，包括Prometheus和InfluxDB。然而，我们在这本书中已经使用的一些工具也适合处理时间序列。具体来说，`github.com/kniren/gota/dataframe`、`gonum.org/v1/gonum/floats`和`gonum.org/v1/gonum/mat`可以帮助我们在处理时间序列数据时。
- en: 'Take, for example, a dataset that includes a time series representing the number
    of international air passengers during the years 1949-1960 (available for download
    at [https://raw.github.com/vincentarelbundock/Rdatasets/master/csv/datasets/AirPassengers.csv](https://raw.github.com/vincentarelbundock/Rdatasets/master/csv/datasets/AirPassengers.csv)):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个包括1949-1960年期间国际航空旅客数量时间序列的数据集为例（可在[https://raw.github.com/vincentarelbundock/Rdatasets/master/csv/datasets/AirPassengers.csv](https://raw.github.com/vincentarelbundock/Rdatasets/master/csv/datasets/AirPassengers.csv)下载）：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the `time` column includes a series of times represented by a year along
    with a decimal, and the `AirPassengers` column includes the number of international
    air passengers at that `time`. In other words, this is a time series with a pairing
    of (time, number of passengers).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`time`列包含一系列由年份和十进制数表示的时间，而`AirPassengers`列包含在那个`time`时刻的国际航空旅客数量。换句话说，这是一个具有（时间，乘客数量）配对的时序。
- en: 'This is just tabular data and we can represent it perfectly well using a dataframe
    or matrix. Let''s utilize a dataframe for simplicity, as shown in the following
    code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是表格数据，我们可以用dataframe或矩阵完美地表示它。为了简单起见，让我们使用dataframe，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will produce the following output:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We could represent the series similarly with `gonum.org/v1/gonum/mat` and,
    when/if needed, we can convert the dataframe to slices of floats for use with
    `gonum.org/v1/gonum/floats`. If we wanted to plot the time series, for example,
    we could convert the columns to floats and produce a plot with `gonum.org/v1/plot`,
    as shown in the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`gonum.org/v1/gonum/mat`类似地表示这个序列，并在需要时将dataframe转换为浮点数切片，用于`gonum.org/v1/gonum/floats`。如果我们想绘制时间序列，例如，我们可以将列转换为浮点数，并用`gonum.org/v1/plot`生成一个图表，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Compiling and running this program produces the following plot of our time
    series:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行此程序会产生以下时间序列的图表：
- en: '![](img/f8613e7d-2182-4772-93e7-b564d8e2771a.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8613e7d-2182-4772-93e7-b564d8e2771a.png)'
- en: As expected, the number of international air passengers increases over time
    as more and more people begin to travel via airplanes. We can also see that there
    appear to be bumps or spikes that are repeating over time. We will dive more into
    these features shortly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，随着时间的推移，越来越多的人开始通过飞机旅行，国际航空旅客的数量也在增加。我们还可以看到，似乎存在重复出现的波峰或峰值。我们将在稍后更深入地探讨这些特征。
- en: Understanding time series jargon
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解时间序列术语
- en: You are probably noticing by this time in the book that each set of machine
    learning techniques has an associated set of jargon, and time series is no different.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的这一部分，你可能已经注意到每一套机器学习技术都有一套相关的术语，时间序列也不例外。
- en: 'Here is an explanation of some of this jargon that will be utilized throughout
    the rest of the chapter:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对本章余下部分将要用到的部分术语的解释：
- en: '**Time**, **datetime**, or **timestamp**: This property is the temporal element
    of each pairing in our time series. This could be simply a time or it could be
    a combination of date and time (sometimes referred to as datetime or timestamp).
    It might also include time zone.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间**、**日期时间**或**时间戳**：这个属性是我们时间序列中每一对的时间元素。这可以简单地是一个时间，也可以是日期和时间的组合（有时称为日期时间或时间戳）。它也可能包括时区。'
- en: '**Observation**, **measurement**, **signal**, or **random variable**: This
    is the property that we are trying to forecast and/or otherwise analyze as a function
    of time.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观测值**、**测量值**、**信号**或**随机变量**：这是我们试图作为时间函数预测和/或分析的性质。'
- en: '**Seasonality**: A time series, such as the time series of air passenger data,
    may exhibit changes that correspond to seasons (weeks, months, years, and so on).
    Time series that behave in this manner are said to exhibit some seasonality.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**季节性**：像航空旅客数据这样的时间序列可能会表现出与季节（周、月、年等）相对应的变化。以这种方式表现的时间序列被称为表现出某种季节性。'
- en: '**Trends**: Time series that gradually increase or decrease over time (separate
    from seasonal effects) are said to exhibit a trend.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**趋势**：随着时间的推移逐渐增加或减少的时间序列（与季节性效应分开）被称为表现出趋势。'
- en: '**Stationary**: A time series that exhibits the same patterns over time, without
    trends or other gradual changes (such as changes in variance or covariance), is
    said to be stationary.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平稳性**：如果一个时间序列在时间上表现出相同的模式，没有趋势或其他逐渐变化（如方差或协方差的变化），则称其为平稳的。'
- en: '**Time period**: The amount of time between successive observations in the
    time series, or the difference between one timestamp and the previously occurring
    timestamp in the series.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间周期**：时间序列中连续观测之间的时间量，或者系列中一个时间戳与之前发生的时间戳之间的差异。'
- en: '**Auto-regressive model**: This is a model that tries to model a time series
    process by one or more delayed, or lagged, versions of the same process. For example,
    an auto-regressive model of stock prices would try to model stock prices by the
    value of the stock price at previous time intervals.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自回归模型**：这是一个试图通过一个或多个延迟或滞后版本的同过程来模拟时间序列过程的模型。例如，股票价格的自回归模型会试图通过股票价格在先前时间间隔的值来模拟股票价格。'
- en: '**Moving average model**: This is a model that tries to model a times series
    based on the current and various past values of an imperfectly predictable term,
    commonly referred to as **error**. For example, this imperfectly predictable term
    may be some white noise in the time series.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动平均模型**：这是一个试图根据一个不完全可预测的项的当前和过去各种值来模拟时间序列的模型，这个项通常被称为**误差**。例如，这个不完全可预测的项可能是时间序列中的某些白噪声。'
- en: Statistics related to time series
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与时间序列相关的统计
- en: In addition to certain jargon associated with time series, there is an important
    set of statistics related to time series that we will be relying on as we perform
    forecasting and anomaly detection. These statistics are mainly related to how
    values in times series are related to other values in the same time series.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与时间序列相关的一些术语之外，还有一些重要的与时间序列相关的统计，我们在进行预测和异常检测时将依赖这些统计。这些统计主要与时间序列中的值如何与其他值相关联有关。
- en: The statistics will help us as we profile our data, which is an important part
    of any time series modeling project, as it is with all of the other types of modeling
    that we have covered. Gaining intuition about the behavior of your time series
    over time, seasonality, and trends is crucial for ensuring that you apply appropriate
    models and perform mental checks of your results.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些统计将帮助我们分析数据，这是任何时间序列建模项目的重要部分，正如我们在其他类型的建模中所做的那样。了解你的时间序列随时间、季节性和趋势的行为，对于确保你应用适当的模型并对你结果进行心理检查至关重要。
- en: Autocorrelation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自相关
- en: '**Autocorrelation** is a measure of how correlated a signal is with a delayed
    version of itself. For example, one or more previous observation of a stock price
    may be correlated (or change together) with the next observation of the stock
    price. If this was the case, we would say that the stock price was influenced
    by itself according to some lag or delay. We could then model the future stock
    price by a delayed version of itself at the specific lags indicated as highly
    correlated.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**自相关**是衡量一个信号与其延迟版本的相关程度。例如，一个或多个股票价格的先前观测值可能与下一个股票价格的观测值相关（或一起变化）。如果这种情况发生，我们就会说股票价格根据某些滞后或延迟影响了自己。然后我们可以通过在特定滞后中指示为高度相关的滞后版本来模拟未来的股票价格。'
- en: 'To measure the autocorrelation of a variable *x[t]* with a delayed version
    of itself (or a version with a lag) *x[s]*, we can utilize the **autocorrelation
    function** (**ACF**), defined as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测量变量 *x[t]* 与其延迟版本（或滞后版本）*x[s]* 的自相关，我们可以利用**自相关函数**（**ACF**），其定义如下：
- en: '![](img/7c5965b3-e042-4979-9db1-815be4227eef.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c5965b3-e042-4979-9db1-815be4227eef.png)'
- en: Here, *s* could represent any lagged version of *x*. Thus, we can calculate
    the autocorrelation between *x* and a version of *x* that has a lag of a single
    time period (*x[t-1]*), between *x* and a version of *x* that has a lag of two
    time periods (*x[t-2]*), and so on. Doing this gives us information about which
    delayed versions of *x* are most correlated with *x*, and thus helps us determine
    which delayed versions of *x* might be good candidates for use in modeling future
    versions of *x.*
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*s* 可以代表 *x* 的任何滞后版本。因此，我们可以计算 *x* 与滞后一个时间周期的 *x* 版本（*x[t-1]*）之间的自相关，与滞后两个时间周期的
    *x* 版本（*x[t-2]*）之间的自相关，依此类推。这样做可以告诉我们哪些延迟版本的 *x* 与 *x* 最相关，从而帮助我们确定哪些延迟版本的 *x*
    可能是用于模拟 *x* 未来版本的好候选者。
- en: 'Let''s try calculating the first few autocorrelations of our airline passenger
    time series with itself. To do this, we first need to create a function that will
    calculate an autocorrelation in our time series for a specific time period lag.
    Here is an example implementation of this function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试计算我们的航空公司乘客时间序列与其自身的第一个几个自相关系数。为此，我们首先需要创建一个函数，该函数将计算特定时间段滞后的时间序列中的自相关系数。以下是该函数的一个示例实现：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will then loop over a few lags and utilize the `acf()` function to calculate
    the various autocorrelations. This process is shown in the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将遍历几个滞后，并利用`acf()`函数计算各种自相关系数。这个过程在以下代码中显示：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This produces the following results:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下结果：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see, the autocorrelations with lags further back in the series tend
    to be smaller (although, this is not the case for every lag). However, this information
    can be a little bit hard to absorb in its numerical form. Let''s plot these values
    as a function of the lag to better visualize the correlations:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，序列中更早的滞后处的自相关系数往往较小（尽管，这并不是每个滞后都如此）。然而，这种信息在数值形式上可能有点难以吸收。让我们将这些值作为滞后函数的函数来绘制，以更好地可视化相关性：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code produces the following plot of the ACF:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生了以下ACF图的绘制：
- en: '![](img/03bf60a0-2e99-416b-a1e9-c104396d33cc.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03bf60a0-2e99-416b-a1e9-c104396d33cc.png)'
- en: Notice how the autocorrelations are decreasing generally, but they are staying
    rather large (well above 0.5) even out to lags of 20 time periods. This is an
    indication that our time series is not stationary. Indeed, if we look at the previous
    plot of our time series, it is obviously trending upward. We will deal with this
    non-stationary behavior later in the chapter, but for now, suffice it to say that
    the ACF plot is indicating to us that the lagged versions of the number of air
    passengers are correlated with their non-delayed counterparts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到自相关系数总体上是下降的，但它们保持相当大（远高于0.5），甚至到20个时间周期的滞后。这是我们的时间序列不是平稳的一个迹象。实际上，如果我们看我们时间序列的先前图，它显然是向上趋势的。我们将在本章的后面部分处理这种非平稳行为，但就目前而言，我们可以说ACF图正在向我们表明，乘客数量的滞后版本与其非延迟版本是相关的。
- en: More generally, the ACF will allow us to determine which type of time series
    we are modeling. For a process that could be modeled well by an auto-regressive
    model, we should see that the `acf` function decreases somewhat quickly, but not
    immediately, as you move to further lags. For a process that could be modeled
    well by a so-called moving average model, we would see a significant ACF term
    at the first lag, but then the ACF would die off after that first lag.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，自相关函数将使我们能够确定我们正在建模的时间序列类型。对于一个可以用自回归模型很好地建模的过程，我们应该看到`acf`函数随着滞后时间的增加而迅速下降，但不是立即下降。对于一个可以用所谓的移动平均模型很好地建模的过程，我们会在第一个滞后处看到一个显著的ACF项，但之后ACF会在第一个滞后之后消失。
- en: For more information on interpreting ACF plots, see [https://coolstatsblog.com/2013/08/07/how-to-use-the-autocorreation-function-acf/](https://coolstatsblog.com/2013/08/07/how-to-use-the-autocorreation-function-acf/).
    This post gives some great details, some of which we are not able to cover here.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何解释自相关函数（ACF）图的信息，请参阅[https://coolstatsblog.com/2013/08/07/how-to-use-the-autocorreation-function-acf/](https://coolstatsblog.com/2013/08/07/how-to-use-the-autocorreation-function-acf/)。这篇文章提供了一些很好的细节，其中一些我们在这里无法涵盖。
- en: Partial autocorrelation
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分自相关
- en: As you might expect from the name, partial autocorrelation is related to autocorrelation,
    but there are some subtle differences. Partial means that this is a conditional
    sort of correlation. In essence, partial autocorrelation measures the correlation
    of a series with itself at a certain lag after subtracting off any autocorrelations
    at intermediate lags. You could think of this as the leftover autocorrelation
    after intermediate correlations have been removed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，部分自相关与自相关相关，但也有一些细微的差别。部分意味着这是一种条件性的相关。本质上，部分自相关是在减去中间滞后处的自相关之后，测量序列与其自身在某个滞后处的相关程度。你可以将其视为在移除中间相关之后剩余的自相关。
- en: The reason that we might want something like this is that we need more than
    just the ACF to determine the order of our time series model, assuming that it
    can be modeled by an auto-regressive model. Let's suppose that, using the ACF,
    we have determined that we can model our series by an auto-regressive model, because
    the ACF decays exponentially with the lags. How are we to know if we should model
    this time series by a version of itself lagged by one time period, or both a version
    of itself lagged by one time period and two time periods, and so on?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要这样的原因是我们需要比ACF更多的信息来确定时间序列模型的阶数，假设它可以由自回归模型来建模。假设我们使用ACF确定我们可以通过自回归模型来建模我们的序列，因为ACF随着滞后时间的增加而指数衰减。我们如何知道我们应该通过自身滞后一个时间周期的版本来建模这个时间序列，或者是一个滞后一个时间周期和一个滞后两个时间周期的版本，依此类推？
- en: By subtracting out intermediate correlations, we are able to quickly determine
    any leftover correlation that could be modeled using an auto-regressive model
    with more terms. If the partial autocorrelation dies off after a first lag, we
    know that we should be able to model our series based on a single lagged version
    of itself (lagged at one time period). However, if the partial autocorrelation
    does not die off after a first lag, we know that we will need to employ multiple
    lagged versions of the time series in our auto-regressive model.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过减去中间相关性，我们能够快速确定任何剩余的相关性，这些相关性可以用具有更多项的自回归模型来建模。如果偏自相关性在第一个滞后之后消失，我们知道我们可以根据自身的一个滞后版本（滞后一个时间周期）来建模我们的序列。然而，如果偏自相关性在第一个滞后之后没有消失，我们知道我们需要在我们的自回归模型中采用多个时间序列的滞后版本。
- en: 'If we imagine linearly modeling a value in our time series (*x[t])* by values
    at successively larger lags in the series (*x[t-1]*, *x[t-2],* and so on), our
    equation would look as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设通过时间序列中逐次增加的滞后值（*x[t-1]*, *x[t-2]*, 以及等等）线性建模时间序列中的值（*x[t]*），我们的方程将如下所示：
- en: '![](img/32e2bed0-9723-47dd-9fd2-cfae67fc46e5.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32e2bed0-9723-47dd-9fd2-cfae67fc46e5.jpg)'
- en: The various coefficients *m[1]*, *m[2]*, and so on, are the partial autocorrelations
    for a lag of one time period, the partial autocorrelation for the lag at two time
    periods, and so on, respectively. Thus, all we need to do to calculate the partial
    autocorrelation for a certain lag is to estimate the linear regression formula
    that will give us the corresponding coefficient. A function that performs this
    calculation is called the **partial autocorrelation function** (**PACF**).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 各种系数*m[1]*, *m[2]*，等等，分别是一个时间周期的滞后偏自相关性，两个时间周期的滞后偏自相关性，依此类推。因此，我们为了计算某个滞后期的偏自相关性，只需要估计出给我们相应系数的线性回归公式。执行这种计算的功能被称为**偏自相关函数**（**PACF**）。
- en: 'Using our favorite linear regression package, `github.com/sajari/regression`,
    we can create a Go function that implements the PACF as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们最喜欢的线性回归包`github.com/sajari/regression`，我们可以创建一个Go函数来实现PACF，如下所示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we can use this `pacf` function to calculate a few values of partial
    autocorrelation, corresponding to lags for which we previously calculated autocorrelation.
    This is demonstrated as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用这个`pacf`函数来计算一些偏自相关值，这些值对应于我们之前计算自相关性的滞后。如下所示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Compiling and running this gives the following values of `Partial Autocorrelation`
    in our air passengers times series:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行此代码将给出我们航空乘客时间序列中的以下`偏自相关性`值：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the partial autocorrelation dies off quickly after about the
    second lag. This indicates that there is not much remaining relationship-wise
    in the time series after factoring in the relationships between the time series
    and its first and second lags. The partial autocorrelation does not go to *0.0*
    exactly, but that is expected due to some noise in the data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，偏自相关在第二个滞后之后迅速衰减。这表明，在考虑了时间序列与其第一和第二个滞后之间的关系后，时间序列中剩余的关系并不多。偏自相关性不会精确地达到*0.0*，这是由于数据中的一些噪声所预期的。
- en: 'To help us better visualize the PACF, let''s create another plot. We can do
    this the exact same way as we did with the ACF, just substituting the `pacf()`
    function for the `acf()` function. The resulting plot is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们更好地可视化PACF，让我们创建另一个图表。我们可以用与创建ACF图表完全相同的方式来做这件事，只是将`pacf()`函数替换为`acf()`函数。结果图表如下：
- en: '![](img/ea6ac50a-56db-457f-be30-be7aee2d3c55.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea6ac50a-56db-457f-be30-be7aee2d3c55.png)'
- en: Auto-regressive models for forecasting
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测的自回归模型
- en: The first category of models that we are going to use to try and forecast our
    time series are called **auto-regressive** (**AR**) models. As already mentioned,
    we try to model a data point in our time series based on one or more previous
    points in the series. We are, thus, modeling the time series using the time series
    itself. This use of the series itself is what distinguishes AR methods from the
    more general regression methods discussed in [Chapter 4](c5c610c4-4e25-4e09-9150-b25c4b69720e.xhtml),
    *Regression*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的第一个模型类别，用于尝试预测我们的时间序列，被称为**自回归**（**AR**）模型。如前所述，我们试图根据时间序列中的一或多个先前点来建模时间序列中的数据点。因此，我们使用时间序列本身来建模时间序列。这种使用序列本身是区分AR方法与第4章中讨论的更一般回归方法的特点。*回归*。
- en: Auto-regressive model overview
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自回归模型概述
- en: You will often see AR models referred to as AR(1), AR(2), and so on. These numbers
    correspond to the **order** of the AR model or process you are using to model
    the time series, and it is this order that you can determine by performing autocorrelation
    and partial autocorrelation analysis.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会看到将AR模型称为AR(1)、AR(2)等等。这些数字对应于你用于时间序列建模的AR模型或过程的**阶数**，你可以通过进行自相关和偏自相关分析来确定这个阶数。
- en: 'An AR(1) model attempts to model an observation in your series based on the
    observation in the same series at a one time period delay:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: AR(1)模型试图根据同一时间序列中一个时间周期延迟的观察值来建模你的序列中的观察值：
- en: '![](img/e12f1bd0-9f16-45a3-8ff5-a0047b6eb370.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e12f1bd0-9f16-45a3-8ff5-a0047b6eb370.jpg)'
- en: 'An AR(2) model would look as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: AR(2)模型将如下所示：
- en: '![](img/1679ea40-6d0e-4b16-8261-29ccbc3edaf6.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1679ea40-6d0e-4b16-8261-29ccbc3edaf6.jpg)'
- en: An AR(3) model would add another term and so on, all following this pattern.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: AR(3)模型将添加另一个项，依此类推，所有这些都遵循相同的模式。
- en: These formulas might remind you of linear regression, and we will actually use
    many of the same methods here that we used when creating linear regression models.
    However, the unique aspects of time series modeling should not be ignored here.
    It is important to have an intuition of the time-related elements of your data
    (seasonality, trends, autocorrelations, and so on) and how they influence the
    AR models.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些公式可能会让你想起线性回归，实际上我们在这里将使用与创建线性回归模型时相同的一些方法。然而，时间序列建模的独特方面不应被忽视。了解数据的时间相关元素（季节性、趋势、自相关等）以及它们如何影响AR模型是很重要的。
- en: The order of AR model that you use to model your time series can be determined
    best by looking at a graph of the PACF. In the graph, you will see the PACF values
    decay to and then hover around zero. Look at how many lags it takes for the PACF
    to start hovering around zero, and then utilize an AR order corresponding to that
    many lags.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你用于建模时间序列的AR模型阶数可以通过查看PACF图来确定。在图中，你会看到PACF值衰减到并围绕零徘徊。看看需要多少滞后时间PACF开始围绕零徘徊，然后使用相应滞后数的AR阶数。
- en: 'Note that some packages to plot the PACF and ACF include horizontal lines indicating
    the statistical significance of the various lagged terms. I have not included
    these here, but if you want to quantitatively determine the order for your AR
    models, you might consider calculating these as further discussed here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些用于绘制PACF和ACF的软件包包括表示各种滞后项统计显著性的水平线。这里我没有包括这些，但如果你想要定量确定AR模型中的阶数，你可能需要考虑在这里进一步讨论的计算：
- en: '[http://www.itl.nist.gov/div898/handbook/eda/section3/autocopl.htm](http://www.itl.nist.gov/div898/handbook/eda/section3/autocopl.htm)
    and [](http://www.itl.nist.gov/div898/handbook/eda/section3/autocopl.htm) [http://www.itl.nist.gov/div898/handbook/pmc/section4/pmc4463.htm](http://www.itl.nist.gov/div898/handbook/pmc/section4/pmc4463.htm).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.itl.nist.gov/div898/handbook/eda/section3/autocopl.htm](http://www.itl.nist.gov/div898/handbook/eda/section3/autocopl.htm)
    和 [](http://www.itl.nist.gov/div898/handbook/eda/section3/autocopl.htm) [http://www.itl.nist.gov/div898/handbook/pmc/section4/pmc4463.htm](http://www.itl.nist.gov/div898/handbook/pmc/section4/pmc4463.htm).'
- en: Auto-regressive model assumptions and pitfalls
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自回归模型假设和陷阱
- en: 'The main assumptions of auto-regressive models are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归模型的主要假设如下：
- en: '**Stationarity**: AR models assume that your time series is stationary. We
    should not see any trends in the data if we plan on using AR models.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平稳性**：AR模型假设你的时间序列是平稳的。如果我们计划使用AR模型，我们不应该在数据中看到任何趋势。'
- en: '**Ergodicity**: This fancy term basically means that the statistical properties
    of the time series, like mean and variance, should not vary or drift over time.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遍历性**：这个术语听起来很复杂，基本上意味着时间序列的统计属性，如均值和方差，不应随时间变化或漂移。'
- en: Whatever time series that we are modeling with AR methods should meet these
    assumptions. However, even when some data (like our air passenger data) that does
    not meet these assumptions, we can play some differencing tricks to still take
    advantage of AR models.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用AR方法建模的任何时间序列都应该满足这些假设。然而，即使有些数据（如我们的航空旅客数据）不满足这些假设，我们也可以使用一些差分技巧来仍然利用AR模型。
- en: Auto-regressive model example
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自回归模型示例
- en: We will try to model our air passenger data using an auto-regressive model.
    Now, we already know that we are breaking one of the assumptions of AR models
    in that our data is not stationary. However, we can apply a common trick to make
    our series stationary, called **differencing**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用自回归模型来建模我们的航空旅客数据。现在，我们已经知道我们在打破AR模型的一个假设，即我们的数据不是平稳的。然而，我们可以应用一个常见的技巧来使我们的序列平稳，这被称为**差分**。
- en: Transforming to a stationary series
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为平稳序列
- en: 'To make our time series stationary, we will create a proxy time series where
    the observation at time period *t* is the observation at time period *t* from
    our original time series minus the previous observation. Let''s difference each
    observation in this manner and then plot the results to see if it gets rid of
    the trends in our data. We are also going to output this differenced time series
    to a new `*.csv` file, as shown in the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的时间序列平稳，我们将创建一个代理时间序列，其中时间周期*t*的观测值是原始时间序列中时间周期*t*的观测值减去前一个观测值。让我们以这种方式差分每个观测值，然后绘制结果以查看是否消除了数据中的趋势。我们还将输出这个差分时间序列到一个新的`*.csv`文件，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This results in the following plot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下图表：
- en: '![](img/8be8954a-2996-4c3b-bbff-648fa7c4c7e1.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/8be8954a-2996-4c3b-bbff-648fa7c4c7e1.png)'
- en: Here, we can see that we have basically removed all signs of the upward trend
    that was in the original time series. However, there still appears to be a problem
    related to variance. The differenced time series appears to have an increasing
    variance about the mean as time gets larger, which breaks our ergodicity assumption.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们基本上消除了原始时间序列中存在的上升趋势。然而，似乎仍然存在与方差相关的问题。差分时间序列似乎在时间变大时围绕均值有增加的方差，这违反了我们的遍历性假设。
- en: 'To deal with the increase in variance, we can further transform our time series
    using a log or power transformation that penalizes the larger values later in
    the time series. Let''s add this log transform, replot the log of the differenced
    series, and then save the resulting data to a file called `log_diff_series.csv`.
    The code to accomplish this is the same as the previous code snippet, except we
    use `math.Log()` to transform each value, so we will spare the details. The following
    is the resulting plot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理方差增加的问题，我们可以进一步使用对数或幂变换来转换我们的时间序列，这种变换会惩罚时间序列后期较大的值。让我们添加这个对数变换，重新绘制差分序列的对数，然后将结果数据保存到名为`log_diff_series.csv`的文件中。完成这个任务的代码与之前的代码片段相同，只是我们使用`math.Log()`来转换每个值，所以这里就不详细说明了。以下是对应的图表：
- en: '![](img/99844e43-29c8-4f78-95ec-55d733dbad0c.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/99844e43-29c8-4f78-95ec-55d733dbad0c.png)'
- en: Awesome! Now we have what looks to be a stationary series that we can utilize
    in our AR models. Note, we are looking at this qualitatively for the most part
    in this example, but there are quantitative tests for stationarity (the Dickey–Fuller
    test, for example).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们得到了一个看起来是平稳序列，我们可以在AR模型中使用它。注意，在这个例子中，我们大部分是定性分析这个序列，但存在一些用于平稳性的定量测试（例如Dickey-Fuller测试）。
- en: We have transformed our data here with both a difference and a log transformation.
    This allowed us to fit within the assumptions of the AR model, but it also made
    our data and our eventual model a little less interpretable. It's harder to think
    about the log of a differenced time series than the time series itself. We had
    a justification for this trade-off here, but the trade-off should be noted, and
    the hope is to avoid such obfuscations where we can.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用差分和对数变换来转换我们的数据。这使我们能够满足AR模型的前提假设，但它也使得我们的数据和最终模型变得稍微难以解释。与时间序列本身相比，思考差分时间序列的对数更困难。我们在这里有这个权衡的合理性，但这个权衡应该被注意，希望我们能在可能的情况下避免这种混淆。
- en: Analyzing the ACF and choosing an AR order
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析自相关函数并选择AR阶数
- en: Now that we have a stationary series that fits within the assumptions of our
    model, let's revisit our ACF and PACF plots to see what has changed. We can utilize
    the same code that we used to plot the ACF and PACF previously, but this time
    we will use our transformed series.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个符合我们模型假设的平稳序列，让我们重新审视我们的ACF和PACF图，看看有什么变化。我们可以利用之前用来绘制ACF和PACF的相同代码，但这次我们将使用我们的转换序列。
- en: 'Here are the resulting ACF plot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是生成的ACF图：
- en: '![](img/8756cb7f-fb4e-4a2b-a9ce-64eb930f59c3.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8756cb7f-fb4e-4a2b-a9ce-64eb930f59c3.png)'
- en: 'Here are the resulting PACF plot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是生成的PACF图：
- en: '![](img/0d3896c7-b4e8-402c-b6b9-6dbc589e7f7a.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d3896c7-b4e8-402c-b6b9-6dbc589e7f7a.png)'
- en: The first thing we notice is that the ACF plot no longer has a slow decay from
    *1.0* as the lags get larger and larger. The ACF plot decays and fluctuates around
    *0.0*. We will come back to the ACF in the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先注意到，随着滞后时间的增加，ACF图不再从*1.0*缓慢衰减。ACF图衰减并在*0.0*附近波动。我们将在下一节回到ACF。
- en: Next, we can see that the PACF also decays down to *0.0* and fluctuates around
    0.0 thereafter. To choose the order of our AR model, we want to examine where
    the PACF plot appears to cross the zero line for the first time. In our case,
    this appears to be after the second lag period, and thus, we might want to consider
    using an AR(2) model to model this time series auto-regressively.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到，PACF也衰减到*0.0*并在此之后围绕0.0波动。为了选择我们AR模型的阶数，我们想要检查PACF图首次似乎穿过零线的地方。在我们的例子中，这似乎是在第二个滞后期之后，因此，我们可能想要考虑使用AR(2)模型来模型这个时间序列的自回归。
- en: Fitting and evaluating an AR(2) model
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拟合和评估AR(2)模型
- en: 'We have already seen that PACF gives us the coefficients for various orders
    in our AR model. Taking advantage of this, we can get the coefficients for our
    first and second lag terms along with the intercept (or error term) in our model
    using a slightly modified version of the `pacf()` function shown in the following
    code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，PACF为我们AR模型中各种阶数的系数。利用这一点，我们可以通过以下代码中显示的`pacf()`函数的略微修改版本，获取我们模型中第一和第二滞后项的系数以及截距（或误差项）：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can then call this on our log differenced series to get our trained AR(2)
    model coefficients:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调用我们的对数差分序列以获取我们的训练AR(2)模型系数：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compiling and running this training gives us the following AR(2) formula for
    the log of the differenced passenger counts:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行此训练给出了以下关于差分乘客计数对数的AR(2)公式：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To evaluate this AR(2) model, we can calculate the **Mean Absolute Error** (**MAE**),
    similar to how we calculated it for linear regression models. Specifically, we
    will compute predicted passenger count values paired with our observed passenger
    count values, and then we will calculate the error and accumulate the MAE.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估这个AR(2)模型，我们可以计算**平均绝对误差**（**MAE**），类似于我们计算线性回归模型的方式。具体来说，我们将计算预测的乘客计数值与观察到的乘客计数值配对，然后计算误差并累计MAE。
- en: 'First, let''s calculate our transformed (log and differenced) predictions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们计算我们的转换（对数和差分）预测：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, in order to calculate our MAE, we need to transform these predictions
    back to normal passenger counts (such that we can compare them directly to our
    original time series). The reverse transform of our log and differenced data involves
    calculating cumulative sums in the transformed series, adding them back to the
    base series values, and then taking an exponential. This reverse transform, the
    accumulation of the MAE, and the aggregation of points to plot our observations
    and predictions is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了计算我们的MAE，我们需要将这些预测转换回正常的乘客计数（这样我们就可以直接与原始时间序列进行比较）。我们的对数和差分数据的反向转换涉及在转换序列中计算累积总和，将它们加回到基础序列值上，然后取指数。这个反向转换，MAE的累积，以及将点聚合以绘制我们的观察值和预测值的聚合如下：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, let''s output the MAE to stand out and save a line plot of the observed
    and predicted values:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们输出MAE以突出显示，并保存观察值和预测值的线图：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Compiling this and running it results in the following `MAE`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此代码并运行得到以下`MAE`：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you remember from our original visualization of this series, the passenger
    counts range from just above zero to just above 600\. Thus, an MAE of approximately
    355 is not super great. To get a more complete view of how our predictions and
    observations line up, however, let''s look at the plot generated by the preceding
    code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得我们最初对这个序列的可视化，乘客计数从略高于零到略高于600。因此，大约355的MAE并不是很好。然而，为了更全面地了解我们的预测和观察结果如何对齐，让我们看一下前面代码生成的图表：
- en: '![](img/770fe545-b8a4-4fa3-8517-a582b320c31e.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/770fe545-b8a4-4fa3-8517-a582b320c31e.png)'
- en: As you can see, our model overpredicts the number of air passengers, especially
    as time goes on. The model does exhibit some of the structure that is seen in
    the original data and it produces a similar trend. Yet, it appears that we may
    need a slightly more sophisticated model to more realistically represent this
    series.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的模型对航空乘客数量的预测过高，尤其是在时间推移的情况下。模型确实表现出了一些在原始数据中可以看到的结构，并产生了相似的趋势。然而，似乎我们需要一个稍微复杂一些的模型来更真实地表示这个序列。
- en: No model is perfect and we have tried a relatively simple time series model
    here. It's good that we tried to stick with a simple and interpretable model,
    but our evaluation results would probably motivate us to refactor our model in
    a real-world scenario. Refactoring is good! It means that we learned something.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 没有模型是完美的，我们在这里尝试了一个相对简单的时序模型。我们坚持使用简单且可解释的模型是好事，但我们的评估结果可能会激励我们在实际场景中重构我们的模型。重构是好事！这意味着我们学到了一些东西。
- en: Auto-regressive moving averages and other time series models
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自回归移动平均和其他时间序列模型
- en: The model that we tried earlier was a relatively simple pure auto-regressive
    model. However, we are not stuck with using auto-regression or pure auto-regression
    alone in our time series models. As with other classes of machine learning models
    covered in this book, there is a whole zoo of time series techniques, and we cannot
    cover them all here. However, we did want to mention a few notable techniques
    that you could explore as you follow up on this material.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前尝试的模型是一个相对简单的纯自回归模型。然而，我们并不局限于在时序模型中使用自回归或纯自回归。与其他在本书中涵盖的机器学习模型类别一样，存在一系列时序技术，我们无法在这里全部涵盖。然而，我们确实想提到一些值得探索的显著技术，您可以在跟进这些材料时探索它们。
- en: Auto-regressive models are often combined with models called **moving average
    models**. When these are combined, they are often referred to as **auto-regressive
    moving average** (**ARMA**) or **auto-regressive integrated moving average** (**ARIMA**)
    models. The moving average part of ARMA/ARIMA models allows you to capture the
    effects of things like white noise or other error terms in your time series, which
    would actually improve our AR(2) model for air passengers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归模型通常与称为**移动平均模型**的模型相结合。当这些模型结合在一起时，它们通常被称为**自回归移动平均**（**ARMA**）或**自回归积分移动平均**（**ARIMA**）模型。ARMA/ARIMA模型的移动平均部分允许你捕捉到时间序列中的白噪声或其他误差项的影响，这实际上可以改善我们为航空乘客建立的AR(2)模型。
- en: Unfortunately, at the time of writing this content, no out of the box package
    exists to perform ARIMA in Go. As mentioned earlier, the auto-regressive part
    is relatively easy, but the moving average fitting is slightly more complicated.
    This is another great place to jump in with contributions!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在撰写此内容时，没有现成的Go语言包可以执行ARIMA。如前所述，自回归部分相对简单，但移动平均拟合稍微复杂一些。这是一个很好的地方，可以跳进来做出贡献！
- en: There are also time series models that are outside of the realm of ARIMA models.
    For example, the **Holt-Winters method** attempts to capture seasonality in time
    series data via a forecast equation and three smoothing equations. There are preliminary
    implementations of the Holt-Winters method in `github.com/datastream/holtwinters`
    and `github.com/dgryski/go-holtwinters`. These likely need to be further maintained
    and productionized, but they serve as a starting point.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些时间序列模型超出了ARIMA模型的范围。例如，**Holt-Winters方法**试图通过预测方程和三个平滑方程来捕捉时间序列数据中的季节性。在`github.com/datastream/holtwinters`和`github.com/dgryski/go-holtwinters`中已有Holt-Winters方法的初步实现。这些可能需要进一步维护和产品化，但它们可以作为起点。
- en: Anomaly detection
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常检测
- en: As mentioned in the introduction to this chapter, we might not always be interested
    in forecasting a time series. We might want to detect anomalous behavior in a
    time series. For example, we might want to know when out of the ordinary bursts
    of traffic come across our network, or we may want an alert when out of the ordinary
    numbers of users are attempting certain things inside of our application. These
    events could be tied to security concerns or may just be used to adjust our infrastructure
    or application settings.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言所述，我们可能并不总是对预测时间序列感兴趣。我们可能想检测时间序列中的异常行为。例如，我们可能想知道异常流量爆发何时出现在我们的网络中，或者我们可能希望在应用程序内部有异常数量的用户尝试某些操作时收到警报。这些事件可能与安全相关，也可能只是用来调整我们的基础设施或应用程序设置。
- en: Thankfully, due to Go's history of usage in monitoring and infrastructure, there
    are a variety of Go-based options to detect anomalies in time series data. This
    tooling has been used in production to detect anomalous behavior while monitoring
    infrastructure and applications and, although there are more tools than can be
    mentioned here, I will highlight a couple.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，由于 Go 在监控和基础设施方面的历史应用，有各种基于 Go 的选项可以检测时间序列数据中的异常。这些工具已在生产环境中用于在监控基础设施和应用时检测异常行为，尽管这里无法提及所有工具，但我将突出介绍几个。
- en: First, the InfluxDB ([https://www.influxdata.com/](https://www.influxdata.com/))
    and Prometheus ([https://prometheus.io/](https://prometheus.io/)) ecosystems have
    a variety of options for anomaly detection. Both InfluxDB and Prometheus offer
    open source, Go-based time series databases and related tooling. They are useful
    to monitor infrastructure and applications, and they have widespread use both
    in the Go community and outside of the Go community. For example, if you are interested
    in using InfluxDB, you can use `github.com/nathanielc/morgoth` for anomaly detection.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，InfluxDB ([https://www.influxdata.com/](https://www.influxdata.com/)) 和 Prometheus
    ([https://prometheus.io/](https://prometheus.io/)) 生态系统在异常检测方面提供了多种选择。InfluxDB
    和 Prometheus 都提供了基于 Go 的开源时序数据库和相关工具。它们在监控基础设施和应用方面非常有用，在 Go 社区和非 Go 社区都有广泛的应用。例如，如果你对使用
    InfluxDB 感兴趣，你可以使用 `github.com/nathanielc/morgoth` 进行异常检测。
- en: This package implements the **Lossy Counting Algorithm** (**LCA**). On the Prometheus
    side, you could utilize a query-based approach as further discussed on [https://prometheus.io/blog/2015/06/18/practical-anomaly-detection/](https://prometheus.io/blog/2015/06/18/practical-anomaly-detection/).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此包实现了 **损失计数算法**（**LCA**）。在 Prometheus 方面，你可以利用基于查询的方法，如 [https://prometheus.io/blog/2015/06/18/practical-anomaly-detection/](https://prometheus.io/blog/2015/06/18/practical-anomaly-detection/)
    中进一步讨论的那样。
- en: There are a variety of standalone Go packages for anomaly detection as well,
    including `github.com/lytics/anomalyzer` and `github.com/sec51/goanomaly`. More
    specifically, `github.com/lytics/anomalyzer` implements a variety of tests to
    determine if an observation in your series is anomalous, including tests based
    on the cumulative distribution functions, bootstrap permutations, permuted rank-sums,
    relative magnitudes, and more.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，也有许多独立的 Go 包用于异常检测，包括 `github.com/lytics/anomalyzer` 和 `github.com/sec51/goanomaly`。更具体地说，`github.com/lytics/anomalyzer`
    实现了多种测试来确定你的序列中的观察值是否异常，包括基于累积分布函数、自举排列、排列秩和、相对幅度等测试。
- en: 'To detect anomalies with `github.com/lytics/anomalyzer`, we need to create
    some configurations and an `anomalyzer.Anomalyzer` value. Once we have done this,
    detecting an anomaly is as simple as calling the `Push()` method on the `anomalyzer.Anomalyzer`
    value, as shown in the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `github.com/lytics/anomalyzer` 检测异常，我们需要创建一些配置和一个 `anomalyzer.Anomalyzer`
    值。一旦完成这些，检测异常就像在 `anomalyzer.Anomalyzer` 值上调用 `Push()` 方法一样简单，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Compiling and running this anomaly detection yields the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行此异常检测会产生以下结果：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: References
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Time series statistics (ACF and PACF):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列统计（ACF 和 PACF）：
- en: 'How to use ACF: [https://coolstatsblog.com/2013/08/07/how-to-use-the-autocorreation-function-acf/](https://coolstatsblog.com/2013/08/07/how-to-use-the-autocorreation-function-acf/)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 ACF：[https://coolstatsblog.com/2013/08/07/how-to-use-the-autocorreation-function-acf/](https://coolstatsblog.com/2013/08/07/how-to-use-the-autocorreation-function-acf/)
- en: 'Identifying the number of AR or MA terms in an ARIMA model: [https://people.duke.edu/~rnau/411arim3.htm](https://people.duke.edu/~rnau/411arim3.htm)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ARIMA 模型中识别 AR 或 MA 项的数量：[https://people.duke.edu/~rnau/411arim3.htm](https://people.duke.edu/~rnau/411arim3.htm)
- en: 'Auto-regressive models:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归模型：
- en: 'A more mathematical introduction to AR models: [https://onlinecourses.science.psu.edu/stat501/node/358](https://onlinecourses.science.psu.edu/stat501/node/358)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对AR模型更数学化的介绍：[https://onlinecourses.science.psu.edu/stat501/node/358](https://onlinecourses.science.psu.edu/stat501/node/358)
- en: '`github.com/sajari/regression` docs: [https://godoc.org/github.com/sajari/regression](https://godoc.org/github.com/sajari/regression)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`github.com/sajari/regression` 文档：[https://godoc.org/github.com/sajari/regression](https://godoc.org/github.com/sajari/regression)'
- en: 'ARMA/ARIMA models:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ARMA/ARIMA模型：
- en: 'Introduction to ARIMA: [https://people.duke.edu/~rnau/411arim.htm](https://people.duke.edu/~rnau/411arim.htm)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARIMA简介：[https://people.duke.edu/~rnau/411arim.htm](https://people.duke.edu/~rnau/411arim.htm)
- en: 'Anomaly detection:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 异常检测：
- en: 'InfluxDB: [https://www.influxdata.com/](https://www.influxdata.com/)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: InfluxDB：[https://www.influxdata.com/](https://www.influxdata.com/)
- en: 'Prometheus: [https://prometheus.io/](https://prometheus.io/)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus：[https://prometheus.io/](https://prometheus.io/)
- en: '`github.com/lytics/anomalyzer` docs: [https://godoc.org/github.com/lytics/anomalyzer](https://godoc.org/github.com/lytics/anomalyzer)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`github.com/lytics/anomalyzer` 文档：[https://godoc.org/github.com/lytics/anomalyzer](https://godoc.org/github.com/lytics/anomalyzer)'
- en: '`github.com/sec51/goanomaly` docs: [https://godoc.org/github.com/sec51/goanomaly](https://godoc.org/github.com/sec51/goanomaly)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`github.com/sec51/goanomaly` 文档：[https://godoc.org/github.com/sec51/goanomaly](https://godoc.org/github.com/sec51/goanomaly)'
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Well, that was timely! We now know what time series data is, how to represent
    it in Go, how to make some forecasts, and how to detect anomalies in our time
    series data. These skills will come in useful anytime you are working with data
    that is changing with time, whether its data related to stock prices, or monitoring
    data related to your infrastructure.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这真是及时！我们现在知道了时间序列数据是什么，如何在Go中表示它，如何进行一些预测，以及如何在我们的时间序列数据中检测异常。这些技能在你处理随时间变化的数据时将非常有用，无论是与股价相关的数据，还是与你的基础设施相关的监控数据。
- en: In the next chapter, we will level up our Go-based machine learning by looking
    at a few advanced techniques, including neural networks and deep learning.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过查看一些高级技术，包括神经网络和深度学习，来提升我们的基于Go的机器学习水平。
