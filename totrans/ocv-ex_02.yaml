- en: Chapter 2. An Introduction to the Basics of OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After covering the installation of OpenCV on different operating systems in
    [Chapter 1](ch01.html "Chapter 1. Getting Started with OpenCV"), *Getting Started
    with OpenCV*, we are going to introduce the basics of OpenCV development in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create your project using CMake.
  prefs: []
  type: TYPE_NORMAL
- en: We will also introduce the image basic data structures, matrices, and other
    structures that are required in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to save our variables and data in files using the XML/YAML
    persistence OpenCV functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring projects with CMake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading/writing images from/to disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading videos and accessing camera devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main image structures (matrices)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other important and basic structures (vectors, scalars, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to basic matrix operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File storage operations with the XML/YAML persistence OpenCV API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic CMake configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To configure and check all the required dependencies of our project, we are
    going to use CMake; but it is not mandatory, so we can configure our project in
    any other tool or IDE such as Makefiles or Visual Studio. However, CMake is the
    most portable way to configure multiplatform C++ projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake uses configuration files called `CMakeLists.txt`, where the compilation
    and dependency processes are defined. For a basic project, based on an executable
    build from one source code file, a two-line `CMakeLists.txt` file is all that
    is needed. The file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line defines the minimum version of CMake required. This line is mandatory
    in our `CMakeLists.txt` file and allows you to use the `cmake` functionality defined
    from a given version defined in the second line; it defines the project name.
    This name is saved in a variable called `PROJECT_NAME`.
  prefs: []
  type: TYPE_NORMAL
- en: The last line creates an executable command (`add_executable()`) in the `main.cpp`
    file, gives it the same name as our project (`${PROJECT_NAME}`), and compiles
    our source code into an executable called `CMakeTest`, which we set as the project
    name.
  prefs: []
  type: TYPE_NORMAL
- en: The `${}` expression allows access to any variable defined in our environment.
    Then, we can use the `${PROJECT_NAME}` variable as an executable output name.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CMake allows you to create libraries, which are indeed used by the OpenCV build
    system. Factorizing the shared code among multiple applications is a common and
    useful practice in software development. In big applications or when the common
    code is shared in multiple applications, this practice is very useful.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we do not create a binary executable; instead, we create a compiled
    file that includes all the functions, classes, and so on, developed. We can then
    share this library file with the other applications without sharing our source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake includes the `add_library` function for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The lines starting with `#` add comments and are ignored by CMake.
  prefs: []
  type: TYPE_NORMAL
- en: The `add_library(Hello hello.cpp hello.h)` command defines our new library called,
    where `Hello` is the library name and `hello.cpp`, `hello.h` are the source files.
    We add the header file to allow IDEs such as Visual Studio to link to the header
    files.
  prefs: []
  type: TYPE_NORMAL
- en: This line will generate a shared file (So for OS X and Unix or `.dll` for Windows)
    or a static library (A for OS X and Unix or `.dll` for Windows), depending on
    our operating system or if it is a dynamic or static library.
  prefs: []
  type: TYPE_NORMAL
- en: '`target_link_libraries( executable Hello)` is the function that links our executable
    to the desired library; in our case, it''s the `Hello` library.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CMake has the ability to search our dependencies and external libraries, giving
    us the facility to build complex projects depending on external components in
    our projects and by adding some requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, the most important dependency is, of course, OpenCV, and we will
    add it to all our projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s understand the working of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line defines the minimum CMake version; the second line tells CMake
    to use the new behavior of CMake so that it can correctly recognize numbers and
    Booleans constants without dereferencing variables with such names. This policy
    was introduced in CMake 2.8.0, and CMake warns when the policy is not set to version
    3.0.2\. Finally, the last line defines the project title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is where we search for our OpenCV dependency. `FIND_PACKAGE` is the function
    that allows us to find our dependencies and the minimum version required if this
    dependency is required or optional. In this sample script, we look for OpenCV
    in version 3.0.0 or greater and it is a required package.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `FIND_PACKAGE` command includes all OpenCV submodules, but you can specify
    the submodules that you want to include in the project by making your application
    smaller and faster. For example, if we are going to work only with the basic OpenCV
    types and core functionalities, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If CMake does not find it, it returns an error and does not prevent us from
    compiling our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MESSAGE function shows a message on the terminal or CMake GUI. In our case,
    we will show the OpenCV version, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`${OpenCV_VERSION}` is a variable where CMake stores the OpenCV package version.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `include_directories()` and `link_directories()` add the header and the
    directory of the specified library to our environment. OpenCV''s CMake module
    saves this data in the `${OpenCV_INCLUDE_DIRS}` and `${OpenCV_LIB_DIR}` variables.
    These lines are not required in all platforms, such as Linux, because these paths
    are normally in the environment, but it''s recommended that you have more than
    one OpenCV version to choose from the correct link and include directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This last line creates the executable and links it to the OpenCV library, as
    we saw in the previous section, *Creating a library*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a new function in this piece of code called `SET`. This function creates
    a new variable and adds any value that we need to it. In our case, we set the
    SRC variable to the `main.cpp` value. However, we can add more and more values
    to the same variable, as shown in this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Making the script more complex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you a more complex script that includes subfolders,
    libraries, and executables, all in only two files and a few lines, as shown in
    this script.
  prefs: []
  type: TYPE_NORMAL
- en: It's not mandatory to create multiple `CMakeLists.txt` files because we can
    specify everything in the main `CMakeLists.txt` file. It is more common to use
    different `CMakeLists.txt` files for each project subfolder, making it more flexible
    and portable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example has a code structure folder that contains one folder for the `utils`
    library and the other for the `root` folder, which contains the main executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to define two `CMakeLists.txt` files: one in the `root` folder
    and the other in the `utils` folder. The `CMakeLists.txt` root folder file has
    the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Almost all the lines are described in the previous sections except for some
    functions that we will explain in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: The `add_subdirectory()` tells CMake to analyze the `CMakeLists.txt` of a desired
    subfolder.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue with an explanation of the main `CMakeLists.txt` file, we
    will explain the `utils CMakeLists.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CMakeLists.txt` file in the `utils` folder, we will write a new library
    to include it in our main project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This CMake script file defines an `UTILS_LIB_SRC` variable where we add all
    the source files included in our library, generate the library with the `add_library`
    function, and use the `target_include_directories` function to allow our main
    project to detect all header files.
  prefs: []
  type: TYPE_NORMAL
- en: Leaving out the `utils` subfolder and continuing with the root `cmake` script,
    the Option function creates a new variable—in our case, `WITH_LOG`, with a small
    description attached. This variable can be changed via the `ccmake` command line
    or CMake GUI interface, where the description and a checkbox appears that allow
    users to enable or disable this option.
  prefs: []
  type: TYPE_NORMAL
- en: This function is very useful and allows the user to decide about compile-time
    features such as enabling or disabling logs, compiling with Java or Python support
    as with OpenCV, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we use this option to enable a logger in our application. To enable
    the logger, we use a precompiler definition in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To tell our compiler that we require the `LOG` compile time definition, we
    use the `add_definitions(-DLOG)` function in our `CMakeLists.txt`. To allow the
    user to decide whether they want to enable it or not, we only have to verify whether
    the `WITH_LOG` CMake variable is checked or not with a simple condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to create our CMake script files to be compiled in any operating
    system our Computer Vision projects. Then, we will continue with the OpenCV basics
    before we start with a sample project.
  prefs: []
  type: TYPE_NORMAL
- en: Images and matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important structure in a Computer Vision is without any doubt the images.
    The image in Computer Vision is a representation of the physical world captured
    with a digital device. This picture is only a sequence of numbers stored in a
    matrix format, as shown in the following image. Each number is a measurement of
    the light intensity for the considered wavelength (for example, red, green, or
    blue in color images) or for a wavelength range (for panchromatic devices). Each
    point in an image is called a pixel (for a picture element), and each pixel can
    store one or more values depending on whether it is a gray, black, or white image
    (called a binary image as well) that stores only one value, such as 0 or 1, a
    gray-scale-level image that can store only one value, or a color image that can
    store three values. These values are usually integer numbers between 0 and 255,
    but you can use the other range. For example, 0 to 1 in a floating point numbers
    such as **HDRI** (**High Dynamic Range Imaging**) or thermal images.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images and matrices](img/B04283_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The image is stored in a matrix format, where each pixel has a position in
    it and can be referenced by the number of the column and row. OpenCV uses the
    `Mat` class for this purpose. In the case of a grayscale image, a single matrix
    is used, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images and matrices](img/B04283_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the case of a color image, as shown in the following image, we use a matrix
    of size width x height x number of colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images and matrices](img/B04283_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `Mat` class is not only used to store images, but also to store different
    types of arbitrarily sized matrices. You can use is it as an algebraic matrix
    and perform operations with it. In the next section, we are going to describe
    the most important matrix operations such as add, matrix multiplication, create
    a diagonal matrix, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: However, before that, it's important to know how the matrix is stored internally
    in the computer memory because it is always better to have efficient access to
    the memory slots instead of access to each pixel with the OpenCV functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In memory, the matrix is saved as an array or sequence of values ordered by
    columns and rows. The following table shows the sequence of pixels in the BGR
    image format:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Row 0 | Row 1 | Row 2 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Col 0 | Col 1 | Col 2 | Col 0 | Col 1 | Col 2 | Col 0 | Col 1 | Col 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Pixel 1 | Pixel 2 | Pixel 3 | Pixel 4 | Pixel 5 | Pixel 6 | Pixel 7 | Pixel
    8 | Pixel 9 |'
  prefs: []
  type: TYPE_TB
- en: '| B | G | R | B | G | R | B | G | R | B | G | R | B | G | R | B | G | R | B
    | G | R | B | G | R | B | G | R |'
  prefs: []
  type: TYPE_TB
- en: 'With this order, we can access any pixel, as shown in the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenCV functions are quite optimized for random access, but sometimes direct
    access to the memory (working with pointer arithmetic) is more efficient—for example,
    when we have access to all the pixels in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Reading/writing images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the introduction of this matrix, we are going to start with the basics
    of the OpenCV code. Firstly, we need to learn how to read and write images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to understand this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, we have to include the declarations of the functions that we need in
    our sample. These functions come from core (basic image data handling) and high-gui
    (the cross-platform I/O functions provided by OpenCV are `core` and `highui`.
    The first includes the basic classes, such as matrices, and the second includes
    the functions to read, write, and show images with graphical interfaces).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The **imread** is the main function used to read images. This function opens
    an image and stores the image in a matrix format. The `imread` function accepts
    two parameters: the first parameter is a string that contains the image''s path,
    and the second parameter is optional and, by default, loads the image as a color
    image. The second parameter allows the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CV_LOAD_IMAGE_ANYDEPTH`: If set to this constant, returns a 16-bit/32-bit
    image when the input has the corresponding depth; otherwise, the `imread` function
    converts it to an 8-bit image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CV_LOAD_IMAGE_COLOR`: If set to this constant, always converts the image to
    color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CV_LOAD_IMAGE_GRAYSCALE`: If set to this constant, always converts the image
    to grayscale'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To save images, we can use the `imwrite` function, which stores a matrix image
    in our computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is the path where we want to save the image with the extension
    format that we desire. The second parameter is the matrix image that we want to
    save. In our code sample, we create and store a gray version of the image and
    then save it as a jpg file the gray image that we loaded and store in `gray` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `.cols` and `.rows` attributes of a matrix, we can access the number
    of columns and rows of an image—or in other words, the width and height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To access one pixel of an image, we use the `cv::Mat::at<typename t>(row,col)`
    template function from the `Mat` OpenCV class. The template parameter is the desired
    return type. A `typename` in an 8-bit color image is a `Vec3b` class that stores
    three unsigned char data (Vec=vector, 3=number of components, and b = 1 byte).
    In the case of the gray image, we can directly use the unsigned char or any other
    number format used in the image, such as `uchar pixel= color.at<uchar>(myRow,
    myCol)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Finally, to show the images, we can use the `imshow` function that creates a
    window with a title as the first parameter and the image matrix as the second
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want to stop our application by waiting for the user to press a key, we
    can use the OpenCV `waitKey` function with a parameter set to the number of milliseconds
    we want to wait. If we set the parameter to `0`, then the function will wait forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this code is shown in the following picture; the left-hand image
    is a color image and right-hand image is a gray scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading/writing images](img/B04283_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, as an example for the following samples, we are going to create the
    `CMakeLists.txt` to allow you to compile our project and also see how to compile
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code describes the `CMakeLists.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile our code, using the `CMakeLists.txt` file we have to perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `build` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `build` folder, execute `cmake` or open the `CMake gui` app in Windows,
    choose the source folder and build folder, and click on the Configure and Generate
    buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After step 2, if we are in Linux or OS, generate a `makefile`; then we have
    to compile the project using the make command. If we are in Windows, we have to
    open the project with the editor that we selected in step 2 and compile it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After step 3, we have an executable called `app`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reading videos and cameras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section introduces you to reading a video and camera with this simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we explain how to read video or camera inputs, we need to introduce
    a useful new class that will help us manage the input command line parameters;
    this new class was introduced in OpenCV version 3.0 and is called the `CommandLineParser`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that we have to do for a command-line parser is define the
    parameters that we need or allow in a constant char vector; each line has this
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `name_param` can be preceded with `@`, which defines this parameter as
    a default input. We can use more than one `name_param`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor will get the inputs of the main function and the key constants
    defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.has` class method checks the parameter''s existence. In this sample,
    we check whether the user has added the `–help` or ? `parameter`, and then, use
    the `printMessage` class function to show all the description parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `.get<typename>(parameterName)` function, we can access and read any
    of the input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After getting all the required parameters, we can check whether these parameters
    are parsed correctly and show an error message if one of the parameters is not
    parsed. For example, add a string instead of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The class to read a video and camera is the same. The `VideoCapture` class belongs
    to the `videoio` submodel instead of the `highgui` submodule, as in the former
    version of OpenCV. After creating the object, we check whether the input command
    line `videoFile` parameter has a path filename. If it's empty, then we try to
    open a web camera and, if it has a filename, then we open the video file. To do
    this, we use the open function, giving the video filename or the index camera
    that we want to open as a parameter. If we have a single camera, we can use `0`
    as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether we can read the video filename or the camera, we use the `isOpened`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we create a window to show the frames with the `namedWindow` function
    and, with a non-finish loop, we grab each frame with the `>>` operation and show
    the image with the `imshow` function, if we correctly retrieve the frame. In this
    case, we don't want to stop the application, but we want to wait for 30 milliseconds
    to check whether users want to stop the application execution with any key using
    `waitKey(30)`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To choose a good value to wait for the next frame, using a camera access is
    calculated from the speed of the camera. For example, if a camera works at 20
    FPS, a great wait value is *40 = 1000/20*.
  prefs: []
  type: TYPE_NORMAL
- en: When the user wants to finish the app, he has to only press a key, and then
    we have to release all the video resources using the `release` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very important to release all the resources that we use in a Computer
    Vision application; if we do not do it, we can consume all the RAM memory. We
    can release the matrices with the `release` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the code is a new window that shows a video or web camera in
    the BGR format, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading videos and cameras](img/B04283_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Other basic object types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned about the Mat and Vec3b classes, but we need to learn about
    other classes as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will learn about the most basic object types required in
    most of the projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Vec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scalar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Point`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Size`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rect`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RotatedRect`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vec object type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`vec` is a template class that is used mainly for numerical vectors. We can
    define any type of vectors and a number of components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can use any of the predefined types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All the expected vector operations are also implemented, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1 = v2 + v3`'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1 = v2 - v3`'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1 = v2 * scale`'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1 = scale * v2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1 = -v2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1 += v2` and other augmenting operations'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1 == v2, v1 != v2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`norm(v1) (euclidean norm)`'
  prefs: []
  type: TYPE_NORMAL
- en: The Scalar object type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Scalar` object type is a template class derived from Vec with four elements.
    The `Scalar` type is widely used in OpenCV to pass and read pixel values.
  prefs: []
  type: TYPE_NORMAL
- en: To access the values of `Vec` and `Scalar`, we use the [] operator.
  prefs: []
  type: TYPE_NORMAL
- en: The Point object type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another very common class template is `Point`. This class defines a 2D point
    specified by its `x` and `y` coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like the Point object type, there is a Point3 template class for 3D point support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the `Vec` class, OpenCV defines the following `Point` aliases for our
    convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following operators are defined for points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The Size object type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another `template` class that is very important and used in OpenCV is the `template`
    class used to specify the size of an image or rectangle, Size. This class adds
    two members: the width and height and a useful `area()`function.'
  prefs: []
  type: TYPE_NORMAL
- en: The Rect object type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Rect` is another important template class used to define 2D rectangles by
    the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The coordinates of the top-left corner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The width and height of a rectangle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Rect` template class can be used to define a **ROI** (**region of interest**)
    of an image.
  prefs: []
  type: TYPE_NORMAL
- en: RotatedRect object type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last useful class is a particular rectangle called `RotatedRect`. This
    class represents a rotated rectangle specified by a center point, the width and
    height of a rectangle, and the rotation angle in degrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting function of this class is `boundingBox`; this function returns
    a `Rect` that contains the rotated rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![RotatedRect object type](img/B04283_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Basic matrix operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn some basic and important matrix operations that
    we can apply to images or any matrix data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned how to load an image and store it in a `Mat` variable, but we can
    manually create a Mat variable. The most common constructor that provides the
    matrix size and type is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create a new `Matrix link` with a stored buffer from third-party libraries,
    without copying the data, using the following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The supported types depend on the type of the number you want to store and
    the number of channels. The most common types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can create any type of a matrix using `CV_number_typeC(n)`, where `number_type`
    is 8U (8 bits unsigned) to 64F (64 float) and (n) is the number of channels. The
    number of channels allowed is from `1` to `CV_CN_MAX`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This initialization does not set up the data values and you can get undesirable
    values. To avoid undesirable values, you can initialize the matrix with `zeros`
    or `ones` values with the `zeros` or `ones` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding matrix is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic matrix operations](img/B04283_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A special matrix initialization is the **eye** function that creates an `identity`
    matrix with the specified type (`CV_8UC1, CV_8UC3…`) and size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic matrix operations](img/B04283_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All matrix operations are allowed in the OpenCV Mat class. We can add or subtract
    two matrices with `+` and `-` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of the previous operations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic matrix operations](img/B04283_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can multiply a matrix by a scalar with the `*` operator, a matrix per element
    matrix with the `mul` function, or a matrix by matrix multiplication with `*`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of the previous operations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic matrix operations](img/B04283_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The other common mathematical matrix operations are transposition and matrix
    inversion, defined by the `t()` and `inv()` functions, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other interesting functions that OpenCV provides us with are array operations
    in a matrix; for example, count the non-zero elements. This is useful to count
    the pixels or area of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'OpenCV provides some statistical functions. The mean and standard deviation
    by channel can be calculated using the `meanStdDev` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The other useful statistical function is `minMaxLoc`. This function finds the
    minimum and the maximum of a matrix or array and returns its location and value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, `src` is the input matrix, `minVal` and `maxVal` are double values detected,
    and `minLoc` and `maxLoc` are point values detected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other core and useful functions are described in detail at [http://docs.opencv.org/modules/core/doc/core.html](http://docs.opencv.org/modules/core/doc/core.html).
  prefs: []
  type: TYPE_NORMAL
- en: Basic data persistence and storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish this chapter, we will explore the OpenCV functions to store
    and read our data. In many applications, such as calibration or machine learning,
    when we are done with the calculations, we need to save the results in order to
    retrieve them in the next executions. For this purpose, OpenCV provides an XML/YAML
    persistence layer.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a file storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write a file with some OpenCV data or other numeric data, we can use the
    `FileStorage` class using the streaming c operator such as STL streaming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a file storage where we save the data, we only need to call the constructor
    by giving a path filename with the desired extension format (XML or YAML) with
    the second parameter set to `write`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to save the data, we only need to use the stream operator by giving
    an identifier in the first stage and the matrix or value that we want to save
    in the later stage. For example, to save an `int`, we need to write the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'A `mat` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code is in YAML format, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading from a saved file previously is very similar to save functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we have to open a saved file with the `FileStorage` constructor using
    the appropriate path and `FileStorage::READ` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To read any stored variable, we only need to use the common `>>` stream operator
    using our `FileStorage` object and the identifier with the `[]` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basics of how to access images and videos and
    how they are stored in matrices.
  prefs: []
  type: TYPE_NORMAL
- en: We learned the basic matrix operations and other basic OpenCV classes to store
    pixels, vectors, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to save our data in files to allow them to be read in
    other applications or executions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to create our first application by learning
    the basics of a Graphical User Interface that OpenCV gives us. We will create
    buttons and sliders and introduce some image processing basics.
  prefs: []
  type: TYPE_NORMAL
