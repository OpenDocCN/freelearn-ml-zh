<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Quantifying Learning Algorithms</h1>
                </header>
            
            <article>
                
<p>We have stepped into an era where we are building smart or intelligent machines. This smartness or intelligence is infused into the machine with the help of smart algorithms based on mathematics/statistics. These algorithms enable the system or machine to learn automatically without any human intervention. As <span>an example of this, today we are surrounded by a number of mobile applications. One of the prime messaging apps of today in WhatsApp (currently owned by Facebook). Whenever we type a message into a textbox of WhatsApp, and we type, for example, <em>I am...</em>, we get a few word prompts popping up, such as <em>..going home</em>, <em>Rahul</em>, <em>traveling tonight</em>, and so on. Can we guess what's happening here and why?</span> Multiple questions come up:</p>
<ul>
<li>What is it that the system is learning?</li>
<li>Where does it learn from?</li>
<li>How does it learn?</li>
</ul>
<p>Let's answer all these questions in this chapter.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Statistical models</li>
<li>Learning curves</li>
<li>Curve fitting</li>
<li>Modeling cultures</li>
<li>Overfitting and regularization</li>
<li>Train, validation, and test</li>
<li>Cross-validation and model selection</li>
<li>Bootstrap method</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Statistical models</h1>
                </header>
            
            <article>
                
<p>A statistical model is the approximation of the truth that has been captured through data and mathematics or statistics, and acts as an enabler here. This approximation is used to predict an event. A statistical model is nothing but a mathematical equation. </p>
<p>For example, let's say we reach out to a bank for a home loan. What does the bank ask us? The first thing they would ask us to do is furnish lots of documents such as salary slips, identity proof documents, documents regarding the house we are going to purchase, a utility bill, the number of current loans we have, the number of dependants we have, and so on. All of these documents are nothing but the data that the bank would use to assess and check our creditworthiness:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/50ec8721-c5e9-49c9-8a58-f60aacf91fa8.png" style="width:30.67em;height:1.33em;"/></p>
<p>What this means is that your creditworthiness is a function of the salary, number of loans, number of dependants, and so on. We can arrive at this equation or relationship mathematically.</p>
<div class="packt_tip packt_infobox">A statistical model is a mathematical equation that arrives at using given data for a particular business scenario.</div>
<p>In the next section, we will see how models learn and how the model can keep getting better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning curve</h1>
                </header>
            
            <article>
                
<p>The basic premise behind the learning curve is that the more time you spend doing something, the better you tend to get. Eventually, the time to perform a task keeps on plummeting. This is known by different names, such as <strong>improvement curve</strong>, <strong>progress curve</strong>, and <strong>startup function</strong>.</p>
<p>For example, when you start learning to drive a manual car, you undergo a learning cycle. Initially, you are extra careful about operating the break, clutch, and gear. You have to keep reminding yourself when and how to operate these components.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>But, as the days go by and you continue practicing, your brain gets accustomed and trained to the entire process. With each passing day, your driving will keep getting smoother and your brain will react to the situation without any realization. This is called <strong>subconscious intelligence</strong>. You reach this stage with lots of practice and transition from a conscious intelligence to a subconscious intelligence that has got a cycle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Machine learning</h1>
                </header>
            
            <article>
                
<p><span>Let me define machine learning and its components so that you don't get bamboozled by lots of jargon when it gets thrown at you.</span></p>
<p>In the words of Tom Mitchell, "<span><em>A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E</em>."</span> <span>Also, another theory says that machine learning is the field that gives computers the ability to learn without being explicitly programmed.</span></p>
<p>For example, if a computer has been given cases such as, <em>[(father, mother), (uncle, aunt), (brother, sisters)]</em>, based on this, it needs to find out <em>(son, ?)</em>. That is, given son, what will be the associated item? To solve this problem, a computer program will go through the previous records and try to understand and learn the association and pattern out of these combinations as it hops from one record to another. This is called <strong>learning</strong>, and it takes place through algorithms. With more records, that is, more experience, the machine gets smarter and smarter.</p>
<p>Let's take a look at the different branches of machine learning, as indicated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-807 image-border" src="assets/171db42c-de53-4ce2-9ec5-5acda2329ca5.png" style="width:28.25em;height:11.50em;"/></p>
<p>We will explain the preceding <span>diagram </span>as follows:</p>
<ul>
<li><strong>Supervised learning</strong>: In this type of learning, both the input variables and output variables are known to us. Here, we are supposed to establish a relationship between the input variables and the output, and the learning will be based on that. There are two types of problems under it, as follows:
<ul>
<li><strong>Regression problem</strong>: It has got a continuous output. For example, a housing price dataset wherein the price of the house needs to be predicted based on input variables such as area, region, city, number of rooms, and so on. The price to be predicted is a continuous variable.</li>
<li><strong>Classification</strong>: It has got a discrete output. For example, the prediction that an employee would leave an organization or not, based on salary, gender, the number of members in their family, and so on.</li>
</ul>
</li>
<li><strong>Unsupervised learning</strong>: In this type of scenario, there is no output variable. We are supposed to extract a pattern based on all the variables given. For example, the segmentation of customers based on age, gender, income, and so on.</li>
<li><strong>Reinforcement learning</strong>: This<span> is an area of machine learning wherein suitable action is taken to maximize reward. For example, training a dog to catch a ball and give it—we reward the dog if they carry out this action; otherwise, we tell them off, leading to a punishment.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wright's model</h1>
                </header>
            
            <article>
                
<p>In Wright's model, the learning curve function is defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/f534dff2-a5c4-4f11-b694-b14f97180b55.png" style="width:5.08em;height:1.42em;"/></p>
<p>The variables are as follows:</p>
<ul>
<li><span><em>Y</em>: The cumulative average time per unit</span></li>
<li><span><em>X</em>: The cumulative number of units produced</span></li>
<li><span><em>a</em>: Time required to produce the first unit</span></li>
<li><span><em>b</em>: Slope of the function when plotted on graph paper</span><em> (log of the learning rate/log of 2)</em></li>
</ul>
<p>The following curve has got a vertical axis (<em>y</em> axis) representing the learning with respect to a particular work and a horizontal axis that corresponds to the time taken to learn. A learning curve with a steep beginning can be comprehended as a sign of rapid progress. The following diagram shows <strong>Wright's Learning Curve Model</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-795 image-border" src="assets/f10a6a22-e064-4c82-9f37-ebe5f7384a35.png" style="width:20.67em;height:17.75em;"/></p>
<p>However, the question that arises is, <em>How is it connected to machine learning?</em> We will discuss this in detail now.</p>
<p>Let's discuss a scenario that happens to be a supervised learning problem by going over the following steps:</p>
<ol>
<li>We take the data and partition it into a training set (on which we are making the system learn and come out as a model) and a validation set (on which we are testing how well the system has learned).</li>
<li>The next step would be to take one instance (observation) of the training set and make use of it to estimate a model. The model error on the training set will be 0.</li>
<li>Finally, we would find out the model error on the validation data.</li>
</ol>
<p><em>Step 2</em> and <em>Step 3</em> are repeated by taking a number of instances (training size) such as 10, 50, and 100 and studying the training error and validation error, as well as their relationship with a number of instances (training size). This curve—or the relationship—is called a <strong>l</strong><strong>earning curve</strong> in a machine learning scenario.</p>
<p class="mce-root"/>
<p>Let's work on a combined power plant dataset. The f<span>eatures comprised hourly average ambient variables, that is, <strong>temperature</strong> (<strong>T</strong>), <strong>ambient pressure</strong> (<strong>AP</strong>), <strong>relative humidity</strong> (<strong>RH</strong>), and exhaust <strong>vacuum</strong> (<strong>V</strong>), to predict the net hourly <strong>electrical energy output</strong> (<strong>PE</strong>) of the plant:</span></p>
<pre># importing all the libraries<br/>import pandas as pd<br/>from sklearn.linear_model import LinearRegression<br/>from sklearn.model_selection import learning_curve<br/>import matplotlib.pyplot as plt<br/><br/>#reading the data<br/>data= pd.read_excel("Powerplant.xlsx")<br/><br/>#Investigating the data<br/>print(data.info())<br/>data.head()</pre>
<p><span>From this, we are able to see the data structure of the variables in the data:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-792 image-border" src="assets/05d57d50-1764-4cb0-a172-83bb011dc055.png" style="width:20.75em;height:13.67em;"/></p>
<p>The output can be seen as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-808 image-border" src="assets/52260431-6fcc-4767-87d9-f47a04b70257.png" style="width:21.92em;height:7.67em;"/></p>
<p>The second output gives you a good feel for the data.</p>
<p>The dataset has five variables, where <strong>ambient temperature</strong> (<span><strong>AT</strong>)</span> and PE <span>(target variable).</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Let's vary the training size of the data and study the impact of it on learning. A list is created for <kbd>train_size</kbd> with varying training sizes, as shown in the following code:</p>
<pre># As discussed here we are trying to vary the size of training set<br/>train_size = [1, 100, 500, 2000, 5000]<br/>features = ['AT', 'V', 'AP', 'RH']<br/>target = 'PE'<br/># estimating the training score &amp; validation score<br/>train_sizes, train_scores, validation_scores = learning_curve(estimator = LinearRegression(), X = data[features],y = data[target], train_sizes = train_size, cv = 5,scoring ='neg_mean_squared_error')</pre>
<p>Let's generate the <kbd>learning_curve</kbd>:</p>
<pre><span># Generating the Learning_Curve<br/>train_scores_mean </span><span class="token operator">=</span><span> </span><span class="token operator">-</span><span>train_scores</span><span class="token punctuation">.</span><span>mean</span><span class="token punctuation">(</span><span>axis </span><span class="token operator">=</span><span> </span><span class="token number">1</span><span class="token punctuation">)</span><span> <br/>validation_scores_mean </span><span class="token operator">=</span><span> </span><span class="token operator">-</span><span>validation_scores</span><span class="token punctuation">.</span><span>mean</span><span class="token punctuation">(</span><span>axis </span><span class="token operator">=</span><span> </span><span class="token number">1</span><span class="token punctuation">)<br/><span class="token keyword">import</span><span> matplotlib</span>.<span>pyplot </span><span class="token keyword">as</span><span> plt <br/></span><span>plt</span>.<span>style</span>.<span>use</span>(<span class="token string">'seaborn'</span>)<span> <br/>plt</span>.<span>plot</span>(<span>train_sizes</span>,<span> train_scores_mean</span>,<span> label </span><span class="token operator">=</span><span> </span><span class="token string">'Train_error'</span>)<span> <br/>plt</span>.<span>plot</span>(<span>train_sizes</span>,<span> validation_scores_mean</span>,<span> label </span><span class="token operator">=</span><span> </span><span class="token string">'Validation_error'</span>)<span> <br/>plt</span>.<span>ylabel</span>(<span class="token string">'MSE'</span>,<span> fontsize </span><span class="token operator">=</span><span> </span><span class="token number">16</span>)<span> <br/>plt</span>.<span>xlabel</span>(<span class="token string">'Training set size'</span>,<span> fontsize </span><span class="token operator">=</span><span> </span><span class="token number">16</span>)<span> <br/>plt</span>.<span>title</span>(<span class="token string">'Learning_Curves'</span>,<span> fontsize </span><span class="token operator">=</span><span> 20</span>,<span> y </span><span class="token operator">=</span><span> </span><span class="token number">1</span>)<span> <br/>plt</span>.<span>legend</span>()<span> <br/></span><br/></span></pre>
<p>We get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-798 image-border" src="assets/0e15e0c1-657c-495d-a65f-14de600ca4fa.png" style="width:28.08em;height:20.58em;"/></p>
<p>From the preceding plot, we can see that when the training size is just 1, the training error is 0, but the validation error shoots beyond <strong>400</strong>.</p>
<p>As we go on increasing the training set's size (from 1 to 100), the training error continues rising. However, the validation error starts to plummet as the model performs better on the validation set. After the training size hits the 500 mark, the validation error and training error begin to converge. So, what can be inferred out of this? The performance of the model won't change, irrespective of the size of the training post. However, if you try to add more features, it might make a difference, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-791 image-border" src="assets/21d6445c-9045-477b-8f6b-6f8203070ac2.png" style="width:26.58em;height:23.75em;"/></p>
<p><span><span>The preceding diagram shows that the validation and training curve have converged, so adding training data will not help at all. However, in the following diagram, the curves haven't converged, so adding training data will be a good idea:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-793 image-border" src="assets/f6ec0074-8426-4428-b50a-f7d40b70373d.png" style="width:25.25em;height:21.83em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Curve fitting</h1>
                </header>
            
            <article>
                
<p>So far, we have learned about the learning curve and its significance. However, it only comes into the picture once we tried fitting a curve on the available data and features. But what does curve fitting mean? Let's try to understand this.</p>
<p>Curve fitting is nothing but establishing a relationship between a number of features and a target. It helps in finding out what kind of association the features have with respect to the target. </p>
<p>Establishing a relationship (curve fitting) is nothing but coming up with a mathematical function that should be able to explain the behavioral pattern in such a way that it comes across as a best fit for the dataset.</p>
<p>There are multiple reasons behind why we do curve fitting:</p>
<ul>
<li>To carry out system simulation and optimization</li>
<li>To determine the values of intermediate points (interpolation)</li>
<li>To do trend analysis (extrapolation)</li>
<li>To carry out hypothesis testing</li>
</ul>
<p>There are two types of curve fitting:</p>
<ol>
<li><strong>Exact fit</strong>: In this scenario, the curve would pass through all the points. There is no residual error (we'll discuss shortly what's classed as an error) in this case. For now, you can understand an error as the difference between the actual error and the predicted error. It can be used for interpolation and is majorly involved with a distribution fit. </li>
</ol>
<p style="padding-left: 60px">The following diagram shows the polynomial but exact fit:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-810 image-border" src="assets/324d5cff-68ea-43a5-9285-805f65773b79.png" style="width:18.25em;height:15.83em;"/></p>
<p style="padding-left: 60px">The following diagram shows the line but exact fit:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-800 image-border" src="assets/af0953fd-f87c-4546-a6f8-193044a707eb.png" style="width:17.00em;height:16.83em;"/></p>
<ol start="2">
<li class="CDPAlignLeft CDPAlign"><strong>Best fit</strong>: The curve doesn't pass through all the points. There will be a residual associated with this.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's look at some different scenarios and study them to understand these differences.</p>
<p>Here, we will fit a curve for two numbers:</p>
<pre># importing libraries<br/> import numpy as np<br/> import matplotlib.pyplot as plt<br/> from scipy.optimize import curve_fit<br/><br/># writing a function of Line<br/> def func(x, a, b):<br/> return a + b * x <br/> x_d = np.linspace(0, 5, 2) # generating 2 numbers between 0 &amp; 5<br/> y = func(x_d,1.5, 0.7) <br/> y_noise = 0.3 * np.random.normal(size=x_d.size)<br/> y_d = y + y_noise<br/> plt.plot(x_d, y_d, 'b-', label='data')<br/> <br/> popt, pcov = curve_fit(func, x_d, y_d) # fitting the curve<br/> plt.plot(x_d, func(x_d, *popt), 'r-', label='fit')</pre>
<p>From this, we will get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-806 image-border" src="assets/e4a9a050-461b-4b09-9b31-ac5dd5c9602e.png" style="width:31.25em;height:21.00em;"/></p>
<p>Here, we have used two points to fit the line and we can very well see that it becomes an <strong>exact fit</strong>. When introducing three points, we will get the following:</p>
<pre> x_d = np.linspace(0, 5, 3) # generating 3 numbers between 0 &amp; 5</pre>
<p class="mce-root"/>
<p>Run the entire code and focus on the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-799 image-border" src="assets/c682382b-fb8a-4d93-abc0-99925922b1b8.png" style="width:25.75em;height:17.25em;"/></p>
<p>Now, you can see the drift and effect of noise. It has started to take the shape of a curve. A line might not be a good fit here (however, it's too early to say). It's no longer an exact fit.</p>
<p>What if we try to introduce 100 points and study the effect of that? By now, we know how to introduce the number of points.</p>
<p>By doing this, we get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-789 image-border" src="assets/ef332a8e-1123-44ca-bade-917751904b26.png" style="width:26.00em;height:17.42em;"/></p>
<p>This is not an exact fit, but rather a best fit that tries to generalize the whole dataset.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Residual</h1>
                </header>
            
            <article>
                
<p><span>Residuals are the difference between an observed or true value and a predicted (fitted) value. For example, in the following diagram, one of the residuals is </span><strong>(A-B)</strong><span>, where </span><strong>A</strong><span> is the observed value and </span><strong>B</strong><span> is the fitted value:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-786 image-border" src="assets/554e01db-d173-45cc-a834-039d7a111e50.png" style="width:26.00em;height:21.83em;"/></p>
<p>The preceding scatter plot depicts that we are fitting a line that could represent the behavior of all the data points. However, one thing that's noticeable is that the line doesn't pass through all of the poi<span>nts</span><span>. Most of the points are off the line.</span></p>
<div class="packt_tip">The sum and mean of residuals will always be 0. <em>∑e =0</em> and mean of <em>e =0</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Statistical modeling – the two cultures of Leo Breiman</h1>
                </header>
            
            <article>
                
<p>Whenever we try to analyze data and finally make a prediction, there are two approaches that we consider, both of which were discovered by Leo Breiman, a Berkeley professor, in his paper titled <em>Statistical Modeling: Two Cultures</em> in 2001.</p>
<p>Any analysis needs data. An analysis can be as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-803 image-border" src="assets/5fa263dc-3aee-4d76-a18c-216f46278c34.png" style="width:25.58em;height:5.58em;"/></p>
<p>A vector of <strong>X</strong> (<strong>Features</strong>) undergoes a nature box, which translates into a response. A nature box tries to establish a relationship between <strong>X</strong> and <strong>Y</strong>. Typically, there are goals pertaining to this analysis, as follows:</p>
<ul>
<li><strong>Prediction</strong>: To predict the response with the future input features</li>
<li><strong>Information</strong>: To find out and understand the association between the response and driving input variables</li>
</ul>
<p>Breiman states that, when it comes to solving business problems, there are two distinct approaches:</p>
<ul>
<li><strong>The data modeling culture</strong>: In this kind of model, nature takes the shape of a stochastic model that estimates the necessary parameters. Linear regression, logistic regression, and the Cox model usually act under the nature box. This model talks about observing the pattern of the data and <span>looks to design an approximation of what is being observed. Based on their experience, the scientist or a statistician would decide which model to be used. It is the case of a model coming before the problem and the data, the solutions from this model is more towards the model's architecture. Breiman says that over-reliance on this kind of approach doesn't help the statisticians cater to a diverse set of problems. When it comes to finding out solutions pertaining to earthquake prediction, rain prediction, and global warming causes, it doesn't give accurate results, since this approach doesn't focus on accuracy, and instead focuses on the two goals.</span></li>
<li><strong>The algorithm modeling culture</strong>: In this approach, pre-designed algorithms are used to make a better approximation. Here, the algorithms use complex mathematics to reach out to the conclusion and acts inside the nature box. With better computing power and using these models, it's easy to replicate the driving factors as the model keeps on running until it learns and understands the pattern that drives the outcome. It enables us to address more complex problems, and emphasizes more on accuracy. With more data coming through, it can give a much better result than the data modeling culture.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Training data development data – test data</h1>
                </header>
            
            <article>
                
<p>This is one of the most important steps of building a model and it can lead to lots of debate regarding whether we really need all three sets (train, dev, and test), and if so, what should be the breakup of those datasets. Let's understand these concepts.</p>
<p>After we have sufficient data to start modelling, the first thing we need to do is partition the data into three segments, that is, <strong>Training <span>Set</span></strong>, <strong>Development</strong> <span><strong>Set</strong>, </span>and <strong>Test Set</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-794 image-border" src="assets/936279c1-3f92-41cf-ae3c-751f3f5afc0f.png" style="width:31.00em;height:2.50em;"/></p>
<p>Let's examine the goal of having these three sets:</p>
<ol>
<li><strong>Training Set</strong>:<strong> </strong>The training set is used to train the model. When we apply any algorithm, we are fitting the parameter in the training set. In the case of a neural network, finding out about the weights takes place.</li>
</ol>
<p style="padding-left: 60px">Let's say in one scenario that we are trying to fit polynomials of various degrees:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><em>f(x) = a+ bx</em> → 1<sup>st</sup> degree polynomial</li>
<li><em>f(x) = a + bx + cx<sup>2</sup></em> <span>→</span> 2<sup>nd</sup> degree polynomial</li>
<li><em>f(x) = a + bx + cx<sup>2 </sup>+ dx<sup>3</sup></em> <span>→ </span>3<sup>rd</sup> degree polynomial</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">After fitting the model, we calculate the training error for all the fitted models:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/4fb00d4e-01ed-4227-9e89-bd91428ee696.png" style="width:32.83em;height:1.42em;"/></p>
<p style="padding-left: 60px">We cannot assess how good the model is based on the training error. If we do that, it will lead us to a biased model that might not be able to perform well on unseen data. To counter that, we need to head into the development set.</p>
<ol start="2">
<li><strong>Development</strong> <strong>set</strong>: This is also called the <strong>holdout set</strong> or <strong>validation set</strong>. The goal of this set is to tune the parameters that we have got from the training set. It is also part of an assessment of how well the model is performing. Based on its performance, we have to take steps to tune the parameters. For example, controlling the learning rate, minimizing the overfitting, and electing the best model of the lot all take place in the development set. Here, again, the development set error gets calculated and tuning of the model takes place after seeing which model is giving the least error. The model giving the least error at this stage still needs tuning to minimize overfitting. Once we are convinced about the best model, it is chosen and we head toward the test set.</li>
</ol>
<ol start="3">
<li><strong>Test set</strong>: The test set is primarily used to assess the best selected model. At this stage, the accuracy of the model is calculated, and if the model's accuracy is not too deviated from the training accuracy and development accuracy, we send this model for deployment.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Size of the training, development, and test set</h1>
                </header>
            
            <article>
                
<p>Typically, machine learning practitioners choose the size of the three sets in the ratio of 60:20:20 or 70:15:15. However, there is no hard and fast rule that states that the development and test sets should be of equal size. The following diagram shows the different sizes of the training, development, and test sets:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-805 image-border" src="assets/9123ff4d-f4ae-454d-9636-21f3f0f47e60.png" style="width:37.17em;height:4.33em;"/></p>
<p>Another example of the three different sets is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-790 image-border" src="assets/badde5d1-a170-4982-80a6-f8bb01bdc94c.png" style="width:36.25em;height:4.33em;"/></p>
<p>But what about the scenarios where we have big data to deal with? For example, if we have 10,000,000 records or observations, how would we partition the data? In such a scenario, ML practitioners take most of the data for the training set—as much as 98-99%—and the rest gets divided up for the development and test sets. This is done so that the practitioner can take different kinds of scenarios into account. So, even if we have 1% of data for development and the same for the test test, we will end up with 100,000 records each, and that is a good number.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bias-variance trade off</h1>
                </header>
            
            <article>
                
<p>Before we get into modelling and try to figure out what the trade-off is, let's understand what bias and variance are from the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-996 image-border" src="assets/13bf10e0-73cb-42ad-afcb-acd933d0dda9.png" style="width:36.08em;height:9.92em;"/></p>
<p>There are two types of errors that are developed in the bias-variance trade off, as follows:</p>
<ul>
<li><strong>Training error</strong>: This is a measure of deviation of the fitted value from the actual value while predicting the output by using the training inputs. This error depends majorly on the model's complexity. As the model's complexity increases, the error appears to plummet.</li>
<li><strong>Development error</strong>: This is a measure of deviation of the predicted value, and is used by the development set as input (while using the same model trained on training data) from the actual values. Here, the prediction is being done on unseen data. We need to minimize this error. Minimizing this error will determine how good this model will be in the actual scenario.</li>
</ul>
<p>As the complexity of the algorithm keeps o<span>n increasing, the training error goes down. However, the development error or validation error keeps going down until a certain point, and then rises, as shown in the following diagram:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-796 image-border" src="assets/24f381ef-b08b-44e5-9e20-201ac3b1d0cf.png" style="width:33.33em;height:23.42em;"/></p>
<p>The preceding diagram can be explained as follows:</p>
<ul>
<li><strong>Underfitting</strong>: Every dataset has a specific pattern and properties due to the existing variables in the dataset. Along with that, it also has a random and latent pattern which is caused by the variables that are not part of the dataset. Whenever we come up with a model, the model should ideally be learning patterns from the existing variables. However, the learning of these patterns also depends on how good and robust your algorithm is. Let's say we have picked up a model that is not able to derive even the essential patterns out of the dataset—<span>this is</span> called <strong>underfitting</strong>. In the preceding plots, it is a scenario of classification and we are trying to classify <em>x</em> and <em>o</em>. In plot 1, we are trying to use a linear classification algorithm to classify the data, but we can see that it is resulting in lots of misclassification errors. This is a case of underfitting.</li>
<li><strong>Overfitting</strong>: Going further afield from plot 1, we are trying to use complex algorithms to find out the patterns and classify them. It is noticeable that the misclassification errors have gone down in the second plot, since the complex model being used here is able to detect the patterns. The development error (as shown in the preceding diagram) goes down too. We will increase the complexity of the model and see what happens. Plot 3 suggests that there is no misclassification error in the model now. However, if we look at the plot below it, we can see that the development error is way too high now. This happens because the model is learning from the misleading and random patterns that were exhibited due to the non-existent variables in the dataset. This means that it has started to learn the noise that's present in the set. This phenomenon is called <strong>overfitting</strong>.</li>
<li><strong>Bias</strong>: How often have we seen this? This occurs in a situation wherein we have used an algorithm and it doesn't fit properly. This means that the function that's being used here has been of little relevance to this scenario and it's not able to extract the correct patterns. This causes an error called <strong>bias</strong>. It crops up majorly due to making a certain assumption about the data and using a model that might be correct but isn't. For example, if we had to use a second degree polynomial for a situation, we would use simple linear regression, which doesn't establish a correct relationship between the response and explanatory variables.</li>
<li><strong>Variance</strong>: When we have a dataset that is being used for training the model, the model should remain immune, even if we change the training set to a set that's coming from the same population. If variation in the dataset brings in a change in the performance of the model, it is termed a <strong>variance error</strong>. This takes place due to noise (an unexplained variation) being learned by the model and, due to that, this model doesn't give a good result on unseen data:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-804 image-border" src="assets/c371896e-14ed-449f-a25c-72c9f845cd9f.png" style="width:45.33em;height:8.42em;"/></p>
<p style="padding-left: 60px">We will explain the preceding diagram as follows:</p>
<ul>
<li><span>If the</span> <strong>Training Error</strong> <span>goes down and (</span><strong>Development Error</strong><span>-</span><strong>Training Error</strong><span>) rises, it implies a</span> <strong>High Variance</strong> <span>situation (scenario 1 in the preceding table)</span></li>
<li><span>If the <strong>Training Error</strong> and</span><span> <strong>Development Error</strong> rises</span><span> and (<strong>Development Error</strong>-<strong>Training Error</strong>) goes down, it implies a <strong>High Bias</strong> situation (scenario 2 in the preceding table)</span></li>
<li><span>If the <strong>Training Error</strong> and</span><span> <strong>Development Error</strong> rises and </span><span>(<strong>Development Error</strong>-<strong>Training Error</strong>) goes up as well, it implies <strong>High Bias</strong> and <strong>High Variance</strong> (scenario 3 in the preceding table)</span></li>
<li><span>If the <strong>Training Error</strong> goes up and the</span><span> <strong>Development Error</strong> declines, that is, </span><span>(<strong>Development Error</strong>-<strong>Training Error</strong>) goes down, it implies <strong>Low Bias</strong> and <strong>Low Variance</strong> (scenario 4 in the preceding table)</span></li>
</ul>
<p>We should always strive for the fourth scenario, which depicts the training error being low, as well as a low development set error. In the preceding table, this is where we have to find out a bias variance trade-off, which is depicted by a vertical line.</p>
<p>Now, the following question arises: how we can counter overfitting? Let's find out the answer to this by moving on to the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Regularization</h1>
                </header>
            
            <article>
                
<p>We have now got a fair understanding of what overfitting means when it comes to machine learning modeling. Just to reiterate, when the model learns the noise that has crept into the data, it is trying to learn the patterns that take place due to random chance, and so overfitting occurs. Due to this phenomenon, the model's generalization runs into jeopardy and it performs poorly on unseen data. As a result of that, the accuracy of the model takes a nosedive.</p>
<p>Can we combat this kind of phenomenon? The answer is yes. Regularization comes to the rescue. Let's figure out what it can offer and how it works.</p>
<p class="mce-root"/>
<p>Regularization is a technique that enables the model to not become complex to avoid overfitting.</p>
<p>Let's take a look at the following regression equation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/107b0b1a-755e-4c96-b235-5e4a9a676cf2.png" style="width:11.67em;height:1.33em;"/></p>
<p>The loss function for this is as follows:</p>
<p class="CDPAlignCenter CDPAlign"> <img class="fm-editor-equation" src="assets/69cb5478-5ca8-45e7-9123-c85fd63b62e0.png" style="width:11.75em;height:3.42em;"/></p>
<p>The loss function would help in getting the coefficients adjusted and retrieving the optimal one. In the case of noise in the training data, the coefficients wouldn't generalize well and would run into overfitting. Regularization helps get rid of this by making these estimates or coefficients drop toward 0.</p>
<p>Now, we will cover two types of regularization. In later chapters, the other types will be covered.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ridge regression (L2)</h1>
                </header>
            
            <article>
                
<p>Due to ridge regression, we need to make some changes to the loss function. The original loss function gets added by a shrinkage component:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c423cec4-f053-4798-8e0e-bfcf116acdcd.png" style="width:18.50em;height:3.75em;"/></p>
<p class="CDPAlignLeft CDPAlign">Now, this modified loss function needs to be minimized to adjust the estimates or coefficients. Here, the lambda is tuning the parameter that regularizes the loss function. That is, it decides how much it should penalize the flexibility of the model. The flexibility of the model is dependent on the coefficients. If the coefficients of the model go up, the flexibility also goes up, which isn't a good sign for our model. Likewise, as the coefficients go down, the flexibility is restricted and the model starts to perform better. The shrinkage of each estimated parameter makes the model better here, and this is what ridge regression does. When lambda keeps going higher and higher, that is, <em>λ → ∞</em>, the penalty component rises, and the estimates start shrinking. However, when <em><span>λ </span></em><span><em>→ 0</em>, the penalty component decreases and starts to become an <strong>ordinary least square</strong> (<strong>OLS</strong>) for estimating unknown parameters in a linear regression.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Least absolute shrinkage and selection operator </h1>
                </header>
            
            <article>
                
<p>The <strong>least absolute shrinkage and selection operator</strong> (<strong>LASSO</strong>) is also called <em>L1</em>. In this case, the preceding penalty parameter is replaced by <em>|βj|</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/41f4f28d-b58f-4302-b8b4-39ccc8340d14.png" style="width:19.50em;height:3.83em;"/></p>
<p>By minimizing the preceding function, the coefficients are found and adjusted. In this scenario, as lambda becomes larger,<span> <em>λ → ∞</em>, the penalty component rises, and so estimates start shrinking and become 0 (it doesn't happen in the case of ridge regression; rather, it would just be close to 0).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cross-validation and model selection</h1>
                </header>
            
            <article>
                
<p>We have already spoken about overfitting. It is something to do with the stability of a model since the real test of a model occurs when it works on unseen and new data. One of the most important aspects of a model is that it shouldn't pick up on noise, apart from regular patterns.</p>
<p>Validation is nothing but an assurance of the model being a relationship between the response and predictors as the outcome of input features and not noise. A good indicator of the model is not through training data and error. That's why we need cross-validation.</p>
<p>Here, we will stick with k-fold cross-validation and understand how it can be used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">K-fold cross-validation</h1>
                </header>
            
            <article>
                
<p>Let's walk through the steps of k-fold cross-validation:</p>
<ol>
<li>The data is divided into k-subsets.</li>
<li>One set is kept for testing/development and the model is built on the rest of the data (<em>k-1</em>). That is, the rest of the data forms the training data.</li>
</ol>
<ol start="3">
<li><em>Step 2</em> is repeated k-times. That is, once the preceding step has been performed, we move on to the second set and it forms a test set. The rest of the (<em>k-1</em>) data is then available for building the model:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-797 image-border" src="assets/b90b29ab-dfe7-4c11-9a2f-321e84f79495.png" style="width:21.83em;height:25.17em;"/></p>
<p style="padding-left: 60px">4. An error is calculated and an average is taken over all k-trials.</p>
<p>Every subset gets one chance to be a validation/test set since most of the data is used as a training set. This helps in reducing bias. At the same time, almost all the data is being used as validation set, which reduces variance.</p>
<p>As shown in the preceding diagram, <em>k = 5</em> has been selected. This means that we have to divide the whole dataset into five subsets. In the first iteration, subset 5 becomes the test data and the rest becomes the training data. Likewise, in the second iteration, subset 4 turns into the test data and the rest becomes the training data. This goes on for five iterations.</p>
<p>Now, let's try to do this in Python by splitting the train and test data using the K neighbors classifier:</p>
<pre>from sklearn.datasets import load_breast_cancer # importing the dataset<br/>from sklearn.cross_validation import train_test_split,cross_val_score # it will help in splitting train &amp; test<br/>from sklearn.neighbors import KNeighborsClassifier<br/>from sklearn import metrics<br/><br/>BC =load_breast_cancer() <br/>X = BC.data<br/>y = BC.target<br/><br/>X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=4)<br/><br/>knn = KNeighborsClassifier(n_neighbors=5)<br/>knn.fit(X_train, y_train)<br/>y_pred = knn.predict(X_test)<br/>print(metrics.accuracy_score(y_test, y_pred))<br/><br/>knn = KNeighborsClassifier(n_neighbors=5)<br/>scores = cross_val_score(knn, X, y, cv=10, scoring='accuracy')<br/>print(scores)<br/>print(scores.mean())</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Model selection using cross-validation</h1>
                </header>
            
            <article>
                
<p>We can make use of cross-validation to find out which model is performing better by using the following code:</p>
<pre>knn = KNeighborsClassifier(n_neighbors=20)<br/>print(cross_val_score(knn, X, y, cv=10, scoring='accuracy').mean())</pre>
<p>The 10-fold cross-validation is as follows:</p>
<pre class="mce-root"># 10-fold cross-validation with logistic regression<br/>from sklearn.linear_model import LogisticRegression<br/>logreg = LogisticRegression()<br/>print(cross_val_score(logreg, X, y, cv=10, scoring='accuracy').mean())</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">0.632 rule in bootstrapping</h1>
                </header>
            
            <article>
                
<p>Before we get into the 0.632 rule of bootstrapping, we need to understand what bootstrapping is. Bootstrapping is the process wherein random sampling is performed with a replacement from a population that's comprised of <em>n</em> observations. In this scenario, a sample can have duplicate observations. For example, if the population is (2,3,4,5,6) and we are trying to draw two random samples of size 4 with replacement, then sample 1 will be (2,3,3,6) and sample 2 will be (4,4,6,2).</p>
<p>Now, let's delve into the 0.632 rule.</p>
<p>We have already seen that the estimate of the training error while using a prediction is <em>1/n ∑L(y<sub>i,</sub>y-hat)</em>. This is nothing but the loss function:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/dfea359d-89d5-48f1-93e5-2d6bf1a50c7c.png" style="width:20.00em;height:1.83em;"/></p>
<p>Cross-validation is a way to estimate the expected output of a sample error:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/5863896c-0524-4013-a73a-cd6b176f4183.png" style="width:11.58em;height:1.50em;"/></p>
<p>However, in the case of k-fold cross-validation, it is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/baff7e70-d144-4371-a088-6ffd520061d0.png" style="width:16.75em;height:1.92em;"/></p>
<p>Here, the training data is <em>X=(x1,x2.....,xn)</em> and we take bootstrap samples from this set <em>(z1,.....,zb)</em> where each <em>zi</em> is a set of <em>n</em> samples. </p>
<p>In this scenario, the following is our out-of-sample error:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/5571d600-2600-4985-a2d5-ae703b7eceec.png" style="width:12.25em;height:1.50em;"/></p>
<p class="CDPAlignLeft CDPAlign"><span>Here, </span><em><span class="MathJax"><span class="math"><span><span class="mrow"><span class="msubsup"><span class="mi">f</span><span class="mi">b</span></span><span class="mo">(</span><span class="msubsup"><span class="mi">x</span><span class="mi">i</span></span><span class="mo">)</span></span></span></span></span></em><span> is the predicted value at </span><em><span class="MathJax"><span class="math"><span><span class="mrow"><span class="msubsup"><span class="mi">x</span><span class="mi">i </span></span></span></span></span></span></em><span>from the model that's been fit to the</span><span> bootstrap dataset.</span></p>
<p><span>Unfortunately, this is not a particularly good estimator because bootstrap samples that have been used to produce </span><em><span class="MathJax"><span class="math"><span><span class="mrow"><span class="msubsup"><span class="mi">fb</span></span><span class="mo">(</span><span class="msubsup"><span class="mi">x</span><span class="mi">i</span></span><span class="mo">)</span></span></span></span></span></em><span> may have contained </span><span class="MathJax"><span class="math"><span><span class="mrow"><span class="msubsup"><em><span class="mi">x</span><span class="mi">i</span></em></span></span></span></span></span><span>.</span> <span>OOSE</span><span> solves the overfitting problem, but is still biased. This bias is due to non-distinct observations in the bootstrap samples that result from sampling with replacement. The average number of distinct observations in each sample is about </span><span class="MathJax"><span class="math"><span><span class="mrow"><em><span class="mn">0.632n</span></em><span class="mi">.</span></span></span></span></span><span> </span><span>To solve the bias problem, Efron and Tibshirani proposed the <em>0.632</em> estimator:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/ff94ac0d-9c57-454c-9943-1fb1983f5632.png" style="width:23.17em;height:1.25em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Model evaluation</h1>
                </header>
            
            <article>
                
<p>Let's look at some of the model evaluation techniques that are currently being used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Confusion matrix</h1>
                </header>
            
            <article>
                
<p>A confusion matrix is a table that helps in assessing how good the classification model is. It is used when true values/labels are known. Most beginners in the field of data science feel intimidated by the confusion matrix and think it looks more difficult to comprehend than it really is; let me tell you—it's pretty simple and easy.</p>
<p>Let's understand this by going through an example. Let's say that we have built a classification model that predicts whether a customer would like to buy a certain product or not. To do this, we need to assess the model on unseen data.</p>
<p>There are two classes:</p>
<ul>
<li><strong>Yes</strong>: The customer will buy the product</li>
<li><strong>No</strong>: The customer will not buy the product</li>
</ul>
<p> From this, we have put the matrix together:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-787 image-border" src="assets/d2619d94-1b89-4ec3-b363-e816077f5e39.png" style="width:26.50em;height:11.92em;"/></p>
<p>What are the inferences we can draw from the preceding matrix at first glance?</p>
<ul>
<li>The classifier has made a total of 80 predictions. What this means is that 80 customers were tested in total to find out whether he/she will buy the product or not.</li>
<li><strong>54</strong> customers bought the product and <strong>26</strong> didn't. </li>
<li>The classifier predicts that <strong>56</strong> customers will buy the product and that <strong>24</strong> won't:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-801 image-border" src="assets/0b20dc6e-24bf-4e3b-bd6a-538c81b2a894.png" style="width:22.75em;height:11.33em;"/></p>
<p>The different terms pertaining to the confusion matrix are as follows:</p>
<ul>
<li><strong>True Positive (TP)</strong>: These are the cases in which we predicted that the customer will buy the product and they did.</li>
<li><strong>True Negative (TN)</strong>: These are the cases in which we predicted <span>that the</span> customer won't buy the product and they didn't.</li>
<li><strong>False Positive (FP)</strong>: We predicted <em>Yes the customer will buy the product</em>, but they didn't. This is known as a <em>Type 1</em> error.</li>
<li><strong>False Negative (FN)</strong>: We predicted <em>No</em>, but the customer bought the product. This is known as a <em>Type 2</em> error.</li>
</ul>
<p>Now, let's talk about a few metrics that are required for the assessment of a classification model:</p>
<ul>
<li><strong>Accuracy</strong>: This measures the overall accuracy of the classifier. To calculate this, we will use the following formula: <em>(TP+TN)/Total cases</em>. In the preceding scenario, the accuracy is (50+20)/80, which turns out to be 0.875. So, we can say that this classifier will predict correctly in 87.5% of scenarios.</li>
<li><strong>Misclassification rate</strong>: This measures how often the classifier has got the results wrong. The formula <em>(FP+FN)/Total cases</em> will give the result. In the preceding scenario, the misclassification rate is <em>(6+4)/80</em>, which is 0.125. So, in 12.5% of cases, it won't produce correct results. It can also be calculated as (1- Accuracy).</li>
<li><strong>TP rate</strong>: This is a measure of what the chances are that it would predict <em>yes</em> as the answer, and the answer actually is <em>yes</em>. The formula to calculate this is <strong>TP/(Actual:Yes)</strong>. In this scenario, <em>TPR = (50/54)= 0.92</em>. It's also called <strong>Sensitivity</strong> or <strong>Recall</strong>.</li>
<li><strong>FP rate</strong>: This is a measure of <span>what the chances are that it would predict <em>yes</em>, when the actual answer is <em>no</em>. The formula to calculate this rate is <strong>FP/(Actual:No)</strong>.<strong> </strong>For the preceding example, <em>FPR = (6/26)= 0.23</em>.</span></li>
<li><strong>TN rate</strong>: This<span> is a measure of what the chances are that it would predict <em>no</em>, when the answer is actually <em>no</em>. The formula to calculate this is </span><em>TN/(Actual:No)</em><span>. In this scenario, <em>TNR= (20/26)= 0.76</em>. It can also be calculated using (1-FPR). It's also called <strong>Specificity</strong>. </span></li>
<li><strong>Precision</strong>: This is a measure of correctness of the prediction of <em>yes</em> out of all the <em>yes</em> predictions. It finds out how many times a prediction of <em>yes</em> was made correctly out of total <em>yes</em> predictions. The formula to calculate this is <em>TP/(Predicted:Yes)</em>. Here, <em>Precision = (50/56)=0.89</em>.</li>
<li><strong>Prevalence</strong>: This is a measure of how many <em>yes</em> were given out of the total sample. The formula is <em>(Actual:Yes/ Total Sample)</em>. Here, this is <em>54/80 = 0.67</em>.</li>
<li><strong>Null error rate</strong>: This is a measure of how wrong the classifier would be if it predicted just the majority class. The formula is <em>(Actual:No/Total Sample)</em>. Here, this is <em>26/80=0.325</em>.</li>
<li><strong>Cohen's Kappa value</strong>: <span>This is a measure of how well the classifier performed compared to how well it would have performed simply by chance. </span></li>
<li><strong>F-Score</strong>: This is a harmonic mean of recall and precision, that is,<span> </span><em>(2*Recall*Precision)/(Recall+Precision)</em><span>.</span> It considers both Recall and Precision as important measures of a model's evaluation. The best value of the F-score is 1, wherein Recall and Precision are at their maximum. The worst value of the F-score is 0. The higher the score, the better the model is: </li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-959 image-border" src="assets/c1c5e09b-fc65-4721-92c0-474cf4b1ff56.png" style="width:90.50em;height:46.17em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Receiver operating characteristic curve</h1>
                </header>
            
            <article>
                
<p>We have come across many budding data scientists who would build a model and, in the name of evaluation, are just content with the <strong>overall accuracy</strong>. However, that's not the correct way to go about evaluating a model. For example, let's say there's a dataset that has got a response variable that has two categories: customers willing to buy the product and customers not willing to buy the product. Let's say that the dataset has 95% of customers not willing to buy the product and 5% of customers willing to buy it. Let's say that the classifier is able to correctly predict the majority class and not the minority class. So, if there are 100 observations, <em>TP=0</em>, <em>TN= 95</em>, and the rest misclassified, this will still result in 95% accuracy. However, it won't be right to conclude that this is a good model as it's not able to classify the minority class at all.</p>
<p>Hence, we need to look beyond accuracy so that we have a better judgement about the model. In this situation, Recall, Specificity, Precision, and the <strong>receiver operating characteristic</strong> (<strong>ROC</strong>) curve come to rescue. We learned about Recall, specificity, and precision in the previous section. Now, let's understand what the ROC curve is.</p>
<p>Most of the classifiers produce a score between 0 and 1. The next step occurs when we're setting up the threshold, and, based on this threshold, the classification is decided. Typically, 0.5 is the threshold—<span>if it's</span> more than 0.5, it creates a class, 1, and if the threshold is less than 0.5 it falls into another class, 2:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-811 image-border" src="assets/46bc9f8a-2b3c-4985-8b09-17bafb7d919a.png" style="width:30.42em;height:24.83em;"/></p>
<p>For ROC, every point between <strong>0.0</strong> and <strong>1.0</strong> is treated as a threshold, so the line of threshold keeps on moving from <strong>0.0</strong> to <strong>1.0</strong>. The threshold will result in us having a TP, TN, FP, and FN. At every threshold, the following metrics are calculated:</p>
<ul>
<li>
<p><em>True Positive Rate = TP/(TP+FN)</em></p>
</li>
<li>
<p><em>True Negative Rate = TN/(TN + FP)</em></p>
</li>
<li>
<p><em>False Positive Rate = 1- True Negative Rate</em></p>
</li>
</ul>
<p>The calculation of (TPR and FPR) starts from 0. When the threshold line is at 0, we will be able to classify all of the customers who are willing to buy (positive cases), whereas those who are not willing to buy will be misclassified as there will be too many false positives. This means that the threshold line will start moving toward the right from zero. As this happens, the false positive starts to decline and the true positive will continue increasing.</p>
<p>Finally, we will need to plot a graph of the TPR versus FPR after calculating them at every point of the threshold:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-802 image-border" src="assets/d6092b1e-d657-46ef-9d5e-a8b25de6f5c5.png" style="width:43.17em;height:25.33em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The red diagonal line represents the classification at random, that is, classification without the model. The perfect ROC curve will go along the <em>y</em> axis and will take the shape of an absolute triangle, which will pass through the top of the <em>y</em> axis. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Area under ROC</h1>
                </header>
            
            <article>
                
<p>To assess the model/classifier, we need to determine the <strong>area under ROC</strong> (<strong>AUROC</strong>). The whole area of this plot is 1 as the maximum value of FPR and TPR <span>– both are 1 here</span>. Hence, it takes the shape of a square. The random line is positioned perfectly at 45 degrees, which partitions the whole area into two symmetrical and equilateral triangles. This means that the areas under and above the red line are 0.5. The best and perfect classifier will be the one that tries to attain the AUROC as 1. The higher the AUROC, the better the model is.</p>
<p>In a situation where you have got multiple classifiers, you can use AUROC to determine which is the best one among the lot.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">H-measure</h1>
                </header>
            
            <article>
                
<p>Binary classification has to apply techniques so that it can map independent variables to different labels. For example, a number of variables exist such as gender, income, number of existing loans, and payment on time/not, that get mapped to yield a score that helps us classify the customers into good customers (more propensity to pay) and bad customers.</p>
<p>Typically, everyone seems to be caught up with the misclassification rate or derived form since the <strong>area under curve</strong> (<strong>AUC</strong>) is known to be the best evaluator of our classification model. You get this rate by dividing the total number of misclassified examples by the total number of examples. But does this give us a fair assessment? Let's see. Here, we have a misclassification rate that keeps something important under wraps. More often than not, classifiers come up with a tuning parameter, the side effect of which tends to be favoring false positives over false negatives, or vice versa. Also, picking the AUC as sole model evaluator can act as a double whammy for us. AUC has got different misclassification costs for different classifiers, which is not desirable. This means that using this is equivalent to using different metrics to evaluate different classification rules.</p>
<p>As we have already discussed, the real test of any classifier takes place on the unseen data, and this takes a toll on the model by some decimal points. Adversely, if we have got scenarios like the preceding one, the decision support system will not be able to perform well. It will start producing misleading results.</p>
<p class="mce-root"/>
<p>H-measure overcomes the situation of incurring different misclassification costs for different classifiers. It needs a severity ratio as input, which examines how much more severe misclassifying a class 0 instance is than misclassifying a class 1 instance:</p>
<p class="CDPAlignCenter CDPAlign"><em>Severity Ratio = cost_0/cost_1</em></p>
<p>Here, <em>cost_0 &gt; 0</em> is the cost of misclassifying a class 0 datapoint as class 1.</p>
<p>It is sometimes more convenient to consider the normalized cost <em>c = cost_0/(cost_0 + cost_1)</em> instead. For example, <em>severity.ratio = 2</em> implies that a false positive costs twice as much as a false negative.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dimensionality reduction</h1>
                </header>
            
            <article>
                
<p>Let's talk about a scenario wherein we have been given a dataset from a bank and it has got features pertaining to bank customers. These features comprise customer's income, age, gender, payment behavior, and so on. Once you take a look at the data dimension, you realize that there are 850 features. You are supposed to build a model to predict the customer who is going to default if a loan is given. Would you take all of these features and build the model?</p>
<p>The answer should be a clear <strong>no</strong>. The more features in a dataset, the more likely it is that the model will overfit. Although having fewer features doesn't guarantee that overfitting won't take place, it reduces the chance of that. Not a bad deal, right?</p>
<p>Dimensionality reduction is one of the ways to deal with this. It implies a reduction of dimensions in the feature space.</p>
<p>There are two ways this can be achieved:</p>
<ul>
<li><strong>Feature elimination</strong>: This is a process in which features that are not adding value to the model are rejected. Doing this makes the model quite simple. We know from Occam's Razor that we should strive for simplicity when it comes to building models. However, doing this step may result in the loss of information as a combination of such variables may have an impact on the model.</li>
<li><strong>Feature extraction</strong>: This is a process in which we create new independent variables that are a combination of existing variables. Based on the impact of these variables, we either keep or drop them.</li>
</ul>
<p class="mce-root"/>
<p>Principal component analysis is a feature extraction technique that takes all of the variables into account and forms a linear combination of the variables. Later, the least important variable can be dropped while the most important part of that variable is retained.</p>
<p>Newly formed variables (components) are independent of each other, which can be a boon for a model-building process wherein data distribution is linearly separable. Linear models have the underlying assumption that variables are independent of each other.</p>
<p>To understand the functionality of PCA, we have to become familiar with a few terms:</p>
<ul>
<li><strong>Variance</strong>: This is the average squared deviation from the mean. It is also called a <strong>spread</strong>, which measures the variability of the data:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/7a19ac0f-a890-4f5e-afd1-ed3d108cbf02.png" style="width:12.42em;height:3.08em;"/></p>
<p style="padding-left: 60px">Here, <em>x</em> is the mean.</p>
<ul>
<li><strong>Covariance</strong>: This is a measure of the degree to which two variables move in the same direction:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/ad894e3b-abe7-4f79-9626-915f5215f0db.png" style="width:16.75em;height:2.83em;"/></p>
<p>In PCA, we find out the pattern of the data as follows: in the case of the dataset having high covariance when represented in <em>n</em> of dimensions, we represent those dimensions with a linear combination of the same <em>n</em> dimensions. These combinations are orthogonal to each other, which is the reason why they are independent of each other. Besides, dimension follows an order by variance. The top combination comes first.</p>
<p>Let's go over how PCA works by talking about the following steps:</p>
<ol>
<li>Let's split our dataset into <em>Y</em> and <em>X</em> sets, and just focus on <em>X</em>.</li>
<li>A matrix of <em>X</em> is taken and standardized with a mean of 0 and a standard deviation of <em>1</em>. Let's call the new matrix <em>Z</em>.</li>
<li>Let's work on <em>Z</em> now. We have to transpose it and multiply the transposed matrix by <em>Z</em>. By doing this, we have got our covariance matrix:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><em>Covariance Matrix = Z<sup>T</sup>Z</em></p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li class="CDPAlignLeft CDPAlign">Now<span>, we need to calculate the eigenvalues and their corresponding eigenvectors of <em>Z<sup>T</sup>Z</em></span><span>. Typically, the eigen decomposition of the covariance matrix into </span><em>PDP</em><span>⁻¹ is done, where </span><em>P </em><span>is the matrix of eigenvectors and </span><em>D</em><span> is the diagonal matrix with eigenvalues on the diagonal and values of 0 everywhere else.</span></li>
<li>Take the eigenvalues <em>λ₁</em>, <em>λ₂</em>, …, <em>λp </em>and sort them from largest to smallest. In doing so, sort the eigenvectors in <em>P</em> accordingly. Call this sorted matrix of eigenvectors <em>P*</em>.</li>
<li>Calculate <em>Z*</em>= <em>ZP*</em>. This new matrix, <em>Z*</em>, is a centered/standardized version of <em>X</em>, but now each observation is a combination of the original variables, where the weights are determined by the eigenvector. As a bonus, because our eigenvectors in <em>P*</em> are independent of one another, the columns of <em>Z*</em> are independent of one another.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we studied the statistical model, the learning curve, and curve fitting. We also studied two cultures that Leo Breiman introduced, which describe that any analysis needs data. We went through the different types of training, development, and test data, including their sizes. We studied regularization, which explains <span>what overfitting means in machine learning modeling.</span></p>
<p>This chapter also explained cross validation and model selection, the 0.632 rule in bootstrapping, and also ROC and AUC in depth.</p>
<p>In the next chapter, we will study evaluating kernel learning, which is <span>the most widely used approach in machine learning.</span></p>


            </article>

            
        </section>
    </body></html>