["```py\n    import numpy as np\n    import pandas as pd\n    ```", "```py\n    rng_ = pd.date_range(\n        \"2024-05-17\", periods=20, freq=\"D\")\n    data = pd.DataFrame({\"date\": rng_})\n    data.head()\n    ```", "```py\n    data[\"year\"] = data[\"date\"].dt.year\n    data.head()\n    ```", "```py\n    data[\"quarter\"] = data[\"date\"].dt.quarter\n    data[[\"date\", \"quarter\"]].head()\n    ```", "```py\n    data[\"semester\"] = np.where(data[\"quarter\"] < 3, 1, 2)\n    ```", "```py\n    data[\"month\"] = data[\"date\"].dt.month\n    data[[\"date\", \"month\"]].head()\n    ```", "```py\n    data[\"week\"] = data[\"date\"].dt.isocalendar().week\n    data[[\"date\", \"week\"]].head()\n    ```", "```py\n    data[\"day_mo\"] = data[\"date\"].dt.day\n    data[[\"date\", \"day_mo\"]].head()\n    ```", "```py\n    data[\"day_week\"] = data[\"date\"].dt.dayofweek\n    data[[\"date\", \"day_mo\", \"day_week\"]].head()\n    ```", "```py\n    data[\"is_weekend\"] = (\n        data[«date»].dt.dayofweek > 4).astype(int)\n    data[[\"date\", \"day_week\", \"is_weekend\"]].head()\n    ```", "```py\n    import numpy as np\n    import pandas as pd\n    ```", "```py\n    rng_ = pd.date_range(\n        \"2024-05-17\", periods=20, freq=\"1h15min10s\")\n    df = pd.DataFrame({\"date\": rng_})\n    df.head()\n    ```", "```py\n    df[\"hour\"] = df[\"date\"].dt.hour\n    df[\"min\"] = df[\"date\"].dt.minute\n    df[\"sec\"] = df[\"date\"].dt.second\n    df.head()\n    ```", "```py\n    df[[\"h\", \"m\", \"s\"]] = pd.DataFrame(\n        [(x.hour, x.minute, x.second) for x in df[\"date\"]]\n    )\n    df.head()\n    ```", "```py\n    df[\"is_morning\"] = np.where(\n        (df[«hour»] < 12) & (df[«hour»] > 6), 1, 0 )\n    df.head()\n    ```", "```py\n    import datetime\n    import numpy as np\n    import pandas as pd\n    ```", "```py\n    date = \"2024-05-17\"\n    rng_hr = pd.date_range(date, periods=20, freq=\"h\")\n    rng_month = pd.date_range(date, periods=20, freq=\"ME\")\n    df = pd.DataFrame(\n        {\"date1\": rng_hr, \"date2\": rng_month})\n    df.head()\n    ```", "```py\n    df[\"elapsed_days\"] = (\n        df[\"date2\"] - df[\"date1\"]).dt.days\n    df.head()\n    ```", "```py\n    df[\"weeks_passed\"] = (\n        (df[«date2»] - df[«date1»]) / np.timedelta64(1, \"W\"))\n    df.head()\n    ```", "```py\n    df[\"diff_seconds\"] = (\n        df[«date2»] - df[«date1»])/np.timedelta64(1, «s»)\n    df[\"diff_minutes\"] = (\n        df[«date2»] - df[«date1»])/ np.timedelta64(1,»m»)\n    df.head()\n    ```", "```py\n    df[\"to_today\"] = (\n        datetime.datetime.today() - df[\"date1\"])\n    df.head()\n    ```", "```py\n    import pandas as pd\n    from feature_engine.datetime import (\n        DatetimeSubtraction\n    )\n    ```", "```py\n    date = \"2024-05-17\"\n    rng_hr = pd.date_range(date, periods=20, freq=\"h\")\n    rng_month = pd.date_range(date, periods=20, freq=\"ME\")\n    df = pd.DataFrame(\n        {\"date1\": rng_hr, \"date2\": rng_month})\n    ```", "```py\n    ds = DatetimeSubtraction(\n        variables=\"date2\",\n        reference=\"date1\",\n        output_unit=\"D\",\n    )\n    ```", "```py\n    dft = ds.fit_transform(df)\n    dft.head()\n    ```", "```py\n    import pandas as pd\n    ```", "```py\n    df = pd.DataFrame()\n    df['time1'] = pd.concat([\n        pd.Series(\n            pd.date_range(\n                start='2024-06-10 09:00',\n                freq='h',\n                periods=3,\n                tz='Europe/Berlin')),\n        pd.Series(\n            pd.date_range(\n                start='2024-09-10 09:00',\n                freq='h',\n                periods=3,\n                tz='US/Central'))\n        ], axis=0)\n    ```", "```py\n    df['time2'] = pd.concat([\n        pd.Series(\n            pd.date_range(\n                start='2024-07-01 09:00',\n                freq='h',\n                periods=3,\n                tz='Europe/Berlin')),\n        pd.Series(\n            pd.date_range(\n                start='2024-08-01 09:00',\n                freq='h',\n                periods=3,\n                tz='US/Central'))\n        ], axis=0)\n    ```", "```py\n    df['time1_utc'] = pd.to_datetime(\n        df['time1'], utc=True)\n    df['time2_utc'] = pd.to_datetime(\n        df['time2'], utc=True)\n    ```", "```py\n    df['elapsed_days'] = (\n        df[‹time2_utc›] - df[‹time1_utc›]). dt.days\n    df['elapsed_days'].head()\n    ```", "```py\n    0    21\n    1    21\n    2    21\n    0   -40\n    1   -40\n    datetime variables to the London and Berlin time zones, and then display the resulting variables:\n\n    ```", "```py\n\n    We see the variables in their respective time zones in the following output:\n    ```", "```py\n    import pandas as pd\n    from feature_engine.datetime import DatetimeFeatures\n    ```", "```py\n    rng_ = pd.date_range(\n        '2024-05-17', periods=20, freq='D')\n    data = pd.DataFrame({'date': rng_})\n    ```", "```py\n    dtfs = DatetimeFeatures(\n        variables=None,\n        features_to_extract= \"all\",\n    )\n    ```", "```py\n    dft = dtfs.fit_transform(data)\n    ```", "```py\n    vars_ = [v for v in dft.columns if \"date\" in v]\n    ```", "```py\n['date_month',\n 'date_quarter',\n 'date_semester',\n 'date_year',\n 'date_week',\n 'date_day_of_week',\n 'date_day_of_month',\n 'date_day_of_year',\n 'date_weekend',\n 'date_month_start',\n 'date_month_end',\n 'date_quarter_start',\n 'date_quarter_end',\n'date_year_start',\n 'date_year_end',\n 'date_leap_year',\n 'date_days_in_month',\n 'date_hour',\n 'date_minute',\ndft[vars_].head(). We can’t show the resulting DataFrame in the book because it is too big.\nNote\nWe can create specific features by passing their names to the `features_to_extract` parameter.\nFor example, to extract `week` and `year`, we set the transformer like this: `dtfs = DatetimeFeatures(features_to_extract=[\"week\", \"year\"])`. We can also extract all supported features by setting the `features_to_extract` parameter to `\"all\"`.\n`DatetimeFeatures()` can also create features from variables in different time zones. Let’s learn how to correctly set up the transformer in this situation.\n\n1.  Let’s create a sample DataFrame with a variable’s values in different time zones:\n\n    ```", "```py\n\n    If we execute `df`, we will see the DataFrame from *Step 6*, as shown in the following output:\n\n![Figure 6.22 – A DataFrame with a variable’s values in different time zones](img/B22396_06_22.jpg)\n\nFigure 6.22 – A DataFrame with a variable’s values in different time zones\n\n1.  We’ll set the transformer to extract three specific features from this variable after setting it to the UTC:\n\n    ```", "```py\n\n     2.  Let’s create the new features:\n\n    ```", "```py\n\n    `DatetimeFeatures()` will set all variables into UTC before deriving the features. With `dft.head()`, we can see the resulting DataFrame:\n\n![Fig﻿ure 6.23 – A DataFrame with t﻿he original and new variables](img/B22396_06_23.jpg)\n\nFigure 6.23 – A DataFrame with the original and new variables\nWith that, we’ve created multiple date and time-related features in a few lines of code. `feature-engine` offers a great alternative to manually creating features per feature with `pandas`. In addition, `DatetimeFeatures()` can be integrated into scikit-learn’s `Pipeline` and `GridSearchCV`, among other classes.\nHow it works...\n`DatetimeFeatures()` extracts several date and time features from `datetime` variables automatically by utilizing `pandas`’ `dt` under the hood. It works with variables whose original data types are `datetime`, as well as with object-like and categorical variables, provided that they can be parsed into a `datetime` format.\n`DatetimeFeatures()` extracts the following features by default: `month`, `year`, `day_of_week`, `day_of_month`, `hour`, `minute` and `second`. We can make the transformer return all the features it supports by setting the parameter `features_to_extract` to `all`. In addition, we can extract a specific subset of features by passing the feature names in a list, as we did in *Step 7*.\n`DatetimeFeatures()` automatically finds `datetime` variables or variables that can be parsed as `datetime` in the DataFrame passed to the `fit()` method. To extract features from a selected variable or group of variables, we can pass their name in a list to the `variables` parameter when we set up the transformer.\nWith `fit()`, `DatetimeFeatures()` does not learn any parameters; instead, it checks that the variables entered by the user are, or can be, parsed into a `datetime` format. If the user does not indicate variable names, `DatetimeFeatures()` finds the `datetime` variables automatically. With `transform()`, the transformer adds the date and time-derived variables to the DataFrame.\n\n```"]