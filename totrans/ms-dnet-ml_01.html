<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;1.&#xA0;Welcome to Machine Learning Using the .NET Framework" id="E9OE1-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Welcome to Machine Learning Using the .NET Framework</h1></div></div></div><p class="calibre6">This is a book on creating and then using <span class="strong"><strong class="calibre7">Machine Learning</strong></span> (<span class="strong"><strong class="calibre7">ML</strong></span>) programs using the .NET Framework. Machine learning, a hot topic these days, is part of an overall trend in the software industry of analytics which attempts to make machines <span class="strong"><em class="calibre11">smarter</em></span>. Analytics, though not really a new trend, has perhaps a higher visibility than in the past. This chapter will focus on some of the larger questions you might have about machine learning using the .NET Framework, namely: What is machine learning? Why should we consider it in the .NET Framework? How can I get started with coding?</p></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Welcome to Machine Learning Using the .NET Framework" id="E9OE1-a18db0be6c20485ba81f22e43ca13055">
<div class="book" title="What is machine learning?"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec08" class="calibre1"/>What is machine learning?</h1></div></div></div><p class="calibre6">If you check<a id="id0" class="calibre1"/> out on Wikipedia, you will find a fairly abstract definition of machine learning:</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre10"><span class="strong"><em class="calibre11">"Machine learning explores the study and construction of algorithms that can learn from and make predictions on data. Such algorithms operate by building a model from example inputs in order to make data-driven predictions or decisions, rather than following strictly static program instructions."</em></span></p></blockquote></div><p class="calibre6">I like to think of machine learning as computer programs that produce different results as they are exposed to more information without changing their source code (and consequently needed to be redeployed). For example, consider a game that I play with the computer.</p><p class="calibre6">I show the computer this picture <span class="strong"><img src="../images/00002.jpeg" alt="What is machine learning?" class="calibre14"/></span> and tell it "Blue Circle". I then show it this picture <span class="strong"><img src="../images/00003.jpeg" alt="What is machine learning?" class="calibre14"/></span> and tell it "Red Circle". Next I show it this picture <span class="strong"><img src="../images/00004.jpeg" alt="What is machine learning?" class="calibre14"/></span> and say "Green Triangle."</p><p class="calibre6">Finally, I show it this picture <span class="strong"><img src="../images/00005.jpeg" alt="What is machine learning?" class="calibre14"/></span> and ask it "What is this?". Ideally the computer would respond, "Green Circle."</p><p class="calibre6">This is one example of machine learning. Although I did not change my code or recompile and redeploy, the <a id="id1" class="calibre1"/>computer program can respond accurately to data it has never seen before. Also, the computer code does not have to explicitly write each possible data permutation. Instead, we create models that the computer applies to new data. Sometimes the computer is right, sometimes it is wrong. We then feed the new data to the computer to retrain the model so the computer gets more and more accurate over time—or, at least, that is the goal.</p><p class="calibre6">Once you decide to implement some machine learning into your code base, another decision has to be made fairly early in the process. How often do you want the computer to learn? For example, if you create a model by hand, how often do you update it? With every new data row? Every month? Every year? Depending on what you are trying to accomplish, you might create a real-time ML model, a near-time model, or a periodic model. We will discuss the implications and implementations of each of these in several chapters in the book as different models lend themselves to different retraining strategies.</p></div></div>
<div class="book" title="Why .NET?" id="F8901-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec09" class="calibre1"/>Why .NET?</h1></div></div></div><p class="calibre6">If you are a Windows developer, using .NET is something you do without thinking. Indeed, a vast majority of Windows business applications written in the last 15 years use <a id="id2" class="calibre1"/>managed code—most of it written in C#. Although it is difficult to categorize millions of software developers, it is fair to say that .NET developers often come from nontraditional backgrounds. Perhaps a developer came to .NET from a BCSC degree but it is equally<a id="id3" class="calibre1"/> likely s/he started writing VBA scripts in Excel, moving up to Access applications, and then into VB.NET/C# applications. Therefore, most .NET developers are likely to be familiar with C#/VB.NET and write in an imperative and perhaps OO style.</p><p class="calibre6">The problem with this rather narrow exposure is that most machine learning classes, books, and code examples are in R or Python and very much use a functional style of writing code. Therefore, the .NET developer is at a disadvantage when acquiring machine learning skills because of the need to learn a new development environment, a new language, and a new style of coding before learning how to write the first line of machine learning code.</p><p class="calibre6">If, however, that same developer could use their familiar IDE (Visual Studio) and the same base libraries (the .NET Framework), they can concentrate on learning machine learning much sooner. Also, when creating machine learning models in .NET, they have immediate impact as you can slide the code right into an existing C#/VB.NET solution.</p><p class="calibre6">On the other hand, .NET is under-represented in the data science community. There are a couple of different<a id="id4" class="calibre1"/> reasons floating around for that fact. The first is that historically Microsoft was a proprietary closed system and the academic community embraced open source systems such as Linux and Java. The second reason is that much academic research uses domain-specific languages such as R, whereas Microsoft concentrated .NET on general purpose programming languages. Research that moved to industry took their language with them. However, as the researcher's role is shifted from data science to building programs that can work at real time that customers touch, the researcher is<a id="id5" class="calibre1"/> getting more and more exposure to Windows and Windows development. Whether you like it or not, all companies which create software that face customers must have a Windows strategy, an iOS strategy, and an Android strategy.</p><p class="calibre6">One real advantage to writing and then deploying your machine learning code in .NET is that you can get everything with one stop shopping. I know several large companies who write their models in R and then have another team rewrite them in Python or C++ to deploy them. Also, they might write their model in Python and then rewrite it in C# to deploy on Windows devices. Clearly, if you could write and deploy in one language stack, there is a tremendous opportunity for efficiency and speed to market.</p></div>
<div class="book" title="What version of the .NET Framework are we using?" id="G6PI1-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>What version of the .NET Framework are we using?</h1></div></div></div><p class="calibre6">The .NET Framework<a id="id6" class="calibre1"/> has been around for general release since 2002. The base of the framework is the Common Language Runtime or CLR. The CLR is a virtual machine that abstracts much of the OS specific functionality like memory management and exception handling. The<a id="id7" class="calibre1"/> CLR is loosely based on the <span class="strong"><strong class="calibre7">Java Virtual Machine</strong></span> (<span class="strong"><strong class="calibre7">JVM</strong></span>). Sitting on top of the CLR is the <span class="strong"><strong class="calibre7">Framework Class Library</strong></span> (<span class="strong"><strong class="calibre7">FCL</strong></span>) that allows different languages to interoperate with the CLR<a id="id8" class="calibre1"/> and each other: the FCL is what allows VB.Net, C#, F#, and Iron Python code to work side-by-side with each other.</p><p class="calibre6">Since its first release, the .NET Framework has included more and more features. The first release saw support for the major platform libraries like WinForms, ASP.NET, and ADO.NET. Subsequent releases brought in<a id="id9" class="calibre1"/> things like <span class="strong"><strong class="calibre7">Windows Communication Foundation</strong></span> (<span class="strong"><strong class="calibre7">WCF</strong></span>), <span class="strong"><strong class="calibre7">Language Integrated Query</strong></span> (<span class="strong"><strong class="calibre7">LINQ</strong></span>), and <span class="strong"><strong class="calibre7">Task Parallel Library</strong></span> (<span class="strong"><strong class="calibre7">TPL</strong></span>). At the time of writing, the latest <a id="id10" class="calibre1"/>version is of the .Net Framework is<a id="id11" class="calibre1"/> 4.6.2.</p><p class="calibre6">In addition to the full-Monty .NET Framework, over the years Microsoft has released slimmed down versions of the .NET Framework intended to run on machines that have limited hardware and OS support. The most famous of these releases was the<a id="id12" class="calibre1"/> <span class="strong"><strong class="calibre7">Portable Class Library</strong></span> (<span class="strong"><strong class="calibre7">PCL</strong></span>) that targeted Windows RT applications running Windows 8. The most recent incantation of this is <a id="id13" class="calibre1"/>
<span class="strong"><strong class="calibre7">Universal Windows Applications</strong></span> (<span class="strong"><strong class="calibre7">UWA</strong></span>), targeting Windows 10.</p><p class="calibre6">At <code class="literal">Connect()</code>; in November 2015, Microsoft announced GA of the latest edition of the .NET Framework. This<a id="id14" class="calibre1"/> release introduced the .Net Core 5. In January, they decided to rename it to .Net Core 1.0. .NET Core 1.0 is intended to be a slimmed down version of the full .NET Framework that runs on multiple operating systems (specifically targeting OS X and Linux). The next release of ASP.NET (ASP.NET Core 1.0) sits on top of .NET Core 1.0. ASP.NET Core 1.0 applications that run on Windows can still run the full .NET Framework.</p><div class="mediaobject"><img src="../images/00006.jpeg" alt="What version of the .NET Framework are we using?" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">(<a class="calibre1" href="https://blogs.msdn.microsoft.com/webdev/2016/01/19/asp-net-5-is-dead-introducing-asp-net-core-1-0-and-net-core-1-0/">https://blogs.msdn.microsoft.com/webdev/2016/01/19/asp-net-5-is-dead-introducing-asp-net-core-1-0-and-net-core-1-0/</a>)</p><p class="calibre6">In this book, we will be using<a id="id15" class="calibre1"/> a mixture of ASP.NET 4.0, ASP.NET 5.0, and Universal Windows Applications. As you can guess, machine learning models (and the theory behind the models) change with a lot less frequency than framework releases so the most of the code you write on .NET 4.6 will work equally well with PCL and .NET Core 1.0. Saying that, the external libraries that we will use need some time to catch up—so they might work with PCL but not with .NET Core 1.0 yet. To make things realistic, the demonstration projects will use .NET 4.6 on ASP.NET 4.x for existing (Brownfield) applications. New (Greenfield) applications will be a mixture of a UWA using PCL and ASP.NET 5.0 applications.</p></div>
<div class="book" title="Why write your own?" id="H5A41-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Why write your own?</h1></div></div></div><p class="calibre6">It seems like all of the major software companies are pitching machine learning services such as Google Analytics, Amazon Machine Learning Services, IBM Watson, Microsoft Cortana Analytics, to name a few. In addition, major software companies often try to sell products that have a machine learning component, such as Microsoft SQL Server Analysis Service, Oracle Database Add-In, IBM SPSS, or SAS JMP. I have not included some common analytical software packages such as PowerBI or Tableau because they are more data aggregation and report writing applications. Although they do analytics, they do not have a machine learning component (not yet at least).</p><p class="calibre6">With all these options, why would you want to learn how to implement machine learning inside your applications, or in effect, write some code that you can purchase elsewhere? It is the classic build<a id="id16" class="calibre1"/> versus buy decision that every department or company has to make. You might want to build because:</p><div class="book"><ul class="itemizedlist"><li class="listitem">You really understand what you are doing and you can be a much more informed consumer and critic of any given machine learning package. In effect, you are building your internal skill set that your company will most likely prize. Another way to look at it, companies are not one tool away from purchasing competitive advantage because if they were, their competitors could also buy the same tool and cancel any advantage. However, companies can be one hire away or more likely one team away to truly have the ability to differentiate themselves in their market.</li><li class="listitem">You can get better performance by executing locally, which is especially important for real-time machine learning and can be implemented in disconnected or slow connection scenarios. This<a id="id17" class="calibre1"/> becomes particularly important when we start implementing machine learning with <span class="strong"><strong class="calibre7">Internet of Things</strong></span> (<span class="strong"><strong class="calibre7">IoT</strong></span>) devices in scenarios where the device has a lot more RAM than network bandwidth. Consider the Raspberry Pi running Windows 10 on a pipeline. Network communication might be spotty, but the machine has plenty of power to implement ML models.</li><li class="listitem">You are not beholden to any one vendor or company, for example, every time you implement an application with a specific vendor and are not thinking about how to move away from the vendor, you make yourself more dependent on the vendor and their inevitable recurring licensing costs. The next time you are talking to the CTO of a shop that has a lot of Oracle, ask him/her if they regret any decision to implement any of their business logic in Oracle databases. The answer will not surprise you. A majority of this book's code is written in F#—an open source language that runs great on Windows, Linux, and OS X.</li><li class="listitem">You can be much more agile and have much more flexibility in what you implement. For example, we will often re-train our models on the fly and when you write your own code, it is fairly easy to do this. If you use a third-party service, they <a id="id18" class="calibre1"/>may not even have API hooks to do model training and evaluation, so near-time model changes are impossible.</li></ul></div><p class="calibre6">Once you decide to go native, you have a choice of rolling your own code or using some of the open source assemblies out there. This book will introduce both the techniques to you, highlight some of the pros and cons of each technique, and let you decide how you want to implement them. For example, you can easily write your own basic classifier that is very effective in production but certain models, such as a neural network, will take a considerable amount of time and energy and probably will not give you the results that the open source libraries do. As a final note, since the libraries that we will look at are open source, you are free to customize pieces of it—the owners might even accept your changes. However, we will not be customizing these libraries in this book.</p></div>
<div class="book" title="Why open data?" id="I3QM1-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Why open data?</h1></div></div></div><p class="calibre6">Many books on machine learning use datasets that come with the language install (such as R or Hadoop) or point to public repositories that have considerable visibility in the data science community. The most common ones are Kaggle (especially the Titanic competition) and the UC Irvine's datasets. While these are great datasets and give a common denominator, this book will expose you to datasets that come from government entities. The notion of getting data from government and hacking for social good is typically called <span class="strong"><strong class="calibre7">open data</strong></span>. I believe<a id="id19" class="calibre1"/> that open data will transform how the government interacts with its citizens and will make government entities more efficient and transparent. Therefore, we will use open datasets in this book and hopefully you will consider helping out with the open data movement.</p></div>
<div class="book" title="Why F#?" id="J2B81-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec13" class="calibre1"/>Why F#?</h1></div></div></div><p class="calibre6">As we will be on the .NET Framework, we could use either C#, VB.NET, or F#. All three languages have strong support within Microsoft and all three will be around for many years. F# is the best choice for this book because it is unique in the .NET Framework for thinking in the scientific method and machine learning model creation. Data scientists will feel right at home with the syntax and IDE (languages such as R are also functional first languages). It is<a id="id20" class="calibre1"/> the best choice for .NET business developers because it is built right into Visual Studio and plays well with your existing C#/VB.NET code. The obvious alternative is C#. Can I do this all in C#? Yes, kind of. In fact, many of the .NET libraries we will use are written in C#.</p><p class="calibre6">However, using C# in our code base will make it larger and have a higher chance of introducing bugs into the code. At certain points, I will show some examples in C#, but the majority of the book is in F#.</p><p class="calibre6">Another alternative is to forgo .NET altogether and develop the machine learning models in R and Python. You could spin up a web service (such as AzureML), which might be good in some scenarios, but in disconnected or slow network environments, you will get stuck. Also, assuming comparable machines, executing locally will perform better than going over the wire. When we implement our models to do real-time analytics, anything we can do to minimize the performance hit is something to consider.</p><p class="calibre6">A third alternative that the .NET developers will consider is to write the models in T-SQL. Indeed, many<a id="id21" class="calibre1"/> of our initial models have been implemented in T-SQL and are part of the SQL Server Analysis Server. The advantage of doing it on the data server is that the computation is as close as you can get to the data, so you will not suffer the latency of moving large amount of data over the wire. The downsides of using T-SQL are that you can't implement unit tests easily, your domain logic is moving away from the application and to the data server (which is considered bad form with most modern application architecture), and you are now reliant on a specific implementation of the database. F# is open source and runs on a variety of operating systems, so you can port your code much more easily.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Getting ready for machine learning"><div class="book" id="K0RQ2-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec14" class="calibre1"/>Getting ready for machine learning</h1></div></div></div><p class="calibre6">In this section, we<a id="id22" class="calibre1"/> will install Visual Studio, take a quick lap around F#, and install the major open source libraries that we will be using.</p></div>

<div class="book" title="Getting ready for machine learning">
<div class="book" title="Setting up Visual Studio"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec06" class="calibre1"/>Setting up Visual Studio</h2></div></div></div><p class="calibre6">To get going, you<a id="id23" class="calibre1"/> will need to download Visual Studio on a Microsoft Windows machine. As of this writing, the latest (free) version is Visual <a id="id24" class="calibre1"/>Studio 2015 Community. If you have a higher version already installed on your machine, you can skip this step. If you need a copy, head on over to the <a id="id25" class="calibre1"/>Visual Studio home page at <a class="calibre1" href="https://www.visualstudio.com">https://www.visualstudio.com</a>. Download the Visual Studio Community 2015 installer and execute it.</p><p class="calibre6">Now, you will get the following screen:</p><div class="mediaobject"><img src="../images/00007.jpeg" alt="Setting up Visual Studio" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Select <span class="strong"><strong class="calibre7">Custom</strong></span> installation and you <a id="id26" class="calibre1"/>will be taken to the<a id="id27" class="calibre1"/> following screen:</p><div class="mediaobject"><img src="../images/00008.jpeg" alt="Setting up Visual Studio" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Make sure <a id="id28" class="calibre1"/>Visual F# has a check mark next to it. Once it is installed, you should see Visual Studio<a id="id29" class="calibre1"/> in your Windows Start menu.</p></div></div>

<div class="book" title="Getting ready for machine learning">
<div class="book" title="Learning F#"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec07" class="calibre1"/>Learning F#</h2></div></div></div><p class="calibre6">One of the great features about F# is that you can accomplish a whole lot with very little code. It is a very terse language<a id="id30" class="calibre1"/> compared to C# and VB.NET, so picking up the syntax is a bit easier. Although this is not a<a id="id31" class="calibre1"/> comprehensive introduction, this is going to introduce you to the major language features that we will use in this book. I encourage you to check<a id="id32" class="calibre1"/> out <a class="calibre1" href="http://www.tryfsharp.org/">http://www.tryfsharp.org/</a> or the tutorials at <a class="calibre1" href="http://fsharpforfunandprofit.com/">http://fsharpforfunandprofit.com/</a> if you want to get a deeper understanding of the language.  With that in mind, let's create our 1st F# project:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start Visual Studio.</li><li class="listitem" value="2">Navigate to <span class="strong"><strong class="calibre7">File</strong></span> | <span class="strong"><strong class="calibre7">New</strong></span> | <span class="strong"><strong class="calibre7">Project</strong></span> as shown in the following screenshot:<div class="mediaobject"><img src="../images/00009.jpeg" alt="Learning F#" class="calibre8"/></div><p class="calibre15"> </p></li><li class="listitem" value="3">When the <span class="strong"><strong class="calibre7">New Project</strong></span> dialog box appears, navigate the tree view to <span class="strong"><strong class="calibre7">Visual F#</strong></span> | <span class="strong"><strong class="calibre7">Windows</strong></span> | <span class="strong"><strong class="calibre7">Console Application</strong></span>. Have a look at the following screenshot:<div class="mediaobject"><img src="../images/00010.jpeg" alt="Learning F#" class="calibre8"/></div><p class="calibre15"> </p></li><li class="listitem" value="4">Give your <a id="id33" class="calibre1"/>project a name, hit <span class="strong"><strong class="calibre7">OK</strong></span>, and the Visual Studio Template generator will create the following boilerplate:<div class="mediaobject"><img src="../images/00011.jpeg" alt="Learning F#" class="calibre8"/></div><p class="calibre15"> </p><p class="calibre16">Although Visual Studio created a <code class="literal">Program.fs</code> file that creates a basic console <code class="literal">.exe</code> application for us, we will start learning about F# in a different way, so we are going to ignore it for now.</p></li><li class="listitem" value="5">Right-click in the <a id="id34" class="calibre1"/><span class="strong"><strong class="calibre7">Solution Explorer</strong></span> and navigate to <span class="strong"><strong class="calibre7">Add</strong></span> | <span class="strong"><strong class="calibre7">New Item</strong></span>.<div class="mediaobject"><img src="../images/00012.jpeg" alt="Learning F#" class="calibre8"/></div><p class="calibre15"> </p></li><li class="listitem" value="6">When the <span class="strong"><strong class="calibre7">Add New Item</strong></span> dialog box appears, select <span class="strong"><strong class="calibre7">Script File</strong></span>.<div class="mediaobject"><img src="../images/00013.jpeg" alt="Learning F#" class="calibre8"/></div><p class="calibre15"> </p><p class="calibre16">The <code class="literal">Script1.fsx</code> file is<a id="id35" class="calibre1"/> then added to the project.</p><div class="mediaobject"><img src="../images/00014.jpeg" alt="Learning F#" class="calibre8"/></div><p class="calibre15"> </p></li><li class="listitem" value="7">Once <code class="literal">Script1.fsx</code> is created, open it up, and enter the following into the file:<div class="informalexample"><pre class="programlisting">let x = "Hello World"</pre></div></li><li class="listitem" value="8">Highlight that entire row of code, right-click and select <span class="strong"><strong class="calibre7">Execute In Interactive</strong></span> (or press <span class="strong"><em class="calibre11">Alt</em></span> + <span class="strong"><em class="calibre11">Enter</em></span>):<div class="mediaobject"><img src="../images/00015.jpeg" alt="Learning F#" class="calibre8"/></div><p class="calibre15"> </p><p class="calibre16">And the <span class="strong"><strong class="calibre7">F# Interactive</strong></span> console will pop up and you will see this:</p><div class="mediaobject"><img src="../images/00016.jpeg" alt="Learning F#" class="calibre8"/></div><p class="calibre15"> </p></li></ol><div class="calibre13"/></div><p class="calibre6">The F# Interactive is a type <a id="id36" class="calibre1"/>of REPL, which stands for Read-Evaluate-Print-Loop. If you are a .NET developer who has spent any time in SQL Server Management Studio, the F# Interactive will look very familiar to the Query Analyzer where you enter your code at the top and see how it executes at the bottom. Also, if you are a data scientist using R Studio, you are very familiar with the concept of a REPL. I have used the words REPL and FSI interchangeably in this book.</p><p class="calibre6">There are a couple of things to notice about this first line of F# code you wrote. First, it looks very similar to C#. In fact, consider changing the code to this:</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="Learning F#" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">It would be perfectly<a id="id37" class="calibre1"/> valid C#. Note that the red squiggly line, showing you that the F# compiler certainly does not think this is valid.</p><p class="calibre6">Going back to the correct code, notice that type of <code class="literal">x</code> is not explicitly defined. F# uses the concept of inferred typing so that you don't have to write the type of the values that you create. I used the term <span class="strong"><em class="calibre11">value</em></span> deliberately because unlike variables, which can be assigned in C# and VB.NET, values are immutable; once bound, they can never change. Here, we are permanently binding the name <code class="literal">x</code> to its value, <code class="literal">Hello World</code>. This notion of immutability might seem constraining at first, but it has profound and positive implications, especially when writing machine learning models.</p><p class="calibre6">With our basic program idea proven out, let's move it over to a compliable assembly; in this case, an <code class="literal">.exe</code> that targets the console. Highlight the line that you just wrote, press <span class="strong"><em class="calibre11">Ctrl</em></span> + <span class="strong"><em class="calibre11">C</em></span>, and then open up <code class="literal">Program.fs</code>. Go into the code that was generated and paste it in:</p><div class="informalexample"><pre class="programlisting">[&lt;EntryPoint&gt;]
let main argv = 
    printfn "%A" argv
    let x = "Hello World"
    0 // return an integer exit code</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre6"><span class="strong"><strong class="calibre7">Downloading the example code</strong></span></p><p class="calibre6">You can download the example code files for this book from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p><p class="calibre6">You can download the code files by following these steps:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Log in or register to our website using your e-mail address and password.</li><li class="listitem">Hover the mouse pointer on the <span class="strong"><strong class="calibre7">SUPPORT</strong></span> tab at the top.</li><li class="listitem">Click on <span class="strong"><strong class="calibre7">Code Downloads &amp; Errata</strong></span>.</li><li class="listitem">Enter the name of the book in the <span class="strong"><strong class="calibre7">Search</strong></span> box.</li><li class="listitem">Select the book for which you're looking to download the code files.</li><li class="listitem">Choose from the drop-down menu where you purchased this book from.</li><li class="listitem">Click on <span class="strong"><strong class="calibre7">Code Download</strong></span>.</li></ul></div><p class="calibre6">Once the file is downloaded, please make sure that you unzip or extract the folder using the latest version of:</p><div class="book"><ul class="itemizedlist"><li class="listitem">WinRAR / 7-Zip for Windows</li><li class="listitem">Zipeg / iZip / UnRarX for Mac</li><li class="listitem">7-Zip / PeaZip for Linux</li></ul></div></div><p class="calibre6">Then, add the following lines of code around what you just added:</p><div class="informalexample"><pre class="programlisting">// Learn more about F# at http://fsharp.org
// See the 'F# Tutorial' project for more help.
open System

[&lt;EntryPoint&gt;]
let main argv = 
    printfn "%A" argv
    let x = "Hello World"
    Console.WriteLine(x)
    let y = Console.ReadKey()
    0 // return an integer exit code</pre></div><p class="calibre6">Press the Start button (or hit <span class="strong"><em class="calibre11">F5</em></span>) and you should see your program run:</p><div class="mediaobject"><img src="../images/00018.jpeg" alt="Learning F#" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">You will notice that I had to bind the return value from <code class="literal">Console.ReadKey()</code> to <code class="literal">y</code>. In C# or VB.NET, you can get away with not handling the return value explicitly. In F#, you are not allowed to ignore the returned values. Although some might think this is a limitation, it is actually a strength of the language. It is much harder to make a mistake in F# because the language<a id="id38" class="calibre1"/> forces you to address execution paths explicitly versus accidentally sweeping them under the rug (or into a null, but we'll get to that later).</p><p class="calibre6">In any event, let's go back to our script file and enter in another line of code:</p><div class="informalexample"><pre class="programlisting">let ints = [|1;2;3;4;5;6|]</pre></div><p class="calibre6">If you send that line of code to the REPL, you should see this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val ints : int [] = [|1; 2; 3; 4; 5; 6|]</strong></span>
</pre></div><p class="calibre6">This is an array, as if you did this in C#:</p><div class="informalexample"><pre class="programlisting">var ints = new[] {1,2,3,4,5,6};</pre></div><p class="calibre6">Notice that the separator is a semicolon in F# and not a comma. This differs from many other languages, including C#. The comma in F# is reserved for tuples, not for separating items in an array. We'll discuss tuples later.</p><p class="calibre6">Now, let's sum up the values in our array:</p><div class="informalexample"><pre class="programlisting">let summedValue = ints |&gt; Array.sum</pre></div><p class="calibre6">While sending that line to the REPL, you should see this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val summedValue : int = 21</strong></span>
</pre></div><p class="calibre6">There are two things going on. We have the <code class="literal">|&gt;</code> operator, which is a pipe forward operator. If you have experience with Linux or PowerShell, this should be familiar. However, if you have a background in C#, it might look unfamiliar. The pipe forward operator takes the result of the value on the left-hand side of the operator (in this case, <code class="literal">ints</code>) and pushes it into the function on the right-hand side (in this case, <code class="literal">sum</code>).</p><p class="calibre6">The other new language construct is <code class="literal">Array.sum</code>. Array is a module in the core F# libraries, which has a series of functions that you can apply to your data. The function <code class="literal">sum</code>, well, sums the values in the array, as you can probably guess by inspecting the result.</p><p class="calibre6">So, now, let's add a different function from the <code class="literal">Array</code> type:</p><div class="informalexample"><pre class="programlisting">let multiplied = ints |&gt; Array.map (fun i -&gt; i * 2)</pre></div><p class="calibre6">If you send it to the REPL, you should see this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val multiplied : int [] = [|2; 4; 6; 8; 10; 12|]</strong></span>
</pre></div><p class="calibre6"><code class="literal">Array.map</code> is an example of a high ordered function that is part of the <code class="literal">Array</code> type. Its parameter is another function. Effectively, we are passing a function into another function. In this case, we are creating an anonymous function that takes a parameter <code class="literal">i</code> and returns <code class="literal">i * 2</code>. You know it is an anonymous function because it starts with the keyword <code class="literal">fun</code> and the IDE makes it easy for us to understand that by making it blue. This anonymous function is <a id="id39" class="calibre1"/>also called a<a id="id40" class="calibre1"/> lambda expression, which has been in C# and VB.NET since .Net 3.5, so you might have run across it before. If you have a data science background using R, you are already quite familiar with lambdas.</p><p class="calibre6">Getting back to the higher-ordered function <code class="literal">Array.map</code>, you can see that it applies the lambda function against each item of the array and returns a new array with the new values.</p><div class="mediaobject"><img src="../images/00019.jpeg" alt="Learning F#" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">We will be using <code class="literal">Array.map</code> (and its more generic kin <code class="literal">Seq.map</code>) a lot when we start implementing machine learning models as it is the best way to transform an array of data. Also, if you have been paying attention to the buzz words of map/reduce when describing big data applications such as Hadoop, the word map means exactly the same thing in this context. One final note is that because of immutability in F#, the original array is not altered, instead, multiplied is bound to a new array.</p><p class="calibre6">Let's stay in the script and add in another couple more lines of code:</p><div class="informalexample"><pre class="programlisting">let multiplyByTwo x =
    x * 2</pre></div><p class="calibre6">If you send it to the REPL, you should see this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val multiplyByTwo : x:int -&gt; int</strong></span>
</pre></div><p class="calibre6">These two lines created a named function called <code class="literal">multiplyByTwo</code>. The function that takes a single parameter <code class="literal">x</code> and then returns the value of the parameter multiplied by <code class="literal">2</code>. This is exactly the same as our anonymous function we created earlier in-line that we passed into the <code class="literal">map</code> function. The syntax might seem a bit strange because of the <code class="literal">-&gt;</code> operator. You can read this as, "the function <code class="literal">multiplyByTwo</code> takes in a parameter called <code class="literal">x</code> of type <code class="literal">int</code> and returns an <code class="literal">int</code>."</p><p class="calibre6">Note three things here. Parameter <code class="literal">x</code> is inferred to be an <code class="literal">int</code> because it is used in the body of the function as multiplied to another <code class="literal">int</code>. If the function reads <code class="literal">x * 2.0</code>, the <code class="literal">x</code> would have been inferred as a float. This is a significant departure from C# and VB.NET but pretty familiar for<a id="id41" class="calibre1"/> people who use R. Also, there is no return statement for the function, instead, the final expression of any function is always returned as the result. The last thing to note is that whitespace is important so that the indentation is required. If the code was written like this:</p><div class="informalexample"><pre class="programlisting">let multiplyByTwo(x) =
x * 2</pre></div><p class="calibre6">The compiler would complain:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">Script1.fsx(8,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (7:1).</strong></span>
</pre></div><p class="calibre6">Since F# does not use curly braces and semicolons (or the end keyword), such as C# or VB.NET, it needs to use something to separate code. That separation is whitespace. Since it is good coding practice to use whitespace judiciously, this should not be very alarming to people having a C# or VB.NET background. If you have a background in R or Python, this should seem natural to you.</p><p class="calibre6">Since <code class="literal">multiplyByTwo</code> is the functional equivalent of the lambda created in <code class="literal">Array.map (fun i -&gt; i * 2)</code>, we can do this if we want:</p><div class="informalexample"><pre class="programlisting">let multiplied' = ints |&gt; Array.map (fun i -&gt; multiplyByTwo i)</pre></div><p class="calibre6">If you send it to the REPL, you should see this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val multiplied' : int [] = [|2; 4; 6; 8; 10; 12|]</strong></span>
</pre></div><p class="calibre6">Typically, we will use named functions when we need to use that function in several places in our code and we use a lambda expression when we only need that function for a specific line of code.</p><p class="calibre6">There is another minor thing to note. I used the tick notation for the value multiplied when I wanted to create another value that was representing the same idea. This kind of notation is used frequently in the scientific community, but can get unwieldy if you attempt to use it for a third or even fourth (multiplied'''') representation.</p><p class="calibre6">Next, let's add another named function to the REPL:</p><div class="informalexample"><pre class="programlisting">let isEven x =
    match x % 2 = 0 with
    | true -&gt; "even"
    | false -&gt; "odd"
isEven 2
isEven 3</pre></div><p class="calibre6">If you send it to the REPL, you should see this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val isEven : x:int -&gt; string</strong></span>
</pre></div><p class="calibre6">This is a function named <code class="literal">isEven</code> that takes a single parameter <code class="literal">x</code>. The body of the function uses a pattern-matching<a id="id42" class="calibre1"/> statement to determine whether the parameter is odd or even. When it is odd, then it returns the string <code class="literal">odd</code>. When it is even, it returns the string <code class="literal">even</code>.</p><p class="calibre6">There is one really interesting thing going on here. The match statement is a basic example of pattern matching and it is one of the coolest features of F#. For now, you can consider the match statement much like the switch statement that you may be familiar within R, Python, C#, or VB.NET, but we will see how it becomes much more powerful in the later chapters. I would have written the conditional logic like this:</p><div class="informalexample"><pre class="programlisting">let isEven' x =
    if x % 2 = 0 then "even" else "odd"</pre></div><p class="calibre6">But I prefer to use pattern matching for this kind of conditional logic. In fact, I will attempt to go through this entire book without using an <code class="literal">if…then</code> statement.</p><p class="calibre6">With <code class="literal">isEven</code> written, I can now chain my functions together like this:</p><div class="informalexample"><pre class="programlisting">let multipliedAndIsEven = 
    ints
    |&gt; Array.map (fun i -&gt; multiplyByTwo i)
    |&gt; Array.map (fun i -&gt; isEven i)</pre></div><p class="calibre6">If you send it to REPL, you should see this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val multipliedAndIsEven : string [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|"even"; "even"; "even"; "even"; "even"; "even"|]</strong></span>
</pre></div><p class="calibre6">In this case, the resulting array from the first pipe <code class="literal">Array.map (fun i -&gt; multiplyByTwo i))</code> gets sent to the next function <code class="literal">Array.map (fun i -&gt; isEven i)</code>. This means we might have three arrays floating around in memory: ints which is passed into the first pipe, the result from the first pipe that is passed into the second pipe, and the result from the second pipe. From your mental model point of view, you can think about each array being passed from one function into the next. In this book, I will be chaining pipe forwards frequently as it is such a powerful construct and it perfectly matches the thought process when we are creating and using machine learning models.</p><p class="calibre6">You now know enough F# to get you up and running with the first machine learning models in this book. I will be introducing other F# language features as the book goes along, but this is a good <a id="id43" class="calibre1"/>start. As you will see, F# is truly a powerful language where a simple syntax can lead to very complex work.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Third-party libraries" id="KVCC1-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec15" class="calibre1"/>Third-party libraries</h1></div></div></div><p class="calibre6">The following are a<a id="id44" class="calibre1"/> few third-party libraries that we will cover in our book later on.</p></div>

<div class="book" title="Third-party libraries" id="KVCC1-a18db0be6c20485ba81f22e43ca13055">
<div class="book" title="Math.NET"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec08" class="calibre1"/>Math.NET</h2></div></div></div><p class="calibre6">Math.NET is an open source <a id="id45" class="calibre1"/>project that was created to augment (and sometimes replace) the functions that are available in <code class="literal">System.Math</code>. Its home<a id="id46" class="calibre1"/> page is <a class="calibre1" href="http://www.mathdotnet.com/">http://www.mathdotnet.com/</a>. We will be using Math.Net's <code class="literal">Numerics</code> and <code class="literal">Symbolics</code> namespaces in some of the machine learning algorithms that we will <a id="id47" class="calibre1"/>write by hand. A nice feature about Math.Net is that it has strong support for F#.</p></div></div>

<div class="book" title="Third-party libraries" id="KVCC1-a18db0be6c20485ba81f22e43ca13055">
<div class="book" title="Accord.NET"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec09" class="calibre1"/>Accord.NET</h2></div></div></div><p class="calibre6">Accord.NET is an open <a id="id48" class="calibre1"/>source project that was created to implement many common machine learning models. Its<a id="id49" class="calibre1"/> home page is <a class="calibre1" href="http://accord-framework.net/">http://accord-framework.net/</a>. Although the focus of Accord.NET was for computer vision and signal processing, we will be using Accord.Net<a id="id50" class="calibre1"/> extensively in this book as it makes it very easy to implement algorithms in our problem domain.</p></div></div>

<div class="book" title="Third-party libraries" id="KVCC1-a18db0be6c20485ba81f22e43ca13055">
<div class="book" title="Numl"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec10" class="calibre1"/>Numl</h2></div></div></div><p class="calibre6">Numl is an open source<a id="id51" class="calibre1"/> project that implements several common machine learning models as experiments. Its home page is <a class="calibre1" href="http://numl.net/">http://numl.net/</a>. Numl is newer than any of the <a id="id52" class="calibre1"/>other third-party libraries<a id="id53" class="calibre1"/> that we will use in the book, so it may not be as extensive as the other ones, but it can be very powerful and helpful in certain situations. We will be using Numl in several chapters of the book.</p></div></div>
<div class="book" title="Summary" id="LTSU1-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec16" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">We covered a lot of ground in this chapter. We discussed what machine learning is, why you want to learn about it in the .NET stack, how to get up and running using F#, and had a brief introduction to the major open source libraries that we will be using in this book. With all this preparation out of the way, we are ready to start exploring machine learning.</p><p class="calibre6">In the next chapter, we will apply our newly found F# skills to create a simple linear regression to see if we can help AdventureWorks improve their sales.</p></div></body></html>