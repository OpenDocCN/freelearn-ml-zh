- en: Simulating a Differential Drive Robot Using ROS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ROS模拟差速驱动机器人
- en: 'In the previous chapter, we looked at how to model Chefbot. In this chapter,
    we are going to learn how to simulate the robot using the Gazebo simulator in
    ROS. We will learn how to create a simulation model of Chefbot, and we will create
    a hotel-like environment in Gazebo to test our application, which is programmed
    to automatically deliver food to customers. We will look at a detailed explanation
    of each of the steps to test out our application. The following are the important
    topics that we are going to cover in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了如何对Chefbot进行建模。在本章中，我们将学习如何使用ROS中的Gazebo模拟器来模拟机器人。我们将学习如何创建Chefbot的模拟模型，并在Gazebo中创建一个类似酒店的环境来测试我们的应用程序，该应用程序被编程为自动向客户送餐。我们将详细解释每个步骤以测试我们的应用程序。以下是我们将在本章中涉及的重要主题：
- en: Getting started with the Gazebo simulator
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Gazebo模拟器
- en: Working with the TurtleBot 2 simulation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与TurtleBot 2模拟器一起工作
- en: Creating a simulation of Chefbot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Chefbot的模拟
- en: URDF tags and plugins for simulations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于模拟的URDF标签和插件
- en: Getting started with simultaneous localization and mapping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用同时定位与建图
- en: Implementing SLAM in a Gazebo environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Gazebo环境中实现SLAM
- en: Creating a map using SLAM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SLAM创建地图
- en: Getting started with adaptive Monte Carlo localization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用自适应蒙特卡洛定位
- en: Implementing AMCL in a Gazebo environment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Gazebo环境中实现AMCL
- en: Autonomous navigation of Chefbot in a hotel using Gazebo
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gazebo在酒店中自主导航Chefbot
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To test the application and codes in this chapter, you need an Ubuntu 16.04
    LTS PC/laptop with ROS Kinetic installed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试本章中的应用程序和代码，您需要一个安装了ROS Kinetic的Ubuntu 16.04 LTS PC/笔记本电脑。
- en: Getting started with the Gazebo simulator
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Gazebo模拟器
- en: In the first chapter, we looked at the basic concepts of the Gazebo simulator
    and its installation procedures. In this chapter, we will learn more about the
    usage of Gazebo and how to simulate a differential drive robot in the Gazebo simulator.
    The first step is to understand the GUI interfaces and its various controls. As
    we have discussed in the first chapter, Gazebo has two main sections. The first
    is the Gazebo server and the second is the Gazebo client. The simulation is done
    on the Gazebo server, which acts as a backend. The GUI is the frontend, which
    acts as the Gazebo client. We will also look at Rviz (ROS Visualizer), which is
    a GUI tool in ROS that is used to visualize different kinds of robot sensor data
    from robot hardware or a simulator, such as Gazebo.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们探讨了Gazebo模拟器的基本概念及其安装过程。在本章中，我们将更深入地了解Gazebo的使用方法以及如何在Gazebo模拟器中模拟差速驱动机器人。第一步是理解GUI界面及其各种控制。正如我们在第一章中讨论的那样，Gazebo有两个主要部分。第一部分是Gazebo服务器，第二部分是Gazebo客户端。模拟是在Gazebo服务器上进行的，它充当后端。GUI是前端，充当Gazebo客户端。我们还将探讨Rviz（ROS可视化器），这是一个ROS中的GUI工具，用于从机器人硬件或模拟器（如Gazebo）可视化不同类型的机器人传感器数据。
- en: We can use Gazebo as an independent simulator to simulate the robot, or we can
    use interfaces with ROS and Python that can be used to program robots in the Gazebo
    simulator. If we are using Gazebo as an independent simulator, the default option
    to simulate the robot is by writing C++-based plugins ([http://gazebosim.org/tutorials/?tut=plugins_hello_world](http://gazebosim.org/tutorials/?tut=plugins_hello_world)).
    We can write C++ plugins for simulating a robot's behavior, creating new sensors,
    creating a new world, and so on. By default, the modeling of robots and environments
    in Gazebo is done using the SDF ([http://sdformat.org/](http://sdformat.org/))
    file. If we are using an ROS interface for Gazebo, we have to create a URDF file
    that contains all the parameters of the robot and has Gazebo-specific tags to
    mention the simulation properties of the robot. When we start the simulation using
    URDF, it will convert to an SDF file using some tools and display the robot in
    Gazebo. The ROS interface of Gazebo is called gazebo-ros-pkgs. It is a set of
    wrappers and plugins that have the ability to model a sensor, robot controller,
    and other simulations in Gazebo and communicate over ROS topics. In this chapter,
    we will be mainly focusing on the ROS-Gazebo interface for simulating Chefbot.
    The advantage of the ROS-Gazebo interface is that we can program the robot by
    making use of the ROS framework. We can program the robot using popular programming
    languages such as C++ and Python using ROS.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 Gazebo 作为独立的模拟器来模拟机器人，或者我们可以使用与 ROS 和 Python 的接口，这些接口可以用来在 Gazebo 模拟器中编程机器人。如果我们使用
    Gazebo 作为独立的模拟器，模拟机器人的默认选项是通过编写基于 C++ 的插件（[http://gazebosim.org/tutorials/?tut=plugins_hello_world](http://gazebosim.org/tutorials/?tut=plugins_hello_world)）。我们可以编写
    C++ 插件来模拟机器人的行为，创建新的传感器，创建新的世界等等。默认情况下，Gazebo 中机器人和环境的建模是通过 SDF ([http://sdformat.org/](http://sdformat.org/))
    文件完成的。如果我们使用 ROS 接口来使用 Gazebo，我们必须创建一个包含所有机器人参数并具有 Gazebo 特定标签来提及机器人模拟属性的 URDF
    文件。当我们使用 URDF 启动模拟时，它将使用一些工具转换为 SDF 文件，并在 Gazebo 中显示机器人。Gazebo 的 ROS 接口称为 gazebo-ros-pkgs。它是一组包装器和插件，具有在
    Gazebo 中建模传感器、机器人控制器和其他模拟以及通过 ROS 主题进行通信的能力。在本章中，我们将主要关注 ROS-Gazebo 接口，用于模拟 Chefbot。ROS-Gazebo
    接口的优势在于我们可以通过利用 ROS 框架来编程机器人。我们可以使用 ROS 使用流行的编程语言，如 C++ 和 Python 来编程机器人。
- en: If you are not interested in using ROS and want to program the robot using Python,
    you should check out an interface called pygazebo ([https://github.com/jpieper/pygazebo](https://github.com/jpieper/pygazebo)).
    It is a Python binding of Gazebo. In the next section, we will see the GUI of
    Gazebo, along with some of its important controls.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不感兴趣使用 ROS，并想使用 Python 编程机器人，您应该查看一个名为 pygazebo ([https://github.com/jpieper/pygazebo](https://github.com/jpieper/pygazebo))
    的接口。它是 Gazebo 的 Python 绑定。在下一节中，我们将看到 Gazebo 的 GUI，以及其中的一些重要控件。
- en: The Gazebo's graphical user interface
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gazebo 的图形用户界面
- en: 'We can start Gazebo in several ways. You have already seen this in *Chapter
    1, Getting Started with Robot Operating System*. In this chapter, we are using
    the following command to start an empty world, meaning that there is no robot
    and no environment:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式启动 Gazebo。您已经在 *第 1 章，开始使用机器人操作系统* 中看到了这一点。在本章中，我们使用以下命令启动一个空世界，这意味着没有机器人和环境：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding command will start the Gazebo server and client and load an empty
    world into Gazebo. Here is the view of the empty world in Gazebo:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将启动 Gazebo 服务器和客户端，并将一个空世界加载到 Gazebo 中。以下是 Gazebo 中空世界的视图：
- en: '![](img/a8b1fed3-5755-414e-9712-211259906122.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a8b1fed3-5755-414e-9712-211259906122.png)'
- en: Gazebo user interface
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Gazebo 用户界面
- en: 'The Gazebo user interface can be divided into three sections: **Scene**, **Left
    Panel**, and the **Right Panel**.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Gazebo 用户界面可以分为三个部分：**场景**、**左侧面板**和**右侧面板**。
- en: The Scene
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景
- en: The Scene is the place where the simulation of the robot takes place. We can
    add various objects to the scene, and we can interact with the robot in the scene
    using the mouse and keyboard.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 场景是机器人模拟发生的地方。我们可以向场景添加各种对象，并可以使用鼠标和键盘与场景中的机器人进行交互。
- en: The Left Panel
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 左侧面板
- en: 'You can see the left Panel when we launch Gazebo. There are three main tabs
    in the Left Panel:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动 Gazebo 时，您可以看到左侧面板。左侧面板有三个主要选项卡：
- en: '**World**: The **World** tab contains a list of models in the current Gazebo
    Scene. Here, we can modify model parameters, such as the pose, and can also change
    the camera''s pose.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**世界**：**世界**选项卡包含当前 Gazebo 场景中的模型列表。在这里，我们可以修改模型参数，例如姿态，也可以更改摄像机的姿态。'
- en: '**Insert**: The **Insert** tab allows you to add a new simulation model to
    the Scene. The models are available in the local system, as well as the remote
    server. The `/home/<user_name>/.gazebo/model` folder will keep the local model
    files and models in the remote server in [http://gazebosim.org/models](http://gazebosim.org/models),
    as shown in the following screenshot:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：**插入**选项卡允许您向场景添加新的仿真模型。这些模型可在本地系统以及远程服务器中找到。`/home/<用户名>/.gazebo/model`文件夹将保存本地模型文件和远程服务器中的模型，如下面的截图所示：'
- en: '![](img/122b4b47-772b-4175-b19b-87c54b5cc0aa.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/122b4b47-772b-4175-b19b-87c54b5cc0aa.png)'
- en: The Insert tab in the left panel of Gazebo
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Gazebo左侧面板中的插入选项卡
- en: You can see both the local files and remote files in the **Insert** tab that
    is shown in the preceding screenshot.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在前面截图所示的**插入**选项卡中看到本地文件和远程文件。
- en: When you start Gazebo for the first time, or when you start a world that has
    models from the remote server, you may see a black screen on Gazebo or a warning
    on the terminal. This is because the model in the remote server is being downloaded
    and Gazebo has to wait a while. The waiting time can vary according to the speed
    of your internet connection. Once the model is downloaded, it will be kept in
    the local model folder, so there will not be any delay the next time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当您第一次启动Gazebo或启动包含来自远程服务器模型的场景时，您可能在Gazebo上看到黑色屏幕或在终端上看到警告。这是因为远程服务器中的模型正在下载，Gazebo必须等待一段时间。等待时间会根据您的互联网连接速度而变化。一旦模型下载完成，它将被保存在本地模型文件夹中，因此下次将不会有任何延迟。
- en: '**Layers**: Most of the time, we will not use this tab. This tab is for organizing
    the different visualizations available in the simulation. We can hide/unhide the
    models in the simulation by toggling each layer. Most of the time in the simulation,
    this tab will be empty.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图层**：大多数时候，我们不会使用此选项卡。此选项卡用于组织模拟中可用的不同可视化。我们可以通过切换每个图层来隐藏/显示模拟中的模型。在模拟的大多数情况下，此选项卡将是空的。'
- en: Right Panel
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 右侧面板
- en: The Right panel is hidden by default. We have to drag it in order to view it.
    This panel enables us to interact with the mobile parts of the model. We can see
    the joints of the model if we select the model in the scene.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，右侧面板是隐藏的。我们必须将其拖动才能查看。此面板使我们能够与模型的移动部分交互。如果我们选择场景中的模型，我们可以看到模型的关节。
- en: Gazebo toolbars
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gazebo工具栏
- en: The Gazebo has two toolbars. One is above the Scene and one is below it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Gazebo有两个工具栏。一个位于场景上方，另一个位于场景下方。
- en: Upper toolbar
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上工具栏
- en: 'he upper toolbar is very useful for interacting with the Gazebo Scene. This
    toolbar is mainly for manipulating the Gazebo Scene. It has functions to select
    the model, scale it, translate and rotate it, and add new shapes to the scene:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上工具栏对于与Gazebo场景交互非常有用。此工具栏主要用于操作Gazebo场景。它具有选择模型、缩放、平移和旋转模型以及向场景添加新形状的功能：
- en: '![](img/47124ce9-d9b2-49fa-a1aa-44d43dc35a2c.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47124ce9-d9b2-49fa-a1aa-44d43dc35a2c.png)'
- en: Upper toolbar of Gazebo
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Gazebo的上工具栏
- en: 'The following list shows you detailed descriptions of each option:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了每个选项的详细描述：
- en: '**Select Mode**: If we are in Select Mode, we can select the models in the
    Scene and set their properties, as well as navigate inside the Scene.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择模式**：如果我们处于选择模式，我们可以选择场景中的模型并设置其属性，以及导航场景内部。'
- en: '**Translate Mode**: In Translate Mode, we can select a model and translate
    it model by clicking the Left button.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平移模式**：在平移模式下，我们可以选择一个模型并通过点击左键将其平移。'
- en: '**Rotate Mode**: In Rotate Mode, we can select the model and change its orientation.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转模式**：在旋转模式下，我们可以选择模型并改变其方向。'
- en: '**Scale Mode**: In Scale Mode, we can select the model and scale it.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩放模式**：在缩放模式下，我们可以选择模型并对其进行缩放。'
- en: '**Undo/Redo**: This enables us to undo or redo actions in the Scene.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**撤销/重做**：这使我们能够在场景中撤销或重做操作。'
- en: '**Simple Shapes**: With this option, we can insert primitive shapes into the
    scene, such as a cylinder, cube, or sphere.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单形状**：使用此选项，我们可以将原始形状插入场景，例如圆柱体、立方体或球体。'
- en: '**Lights**: The Lights option enables us to add different kinds of light sources
    into the Scene.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灯光**：灯光选项使我们能够向场景添加不同类型的灯光源。'
- en: '**Copy/Paste**: The Copy and Paste options enable us to copy and paste different
    models and parts of the Scene.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制/粘贴**：复制和粘贴选项使我们能够复制和粘贴不同的模型和场景的部分。'
- en: '**Align**: This enables us to align models to one another.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐**：这使我们能够将模型对齐。'
- en: '**Snap**: This snaps one model and moves it inside the Scene.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捕捉**：这会将一个模型捕捉并移动到场景内部。'
- en: '**Change view**: This changes the view of the Scene. It mainly uses the perspective
    view and orthogonal view.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改视图**：这会更改场景的视图。它主要使用透视视图和正交视图。'
- en: '**Screenshot:** This takes a screenshot of the current Scene.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**截图**：这会截取当前场景的截图。'
- en: '**Record Log:** This saves Gazebo''s logs.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录日志**：这会保存 Gazebo 的日志。'
- en: Bottom toolbar
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 底部工具栏
- en: The bottom toolbar mainly gives us an idea about the simulation. It displays
    the Simulation Time, which refers to the time that is passing within the simulator.
    The simulation can sped up or slowed down. This depends on the computation required
    for the current simulation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 底部工具栏主要给我们一个关于模拟的概览。它显示模拟时间，这指的是在模拟器内流逝的时间。模拟可以加速或减速。这取决于当前模拟所需的计算量。
- en: The Real Time display refers to the actual time passing in real life when the
    simulator is running. The **real time factor** (**RTF**) is the ratio between
    simulation time and the speed of real time. If the RTF is one, it means that the
    simulation is happening at a rate identical to the speed of time in reality.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实时显示指的是当模拟器运行时在现实生活中流逝的实际时间。**实时因子（RTF**）是模拟时间和真实时间速度的比率。如果 RTF 为 1，则表示模拟以与现实中时间速度相同的速率进行。
- en: 'The state of the world in Gazebo can change with each iteration. Each iteration
    can make changes in Gazebo for a fixed amount of time. That fixed time is called
    the step size. By default, the step size is 1 millisecond. The step size and iteration
    are shown in the tool bar, as shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Gazebo 中的世界状态会随着每次迭代而改变。每次迭代可以在 Gazebo 中进行固定时间内的更改。这个固定时间被称为步长。默认情况下，步长为 1 毫秒。步长和迭代在工具栏中显示，如下面的截图所示：
- en: '![](img/e829777b-5166-47cc-8597-0b4bae78a4b3.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e829777b-5166-47cc-8597-0b4bae78a4b3.png)'
- en: Lower toolbar of Gazebo
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Gazebo 的下工具栏
- en: We can pause the simulation and see each step using the **Step** button.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**步进**按钮暂停模拟并查看每个步骤。
- en: You can get more information about the Gazebo GUI from [http://gazebosim.org/tutorials?cat=guided_b&amp;tut=guided_b2](http://gazebosim.org/tutorials?cat=guided_b&tut=guided_b2).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [http://gazebosim.org/tutorials?cat=guided_b&tut=guided_b2](http://gazebosim.org/tutorials?cat=guided_b&tut=guided_b2)
    获取更多关于 Gazebo GUI 的信息。
- en: Before going to the next section, you can play with Gazebo and learn more about
    how it works.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一节之前，您可以尝试使用 Gazebo 并了解更多关于其工作原理的信息。
- en: Working with a TurtleBot 2 simulation
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TurtleBot 2 模拟
- en: After working with Gazebo, now it's time to run a simulation on it and work
    with some robots. One of the popular robots available for education and research
    is TurtleBot. The TurtleBot software was developed within the ROS framework, and
    there is a good simulation of its operations available in Gazebo. The popular
    versions of TurtleBot are TurtleBot 2 and 3\. We will learn about TurtleBot 2
    in this section because our development of Chefbot was inspired by its design.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Gazebo 的工作之后，现在是我们运行模拟并处理一些机器人的时候了。在教育和研究领域，TurtleBot 是一种流行的机器人。TurtleBot
    软件是在 ROS 框架内开发的，Gazebo 中有它操作的很好模拟。TurtleBot 的流行版本有 2 和 3。我们将在本节中学习 TurtleBot 2，因为
    Chefbot 的开发受到了其设计的启发。
- en: 'Installing TurtleBot 2 simulation packages in Ubuntu 16.04 is straightforward.
    You can use the following command to install TurtleBot 2 simulation packages for
    Gazebo:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 16.04 中安装 TurtleBot 2 模拟包非常简单。您可以使用以下命令安装 TurtleBot 2 模拟包用于 Gazebo：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After installing the packages, we can start running the simulation. There are
    several launch files inside the turtlebot-gazebo packages that have different
    world files. A Gazebo world file (`*.world`) is an SDF file consisting of the
    properties of the models in the environment. When the world file changes, Gazebo
    will load with a different environment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完包后，我们可以开始运行模拟。turtlebot-gazebo 包内包含几个不同的启动文件，它们具有不同的世界文件。Gazebo 世界文件（`*.world`）是一个
    SDF 文件，包含环境中模型的属性。当世界文件更改时，Gazebo 将加载不同的环境。
- en: 'The following command will start a world that has a certain set of components:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将启动一个包含特定组件集的世界：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The simulation will take some time to load, and when it loads, you will see
    the following models in the Gazebo Scene:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟加载需要一些时间，加载完成后，您将在 Gazebo 场景中看到以下模型：
- en: '![](img/92bc12f5-0ac0-42ad-8efd-3fb132a0e954.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/92bc12f5-0ac0-42ad-8efd-3fb132a0e954.png)'
- en: TurtleBot 2 simulation in Gazebo
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Gazebo 中的 TurtleBot 2 模拟
- en: 'When we load the simulation in Gazebo, it will also load the necessary plugins
    to interact with ROS. TurtleBot 2 has the following important components:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Gazebo中加载模拟时，它也会加载与ROS交互所需的插件。TurtleBot 2有以下重要组件：
- en: A mobile base with a differential drive
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有差速驱动的移动底盘
- en: A depth sensor for creating a map
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建地图的深度传感器
- en: A bumper switch to detect collision
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于检测碰撞的碰撞开关
- en: When the simulation loads, it will load the ROS-Gazebo plugins to simulate a
    differential drive mobile base, depth sensor (Kinect or Astra), and plugins for
    bumper switches. So, after loading the simulation, if we enter a `$ rostopic list`
    command in the terminal, a selection of topics will appear as shown in the following
    screenshot.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟加载时，它将加载ROS-Gazebo插件来模拟差速驱动移动底盘、深度传感器（Kinect或Astra）和碰撞开关插件。因此，在加载模拟后，如果我们输入终端中的`$
    rostopic list`命令，将出现一系列主题，如下面的截图所示。
- en: As we saw earlier, we can see the topics from the differential drive plugin,
    depth sensor, and bumper switches. In addition to these, we can see the topics
    from the ROS-Gazebo plugins that mainly contain the current state of the robot
    and other models in the simulation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，我们可以从差速驱动插件、深度传感器和碰撞开关中看到主题。除此之外，我们还可以看到来自ROS-Gazebo插件的主题，这些主题主要包含机器人在模拟中的当前状态和其他模型。
- en: 'The Kinect/Astra sensors can give an RGB image and depth image. The differential
    drive plugin can send the odometry data of the robot in the `/odom` (`nav_msgs/Odometry`)
    topic and can publish the robot''s transformation in the `/tf` (`tf2_msgs/TFMessage`)
    topics, as shown in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kinect/Astra传感器可以提供RGB图像和深度图像。差速驱动插件可以将机器人的里程计数据发送到`/odom`（`nav_msgs/Odometry`）主题，并在`/tf`（`tf2_msgs/TFMessage`）主题中发布机器人的变换，如下面的截图所示：
- en: '![](img/eac279c0-935f-46f8-b44c-d60a905d751c.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eac279c0-935f-46f8-b44c-d60a905d751c.png)'
- en: ROS topics from the TurtleBot 2 simulation
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: TurtleBot 2模拟的ROS主题
- en: 'We can visualize the robot model and sensor data in Rviz. There is a TurtleBot
    package dedicated for visualization. You can install the following package to
    visualize the robot data:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Rviz中可视化机器人模型和传感器数据。有一个专门用于可视化的TurtleBot包。您可以通过安装以下包来可视化机器人数据：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After installing this package, we can use the following launch file to visualize
    the robot and its sensor data:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 安装此包后，我们可以使用以下启动文件来可视化机器人和其传感器数据：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will get the following Rviz window with the robot model displayed in it.
    We can then enable the sensor displays to visualize this particular data, as shown
    in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下带有显示机器人模型的Rviz窗口。然后我们可以启用传感器显示来可视化这些特定数据，如下面的截图所示：
- en: '![](img/4c288263-0b1a-45b7-b09c-593ed6df1ead.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c288263-0b1a-45b7-b09c-593ed6df1ead.png)'
- en: TurtleBot 2 visualization in Rviz
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: TurtleBot 2在Rviz中的可视化
- en: In the next section, we will learn how to move this robot.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何移动这个机器人。
- en: Moving the robot
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动机器人
- en: The differential drive plugin of the robot is capable of receiving ROS Twist
    messages (`geometry_msgs/Twist`), which consist of the current linear and angular
    velocities of the robot. The teleoperation of the robot means moving the robot
    manually using a joy stick or keyboard by using ROS Twist messages. We will now
    look at how to move the Turtlebot 2 robot using keyboard teleoperation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人的差速驱动插件能够接收ROS Twist消息（`geometry_msgs/Twist`），这些消息包含机器人的当前线性和角速度。机器人的遥控意味着通过使用ROS
    Twist消息手动使用操纵杆或键盘来移动机器人。我们现在将看看如何使用键盘遥控来移动Turtlebot 2机器人。
- en: 'We have to install a package to teleoperate the TurtleBot 2 robot. The following
    command will install the TurtleBot teleoperation package:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须安装一个包来遥控TurtleBot 2机器人。以下命令将安装TurtleBot遥控包：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To start teleoperation, we have to start the Gazebo simulator first, and then
    start the teleoperation node using the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始遥控操作，我们首先需要启动Gazebo模拟器，然后使用以下命令启动遥控节点：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the terminal, we can see the key combination for moving the robot. You can
    move it using those keys, and you will see the robot moving in Gazebo and Rviz,
    as shown in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我们可以看到移动机器人的快捷键组合。您可以使用这些键来移动它，您将看到机器人在Gazebo和Rviz中的移动，如下面的截图所示：
- en: '![](img/45b86691-5f61-415d-aff2-573de750e345.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/45b86691-5f61-415d-aff2-573de750e345.png)'
- en: TurtleBot 2 keyboard teleoperation
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: TurtleBot 2键盘遥控
- en: 'When we press the buttons on the keyboard, it will send a Twist message to
    the differential drive controller, and the controller will move the robot in the
    simulation. The teleop node sends a topic called `/cmd_vel_mux/input/teleop` (`geometry_msgs/Twist`),
    which is shown in the following diagram:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按下键盘上的按钮时，它将向差速驱动控制器发送Twist消息，控制器将在模拟中移动机器人。teleop节点发送一个名为`/cmd_vel_mux/input/teleop`（`geometry_msgs/Twist`）的主题，如下图所示：
- en: '![](img/8412f9ba-3fa4-4742-8035-cbcab5be31bb.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8412f9ba-3fa4-4742-8035-cbcab5be31bb.png)'
- en: The TurtleBot keyboard teleoperation node
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: TurtleBot键盘遥控节点
- en: Creating a simulation of Chefbot
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Chefbot的模拟
- en: We have seen how the turtlebot simulation works. In this section, we will be
    looking at how to create our own robot simulation using Gazebo.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了turtlebot模拟的工作原理。在本节中，我们将探讨如何使用Gazebo创建自己的机器人模拟。
- en: Before we start discussing this subject, you should copy the `chefbot_gazebo`
    package to your catkin workspace and enter `catkin_make` to build the package.
    Make sure you have two packages in your workspace, one called `chefbot_description`
    and the other called `chefbot_gazebo`. The `chefbot_gazebo` package contains a
    simulation-related launch file and parameters, and `chefbot_description` has the
    robot's URDF model, along with its simulation parameters, and the launch file
    that is used to view the robot in Rviz and Gazebo.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论这个主题之前，你应该将`chefbot_gazebo`包复制到你的catkin工作区，并执行`catkin_make`来构建包。确保你的工作区中有两个包，一个叫做`chefbot_description`，另一个叫做`chefbot_gazebo`。`chefbot_gazebo`包包含与模拟相关的launch文件和参数，而`chefbot_description`包含机器人的URDF模型，以及其模拟参数和用于在Rviz和Gazebo中查看机器人的launch文件。
- en: Let's begin creating our Chefbot model in Gazebo so that you can familiarize
    yourself with the procedure. After that, we will dig deep into the xacro file
    and can look at the simulation parameters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Gazebo中开始创建我们的Chefbot模型，这样你就可以熟悉这个过程。之后，我们将深入探讨xacro文件，并查看模拟参数。
- en: 'The following launch file will show the robot model in Gazebo with an empty
    world and start all the Gazebo plugins for the robot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下launch文件将在Gazebo中显示带有空世界的机器人模型，并启动所有用于机器人的Gazebo插件：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following figure shows a screenshot of the Chefbot in Gazebo:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了Gazebo中的Chefbot截图：
- en: '![](img/4b2a0759-4163-4c93-8715-ff1030f0b0de.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b2a0759-4163-4c93-8715-ff1030f0b0de.png)'
- en: The Chefbot in Gazebo
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Gazebo中的Chefbot
- en: Let's see how we can add a URDF robot model in Gazebo. You can find the definition
    of the URDF robot model at `chefbot_description/launch/view_robot_gazebo.launch`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Gazebo中添加URDF机器人模型。你可以在`chefbot_description/launch/view_robot_gazebo.launch`中找到URDF机器人模型的定义。
- en: 'The first section of the code calls the `upload_model.launch` file for creating
    the `robot_description` parameter. If it is successful, then it will start an
    empty world in Gazebo:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一部分调用了`upload_model.launch`文件来创建`robot_description`参数。如果成功，它将在Gazebo中启动一个空的世界：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So how does the robot model in the `robot_description` parameter show in Gazebo?
    The following code snippet in the launch file does that job:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在Gazebo中如何显示`robot_description`参数中的机器人模型？以下launch文件中的代码片段完成了这项工作：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The node called `spawn_model` inside the `gazebo_ros` package will read the
    `robot_description` and spawn the model in Gazebo. The `-z 0.1` argument indicates
    the height of the model to be placed in Gazebo. If the height is 0.1, the model
    will be spawned at a height of 0.1\. If gravity is enabled, then the model will
    fall to the ground. We can change this parameter according to our requirement.
    The `-model` argument is the name of the robot model in Gazebo. This node will
    parse all the Gazebo parameters from the `robot_description` and start the simulation
    in Gazebo.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`gazebo_ros`包内的`spawn_model`节点将读取`robot_description`并在Gazebo中生成模型。`-z 0.1`参数表示要在Gazebo中放置的模型的高度。如果高度为0.1，则模型将在0.1的高度生成。如果启用了重力，则模型将落到地面上。我们可以根据需要更改此参数。`-model`参数是Gazebo中机器人模型的名字。此节点将解析`robot_description`中的所有Gazebo参数，并在Gazebo中启动模拟。'
- en: 'After spawning the model, we can publish the robot transformation (tf) using
    the following lines of code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型生成后，我们可以使用以下代码行发布机器人变换（tf）：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are publishing the ROS tf at 30 Hz.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在以30Hz的频率发布ROS tf。
- en: Depth image to laser scan conversion
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度图像到激光扫描转换
- en: 'The depth sensor on the robot provides the 3D coordinates of the environment.
    To achieve autonomous navigation, we can use this data to create a 3D map. There
    are different techniques for creating a map of the environment. One of the algorithms
    that we are using for this robot is called gmapping ([http://wiki.ros.org/gmapping](http://wiki.ros.org/gmapping)).
    The gmapping algorithm mainly use a laser scan for creating the map, but in our
    case, we get an entire 3D point cloud from the sensor. We can convert the 3D depth
    data from a laser scan by taking a slice of the depth data. The following nodelet
    ([http://wiki.ros.org/nodelet](http://wiki.ros.org/nodelet)) in this launch file
    is able to receive the depth data and convert it to laser scan data:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人上的深度传感器提供了环境的 3D 坐标。为了实现自主导航，我们可以使用这些数据创建 3D 地图。创建环境地图的技术有很多种。我们为这个机器人使用的算法之一叫做
    gmapping ([http://wiki.ros.org/gmapping](http://wiki.ros.org/gmapping))。gmapping
    算法主要使用激光扫描来创建地图，但在这个案例中，我们从传感器获取整个 3D 点云。我们可以通过截取深度数据来将激光扫描的 3D 深度数据转换。以下 launch
    文件中的节点（[http://wiki.ros.org/nodelet](http://wiki.ros.org/nodelet)）能够接收深度数据并将其转换为激光扫描数据：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The nodelet is a special kind of ROS node that has a property called zero copy
    transport, meaning that it doesn't take network bandwidth to subscribe to a topic.
    This will make the conversion from the depth image (`sensor_msgs/Image`) to the
    laser scan (`sensor_msgs/LaserScan`) faster and more efficient. One of the other
    properties of the nodelet is that it can be dynamically loaded as plugins. We
    can set various properties of this nodelet, such as the `range_min`, name of the
    image topic, and the output laser topic.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 节点是一个特殊的 ROS 节点，它有一个名为零拷贝传输的属性，这意味着它不需要网络带宽来订阅主题。这将使深度图像（`sensor_msgs/Image`）到激光扫描（`sensor_msgs/LaserScan`）的转换更快、更高效。节点的一个其他属性是它可以作为插件动态加载。我们可以设置此节点的各种属性，例如
    `range_min`、图像主题的名称和输出激光主题。
- en: URDF tags and plugins for Gazebo simulation
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URDF 标签和 Gazebo 模拟插件
- en: We have seen the simulated robot in Gazebo. Now, we will look in more detail
    at the simulation-related tags in URDF and the various plugins we have included
    in the URDF model.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 Gazebo 中看到了模拟的机器人。现在，我们将更详细地查看 URDF 中的与模拟相关的标签以及我们在 URDF 模型中包含的各种插件。
- en: 'Most of the Gazebo-specific tags are in the `chefbot_description/gazebo/chefbot.gazebo.xacro`
    file. Also, some of the tags in `chefbot_description/urdf/chefbot.xacro` are used
    in the simulation. Defining the `<collision>` and `<inertial>` tags in chefbot.xacro
    is very important for our simulation. The `<collision>` tag in URDF defines a
    boundary around the robot link, which is mainly used to detect the collision of
    that particular link, whereas the `<inertial>` tag encompasses the mass of the
    link and the moment of inertia. Here is an example of the `<inertial>` tag definition:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Gazebo 特定标签位于 `chefbot_description/gazebo/chefbot.gazebo.xacro` 文件中。此外，`chefbot_description/urdf/chefbot.xacro`
    文件中的一些标签也用于模拟。在 chefbot.xacro 中定义 `<collision>` 和 `<inertial>` 标签对于我们的模拟非常重要。URDF
    中的 `<collision>` 标签定义了机器人连杆周围的边界，主要用于检测该特定连杆的碰撞，而 `<inertial>` 标签则包含了连杆的质量和转动惯量。以下是
    `<inertial>` 标签定义的示例：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These parameters are part of the robot's dynamics, so in the simulation these
    values will have an effect on the robot model. Also, in the simulation, it will
    process all the links and joints, as well as its properties.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数是机器人动力学的一部分，因此在模拟中，这些值将对机器人模型产生影响。此外，在模拟中，它将处理所有连杆和关节，以及它们的属性。
- en: 'Next, we will look at the tags inside the `gazebo/chefbot.gazebo.xacro` file.
    The important Gazebo-specific tag we are using is `<gazebo>`, which is used to
    define the simulation properties of an element in the robot. We can either define
    a property that is applicable to all the links or one that is specific to a link.
    Here is a code snippet inside the xacro file that defines the coefficient of the
    friction of a link:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看 `gazebo/chefbot.gazebo.xacro` 文件内的标签。我们使用的最重要的 Gazebo 特定标签是 `<gazebo>`，它用于定义机器人中元素的模拟属性。我们可以定义一个适用于所有连杆的属性，或者一个特定于某个连杆的属性。以下是
    xacro 文件中定义连杆摩擦系数的代码片段：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `reference` property is used to specify a link in the robot. So, the preceding
    properties will only be applicable to the `chefbot_wheel_left_link`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`reference` 属性用于指定机器人中的连杆。因此，前面的属性将仅适用于 `chefbot_wheel_left_link`。'
- en: 'The following code snippet shows you how to set the color of a robot link.
    We can create custom colors, define the custom colors, or use the default colors
    in Gazebo. You can see that for the `base_link`, we are using the `Gazebo/White`
    color from Gazebo''s default property:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何设置机器人连接的颜色。我们可以创建自定义颜色，定义自定义颜色，或在Gazebo中使用默认颜色。您可以看到，对于`base_link`，我们正在使用Gazebo默认属性中的`Gazebo/White`颜色：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Refer to [http://gazebosim.org/tutorials/?tut=ros_urdf](http://gazebosim.org/tutorials/?tut=ros_urdf)
    to see all the tags that are used in the simulation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[http://gazebosim.org/tutorials/?tut=ros_urdf](http://gazebosim.org/tutorials/?tut=ros_urdf)以查看模拟中使用的所有标签。
- en: That covers the main tags of the simulation. Now we will look at the Gazebo-ROS
    plugins that we have used in this simulation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了模拟的主要标签。现在我们将查看在这个模拟中使用的Gazebo-ROS插件。
- en: Cliff sensor plugin
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 悬崖传感器插件
- en: The cliff sensor is a set of IR sensors that detect cliffs, which helps to avoid
    steps and prevents the robot from falling. This is one of the sensors in the mobile
    base of Turtlebot 2, called Kobuki ([http://kobuki.yujinrobot.com/](http://kobuki.yujinrobot.com/)).
    We're using this plugin in the Turtlebot 2 simulation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 悬崖传感器是一组红外传感器，用于检测悬崖，有助于避免台阶并防止机器人跌落。这是Turtlebot 2移动基座中的传感器之一，称为Kobuki ([http://kobuki.yujinrobot.com/](http://kobuki.yujinrobot.com/))。我们在Turtlebot
    2模拟中使用此插件。
- en: 'We can set the parameters of the sensors, such as the minimum and maximum angle
    of the IR beams, the resolution, and the number of samples per second. We can
    also limit the detection range of the sensor. There are three cliff sensors in
    our simulation model, as shown in the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置传感器的参数，例如红外光束的最小和最大角度、分辨率以及每秒的样本数。我们还可以限制传感器的检测范围。在我们的模拟模型中有三个悬崖传感器，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Contact sensor plugin
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接触传感器插件
- en: 'Here is the code snippet for the contact sensor on our robot. If the base of
    the robot collides with any objects, this plugin will trigger. It is commonly
    attached to the `base_link` of the robot, so whenever the bumper hits any object,
    this sensor will be triggered:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的机器人上接触传感器的代码片段。如果机器人的底部与任何物体发生碰撞，此插件将被触发。它通常连接到机器人的`base_link`，因此每当保险杠撞击任何物体时，此传感器将被触发：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Gyroscope plugin
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 陀螺仪插件
- en: 'The gyroscope plugin is used to measure the angular velocity of the robot.
    Using the angular velocity, we can compute the orientation of the robot. The orientation
    of the robot is used in the robot drive controller for computing the robot''s
    pose, as shown in the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 陀螺仪插件用于测量机器人的角速度。使用角速度，我们可以计算机器人的方向。机器人的方向用于机器人驱动控制器中计算机器人的姿态，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Differential drive plugin
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 差动驱动插件
- en: 'The differential drive plugin is the most important plugin of the simulation.
    This plugin simulates the differential drive behavior in the robot. It will move
    the robot model when it receives the command velocity (the linear and angular
    velocity) in the form of ROS Twist messages (`geometry_msgs/Twist`). This plugin
    also computes the odometry of the robot, which gives the local position of the
    robot, as shown in the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 差动驱动插件是模拟中最重要的插件。此插件模拟机器人的差动驱动行为。当它接收到命令速度（线性速度和角速度）的ROS Twist消息（`geometry_msgs/Twist`）时，将移动机器人模型。此插件还计算机器人的里程计，给出机器人的局部位置，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To compute the robot's odometry, we have to provide the robot's parameters,
    such as the distance between the wheels, wheel diameter, and the torque of the
    motors. According to our design, the wheel separation is 30 cm, the wheel diameter
    is 9 cm, and the torque is 18 N. If we want to publish the transformation of the
    robot, we can set the `publish_tf` as 1\. Each tag inside the plugin is the parameter
    of the corresponding plugin. As you can see, it takes all the inputs from the
    contact sensor, imu, and cliff sensor.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算机器人的里程计，我们必须提供机器人的参数，例如车轮之间的距离、车轮直径和电机的扭矩。根据我们的设计，车轮间距为30厘米，车轮直径为9厘米，扭矩为18
    N。如果我们想发布机器人的变换，可以将`publish_tf`设置为1。插件内的每个标签都是相应插件的参数。如您所见，它从接触传感器、IMU和悬崖传感器获取所有输入。
- en: The `libgazebo_ros_kobuki`.so plugin is installed along with Turtlebot 2 simulation
    packages. We are using the same plugin in our robot. We have to make sure that,
    the Turtlebot 2 simulation is installed on your system, prior to running this
    simulation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`libgazebo_ros_kobuki`.so插件与Turtlebot 2仿真包一起安装。我们在我们的机器人上使用相同的插件。我们必须确保在运行此仿真之前，Turtlebot
    2仿真已安装在你的系统上。'
- en: Depth camera plugin
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度相机插件
- en: 'The depth camera plugin simulates the characteristics of a depth camera, such
    as Kinect or Astra. The plugin name is `libgazebo_ros_openni_kinect.so`, and it
    helps us to simulate different kinds of depth sensors that have different characteristics.
    The plugin is shown in the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 深度相机插件模拟了深度相机的特性，例如Kinect或Astra。该插件名称为`libgazebo_ros_openni_kinect.so`，它帮助我们模拟具有不同特性的不同类型的深度传感器。该插件在以下代码中显示：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The plugin's publishers, the RGB image, depth image, and the point cloud data.
    We can set the camera matrix in the plugin, as well as customize other parameters.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的发布者，RGB图像、深度图像和点云数据。我们可以在插件中设置相机矩阵，以及自定义其他参数。
- en: You can refer to [http://gazebosim.org/tutorials?tut=ros_depth_camera&amp;cat=connect_ros](http://gazebosim.org/tutorials?tut=ros_depth_camera&cat=connect_ros)
    to learn more about the depth camera plugin in Gazebo.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考[http://gazebosim.org/tutorials?tut=ros_depth_camera&cat=connect_ros](http://gazebosim.org/tutorials?tut=ros_depth_camera&cat=connect_ros)来了解Gazebo中深度相机插件的更多信息。
- en: Visualizing the robot sensor data
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化机器人传感器数据
- en: 'In this section, we learn how to visualize the sensor data from the simulated
    robot. In the `chefbot_gazebo` package, there are launch files to start the robot
    in an empty world or in a hotel-like environment. The custom environment can be
    built using Gazebo itself. Just create the environment using primitive meshes
    and save as a `*. world` file, which can be the input of the `gazebo_ros` node
    in the launch file. For starting the hotel environment in Gazebo, you can use
    the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习如何从模拟机器人中可视化传感器数据。在`chefbot_gazebo`包中，有启动文件可以在空世界或类似酒店的环境中启动机器人。可以使用Gazebo本身构建自定义环境。只需使用原始网格创建环境，并保存为`*.world`文件，这可以作为启动文件中`gazebo_ros`节点的输入。要启动Gazebo中的酒店环境，可以使用以下命令：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](img/17b03ab3-7436-498a-b5a4-4665fe13f3e1.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17b03ab3-7436-498a-b5a4-4665fe13f3e1.png)'
- en: The Chefbot in Gazebo in the hotel environment
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 酒店环境中的Gazebo中的Chefbot
- en: The nine cubes inside the space represent nine tables. The robot can navigate
    to any of the tables to deliver food. We will learn how to do this, but before
    that, we will learn how to visualize the different kinds of sensor data from the
    robot model.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 空间内部的九个立方体代表九张桌子。机器人可以导航到任何一张桌子去送餐。我们将学习如何做到这一点，但在那之前，我们将学习如何从机器人模型中可视化不同类型的传感器数据。
- en: '![](img/676fd283-5240-4564-a88f-ab5e878c1829.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/676fd283-5240-4564-a88f-ab5e878c1829.png)'
- en: The Chefbot in Gazebo in the hotel environment
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 酒店环境中的Gazebo中的Chefbot
- en: 'The following command will launch the Rviz, which displays the sensor data
    from the robot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将启动Rviz，显示来自机器人的传感器数据：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This generates a visualization of the sensor data, as shown in the following
    screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成传感器数据的可视化，如下面的截图所示：
- en: '![](img/7f66a613-dc3a-4f86-b6ee-3fb46735ed1c.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f66a613-dc3a-4f86-b6ee-3fb46735ed1c.png)'
- en: The sensor visualization of Chefbot in Rviz
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Rviz中的Chefbot传感器可视化
- en: We can enable the Rviz display types to view different kinds of sensor data.
    In the preceding figure, you can see the depth cloud, laser scan, TF, robot model,
    and RGB camera images.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以启用Rviz显示类型来查看不同类型的传感器数据。在先前的图中，你可以看到深度云、激光扫描、TF、机器人模型和RGB相机图像。
- en: Getting started with Simultaneous Localization and Mapping
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用同时定位与建图
- en: One of the requirements of the Chefbot was that it should be able to navigate
    the environment autonomously and deliver food. To achieve this requirement, we
    have to use several algorithms, such as SLAM (Simultaneous Localization and Mapping)
    and AMCL (Adaptive Monte Carlo Localization). There are different approaches to
    solving the autonomous navigation problem. In this book, we are mainly sticking
    with these algorithms. The SLAM algorithms are used for mapping an environment
    at the same time as localizing the robot on the same map. It's seems like a chicken-and-egg
    problem, but now there are different algorithms to solve it. The AMCL algorithm
    is used to localize the robot in an existing map. The algorithm that we use in
    this book is called Gmapping ([http://www.openslam.org/gmapping.html](http://www.openslam.org/gmapping.html)),
    which implements Fast SLAM 2.0 ([http://robots.stanford.edu/papers/Montemerlo03a.html](http://robots.stanford.edu/papers/Montemerlo03a.html)).
    The standard gmapping library is wrapped in an ROS package called ROS Gmapping
    ([http://wiki.ros.org/gmapping](http://wiki.ros.org/gmapping)), which can be used
    in our application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Chefbot 的一个要求是它应该能够自主导航环境并递送食物。为了满足这一要求，我们必须使用几个算法，例如 SLAM（同时定位与建图）和 AMCL（自适应蒙特卡洛定位）。解决自主导航问题有不同方法。在本书中，我们主要坚持使用这些算法。SLAM
    算法用于在相同地图上同时进行环境建图和定位机器人。这似乎是一个鸡生蛋的问题，但现在有不同算法可以解决它。AMCL 算法用于在现有地图上定位机器人。本书中使用的算法称为
    Gmapping ([http://www.openslam.org/gmapping.html](http://www.openslam.org/gmapping.html))，它实现了
    Fast SLAM 2.0 ([http://robots.stanford.edu/papers/Montemerlo03a.html](http://robots.stanford.edu/papers/Montemerlo03a.html))。标准的
    gmapping 库被封装在一个名为 ROS Gmapping ([http://wiki.ros.org/gmapping](http://wiki.ros.org/gmapping))
    的 ROS 软件包中，可以在我们的应用中使用。
- en: The idea of the SLAM node is that as we move the robot around the environment,
    it will create a map of the environment using the laser scan data and the odometry
    data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: SLAM 节点的想法是，当我们移动机器人绕环境移动时，它将使用激光扫描数据和里程计数据创建环境的地图。
- en: Refer to the ROS Gmapping wiki page at [http://wiki.ros.org/gmapping](http://wiki.ros.org/gmapping) for
    more details. [](http://wiki.ros.org/gmapping)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 ROS Gmapping 维基页 [http://wiki.ros.org/gmapping](http://wiki.ros.org/gmapping)
    以获取更多详细信息。
- en: Implementing SLAM in the Gazebo environment
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Gazebo 环境中实现 SLAM
- en: 'In this section, we will learn how to implement SLAM and apply it to the simulation
    that we built. You can check the code at `chefbot_gazebo/launch/gmapping_demo.launch`
    and `launch/includes/ gmapping.launch.xml`. Basically, we are using a node from
    the gmapping package and configuring it with the proper parameters. The `gmapping.launch.xml`
    code fragment has the complete definition of this node. The following is the code
    snippet of this node:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何实现 SLAM 并将其应用于我们构建的仿真。您可以在 `chefbot_gazebo/launch/gmapping_demo.launch`
    和 `launch/includes/gmapping.launch.xml` 中查看代码。基本上，我们正在使用 gmapping 软件包中的一个节点，并使用适当的参数进行配置。`gmapping.launch.xml`
    代码片段包含了该节点的完整定义。以下是该节点的代码片段：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The name of the node that we are using is `slam_gmapping` and the package is
    `gmapping`. We have to provide a few parameters to this node, which can be found
    in the Gmapping wiki page.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所使用的节点名称是 `slam_gmapping`，而软件包名为 `gmapping`。我们必须为此节点提供一些参数，这些参数可以在 Gmapping
    维基页面上找到。
- en: Creating a map using SLAM
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SLAM 创建地图
- en: In this section, we will learn how to create a map of our environment using
    SLAM. First, however, there are several commands that we have to use to start
    mapping. You should execute each command in each Linux terminal.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 SLAM 创建我们环境的地图。然而，首先我们必须使用一些命令来启动建图。您应该在每个 Linux 终端中执行每个命令。
- en: 'First, we have to start our simulation using the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须使用以下命令启动我们的仿真：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we have to start the keyboard teleoperation node in a new terminal. This
    will help us move the robot manually using the keyboard:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须在新的终端中启动键盘遥控节点。这将帮助我们使用键盘手动移动机器人：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next command starts the SLAM in a new terminal:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令将在新的终端中启动 SLAM：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now the mapping will begin. To visualize the mapping process, we can start
    Rviz with the help of **Navigation** settings:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，建图过程将开始。为了可视化建图过程，我们可以使用 **导航** 设置启动 Rviz：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we can see the map created in Rviz, as shown in the following screenshot:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到在 Rviz 中创建的地图，如下面的截图所示：
- en: '![](img/69957574-a44c-4995-8cdb-d6be0651b919.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/69957574-a44c-4995-8cdb-d6be0651b919.png)'
- en: Creating a map in Rviz using Gmapping.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Gmapping 在 Rviz 中创建地图。
- en: 'Now we can use the teleop node to move the robot, and you can see that a map
    is being created in Rviz. To create a good map of the environment, you have to
    move the robot slowly, and often you have to rotate the robot. When we move the
    robot in the environment and build the map, you can save the current map using
    the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用teleop节点来移动机器人，您会看到在Rviz中正在创建地图。为了创建一个良好的环境地图，您必须缓慢移动机器人，并且通常需要旋转机器人。当我们移动机器人在环境中并构建地图时，您可以使用以下命令保存当前地图：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The map will be saved as `*.pgm` and `*.yaml`, where the `pgm` file is the map
    and the `yaml` file is the configuration of the map. You can see the saved map
    in your desktop.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 地图将被保存为`*.pgm`和`*.yaml`，其中`pgm`文件是地图，`yaml`文件是地图的配置。您可以在您的桌面上看到保存的地图。
- en: 'After moving the robot around the environment, you may get a complete map,
    such as the one shown in the following screenshot:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器人周围移动后，您可能会得到一个完整的地图，如图下所示：
- en: '![](img/38006876-9c8f-4f46-9196-0b3680f204e8.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38006876-9c8f-4f46-9196-0b3680f204e8.png)'
- en: Final map using Gmapping.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gmapping生成的最终地图。
- en: The map can be saved at any time, but make sure that the robot covers the entire
    area of the environment and has mapped all of its space, as shown in the preceding
    screenshot*.* Once we are sure that the map is completely built, enter the `map_saver`
    command again and close the terminals. If you aren't able to map the environment,
    you can check the existing map from `chefbot_gazebo/maps/hotel`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 地图可以随时保存，但请确保机器人覆盖了环境的整个区域并已绘制了其所有空间，如图中所示*.* 一旦我们确信地图已完全构建，再次输入`map_saver`命令并关闭终端。如果您无法绘制环境，可以从`chefbot_gazebo/maps/hotel`检查现有地图。
- en: Getting started with Adaptive Monte Carlo Localization
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用自适应蒙特卡洛定位
- en: We have successfully built the map of the environment. Now we have to navigate
    autonomously from the current robot position to target position. The first step
    before starting autonomous navigation is localizing the robot in the current map.
    The algorithm we are using to localize on the map is called AMCL. The AMCL uses
    a particle filter to track the robot's position with respect to the map. We are
    using an ROS package to implement AMCL in our robot ([http://wiki.ros.org/amcl](http://wiki.ros.org/amcl)).
    Similar to Gmapping, there are a lot of parameters to configure for the `amcl`
    node, which is inside the `amcl` package. You can find all the parameters of amcl
    on the ROS wiki page itself.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功构建了环境的地图。现在我们必须从当前机器人位置自主导航到目标位置。在开始自主导航之前的第一步是在当前地图中定位机器人。我们在地图上定位所使用的算法称为AMCL。AMCL使用粒子滤波器跟踪机器人相对于地图的位置。我们使用ROS包在我们的机器人中实现AMCL（[http://wiki.ros.org/amcl](http://wiki.ros.org/amcl)）。与Gmapping类似，`amcl`节点有很多参数需要配置，该节点位于`amcl`包内。您可以在ROS
    wiki页面上找到所有amcl参数。
- en: So how we can start AMCL for our robot? There is a launch file for doing that,
    which is placed in `chefbot_gazebo/amcl_demo.launch` and `chefbot_gazebo/includes/amcl.launch.xml`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何为我们的机器人启动AMCL呢？有一个启动文件可以做到这一点，它位于`chefbot_gazebo/amcl_demo.launch`和`chefbot_gazebo/includes/amcl.launch.xml`。
- en: 'We can see the definition of `amcl_demo.launch`. The following code shows the
    definition of this launch file:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`amcl_demo.launch`的定义。以下代码显示了此启动文件的定义：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first node in this launch file starts `map_server` from the `map_server`
    package. The `map_server` node loads a static map that we have already saved and
    publishes it into a topic called `map` (`nav_msgs/OccupancyGrid`). We can mention
    the map file as an argument of the `amcl_demo.launch` file, and if there is a
    map file, the `map_server` node will load that; otherwise it will load the default
    map, which is located in the `chefbot_gazeob/maps/hotel.yaml` file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个启动文件中的第一个节点是从`map_server`包中启动`map_server`。`map_server`节点加载我们已保存的静态地图并将其发布到名为`map`（`nav_msgs/OccupancyGrid`）的主题中。我们可以将地图文件作为`amcl_demo.launch`文件的参数提及，如果有地图文件，`map_server`节点将加载该文件；否则，它将加载默认地图，该地图位于`chefbot_gazeob/maps/hotel.yaml`文件中。
- en: 'After loading the map, we start the `amcl` node and move the base node. The
    AMCL node helps to localize the robot on the current `map` and the `move_base`
    node inside the ROS navigation stack, which helps in navigating the robot from
    the start to the target position. We will learn more about the `move_base` node
    in the upcoming chapters. The `move_base` node also needs to be configured with
    parameters. The parameter files are kept inside the `chefbot_gazebo/param` folder,
    as shown in the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载地图后，我们启动`amcl`节点并移动基础节点。`amcl`节点有助于在当前`map`上定位机器人，以及ROS导航堆栈中的`move_base`节点，它有助于将机器人从起点导航到目标位置。我们将在接下来的章节中了解更多关于`move_base`节点的内容。`move_base`节点也需要配置参数。参数文件保存在`chefbot_gazebo/param`文件夹中，如下所示：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can refer more about ROS navigation stack from following link
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下链接了解更多关于ROS导航堆栈的信息。
- en: '[http://wiki.ros.org/navigation/Tutorials/RobotSetup](http://wiki.ros.org/navigation/Tutorials/RobotSetup)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://wiki.ros.org/navigation/Tutorials/RobotSetup](http://wiki.ros.org/navigation/Tutorials/RobotSetup)'
- en: Implementing AMCL in the Gazebo environment
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Gazebo环境中实现AMCL
- en: In this section, we will learn how to implement AMCL in our Chefbot. We will
    use the following procedures to incorporate AMCL within the simulation. Each command
    should be executed in each terminal.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在Chefbot中实现AMCL。我们将使用以下步骤在模拟中集成AMCL。每个命令应在每个终端中执行。
- en: 'The first command starts the Gazebo simulator:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令启动Gazebo模拟器：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we can start the AMCL launch file, with or without the map file as an argument.
    If you want to use a custom map that you have built, then use the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以启动AMCL启动文件，带或不带地图文件作为参数。如果您想使用您自己构建的自定义地图，请使用以下命令：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you want to use the default map, you can use the following command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用默认地图，可以使用以下命令：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After starting AMCL, we can start Rviz to visualize the map and robot. We will
    see a view in Rviz as shown in the following screenshot. You can see a map and
    a robot surrounded by green particles. The green particles are called `amcl` particles.
    They indicate the uncertainty of the robot''s position. If there are more particles
    around the robot, then this means that the uncertainty of the robot''s position
    is higher. When it starts moving, the particle count will reduce and its position
    will be more certain. If the robot isn''t able to localize the position of the
    map, we can use the *2D Pose Estimate* button in Rviz (on the toolbar) to manually
    set the initial position of the robot on the map. You can see the button in the
    following screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动AMCL之后，我们可以启动Rviz来可视化地图和机器人。您将在以下屏幕截图中看到Rviz中的视图。您可以看到一个地图和一个被绿色粒子包围的机器人。这些绿色粒子被称为`amcl`粒子，它们表示机器人位置的不确定性。如果机器人周围有更多的粒子，这意味着机器人位置的不确定性更高。当它开始移动时，粒子计数将减少，其位置将更加确定。如果机器人无法定位地图的位置，我们可以在Rviz（在工具栏上）使用`2D
    Pose Estimate`按钮手动设置机器人在地图上的初始位置。您可以在以下屏幕截图中看到该按钮：
- en: '![](img/6521ef37-a6a5-4f66-9b4e-b3c36db0db91.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6521ef37-a6a5-4f66-9b4e-b3c36db0db91.png)'
- en: Starting AMCL on the hotel map.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在酒店地图上启动AMCL。
- en: 'If you zoom into the robot''s position in Rviz, you can see the particles,
    as shown in the preceding screenshot. We can also see the obstacles around the
    robot in different colors:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Rviz中放大机器人的位置，您可以看到粒子，如前述屏幕截图所示。我们还可以看到机器人周围的不同颜色的障碍物：
- en: '![](img/2a7f6680-0766-4bb0-b0cf-9a17ec0fa8e0.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a7f6680-0766-4bb0-b0cf-9a17ec0fa8e0.png)'
- en: AMCL cloud around the robot.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人周围的AMCL云。
- en: In the next section, we will learn how to program the Chefbot to autonomously
    navigate this map. You don't need to close the current terminals; we can navigate
    the robot autonomously in the Rviz itself.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何编程Chefbot以自主导航此地图。您不需要关闭当前终端；我们可以在Rviz本身中自主导航机器人。
- en: Autonomous navigation of Chefbot in the hotel using Gazebo
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gazebo在酒店中自主导航Chefbot
- en: 'To start the robot''s autonomous navigation, we just need to command the target
    robot position on the map. There is a button in Rviz called 2D Nav Goal. We can
    click that button and click on a point on the map. You can now see an arrow indicating
    the position of the robot. When you give the target position in the map, you can
    see that the robot is planning a path from its current position to the target
    position. It will slowly move from its current position to the target position,
    avoiding all obstacles. The following screenshot shows the path planning and navigation
    of the robot to the target position. The color grid around the robot shows the
    local cost map of the robot, as well as the local planner path and the obstacles
    around the robot:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动机器人的自主导航，我们只需在地图上指定目标机器人的位置。在Rviz中有一个名为2D Nav Goal的按钮。我们可以点击该按钮并在地图上点击一个点。你现在可以看到一个箭头指示机器人的位置。当你给出地图上的目标位置时，你可以看到机器人正在从当前位置到目标位置规划路径。它将缓慢地从当前位置移动到目标位置，避开所有障碍。以下截图显示了机器人到目标位置的路径规划和导航。机器人周围的彩色网格显示了机器人的局部成本图，以及局部规划路径和机器人周围的障碍物：
- en: '![](img/cadf1a03-9f08-4649-91d6-23ec2e051d5c.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cadf1a03-9f08-4649-91d6-23ec2e051d5c.png)'
- en: Autonomous navigation of the robot.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人的自主导航。
- en: In this way, if we command a position inside the map that is nearer to a table,
    the robot can go to that table and serve the food and then return back to its
    home position. Instead of commanding it from Rviz, we can write an ROS node to
    do the same. This will be explained in the last few chapters of this book.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，如果我们命令地图内部靠近桌子位置，机器人可以前往那个桌子，提供食物，然后返回到其起始位置。我们不必从Rviz中命令它，我们可以编写一个ROS节点来完成同样的任务。这将在本书的最后几章中解释。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to simulate our own robot, called Chefbot. We
    looked at the design of the Chefbot in the previous chapter. We started the chapter
    by learning about the Gazebo simulator and its different features and capabilities.
    After that, we looked at how the ROS framework and Gazebo simulator are used to
    perform a robot simulation. We installed the TurtleBot 2 package and tested the
    Turtlebot 2 simulation in Gazebo. After that, we created the Chefbot simulation
    and used Gmapping, AMCL, and autonomous navigation in a hotel environment. We
    learned that the accuracy of the simulation depends on the map, and that the robot
    will work better in a simulation if the generated map is perfect.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何模拟自己的机器人，称为Chefbot。我们在上一章中探讨了Chefbot的设计。我们以学习Gazebo模拟器和它的不同特性和功能开始本章。之后，我们探讨了如何使用ROS框架和Gazebo模拟器进行机器人模拟。我们安装了TurtleBot
    2包并在Gazebo中测试了Turtlebot 2模拟。之后，我们创建了Chefbot模拟，并在酒店环境中使用了Gmapping、AMCL和自主导航。我们了解到，模拟的准确性取决于地图，如果生成的地图完美，机器人在模拟中会工作得更好。
- en: In the next chapter, we will learn how to design the robot's hardware and electronic
    circuit.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何设计机器人的硬件和电子电路。
- en: Questions
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How we can model a sensor in Gazebo?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在Gazebo中建模传感器？
- en: How is ROS interfaced with Gazebo?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ROS如何与Gazebo接口？
- en: What are the important URDF tags for simulation?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟中重要的URDF标签有哪些？
- en: What is Gmapping, and how we can implement it in ROS?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gmapping是什么，我们如何在ROS中实现它？
- en: What is the function of the `move_base` node in ROS?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ROS中的`move_base`节点有什么功能？
- en: What is AMCL, and how we can implement it in ROS?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AMCL是什么，我们如何在ROS中实现它？
- en: Further reading
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn more about URDF, Xacro, and Gazebo, you can refer to the book *Mastering
    ROS for Robotics Programming - Second Edition* ([https://www.packtpub.com/hardware-and-creative/mastering-ros-robotics-programming-second-edition](https://www.packtpub.com/hardware-and-creative/mastering-ros-robotics-programming-second-edition)).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于URDF、Xacro和Gazebo的信息，您可以参考书籍《Mastering ROS for Robotics Programming -
    Second Edition》([https://www.packtpub.com/hardware-and-creative/mastering-ros-robotics-programming-second-edition](https://www.packtpub.com/hardware-and-creative/mastering-ros-robotics-programming-second-edition))。
