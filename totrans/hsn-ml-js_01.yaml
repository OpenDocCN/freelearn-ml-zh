- en: Exploring the Potential of JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why JavaScript?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why machine learning, why now?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages and challenges of JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CommonJS initiative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improvements in ES6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why JavaScript?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I started writing about **machine learning** (**ML**) in JavaScript in 2010\.
    At the time, Node.js was brand new and JavaScript was just beginning to come into
    its own as a language. For much of the history of the internet, JavaScript had
    been seen as a toy language, used to create simple dynamic interactions on web
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The perception of JavaScript began to change in 2005 with the release of the
    **Prototype JavaScript Framework**, which aimed to simplify AJAX requests and
    help developers deal with cross-browser `XMLHttpRequest`. The Prototype Framework
    also introduced the familiar dollar function as an alias for `` `document.getElementById`:
    `$(“myId”)` ``, for instance.'
  prefs: []
  type: TYPE_NORMAL
- en: One year later, John Resig released the wildly popular jQuery library. At the
    time of writing, [w3techs.com](https://w3techs.com/) reports that jQuery is used
    on 96% of websites whose JavaScript libraries are known to them (which accounts
    for 73% of all websites). jQuery worked to make common JavaScript operations cross-browser
    compatible and easy to achieve, bringing important tools such as AJAX requests,
    **Document Object Model** (**DOM**) traversal and manipulation, and animations
    to web developers everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in 2008, the Chrome web browser and the Chrome V8 JavaScript engine were
    released. Chrome and V8 introduced a marked performance improvement over older
    browsers: JavaScript was now fast, owing in large part to the V8 engine''s innovative
    just-in-time compiler that builds machine code directly from JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript became more popular as jQuery and Chrome took over the web. Developers
    historically have never loved JavaScript as a programming language, but with jQuery
    in the picture, running on a fast and modern browser, it became clear that JavaScript
    was an underutilized tool and capable of much more than it had been used for previously.
  prefs: []
  type: TYPE_NORMAL
- en: In 2009, the JavaScript developer community decided to break JavaScript free
    from the web browser environment. The CommonJS initiative was launched early that
    year, and Node.js followed after a few months. CommonJS modules' goal was to develop
    a standard library and improve the ecosystem for JavaScript so that it could be
    used outside of the browser environment. As part of this effort, CommonJS standardized
    a module-loading interface that allowed developers to build libraries that they
    could share with others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The release of Node.js in mid-2009 rocked the JavaScript world by giving JavaScript
    developers a new paradigm to consider: JavaScript as a server-side language. Packing
    the Chrome V8 engine under the hood made Node.js surprisingly fast, though the
    V8 engine doesn''t deserve all of the credit for the software''s performance.
    The Node.js instance uses an event loop to process requests, so it can handle
    a large number of concurrent connections despite being single-threaded.'
  prefs: []
  type: TYPE_NORMAL
- en: The novelty of JavaScript on the server, its surprising performance, and the
    early introduction of the npm registry which let developers publish and discover
    modules, attracted thousands of developers. The standard library published with
    Node.js was primarily low-level I/O APIs, and developers raced to see who could
    publish the first good HTTP request wrapper, the first easy-to-use HTTP server,
    the first high-level image processing library, and so on. The rapid early growth
    of the JavaScript ecosystem generated confidence in developers who were reluctant
    to adopt the new technology. JavaScript, for the first time, was being seen as
    a real programming language, rather than just something we tolerated because of
    web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: While JavaScript as a programming platform was maturing, the Python community
    was busy working on ML, in part inspired by Google's success in the market. The
    foundational and very popular number processing library, NumPy, was released in
    2006, though it had existed in one form or another for a decade prior. A ML library
    called **scikit-learn** was released in 2010, and that was the moment I decided
    to start teaching ML to JavaScript developers.
  prefs: []
  type: TYPE_NORMAL
- en: The popularity of ML in Python and the ease of building and training models
    with tools, such as scikit-learn, astounded me and many others. In my eyes, the
    surge in popularity caused an ML bubble; because models were so easy to build
    and run, I found that many developers didn't actually understand the mechanics
    of the algorithms and techniques they were using. Many developers lamented their
    underperforming models, not understanding that they themselves were the weak link
    in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning at the time had been seen as mystical, magical, academic, accessible
    only to a select few geniuses, and only accessible to Python developers. I felt
    differently. Machine learning is just a category of algorithms with no magic involved.
    Most of the algorithms are actually easy to understand and reason about!
  prefs: []
  type: TYPE_NORMAL
- en: Rather than showing developers how to import Bayes in Python, I wanted to show
    developers how to build the algorithms from scratch, an important step in building
    intuition. I also wanted my students to largely ignore the popular Python libraries
    that existed at the time, because I wanted to reinforce the notion that ML algorithms
    can be written in any language and Python is not required.
  prefs: []
  type: TYPE_NORMAL
- en: I chose JavaScript as my teaching platform. To be perfectly honest, I chose
    JavaScript in part because it was considered a *bad* language by many at that
    time. My message was *machine learning is easy, you can even do it in JavaScript!* Fortunately
    for me, Node.js and JavaScript were both becoming incredibly popular, and my early
    articles on ML in JavaScript were read by over a million curious developers in
    the following years.
  prefs: []
  type: TYPE_NORMAL
- en: I also chose JavaScript in part because I didn't want ML to be seen as a tool
    only accessible to academics, or computer scientists, or even college graduates.
    I believed, and still believe, that these algorithms can be thoroughly understood
    by any competent developer, given enough practice and repetition. I chose JavaScript
    because it allowed me to reach a new audience of frontend and full-stack web developers,
    many of whom were self-taught or had never studied computer science formally.
    If the goal was to demystify and democratize the field of ML, I felt it was much
    better to reach the web developer community rather than the backend Python programmer
    community, which as a whole was already more comfortable with ML at the time.
  prefs: []
  type: TYPE_NORMAL
- en: Python has always been and remains the language of choice for ML, in part due
    to the maturity of the language, in part due to the maturity of the ecosystem,
    and in part due to the positive feedback loop of early ML efforts in Python. Recent
    developments in the JavaScript world, however, are making JavaScript more attractive
    to ML projects. I think we will see a major ML renaissance in JavaScript within
    a few years, especially as laptops and mobile devices become ever more powerful
    and JavaScript itself surges in popularity.
  prefs: []
  type: TYPE_NORMAL
- en: Why machine learning, why now?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several ML techniques have been around since before computers themselves, but
    many of the modern ML algorithms we use today were discovered all the way back
    in the 1970s and 1980s. They were interesting but not practical then, and were
    confined largely to academia.
  prefs: []
  type: TYPE_NORMAL
- en: 'What changed to give ML its massive rise in popularity? First, computers finally
    got fast enough to run non-trivial neural networks and large ML models. And then
    two things happened: Google and **Amazon Web Services** (**AWS**). Google proved
    the value of ML to the market in a very visible manner, and then AWS made scalable
    computing and storage resources readily available (AWS democratized it and created
    new competition).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Google PageRank, the ML algorithm powering Google Search, taught us all about
    business applications of ML. Sergei and Larry, the founders of Google, told the
    world that the massive success of their search engine and resultant advertising
    business was the PageRank algorithm: a relatively straightforward linear algebra
    equation, with a massive matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that neural networks are also relatively straightforward linear algebra
    equations with a massive matrix.
  prefs: []
  type: TYPE_NORMAL
- en: That was ML in all its glory; big data giving big insight which translates into
    a major market success. This got the world economically interested in ML.
  prefs: []
  type: TYPE_NORMAL
- en: AWS, with the launch of EC2 and hourly billing, democratized compute resources.
    Researchers and early-stage start ups were now able to launch large computing
    clusters quickly, train their models, and scale the cluster back down, avoiding
    the need for large capital expenditures on beefy servers. This created new competition
    and an inaugural generation of ML-focused start ups, products, and initiatives.
  prefs: []
  type: TYPE_NORMAL
- en: ML has recently had another surge in popularity, both in the developer and business
    communities. The first generation of ML-focused start ups and products have now
    come to maturity and are proving the value of ML in the market, and in many cases
    these companies are closing in on or have overtaken their competitors. The desire
    of companies to remain competitive in their market drove up the demand for ML
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The late 2015 introduction of Google's neural network library, **TensorFlow**,
    energized developers by democratizing neural networks much in the same way that
    EC2 democratized computing power. Additionally, those first-generation start ups
    that focused on developers have also come to maturity, and now we can make a simple
    API request to AWS or **Google Cloud Platform** (**GCP**) that runs an entire
    pretrained **Convolutional Neural Network** (**CNN**) on an image, and tells me
    if I'm looking at a cat, a woman, a handbag, a car, or all four at once.
  prefs: []
  type: TYPE_NORMAL
- en: As ML is democratized it will slowly lose its competitive value, that is, companies
    will no longer be able to use ML to jump leaps and bounds ahead of the competition,
    because their competition will also be using ML. Everyone in the field is now
    using the same algorithms, and competition becomes a data war. If we want to keep
    competing on technology, if we want to find the next 10x improvement, then we'll
    either need to wait for, or preferably cause, the next big technological breakthrough.
  prefs: []
  type: TYPE_NORMAL
- en: If ML had not been such a success in the market, that would have been the end
    of the story. All the important algorithms would be known to all, and the fight
    would move to who can gather the best data, put walls around their garden, or
    exploit their ecosystem the best.
  prefs: []
  type: TYPE_NORMAL
- en: But introducing a tool such as TensorFlow into the market changed all of that.
    Now, neural networks have been democratized. It's surprisingly easy to build a
    model, train and run it on a GPU, and generate real results. The academic fog
    surrounding neural networks has been lifted, and now tens of thousands of developers
    are playing around with techniques, experimenting, and refining. This will launch
    a second major wave of ML popularity, particularly focused on neural networks.
    The next generation of ML and neural network-focused start ups and products is
    being born right now, and when they come to maturity in a few years, we should
    see a number of significant breakthroughs, as well as breakaway companies.
  prefs: []
  type: TYPE_NORMAL
- en: Each new market success we see will create demand for ML developers. The increase
    of the talent pool and democratization of technology causes technology breakthroughs.
    Each new technology breakthrough hits the market and creates new market successes,
    and the cycle will continue while the field itself advances at an accelerating
    pace. I think, for purely economic reasons, that we really are headed for an **artificial
    intelligence** (**AI**) boom.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and challenges of JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite my optimism towards the future of ML in JavaScript, most developers
    today would still choose Python for their new projects, and nearly all large-scale
    production systems are developed in Python or other languages more typical to
    ML.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript, like any other tool, has its advantages and disadvantages. Much
    of the historic criticism of JavaScript has focused on a few common themes: strange
    behavior in type coercion, the prototypical object-oriented model, difficulty
    organizing large codebases, and managing deeply nested asynchronous function calls
    with what many developers call *callback hell*. Fortunately, most of these historic
    gripes have been resolved by the introduction of **ES6**, that is, **ECMAScript
    2015**, a recent update to the JavaScript syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the recent language improvements, most developers would still advise
    against using JavaScript for ML for one reason: the ecosystem. The Python ecosystem
    for ML is so mature and rich that it''s difficult to justify choosing any other
    ecosystem. But this logic is self-fulfilling and self-defeating; we need brave
    individuals to take the leap and work on real ML problems if we want JavaScript''s
    ecosystem to mature. Fortunately, JavaScript has been the most popular programming
    language on GitHub for a few years running, and is growing in popularity by almost
    every metric.'
  prefs: []
  type: TYPE_NORMAL
- en: There are some advantages to using JavaScript for ML. Its popularity is one;
    while ML in JavaScript is not very popular at the moment, the language itself
    is. As demand for ML applications rises, and as hardware becomes faster and cheaper,
    it's only natural for ML to become more prevalent in the JavaScript world. There
    are tons of resources available for learning JavaScript in general, maintaining
    Node.js servers, and deploying JavaScript applications. The **Node Package Manager**
    (**npm**) ecosystem is also large and still growing, and while there aren't many
    very mature ML packages available, there are a number of well built, useful tools
    out there that will come to maturity soon.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage to using JavaScript is the universality of the language. The
    modern web browser is essentially a portable application platform which allows
    you to run your code, basically without modification, on nearly any device. Tools
    like **electron** (while considered by many to be bloated) allow developers to
    quickly develop and deploy downloadable desktop applications to any operating
    system. Node.js lets you run your code in a server environment. React Native brings
    your JavaScript code to the native mobile application environment, and may eventually
    allow you to develop desktop applications as well. JavaScript is no longer confined
    to just dynamic web interactions, it's now a general-purpose, cross-platform programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, using JavaScript makes ML accessible to web and frontend developers,
    a group that historically has been left out of the ML discussion. Server-side
    applications are typically preferred for ML tools, since the servers are where
    the computing power is. That fact has historically made it difficult for web developers
    to get into the ML game, but as hardware improves, even complex ML models can
    be run on the client, whether it's the desktop or the mobile browser.
  prefs: []
  type: TYPE_NORMAL
- en: If web developers, frontend developers, and JavaScript developers all start
    learning about ML today, that same community will be in a position to improve
    the ML tools available to us all tomorrow. If we take these technologies and democratize
    them, expose as many people as possible to the concepts behind ML, we will ultimately
    elevate the community and seed the next generation of ML researchers.
  prefs: []
  type: TYPE_NORMAL
- en: The CommonJS initiative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2009, a Mozilla engineer named Kevin Dangoor realized that server-side JavaScript
    needed a lot of help in order to be useful. The concept of server-side JavaScript
    had already existed, but wasn't very popular due to a number of limitations, particularly
    in terms of the JavaScript ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: In a blog post written in January of 2009, Dangoor cited a few examples of where
    JavaScript needed some help. He wrote that the JavaScript ecosystem would need
    a standard library and standard interfaces for things such as file and database
    access. Additionally, the JavaScript environment needed a way to package, publish,
    and install libraries and dependencies for others to use, and also needed a package
    repository to host all of the aforementioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of all of this came the **CommonJS** initiative, whose most notable contribution
    to the JavaScript ecosystem is the CommonJS module format. If you''ve done any
    work with Node.js, you''re probably already familiar with CommonJS: your `package.json` file
    is written in the CommonJS modules package specification format, and writing code
    like `var app = require(‘./app.js’)` in one file with `module.exports = App` in
    `app.js` is using the CommonJS module specification.'
  prefs: []
  type: TYPE_NORMAL
- en: The standardization of modules and packages paved the way for a significant
    boost in JavaScript popularity. Developers were now able to use modules to write
    complex applications spanning many files, without polluting the global namespace.
    Package and library developers were able to build and publish new libraries of
    higher levels of abstraction than JavaScript's standard library. Node.js and npm
    would shortly grab onto these concepts and build a major ecosystem around package
    sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The release of Node.js in 2009 is possibly the single most important moment
    in JavaScript's history, though it would not have been possible without the release
    of the Chrome browser and Chrome's V8 JavaScript engine in the previous year.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those readers who remember the launch of Chrome also recognize why Chrome dominated
    the browser wars: Chrome was fast, it was minimalist, it was modern, it was easy
    to develop for, and JavaScript itself ran much faster on Chrome than on other
    browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind Chrome is the open source Chromium project, which in turn developed
    the **V8** JavaScript engine. The innovation that V8 brought to the JavaScript
    world was its new execution model: instead of interpreting JavaScript in real
    time, V8 contains a JIT compiler that turns JavaScript directly into native machine
    code. This gambit paid off, and the combined effect of its stellar performance
    and its open source status led others to co-opt V8 for their own purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js took the V8 JavaScript engine, added an event-driven architecture around
    it, and added a low-level I/O API for disk and file access. The event-driven architecture
    turned out to be a critical decision. Other server-side languages and technologies,
    such as PHP, typically used a thread pool to manage concurrent requests, with
    each thread itself blocking while processing the request. Node.js is a single-threaded
    process, but using an event loop avoids blocking operations and instead favors
    asynchronous, callback-driven logic. While the single-threaded nature of Node.js
    is considered by many to be a drawback, Node.js was still able to handle many
    concurrent requests with good performance, and that was enough to bring developers
    to the platform.
  prefs: []
  type: TYPE_NORMAL
- en: A few months later, the npm project was released. Building on top of the foundational
    work that CommonJS achieved, npm allowed package developers to publish their modules
    to a centralized registry (called the **npm registry**), and allowed package consumers
    to install and maintain dependencies with the npm command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js likely would not have broken into the mainstream if not for npm. The
    Node.js server itself provided the JavaScript engine, the event loop, and a few
    low-level APIs, but as developers work on bigger projects they tend to want higher-level
    abstractions. When making HTTP requests or reading files from disk, developers
    don't always want to have to worry about binary data, writing headers, and other
    low-level issues. The npm and the npm registry let the developer community write
    and share their own high-level abstractions in the form of modules other developers
    could simply install and `require()`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other programming languages which typically have high-level abstractions
    built in, Node.js was allowed to focus on providing the low-level building blocks
    and the community took care of the rest. The community stepped up by building
    excellent abstractions such as the `Express.js` web application framework, the
    `Sequelize ORM`, and hundreds of thousands of other libraries ready to be used
    after just a simple `npm install` command.
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of Node.js, JavaScript developers with no prior server-side
    language knowledge were now able to build entire full-stack applications. The
    frontend code and backend code could now be written in the same language, by the
    same developers.
  prefs: []
  type: TYPE_NORMAL
- en: Ambitious developers were now building entire applications in JavaScript, though
    they ran into a few issues and solutions along the way. Single-page applications
    fully written in JavaScript became popular, but also became difficult to template
    and organize. The community responded by building frameworks such as **Backbone.js**
    (the spiritual predecessor to frameworks such as Angular and React), **RequireJS**
    (a CommonJS and AMD module loader), and templating languages such as **Mustache**
    (a spiritual predecessor to JSX).
  prefs: []
  type: TYPE_NORMAL
- en: When developers ran into issues with SEO on their single-page applications,
    they invented the concept of **isomorphic applications**, or codes that could
    be rendered both server side (so that web spiders could index the content) and
    client side (to keep the application fast and JavaScript-powered). This led to
    the invention of more JavaScript frameworks such as **MeteorJS**.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, JavaScript developers building single-page applications realized
    that often, their server-side and database requirements were lightweight, requiring
    just authentication, and data storage, and retrieval. This led to the development
    of *serverless* technologies or **database-as-a-service** (**DBaaS**) platforms
    such as **Firebase**, which in turn laid out a path for mobile JavaScript applications
    to become popular. The Cordova/PhoneGap project appeared around the same time,
    allowing developers to wrap their JavaScript code in a native iOS or Android WebView
    component and deploy their JavaScript applications to the mobile app stores.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes throughout this book, we'll be relying on Node.js and npm very
    heavily. Most of the examples in this book will use ML packages available on npm.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development and sharing of new packages on npm was not the only result of
    JavaScript's popularity. JavaScript's increasing usage as a primary programming
    language caused many developers to lament the lack of IDE and language tooling
    support. Historically, IDEs were more popular with developers of compiled and
    statically-typed languages such as C and Java, as it’s easier to parse and statically
    analyze those types of languages. It wasn't until recently that great IDEs started
    appearing for languages such as JavaScript and PHP, while Java has had IDEs geared
    towards it for many years.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft wanted better tooling and support for their large-scale JavaScript
    projects, but there were a few issues with the JavaScript language itself that
    got in the way. In particular, JavaScript's dynamic typing (the fact that `var
    number` could start its life as the integer **5**, but then be assigned to an
    object later) precludes using static analysis tools to ensure type safety, and
    also makes it difficult for an IDE to find the correct variable or object to autocomplete
    with. Additionally, Microsoft wanted a class-based object-oriented paradigm with
    interfaces and contracts, but JavaScript's object-oriented programming paradigm
    was based on **prototypes**, not classes.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft therefore invented the TypeScript language in order to support large-scale
    JavaScript development efforts. TypeScript introduced classes, interfaces, and
    static typing to the language. Unlike Google's Dart, Microsoft made sure TypeScript
    would always be a strict superset of JavaScript, meaning that all valid JavaScript
    is also valid TypeScript. The TypeScript compiler does static type checking at
    compile time, helping developers catch errors early. Support for static typing
    also helps IDEs interpret code more accurately, making for a nicer developer experience.
  prefs: []
  type: TYPE_NORMAL
- en: Several of TypeScript's early improvements to the JavaScript language have been
    made irrelevant by ECMAScript 2015, or what we call ES6\. For instance, TypeScript's
    module loader, class syntax, and arrow function syntax have been subsumed by ES6,
    and TypeScript now simply uses the ES6 versions of those constructs; however,
    TypeScript still brings static typing to JavaScript, which ES6 wasn't able to
    accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: I bring up TypeScript here because, while we won't be using TypeScript in the
    examples in this book, some of the examples of ML libraries we examine here are
    written in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, one example found on the `deeplearn.js` tutorials page shows
    code that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax looks like ES6 JavaScript except for the new colon notation seen
    in `const x: Tensor = … :` this code is telling the TypeScript compiler that the
    `const x` must be an instance of the `Tensor` class. When TypeScript compiles
    this code, it first checks that everywhere `x` is used expects a `Tensor` (it
    will throw an error if not), and then it simply discards the type information
    when compiling to JavaScript. Converting the preceding TypeScript code to JavaScript
    is as simple as removing the colon and the `Tensor` keyword from the variable
    definition.'
  prefs: []
  type: TYPE_NORMAL
- en: You are welcome to use TypeScript in your own examples as you follow along with
    this book, however, you will have to update the build process that we set up later
    to support TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Improvements in ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ECMAScript committee, which defines the specification for the JavaScript
    language itself, released a new specification called ECMAScript 6/ECMAScript 2015
    in June 2015\. The new standard, called **ES6** for short, was a major revision
    of the JavaScript programming language and added a number of new paradigms intended
    to make development of JavaScript programs easier.
  prefs: []
  type: TYPE_NORMAL
- en: While ECMAScript defines the specification for the JavaScript language, the
    actual implementation of the language is dependent on the browser vendors and
    the maintainers of the various JavaScript engines. ES6 by itself is only a guideline,
    and because the browser vendors each have their own timeline for implementing
    new language features, the JavaScript language and the JavaScript implementations
    diverged slightly. Features defined by ES6, such as classes, were not available
    in the major browsers, but developers wanted to use them anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Enter **Babel**, the JavaScript transpiler. Babel can read and parse different
    JavaScript flavors (such as ES6, ES7, ES8, and React JSX) and convert it or compile
    it into browser-standard ES5\. Even today, the entirety of ES6 has not yet been
    implemented by the browser vendors, so Babel remains an essential tool for developers
    wishing to write ES6 code.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this book will use ES6\. If you're not yet familiar with the
    newer syntax, here are a few of the major features you'll see used throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Let and const
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In ES5 JavaScript, we use the `var` keyword to define variables. In most cases,
    `var` can simply be replaced with `let`, with the major difference between the
    two constructs being the scoping of the variable with respect to blocks. The following
    example from **MDN web docs**, or previously **Mozilla Developer Network** ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let)),
    demonstrates the subtle difference between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, while you must use additional caution in cases like the preceding one, in
    most cases you can simply replace `var` with `let`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `const` keyword, unlike `let`, defines a variable as a constant; that is,
    you cannot reassign a variable initialized with `const` at a later date. For example,
    the following code causes an error with a message similar to `invalid assignment
    to const a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand the same code, using `var` or `let` to define `a`, would run
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if `a` is an object, you are allowed to modify object properties of
    `a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will run successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, attempting to redefine objects such as in `obj = {name: “other object”}`
    would cause an error.'
  prefs: []
  type: TYPE_NORMAL
- en: I find that in most programming contexts, `const` is typically more appropriate
    than `let`, as most variables you use never need to be redefined. My recommendation
    is to use `const` as much as you can, and use `let` only when you have a reason
    to redefine the variable later.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One very welcome change in ES6 is the addition of classes and class inheritance.
    Previously, object-oriented programming in JavaScript required prototypical inheritance,
    which many developers found unintuitive, like the following ES5 example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, extending an object requires calling the parent class
    in the child's `constructor` function, creating a clone of the parent's prototype
    object, and overriding the parent's prototype constructor with the child's prototype
    constructor. These steps were seen as unintuitive and burdensome by most developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using ES6 classes, however, the code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding syntax is more in line with what we'd expect from object-oriented
    programming, and also makes inheritance much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that under the hood, ES6 classes still use JavaScript's
    prototypical inheritance paradigm. Classes are just syntactic sugar on top of
    the existing system, so there is no significant difference between these two approaches
    other than clean code.
  prefs: []
  type: TYPE_NORMAL
- en: Module imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ES6 also defines a module import and export interface. With the older CommonJS
    approach, modules are exported using the `modules.export` construct, and modules
    are imported with the `require(filename)` function. The ES6 approach looks a little
    different. In one file, define and export a class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And in another file, import the class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At present, Babel compiles ES6 modules to the same format as CommonJS modules,
    so you can use either the ES6 modules syntax or the CommonJS modules syntax if
    you’re using Babel.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One quirky, useful, but somewhat annoying aspect of ES5 JavaScript is its heavy
    use of callbacks that run asynchronously. You are probably intimately familiar
    with jQuery code that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We're forced to create a variable called `$self` because the original `this`
    context is lost in our inner anonymous function. We also have a lot of boilerplate
    and difficult-to-read code due to needing to create three separate anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow function syntax is both syntactic sugar that helps us write anonymous
    functions with a shorter syntax, and also a functional update that preserves the
    context of `this` inside an arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the preceding code may be written in ES6 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the preceding code that we no longer need a `$self` variable
    to preserve `this`, and our call to `.map` is much simpler, no longer requiring
    the `function` keyword, parentheses, curly braces, or a `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at some equivalent functions. Let''s look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would be similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned examples, we can omit the parentheses around the `number`
    parameter because the function only requires one parameter. If the function required
    two parameters, we would be required to add parentheses as in the next example.
    Additionally, if the body of our function only requires one line, we can omit
    the function body curly braces and omit the `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another equivalence, with multiple parameters, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would be similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: I find that arrow functions make themselves most useful in situations like the
    preceding one, when you're doing data transformations, especially where using
    `Array.map`, `Array.filter`, `Array.reduce`, and `Array.sort` calls with straightforward
    function bodies. Arrow functions are less useful in jQuery because of jQuery's
    tendency to give you data using the `this` context, which you don't receive with
    anonymous arrow functions.
  prefs: []
  type: TYPE_NORMAL
- en: Object literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ES6 makes some improvements to object literals. There are several improvements,
    but the one you''ll see most is the implicit naming of object properties. In ES5
    it would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In ES6, if the property name and the variable name are the same as the preceding
    one, you can simplify it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, ES6 introduces the object spread operator, which simplifies shallow
    object merges. For instance, take a look at the following code in ES5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will create a new object from `defaultPreferences`, and merge
    in properties from `userPreferences`. Passing an empty object to the `Object.assign` instance
    first parameter ensures that we create a new object rather than overwriting `defaultPreferences`
    (which isn't an issue in the preceding example, but is an issue in real-life use
    cases).
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, let''s take a look at the same in ES6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This approach does the same as the ES5 example, but is quicker and easier to
    read in my opinion than the `Object.assign` method. Developers familiar with React
    and Redux, for instance, often use the object spread operator when managing reducer
    state operations.
  prefs: []
  type: TYPE_NORMAL
- en: The for...of function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` loops over arrays in ES5 are often achieved using the `for (index
    in array)` syntax, which looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And ES6 adds the `for...of` syntax, which saves you a step, as you can see
    from the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Promises, in one form or another, have been available in JavaScript for a while.
    All jQuery users are familiar with the idea. A **promise** is a reference to a
    variable that is generated asynchronously and may become available in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ES5 way of doing things, if you weren''t already using some sort of third-party
    promise library or jQuery''s deferred''s, was to accept a callback function to
    an asynchronous method and run the callback upon successful completion, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In ES6, you may return a `Promise` which encapsulates the asynchronous request
    and either gets resolved or rejected, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The real power of promises is that they can be passed around as objects, and
    promise handlers can be chained.
  prefs: []
  type: TYPE_NORMAL
- en: The async/await functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `async` and `await` keywords are not an ES6 feature but rather an ES8 feature.
    While promises bring huge improvements to the way we deal with asynchronous calls,
    promises also are susceptible to lots of method chaining, and in some cases force
    us to use asynchronous paradigms when we really just want to write a function
    that acts asynchronously but reads as if it were a synchronous function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the following example from MDN''s asynchronous function
    reference page ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `resolveAfter2Seconds` function is a normal JavaScript function that returns
    an ES6 promise. The magic is in the `asyncCall` function, which is marked by the
    `async` keyword. Inside `asyncCall`, we invoke `resolveAfter2Seconds` with the
    `await` keyword, rather than using the more familiar promise `.then(result =>
    console.log(result))` construct we'd normally use in ES6\. The `await` keyword
    makes our `async` function wait for the promise to resolve before continuing,
    and returns the result of the `Promise` directly. In this manner, `async`/`await`
    can convert asynchronous functions that use promises to read like synchronous
    functions, which should help keep deeply nested promise calls and asynchronous
    function stats neat and easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: The `async` and `await` features are part of ES8, not ES6, so when we set up
    Babel in a few minutes we'll need to be sure to include all new versions of EMCAScript
    in our configuration, not just ES6.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The examples in this book will use both the web browser environment and the
    Node.js environment. While Node.js Version 8 and higher has support for ES6+,
    not all browser vendors have complete support yet for ES6+ features, and we will
    therefore be using Babel to transpile all of our code regardless.
  prefs: []
  type: TYPE_NORMAL
- en: This book will try its best to use the same project structure for all examples,
    whether they're executed on the command line in Node.js or run in the browser.
    Because we're attempting to standardize this project structure, not every project
    will use all of the features we set up in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tools you will need are:'
  prefs: []
  type: TYPE_NORMAL
- en: Your favorite code editor, such as Vim, Emacs, Sublime Text, or WebStorm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An up-to-date web browser such as Chrome or Firefox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js Version 8 LTS or higher; this book will use version 9.4.0 for all examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Yarn package manager (optional; you may use npm instead)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various build tools such as Babel and Browserify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're a macOS user, the easiest way to install Node.js is through a package
    manager such as **Homebrew** or **MacPorts**. For best compatibility with the
    examples in this book, install Node.js version 9.4.0 or greater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows users can also use the **Chocolatey** package manager to install Node.js,
    otherwise you may follow the instructions on the Node.js current download page:
    [https://nodejs.org/en/](https://nodejs.org/en/).'
  prefs: []
  type: TYPE_NORMAL
- en: Linux users should be careful if installing Node.js through their distribution's
    package manager, as the shipped version of Node.js may be a much older version.
    If your package manager uses a version older than V8, you may either add a repository
    to your package manager, build from source, or install from binary, as appropriate
    for your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve installed Node.js, ensure that it runs and is the correct version
    by running `node --version` from the command line. The output will look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is also a good time to test that `npm` also works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Optionally installing Yarn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yarn is a package management tool similar to and compatible with npm, though
    I find it is faster and easier to work with. If using Homebrew on macOS, you may
    simply install it using `brew install yarn`; otherwise follow the instructions
    found on Yarn's installation guide page ([https://yarnpkg.com/en/docs/install#windows-stable](https://yarnpkg.com/en/docs/install#windows-stable)).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use npm instead of Yarn, you may; both respect the same format
    for `package.json`, though they have slightly different syntaxes for commands
    such as `add`, `require`, and `install`. If you're using npm instead of Yarn,
    simply replace the commands with the correct function; the package names used
    will all be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and initializing an example project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use the command line, your favorite IDE, or your file browser to create a directory
    somewhere on your machine called `MLinJSBook`, with a subdirectory called `Ch1-Ex1`.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate your command line to the `Ch1-Ex1` folder, and run the command `yarn
    init`, which like `npm init` will create a `package.json` file and prompt you
    for basic information. Respond to the prompts, answering appropriately. You will
    not be publishing this package so the answers aren't too important, however, when
    prompted for the application's entry point, type in `dist/index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to install a few build tools that we''ll use for the majority
    of our example projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`babel-core`: The Babel transpiler core'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`babel-preset-env`: The Babel parser preset that parses ES6, ES7, and ES8 code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`browserify`: A JavaScript bundler which can compile multiple files into a
    single file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`babelify`: The Babel plugin for Browserify'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install these as development environment requirements by issuing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Hello World project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test that everything is building and running, we'll create a very simple
    two-file Hello World project and add our build script.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create two subdirectories under your `Ch1-Ex1` folder: `src` and `dist`.
    We''ll use this convention for all projects: `src` will contain JavaScript source
    code, `dist` will contain built source code and any additional assets (images,
    CSS, HTML files, and so on) required by the project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src` folder, create a file called `greeting.js` with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create another file called `index.js` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This small application tests whether we can use basic ES6 syntax and module
    loading, as well as access command-line arguments given to Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open up the `package.json` file in `Ch1-Ex1`, and add the following section
    to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines three simple command-line scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Build-web` uses Browserify and Babel to compile everything that `src/index.js`
    touches into a single file called `dist/index.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Build-cli` is similar to `build-web`, except it also uses Browserify''s node
    option flag; without this option we would not be able to access command-line arguments
    given to Node.js'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Start` is intended only for CLI/Node.js examples, and both builds and runs
    the source code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Your `package.json` file should now look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put this simple application through a few tests. First, make sure that
    `yarn build-cli` works. You should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, confirm that the `dist/index.js` file has been built, and try
    running it directly, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Also try passing in your name as an argument to the command, using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try the `build-web` command, as shown in the following code. Because
    this command omits the `node` option, we expect that our argument will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Without the `node` option, our arguments are not forwarded to the script, and
    it defaults to saying `Hello, world!`, which is the expected result here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s test our `yarn start` command, using the following code, to
    make sure it builds the CLI version of the application and also forwards our command-line
    arguments, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `yarn start` command successfully built the CLI version of the application
    and forwarded our command-line arguments to the program.
  prefs: []
  type: TYPE_NORMAL
- en: We will try our best to use the same structure for each of the examples in this
    book, however, pay attention to the beginning of each chapter as each example
    may require some additional setup work.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've discussed the important moments of JavaScript's history
    as applied to ML, starting from the launch of Google ([https://www.google.com/](https://www.google.com/))
    and finishing up at the end of 2017 with the release of Google's `deeplearn.js`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve discussed some advantages to using JavaScript for machine learning, and
    also some of the challenges we’re facing, particularly in terms of the machine
    learning ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: We then took a tour of the most important recent developments in the JavaScript
    language, and had a brief introduction to ES6, the newest stable JavaScript language
    specification.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set up an example development environment using Node.js, the Yarn
    package manager, Babel, and Browserify—tools that we will use throughout the rest
    of the book in our examples.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll begin exploring and processing the data itself.
  prefs: []
  type: TYPE_NORMAL
