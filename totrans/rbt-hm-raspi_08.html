<html><head></head><body>
<div id="_idContainer140">
<h1 class="chapter-number" id="_idParaDest-165"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-166"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.2.1">Sensing Distances to Detect Objects with Pico</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Our robot is starting to move around independently. </span><span class="koboSpan" id="kobo.3.2">We spent the last chapter preparing mount points to add sensors, including distance sensors. </span><span class="koboSpan" id="kobo.3.3">We can use these sensors to detect how far objects are from the robot, and by adding more than one, we can see which direction is closest. </span><span class="koboSpan" id="kobo.3.4">This sense will allow the robot to respond to the real world and drive around a room without much </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">manual control.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will learn more about these sensors and their limitations. </span><span class="koboSpan" id="kobo.5.2">Then, we will attach the sensors to the robot and learn more about the communication protocol used to talk to them. </span><span class="koboSpan" id="kobo.5.3">Next, we will wire the sensors into Raspberry Pi Pico and get data. </span><span class="koboSpan" id="kobo.5.4">Finally, we will tie multiple sensors together with motor control to make the robot avoid obstacles </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">while driving.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">How distance </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">sensing works</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Soldering headers and attaching them to </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">the robot</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">An introduction to </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">I2C communication</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Communicating with a single </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">distance sensor</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Connecting two </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">distance sensors</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Building a wall avoider with Raspberry </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Pi Pico</span></span></li>
</ul>
<h1 id="_idParaDest-167"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">This chapter requires </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.24.1">The robot build from </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">previous chapters</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">2 x Pimoroni VL53L1X distance </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">sensor modules</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">2 x five-way single row 2.54-mm (included with </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">the modules)</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">8 x male-to-female jump wires with a 2.54-mm </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">DuPont connector</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">2 x M2 nuts and M2 x </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">6-mm bolts</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">A suitable screwdriver for driving the bolts, and a spanner for holding </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">the nuts</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">A soldering station with a soldering iron, solder, tip-cleaning brass, and </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">soldering stand</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">A flat work area with good lighting, free of interruptions or </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">being nudged</span></span></li>
<li><span class="koboSpan" id="kobo.40.1">The code from </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">previous chapters</span></span></li>
<li><span class="koboSpan" id="kobo.42.1">A Raspberry Pi Pico code editor such as Mu </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">or Thonny</span></span></li>
<li><span class="koboSpan" id="kobo.44.1">A USB </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">micro cable</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.46.1">You can find the code for this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">at </span></span><a href="https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-08"><span class="No-Break"><span class="koboSpan" id="kobo.48.1">https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-08</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.49.1">.</span></span></p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.50.1">How distance sensing works</span></h1>
<p><span class="koboSpan" id="kobo.51.1">Before diving into connecting and programming</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.52.1"> distance sensors, we should examine how they operate. </span><a href="B18001_07.xhtml#_idTextAnchor139"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.53.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.54.1">, </span><em class="italic"><span class="koboSpan" id="kobo.55.1">Planning and Shopping for More Devices</span></em><span class="koboSpan" id="kobo.56.1">, evaluated options and chose optical (light-based) distance sensors. </span><span class="koboSpan" id="kobo.56.2">We will be focusing on this type for the remainder of </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">Many distance sensors</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.59.1"> operate using a principle known as </span><strong class="bold"><span class="koboSpan" id="kobo.60.1">time of flight</span></strong><span class="koboSpan" id="kobo.61.1">. </span><span class="koboSpan" id="kobo.61.2">The following diagram </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">demonstrates this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer130">
<span class="koboSpan" id="kobo.63.1"><img alt="Figure 8.1 – Optical distance sensor operation " src="image/Figure_8.01_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.64.1">Figure 8.1 – Optical distance sensor operation</span></p>
<p><span class="koboSpan" id="kobo.65.1">The preceding diagram shows</span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.66.1"> pictures of robots with sensors and the returned light. </span><span class="koboSpan" id="kobo.66.2">On the top left, a single beam is emitted (shown as a cone), hits an object, and its reflection (shown as a dashed line) hits the sensor (the blue box), which detects it. </span><span class="koboSpan" id="kobo.66.3">The time between emitting the beam and receiving the response is the time of flight used to calculate the distance. </span><span class="koboSpan" id="kobo.66.4">At the top right of the diagram, both sensors are active. </span><span class="koboSpan" id="kobo.66.5">However, the left sensor detects a closer object in its beam, returning a lower value than the right sensor, which only detects the wall behind </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">the object.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">For most materials, the light beams make a diffuse reflection in all directions, as the bottom-left part of the diagram shows, and these time-of-flight sensors will detect their return. </span><span class="koboSpan" id="kobo.68.2">However, like the mirror shown in the bottom right of the diagram, some materials do not diffuse their reflected light and reflect away at the incident angle. </span><span class="koboSpan" id="kobo.68.3">Therefore, these objects may not be detected or will confuse the system. </span><span class="koboSpan" id="kobo.68.4">It may even detect objects reflected in a mirror as behind </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">the mirror.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">Note that these sensors have a slight instability in their readings, so they will take several readings and combine them to produce a more accurate reading. </span><span class="koboSpan" id="kobo.70.2">The sensors use a timing budget to take several readings. </span><span class="koboSpan" id="kobo.70.3">The VL53L1X device does this sampling </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">and averaging.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">Ambient light conditions</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.73.1"> can affect these sensors, with very bright light potentially washing out the beam. </span><span class="koboSpan" id="kobo.73.2">However, these work in most conditions, losing accuracy and a little distance but not becoming unusable. </span><span class="koboSpan" id="kobo.73.3">In our context, a robot mainly needs to detect an oncoming obstacle, so a loss of accuracy </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">is acceptable.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">We now understand how the sensors operate. </span><span class="koboSpan" id="kobo.75.2">In the next section, let’s attach them to </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">the robot.</span></span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.77.1">Soldering headers and attaching them to the robot</span></h1>
<p><span class="koboSpan" id="kobo.78.1">Before we can start to use or wire the sensors, we will need to solder headers onto them and then bolt them so they face forward on </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">the robot.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.80.1">Soldering headers</span></h2>
<p><span class="koboSpan" id="kobo.81.1">I recommend using a spare</span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.82.1"> breadboard for soldering these, as you did with Raspberry Pi Pico and the motor controller earlier in </span><a href="B18001_04.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.83.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.84.1">, </span><em class="italic"><span class="koboSpan" id="kobo.85.1">Building a Robot around Pico</span></em><span class="koboSpan" id="kobo.86.1">. </span><span class="koboSpan" id="kobo.86.2">The following photo shows me </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">soldering them:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer131">
<span class="koboSpan" id="kobo.88.1"><img alt="Figure 8.2 – Soldering the distance sensor headers " src="image/Figure_8.02_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.89.1">Figure 8.2 – Soldering the distance sensor headers</span></p>
<p><span class="koboSpan" id="kobo.90.1">The photo on the left of the preceding figure shows the sensors, the headers, and a breadboard to aid soldering. </span><span class="koboSpan" id="kobo.90.2">Place the headers long pins in the breadboard holes and the sensors on top. </span><span class="koboSpan" id="kobo.90.3">Pimoroni designed these sensor modules to hold the board on the header for </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">easy soldering.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">In the right photo, one sensor has had the header</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.93.1"> soldered in, and I am soldering the other. </span><span class="koboSpan" id="kobo.93.2">The headers should be facing back from the sensor so that the wiring will not be in the </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">sensor beam.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">With the headers soldered, you are ready to fit the sensors onto </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">the robot.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.97.1">Mounting the sensors</span></h2>
<p><span class="koboSpan" id="kobo.98.1">We put a lot of groundwork</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.99.1"> into mounting the sensors in previous chapters and created brackets to mount them onto. </span><span class="koboSpan" id="kobo.99.2">The following photo shows these sensors </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">bolted on:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer132">
<span class="koboSpan" id="kobo.101.1"><img alt="Figure 8.3 – Optical distance sensors mounted " src="image/Figure_8.03_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.102.1">Figure 8.3 – Optical distance sensors mounted</span></p>
<p><span class="koboSpan" id="kobo.103.1">On the left of the preceding photo are the robot’s front, the sensors, and the M2 nuts and bolts. </span><span class="koboSpan" id="kobo.103.2">We push the sensor’s headers through the slot and bolt them in place. </span><span class="koboSpan" id="kobo.103.3">Note that there might be a slight tightness around the slot. </span><span class="koboSpan" id="kobo.103.4">If so, file the header space up and out a little to accommodate this. </span><span class="koboSpan" id="kobo.103.5">Wipe or blow away any dust after filing. </span><span class="koboSpan" id="kobo.103.6">The right shows the sensors bolted</span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.104.1"> onto the front of </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">the robot.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">We will wire these sensors in via I2C. </span><span class="koboSpan" id="kobo.106.2">But, first, let’s take a closer look at how I2C is used to talk to sensors </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">like this.</span></span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.108.1">Introduction to I2C communication</span></h1>
<p><span class="koboSpan" id="kobo.109.1">You encountered I2C communication</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.110.1"> in earlier chapters. </span><a href="B18001_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.111.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.112.1">, discussed how I2C is a data bus that carries address information, allowing a primary device such as Raspberry Pi Pico to reach multiple devices on a single bus. </span><span class="koboSpan" id="kobo.112.2">We learned</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.113.1"> then that Raspberry Pi Pico has two hardware I2C buses. </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">I2C</span></strong><span class="koboSpan" id="kobo.115.1"> (or </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">I</span></strong><span class="superscript"><span class="koboSpan" id="kobo.117.1">2</span></span><strong class="bold"><span class="koboSpan" id="kobo.118.1">C</span></strong><span class="koboSpan" id="kobo.119.1">) is an acronym for </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.120.1">Inter-Integrated Circuit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">In </span><a href="B18001_07.xhtml#_idTextAnchor139"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.123.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.124.1">, </span><em class="italic"><span class="koboSpan" id="kobo.125.1">Planning and Shopping for More Devices</span></em><span class="koboSpan" id="kobo.126.1">, we saw how we would be using I2C devices both for VL53L1X distance sensors along with </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">an IMU.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">How exactly does this bus work? </span><a href="B18001_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.129.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.130.1">, also mentioned that I2C has two wires – a </span><strong class="bold"><span class="koboSpan" id="kobo.131.1">Serial Clock</span></strong><span class="koboSpan" id="kobo.132.1"> line (</span><strong class="bold"><span class="koboSpan" id="kobo.133.1">SCL</span></strong><span class="koboSpan" id="kobo.134.1">) and a </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">Serial Data</span></strong><span class="koboSpan" id="kobo.136.1"> line (</span><strong class="bold"><span class="koboSpan" id="kobo.137.1">SDA</span></strong><span class="koboSpan" id="kobo.138.1">). </span><span class="koboSpan" id="kobo.138.2">The following picture shows</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.139.1"> how devices send</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.140.1"> signals </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">through them:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer133">
<span class="koboSpan" id="kobo.142.1"><img alt="Figure 8.4 – I2C signals on the wire " src="image/Figure_8.04_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.143.1">Figure 8.4 – I2C signals on the wire</span></p>
<p><span class="koboSpan" id="kobo.144.1">The preceding diagram shows two graphs</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.145.1"> representing I2C signals. </span><span class="koboSpan" id="kobo.145.2">The horizontal axis is time, and the vertical axis when high is logic one, with low being logic zero. </span><span class="koboSpan" id="kobo.145.3">As shown in the top diagram, the clock produces a stream of pulses, a square wave. </span><span class="koboSpan" id="kobo.145.4">The accompanying data line sends data synchronized with the clock pulses. </span><span class="koboSpan" id="kobo.145.5">This clock means that devices on the bus </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">are synchronized.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">The lines are usually held high (logic high) and pulled down when a device wishes to communicate. </span><span class="koboSpan" id="kobo.147.2">Devices leave the line high when they have stopped communicating so another can control the bus. </span><span class="koboSpan" id="kobo.147.3">In most cases, the central controller will send a request to a device, and the device </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">will respond.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">As mentioned in </span><a href="B18001_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.150.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.151.1">, devices on an I2C bus have an address. </span><span class="koboSpan" id="kobo.151.2">However, these VL53L1X devices both have the same addresses. </span><span class="koboSpan" id="kobo.151.3">Luckily, there are two I2C buses we can use on Raspberry </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">Pi Pico.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">The good thing is that we don’t need to control much of this manually. </span><span class="koboSpan" id="kobo.153.2">CircuitPython has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">busio</span></strong><span class="koboSpan" id="kobo.155.1"> (bus input-output) library for handling I/O operations on a data bus, which we’ll use to control </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">these devices.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">We need to wire both SDA and SCL</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.158.1"> for each sensor and then write code connecting them. </span><span class="koboSpan" id="kobo.158.2">In the next section, we will discuss how to wire and talk to a </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">single sensor.</span></span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.160.1">Communicating with a single distance sensor</span></h1>
<p><span class="koboSpan" id="kobo.161.1">Each distance sensor</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.162.1"> requires only four wires; however, we will also improve the power system. </span><span class="koboSpan" id="kobo.162.2">We will then get into the code needed to read data from </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">a system.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.164.1">Wiring the distance sensors</span></h2>
<p><span class="koboSpan" id="kobo.165.1">We start our wiring by looking</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.166.1"> at a block diagram of our robot, as we saw previously in </span><a href="B18001_07.xhtml#_idTextAnchor139"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.167.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.168.1">. </span><span class="koboSpan" id="kobo.168.2">Look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer134">
<span class="koboSpan" id="kobo.170.1"><img alt="Figure 8.5 – The robot block diagram with distance sensors " src="image/Figure_8.05_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.171.1">Figure 8.5 – The robot block diagram with distance sensors</span></p>
<p><span class="koboSpan" id="kobo.172.1">The preceding diagram shows the robot block diagram with the additional VL53L1x distance sensors connected via I2C to Raspberry Pi Pico. </span><span class="koboSpan" id="kobo.172.2">The new parts have a thick </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">double outline.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">We need the schematic to get into the details of the connections, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer135">
<span class="koboSpan" id="kobo.176.1"><img alt="Figure 8.6 – The schematic with distance sensors " src="image/Figure_8.06_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.177.1">Figure 8.6 – The schematic with distance sensors</span></p>
<p><span class="koboSpan" id="kobo.178.1">In the preceding figure, I’ve shown a close-up schematic of the distance sensors connected to Raspberry Pi Pico. </span><span class="koboSpan" id="kobo.178.2">We connect</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.179.1"> a sensor to each I2C bus, along with 3v3 power and </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">ground connections.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">The right sensor has its SDA connected to </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">GPIO0</span></strong><span class="koboSpan" id="kobo.183.1"> and its SCL connected to </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">GPIO1</span></strong><span class="koboSpan" id="kobo.185.1">. </span><span class="koboSpan" id="kobo.185.2">The left sensor connects SDA to </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">GPIO2</span></strong><span class="koboSpan" id="kobo.187.1"> and SCL </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">GPIO3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">The following photo shows the </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">sensor wiring:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer136">
<span class="koboSpan" id="kobo.193.1"><img alt="Figure 8.7 – Distance sensors wired into the robot " src="image/Figure_8.07_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.194.1">Figure 8.7 – Distance sensors wired into the robot</span></p>
<p><span class="koboSpan" id="kobo.195.1">The preceding photo shows the robot with the sensors wired in using male-to-female jumper wires. </span><span class="koboSpan" id="kobo.195.2">Remember</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.196.1"> that you are not connecting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">INT</span></strong><span class="koboSpan" id="kobo.198.1"> pin from the sensor to anything, so expect a gap here. </span><span class="koboSpan" id="kobo.198.2">Also, double-check power and ground connections, as reversing these may damage the device. </span><span class="koboSpan" id="kobo.198.3">It is also a common troubleshooting problem with I2C to have accidentally swapped SDA and </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">SCL lines.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">Once the wiring is complete, please carefully remove the protective cover from the sensor, as </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">shown next:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer137">
<span class="koboSpan" id="kobo.202.1"><img alt="Figure 8.8 – Removing the protective tape " src="image/Figure_8.08_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.203.1">Figure 8.8 – Removing the protective tape</span></p>
<p><span class="koboSpan" id="kobo.204.1">As the preceding photo shows, if your sensors still have protective cover tape, carefully use a fingernail or tweezers to remove this cover before use. </span><span class="koboSpan" id="kobo.204.2">After removing this, take care not to touch the optical</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.205.1"> parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">the sensor.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">With this wired in, let’s look at how the sensor operates in the </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">next section.</span></span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.209.1">VL53LX theory of operation</span></h2>
<p><span class="koboSpan" id="kobo.210.1">These sensors</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.211.1"> have a particular operation cycle. </span><span class="koboSpan" id="kobo.211.2">We can</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.212.1"> use this as a guide for writing our code. </span><span class="koboSpan" id="kobo.212.2">The following diagram shows the states of </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">the VL53L1X:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer138">
<span class="koboSpan" id="kobo.214.1"><img alt="Figure 8.9 – VL53L1X operating states " src="image/Figure_8.09_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.215.1">Figure 8.9 – VL53L1X operating states</span></p>
<p><span class="koboSpan" id="kobo.216.1">The preceding state diagram is a simplified view of the states of this device. </span><span class="koboSpan" id="kobo.216.2">The nodes are the states, and the lines between them are events/signals that cause the state to change. </span><span class="koboSpan" id="kobo.216.3">First, the sensor starts on the left in an idle mode. </span><span class="koboSpan" id="kobo.216.4">This mode saves power until we want to measure distances. </span><span class="koboSpan" id="kobo.216.5">Then, the host (Pico) sends a start-ranging signal, and the device enters ranging mode, where it takes active measurements. </span><span class="koboSpan" id="kobo.216.6">Next, the device enters a data-ready state when it has taken enough measurements, as set by the timing budget. </span><span class="koboSpan" id="kobo.216.7">In this state, the host can read the </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">distance measured.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">However, the device will not make fresh measurements until the host sends a clear interrupt signal, putting it back in the </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">ranging state.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">Finally, when we no longer</span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.221.1"> need ranging, the host should send</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.222.1"> the stop-ranging signal, which puts the device back into an idle state and uses </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">less power.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">We will need to account for these state changes in our code, which we will cover in the </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">next section.</span></span></p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.226.1">Reading a single distance sensor in CircuitPython</span></h2>
<p><span class="koboSpan" id="kobo.227.1">When reading a sensor, we will use the Adafruit</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.228.1"> VL53L1X library. </span><span class="koboSpan" id="kobo.228.2">Copy </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">adafruit_vl53l1x.mpy</span></strong><span class="koboSpan" id="kobo.230.1"> from the Adafruit</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.231.1"> CircuitPython library into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">lib</span></strong><span class="koboSpan" id="kobo.233.1"> folder on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">CIRCUITPY</span></strong><span class="koboSpan" id="kobo.235.1"> volume. </span><span class="koboSpan" id="kobo.235.2">We can also write code inspired by their documentation examples. </span><span class="koboSpan" id="kobo.235.3">When communicating with any new device, using the example code for the related library is always a good start. </span><span class="koboSpan" id="kobo.235.4">We will adapt it a little for Raspberry </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">Pi Pico.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">We start the code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">read_1_sensor.py</span></strong><span class="koboSpan" id="kobo.239.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">with imports:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
import time
import board
import busio
import adafruit_vl53l1x</span></pre>
<p><span class="koboSpan" id="kobo.242.1">We’ve two new imports here. </span><span class="koboSpan" id="kobo.242.2">Alongside the vl53l1x library, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">busio</span></strong><span class="koboSpan" id="kobo.244.1"> library uses Pico pins to form data buses such </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">I2C</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">Next, we need to set up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">I2C</span></strong><span class="koboSpan" id="kobo.250.1"> bus </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">and device:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.252.1">
i2c = busio.I2C(sda=board.GP2, scl=board.GP3)
vl53 = adafruit_vl53l1x.VL53L1X(i2c)</span></pre>
<p><span class="koboSpan" id="kobo.253.1">This first line forms the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">I2C</span></strong><span class="koboSpan" id="kobo.255.1"> bus using GP0</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.256.1"> and GP1 pins, corresponding</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.257.1"> with the left sensor. </span><span class="koboSpan" id="kobo.257.2">Pico is a little fussy about which pins you can use for the SDA and SCL lines of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">I2C</span></strong><span class="koboSpan" id="kobo.259.1"> bus. </span><span class="koboSpan" id="kobo.259.2">We then create the VL53L1X device with this </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">I2C</span></strong><span class="koboSpan" id="kobo.261.1"> bus. </span><span class="koboSpan" id="kobo.261.2">In the next section of code, we send some settings to </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">the device:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
vl53.distance_mode = 1
vl53.timing_budget = 100</span></pre>
<p><span class="koboSpan" id="kobo.264.1">The device has multiple distance modes; distance mode 1 is short-range – for close objects. </span><span class="koboSpan" id="kobo.264.2">We set a timing budget of 100 milliseconds, controlling how long the sensor is allowed to take for measuring. </span><span class="koboSpan" id="kobo.264.3">It limits the maximum distance and the number of measurements used to </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">smooth data.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">Let’s start </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">the device:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
vl53.start_ranging()</span></pre>
<p><span class="koboSpan" id="kobo.269.1">We have now moved the device from the idle state into the ranging state. </span><span class="koboSpan" id="kobo.269.2">We can now wait for the measurements to be ready. </span><span class="koboSpan" id="kobo.269.3">We can now write the code for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.271.1"> loop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.272.1">
while True:
    if vl53.data_ready:
        print("Distance: {} cm".format(vl53.distance))
        vl53.clear_interrupt()
    time.sleep(0.05)</span></pre>
<p><span class="koboSpan" id="kobo.273.1">This loop starts by checking whether the device has data ready to read. </span><span class="koboSpan" id="kobo.273.2">When it has </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">data_ready</span></strong><span class="koboSpan" id="kobo.275.1">, we can read data with </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">vl53.distance</span></strong><span class="koboSpan" id="kobo.277.1"> and print it. </span><span class="koboSpan" id="kobo.277.2">This distance is </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">in centimeters.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">After reading the data, we need to send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">clear_interrupt</span></strong><span class="koboSpan" id="kobo.281.1"> signal, so the sensor goes back into its ranging mode for a </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">new reading.</span></span></p>
<p><span class="koboSpan" id="kobo.283.1">Regardless of whether there is data, the system will wait 50 milliseconds before looping around and </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">checking again.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">Upload this file to Pico and update </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">code.py</span></strong><span class="koboSpan" id="kobo.287.1"> to import </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">read_1_sensor.py</span></strong><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">Then, when you run it and connect the REPL, you should see output </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.291.1">
code.py output:
Distance: 35.1 cm
Distance: 34.4 cm
Distance: 33.8 cm
Distance: 35.2 cm</span></pre>
<p><span class="koboSpan" id="kobo.292.1">Let’s check</span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.293.1"> a few things to ensure everything’s all working</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.294.1"> before we </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">carry on.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.296.1">Troubleshooting</span></h2>
<p><span class="koboSpan" id="kobo.297.1">If this example code doesn’t work, the following troubleshooting</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.298.1"> steps </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">will help:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.300.1">If you receive the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">No pull up found on SDA or SCL; check your wiring</span></strong><span class="koboSpan" id="kobo.302.1"> warning, this indicates the wiring may be incorrect or that wires may be loose. </span><span class="koboSpan" id="kobo.302.2">Power down and check </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">the wiring.</span></span></li>
<li><span class="koboSpan" id="kobo.304.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">No I2C device at address: 29</span></strong><span class="koboSpan" id="kobo.306.1"> warning likely means you have reversed SDA and SCL. </span><span class="koboSpan" id="kobo.306.2">Swap them and </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">try again.</span></span></li>
<li><span class="koboSpan" id="kobo.308.1">There must be no heat in any part of the circuit including the wires, the batteries, the sensor, or Pico – this will cause damage, and should be powered down then the wiring </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">checked carefully.</span></span></li>
<li><span class="koboSpan" id="kobo.310.1">Sometimes, sensors can get stuck between test runs, resulting in slow or erratic results or sensors showing no errors but never having data ready. </span><span class="koboSpan" id="kobo.310.2">I advise powering the whole </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">robot down.</span></span></li>
<li><span class="koboSpan" id="kobo.312.1">Try adding lines such </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">print("i2c set up")</span></strong><span class="koboSpan" id="kobo.314.1"> between stages to see where the </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">problem is.</span></span></li>
<li><span class="koboSpan" id="kobo.316.1">If you see </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">unsupported operation</span></strong><span class="koboSpan" id="kobo.318.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">unknown distance mode</span></strong><span class="koboSpan" id="kobo.320.1">, check the power wiring to ensure each sensor is </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">well connected.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.322.1">Note that powering down means turning off battery power (if you’ve turned that on) and unplugging the computer. </span><span class="koboSpan" id="kobo.322.2">Never leave the computer plugged in </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">during rewiring.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">We should have data</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.325.1"> being read reliably from a single sensor. </span><span class="koboSpan" id="kobo.325.2">Our robot has two sensors, though, so let’s read data from both in the </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">next section.</span></span></p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.327.1">Connecting two distance sensors</span></h1>
<p><span class="koboSpan" id="kobo.328.1">We have wired </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.329.1">in two sensors, each on a separate set of pins. </span><span class="koboSpan" id="kobo.329.2">Create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">read_2_sensors.py</span></strong><span class="koboSpan" id="kobo.331.1"> file. </span><span class="koboSpan" id="kobo.331.2">The imports </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">look identical:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.333.1">
import time
import board
import busio
import adafruit_vl53l1x</span></pre>
<p><span class="koboSpan" id="kobo.334.1">When we come to set up the sensors, we first need to set up two </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">I2C</span></strong><span class="koboSpan" id="kobo.336.1"> buses on the different pins and then </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">use them:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.338.1">
i2c0 = busio.I2C(sda=board.GP0, scl=board.GP1)
i2c1 = busio.I2C(sda=board.GP2, scl=board.GP3)
vl53_l = adafruit_vl53l1x.VL53L1X(i2c0)
vl53_r = adafruit_vl53l1x.VL53L1X(i2c1)</span></pre>
<p><span class="koboSpan" id="kobo.339.1">We can also apply the same configuration settings for </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">both sensors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.341.1">
vl53_l.distance_mode = 1
vl53_l.timing_budget = 100
vl53_r.distance_mode = 1
vl53_r.timing_budget = 100</span></pre>
<p><span class="koboSpan" id="kobo.342.1">The main loop starts in the same way, with both sensors going into </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">ranging mode:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">
vl53_l.start_ranging()
vl53_r.start_ranging()
while True:</span></pre>
<p><span class="koboSpan" id="kobo.345.1">And in this case, we will check</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.346.1"> for ready data from both sensors </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">before printing:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.348.1">
    if vl53_l.data_ready and vl53_r.data_ready:
        print("Left: {} cm, Right: {} cm".format(vl53_l.distance, vl53_r.distance))
        vl53_l.clear_interrupt()
        vl53_r.clear_interrupt()
    time.sleep(0.05)</span></pre>
<p><span class="koboSpan" id="kobo.349.1">When uploaded and run on Pico, this code will now output both sensors’ data, as </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.351.1">
Left: 39.2 cm, Right: 37.4 cm
Left: 38.8 cm, Right: 37.4 cm
Left: 39.0 cm, Right: 37.4 cm
Left: 38.8 cm, Right: 37.6 cm
Left: 39.1 cm, Right: 37.6 cm</span></pre>
<p><span class="koboSpan" id="kobo.352.1">We’ll troubleshoot any problems</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.353.1"> here before we use two sensors for </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">smarter behavior.</span></span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.355.1">Troubleshooting</span></h2>
<p><span class="koboSpan" id="kobo.356.1">Adding a second sensor</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.357.1"> can still cause </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">odd behavior:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.359.1">First, the wiring considerations in the single </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">sensor apply.</span></span></li>
<li><span class="koboSpan" id="kobo.361.1">If you have used the same I2C bus twice in code, you will get some odd behavior or the same reading from both sensors. </span><span class="koboSpan" id="kobo.361.2">Check the code </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">for this.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.363.1">We now have data from two sensors, and in the next section, we’ll use this data to make the robot </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">avoid objects.</span></span></p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.365.1">Building a wall avoider with Raspberry Pi Pico</span></h1>
<p><span class="koboSpan" id="kobo.366.1">Two distance sensors and independent</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.367.1"> motor control with some code</span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.368.1"> are the ingredients needed to avoid obstacles. </span><span class="koboSpan" id="kobo.368.2">Let’s start by putting the distance sensors in the shared </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">robot library.</span></span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.370.1">Preparing the robot library</span></h2>
<p><span class="koboSpan" id="kobo.371.1">Like we have with other aspects</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.372.1"> of the robot, we’ll start by building the distance sensors set up in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">robot.py</span></strong><span class="koboSpan" id="kobo.374.1"> file. </span><span class="koboSpan" id="kobo.374.2">At the top of this file, the imports now include </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">busio</span></strong><span class="koboSpan" id="kobo.376.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">adafruit_vl53l1x</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.378.1"> libraries:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.379.1">
import board
import pwmio
import pio_encoder
import busio
import adafruit_vl53l1x</span></pre>
<p><span class="koboSpan" id="kobo.380.1">We can then set up our left and right distance sensors. </span><span class="koboSpan" id="kobo.380.2">Insert the following below the encoder setup and above the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">stop</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.382.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.383.1">
i2c0 = busio.I2C(sda=board.GP0, scl=board.GP1)
i2c1 = busio.I2C(sda=board.GP2, scl=board.GP3)
left_distance = adafruit_vl53l1x.VL53L1X(i2c0)
right_distance = adafruit_vl53l1x.VL53L1X(i2c1)</span></pre>
<p><span class="koboSpan" id="kobo.384.1">Save this file and be sure to upload it to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">CIRCUITPY</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.386.1"> volume.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">We will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">robot.py</span></strong><span class="koboSpan" id="kobo.389.1"> in the avoider</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.390.1"> code. </span><span class="koboSpan" id="kobo.390.2">We must next consider how avoiding </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">behaviors operate.</span></span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.392.1">Wall-avoiding theory of operation</span></h2>
<p><span class="koboSpan" id="kobo.393.1">We need to consider data from both</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.394.1"> sensors to avoid walls. </span><span class="koboSpan" id="kobo.394.2">The following diagram shows how we will </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">do this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer139">
<span class="koboSpan" id="kobo.396.1"><img alt="Figure 8.10 – Avoiding walls with two sensors " src="image/Figure_8.10_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.397.1">Figure 8.10 – Avoiding walls with two sensors</span></p>
<p><span class="koboSpan" id="kobo.398.1">In the preceding diagram, a sketched robot is facing a wall. </span><span class="koboSpan" id="kobo.398.2">It has sensed the wall, but the object is closer to the left sensor than the right; dashed arrows show reflections coming from the object. </span><span class="koboSpan" id="kobo.398.3">That means the robot should turn right to avoid this object, shown by the curved arrow to the robot’s left. </span><span class="koboSpan" id="kobo.398.4">We will make the turn by reversing the right motor until it is clear of </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">the obstacle.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">There is a special edge case</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.401.1"> where the two sensors detect the wall as equally close. </span><span class="koboSpan" id="kobo.401.2">To ensure the robot decides to avoid the flat obstacle, we will slightly bias (weight one side) by checking one sensor first and making a turn based </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">on that.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">We have all the parts we need. </span><span class="koboSpan" id="kobo.403.2">So, let’s start writing </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">this code.</span></span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.405.1">Distance sensor wall avoider code</span></h2>
<p><span class="koboSpan" id="kobo.406.1">The code for this uses the distance</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.407.1"> sensors from the robot library. </span><span class="koboSpan" id="kobo.407.2">Put this in </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">avoid_walls.py</span></strong><span class="koboSpan" id="kobo.409.1">. </span><span class="koboSpan" id="kobo.409.2">Let’s start with familiar imports and by setting the </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">sensor config:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.411.1">
import robot
import time
robot.left_distance.distance_mode = 1
robot.right_distance.distance_mode = 1</span></pre>
<p><span class="koboSpan" id="kobo.412.1">We’ll leave sensors on the default timing budget. </span><span class="koboSpan" id="kobo.412.2">We then have some configurations for </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">our avoider:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.414.1">
too_close_cm = 30
speed = 0.9</span></pre>
<p><span class="koboSpan" id="kobo.415.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">too_close_cm</span></strong><span class="koboSpan" id="kobo.417.1"> variable has a threshold for when the robot should turn to avoid a wall. </span><span class="koboSpan" id="kobo.417.2">We can set the overall robot speed for this behavior in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">speed</span></strong><span class="koboSpan" id="kobo.419.1"> variable. </span><span class="koboSpan" id="kobo.419.2">We can tune these two variables to ensure the robot avoids a wall in time. </span><span class="koboSpan" id="kobo.419.3">Let’s start the </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">sensors ranging:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.421.1">
robot.left_distance.start_ranging()
robot.right_distance.start_ranging()</span></pre>
<p><span class="koboSpan" id="kobo.422.1">We are going to start the robot moving; however, we want to ensure that the robot stops moving and stops the sensors ranging if there are any problems, so we wrap the main loop </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">try</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.426.1">
try:
  robot.set_left(speed)
  robot.set_right(speed)
  while True:</span></pre>
<p><span class="koboSpan" id="kobo.427.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">finally</span></strong><span class="koboSpan" id="kobo.429.1"> statement to accompany</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.430.1"> that </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">try</span></strong><span class="koboSpan" id="kobo.432.1"> will come below the main loop. </span><span class="koboSpan" id="kobo.432.2">Next, we check whether there is sensor </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">data ready:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.434.1">
    if robot.left_distance.data_ready and robot.right_distance.data_ready:
      left_dist = robot.left_distance.distance
      right_dist = robot.right_distance.distance</span></pre>
<p><span class="koboSpan" id="kobo.435.1">We store the read distances so that we can use them throughout the handling. </span><span class="koboSpan" id="kobo.435.2">Note that while </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">robot.left_distance.distance</span></strong><span class="koboSpan" id="kobo.437.1"> looks like a variable, it is a property that actively reads the sensor when we </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">use it.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">Since we have two values, we should check if one side is too close. </span><span class="koboSpan" id="kobo.439.2">Note that a timeout will result in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">0</span></strong><span class="koboSpan" id="kobo.441.1"> value, so we should check values are above this too. </span><span class="koboSpan" id="kobo.441.2">By favoring a side, we slightly bias the robot to that side, and this should stop the robot from being </span><em class="italic"><span class="koboSpan" id="kobo.442.1">indecisive</span></em><span class="koboSpan" id="kobo.443.1"> if both sensors detect a </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">close obstacle:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.445.1">
      if 0 &lt; right_dist &lt; too_close_cm:
        print("Obstacle detected - Left: {} cm, Right: {} cm".format(left_dist, right_dist))
        robot.set_left(-speed)</span></pre>
<p><span class="koboSpan" id="kobo.446.1">We check whether the distance on the right sensor is closer than the threshold. </span><span class="koboSpan" id="kobo.446.2">If so, we print a line of debug, showing that we’ve detected an obstacle and the two sensor readings. </span><span class="koboSpan" id="kobo.446.3">We then set the left motor to go backward, which will cause the robot to swerve left, away from </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">the obstacle.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">We can now handle what </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">happens otherwise:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.450.1">
      else:
        robot.set_left(speed)
        if 0 &lt; left_dist &lt; too_close_cm:
          print("Obstacle detected - Left: {} cm, Right: {} cm".format(left_dist, right_dist))
          robot.set_right(-speed)
        else:
          robot.set_right(speed)</span></pre>
<p><span class="koboSpan" id="kobo.451.1">If we’ve not turned left, we ensure</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.452.1"> the left motor is going forward. </span><span class="koboSpan" id="kobo.452.2">We then check the left distance sensor, and if this is too close, we turn right. </span><span class="koboSpan" id="kobo.452.3">Finally, we set the right motor forward, so both motors will be going forward if it detects nothing </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">too close.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">Putting the left distance check in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">else</span></strong><span class="koboSpan" id="kobo.456.1"> means that the robot will not set both motors backward and will favor turning left in front of an obstacle directly </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">in front.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">We then need to finish the loop by clearing the interrupts (so that the sensors are ranging again), and we leave a little time for them to </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">sense again:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.460.1">
      robot.left_distance.clear_interrupt()
      robot.right_distance.clear_interrupt()
      time.sleep(0.1)</span></pre>
<p><span class="koboSpan" id="kobo.461.1">Now, we need to handle any errors that happened. </span><span class="koboSpan" id="kobo.461.2">If you recall, we wrapped this code in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">try</span></strong><span class="koboSpan" id="kobo.463.1"> block. </span><span class="koboSpan" id="kobo.463.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">finally</span></strong><span class="koboSpan" id="kobo.465.1"> block stops and cleans </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">everything up:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.467.1">
finally:
  robot.stop()
  robot.left_distance.clear_interrupt()
  robot.right_distance.clear_interrupt()
  robot.left_distance.stop_ranging()
  robot.right_distance.stop_ranging()</span></pre>
<p><span class="koboSpan" id="kobo.468.1">The first thing we do here is to stop the motors. </span><span class="koboSpan" id="kobo.468.2">If anything goes wrong, such as errors from sensors or the code, we don’t want the robot to drive into a wall. </span><span class="koboSpan" id="kobo.468.3">We then clear the sensor interrupts and stop the sensors, putting them back into </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">idle mode.</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">This example is complete, and you can send it to the robot along with the updated </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">robot.py</span></strong><span class="koboSpan" id="kobo.472.1">. </span><span class="koboSpan" id="kobo.472.2">Keep the battery</span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.473.1"> power turned off initially and test that it detects obstacles. </span><span class="koboSpan" id="kobo.473.2">You should see output like </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.475.1">
Obstacle detected - Left: 29.6 cm, Right: 42.2 cm
Obstacle detected - Left: 17.2 cm, Right: 39.6 cm
Obstacle detected - Left: 10.4 cm, Right: 39.1 cm
Obstacle detected - Left: 5.2 cm, Right: 42.6 cm
Obstacle detected - Left: 6.7 cm, Right: 42.3 cm
Obstacle detected - Left: 18.4 cm, Right: 27.6 cm</span></pre>
<p><span class="koboSpan" id="kobo.476.1">Once you’ve seen it working and detecting, you can turn the battery power on, which will enable the motors and let drive along – either using a long USB cable or independently if it’s working well. </span><span class="koboSpan" id="kobo.476.2">Let’s check whether we have any problems with </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">some troubleshooting.</span></span></p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.478.1">Troubleshooting</span></h1>
<p><span class="koboSpan" id="kobo.479.1">These steps should</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.480.1"> get you up and running if you have </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">any problems:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.482.1">If the robot complains about importing modules, ensure you have uploaded the code and libraries for this chapter and </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">previous ones.</span></span></li>
<li><span class="koboSpan" id="kobo.484.1">If the robot is getting too close before turning, try increasing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">too_close</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.486.1"> variable.</span></span></li>
<li><span class="koboSpan" id="kobo.487.1">With any behavior using motors, ensure the batteries are fresh. </span><span class="koboSpan" id="kobo.487.2">Low power can cause stalling motors and </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">malfunctioning sensors.</span></span></li>
<li><span class="koboSpan" id="kobo.489.1">The sensors will not detect obstacles that are above or below them. </span><span class="koboSpan" id="kobo.489.2">This limitation means the robot</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.490.1"> will drive into and get stuck on low obstacles or under </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">high ones.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.492.1">Your robot now avoids walls </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">and objects.</span></span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.494.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.495.1">In this chapter, we learned about distance sensors. </span><span class="koboSpan" id="kobo.495.2">We looked at how the sensors operate and how to </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">attach them.</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">We learned more about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">I2C</span></strong><span class="koboSpan" id="kobo.499.1"> bus and then saw how to electrically connect these VL53L1X </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">distance sensors.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">We then looked at the operating modes of the VL53L1X sensor and wrote code to get readings from one. </span><span class="koboSpan" id="kobo.501.2">Finally, we finished with a behavior to avoid walls using </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">this sensor.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">In the next chapter, we will gain remote control of our robot by </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">adding Bluetooth.</span></span></p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.505.1">Exercises</span></h1>
<p><span class="koboSpan" id="kobo.506.1">You can use these exercises to practice more of the concepts learned in </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.508.1">Could you write code to follow an object at a fixed distance? </span><span class="koboSpan" id="kobo.508.2">If it’s further away, could you drive it forward, and if it’s too close, back it up </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">a little?</span></span></li>
<li><span class="koboSpan" id="kobo.510.1">Try different materials in front of the robot, such as glass, black fabric, thin paper, and thick paper. </span><span class="koboSpan" id="kobo.510.2">Observe which are detected and how they affect the distance detected. </span><span class="koboSpan" id="kobo.510.3">For example, what happens if you aim the robot at </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">a mirror?</span></span></li>
<li><span class="koboSpan" id="kobo.512.1">Try observing the distance measurements in different light conditions, such as room light, darkness, and </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">full sunlight.</span></span></li>
</ul>
<h1 id="_idParaDest-187"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.514.1">Additional reading</span></h1>
<p><span class="koboSpan" id="kobo.515.1">The following sources of additional reading can deepen your understanding of </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">these sensors:</span></span></p>
<ul>
<li><a href="https://github.com/adafruit/Adafruit_CircuitPython_VL53L1X"><span class="koboSpan" id="kobo.517.1">https://github.com/adafruit/Adafruit_CircuitPython_VL53L1X</span></a><span class="koboSpan" id="kobo.518.1"> has the library and sample code for driving </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">a device.</span></span></li>
<li><a href="https://www.ti.com/lit/an/sbau305b/sbau305b.pdf"><span class="koboSpan" id="kobo.520.1">https://www.ti.com/lit/an/sbau305b/sbau305b.pdf</span></a><span class="koboSpan" id="kobo.521.1"> is a datasheet for a different brand of optical sensors. </span><span class="koboSpan" id="kobo.521.2">However, it has excellent information on reflectance and how materials affect </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">distance sensing.</span></span></li>
<li><a href="https://www.st.com/en/imaging-and-photonics-solutions/vl53l1x.html#documentation"><span class="koboSpan" id="kobo.523.1">https://www.st.com/en/imaging-and-photonics-solutions/vl53l1x.html#documentation</span></a><span class="koboSpan" id="kobo.524.1"> contains the complete product documentation. </span><span class="koboSpan" id="kobo.524.2">Of particular interest are the product specifications and API </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">user manual.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.526.1">For an alternative technique using ultrasonic distance sensors, refer to </span><em class="italic"><span class="koboSpan" id="kobo.527.1">Learn Robotics Programming – Second Edition</span></em><span class="koboSpan" id="kobo.528.1"> by </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.529.1">Danny Staple</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">.</span></span></p>
</div>
</body></html>