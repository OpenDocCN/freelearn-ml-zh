- en: Designing a GUI for a Robot Using Qt and Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we discussed the integration of robotic hardware components
    and software packages for performing autonomous navigation. After the integration,
    the next step is to build a GUI to control the robot. We are building a GUI that
    can act as a trigger for the underlying ROS commands. Instead of running all the
    commands on the Terminal, the user can work with the GUI buttons. The GUI we are
    going to design is for a typical hotel room with nine tables. The user can set
    a table position in the map of the hotel room and command the robot to go to a
    particular table to deliver food. After delivering the food, the user can command
    the robot to go to its home position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Qt on Ubuntu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to PyQt and PySide
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Qt Designer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt signals and slots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a Qt UI file to a Python file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the ChefBot GUI application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to rqt and its features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test the application and code in this chapter, you need an Ubuntu 16.04 LTS
    PC/laptop with ROS Kinetic installed.
  prefs: []
  type: TYPE_NORMAL
- en: You need to know Qt, PyQt, and rqt installed.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the most popular GUI frameworks currently available are Qt ([http://qt.digia.com](http://qt.digia.com))
    and GTK+ ([http://www.gtk.org/](http://www.gtk.org/)).Qt and GTK+ are open source,
    cross-platform user interface toolkits and development platforms. These two software
    frameworks are widely used in Linux desktop environments, such as GNOME and KDE.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be using Python binding of the Qt framework to implement
    the GUI because Python binding of Qt is easier to develop compared to other methods.
    We will look at how to develop a GUI from scratch and program it using Python.
    After discussing basic Python and Qt programming, we will discuss ROS interfaces
    of Qt and Python, which are already available in ROS. We will first look at what
    the Qt UI framework is and how to install it on our PC.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Qt on Ubuntu 16.04 LTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt is a cross-platform application framework that is widely used to develop
    application software with a GUI interface as well as command line tools. Qt is
    available in almost all operating systems, such as Windows, macOS X, Android,
    and so on. The main programming language used for developing Qt applications is
    C++ but there are bindings available for languages such as Python, Ruby, Java,
    and so on. Let''s take a look at how to install Qt SDK on Ubuntu 16.04\. We will
    install Qt from the **Advance Packaging Tool** (**APT**) in Ubuntu. The APT already
    comes with Ubuntu installation. So, for installing Qt/Qt SDK, we can simply use
    the following command, which will install Qt SDK and its required dependencies
    from the Ubuntu package repository. We can install Qt version 4 using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will install the entire Qt SDK and its libraries required for
    our project. The packages available on Ubuntu repositories may not be the latest
    versions. To get the latest version of Qt, we can download the online or offline
    installer of Qt for various OS platforms from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://qt-project.org/downloads](http://qt-project.org/downloads)'
  prefs: []
  type: TYPE_NORMAL
- en: After installing Qt on our system, we will see how we can develop GUI using
    Qt and interface with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Python bindings of Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how we can interface Python and Qt. In general, there are two modules
    available in Python for connecting to the Qt user interface. The two most popular
    frameworks are:'
  prefs: []
  type: TYPE_NORMAL
- en: PyQt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PySide
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyQt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PyQt** is one of the most popular Python bindings for Qt cross-platform.
    PyQt is developed and maintained by Riverbank Computing Limited. It provides binding
    for Qt version 4 and Qt version 5 and comes with GPL (version 2 or 3) along with
    a commercial license. PyQt is available for Qt version 4 and 5, called PyQt4 and
    PyQt5, respectively. These two modules are compatible with Python versions 2 and
    3\. PyQt contains more than 620 classes that cover the user interface, XML, network
    communication, web, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'PyQt is available in Windows, Linux, and macOS X. It is a prerequisite to install
    Qt SDK and Python in order to install PyQt. The binaries for Windows and macOS
    X are available at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.riverbankcomputing.com/software/pyqt/download](http://www.riverbankcomputing.com/software/pyqt/download)'
  prefs: []
  type: TYPE_NORMAL
- en: We will see how to install PyQt4 on Ubuntu 16.04 using Python 2.7.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PyQt in Ubuntu 16.04 LTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to install PyQt on Ubuntu/Linux, use the following command. This
    command will install the PyQt library, its dependencies, and some Qt tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: PySide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PySide** is an open source software project that provides Python binding
    for the Qt framework. The PySide project was initiated by Nokia and offers a full
    set of Qt binding for multiple platforms. The technique used in PySide to wrap
    the Qt library is different from PyQt, but the API of both is similar. PySide
    is currently not supported on Qt 5\. PySide is available for Windows, Linux, and
    macOS X. The following link will guide you to set up PySide on Windows and macOS
    X:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://qt-project.org/wiki/Category:LanguageBindings::PySide::Downloads](http://qt-project.org/wiki/Category:LanguageBindings::PySide::Downloads)'
  prefs: []
  type: TYPE_NORMAL
- en: The prerequisites of PySide are the same as PyQt. Let's see how we can install
    PySide on Ubuntu 16.04 LTS.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PySide on Ubuntu 16.04 LTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The PySide package is available on the Ubuntu package repository. The following
    command will install the PySide module and Qt tools on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's work with both modules and see the differences between both.
  prefs: []
  type: TYPE_NORMAL
- en: Working with PyQt and PySide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After installing the PyQt and PySide packages, we will look at how to write
    an Hello World GUI using PyQt and PySide. The main difference between PyQt and
    PySide is only in some commands; most of the steps are the same. Let's see how
    to make a Qt GUI and convert it into Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Qt Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Designer is the tool for designing and inserting control into the Qt GUI.
    The Qt GUI is basically an XML file that contains the information of its components
    and controls. The first step to work with the GUI relates to its design. The Qt
    Designer tool provides various options to make excellent GUIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start Qt Designer by entering the `designer-qt4` command on the Terminal. The
    following screenshot shows what you will be able to see after running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79d339d8-e7cf-4e57-8570-7632032b932b.png)'
  prefs: []
  type: TYPE_IMG
- en: Qt 4 Designer
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows the Qt Designer interface. Select the Widget
    option from the New Form window and click on the Create button. This will create
    an empty widget; we can drag various GUI controls from the left-hand side of Qt
    4 Designer to the empty widget. Qt widgets are the basic building blocks of the
    Qt GUI. The following screenshot shows a form with a PushButton dragged from the
    left-hand side window of Qt Designer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c5fde11-b827-46ef-9b6f-9a4b73be38d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Qt Designer widget form
  prefs: []
  type: TYPE_NORMAL
- en: The Hello World application that we are going to build will have a PushButton.
    When we click on the PushButton, an Hello World message will be printed on the
    Terminal. Before building the Hello World application, we need to understand what
    Qt signals and slots are, because we have to use these features for building the
    Hello World application.
  prefs: []
  type: TYPE_NORMAL
- en: Qt signals and slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Qt, GUI events are handled using the signals and slots features. A signal
    is emitted from the GUI when an event occurs. Qt widgets have many predefined
    signals, and users can add custom signals for GUI events. A slot is a function
    that is called in response to a particular signal. In this example, we are using
    the `clicked()` signal of PushButton and creating a custom slot for this signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write our own code inside this custom function. Let''s see how we can
    create a button, connect a signal to a slot, and convert the entire GUI to Python.
    Here are the steps involved in creating the Hello World GUI application:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag and create a PushButton from Qt Designer to the empty Form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign a slot for the button clicked event, which emits a signal called `clicked()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the designed UI file in the `.ui` extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert UI files to Python.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the definition of the custom slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the Hello World message inside the defined slot/function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have already dragged a button from Qt Designer to an empty Form. Press the
    F4 key to insert a slot on the button. When we press F4, the PushButton turns
    red, and we can drag a line from the button and place the ground symbol in the
    main window. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea1eb77a-605e-4063-a50d-ac83c58213bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Assigning slots and signals in Qt 4 Designer
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the clicked() signal from the left-hand side and click on the Edit...
    button to create a new custom slot. When we click on the Edit... button, another
    window will pop up to create a custom function. You can create a custom function
    by clicking on the + symbol. We created a custom slot called message(), as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae0a6675-d42b-413b-8a7c-f7c3a82622ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Assigning slots and signals in Qt 4 Designer
  prefs: []
  type: TYPE_NORMAL
- en: Click on the OK button, save the UI file as `hello_world.ui`, and quit Qt Designer.
    After saving the UI file, let's see how we can convert a Qt UI file into a Python
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about Qt Signals and slots from the following link
  prefs: []
  type: TYPE_NORMAL
- en: https://doc.qt.io/qt-5/signalsandslots.html
  prefs: []
  type: TYPE_NORMAL
- en: Converting a UI file into Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After designing the UI file, we can convert the UI file into its equivalent
    Python code. The conversion is done using a `pyuic` compiler. We have already
    installed this tool while installing PyQt/PySide. The following are the commands
    to convert a Qt UI file into a Python file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to use different commands for PyQt and PySide. The following command
    is to convert the UI into its PyQt equivalent file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `pyuic4` is a UI compiler to convert a UI file into its equivalent Python
    code. We need to mention the UI filename after the `-x` argument and mention the
    output filename after the `-o` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are not many changes to the PySide command. Instead of `pyuic4`, PySide
    uses `pyside-uic` to convert UI files into Python files. The remaining arguments
    are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will generate an equivalent Python code for the UI file.
    This will create a Python class that has the GUI components. The generated script
    will not have the definition of the custom function `message()`. We should add
    this custom function to generate the code. The following procedure will guide
    you to add the custom function; so when you click on the button, the custom function
    `message()` will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a slot definition to PyQt code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The generated Python code from PyQt is given here. The code generated by `pyuic4`
    and `pyside-uic` are the same, except in importing module names. All other parts
    are the same. The explanation of the code generated using PyQt is also applicable
    to PySide code. The code generated from the preceding conversion is as follows.
    The code structure and parameters can change according to the UI file that you
    have designed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is the equivalent Python script of the Qt UI file that we
    designed in the Qt Designer application. Here is the step-by-step procedure of
    the working of this code:'
  prefs: []
  type: TYPE_NORMAL
- en: The code will start executing from `if __name__ == "__main__":`. The first thing
    in the PyQt code is to create a `QApplication` object. A `QApplication` class
    manages the GUI application's control flow and main settings. The `QApplication`
    class contains the main event loop, where all events from the Windows system and
    other sources are processed and dispatched. It also handles initialization and
    finalization of an application. The `QApplication` class is inside the `QtGui`
    module. This code creates an object of `QApplication` called `app`. We have to
    add the main code manually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Form = QtGui.QWidget()` line creates an object called `Form` of the `QWidget`
    class that is present inside the `QtGui` module. The `QWidget` class is the base
    class of all user interface objects of Qt. It can receive the mouse and keyboard
    event from the main Windows system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `ui = Ui_Form()` line creates an object called `ui` of the `Ui_Form()`
    class defined in the code. The `Ui_Form()` object can accept the `QWidget` class
    that we created in the previous line and it can add buttons, text, button control,
    and other UI components into this `QWidget` object. The `Ui_Form()` class contains
    two functions: `setupUi()` and `retranslateUi()`. We can pass the `QWidget` object
    to the function called `setupUi()`. This function will add UI components on this
    widget object, such as buttons, assigning slots for signals, and so on. The `retranslateUi()`
    function will translate the language of the UI to other languages if needed. For
    example, if we need translation from English to Spanish, we can mention the corresponding
    Spanish word in this function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Form.show()` line displays the final window with buttons and text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next thing is to create the slot function, which prints the Hello World
    message. The slot definition is created inside the `Ui_Form()` class. The following
    steps insert the slot called `message()` into the `Ui_Form()` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `message()` function definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be inserted as a function inside the `Ui_Form()` class. Also, change
    the following line in the `setupUi()` function inside the `Ui_Form()` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `Form.message` parameter should be replaced with the `self.message` parameter.
    The preceding line connects the PushBbutton signal, `clicked(),` to the `self.message()`
    slot that we already inserted in the `Ui_Form()` class.
  prefs: []
  type: TYPE_NORMAL
- en: Operation of the Hello World GUI application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After replacing the `Form.message` parameter with the `self.message` parameter,
    we can execute the code and the output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2c93c15-f076-430b-b5f3-308ab5a216bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Running Pyqt4 application
  prefs: []
  type: TYPE_NORMAL
- en: When we click on the Press the button, it will print the Hello world message.
    This is all about setting a custom GUI with Python and Qt.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see the actual GUI that we are designing for the
    robot.
  prefs: []
  type: TYPE_NORMAL
- en: Working with ChefBot's control GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After completing the Hello World application in PyQt, we will now discuss a
    GUI for controlling ChefBot. The main use of building a GUI is to create an easier
    way to control the robot. For example, if the robot is deployed in a hotel to
    serve food, the person who controls this robot need not have knowledge about the
    complex commands to start and stop this robot; so, building a GUI for ChefBot
    can reduce the complexity and make it easier for the user. We are planning to
    build a GUI using PyQt, ROS, and the Python interface. The ChefBot ROS package
    is available on GitHub at the following link: [https://github.com/qboticslabs/learning_robotics_2nd_ed](https://github.com/qboticslabs/learning_robotics_2nd_ed)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t cloned the code yet, you can do so now using following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The GUI code named `robot_gui.py` is placed in the `scripts` folder, which is
    inside the `chefbot_bringup` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the GUI that we have designed for ChefBot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5ce585c-4d5b-424b-b6d9-45e81d1bd871.png)'
  prefs: []
  type: TYPE_IMG
- en: Running Pyqt4 application
  prefs: []
  type: TYPE_NORMAL
- en: 'The GUI has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It can monitor the robot battery status and robot status. The robot status indicates
    the working status of the robot. For example, if the robot encounters an error,
    it will indicate the error on this GUI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It can command the robot to move into a table position for delivering food.
    There is a spin box widget on the GUI to input the table position. Currently,
    we are planning this GUI for a room with nine tables, but we may expand it to
    any number according to the requirement. After inputting the table number, we
    can command the robot to go to that table by clicking on the Go button; the robot
    will get into that position. If we want to return the robot to the initial position,
    we can click on the Home button. If we want to cancel the current robot movement,
    click on Cancel to stop the robot. The working of this GUI application is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have to deploy ChefBot in a hotel, the first procedure that we have
    to do is to create a map of the room. After mapping the entire room properly,
    we have to save the map on the robot PC. The robot does the mapping only once.
    After mapping, we can run the localization and navigation routines and command
    the robot to get into a position on the map. The ChefBot ROS package comes with
    a map and simulation model of a hotel-like environment. We can now run this simulation
    and localization for testing the GUI and in the next chapter, we will discuss
    how to control the hardware using the GUI. If you install the ChefBot ROS packages
    on your local system, we can simulate a hotel environment and test the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the ChefBot simulation in a hotel-like arrangement using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After starting the ChefBot simulation, we can run the localization and navigation
    routines using an already built map. The map is placed in the `chefbot_bringup`
    package. We can see a `map` folder inside this package. Here, we will use this
    map for performing this test. We can load the localization and navigation routine
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The path of the map file can change in different systems, so use the path in
    your system instead of this path.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the path mentioned is correct, it will start running the ROS navigation
    stack. If we want to see the robot position on the map or manually set the initial
    position of the robot, we can use RViz using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In RViz, we can command the robot to go to any map coordinates using the 2D
    Nav Goal button.
  prefs: []
  type: TYPE_NORMAL
- en: We can command the robot to go to any map coordinates using programming too.
    The ROS navigation stack works using the ROS `actionlib` library. The ROS `actionlib`
    library is for performing preemptable tasks; it is similar to ROS services. An
    advantage over ROS services is that we can cancel the request if we don't want
    it at that time.
  prefs: []
  type: TYPE_NORMAL
- en: In the GUI, we can command the robot to go to a map coordinate using the Python
    `actionlib` library. We can get the table position on the map using the following
    technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'After starting the simulator and AMCL nodes, launch the keyboard teleoperation
    and move the robot near each table. Use the following command to get the translation
    and rotation of the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When we click on the Go button, the position is fed to the navigation stack
    and the robot plans its path and reaches its goal. We can even cancel the task
    at any time. So, the ChefBot GUI acts as an `actionlib` client, which sends map
    coordinates to the `actionlib` server; that is, the navigation stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the robot GUI to control the robot using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can select a table number and click on the Go button for moving the robot
    to each table.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that you cloned the files and got the `robot_gui.py` file, we will
    discuss the main slots we added into the `Ui_Form()` class for the `actionlib`
    client and to get values of the battery and robot status.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to import the following Python modules for this GUI application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The additional modules we require are the ROS Python client `rospy`, and the
    `actionlib` module to send values to the navigation stack. The `move_base_msgs`
    module contains the message definition of the goal that needs to be sent to the
    navigation stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The robot position near each table is mentioned in a Python dictionary. The
    following code shows hardcode values of the robot''s position near each table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can access the position of the robot near each table by accessing this dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we have inserted only four values for the purpose of demonstration.
    You can add more values by finding the position of other tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are assigning some variables to handle the table number, position of the
    robot, and the `actionlib` client inside the `Ui_Form()` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the signals and slots assignment in this code for
    buttons and spin box widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following slot handles the spin box value from the UI and assigns a table
    number. Also, it converts the table number to the corresponding robot position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the definition of the Go slot for the Go button. This function will
    insert the robot position of the selected table in a goal message header and send
    it into the navigation stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the `Cancel()` slot definition. This will cancel all
    the robot paths that it was planning to perform at that time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the definition of `Home()`. This will set the table position
    to zero, and call the `Go()` function. The table at position zero is the home
    position of the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following definitions are for the `update_values()` and `add()` functions.
    The `update_values()` method will start updating the battery level and robot status
    in a thread. The `add()` function will retrieve the ROS parameters of the battery
    status and robot status, and set them to the progress bar and label, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WorkThread()` class used in the preceding function is given here. The
    `WorkThread()` class is inherited from `QThread` provided by Qt for threading.
    The thread simply emits the signal `update(Qstring)` with a particular delay.
    In the preceding function, `update_values()`, the `update(QString)` signal is
    connected to the `self.add()` slot; so when a signal `update(QString)` is emitted
    from the thread, it will call the `add()` slot and update the battery and status
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have discussed how to make a GUI for ChefBot, but this GUI is only for the
    user who controls ChefBot. If someone wants to debug and inspect the robot data,
    we may have to go for other tools. ROS provides an excellent debugging tool to
    visualize data from the robot.
  prefs: []
  type: TYPE_NORMAL
- en: The rqt tool is a popular ROS tool. It is based on a Qt-based framework for
    GUI development for ROS. Let's discuss the rqt tool, installation procedure, and
    how we can inspect the sensor data from the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and working with rqt in Ubuntu 16.04 LTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**rqt** is a software framework in ROS, which implements various GUI tools
    in the form of plugins. We can add plugins as dockable windows in rqt.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing rqt in Ubuntu 16.04 can be done using the following command. Before
    installing rqt, ensure that you have the full installation of ROS Indigo.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After installing the rqt packages, we can access the GUI implementation of rqt,
    called `rqt_gui`, in which we can dock `rqt plugins` in a single window.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start using `rqt_gui`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `roscore` command before running `rqt_gui`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to start `rqt_gui`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following window if the commands work fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e961dbae-41f4-4d68-aabc-a1841a13c0ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Running rqt
  prefs: []
  type: TYPE_NORMAL
- en: We can load and unload plugins at runtime. To analyze the ROS message log, we
    can load the Console plugin from Plugins | Logging | Console. In the following
    example, we load the Console plugin and run a talker node inside `rospy_tutorials`,
    which will send an Hello World message to a topic called `/chatter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to start the node `talker.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the following screenshot, `rqt_gui` is loaded with two plugins named Console
    and Topic Monitor. The Topic Monitor plugin can be loaded from Plugins | Topics
    | Topic Monitor. The Console plugin monitors the messages printing on each node
    and their severity. It is very useful for debugging purposes. In the following
    screenshot, the left section of `rqt_gui` is loaded with the Console plugin and
    the right side is loaded with the Topic Monitor. The Topic Monitor will list the
    topics available and will monitor its values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, the Console plugin monitors the `talker.py` node''s
    messages and their severity level and the Topic Monitor monitors the value inside
    the `/chatter` topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fbb4413-7100-4866-8ed2-e38d1fe16381.png)'
  prefs: []
  type: TYPE_IMG
- en: Running rqt with different plugins
  prefs: []
  type: TYPE_NORMAL
- en: We can also visualize data such as images and plot graphs on `rqt_gui`. For
    the robot's navigation and its inspection, there are plugins for embedding RViz
    on `rqt_gui`. The Navigation viewer plugin views from the `/map` topic. The visualization
    plugins are available in Plugin | Visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create the GUI using rqt. The instructions to create rqt plugins
    that can load in to rqt_gui can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://wiki.ros.org/rqt/Tutorials/Create%20your%20new%20rqt%20plugin](http://wiki.ros.org/rqt/Tutorials/Create%20your%20new%20rqt%20plugin)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed creating a GUI for ChefBot that can be used by
    an ordinary user who doesn't have any idea about the internal workings of a robot.
    We used Python binding of Qt called PyQt to create this GUI. Before we looked
    at the main GUI design, we looked at an Hello World application to get an easier
    understanding of PyQt. The UI design was done using the Qt Designer tool and the
    UI file was converted into its equivalent Python script using the Python UI compiler.
    After designing the main GUI in Qt Designer, we converted the UI file into Python
    script and inserted the necessary slots in the generated script. The ChefBot GUI
    can start the robot, select a table number, and command the robot to get into
    that position. The position of each table comes from the generated map where we
    hardcoded the positions in this Python script for testing. When a table is selected,
    we set a goal position on the map, and when we click on the Go button, the robot
    will move into the intended position. The user can cancel the operation at any
    time and command the robot to come to the home position. The GUI can also receive
    the real-time status of the robot and its battery status. After discussing the
    robot GUI, we looked at the debugging GUI tool in ROS, called rqt. We saw some
    plugins used for debugging the data from the robot. In the next chapter, we will
    see the complete testing and calibration of the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the popular UI toolkits available on the Linux platform?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the differences between PyQt and PySide Qt bindings?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you convert a Qt UI file into Python script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Qt signals and slots?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is rqt and what are its main applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read more about robotic vision packages in ROS at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://wiki.ros.org/rqt/UserGuide](http://wiki.ros.org/rqt/UserGuide)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://wiki.ros.org/rqt/Tutorials](http://wiki.ros.org/rqt/Tutorials)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
