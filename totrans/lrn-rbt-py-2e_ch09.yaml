- en: Designing a GUI for a Robot Using Qt and Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt和Python设计机器人GUI
- en: In the last chapter, we discussed the integration of robotic hardware components
    and software packages for performing autonomous navigation. After the integration,
    the next step is to build a GUI to control the robot. We are building a GUI that
    can act as a trigger for the underlying ROS commands. Instead of running all the
    commands on the Terminal, the user can work with the GUI buttons. The GUI we are
    going to design is for a typical hotel room with nine tables. The user can set
    a table position in the map of the hotel room and command the robot to go to a
    particular table to deliver food. After delivering the food, the user can command
    the robot to go to its home position.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了用于执行自主导航的机器人硬件组件和软件包的集成。集成之后，下一步是构建一个GUI来控制机器人。我们正在构建一个可以作为底层ROS命令触发器的GUI。用户不必在终端上运行所有命令，而是可以通过GUI按钮进行操作。我们将要设计的GUI适用于典型的酒店房间，房间内有九张桌子。用户可以在酒店房间的地图上设置桌子位置，并命令机器人前往特定的桌子送餐。送餐后，用户可以命令机器人返回其起始位置。
- en: 'The following topics will be covered in the chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Installing Qt on Ubuntu
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Ubuntu上安装Qt
- en: Introduction to PyQt and PySide
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyQt和PySide的介绍
- en: Introduction to Qt Designer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Designer的介绍
- en: Qt signals and slots
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt信号和槽
- en: Converting a Qt UI file to a Python file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Qt UI文件转换为Python文件
- en: Working with the ChefBot GUI application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与ChefBot GUI应用程序一起工作
- en: Introduction to rqt and its features
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: rqt及其特性的介绍
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To test the application and code in this chapter, you need an Ubuntu 16.04 LTS
    PC/laptop with ROS Kinetic installed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试本章中的应用程序和代码，您需要一个安装了ROS Kinetic的Ubuntu 16.04 LTS PC/笔记本电脑。
- en: You need to know Qt, PyQt, and rqt installed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要了解Qt、PyQt和rqt已安装。
- en: Two of the most popular GUI frameworks currently available are Qt ([http://qt.digia.com](http://qt.digia.com))
    and GTK+ ([http://www.gtk.org/](http://www.gtk.org/)).Qt and GTK+ are open source,
    cross-platform user interface toolkits and development platforms. These two software
    frameworks are widely used in Linux desktop environments, such as GNOME and KDE.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最流行的两个GUI框架是Qt ([http://qt.digia.com](http://qt.digia.com)) 和 GTK+ ([http://www.gtk.org/](http://www.gtk.org/))。Qt和GTK+是开源的、跨平台的用户界面工具包和开发平台。这两个软件框架在Linux桌面环境中被广泛使用，例如GNOME和KDE。
- en: In this chapter, we will be using Python binding of the Qt framework to implement
    the GUI because Python binding of Qt is easier to develop compared to other methods.
    We will look at how to develop a GUI from scratch and program it using Python.
    After discussing basic Python and Qt programming, we will discuss ROS interfaces
    of Qt and Python, which are already available in ROS. We will first look at what
    the Qt UI framework is and how to install it on our PC.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Qt框架的Python绑定来实现GUI，因为与其它方法相比，Qt的Python绑定更容易开发。我们将探讨如何从头开始开发GUI并使用Python进行编程。在讨论基本的Python和Qt编程之后，我们将讨论Qt和Python的ROS接口，这些接口已经在ROS中可用。我们首先将了解Qt
    UI框架是什么以及如何在我们的PC上安装它。
- en: Installing Qt on Ubuntu 16.04 LTS
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Ubuntu 16.04 LTS上安装Qt
- en: 'Qt is a cross-platform application framework that is widely used to develop
    application software with a GUI interface as well as command line tools. Qt is
    available in almost all operating systems, such as Windows, macOS X, Android,
    and so on. The main programming language used for developing Qt applications is
    C++ but there are bindings available for languages such as Python, Ruby, Java,
    and so on. Let''s take a look at how to install Qt SDK on Ubuntu 16.04\. We will
    install Qt from the **Advance Packaging Tool** (**APT**) in Ubuntu. The APT already
    comes with Ubuntu installation. So, for installing Qt/Qt SDK, we can simply use
    the following command, which will install Qt SDK and its required dependencies
    from the Ubuntu package repository. We can install Qt version 4 using the following
    command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Qt是一个跨平台的应用程序框架，广泛用于开发具有GUI界面的应用程序软件以及命令行工具。Qt几乎在所有操作系统上都有可用，例如Windows、macOS
    X、Android等。用于开发Qt应用程序的主要编程语言是C++，但还有为Python、Ruby、Java等语言提供的绑定。让我们看看如何在Ubuntu 16.04上安装Qt
    SDK。我们将从Ubuntu的**高级包装工具**（**APT**）中安装Qt。APT已经包含在Ubuntu安装中。因此，为了安装Qt/Qt SDK，我们可以简单地使用以下命令，该命令将从Ubuntu软件仓库安装Qt
    SDK及其所需依赖项。我们可以使用以下命令安装Qt版本4：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command will install the entire Qt SDK and its libraries required for
    our project. The packages available on Ubuntu repositories may not be the latest
    versions. To get the latest version of Qt, we can download the online or offline
    installer of Qt for various OS platforms from the following link:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将安装整个 Qt SDK 及其项目所需的库。Ubuntu 仓库中提供的软件包可能不是最新版本。要获取 Qt 的最新版本，我们可以从以下链接下载适用于各种操作系统平台的
    Qt 在线或离线安装程序：
- en: '[http://qt-project.org/downloads](http://qt-project.org/downloads)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://qt-project.org/downloads](http://qt-project.org/downloads)'
- en: After installing Qt on our system, we will see how we can develop GUI using
    Qt and interface with Python.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的系统上安装 Qt 后，我们将了解如何使用 Qt 开发 GUI 并与 Python 进行接口。
- en: Working with Python bindings of Qt
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 的 Qt 绑定
- en: 'Let''s see how we can interface Python and Qt. In general, there are two modules
    available in Python for connecting to the Qt user interface. The two most popular
    frameworks are:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将 Python 和 Qt 进行接口。一般来说，Python 中有用于连接 Qt 用户界面的两个模块。两个最受欢迎的框架是：
- en: PyQt
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyQt
- en: PySide
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PySide
- en: PyQt
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyQt
- en: '**PyQt** is one of the most popular Python bindings for Qt cross-platform.
    PyQt is developed and maintained by Riverbank Computing Limited. It provides binding
    for Qt version 4 and Qt version 5 and comes with GPL (version 2 or 3) along with
    a commercial license. PyQt is available for Qt version 4 and 5, called PyQt4 and
    PyQt5, respectively. These two modules are compatible with Python versions 2 and
    3\. PyQt contains more than 620 classes that cover the user interface, XML, network
    communication, web, and so on.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyQt** 是最流行的 Qt 跨平台 Python 绑定之一。PyQt 由 Riverbank Computing Limited 开发和维护，为
    Qt 版本 4 和 Qt 版本 5 提供绑定，并附带 GPL（版本 2 或 3）和商业许可证。PyQt 可用于 Qt 版本 4 和 5，分别称为 PyQt4
    和 PyQt5。这两个模块与 Python 2 和 3 兼容。PyQt 包含 620 多个类，涵盖了用户界面、XML、网络通信、Web 等方面。'
- en: 'PyQt is available in Windows, Linux, and macOS X. It is a prerequisite to install
    Qt SDK and Python in order to install PyQt. The binaries for Windows and macOS
    X are available at the following link:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: PyQt 可用于 Windows、Linux 和 macOS X。安装 PyQt 的先决条件是安装 Qt SDK 和 Python。Windows 和
    macOS X 的二进制文件可在以下链接找到：
- en: '[http://www.riverbankcomputing.com/software/pyqt/download](http://www.riverbankcomputing.com/software/pyqt/download)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.riverbankcomputing.com/software/pyqt/download](http://www.riverbankcomputing.com/software/pyqt/download)'
- en: We will see how to install PyQt4 on Ubuntu 16.04 using Python 2.7.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解如何在 Ubuntu 16.04 上使用 Python 2.7 安装 PyQt4。
- en: Installing PyQt in Ubuntu 16.04 LTS
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Ubuntu 16.04 LTS 上安装 PyQt
- en: 'If you want to install PyQt on Ubuntu/Linux, use the following command. This
    command will install the PyQt library, its dependencies, and some Qt tools:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 Ubuntu/Linux 上安装 PyQt，请使用以下命令。此命令将安装 PyQt 库、其依赖项以及一些 Qt 工具：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: PySide
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PySide
- en: '**PySide** is an open source software project that provides Python binding
    for the Qt framework. The PySide project was initiated by Nokia and offers a full
    set of Qt binding for multiple platforms. The technique used in PySide to wrap
    the Qt library is different from PyQt, but the API of both is similar. PySide
    is currently not supported on Qt 5\. PySide is available for Windows, Linux, and
    macOS X. The following link will guide you to set up PySide on Windows and macOS
    X:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**PySide** 是一个开源软件项目，为 Qt 框架提供 Python 绑定。PySide 项目由诺基亚发起，为多个平台提供完整的 Qt 绑定。PySide
    用于包装 Qt 库的技术与 PyQt 不同，但两者的 API 相似。PySide 目前不支持 Qt 5。PySide 可用于 Windows、Linux 和
    macOS X。以下链接将指导您在 Windows 和 macOS X 上设置 PySide：'
- en: '[http://qt-project.org/wiki/Category:LanguageBindings::PySide::Downloads](http://qt-project.org/wiki/Category:LanguageBindings::PySide::Downloads)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://qt-project.org/wiki/Category:LanguageBindings::PySide::Downloads](http://qt-project.org/wiki/Category:LanguageBindings::PySide::Downloads)'
- en: The prerequisites of PySide are the same as PyQt. Let's see how we can install
    PySide on Ubuntu 16.04 LTS.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: PySide 的先决条件与 PyQt 相同。让我们看看如何在 Ubuntu 16.04 LTS 上安装 PySide。
- en: Installing PySide on Ubuntu 16.04 LTS
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Ubuntu 16.04 LTS 上安装 PySide
- en: 'The PySide package is available on the Ubuntu package repository. The following
    command will install the PySide module and Qt tools on Ubuntu:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: PySide 软件包可在 Ubuntu 软件仓库中找到。以下命令将在 Ubuntu 上安装 PySide 模块和 Qt 工具：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's work with both modules and see the differences between both.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们同时使用这两个模块，并看看它们之间的区别。
- en: Working with PyQt and PySide
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PyQt 和 PySide
- en: After installing the PyQt and PySide packages, we will look at how to write
    an Hello World GUI using PyQt and PySide. The main difference between PyQt and
    PySide is only in some commands; most of the steps are the same. Let's see how
    to make a Qt GUI and convert it into Python code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 PyQt 和 PySide 包之后，我们将探讨如何使用 PyQt 和 PySide 编写 Hello World GUI。PyQt 和 PySide
    之间的主要区别仅在于一些命令；大多数步骤都是相同的。让我们看看如何创建 Qt GUI 并将其转换为 Python 代码。
- en: Introducing Qt Designer
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Qt Designer
- en: Qt Designer is the tool for designing and inserting control into the Qt GUI.
    The Qt GUI is basically an XML file that contains the information of its components
    and controls. The first step to work with the GUI relates to its design. The Qt
    Designer tool provides various options to make excellent GUIs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Designer 是用于设计和向 Qt GUI 插入控件的工具。Qt GUI 基本上是一个包含其组件和控制信息 XML 文件。与 GUI 一起工作的第一步与其设计相关。Qt
    Designer 工具提供了各种选项来制作出色的 GUI。
- en: 'Start Qt Designer by entering the `designer-qt4` command on the Terminal. The
    following screenshot shows what you will be able to see after running this command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在终端中输入 `designer-qt4` 命令来启动 Qt Designer。以下截图显示了运行此命令后您将能看到的内容：
- en: '![](img/79d339d8-e7cf-4e57-8570-7632032b932b.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79d339d8-e7cf-4e57-8570-7632032b932b.png)'
- en: Qt 4 Designer
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 4 Designer
- en: 'The preceding screenshot shows the Qt Designer interface. Select the Widget
    option from the New Form window and click on the Create button. This will create
    an empty widget; we can drag various GUI controls from the left-hand side of Qt
    4 Designer to the empty widget. Qt widgets are the basic building blocks of the
    Qt GUI. The following screenshot shows a form with a PushButton dragged from the
    left-hand side window of Qt Designer:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了 Qt Designer 界面。从新建表单窗口中选择 Widget 选项，然后点击创建按钮。这将创建一个空白的控件；我们可以从 Qt 4
    Designer 的左侧拖动各种 GUI 控件到空白控件中。Qt 控件是 Qt GUI 的基本构建块。以下截图显示了从 Qt Designer 左侧窗口拖动
    PushButton 的表单：
- en: '![](img/4c5fde11-b827-46ef-9b6f-9a4b73be38d8.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c5fde11-b827-46ef-9b6f-9a4b73be38d8.png)'
- en: Qt Designer widget form
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Designer 控件表单
- en: The Hello World application that we are going to build will have a PushButton.
    When we click on the PushButton, an Hello World message will be printed on the
    Terminal. Before building the Hello World application, we need to understand what
    Qt signals and slots are, because we have to use these features for building the
    Hello World application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的 Hello World 应用程序将包含一个 PushButton。当我们点击 PushButton 时，将在终端上打印出 Hello World
    消息。在构建 Hello World 应用程序之前，我们需要了解 Qt 信号和槽是什么，因为我们必须使用这些功能来构建 Hello World 应用程序。
- en: Qt signals and slots
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt 信号和槽
- en: In Qt, GUI events are handled using the signals and slots features. A signal
    is emitted from the GUI when an event occurs. Qt widgets have many predefined
    signals, and users can add custom signals for GUI events. A slot is a function
    that is called in response to a particular signal. In this example, we are using
    the `clicked()` signal of PushButton and creating a custom slot for this signal.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 中，使用信号和槽功能处理 GUI 事件。当发生事件时，GUI 会发出信号。Qt 控件有许多预定义的信号，用户可以为 GUI 事件添加自定义信号。槽是响应特定信号而调用的函数。在这个例子中，我们使用
    PushButton 的 `clicked()` 信号，并为该信号创建一个自定义槽。
- en: 'We can write our own code inside this custom function. Let''s see how we can
    create a button, connect a signal to a slot, and convert the entire GUI to Python.
    Here are the steps involved in creating the Hello World GUI application:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这个自定义函数内部编写自己的代码。让我们看看我们如何创建一个按钮，将一个信号连接到一个槽，并将整个 GUI 转换为 Python。以下是创建
    Hello World GUI 应用程序所涉及的步骤：
- en: Drag and create a PushButton from Qt Designer to the empty Form.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Qt Designer 拖动并创建一个 PushButton 到空白的表单中。
- en: Assign a slot for the button clicked event, which emits a signal called `clicked()`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮点击事件分配一个槽，该事件发出一个名为 `clicked()` 的信号。
- en: Save the designed UI file in the `.ui` extension.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将设计的 UI 文件保存为 `.ui` 扩展名。
- en: Convert UI files to Python.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 UI 文件转换为 Python。
- en: Write the definition of the custom slot.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写自定义槽的定义。
- en: Print the Hello World message inside the defined slot/function.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义的槽/函数内打印 Hello World 消息。
- en: 'We have already dragged a button from Qt Designer to an empty Form. Press the
    F4 key to insert a slot on the button. When we press F4, the PushButton turns
    red, and we can drag a line from the button and place the ground symbol in the
    main window. This is shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从 Qt Designer 拖动了一个按钮到一个空白的表单中。按 F4 键在按钮上插入一个槽。当我们按 F4 时，PushButton 变成红色，我们可以从按钮拖动一条线并将其放置在主窗口的地面符号上。这如图所示：
- en: '![](img/ea1eb77a-605e-4063-a50d-ac83c58213bb.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea1eb77a-605e-4063-a50d-ac83c58213bb.png)'
- en: Assigning slots and signals in Qt 4 Designer
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 4 Designer 中分配槽和信号
- en: 'Select the clicked() signal from the left-hand side and click on the Edit...
    button to create a new custom slot. When we click on the Edit... button, another
    window will pop up to create a custom function. You can create a custom function
    by clicking on the + symbol. We created a custom slot called message(), as shown
    in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从左侧选择 clicked() 信号，然后点击 Edit... 按钮创建一个新的自定义槽。当我们点击 Edit... 按钮时，将弹出一个窗口以创建自定义函数。您可以通过点击
    + 符号创建自定义函数。我们创建了一个名为 message() 的自定义槽，如下面的截图所示：
- en: '![](img/ae0a6675-d42b-413b-8a7c-f7c3a82622ba.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae0a6675-d42b-413b-8a7c-f7c3a82622ba.png)'
- en: Assigning slots and signals in Qt 4 Designer
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 4 Designer 中分配槽和信号
- en: Click on the OK button, save the UI file as `hello_world.ui`, and quit Qt Designer.
    After saving the UI file, let's see how we can convert a Qt UI file into a Python
    file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 OK 按钮，将 UI 文件保存为 `hello_world.ui`，并退出 Qt Designer。在保存 UI 文件后，让我们看看如何将 Qt
    UI 文件转换为 Python 文件。
- en: Read more about Qt Signals and slots from the following link
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下链接了解更多关于 Qt 信号和槽的信息
- en: https://doc.qt.io/qt-5/signalsandslots.html
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[Qt 5 文档 - 信号和槽](https://doc.qt.io/qt-5/signalsandslots.html)'
- en: Converting a UI file into Python code
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 UI 文件转换为 Python 代码
- en: After designing the UI file, we can convert the UI file into its equivalent
    Python code. The conversion is done using a `pyuic` compiler. We have already
    installed this tool while installing PyQt/PySide. The following are the commands
    to convert a Qt UI file into a Python file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计 UI 文件后，我们可以将其转换为等价的 Python 代码。转换使用 `pyuic` 编译器完成。我们在安装 PyQt/PySide 时已经安装了此工具。以下是将
    Qt UI 文件转换为 Python 文件的命令：
- en: 'We have to use different commands for PyQt and PySide. The following command
    is to convert the UI into its PyQt equivalent file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为 PyQt 和 PySide 使用不同的命令。以下命令是将 UI 转换为其 PyQt 等价文件的命令：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `pyuic4` is a UI compiler to convert a UI file into its equivalent Python
    code. We need to mention the UI filename after the `-x` argument and mention the
    output filename after the `-o` argument.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyuic4` 是一个 UI 编译器，用于将 UI 文件转换为等价的 Python 代码。我们需要在 `-x` 参数后指定 UI 文件名，并在 `-o`
    参数后指定输出文件名。'
- en: 'There are not many changes to the PySide command. Instead of `pyuic4`, PySide
    uses `pyside-uic` to convert UI files into Python files. The remaining arguments
    are the same:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: PySide 命令的更改并不多。不再是 `pyuic4`，PySide 使用 `pyside-uic` 将 UI 文件转换为 Python 文件。其余的参数保持不变：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding command will generate an equivalent Python code for the UI file.
    This will create a Python class that has the GUI components. The generated script
    will not have the definition of the custom function `message()`. We should add
    this custom function to generate the code. The following procedure will guide
    you to add the custom function; so when you click on the button, the custom function
    `message()` will be executed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将为 UI 文件生成等价的 Python 代码。这将创建一个包含 GUI 组件的 Python 类。生成的脚本将不会包含自定义函数 `message()`
    的定义。我们应该添加此自定义函数以生成代码。以下步骤将指导您添加自定义函数；因此，当您点击按钮时，自定义函数 `message()` 将被执行。
- en: Adding a slot definition to PyQt code
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 PyQt 代码中添加槽定义
- en: 'The generated Python code from PyQt is given here. The code generated by `pyuic4`
    and `pyside-uic` are the same, except in importing module names. All other parts
    are the same. The explanation of the code generated using PyQt is also applicable
    to PySide code. The code generated from the preceding conversion is as follows.
    The code structure and parameters can change according to the UI file that you
    have designed:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出了 PyQt 生成的 Python 代码。`pyuic4` 和 `pyside-uic` 生成的代码相同，只是在导入模块名称时有所不同。其他部分都相同。使用
    PyQt 生成的代码的解释也适用于 PySide 代码。以下是从前面的转换生成的代码。代码结构和参数可以根据您设计的 UI 文件进行更改：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code is the equivalent Python script of the Qt UI file that we
    designed in the Qt Designer application. Here is the step-by-step procedure of
    the working of this code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是我们使用 Qt Designer 应用程序设计的 Qt UI 文件的等价 Python 脚本。以下是此代码的工作步骤：
- en: The code will start executing from `if __name__ == "__main__":`. The first thing
    in the PyQt code is to create a `QApplication` object. A `QApplication` class
    manages the GUI application's control flow and main settings. The `QApplication`
    class contains the main event loop, where all events from the Windows system and
    other sources are processed and dispatched. It also handles initialization and
    finalization of an application. The `QApplication` class is inside the `QtGui`
    module. This code creates an object of `QApplication` called `app`. We have to
    add the main code manually.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将从 `if __name__ == "__main__":` 开始执行。PyQt 代码中的第一件事是创建一个 `QApplication` 对象。`QApplication`
    类管理 GUI 应用程序的流程和主要设置。`QApplication` 类包含主事件循环，其中处理和分发来自 Windows 系统和其他来源的所有事件。它还处理应用程序的初始化和终止。`QApplication`
    类位于 `QtGui` 模块中。此代码创建了一个名为 `app` 的 `QApplication` 对象。我们必须手动添加主要代码。
- en: The `Form = QtGui.QWidget()` line creates an object called `Form` of the `QWidget`
    class that is present inside the `QtGui` module. The `QWidget` class is the base
    class of all user interface objects of Qt. It can receive the mouse and keyboard
    event from the main Windows system.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Form = QtGui.QWidget()` 这一行创建了一个名为 `Form` 的 `QWidget` 类对象，该对象位于 `QtGui` 模块中。`QWidget`
    类是 Qt 所有用户界面对象的基类。它可以接收来自主 Windows 系统的鼠标和键盘事件。'
- en: 'The `ui = Ui_Form()` line creates an object called `ui` of the `Ui_Form()`
    class defined in the code. The `Ui_Form()` object can accept the `QWidget` class
    that we created in the previous line and it can add buttons, text, button control,
    and other UI components into this `QWidget` object. The `Ui_Form()` class contains
    two functions: `setupUi()` and `retranslateUi()`. We can pass the `QWidget` object
    to the function called `setupUi()`. This function will add UI components on this
    widget object, such as buttons, assigning slots for signals, and so on. The `retranslateUi()`
    function will translate the language of the UI to other languages if needed. For
    example, if we need translation from English to Spanish, we can mention the corresponding
    Spanish word in this function.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ui = Ui_Form()` 这一行创建了一个名为 `ui` 的 `Ui_Form()` 类对象，该对象在代码中定义。`Ui_Form()` 对象可以接受我们在上一行创建的
    `QWidget` 类，并且可以将按钮、文本、按钮控制和其他 UI 组件添加到这个 `QWidget` 对象中。`Ui_Form()` 类包含两个函数：`setupUi()`
    和 `retranslateUi()`。我们可以将 `QWidget` 对象传递给名为 `setupUi()` 的函数。此函数将在该小部件对象上添加 UI
    组件，例如按钮，为信号分配槽，等等。`retranslateUi()` 函数将在需要时将 UI 语言翻译成其他语言。例如，如果我们需要从英语翻译成西班牙语，我们可以在该函数中提及相应的西班牙语单词。'
- en: The `Form.show()` line displays the final window with buttons and text.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Form.show()` 这一行显示带有按钮和文本的最终窗口。'
- en: The next thing is to create the slot function, which prints the Hello World
    message. The slot definition is created inside the `Ui_Form()` class. The following
    steps insert the slot called `message()` into the `Ui_Form()` class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是创建槽函数，该函数将打印“Hello World”消息。槽定义在 `Ui_Form()` 类内部创建。以下步骤将名为 `message()` 的槽插入到
    `Ui_Form()` 类中。
- en: 'The `message()` function definition is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`message()` 函数的定义如下：'
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This should be inserted as a function inside the `Ui_Form()` class. Also, change
    the following line in the `setupUi()` function inside the `Ui_Form()` class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该作为函数插入到 `Ui_Form()` 类中。还要更改 `Ui_Form()` 类中的 `setupUi()` 函数中的以下行：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Form.message` parameter should be replaced with the `self.message` parameter.
    The preceding line connects the PushBbutton signal, `clicked(),` to the `self.message()`
    slot that we already inserted in the `Ui_Form()` class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 应将 `Form.message` 参数替换为 `self.message` 参数。前面的行将 PushButton 的信号 `clicked()` 连接到我们已经在
    `Ui_Form()` 类中插入的 `self.message()` 插槽。
- en: Operation of the Hello World GUI application
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World GUI 应用程序的运行操作
- en: 'After replacing the `Form.message` parameter with the `self.message` parameter,
    we can execute the code and the output will look like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 `Form.message` 参数替换为 `self.message` 参数后，我们可以执行代码，输出将如下所示：
- en: '![](img/b2c93c15-f076-430b-b5f3-308ab5a216bb.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2c93c15-f076-430b-b5f3-308ab5a216bb.png)'
- en: Running Pyqt4 application
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Pyqt4 应用程序
- en: When we click on the Press the button, it will print the Hello world message.
    This is all about setting a custom GUI with Python and Qt.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击“按下按钮”时，它将打印“Hello world”消息。这就是使用 Python 和 Qt 设置自定义 GUI 的全部内容。
- en: In the next section, we will see the actual GUI that we are designing for the
    robot.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到为机器人设计的实际 GUI。
- en: Working with ChefBot's control GUI
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 ChefBot 的控制 GUI 一起工作
- en: 'After completing the Hello World application in PyQt, we will now discuss a
    GUI for controlling ChefBot. The main use of building a GUI is to create an easier
    way to control the robot. For example, if the robot is deployed in a hotel to
    serve food, the person who controls this robot need not have knowledge about the
    complex commands to start and stop this robot; so, building a GUI for ChefBot
    can reduce the complexity and make it easier for the user. We are planning to
    build a GUI using PyQt, ROS, and the Python interface. The ChefBot ROS package
    is available on GitHub at the following link: [https://github.com/qboticslabs/learning_robotics_2nd_ed](https://github.com/qboticslabs/learning_robotics_2nd_ed)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PyQt 中完成 Hello World 应用程序后，我们现在将讨论用于控制 ChefBot 的图形用户界面。构建 GUI 的主要目的是创建一种更简单的方式来控制机器人。例如，如果机器人在酒店部署以提供食物，控制这个机器人的那个人不需要了解启动和停止这个机器人的复杂命令；因此，为
    ChefBot 建立GUI可以减少复杂性并使它对用户来说更容易。我们计划使用 PyQt、ROS 和 Python 接口来构建 GUI。ChefBot ROS
    包可在以下链接的 GitHub 上找到：[https://github.com/qboticslabs/learning_robotics_2nd_ed](https://github.com/qboticslabs/learning_robotics_2nd_ed)
- en: 'If you haven''t cloned the code yet, you can do so now using following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有克隆代码，现在可以使用以下命令进行克隆：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The GUI code named `robot_gui.py` is placed in the `scripts` folder, which is
    inside the `chefbot_bringup` package.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 `robot_gui.py` 的 GUI 代码位于 `scripts` 文件夹中，该文件夹位于 `chefbot_bringup` 包内。
- en: 'The following screenshot shows the GUI that we have designed for ChefBot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了为 ChefBot 设计的 GUI：
- en: '![](img/a5ce585c-4d5b-424b-b6d9-45e81d1bd871.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5ce585c-4d5b-424b-b6d9-45e81d1bd871.png)'
- en: Running Pyqt4 application
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Pyqt4 应用程序
- en: 'The GUI has the following features:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 具有以下功能：
- en: It can monitor the robot battery status and robot status. The robot status indicates
    the working status of the robot. For example, if the robot encounters an error,
    it will indicate the error on this GUI.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以监控机器人电池状态和机器人状态。机器人状态指示机器人的工作状态。例如，如果机器人遇到错误，它将在该 GUI 上指示错误。
- en: 'It can command the robot to move into a table position for delivering food.
    There is a spin box widget on the GUI to input the table position. Currently,
    we are planning this GUI for a room with nine tables, but we may expand it to
    any number according to the requirement. After inputting the table number, we
    can command the robot to go to that table by clicking on the Go button; the robot
    will get into that position. If we want to return the robot to the initial position,
    we can click on the Home button. If we want to cancel the current robot movement,
    click on Cancel to stop the robot. The working of this GUI application is as follows:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以命令机器人移动到餐桌位置以提供食物。GUI 上有一个用于输入餐桌位置的旋转框小部件。目前，我们正在为九张餐桌的房间设计这个 GUI，但我们可能根据需求将其扩展到任何数量。输入餐桌号码后，我们可以通过点击“Go”按钮来命令机器人前往该餐桌；机器人将进入该位置。如果我们想将机器人返回到初始位置，我们可以点击“Home”按钮。如果我们想取消当前的机器人移动，点击“Cancel”以停止机器人。此
    GUI 应用程序的工作原理如下：
- en: When we have to deploy ChefBot in a hotel, the first procedure that we have
    to do is to create a map of the room. After mapping the entire room properly,
    we have to save the map on the robot PC. The robot does the mapping only once.
    After mapping, we can run the localization and navigation routines and command
    the robot to get into a position on the map. The ChefBot ROS package comes with
    a map and simulation model of a hotel-like environment. We can now run this simulation
    and localization for testing the GUI and in the next chapter, we will discuss
    how to control the hardware using the GUI. If you install the ChefBot ROS packages
    on your local system, we can simulate a hotel environment and test the GUI.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们必须在酒店部署 ChefBot 时，我们必须做的第一个程序是创建房间的地图。在正确映射整个房间后，我们必须在机器人 PC 上保存地图。机器人只进行一次映射。映射后，我们可以运行定位和导航例程，并命令机器人进入地图上的一个位置。ChefBot
    ROS 包附带了一个类似酒店的环境的地图和模拟模型。我们现在可以运行这个模拟和定位来测试 GUI，在下一章中，我们将讨论如何使用 GUI 控制硬件。如果您在本地系统上安装了
    ChefBot ROS 包，我们可以模拟一个酒店环境并测试 GUI。
- en: 'Start the ChefBot simulation in a hotel-like arrangement using the following
    command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在类似酒店的安排中启动 ChefBot 模拟：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After starting the ChefBot simulation, we can run the localization and navigation
    routines using an already built map. The map is placed in the `chefbot_bringup`
    package. We can see a `map` folder inside this package. Here, we will use this
    map for performing this test. We can load the localization and navigation routine
    using the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动ChefBot模拟后，我们可以使用已构建的地图运行定位和导航例程。该地图位于`chefbot_bringup`包中。在这个包中，我们可以看到一个`map`文件夹。在这里，我们将使用这个地图进行这项测试。我们可以使用以下命令加载定位和导航例程：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The path of the map file can change in different systems, so use the path in
    your system instead of this path.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 地图文件的路径在不同的系统中可能会变化，所以请使用你系统中的路径而不是这个路径。
- en: 'If the path mentioned is correct, it will start running the ROS navigation
    stack. If we want to see the robot position on the map or manually set the initial
    position of the robot, we can use RViz using the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提到的路径是正确的，它将开始运行ROS导航堆栈。如果我们想查看机器人在地图上的位置或手动设置机器人的初始位置，我们可以使用以下命令的RViz：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In RViz, we can command the robot to go to any map coordinates using the 2D
    Nav Goal button.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在RViz中，我们可以使用2D导航目标按钮命令机器人前往任何地图坐标。
- en: We can command the robot to go to any map coordinates using programming too.
    The ROS navigation stack works using the ROS `actionlib` library. The ROS `actionlib`
    library is for performing preemptable tasks; it is similar to ROS services. An
    advantage over ROS services is that we can cancel the request if we don't want
    it at that time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过编程命令机器人前往任何地图坐标。ROS导航堆栈使用ROS `actionlib`库工作。ROS `actionlib`库用于执行可中断的任务；它与ROS服务类似。与ROS服务相比的一个优点是，如果我们不想在那时执行它，我们可以取消请求。
- en: In the GUI, we can command the robot to go to a map coordinate using the Python
    `actionlib` library. We can get the table position on the map using the following
    technique.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI中，我们可以使用Python `actionlib`库命令机器人前往地图坐标。我们可以使用以下技术获取地图上的餐桌位置。
- en: 'After starting the simulator and AMCL nodes, launch the keyboard teleoperation
    and move the robot near each table. Use the following command to get the translation
    and rotation of the robot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动模拟器和AMCL节点后，启动键盘遥控并移动机器人靠近每个餐桌。使用以下命令获取机器人的平移和旋转：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we click on the Go button, the position is fed to the navigation stack
    and the robot plans its path and reaches its goal. We can even cancel the task
    at any time. So, the ChefBot GUI acts as an `actionlib` client, which sends map
    coordinates to the `actionlib` server; that is, the navigation stack.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击“Go”按钮时，位置信息会被发送到导航堆栈，机器人规划其路径并达到目标位置。我们甚至可以在任何时候取消任务。因此，ChefBot GUI充当一个`actionlib`客户端，它将地图坐标发送到`actionlib`服务器；即导航堆栈。
- en: 'We can now run the robot GUI to control the robot using the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下命令运行机器人GUI来控制机器人：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can select a table number and click on the Go button for moving the robot
    to each table.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择一个餐桌编号并点击“Go”按钮，将机器人移动到每个餐桌。
- en: Assuming that you cloned the files and got the `robot_gui.py` file, we will
    discuss the main slots we added into the `Ui_Form()` class for the `actionlib`
    client and to get values of the battery and robot status.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经克隆了文件并获取了`robot_gui.py`文件，我们将讨论我们添加到`Ui_Form()`类中的主要插槽，用于`actionlib`客户端以及获取电池和机器人状态值。
- en: 'We need to import the following Python modules for this GUI application:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入以下Python模块来运行这个GUI应用程序：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The additional modules we require are the ROS Python client `rospy`, and the
    `actionlib` module to send values to the navigation stack. The `move_base_msgs`
    module contains the message definition of the goal that needs to be sent to the
    navigation stack.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的附加模块是ROS Python客户端`rospy`和用于向导航堆栈发送值的`actionlib`模块。`move_base_msgs`模块包含需要发送到导航堆栈的目标的消息定义。
- en: 'The robot position near each table is mentioned in a Python dictionary. The
    following code shows hardcode values of the robot''s position near each table:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个餐桌附近的机器人位置以Python字典的形式提及。以下代码显示了每个餐桌附近机器人的硬编码位置值：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can access the position of the robot near each table by accessing this dictionary.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问这个字典来获取机器人靠近每个餐桌的位置。
- en: Currently, we have inserted only four values for the purpose of demonstration.
    You can add more values by finding the position of other tables.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们仅为了演示目的插入了四个值。你可以通过找到其他餐桌的位置来添加更多值。
- en: 'We are assigning some variables to handle the table number, position of the
    robot, and the `actionlib` client inside the `Ui_Form()` class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Ui_Form()`类中分配了一些变量来处理表格号、机器人的位置和`actionlib`客户端：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following code shows the signals and slots assignment in this code for
    buttons and spin box widgets:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了此代码中按钮和旋转框小部件的信号和槽分配：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following slot handles the spin box value from the UI and assigns a table
    number. Also, it converts the table number to the corresponding robot position:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下槽处理来自UI的旋转框值并分配一个表格号。它还将表格号转换为相应的机器人位置：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the definition of the Go slot for the Go button. This function will
    insert the robot position of the selected table in a goal message header and send
    it into the navigation stack:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Go按钮的Go槽的定义。此函数将所选表格的机器人位置插入到目标消息头中，并将其发送到导航堆栈：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following code is the `Cancel()` slot definition. This will cancel all
    the robot paths that it was planning to perform at that time:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`Cancel()`槽的定义。这将取消当时计划执行的机器人路径：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following code is the definition of `Home()`. This will set the table position
    to zero, and call the `Go()` function. The table at position zero is the home
    position of the robot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`Home()`的定义。这将表格位置设置为零，并调用`Go()`函数。位置为零的表格是机器人的家位置：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following definitions are for the `update_values()` and `add()` functions.
    The `update_values()` method will start updating the battery level and robot status
    in a thread. The `add()` function will retrieve the ROS parameters of the battery
    status and robot status, and set them to the progress bar and label, respectively:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义是`update_values()`和`add()`函数的定义。`update_values()`方法将在线程中开始更新电池级别和机器人状态。`add()`函数将检索电池状态和机器人状态的ROS参数，并将它们分别设置到进度条和标签中：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `WorkThread()` class used in the preceding function is given here. The
    `WorkThread()` class is inherited from `QThread` provided by Qt for threading.
    The thread simply emits the signal `update(Qstring)` with a particular delay.
    In the preceding function, `update_values()`, the `update(QString)` signal is
    connected to the `self.add()` slot; so when a signal `update(QString)` is emitted
    from the thread, it will call the `add()` slot and update the battery and status
    value:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中使用的`WorkThread()`类在此给出。`WorkThread()`类是从Qt提供的`QThread`继承而来的线程。线程简单地以特定的延迟发出`update(Qstring)`信号。在前面的`update_values()`函数中，`update(QString)`信号连接到`self.add()`槽；因此，当线程从发出`update(QString)`信号时，它将调用`add()`槽并更新电池和状态值：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have discussed how to make a GUI for ChefBot, but this GUI is only for the
    user who controls ChefBot. If someone wants to debug and inspect the robot data,
    we may have to go for other tools. ROS provides an excellent debugging tool to
    visualize data from the robot.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何为ChefBot制作GUI，但这个GUI仅适用于控制ChefBot的用户。如果有人想要调试和检查机器人数据，我们可能需要使用其他工具。ROS提供了一个优秀的调试工具，可以可视化来自机器人的数据。
- en: The rqt tool is a popular ROS tool. It is based on a Qt-based framework for
    GUI development for ROS. Let's discuss the rqt tool, installation procedure, and
    how we can inspect the sensor data from the robot.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: rqt工具是ROS中流行的工具。它基于Qt框架进行GUI开发的ROS。让我们讨论rqt工具、安装过程以及如何检查来自机器人的传感器数据。
- en: Installing and working with rqt in Ubuntu 16.04 LTS
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Ubuntu 16.04 LTS中安装和使用rqt
- en: '**rqt** is a software framework in ROS, which implements various GUI tools
    in the form of plugins. We can add plugins as dockable windows in rqt.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**rqt**是ROS中的一个软件框架，它以插件的形式实现了各种GUI工具。我们可以在rqt中添加可停靠的插件窗口。'
- en: Installing rqt in Ubuntu 16.04 can be done using the following command. Before
    installing rqt, ensure that you have the full installation of ROS Indigo.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu 16.04中安装rqt可以使用以下命令。在安装rqt之前，请确保您已安装ROS Indigo的完整安装。
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After installing the rqt packages, we can access the GUI implementation of rqt,
    called `rqt_gui`, in which we can dock `rqt plugins` in a single window.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装rqt包之后，我们可以访问rqt的GUI实现，称为`rqt_gui`，在其中我们可以在单个窗口中停靠`rqt插件`。
- en: Let's start using `rqt_gui`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用`rqt_gui`开始。
- en: 'Run the `roscore` command before running `rqt_gui`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`rqt_gui`之前，请运行`roscore`命令：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the following command to start `rqt_gui`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以启动`rqt_gui`：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will get the following window if the commands work fine:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令运行正常，我们将得到以下窗口：
- en: '![](img/e961dbae-41f4-4d68-aabc-a1841a13c0ed.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e961dbae-41f4-4d68-aabc-a1841a13c0ed.png)'
- en: Running rqt
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行rqt
- en: We can load and unload plugins at runtime. To analyze the ROS message log, we
    can load the Console plugin from Plugins | Logging | Console. In the following
    example, we load the Console plugin and run a talker node inside `rospy_tutorials`,
    which will send an Hello World message to a topic called `/chatter`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在运行时加载和卸载插件。要分析ROS消息日志，我们可以从插件 | 记录 | 控制台加载控制台插件。在以下示例中，我们加载了控制台插件并在`rospy_tutorials`内部运行了一个talker节点，该节点将发送一个Hello
    World消息到名为`/chatter`的主题。
- en: 'Run the following command to start the node `talker.py`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以启动`talker.py`节点：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the following screenshot, `rqt_gui` is loaded with two plugins named Console
    and Topic Monitor. The Topic Monitor plugin can be loaded from Plugins | Topics
    | Topic Monitor. The Console plugin monitors the messages printing on each node
    and their severity. It is very useful for debugging purposes. In the following
    screenshot, the left section of `rqt_gui` is loaded with the Console plugin and
    the right side is loaded with the Topic Monitor. The Topic Monitor will list the
    topics available and will monitor its values.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，`rqt_gui`加载了两个名为控制台和主题监控器的插件。主题监控器插件可以从插件 | 主题 | 主题监控器加载。控制台插件监控每个节点上打印的消息及其严重程度。这对于调试非常有用。在下面的屏幕截图中，`rqt_gui`的左侧加载了控制台插件，右侧加载了主题监控器。主题监控器将列出可用的主题并监控其值。
- en: 'In the following screenshot, the Console plugin monitors the `talker.py` node''s
    messages and their severity level and the Topic Monitor monitors the value inside
    the `/chatter` topic:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，控制台插件监控着`talker.py`节点的消息及其严重程度，而主题监控器监控着`/chatter`主题内的值：
- en: '![](img/6fbb4413-7100-4866-8ed2-e38d1fe16381.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6fbb4413-7100-4866-8ed2-e38d1fe16381.png)'
- en: Running rqt with different plugins
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 运行带有不同插件的rqt
- en: We can also visualize data such as images and plot graphs on `rqt_gui`. For
    the robot's navigation and its inspection, there are plugins for embedding RViz
    on `rqt_gui`. The Navigation viewer plugin views from the `/map` topic. The visualization
    plugins are available in Plugin | Visualization.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`rqt_gui`上可视化数据，如图像和绘图。对于机器人的导航和检查，`rqt_gui`上有嵌入RViz的插件。导航查看器插件从`/map`主题查看。可视化插件在插件
    | 可视化中可用。
- en: 'We can also create the GUI using rqt. The instructions to create rqt plugins
    that can load in to rqt_gui can be found at:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用rqt创建GUI。创建可以加载到rqt_gui中的rqt插件的说明可以在以下位置找到：
- en: '[http://wiki.ros.org/rqt/Tutorials/Create%20your%20new%20rqt%20plugin](http://wiki.ros.org/rqt/Tutorials/Create%20your%20new%20rqt%20plugin)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[创建您新的rqt插件](http://wiki.ros.org/rqt/Tutorials/Create%20your%20new%20rqt%20plugin)'
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed creating a GUI for ChefBot that can be used by
    an ordinary user who doesn't have any idea about the internal workings of a robot.
    We used Python binding of Qt called PyQt to create this GUI. Before we looked
    at the main GUI design, we looked at an Hello World application to get an easier
    understanding of PyQt. The UI design was done using the Qt Designer tool and the
    UI file was converted into its equivalent Python script using the Python UI compiler.
    After designing the main GUI in Qt Designer, we converted the UI file into Python
    script and inserted the necessary slots in the generated script. The ChefBot GUI
    can start the robot, select a table number, and command the robot to get into
    that position. The position of each table comes from the generated map where we
    hardcoded the positions in this Python script for testing. When a table is selected,
    we set a goal position on the map, and when we click on the Go button, the robot
    will move into the intended position. The user can cancel the operation at any
    time and command the robot to come to the home position. The GUI can also receive
    the real-time status of the robot and its battery status. After discussing the
    robot GUI, we looked at the debugging GUI tool in ROS, called rqt. We saw some
    plugins used for debugging the data from the robot. In the next chapter, we will
    see the complete testing and calibration of the robot.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了为 ChefBot 创建一个 GUI，这个 GUI 可以被一个对机器人内部工作原理一无所知的普通用户使用。我们使用了 Qt 的 Python
    绑定 PyQt 来创建这个 GUI。在我们查看主要的 GUI 设计之前，我们先看了一个 Hello World 应用程序，以便更容易地理解 PyQt。UI
    设计是使用 Qt Designer 工具完成的，UI 文件是通过 Python UI 编译器转换成其等价的 Python 脚本的。在 Qt Designer
    中设计完主要的 GUI 之后，我们将 UI 文件转换成 Python 脚本，并在生成的脚本中插入了必要的槽。ChefBot GUI 可以启动机器人，选择一个餐桌号，并命令机器人进入该位置。每个餐桌的位置来自生成的地图，我们在
    Python 脚本中硬编码了这些位置以进行测试。当选择一个餐桌时，我们在地图上设置一个目标位置，当我们点击“前往”按钮时，机器人将移动到预定位置。用户可以在任何时候取消操作并命令机器人回到初始位置。GUI
    还可以接收机器人的实时状态及其电池状态。在讨论了机器人 GUI 之后，我们看了 ROS 中的调试 GUI 工具 rqt。我们看到了一些用于调试机器人数据的插件。在下一章中，我们将看到机器人的完整测试和校准。
- en: Questions
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the popular UI toolkits available on the Linux platform?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux 平台上可用的流行 UI 工具包有哪些？
- en: What are the differences between PyQt and PySide Qt bindings?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyQt 和 PySide Qt 绑定之间有什么区别？
- en: How do you convert a Qt UI file into Python script?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何将 Qt UI 文件转换为 Python 脚本？
- en: What are Qt signals and slots?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Qt 信号和槽是什么？
- en: What is rqt and what are its main applications?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: rqt 是什么？它的主要应用是什么？
- en: Further reading
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Read more about robotic vision packages in ROS at the following links:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中了解更多关于 ROS 中机器人视觉包的信息：
- en: '[http://wiki.ros.org/rqt/UserGuide](http://wiki.ros.org/rqt/UserGuide)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://wiki.ros.org/rqt/UserGuide](http://wiki.ros.org/rqt/UserGuide)'
- en: '[http://wiki.ros.org/rqt/Tutorials](http://wiki.ros.org/rqt/Tutorials)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://wiki.ros.org/rqt/Tutorials](http://wiki.ros.org/rqt/Tutorials)'
