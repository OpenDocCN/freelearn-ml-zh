<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Hand Gesture Recognition Using a Kinect Depth Sensor</h1>
                </header>
            
            <article>
                
<p>The goal of this chapter is to develop an app that detects and tracks simple hand gestures in real time, using the output of a depth sensor, such as that of a <strong>Microsoft Kinect 3D sensor</strong> or an <strong>ASUS Xtion sensor</strong>.<strong> </strong>The app will analyze each captured frame to perform the following tasks:</p>
<ul>
<li><strong>Hand region segmentation</strong>: The user's hand region will be extracted in each frame by analyzing the <strong>depth map</strong> output of the Kinect sensor, which is done by <strong>thresholding</strong>, applying some <strong>morphological operations</strong>, and finding <strong>connected</strong> <strong>components</strong>.</li>
<li><strong>Hand shape analysis</strong>: The shape of the segmented hand region will be analyzed by determining <strong>contours</strong>, <strong>convex</strong> <strong>hull</strong>, and <strong>convexity defects</strong>.</li>
<li><strong>Hand gesture recognition</strong>: The number of extended fingers will be determined based on the hand contour's <strong>convexity defects</strong>, and the gesture will be classified accordingly (with no extended fingers corresponding to a fist, and five extended fingers corresponding to an open hand).</li>
</ul>
<p>Gesture recognition is an ever-popular topic in computer science. This is because it not only enables humans to communicate with machines (<strong>Human-Machine Interaction</strong> (<strong>HMI</strong>)) but also constitutes the first step for machines to begin understanding human body language. With affordable sensors such as Microsoft Kinect or Asus Xtion and open source software such as <strong>OpenKinect</strong> and <strong>OpenNI</strong>, it has never been easier to get started in the field yourself. <em>So, what shall we do with all this technology?</em></p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Planning the app</li>
<li>Setting up the app</li>
<li>Tracking hand gestures in real time</li>
<li>Understanding hand region segmentation</li>
<li>Performing hand shape analysis</li>
<li>Performing hand gesture recognition</li>
</ul>
<p>The beauty of the algorithm that we are going to implement in this chapter is that it works well for many hand gestures, yet it is simple enough to run in real time on a generic laptop. Also, if we want, we can easily extend it to incorporate more complicated hand-pose estimations.</p>
<p>Once you complete the app, you will understand how to use depth sensors in your own apps. You will learn how to compose shapes of interest with OpenCV from the depth information, as well as understanding how to analyze shapes with OpenCV, using their geometric properties.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article>
                
<p class="mce-root">This chapter requires you to have a Microsoft Kinect 3D sensor installed. Alternatively, you may install an Asus Xtion sensor or any other depth sensor for which OpenCV has built-in support.</p>
<p class="mce-root">First, install OpenKinect and <strong>libfreenect</strong> from <a href="http://www.openkinect.org/wiki/Getting_Started"><span class="URLPACKT">http://www.openkinect.org/wiki/Getting_Started</span></a>. <span>You can find the code that we present in this chapter at our GitHub repository: </span><a href="https://github.com/PacktPublishing/OpenCV-4-with-Python-Blueprints-Second-Edition/tree/master/chapter2">https://github.com/PacktPublishing/OpenCV-4-with-Python-Blueprints-Second-Edition/tree/master/chapter2</a><span>.</span></p>
<p class="mce-root"><span>Let's first plan the application we are going to create in this chapter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Planning the app</h1>
                </header>
            
            <article>
                
<p>The final app will consist of the following modules and scripts:</p>
<ul>
<li><kbd>gestures</kbd>: This is a module that consists of an algorithm for recognizing hand gestures.</li>
<li><kbd>gestures.process</kbd>: This is a function that implements the entire process flow of hand gesture recognition. It accepts a single-channel depth image (acquired from the Kinect depth sensor) and returns an annotated <strong>Blue, Green, Red</strong> (<strong>BGR</strong>) color image with an estimated number of extended fingers.</li>
<li><kbd>chapter2</kbd>: This is the main script for the chapter.</li>
<li><kbd>chapter2.main</kbd>: This is the main function routine that iterates over frames acquired from a depth sensor that uses <kbd>.process</kbd> gestures to process frames, and then illustrates results.</li>
</ul>
<p>The end product looks like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1bd8dec9-a571-476d-bb9c-b3fdef943e4e.png" style="width:48.42em;height:25.58em;"/></p>
<p>No matter how many fingers of a hand are extended, the algorithm correctly segments the hand region (white), draws the corresponding convex hull (the green line surrounding the hand), finds all convexity defects that belong to the spaces between fingers (large green points) while ignoring others (small red points), and infers the correct number of extended fingers (the number in the bottom-right corner), even for a fist.</p>
<p>Now, let's set up the application in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the app</h1>
                </header>
            
            <article>
                
<p>Before we can get down to the nitty-gritty of our gesture recognition algorithm, we need to make sure that we can access the depth sensor and display a stream of depth frames. In this section, we will cover the following things that will help us set up the app: </p>
<ul>
<li>Accessing the Kinect 3D sensor</li>
<li>Utilizing OpenNI-compatible sensors</li>
<li>Running the app and main function routine</li>
</ul>
<p>First, we will look at how to use the Kinect 3D sensor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing the Kinect 3D sensor</h1>
                </header>
            
            <article>
                
<p><span>The easiest way to access a Kinect sensor is by using an </span><kbd>OpenKinect</kbd><span> module called </span><kbd>freenect</kbd><span>. For installation instructions, take a look at the preceding section</span>.</p>
<p><span>The <kbd>freenect</kbd> module has functions such as</span><span> </span><kbd>sync_get_depth()</kbd><span> and </span><kbd>sync_get_video()</kbd>, used to obtain images synchronously from the depth sensor and camera sensor respectively. For this chapter, we will need only the Kinect depth map, which is a single-channel (grayscale) image in which each pixel value is the estimated distance from the camera to a particular surface in the visual scene.</p>
<p>Here, we will design a function that will read a frame from the sensor and convert it to the desired format, and return the frame together with a success status, as follows:</p>
<pre>def read_frame(): -&gt; Tuple[bool,np.ndarray]:</pre>
<p>The function consists of the following steps:</p>
<ol>
<li>Grab a <kbd>frame</kbd>; terminate the function if a frame was not acquired, like this:</li>
</ol>
<pre style="color: black;padding-left: 30px">    frame, timestamp = freenect.sync_get_depth() <br/>    if frame is None:<br/>        return False, None</pre>
<p style="color: black;padding-left: 60px">The <kbd>sync_get_depth</kbd> method returns both the depth map and a timestamp. By default, the map is in an 11-bit format. The last 10 bits of the sensor describes the depth, while the first bit states that the distance estimation was not successful when it's equal to 1.</p>
<ol start="2">
<li>It is a good idea to standardize the data into an 8-bit precision format, as an 11-bit format is inappropriate to be visualized with <kbd>cv2.imshow</kbd> right away, as well as in the future. We might want to use some different sensor that returns in a different format, as follows:</li>
</ol>
<pre style="color: black;padding-left: 60px">np.clip(depth, 0, 2**10-1, depth) 
depth &gt;&gt;= 2 </pre>
<p style="color: black;padding-left: 60px">In the previous code, we have first clipped the values to 1,023 (or <kbd>2**10-1</kbd>) to fit in 10 bits. Such clipping results in the assignment of the undetected distance to the farthest possible point. Next, we shift 2 bits to the right to fit the distance in 8 bits.</p>
<ol start="3">
<li>Finally, we convert the image into an 8-bit unsigned integer array and <kbd>return</kbd> the result, as follows:</li>
</ol>
<pre style="color: black;padding-left: 60px">return True, depth.astype(np.uint8) </pre>
<p style="padding-left: 60px">Now, the <kbd>depth</kbd> image can be visualized as follows:</p>
<pre style="padding-left: 60px">cv2.imshow("depth", read_frame()[1]) </pre>
<p class="mce-root">Let's see how to use OpenNI-compatible sensors in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utilizing OpenNI-compatible sensors</h1>
                </header>
            
            <article>
                
<p>To use an OpenNI-compatible sensor, you must first make sure that <strong>OpenNI2</strong> is installed and that your version of OpenCV was built with the support of OpenNI. The build information can be printed as follows:</p>
<pre>import cv2<br/>print(cv2.getBuildInformation())</pre>
<p>If your version was built with OpenNI support, you will find it under the <kbd>Video I/O</kbd> section. Otherwise, you will have to rebuild OpenCV with OpenNI support, which is done by passing the <kbd>-D WITH_OPENNI2=ON</kbd> flag to <kbd>cmake</kbd>.</p>
<p>After the installation process is complete, you can access the sensor similarly to other video input devices, using <kbd>cv2.VideoCapture</kbd>. In this app, in order to use an OpenNI-compatible sensor instead of a Kinect 3D sensor, you have to cover the following steps:</p>
<ol>
<li>Create a video capture that connects to your OpenNI-compatible sensor, like this:</li>
</ol>
<pre style="color: black;padding-left: 60px">device = cv2.cv.CV_CAP_OPENNI 
capture = cv2.VideoCapture(device) </pre>
<p style="color: black;padding-left: 60px">If you want to connect to Asus Xtion, the <kbd>device</kbd> variable should be assigned to the <kbd>cv2.CV_CAP_OPENNI_ASUS</kbd> value instead.</p>
<ol start="2">
<li>Change the input frame size to the standard <strong>Video Graphics Array</strong> (<strong>VGA</strong>) resolution, as follows:</li>
</ol>
<pre style="color: black;padding-left: 60px">capture.set(cv2.cv.CV_CAP_PROP_FRAME_WIDTH, 640) 
capture.set(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT, 480) </pre>
<ol start="3">
<li>In the previous section, we designed the <kbd>read_frame</kbd> function, which accesses the Kinect sensor using <kbd>freenect</kbd>. In order to read depth images from the video capture, you have to change that function to the following one:</li>
</ol>
<pre style="color: black;padding-left: 60px">def read_frame():<br/>    if not capture.grab():<br/>        return False,None<br/>    return capture.retrieve(cv2.CAP_OPENNI_DEPTH_MAP)</pre>
<p style="padding-left: 60px" class="mce-root"><span>You will note that we have used the</span><span> </span><kbd>grab</kbd><span> </span><span>and</span><span> </span><kbd>retrieve</kbd><span> </span><span>methods instead of the <kbd>read</kbd> method. The reason is that the <kbd>read</kbd> method of <kbd>cv2.VideoCapture</kbd> is inappropriate when we need to synchronize a set of cameras or a multi-head camera, such as a Kinect.</span></p>
<p style="padding-left: 60px" class="mce-root"><span>For such cases, you grab frames from multiple sensors at a certain moment in time with the <kbd>grab</kbd> method and then retrieve the data of the sensors of interest with the <kbd>retrieve</kbd> method. For example, in your own apps, you might also need to retrieve a BGR frame (standard camera frame), which can be done by passing <kbd>cv2.CAP_OPENNI_BGR_IMAGE</kbd> to the <kbd>retrieve</kbd> method.</span></p>
<p class="mce-root">So, now that you can read data from your sensor, let's see how to run the application in the next section.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the app and main function routine</h1>
                </header>
            
            <article>
                
<p>The <kbd>chapter2.py</kbd> script is responsible for running the app, and it first imports the following modules:</p>
<pre>import cv2<br/>import numpy as np<br/>from gestures import recognize<br/>from frame_reader import read_frame</pre>
<p>The <kbd>recognize</kbd> function is responsible for recognizing a hand gesture, and we will compose it later in this chapter. We have also placed the <kbd>read_frame</kbd> method that we composed in the previous section in a separate script, for convenience.</p>
<p>In order to simplify the<span> </span><span>segmentation task, we will instruct the user to place their hand in the center of the screen. </span><span>To provide a visual aid for this, we create the following function:</span></p>
<pre>def draw_helpers(img_draw: np.ndarray) -&gt; None:<br/>    # draw some helpers for correctly placing hand<br/>    height, width = img_draw.shape[:2]<br/>    color = (0,102,255)<br/>    cv2.circle(img_draw, (width // 2, height // 2), 3, color, 2)<br/>    cv2.rectangle(img_draw, (width // 3, height // 3),<br/>                  (width * 2 // 3, height * 2 // 3), color, 2)</pre>
<p>The function<span> draws a rectangl</span><span>e around the image center and highlights the center pixel of the image in orange.</span></p>
<p>All the heavy lifting is done by the <kbd>main</kbd> function, shown in the following code block:</p>
<pre>def main():<br/>    for _, frame in iter(read_frame, (False, None)):</pre>
<p>The function iterates over<span> grayscale frames from Kinect, </span>and, in each iteration, it covers the following steps:</p>
<ol>
<li>Recognize hand gestures using the <kbd>recognize</kbd> function, <span>which returns the estimated number of extended fingers (</span><kbd>num_fingers</kbd><span>) and an annotated BGR color image, as follows</span>:</li>
</ol>
<pre style="padding-left: 60px">num_fingers, img_draw = recognize(frame)</pre>
<ol start="2">
<li><span>Call the </span><kbd>draw_helpers</kbd><span> function on the annotated BGR image in order to provide a visual aid for hand placement, as follows:</span></li>
</ol>
<pre style="padding-left: 60px"> draw_helpers(img_draw)</pre>
<ol start="3">
<li><span>F</span>inally, the <kbd>main</kbd> fu<span>nction draws the number of fingers on the annotated <kbd>frame</kbd>, displays results with <kbd>cv2.imshow</kbd></span>, <span>and sets termination criteria, as follows:</span></li>
</ol>
<pre>        # print number of fingers on image<br/>        cv2.putText(img_draw, str(num_fingers), (30, 30),<br/>                    cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255))<br/>        cv2.imshow("frame", img_draw)<br/>        # Exit on escape<br/>        if cv2.waitKey(10) == 27:<br/>            break</pre>
<p>So, now that we have the main script, you will note that the only function that we are missing is the <kbd>recognize</kbd> function. In order to track hand gestures, we need to compose this function, <span>which we will do in the next section</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tracking hand gestures in real time</h1>
                </header>
            
            <article>
                
<p>Hand gestures are analyzed by the <kbd>recognize</kbd> function; this is where the real magic takes place. This function handles the entire process flow, from the raw grayscale image to a recognized hand gesture. It returns the number of fingers and the illustration frame. It implements the following procedure:</p>
<ol>
<li>It extracts the user's hand region by analyzing the depth map (<kbd>img_gray</kbd>), and returns a hand region mask (<kbd>segment</kbd>), like this:</li>
</ol>
<pre style="padding-left: 60px">def recognize(img_gray: np.ndarray) -&gt; Tuple[int,np.ndarray]:<br/>    # segment arm region<br/>    segment = segment_arm(img_gray) </pre>
<ol start="2">
<li>It performs <kbd>contour</kbd> analysis on the hand region mask (<kbd>segment</kbd>). Then, it returns the largest contour found in the image (<kbd>contour</kbd>) and any convexity defects (<kbd>defects</kbd>), as follows:</li>
</ol>
<pre style="padding-left: 60px"># find the hull of the segmented area, and based on that find the<br/># convexity defects<br/>contour, defects = find_hull_defects(segment)</pre>
<ol start="3">
<li>Based on the contour found and the convexity defects, it detects the number of extended fingers (<kbd>num_fingers</kbd>) in the image. Then, it creates an illustration image <span>(</span><kbd>img_draw</kbd><span>)</span> using (<kbd>segment</kbd>) image as a template, and annotates it with <kbd>contour</kbd> and <kbd>defect</kbd> points, like this:</li>
</ol>
<pre style="padding-left: 60px">img_draw = cv2.cvtColor(segment, cv2.COLOR_GRAY2RGB)<br/>num_fingers, img_draw = detect_num_fingers(contour,<br/>                                             defects, img_draw)</pre>
<ol start="4">
<li>Finally, the estimated number of extended fingers (<kbd>num_fingers</kbd>), as well as the annotated output image (img_draw), are returned, as follows:</li>
</ol>
<pre style="padding-left: 60px">return num_fingers, img_draw</pre>
<p>In the next section, let's learn how to accomplish hand region segmentation, which we used at the beginning of the procedure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding hand region segmentation</h1>
                </header>
            
            <article>
                
<p>The automatic detection of an arm—and later, the hand region—could be designed to be arbitrarily complicated, maybe by combining information about the shape and color of an arm or hand. However, using skin color as a determining feature to find hands in visual scenes might fail terribly in poor lighting conditions or when the user is wearing gloves. Instead, we choose to recognize the user's hand by its shape in the depth map.</p>
<p>Allowing hands of all sorts to be present in any region of the image unnecessarily complicates the mission of the present chapter, so we make two simplifying assumptions:</p>
<ul>
<li>We will instruct the user of our app to place their hand in front of the center of the screen, orienting their palm roughly parallel to the orientation of the Kinect sensor so that it is easier to identify the corresponding depth layer of the hand.</li>
<li>We will also instruct the user to sit roughly 1 to 2 meters away from the Kinect and to slightly extend their arm in front of their body so that the hand will end up in a slightly different depth layer than the arm. However, the algorithm will still work even if the full arm is visible.</li>
</ul>
<p>In this way, it will be relatively straightforward to segment the image based on the depth layer alone. Otherwise, we would have to come up with a hand detection algorithm first, which would unnecessarily complicate our mission. If you feel adventurous, feel free to do this on your own.</p>
<p>Let's see how to find the most prominent depth of the image center region in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finding the most prominent depth of the image center region</h1>
                </header>
            
            <article>
                
<p>Once the hand is placed roughly in the center of the screen, we can start finding all image pixels that lie on the same depth plane as the hand. This is done by following these steps:</p>
<ol>
<li>First, we simply need to determine the most prominent <kbd>depth</kbd> value of the center region of the image. The simplest approach would be to look only at the <kbd>depth</kbd> value of the center pixel, like this:</li>
</ol>
<pre style="padding-left: 60px">width, height = depth.shape 
center_pixel_depth = depth[width/2, height/2] </pre>
<ol start="2">
<li>Then, create a mask in which all pixels at a depth of <kbd>center_pixel_depth</kbd> are white and all others are black, as follows:</li>
</ol>
<pre style="padding-left: 60px">import numpy as np 
 
depth_mask = np.where(depth == center_pixel_depth, 255, <br/>     0).astype(np.uint8)</pre>
<p style="padding-left: 60px">However, this approach will not be very robust, because there is the chance that it will be compromised by the following:</p>
<ul>
<li style="padding-left: 30px">Your hand will not be placed perfectly parallel to the Kinect sensor.</li>
<li style="padding-left: 30px">Your hand will not be perfectly flat.</li>
<li style="padding-left: 30px">The Kinect sensor values will be noisy.</li>
</ul>
<p style="padding-left: 60px">Therefore, different regions of your hand will have slightly different depth values.</p>
<p>The <kbd>segment_arm</kbd> method takes a slightly better approach—it looks at a small neighborhood in the center of the image and determines the median depth value. This is done by following these steps:</p>
<ol>
<li>First, we find the center region (for example, <kbd>21 x 21 pixels</kbd>) of the image frame, like this:</li>
</ol>
<pre style="padding-left: 60px">def segment_arm(frame: np.ndarray, abs_depth_dev: int = 14) -&gt; np.ndarray:<br/>    height, width = frame.shape<br/>    # find center (21x21 pixels) region of imageheight frame<br/>    center_half = 10 # half-width of 21 is 21/2-1<br/>    center = frame[height // 2 - center_half:height // 2 + center_half,<br/>                   width // 2 - center_half:width // 2 + center_half]</pre>
<ol start="2">
<li>Then, we determine the median depth value, <kbd>med_val</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px">med_val = np.median(center) </pre>
<p style="padding-left: 60px">We can now compare <kbd>med_val</kbd> with the depth value of all pixels in the image and create a mask in which all pixels whose depth values are within a particular range <kbd>[med_val-abs_depth_dev, med_val+abs_depth_dev]</kbd> are white, and all other pixels are black.</p>
<p style="padding-left: 60px">However, for reasons that will become clear in a moment, let's paint the pixels gray instead of white, like this:</p>
<pre style="padding-left: 60px">frame = np.where(abs(frame - med_val) &lt;= abs_depth_dev,<br/>                 128, 0).astype(np.uint8)</pre>
<ol start="3">
<li>The result will look like this:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cfde92f7-9d3e-4585-93ee-2fad307bcc0c.png" style="width:33.00em;height:22.83em;"/></p>
<p>You will note that the segmentation mask is not smooth. In particular, it contains holes at points where the depth sensor failed to make a prediction. Let's learn how to apply morphological closing to smoothen the segmentation mask, in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying morphological closing for smoothening</h1>
                </header>
            
            <article>
                
<p>A common problem with segmentation is that a hard threshold typically results in small imperfections (that is, holes, as in the preceding image) in the segmented region. These holes can be alleviated by using morphological opening and closing. When it is opened, it removes small objects from the foreground (assuming that the objects are bright on a dark foreground), whereas closing removes small holes (dark regions).</p>
<p>This means that we can get rid of the small black regions in our mask by applying morphological closing (dilation followed by erosion) with a small <kbd>3</kbd> x <kbd>3</kbd>-pixel kernel, as follows:</p>
<pre>kernel = np.ones((3, 3), np.uint8)<br/>frame = cv2.morphologyEx(frame, cv2.MORPH_CLOSE, kernel)</pre>
<p>The result looks a lot smoother, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/077e761a-48fb-48ac-83c1-48d785d26a5f.png" style="width:32.08em;height:21.92em;"/></p>
<p>Notice, however, that the mask still contains regions that do not belong to the hand or arm, such as what appears to be one of the knees on the left and some furniture on the right. These objects just happen to be on the same depth layer of my arm and hand. If possible, we could now combine the depth information with another descriptor, maybe a texture- or skeleton-based hand classifier that would weed out all non-skin regions.</p>
<p><span>An easier appro</span><span>ach is to realize that most of the time, hands are not connected to knees or furniture. </span>Let's learn how to find connected components in a segmentation mask.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finding connected components in a segmentation mask</h1>
                </header>
            
            <article>
                
<p>We already know that the center region belongs to the hand. For such a scenario, we can simply apply <kbd>cv2.floodfill</kbd> to find all the connected image regions.</p>
<p>Before we do this, we want to be absolutely certain that the seed point for the flood fill belongs to the right mask region. This can be achieved by assigning a grayscale value of <kbd>128</kbd> to the seed point. However, we also want to make sure that the center pixel does not, by any coincidence, lie within a cavity that the morphological operation failed to close.</p>
<p>So, let's set a small 7 x 7-pixel region with a grayscale value of <kbd>128</kbd> instead, like this:</p>
<pre>small_kernel = 3<br/>frame[height // 2 - small_kernel:height // 2 + small_kernel,<br/>      width // 2 - small_kernel:width // 2 + small_kernel] = 128</pre>
<p>As <strong>flood filling</strong> (as well as morphological operations) is potentially dangerous, OpenCV requires the specification of a mask that avoids <em>flooding</em> the entire image. This mask has to be 2 pixels wider and taller than the original image and has to be used in combination with the <kbd>cv2.FLOODFILL_MASK_ONLY</kbd> flag.</p>
<p>It can be very helpful to constrain the flood filling to a small region of the image or a specific contour so that we need not connect two neighboring regions that should never have been connected in the first place. <em>It's better to be safe than sorry, right?</em></p>
<p><em>Nevertheless, today, we feel courageous!</em> Let's make the <kbd>mask</kbd> entirely black, like this:</p>
<pre>mask = np.zeros((height + 2, width + 2), np.uint8)</pre>
<p>Then, we can apply the flood fill to the center pixel (the seed point), and paint all the connected regions white, as follows:</p>
<pre>flood = frame.copy()<br/>cv2.floodFill(flood, mask, (width // 2, height // 2), 255,<br/>              flags=4 | (255 &lt;&lt; 8))</pre>
<p>At this point, it should be clear why we decided to start with a gray mask earlier. We now have a mask that contains white regions (arm and hand), gray regions (neither arm nor hand, but other things in the same depth plane), and black regions (all others). With this setup, it is easy to apply a simple binary <kbd>threshold</kbd> to highlight only the relevant regions of the pre-segmented depth plane, as follows:</p>
<pre>ret, flooded = cv2.threshold(flood, 129, 255, cv2.THRESH_BINARY) </pre>
<p>This is what the resulting mask looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ea3096a1-d616-46c9-ba73-4941a4026c05.png" style="width:33.92em;height:21.83em;"/></p>
<p>The resulting segmentation mask can now be returned to the <kbd>recognize</kbd> function, where it will be used as an input to the <kbd>find_hull_defects</kbd> function, as well as a canvas for drawing the final output image (<kbd>img_draw</kbd>). The function analyzes the shape of a hand in order to detect the defects of a hull that corresponds to the hand. Let's learn how to perform hand shape analysis in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performing hand shape analysis</h1>
                </header>
            
            <article>
                
<p>Now that we know (roughly) where the hand is located, we aim to learn something about its shape. In this app, we will make a decision on which exact gesture is shown, based on convexity defects of a contour corresponding to the hand.</p>
<p>Let's move on and learn how to determine the contour of the segmented hand region in the next section, which will be the first step in our hand shape analysis.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Determining the contour of the segmented hand region</h1>
                </header>
            
            <article>
                
<p>The first step involves determining the contour of the segmented hand region. Luckily, OpenCV comes with a pre-canned version of such an algorithm—<kbd>cv2.findContours</kbd>. This function acts on a binary image and returns a set of points that are believed to be part of the contour. As there might be multiple contours present in the image, it is possible to retrieve an entire hierarchy of contours, as follows:</p>
<pre>def find_hull_defects(segment: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:<br/>    contours, hierarchy = cv2.findContours(segment, cv2.RETR_TREE,<br/>                                           cv2.CHAIN_APPROX_SIMPLE)</pre>
<p>Furthermore, because we do not know which contour we are looking for, we have to make an assumption to clean up the contour result, since it is possible that some small cavities are left over even after the morphological closing. However, we are fairly certain that our mask contains only the segmented area of interest. We will assume that the largest contour found is the one that we are looking for.</p>
<p>Thus, we simply traverse the list of contours, calculate the contour area (<kbd>cv2.contourArea</kbd>), and store only the largest one (<kbd>max_contour</kbd>), like this:</p>
<pre>max_contour = max(contours, key=cv2.contourArea) </pre>
<p>The contour that we found might still have too many corners. We approximate the <kbd>contour</kbd> with a similar <kbd>contour</kbd> that does not have sides that are less than 1 percent of the perimeter of the <kbd>contour</kbd>, like this:</p>
<pre>epsilon = 0.01 * cv2.arcLength(max_contour, True)<br/>max_contour = cv2.approxPolyDP(max_contour, epsilon, True)</pre>
<p>Let's learn how to find the convex hull of a contour area, in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finding the convex hull of a contour area</h1>
                </header>
            
            <article>
                
<p>Once we have identified the largest contour in our mask, it is straightforward to compute the convex hull of the contour area. The convex hull is basically the envelope of the contour area. If you think of all the pixels that belong to the contour area as a set of nails poking out of a board, then a tight rubber band encircles all the nails forming the convex hull shape. We can get the convex hull directly from our largest contour (<kbd>max_contour</kbd>), like this:</p>
<pre>hull = cv2.convexHull(max_contour, returnPoints=False) </pre>
<p>As we now want to look at convexity deficits in this hull, we are instructed by the OpenCV documentation to set the <kbd>returnPoints</kbd> optional flag to <kbd>False</kbd>.</p>
<p>The convex hull drawn in yellow around a segmented hand region looks like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4a661ec5-5d71-4210-924d-13bf84e297d2.png" style="width:25.00em;height:19.83em;"/></p>
<p><span>As mentioned previously, we will determine a hand gesture based on convexity defects. Let's move on and learn how to find the convexity defects of a convex hull in the next section, which will bring us one step closer to recognizing hand gestures.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finding the convexity defects of a convex hull</h1>
                </header>
            
            <article>
                
<p>As is evident from the preceding screenshot, not all points on the convex hull belong to the segmented hand region. In fact, all the fingers and the wrist cause severe <em>convexity defects</em>—that is, points of the contour that are far away from the hull.</p>
<p>We can find these defects by looking at both the largest contour (<kbd>max_contour</kbd>) and the corresponding convex hull (<kbd>hull</kbd>), as follows:</p>
<pre>defects = cv2.convexityDefects(max_contour, hull) </pre>
<p>The output of this function (<kbd>defects</kbd>) is a NumPy array containing all defects. Each defect is an array of four integers that are <kbd>start_index</kbd> (index of the point in the contour where the defect begins), <kbd>end_index</kbd> (index of the point in the contour where the defect ends), <kbd>farthest_pt_index</kbd> (the index of the farthest point from the convex hull within the defect), and <kbd>fixpt_depth</kbd> (the distance between the farthest point and the convex hull).</p>
<p>We will make use of this information in just a moment when we try to estimate the number of extended fingers.</p>
<p>For now, though, our job is done. The extracted contour (<kbd>max_contour</kbd>) and convexity defects (<kbd>defects</kbd>) can be returned to <kbd>recognize</kbd>, where they will be used as inputs to <kbd>detect_num_fingers</kbd>, as follows:</p>
<pre>return max_contour, defects </pre>
<p>So, now that we have found the defects, let's move on and learn how to perform hand gesture recognition using the convexity defects, which will bring us toward the completion of the app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performing hand gesture recognition</h1>
                </header>
            
            <article>
                
<p>What remains to be done is to classify the hand gesture based on the number of extended fingers. For example, if we find five extended fingers, we assume the hand to be open, whereas no extended fingers implies a fist. All that we are trying to do is count from zero to five, and make the app recognize the corresponding number of fingers.</p>
<p>This is actually trickier than it might seem at first. For example, people in <strong>Europe</strong> might count to three by extending their <em>thumb</em>, <em>index finger</em>, and <em>middle finger</em>. If you do that in the <strong>US</strong>, people there might get horrendously confused, because they do not tend to use their thumbs when signaling the number two.</p>
<p>This might lead to frustration, especially in restaurants (trust me). If we could find a way to generalize these two scenarios—maybe by appropriately counting the number of extended fingers, we would have an algorithm that could teach simple hand gesture recognition to not only a machine but also (maybe) to a person of average intellect.</p>
<p>As you might have guessed, the answer is related to convexity defects. As mentioned earlier, extended fingers cause defects in the convex hull. However, the inverse is not true; that is, not all convexity defects are caused by fingers! There might be additional defects caused by the wrist, as well as the overall orientation of the hand or the arm. <em>How can we distinguish between these different causes of defects?</em></p>
<p>Let's distinguish between different cases of convexity defects, in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Distinguishing between different causes of convexity defects</h1>
                </header>
            
            <article>
                
<p>The trick is to look at the angle between the farthest point from the convex hull point within the defect (<kbd>farthest_pt_index</kbd>) and the start and endpoints of the defect (<kbd>start_index</kbd> and <kbd>end_index</kbd>, respectively), as illustrated in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/16ce6afa-bc58-488c-841e-99f93470c5e0.png" style="width:31.17em;height:21.25em;"/></p>
<p>In the previous screenshot, the orange markers serve as a visual aid to center the hand in the middle of the screen, and the convex hull is outlined in green. Each red dot corresponds to <em>the point farthest from the convex hull</em> (<kbd>farthest_pt_index</kbd>) for every convexity defect detected. If we compare a typical angle that belongs to two extended fingers (such as <span class="packt_screen"><strong><span class="packt_screen">θ</span></strong><span class="packt_screen">j</span></span>) to an angle that is caused by general hand geometry (such as <strong><span class="packt_screen">θi</span></strong>), we notice that the former is much smaller than the latter.</p>
<p>This is obviously because humans can spread their fingers only a little, thus creating a narrow angle made by the farthest defect point and the neighboring fingertips. Therefore, we can iterate over all convexity defects and compute the angle between the said points. For this, we will need a utility function that calculates the angle (in radians) between two arbitrary—a list like vectors, <kbd>v1</kbd> and <kbd>v2</kbd>, as follows:</p>
<pre>def angle_rad(v1, v2): 
    return np.arctan2(np.linalg.norm(np.cross(v1, v2)), <br/>         np.dot(v1, v2))</pre>
<p>This method uses the cross product to compute the angle, rather than doing it in the standard way. The standard way of calculating the angle between two vectors <kbd>v1</kbd> and <kbd>v2</kbd> is by calculating their dot product and dividing it by the <kbd>norm</kbd> of <kbd>v1</kbd> and the <kbd>norm</kbd> of <kbd>v2</kbd>. However, this method has two imperfections:</p>
<ul>
<li>You have to manually avoid division by zero if either the <kbd>norm</kbd> of <kbd>v1</kbd> or the <kbd>norm</kbd> of <kbd>v2</kbd> is zero.</li>
<li>The method returns relatively inaccurate results for small angles.</li>
</ul>
<p>Similarly, we provide a simple function to convert an angle from degrees to radians, illustrated here:</p>
<pre>def deg2rad(angle_deg): 
    return angle_deg/180.0*np.pi </pre>
<p class="mce-root">In the next section, we'll see how to classify hand gestures based on the number of extended fingers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Classifying hand gestures based on the number of extended fingers</h1>
                </header>
            
            <article>
                
<p>What remains to be done is to actually classify the hand gesture based on the number of instances of extended fingers. The classification is done using the following function:</p>
<pre>def detect_num_fingers(contour: np.ndarray, defects: np.ndarray,<br/>                       img_draw: np.ndarray, thresh_deg: float = 80.0) -&gt; Tuple[int, np.ndarray]:</pre>
<p><span>The function accepts the detected contour (</span><kbd>contour</kbd><span>), the convexity defects (</span><kbd>defects</kbd><span>), a canvas to draw on (</span><kbd>img_draw</kbd><span>), and </span><span>a cutoff angle that can be used as a threshold to classify whether convexity defects are caused by extended fingers or not </span><span>(</span><kbd>thresh_deg</kbd><span>). </span></p>
<p><span>Except for the angle between the thumb and the index finger, it is rather hard to get anything close to 90 degrees, so anything close to that number should work. We do not want the cutoff angle to be too high, because that might lead to errors in classifications. The complete function will</span> return <span>the number of fingers and the illustration frame, and consists of the following steps:</span></p>
<ol>
<li>First, let's focus on special cases. If we do not find any convexity <kbd>defects</kbd>, it means that we possibly made a mistake during the convex hull calculation, or there are simply no extended fingers in the frame, so we return <kbd>0</kbd> as the number of detected fingers, as follows:</li>
</ol>
<pre style="padding-left: 60px">if defects is None: 
    return [0, img_draw] </pre>
<ol start="2">
<li>However, we can take this idea even further. Due to the fact that arms are usually slimmer than hands or fists, we can assume that the hand geometry will always generate at least two convexity defects (which usually belong to the wrists). So, if there are no additional defects, it implies that there are no extended fingers:</li>
</ol>
<pre style="padding-left: 60px">if len(defects) &lt;= 2: 
    return [0, img_draw] </pre>
<ol start="3">
<li>Now that we have ruled out all special cases, we can begin counting real fingers. If there is a sufficient number of defects, we will find a defect between every pair of fingers. Thus, in order to get the number right (<kbd>num_fingers</kbd>), we should start counting at <kbd>1</kbd>, like this:</li>
</ol>
<pre style="padding-left: 60px">num_fingers = 1 </pre>
<ol start="4">
<li>Then, we start iterating over all convexity defects. For each defect, we extract the three points and draw its hull for visualization purposes, as follows:</li>
</ol>
<pre style="padding-left: 60px"># Defects are of shape (num_defects,1,4)<br/>for defect in defects[:, 0, :]:<br/>    # Each defect is an array of four integers.<br/>    # First three indexes of start, end and the furthest<br/>    # points respectively<br/>    start, end, far = [contour[i][0] for i in defect[:3]]<br/>    # draw the hull<br/>    cv2.line(img_draw, tuple(start), tuple(end), (0, 255, 0), 2)</pre>
<ol start="5">
<li>Then, we compute the angle between the two edges from <kbd>far</kbd> to <kbd>start</kbd> and from <kbd>far</kbd> to <kbd>end</kbd>. If the angle is smaller than <kbd>thresh_deg</kbd> degrees, it means that we are dealing with a defect that is most likely caused by two extended fingers. In such cases, we want to increment the number of detected fingers (<kbd>num_fingers</kbd>) and draw the point with <kbd>green</kbd>. Otherwise, we draw the point with <kbd>red</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px"># if angle is below a threshold, defect point belongs to two<br/># extended fingers<br/>if angle_rad(start - far, end - far) &lt; deg2rad(thresh_deg):<br/>    # increment number of fingers<br/>    num_fingers += 1<br/><br/>    # draw point as green<br/>    cv2.circle(img_draw, tuple(far), 5, (0, 255, 0), -1)<br/>else:<br/>    # draw point as red<br/>    cv2.circle(img_draw, tuple(far), 5, (0, 0, 255), -1)</pre>
<ol start="6">
<li>After iterating over all convexity defects, we <kbd>return</kbd> the number of detected fingers and the assembled output image, like this:</li>
</ol>
<pre style="padding-left: 60px">return min(5, num_fingers), img_draw</pre>
<p style="padding-left: 60px">Computing the minimum will make sure that we do not exceed the common number of fingers per hand.</p>
<p><span>The result can be seen in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ae752397-7a09-4d67-ae38-690491dcc7d5.png" style="width:45.08em;height:21.50em;"/></p>
<p>Interestingly, our app is able to detect the correct number of extended fingers in a variety of hand configurations. Defect points between extended fingers are easily classified as such by the algorithm, and others are successfully ignored.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter showed a relatively simple—and yet surprisingly robust—way of recognizing a variety of hand gestures by counting the number of extended fingers.</p>
<p>The algorithm first shows how a task-relevant region of the image can be segmented using depth information acquired from a Microsoft Kinect 3D sensor, and how morphological operations can be used to clean up the segmentation result. By analyzing the shape of the segmented hand region, the algorithm comes up with a way to classify hand gestures based on the types of convexity effects found in the image.</p>
<p>Once again, mastering our use of OpenCV to perform the desired task did not require us to produce a large amount of code. Instead, we were challenged to gain an important insight that made us use the built-in functionality of OpenCV in an effective way.</p>
<p>Gesture recognition is a popular but challenging field in computer science, with applications in a large number of areas, such as <strong>Human-Computer Interaction</strong> (<strong>HCI</strong>), video surveillance, and even the video game industry. You can now use your advanced understanding of segmentation and structure analysis to build your own state-of-the-art gesture recognition system. Another approach you might want to use for hand gesture recognition is to train a deep image classification network on hand gestures. We will discuss deep networks for image classifications in <a href="8baf5d4c-f1e9-4b76-b957-e19682cb9e68.xhtml">Chapter 9</a>, <span><em>Learning to Classify and Localize Objects</em>.</span></p>
<p>In the next chapter, we will continue to focus on detecting objects of interest in visual scenes, but we will assume a much more complicated case: viewing the object from an arbitrary perspective and distance. To do this, we will combine perspective transformations with scale-invariant feature descriptors to develop a robust feature-matching algorithm.</p>


            </article>

            
        </section>
    </body></html>