- en: 'Chapter 8: Use Case – Customer Churn Prediction'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：用例 - 客户流失预测
- en: In the last chapter, we discussed the alternatives to the **Feast** feature
    store available on the market. We looked at a few feature store offerings from
    cloud providers that are part of **Machine Learning** (**ML**) platform offerings,
    namely, SageMaker, Vertex AI, and Databricks. We also looked at a couple of other
    vendors that offer managed feature stores that can be used with your cloud provider,
    namely, Tecton and Hopsworks, of which Hopsworks is also open source. To get a
    feel for a managed feature store, we tried out an exercise on the SageMaker Feature
    Store and also briefly discussed ML best practices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了市场上可用的**Feast**特征存储的替代方案。我们查看了一些云提供商的特征存储产品，这些产品是**机器学习**（**ML**）平台产品的一部分，即SageMaker、Vertex
    AI和Databricks。我们还查看了一些其他供应商，他们提供可以与您的云提供商一起使用的托管特征存储，例如Tecton和Hopsworks，其中Hopsworks也是开源的。为了了解托管特征存储，我们尝试了SageMaker特征存储的练习，并简要讨论了ML最佳实践。
- en: In this chapter, we will discuss an end-to-end use case of customer churn using
    a telecom dataset. We will walk through data cleaning, feature engineering, feature
    ingestion, model training, deployment, and monitoring. For this exercise, we will
    use a managed feature store – Amazon SageMaker. The reason for choosing SageMaker
    over other alternatives that we discussed in the last chapter is simply the easy
    accessibility to the trial version of the software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论使用电信数据集进行客户流失的端到端用例。我们将逐步介绍数据清洗、特征工程、特征摄取、模型训练、部署和监控。对于这个练习，我们将使用托管特征存储——Amazon
    SageMaker。选择SageMaker而不是上一章中讨论的其他替代方案的原因很简单，那就是软件试用版的易于访问。
- en: The aim of this chapter is to go through a customer churn prediction ML use
    case, step by step, using a managed feature store. This should give you an idea
    of how it differs from self-managed feature stores and also basic feature monitoring
    and model monitoring aspects the feature store helps with.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是逐步通过使用托管特征存储的客户流失预测ML用例。这应该能让你了解它与自管理特征存储的不同之处，以及特征存储帮助的基本特征监控和模型监控方面。
- en: 'In this chapter, we will discuss the following topics in order:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将按以下顺序讨论以下主题：
- en: Infrastructure setup
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施设置
- en: Introduction to the problem and the dataset
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题与数据集的介绍
- en: Data processing and feature engineering
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据处理和特征工程
- en: Feature group definitions and ingestion
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征组定义和摄取
- en: Model training
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型训练
- en: Model prediction
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型预测
- en: Feature monitoring
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征监控
- en: Model monitoring
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型监控
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To run through the examples and to get a better understanding of this chapter,
    an understanding of the topics covered in previous chapters will be useful but
    is not required. To follow the code examples in this chapter, you need familiarity
    with a notebook environment, which could be a local setup such as the Jupyter
    Notebook or an online notebook environment such as Google Colab, Kaggle, or SageMaker.
    You will also need an AWS account with full access to SageMaker and the Glue console.
    You can create a new account and use all the services for free during the trial
    period. You can find the code examples of the book at the following GitHub link:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行示例并更好地理解本章内容，了解前几章涵盖的主题将很有用，但不是必需的。为了跟随本章的代码示例，你需要熟悉笔记本环境，这可以是本地设置，如Jupyter
    Notebook，或者在线笔记本环境，如Google Colab、Kaggle或SageMaker。你还需要一个AWS账户，并完全访问SageMaker和Glue控制台。你可以在试用期间创建新账户并免费使用所有服务。你可以在以下GitHub链接找到本书的代码示例：
- en: https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/tree/main/Chapter08
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/tree/main/Chapter08
- en: Infrastructure setup
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施设置
- en: For the exercises in this chapter, we will need an S3 bucket to store data,
    an IAM role, and an IAM user that has access to both the SageMaker Feature Store
    and the S3 bucket. Since we have already gone through creating all these resources,
    I will skip through this. Please refer to [*Chapter 4*](B18024_04_ePub.xhtml#_idTextAnchor065),
    *Adding Feature Store to ML Models*, for S3 bucket creation, and [*Chapter 7*](B18024_07_ePub.xhtml#_idTextAnchor113),
    *Feast Alternatives and ML Best Practices*, for IAM role and IAM user creation.
    That is all we need, in terms of initial setup for this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习中，我们需要一个S3存储桶来存储数据，一个IAM角色，以及一个可以访问SageMaker Feature Store和S3存储桶的IAM用户。由于我们已经完成了所有这些资源的创建，我将跳过这一部分。请参阅[*第4章*](B18024_04_ePub.xhtml#_idTextAnchor065)，*将特征存储添加到机器学习模型*，了解S3存储桶的创建，以及[*第7章*](B18024_07_ePub.xhtml#_idTextAnchor113)，*Feast替代方案和机器学习最佳实践*，了解IAM角色和IAM用户的创建。这就是本章初始设置所需的所有内容。
- en: Important Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: I am trying to use as few resources of AWS SageMaker as possible since it will
    incur costs if your free trial has come to an end. You can use SageMaker Studio
    for a better experience with notebooks and also the UI of the feature store.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我尽量少使用AWS SageMaker的资源，因为如果你的免费试用已经结束，这将产生费用。你可以使用SageMaker Studio来获得更好的笔记本和特征存储的UI体验。
- en: Introduction to the problem and the dataset
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题及数据集介绍
- en: 'In this exercise, we will use the telecom customer churn dataset, which is
    available on Kaggle at the URL https://www.kaggle.com/datasets/blastchar/telco-customer-churn.
    The aim of the exercise is to use this dataset, prepare the data for model training,
    and train an XGBoost model to predict customer churn. The dataset has 21 columns
    and the column names are self-explanatory. The following is a preview of the dataset:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用可在Kaggle的URL https://www.kaggle.com/datasets/blastchar/telco-customer-churn上找到的电信客户流失数据集。练习的目标是使用这个数据集，为模型训练准备数据，并训练一个XGBoost模型来预测客户流失。该数据集有21列，列名具有自解释性。以下是对数据集的预览：
- en: '![Figure 8.1 – Telecom dataset'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 电信数据集'
- en: '](img/B18024_08_001.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B18024_08_001.jpg](img/B18024_08_001.jpg)'
- en: Figure 8.1 – Telecom dataset
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 电信数据集
- en: '*Figure 8.1* shows the labeled telecom customer churn dataset. The `customerID`
    column is the ID of the customers. All other columns except `Churn` represent
    the set of attributes, and the `Churn` column is the target column.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.1* 展示了标记的电信客户流失数据集。`customerID` 列是客户的ID。除了 `Churn` 列之外的所有列代表属性集，而 `Churn`
    列是目标列。'
- en: Let's get our hands dirty and perform feature engineering next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们动手进行特征工程。
- en: Data processing and feature engineering
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据处理和特征工程
- en: 'In this section, let''s use the telecom customer churn dataset and generate
    the features that can be used for training the model. Let''s create a notebook,
    call it `feature-engineering.ipynb`, and install the required dependencies:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用电信客户流失数据集，并生成可用于训练模型的特征。让我们创建一个笔记本，命名为 `feature-engineering.ipynb`，并安装所需的依赖项：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once the installation of the libraries is complete, read the data. For this
    exercise, I have downloaded the data from Kaggle and saved it in a location where
    it is accessible from the notebook.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 完成库的安装后，读取数据。对于这个练习，我已经从Kaggle下载了数据，并将其保存在可以从笔记本访问的位置。
- en: 'The following command reads the data from S3:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令从S3读取数据：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Important Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are executing the notebook outside AWS, then set the user credentials
    using the environment variables.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在外部AWS中执行笔记本，则使用环境变量设置用户凭据。
- en: If you preview that dataset, there are a few columns that need to be reformatted,
    converted into a categorical column, or have empty values removed. Let's perform
    those transformations one after the other.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你预览该数据集，有几个列需要重新格式化，转换为分类列，或删除空值。让我们依次执行这些转换。
- en: 'The `TotalCharges` column contains a few empty strings. Let''s remove the rows
    that contain empty or null values for `TotalCharges`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`TotalCharges` 列包含一些空字符串。让我们删除包含空或null值 `TotalCharges` 的行：'
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code block replaces all the empty strings with `np.nan` and drops
    all the rows that contain null in the `TotalCharges` column.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码块将所有空字符串替换为 `np.nan`，并删除了 `TotalCharges` 列中包含空的行。
- en: 'Next, let''s look at the `tenure` column. This one has integer values that
    represent the tenure of the customer in months. Along with the value, we can also
    group the customers into three groups: short (0-24 months), mid (24-48 months),
    and long (greater than 48 months).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`tenure`列。这个列有整数值，代表客户以月为单位的服务期限。除了值之外，我们还可以将客户分为三组：短期（0-24个月）、中期（24-48个月）和长期（大于48个月）。
- en: 'The following code adds the customer `tenure_group` column with the defined
    groups:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码添加了具有定义组的客户`tenure_group`列：
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code block creates the categorical column `tenure_group`, which
    will have three values, `0-24`, `24-48`, and `48-end`, depending on the length
    of the customer tenure.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上一代码块创建了一个分类列`tenure_group`，它将根据客户服务期限的长度具有三个值，`0-24`、`24-48`和`48-end`。
- en: A few columns in the dataset are dependent on others. For example, `OnlineSecurity`
    depends on whether the customer has `InternetService` or not. Hence, some of these
    columns, namely, `OnlineSecurity`, `OnlineBackup`, `DeviceProtection`, `TechSupport`,
    `StreamingTV`, and `StreamingMovies` have `No internet service` as the value instead
    of `No`. Let's replace `No internet service` with `No` in those columns.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集中的一些列依赖于其他列。例如，`OnlineSecurity`依赖于客户是否有`InternetService`。因此，一些这些列，即`OnlineSecurity`、`OnlineBackup`、`DeviceProtection`、`TechSupport`、`StreamingTV`和`StreamingMovies`，其值用`No
    internet service`代替`No`。让我们将这些列中的`No internet service`替换为`No`。
- en: 'The following code block performs the replacement:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块执行替换操作：
- en: '[PRE28]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have done a set of data cleaning operations so far. Let's preview the dataset
    once before we proceed and do further transformations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经进行了一系列数据清洗操作。在继续进行进一步转换之前，让我们预览一次数据集。
- en: 'The following code samples the `churn_data` DataFrame:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块对`churn_data` DataFrame进行采样：
- en: '[PRE34]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following code outputs a sample preview as shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码输出一个样本预览，如图所示：
- en: '![Figure 8.2 – Churn dataset'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – Churn数据集'
- en: '](img/B18024_08_002.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B18024_08_002.jpg](img/B18024_08_002.jpg)'
- en: Figure 8.2 – Churn dataset
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – Churn数据集
- en: As you can see in *Figure 8.2*, the dataset is clean and only has categorical
    or numerical columns. The next step is to covert these categorical values into
    numerical encoding. Let's look at the dataset and see which ones are categorical
    and which ones are numerical.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图8.2*所示，数据集是干净的，只包含分类或数值列。下一步是将这些分类值转换为数值编码。让我们查看数据集，看看哪些是分类的，哪些是数值的。
- en: 'The following code calculates the unique values in every column:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码计算每个列的唯一值：
- en: '[PRE35]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code displays the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上一代码块显示以下输出：
- en: '![Figure 8.3 – Unique value count of every column'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – 每个列的唯一值计数'
- en: '](img/B18024_08_003.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B18024_08_003.jpg](img/B18024_08_003.jpg)'
- en: Figure 8.3 – Unique value count of every column
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 每个列的唯一值计数
- en: As you can see in *Figure 8.3*, except `MonthlyCharges`, `tenure`, and `TotalCharges`,
    all other columns are categorical.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图8.3*所示，除了`MonthlyCharges`、`tenure`和`TotalCharges`之外，所有其他列都是分类列。
- en: 'In the dataset, there are binary columns and multi-value category columns.
    Let''s find out which ones are binary and which ones are multi-value columns.
    The following code block checks if the column is binary from the list of columns:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据集中，有二进制列和多值分类列。让我们找出哪些是二进制列，哪些是多值列。以下代码块检查列是否为二进制列：
- en: '[PRE36]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now that we have the list of binary columns, let's transform them into 0s and
    1s using the label encoder.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了二进制列的列表，让我们使用标签编码器将它们转换为0和1。
- en: 'The following code uses the label encoder to perform the transformation on
    the binary columns:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用标签编码器对二进制列进行转换：
- en: '[PRE38]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The next step is to transform the multi-value categorical columns into 0s and
    1s. To do that, let's filter out the multi-value column names first.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将多值分类列转换为0和1。为此，让我们首先过滤出多值列名。
- en: 'The following code block selects the multi-value columns:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块选择多值列：
- en: '[PRE41]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding code block filters out all the categorical columns first and filters
    out the binary columns so that we are left with only the multi-value columns.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 上一代码块首先过滤掉所有分类列，然后过滤掉二进制列，这样我们只剩下多值列。
- en: 'The following code block transforms the multi-value columns into binary encodings:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块将多值列转换为二进制编码：
- en: '[PRE43]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The last part is transforming the numerical values. Since numerical columns
    can have different ranges, scaling the columns to a standard range can be beneficial
    for ML algorithms. It also helps algorithms converge faster. Hence, let's scale
    the number columns to a standard range.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是将数值转换为标准范围。由于数值列可能具有不同的范围，将列缩放到标准范围对于机器学习算法可能有益。这也有助于算法更快地收敛。因此，让我们将数值列缩放到标准范围。
- en: 'The following code block uses `StandardScaler` to scale all the numerical columns
    to a standard range:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块使用 `StandardScaler` 将所有数值列缩放到标准范围：
- en: '[PRE44]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding code block scales the numerical columns: `tenure`, `MonthlyCharges`,
    and `TotalCharges`. Now that our feature engineering is complete, let''s preview
    the final feature set and ingest it into the SageMaker Feature Store.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块缩放了数值列：`tenure`、`MonthlyCharges` 和 `TotalCharges`。现在我们的特征工程已经完成，让我们预览最终的特性集并将其摄取到
    SageMaker Feature Store 中。
- en: 'The following code block shows the feature set preview:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块显示了特征集预览：
- en: '[PRE47]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding code block formats the column names as lowercase and replaces
    all the separators in the string, such as spaces and hyphens, with an underscore.
    The final features are shown in the following screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块将列名格式化为小写，并将字符串中的所有分隔符（如空格和连字符）替换为下划线。最终的特征在下面的屏幕截图中显示：
- en: '![Figure 8.4 – Feature set'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – 特征集]'
- en: '](img/B18024_08_004.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B18024_08_004.jpg]'
- en: Figure 8.4 – Feature set
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 特征集
- en: The final feature set has 33 columns as shown in *Figure 8.4*. If you recall
    in [*Chapter 4*](B18024_04_ePub.xhtml#_idTextAnchor065), *Adding Feature Store
    to ML Models*, while creating feature definitions, we identified entities and
    grouped features based on their entities or logical groups. Though these features
    can be grouped into multiple groups, we will be creating a single feature group
    and ingesting all the features into it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的特征集有 33 列，如 *图 8.4* 所示。如果你还记得在 [*第 4 章*](B18024_04_ePub.xhtml#_idTextAnchor065)
    中，*将特征存储添加到机器学习模型*，在创建特征定义时，我们根据实体或逻辑组对实体和特征进行了分组。尽管这些特征可以分成多个组，但我们将创建一个单独的特征组并将所有特征摄取到其中。
- en: In the next section, let's create the feature definitions and ingest the data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们创建特征定义并摄取数据。
- en: Feature group definitions and feature ingestion
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征组定义和特征摄取
- en: Now that we have the feature set ready for ingestion, let's create the feature
    definitions and ingest the features into a feature store. For this exercise, as
    mentioned before, we will be using the SageMaker Feature Store. If you recall
    from the previous chapters, we always kept feature definitions in a separate notebook,
    as it is a one-time activity. In this exercise, we are going to try a different
    method, which is using a conditional statement to create a feature group if it
    doesn't exist. You can use either of the approaches.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了用于摄取的特征集，让我们创建特征定义并将特征摄取到特征存储中。正如之前提到的，我们将使用 SageMaker Feature Store。如果你还记得前面的章节，我们总是将特征定义保存在一个单独的笔记本中，因为这是一个一次性活动。在这个练习中，我们将尝试一种不同的方法，即使用条件语句在不存在的情况下创建特征组。你可以使用这两种方法中的任何一种。
- en: 'Let''s continue in the same notebook and initialize the boto3 session and check
    whether our feature group exists already or not:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在同一个笔记本中继续，初始化 boto3 会话并检查我们的特征组是否已经存在：
- en: '[PRE49]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The preceding code block queries SageMaker to check whether the feature group
    with the name `telcom-customer-features` exists or not and sets a Boolean based
    on that. We will use this Boolean to either create the feature group or to skip
    creation and just ingest the data into the feature store.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块查询 SageMaker 以检查名为 `telcom-customer-features` 的特征组是否存在，并根据该结果设置一个布尔值。我们将使用这个布尔值来创建特征组或跳过创建，直接将数据摄取到特征存储中。
- en: 'The following code block initializes the objects required for interacting with
    the SageMaker Feature Store:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块初始化了与 SageMaker Feature Store 交互所需的对象：
- en: '[PRE57]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Important Note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Use the IAM role created in the earlier section, in the preceding code block.
    The IAM role should have **AmazonSageMakerFullAccess** and **AmazonS3FullAccess**.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中使用之前创建的 IAM 角色。IAM 角色应该具有 **AmazonSageMakerFullAccess** 和 **AmazonS3FullAccess**。
- en: 'The next step is to initialize the `FeatureGroup` object. The following code
    initializes the feature group object:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是初始化 `FeatureGroup` 对象。下面的代码初始化了特征组对象：
- en: '[PRE65]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now we will use the Boolean that was set earlier to conditionally create the
    feature group if the feature group doesn''t exist. The following code block loads
    the feature definitions and calls `create` if the feature group doesn''t exist:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用之前设置的布尔值来有条件地创建特征组，如果特征组不存在。以下代码块加载特征定义并调用 `create` 方法，如果特征组不存在：
- en: '[PRE70]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Important Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the `load_feature_definitions` call, if you notice, I'm loading all the feature
    definition columns except the `customerid` column and manually adding the `customerid`
    column to the feature definitions list in the following line. The reason for this
    is the `sagemaker` library fails to figure out the `string` data type as the pandas
    `dtype` for `string` is `object`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `load_feature_definitions` 调用中，如果你注意到，我正在加载所有特征定义列，除了 `customerid` 列，并在下一行手动将
    `customerid` 列添加到特征定义列表中。这样做的原因是 `sagemaker` 库无法将 `string` 数据类型识别为 pandas `dtype`
    中的 `object`。
- en: The `create` feature group call is straightforward. I am disabling the online
    store by passing `enable_online_store` as `False`, since we will be trying out
    the batch pipeline and I will leave the online model as an exercise. Once the
    preceding code block executes, based on the conditional statement, for the first
    time, it will create the feature group and for the subsequent runs, it will skip
    the feature group creation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 特征组调用很简单。我通过传递 `enable_online_store` 为 `False` 来禁用在线存储，因为我们将会尝试批量管道，并将在线模型留作练习。一旦前面的代码块执行，根据条件语句，第一次将创建特征组，而对于后续的运行，将跳过特征组创建。'
- en: 'The final step is to ingest the DataFrame. The following code block performs
    the ingestion and prints any failures:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是摄取 DataFrame。以下代码块执行摄取并打印任何失败信息：
- en: '[PRE87]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Important Note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you only have the batch use case, SageMaker has a Spark library that can
    be used to ingest to the offline store directly, which is also cost-effective.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只有批量使用案例，SageMaker 有一个 Spark 库可以直接用于将数据导入离线存储，这也是一种经济高效的方法。
- en: That completes the feature engineering and ingestion. In the next section, let's
    look at model training.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了特征工程和摄取。在下一节中，让我们看看模型训练。
- en: Model training
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型训练
- en: 'As before, for the model training, the feature store is the source. Hence,
    let''s create our model training notebook and install and initialize the required
    objects for querying the feature store. Here is the link to the notebook:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，对于模型训练，特征存储是源。因此，让我们创建我们的模型训练笔记本并安装和初始化查询特征存储所需的所需对象。以下是笔记本的链接：
- en: '[https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_model_training.ipynb](https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_model_training.ipynb)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_model_training.ipynb](https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_model_training.ipynb)'
- en: 'The following code block installs the required libraries for model training:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块安装模型训练所需的库：
- en: '[PRE90]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'After installing the required libraries, initialize the SageMaker session and
    the required objects:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 安装所需的库后，初始化 SageMaker 会话和所需的对象：
- en: '[PRE91]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The preceding code block initializes the SageMaker session and initializes the
    feature group object. The `name` of the feature group should be the same as the
    `name` of the feature group that we created in our feature engineering notebook.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块初始化了 SageMaker 会话并初始化了特征组对象。特征组的 `name` 应该与我们特征工程笔记本中创建的特征组 `name` 相同。
- en: Important Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Assign the IAM role that was created earlier to the `role` variable. Also, if
    you are running the notebook outside AWS, you need to uncomment and set up AWS
    credentials in the preceding code block.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前创建的 IAM 角色分配给 `role` 变量。另外，如果你在 AWS 之外运行笔记本，你需要取消注释并设置前面的代码块中的 AWS 凭据。
- en: 'The next part is to query the historical store to generate the training data.
    Unlike Feast, we don''t need an entity DataFrame here. Instead, we use SQL queries
    to fetch the historical data. It has the same time travel capabilities as Feast
    has. For this exercise, let''s fetch the latest features for all customers, using
    a similar query to one that we used in the last chapter, during the SageMaker
    overview:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是查询历史存储以生成训练数据。与 Feast 不同，我们在这里不需要实体 DataFrame。相反，我们使用 SQL 查询来获取历史数据。它具有与
    Feast 相同的时间旅行功能。为此练习，让我们使用与上一章中在 SageMaker 概述部分使用的类似查询获取所有客户的最新特征：
- en: '[PRE107]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: If you recall correctly, we used a similar nested query in the last chapter.
    The preceding code block fetches all the customers and their latest features.
    The output of the query will be written to a specific S3 location as mentioned
    in the `run` API call.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得正确的话，我们在上一章中使用了类似的嵌套查询。前面的代码块获取了所有客户及其最新特征。查询的输出将被写入`run` API调用中提到的特定S3位置。
- en: 'Once the query runs successfully, the dataset can be fetched using the following
    code block:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦查询成功运行，可以使用以下代码块获取数据集：
- en: '[PRE121]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Important Note
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please note that, we will perform the same steps for model prediction and feature
    monitoring as we have in this section (*Model training*) from the beginning till
    the preceding code block.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将从本节（*模型训练*）开始，直到前面的代码块，执行相同的步骤进行模型预测和特征监控。
- en: 'The preceding code block fetches the dataset and drops the unwanted columns.
    The fetched dataset is similar to the data shown in *Figure 8.4* with additional
    columns: `write_time`, `api_invocation_time`, `is_deleted`, and `row_num`. The
    first three are additional metadata columns added by SageMaker during ingestion
    and `row_num` is the column that we created in the query for fetching the latest
    features for every customer.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块获取数据集并删除了不需要的列。获取的数据集类似于*图8.4*中所示的数据，但增加了以下列：`write_time`、`api_invocation_time`、`is_deleted`和`row_num`。前三个是SageMaker在摄取过程中添加的额外元数据列，而`row_num`是我们为了获取每个客户的最新特征而在查询中创建的列。
- en: 'Now that we have the dataset, let''s split it for training and testing. The
    following code block drops the columns unwanted for training from the dataset
    and splits the data for training and testing:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据集，让我们将其分为训练集和测试集。下面的代码块从数据集中删除了训练中不需要的列，并将数据分为训练集和测试集：
- en: '[PRE123]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The preceding code block leaves out the ID column and performs a 75/25 split
    for training and testing.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块省略了ID列，并执行了75/25的训练和测试分割。
- en: 'The rest of it is straightforward, which is basically training an XGBoost model,
    parameter tuning, and comparing the performance. The following is an example code
    block for training, sample analysis, and logging the model:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的都很直接，基本上是训练XGBoost模型、参数调整和比较性能。以下是一个用于训练、样本分析和记录模型的示例代码块：
- en: '[PRE139]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The preceding code block also logs the model to a specific location in S3\.
    This is a crude way of doing it. It is always better to use an experiment training
    tool for logging the performance and the model.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块还将模型记录到S3的特定位置。这是一种粗略的做法。始终最好使用实验训练工具来记录性能和模型。
- en: Now that the model training is complete, let's look at model scoring.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模型训练已完成，让我们看看模型评分。
- en: Model prediction
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型预测
- en: As mentioned in the last note in the previous section, as this is a batch model,
    the steps are similar for model scoring for fetching the data from the offline
    store. However, depending on which customers need to be scored (maybe all), you
    might filter out the dataset. Once you filter out the dataset, the rest of the
    steps are again straightforward, which is to load the model, run predictions,
    and store the results.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一小节最后一条注释所述，由于这是一个批量模型，因此从离线存储中获取数据的模型评分步骤与之前相似。然而，根据需要评分的客户（可能是所有客户），您可能需要过滤数据集。一旦过滤了数据集，其余步骤再次直接，即加载模型、运行预测和存储结果。
- en: 'The following is a sample code block for loading the model, running predictions,
    and also storing the results back in S3 for consumption:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用于加载模型、运行预测并将结果存储回S3以供消费的示例代码块：
- en: '[PRE157]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: The preceding code block downloads the model from S3, loads the model, scores
    it against the data fetched from the historical store, and also stores the result
    in the S3 bucket for consumption.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块从S3下载模型，加载模型，将其与从历史存储中获取的数据评分，并将结果存储在S3桶中以供消费。
- en: Note
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The library versions of XGBoost, Joblib, and scikit-learn should be the same
    as what was used while saving the model, otherwise loading of the model might
    fail.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: XGBoost、Joblib和scikit-learn的库版本应与保存模型时使用的版本相同，否则加载模型可能会失败。
- en: To productionize this ML pipeline, we can use orchestration similar to what
    we did in [*Chapter 6*](B18024_06_ePub.xhtml#_idTextAnchor096), *Model to Production
    and Beyond*. I will leave that as an exercise since it's duplicate content. Let's
    look at an example of feature monitoring next.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此机器学习管道投入生产，我们可以使用与我们在[*第6章*](B18024_06_ePub.xhtml#_idTextAnchor096)，“模型到生产及之后”中所做的类似的编排。我将将其留作练习，因为它是重复的内容。接下来，让我们看看特征监控的例子。
- en: Feature monitoring
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征监控
- en: We have discussed how important feature monitoring is in an ML system a few
    times in the book. We have also talked about how a feature store standardizes
    feature monitoring. In this section, let's look at an example of feature monitoring
    that can be useful for any model. As feature monitoring is calculating a set of
    statistics on feature data and notifying the data scientist or data engineer of
    changes, it needs the latest features used by the model.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中多次讨论了特征监控在机器学习系统中的重要性。我们还讨论了特征存储如何标准化特征监控。在本节中，让我们看看一个对任何模型都很有用的特征监控示例。由于特征监控是在特征数据上计算一组统计信息并通知数据科学家或数据工程师变化，因此它需要模型使用的最新特征。
- en: In this section, let's calculate the summary stats on the feature data and also
    feature correlation, which can be run on a schedule and sent to people of interest
    regularly so that they can take action based on it. As mentioned in the last note
    of the *Model training* section, the steps to fetch the features are the same
    as what was done in that section. Once you have all the features, the next step
    is to calculate the required stats.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将计算特征数据的摘要统计和特征相关性，这些可以按计划运行并定期发送给相关人员，以便他们可以根据这些信息采取行动。如“模型训练”部分的最后一条注释中提到的，获取特征步骤与该部分所做的是相同的。一旦您拥有了所有特征，下一步就是计算所需的统计量。
- en: Important Note
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Please note you may have to install additional libraries. Here is the URL for
    the notebook: [https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_feature_monitoring.ipynb](https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_feature_monitoring.ipynb).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可能需要安装额外的库。以下是笔记本的URL：[https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_feature_monitoring.ipynb](https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_feature_monitoring.ipynb)。
- en: 'The following code block calculates the summary stats on the feature data and
    also plots the correlation metrics:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块计算了特征数据的摘要统计并绘制了相关指标：
- en: '[PRE169]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: The preceding line of code produces a descriptive statistic of the dataset,
    which includes min, max, count, standard deviation, and more.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码生成了数据集的描述性统计信息，包括最小值、最大值、计数、标准差等。
- en: 'Apart from the descriptive statistics, the correlation matrix of the features
    is another thing that could be useful for all the ML models. The following code
    block calculates the correlation matrix of the features and plots a heatmap:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 除了描述性统计之外，特征的相关矩阵对于所有机器学习模型来说也是非常有用的。以下代码块计算了特征的相关矩阵并绘制了热图：
- en: '[PRE175]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'The preceding code block outputs the following heatmap:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块输出了以下热图：
- en: '![Figure 8.5 – Feature correlation'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 – 特征相关性'
- en: '](img/B18024_08_005.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B18024_08_005.jpg](img/B18024_08_005.jpg)'
- en: Figure 8.5 – Feature correlation
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 特征相关性
- en: 'You can add more statistics, in comparison to the previous run, alerts through
    emails, Slack notifications, and more. This could be in another notebook/Python
    script, which can be scheduled at the same or at a lesser frequency than the feature
    engineering notebook and have automated reports sent to you. Here is the link
    to the complete notebook: [https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_feature_monitoring.ipynb](https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_feature_monitoring.ipynb).'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的运行相比，您可以添加更多统计信息，通过电子邮件、Slack通知等方式发出警报。这可以放在另一个笔记本/Python脚本中，可以按与特征工程笔记本相同的频率或更低的频率进行调度，并将自动报告发送给您。以下是完整笔记本的链接：[https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_feature_monitoring.ipynb](https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_feature_monitoring.ipynb)。
- en: Important Note
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This is just an example of feature monitoring. There are more sophisticated
    statistics and metrics that can be used to determine the health of the features.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个特征监控的例子。还有更复杂的统计和指标可以用来确定特征的健康状况。
- en: Let's look at model monitoring next.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看模型监控。
- en: Model monitoring
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型监控
- en: 'Another important aspect of ML is model monitoring. There are different aspects
    of model monitoring: one could be system monitoring in the case of online models,
    where you monitor the latency, CPU, memory utilization, requests per minute of
    the model, and more. The other aspect is performance monitoring of the model.
    Again, there are many different ways of measuring performance. In this example,
    we will look at a simple classification report and the accuracy of the model.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习的另一个重要方面是模型监控。模型监控有不同的方面：对于在线模型，可能是系统监控，其中你监控延迟、CPU、内存利用率、每分钟模型请求等。另一个方面是模型性能监控。再次强调，有多种不同的方法来衡量性能。在这个例子中，我们将查看一个简单的分类报告和模型的准确率。
- en: To generate the classification report and calculate the accuracy of the live
    model, you need the prediction data and also the ground truth of the live data.
    For this example, let's say that the churn model is run once a week to generate
    the churn prediction and the ground truth will be available every 4 weeks from
    the day the model is run. That means if the model predicts customer x's churn
    as `True`, and within the next 4 weeks, if we lose the customer for any reason,
    the model predicted correctly; otherwise, the prediction was wrong. Hence, for
    every run of the model prediction, we need to wait for 4 weeks to have the ground
    truth.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成分类报告并计算实时模型的准确率，你需要预测数据和实时数据的真实值。对于这个例子，让我们假设流失率模型每周运行一次以生成流失预测，真实值将在模型运行后的每4周可用。这意味着如果模型预测客户x的流失为`True`，并且在接下来的4周内，如果我们因为任何原因失去了这个客户，那么模型预测正确；否则，预测是错误的。因此，对于每次模型预测的运行，我们需要等待4周才能获得真实值。
- en: For the simplicity of this exercise, let's also assume that the ground truth
    is filled back into the feature store every week. That means the feature store
    always has the latest ground truth. Now, our job is to fetch the prediction results
    that correspond to the latest features in the feature store (the prediction that
    was run 4 weeks ago) and calculate the required metrics. Let's do that next.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个练习的简便性，让我们也假设每周将真实值填充回特征存储库。这意味着特征存储库总是包含最新的真实值。现在，我们的任务是获取特征存储库中最新特征对应的预测结果（4周前运行的预测）并计算所需的指标。让我们接下来这么做。
- en: 'As mentioned before, the steps to fetch the latest feature from the feature
    store are the same as what we did in the last three sections. Once you have fetched
    the data from the feature store, the following code fetches the corresponding
    prediction results and merges the dataset:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，从特征存储库获取最新特征的步骤与我们在前三个部分中所做的是相同的。一旦从特征存储库获取了数据，下面的代码获取相应的预测结果并合并数据集：
- en: '[PRE196]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: The preceding code block should produce an output similar to the following snapshot.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码块应该产生类似于以下快照的输出。
- en: '![Figure 8.6 – Merged data for model monitoring'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 – 模型监控合并数据'
- en: '](img/B18024_08_006.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18024_08_006.jpg)'
- en: Figure 8.6 – Merged data for model monitoring
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 模型监控合并数据
- en: Important Note
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As we have assumed the prediction and ground truth to be 4 weeks apart, the
    previous code block tries to fetch the data that is 4 weeks from today. For the
    exercise, you can replace the `file_name` variable with the prediction output
    Parquet file.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们假设预测值和真实值之间相隔4周，之前的代码块尝试获取今天起4周后的数据。对于这个练习，你可以将`file_name`变量替换为预测输出的Parquet文件。
- en: 'Once you have the DataFrame in *Figure 8.6*, the following code block uses
    the `predicted_churn` and `churn` columns to produce the classification report
    and accuracy:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了*图8.6*中的DataFrame，下面的代码块使用`predicted_churn`和`churn`列来生成分类报告和准确率：
- en: '[PRE206]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: The previous code block produces output similar to the following.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码块产生的输出类似于以下内容。
- en: '![Figure 8.7 – Classification report'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 – 分类报告'
- en: '](img/B18024_08_007.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18024_08_007.jpg)'
- en: Figure 8.7 – Classification report
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 分类报告
- en: 'As mentioned before, this is sample monitoring. This can be scheduled at the
    same interval as the feature engineering notebook, though it would fail for the
    first four iterations due to the unavailability of the prediction data. Also make
    sure you adjust the prediction filename appropriately for your needs. Here is
    the URL for the complete notebook: [https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_model_monitoring.ipynb](https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_model_monitoring.ipynb).'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这是样本监控。它可以安排与特征工程笔记本相同的间隔进行，尽管由于预测数据的不可用，它会在前四次迭代中失败。同时，请确保根据您的需求适当地调整预测文件名。以下是完整笔记本的URL：[https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_model_monitoring.ipynb](https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/blob/main/Chapter08/Ch8_model_monitoring.ipynb)。
- en: With that, let's summarize what we have learned in this chapter.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些，让我们总结一下本章所学的内容。
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we set out with the aim of trying out a use case, namely telecom
    customer churn prediction using a dataset available from Kaggle. For this use
    case, we used a managed SageMaker Feature Store, which was introduced in the last
    chapter. In the exercise, we went through the different stages of ML, such as
    data processing, feature engineering, model training, and model prediction. We
    also looked at a feature monitoring and model monitoring example. The aim of this
    chapter was not model building but to showcase how to use a managed feature store
    for model building and the opportunities it opens for monitoring. To learn more
    about feature stores, the apply conference ([https://www.applyconf.com/](https://www.applyconf.com/))
    and feature store forum ([https://www.featurestore.org/](https://www.featurestore.org/))
    are good resources. To stay updated with new developments in ML and how other
    firms are solving similar problems, there are a few interesting podcasts, such
    as TWIML AI ([https://twimlai.com/](https://twimlai.com/)) and Data Skeptic (https://dataskeptic.com/).
    These resources should help you find more resources based on your area of interest
    in ML. With that, let's end this chapter and the book. I hope I was effective
    in conveying the importance of feature stores in the ML process and it was a good
    use of your time, and mine. Thank you!
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是尝试一个用例，即使用从Kaggle可获得的数据库进行电信客户流失预测。为此用例，我们使用了在上章中介绍的管理SageMaker特征存储。在练习中，我们经历了机器学习的不同阶段，如数据处理、特征工程、模型训练和模型预测。我们还查看了一个特征监控和模型监控的示例。本章的目标不是构建模型，而是展示如何使用管理特征存储进行模型构建以及它为监控带来的机会。要了解更多关于特征存储的信息，apply会议([https://www.applyconf.com/](https://www.applyconf.com/))和特征存储论坛([https://www.featurestore.org/](https://www.featurestore.org/))是很好的资源。为了跟上机器学习领域的新发展以及其他公司如何解决类似问题，有一些有趣的播客，例如TWIML
    AI ([https://twimlai.com/](https://twimlai.com/))和数据怀疑论者(https://dataskeptic.com/)。这些资源应该能帮助你根据你对机器学习的兴趣领域找到更多资源。带着这些，让我们结束本章和本书。我希望我有效地传达了特征存储在机器学习过程中的重要性，并且这是对你和我的时间的良好利用。谢谢！
