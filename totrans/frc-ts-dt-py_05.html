<html><head></head><body>
<div id="_idContainer141">
<h1 class="chapter-number" id="_idParaDest-59"><a id="_idTextAnchor254"/><a id="_idTextAnchor255"/><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-60"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.2.1">Working with Seasonality</span></h1>
<p><span class="koboSpan" id="kobo.3.1">One quality that sets time series apart from other datasets is that very often – but not always – the data has a certain rhythm to it. </span><span class="koboSpan" id="kobo.3.2">That rhythm may be yearly, possibly due to the Earth’s rotation around the Sun, or daily, if rooted in the Earth’s rotation around its axis. </span><span class="koboSpan" id="kobo.3.3">The tidal cycle follows the Moon’s rotation around </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">the Earth.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Traffic congestion follows the human activity cycle throughout the day and the 5-day workweek, followed by the 2-day weekend; financial activity follows the quarterly business cycle. </span><span class="koboSpan" id="kobo.5.2">Your own body follows cycles due to your heartbeat, breathing rate, and circadian rhythm. </span><span class="koboSpan" id="kobo.5.3">On very small physical and very short temporal scales, the vibration of atoms is a cause of periodicity in data. </span><span class="koboSpan" id="kobo.5.4">Prophet calls these </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">cycles </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.7.1">seasonalities</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, you will learn about all the different types of seasonalities Prophet fits by default, how to add new ones, and how to control them. </span><span class="koboSpan" id="kobo.9.2">In particular, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Understanding additive versus </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">multiplicative seasonality</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Controlling seasonality with the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Fourier order</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Adding </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">custom seasonalities</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Adding </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">conditional seasonalities</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Regularizing seasonality</span></span></li>
</ul>
<h1 id="_idParaDest-61"><a id="_idTextAnchor258"/><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.21.1">The data files and code for the examples in this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">at </span></span><a href="https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition"><span class="No-Break"><span class="koboSpan" id="kobo.23.1">https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.24.1">.</span></span></p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor260"/><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.25.1">Understanding additive versus multiplicative seasonality</span></h1>
<p><span class="koboSpan" id="kobo.26.1">In our </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.27.1">Mauna Loa example in </span><a href="B19630_02.xhtml#_idTextAnchor104"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.28.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.29.1">, </span><em class="italic"><span class="koboSpan" id="kobo.30.1">Getting Started with Prophet</span></em><span class="koboSpan" id="kobo.31.1">, the yearly seasonality</span><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.32.1"> was constant at all</span><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.33.1"> values along the </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.34.1">trend line. </span><span class="koboSpan" id="kobo.34.2">We added the values predicted by the seasonality curve to the values predicted by the trend curve to arrive at our forecast. </span><span class="koboSpan" id="kobo.34.3">There is an alternative mode of seasonality, though, where we can multiply the trend curve by the seasonality. </span><span class="koboSpan" id="kobo.34.4">Take a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">this figure:</span></span><a id="_idTextAnchor264"/></p>
<div>
<div class="IMG---Figure" id="_idContainer110">
<span class="koboSpan" id="kobo.36.1"><img alt="Figure 5.1 – Additive versus multiplicative seasonality" src="image/Fig_5.1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.37.1">Figure 5.1 – Additive versus multiplicative seasonality</span></p>
<p><span class="koboSpan" id="kobo.38.1">The upper curve demonstrates additive seasonality – the dashed lines that trace the bounds of the seasonality are parallel because the magnitude of seasonality does not change, only the trend does. </span><span class="koboSpan" id="kobo.38.2">In the lower curve, though, these two dashed lines are not parallel. </span><span class="koboSpan" id="kobo.38.3">Where the trend is low, the spread caused by seasonality is low; but where the trend is high, the spread caused by seasonality is high. </span><span class="koboSpan" id="kobo.38.4">This can be modeled with </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">multiplicative seasonality.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">Let’s look at a concrete example using the Air Passengers dataset introduced in the previous chapter. </span><span class="koboSpan" id="kobo.40.2">This data records the number of commercial airline passengers per month from 1949 to 1960. </span><span class="koboSpan" id="kobo.40.3">We will first model it using Prophet’s default </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">seasonality_mode</span></strong><span class="koboSpan" id="kobo.42.1">, the additive mode that we used with the Mauna Loa example, and then contrast it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">multiplicative mode.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">We will begin just as we did in the previous chapter, by importing the necessary libraries and loading the data into </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">a DataFrame</span><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.46.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.47.1">
import pandas as pd
import matplotlib.pyplot as plt
from prophet import Prophet
df = pd.read_csv('AirPassengers.csv')
df ['Month'] = pd.to_datetime(df['Month'])
df.columns = ['ds', 'y']</span></pre>
<p><span class="koboSpan" id="kobo.48.1">Let’s continue</span><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.49.1"> building our model. </span><span class="koboSpan" id="kobo.49.2">I am</span><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.50.1"> calling this one </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">model_a</span></strong><span class="koboSpan" id="kobo.52.1"> to indicate that it is our additive model; I’ll call the next model </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">model_m</span></strong><span class="koboSpan" id="kobo.54.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">for multiplicative:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.56.1">
model_a = Prophet(seasonality_mode='additive',
                  yearly_seasonality=4)
model_a.fit(df)
forecast_a = model_a.predict()
fig_a = model_a.plot(forecast_a)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.57.1">When we instantiated the Prophet object, we explicitly declared </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">seasonality_mode</span></strong><span class="koboSpan" id="kobo.59.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">'additive'</span></strong><span class="koboSpan" id="kobo.61.1"> for clarity’s sake. </span><span class="koboSpan" id="kobo.61.2">By default, if no </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">seasonality_mode</span></strong><span class="koboSpan" id="kobo.63.1"> is stated, then Prophet will automatically select </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">'additive'</span></strong><span class="koboSpan" id="kobo.65.1">. </span><span class="koboSpan" id="kobo.65.2">Also, note that we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">yearly_seasonality=4</span></strong><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">This merely sets </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.68.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">Fourier order</span></strong><span class="koboSpan" id="kobo.70.1"> for the curve, but don’t worry about this for now – we’ll go over it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">After </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.73.1">creating the Prophet model, we </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.74.1">fit and predicted it just as before in the Mauna Loa example, and then plotted the forecast. </span><span class="koboSpan" id="kobo.74.2">Note that in this example, though, we never created a future DataFrame – if no future DataFrame is sent to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">predict</span></strong><span class="koboSpan" id="kobo.76.1"> method, it simply creates predicted values for the historical data it received in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">fit</span></strong><span class="koboSpan" id="kobo.78.1"> method but no future predicted values. </span><span class="koboSpan" id="kobo.78.2">As we are only interested in seeing how Prophet has handled the seasonality, we don’t need a </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">future forecast.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">Here is the figure we </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">just create</span><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.82.1">d:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer111">
<span class="koboSpan" id="kobo.83.1"><img alt="Figure 5.2 – Air passengers with additive seasonality" src="image/Fig_5.2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.84.1">Figure 5.2 – Air passengers with additive seasonality</span></p>
<p><span class="koboSpan" id="kobo.85.1">As y</span><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.86.1">ou can see, early in</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.87.1"> the data, in </span><strong class="bold"><span class="koboSpan" id="kobo.88.1">1949</span></strong><span class="koboSpan" id="kobo.89.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">1951</span></strong><span class="koboSpan" id="kobo.91.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">1952</span></strong><span class="koboSpan" id="kobo.93.1">, Prophet’s predic</span><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.94.1">ted values (the solid line) have large seasonal swings that </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.95.1">are more extreme than the data (the dots) indicates. </span><span class="koboSpan" id="kobo.95.2">Later in the series, in </span><strong class="bold"><span class="koboSpan" id="kobo.96.1">1958</span></strong><span class="koboSpan" id="kobo.97.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.98.1">1959</span></strong><span class="koboSpan" id="kobo.99.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.100.1">1960</span></strong><span class="koboSpan" id="kobo.101.1">, Prophet’s predicted seasonality is less extreme than the data indicates. </span><span class="koboSpan" id="kobo.101.2">The seasonal spread of the data is increasing, but we have predicted it to be constant. </span><span class="koboSpan" id="kobo.101.3">That’s the mistake of choosing additive seasonality when multiplicative seasonality is required. </span><span class="koboSpan" id="kobo.101.4">Let’s run the model again, but this time, we will use </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">multiplicative seasonality:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.103.1">
model_m = Prophet(seasonality_mode='multiplicative',
                  yearly_seasonality=4)
model_m.fit(df)
forecast_m = model_m.predict()
fig_m = model_m.plot(forecast_m)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.104.1">We do everyt</span><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.105.1">hing the same as in the prev</span><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.106.1">ious example, except this time, we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">seasonality_mode='multiplicative'</span></strong><span class="koboSpan" id="kobo.108.1">. </span><span class="koboSpan" id="kobo.108.2">We can see this change reflected in the figure we </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">have produc</span><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.110.1">ed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer112">
<span class="koboSpan" id="kobo.111.1"><img alt="Figure 5.3 – Air passengers with multiplicative seasonality" src="image/Fig_5.3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.112.1">Figure 5.3 – Air passengers with multiplicative seasonality</span></p>
<p><span class="koboSpan" id="kobo.113.1">That’s a much</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.114.1"> better fit! </span><span class="koboSpan" id="kobo.114.2">Now, Prophet matches the growth of the seasonality swings with the growth of the overall trend. </span><span class="koboSpan" id="kobo.114.3">Also, compare the error estimates between </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.115.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.116.1">.2</span></em><span class="koboSpan" id="kobo.117.1"> and </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.118.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.119.1">.3</span></em><span class="koboSpan" id="kobo.120.1"> (the light-shaded area surrounding the solid line). </span><span class="koboSpan" id="kobo.120.2">Prophet shows wider uncertainty intervals when it attempts to fit additive seasonality to a series of data containing multiplicative seasonality. </span><span class="koboSpan" id="kobo.120.3">Prophet knows that it does not have a good fit in the former model and is less certain about </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">its predictions.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">There’</span><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.123.1">s one last thing here I want you to note. </span><span class="koboSpan" id="kobo.123.2">Let me sho</span><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.124.1">w you what it is by plotting </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">the components:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.126.1">
fig_a2 = model_a.plot_components(forecast_a)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.127.1">This plots the components for </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">model_a</span></strong><span class="koboSpan" id="kobo.129.1"> with </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">additive seasonal</span><a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.131.1">ity:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer113">
<span class="koboSpan" id="kobo.132.1"><img alt="Figure 5.4 – Components plot with additive seasonality" src="image/Fig_5.4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.133.1">Figure 5.4 – Components plot with additive seasonality</span></p>
<p><span class="koboSpan" id="kobo.134.1">And now, let’s plot </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.135.1">the components </span><a id="_idIndexMarker180"/><span class="No-Break"><span class="koboSpan" id="kobo.136.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">model_m</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.139.1">
fig_m2 = model_m.plot_components(forecast_m)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.140.1">C</span><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.141.1">ompare the following plot wi</span><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.142.1">th the plot shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.143.1">Figure</span><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.144.1"> 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.145.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer114">
<span class="koboSpan" id="kobo.147.1"><img alt="Figure 5.5 – Components plot with multiplicative seasonality" src="image/Fig_5.5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.148.1">Figure 5.5 – Components plot with multiplicative seasonality</span></p>
<p><span class="koboSpan" id="kobo.149.1">They look almost identical. </span><span class="koboSpan" id="kobo.149.2">The trend is the same, starting in </span><strong class="bold"><span class="koboSpan" id="kobo.150.1">1949</span></strong><span class="koboSpan" id="kobo.151.1"> just above </span><strong class="bold"><span class="koboSpan" id="kobo.152.1">100</span></strong><span class="koboSpan" id="kobo.153.1"> and rising to just below </span><strong class="bold"><span class="koboSpan" id="kobo.154.1">500</span></strong><span class="koboSpan" id="kobo.155.1"> by </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">1961</span></strong><span class="koboSpan" id="kobo.157.1">, with a slight kink in </span><strong class="bold"><span class="koboSpan" id="kobo.158.1">1954</span></strong><span class="koboSpan" id="kobo.159.1"> where the trend accelerates. </span><span class="koboSpan" id="kobo.159.2">The yearly seasonality behaves as we might expect, with the peak number of air passengers occurring in the summer and smaller local peaks over the Christmas holidays and spring break. </span><span class="koboSpan" id="kobo.159.3">The difference between the two charts is the </span><em class="italic"><span class="koboSpan" id="kobo.160.1">y a</span></em><span class="koboSpan" id="kobo.161.1">xis of the </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">seasonality curve.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">In the </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.164.1">additive model, the </span><em class="italic"><span class="koboSpan" id="kobo.165.1">y</span></em><span class="koboSpan" id="kobo.166.1">-axis values are absolute</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.167.1"> numbers. </span><span class="koboSpan" id="kobo.167.2">In the multiplicative model, they are a percentage. </span><span class="koboSpan" id="kobo.167.3">This is because, in the additive seasonality mode, the seasonality is modeled as an additional factor to the trend, with values simply being added to or subtracted from it. </span><span class="koboSpan" id="kobo.167.4">But in the multiplicative seasonality mode, the seasonality represents a relative deviation from the trend, so the magnitude of the seasonality effect will depend on what value the trend is predicting at that point; the seasonality effect is a percentage of </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">the trend.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.169.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.170.1">When your data represents a count of something over time, such as the count of airline passengers each month, you will very often model it with multiplicative seasonality. </span><span class="koboSpan" id="kobo.170.2">Using additive seasonality can cause negative values to be predicted (negative 100 passengers per month, for example, is not possible), whereas multiplicative seasonality will merely shrink values closer </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">to zero.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">Choosing </span><a id="_idIndexMarker183"/><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.173.1">additive versus multiplicative</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.174.1"> seasonality can be a bit tricky at first, but if you just rem</span><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.175.1">ember the insight that the seasonality may be an absolute factor or a relative factor and observe whether the </span><em class="italic"><span class="koboSpan" id="kobo.176.1">spread</span></em><span class="koboSpan" id="kobo.177.1"> of the data is constant or not, you should have no trouble with </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">your models.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">Now that you understand the difference between these two seasonality modes, let’s apply it to a new dataset, the Divvy bike share, and continue learning about seasonality </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">in Prophet.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">In many examples throughout this book, we will be creating examples using data from the Divvy bike share program in Chicago. </span><span class="koboSpan" id="kobo.181.2">In the previous chapter, we used hourly Divvy data, but in this section, we will use </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">daily data.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.183.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.184.1">We used the hourly Divvy data in </span><a href="B19630_04.xhtml#_idTextAnchor197"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.185.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.186.1">, </span><em class="italic"><span class="koboSpan" id="kobo.187.1">Handling Non-Daily Data</span></em><span class="koboSpan" id="kobo.188.1">, to demonstrate both the </span><em class="italic"><span class="koboSpan" id="kobo.189.1">daily</span></em><span class="koboSpan" id="kobo.190.1"> component plot and how to work with regular gaps in data; we will use the hourly data again in this chapter when we look at conditional seasonalities. </span><span class="koboSpan" id="kobo.190.2">But otherwise, throughout this book, we will be using the daily Divvy data, which is presented here. </span><span class="koboSpan" id="kobo.190.3">In these cases, we don’t need the extra granularity of the hourly data, and changing to daily data reduces the processing time from minutes down to seconds. </span><span class="koboSpan" id="kobo.190.4">Furthermore, the daily dataset has associated weather and temperature columns, which are lacking in the hourly dataset, which we will use in </span><a href="B19630_09.xhtml#_idTextAnchor599"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.191.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.192.1">, </span><em class="italic"><span class="koboSpan" id="kobo.193.1">Including </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.194.1">Additional Regressors</span><a id="_idTextAnchor282"/></em></span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">Here is what </span><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.197.1">the daily Divvy data </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">loo</span><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.199.1">ks</span><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.200.1"> like:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer115">
<span class="koboSpan" id="kobo.201.1"><img alt="Figure 5.6 – Number of rides per day on Divvy" src="image/Fig_5.6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.202.1">Figure 5.6 – Number of rides per day on Divvy</span></p>
<p><span class="koboSpan" id="kobo.203.1">This is count </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.204.1">data because it represents the </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.205.1">number of rides each day, and you can also see that the magnitude of the seasonality is growing with the trend (if we plotted those dotted lines from </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.206.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.207.1">.1</span></em><span class="koboSpan" id="kobo.208.1">, tracing the upper and lower bounds of the data, the lines would diverge). </span><span class="koboSpan" id="kobo.208.2">As we just learned, these are an indication of multiplicative seasonality, so let’s be sure to set that when instantiating our model. </span><span class="koboSpan" id="kobo.208.3">We imported the necessary Python libraries in the previous example, so we can begin this example by loading </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">This dataset contains some additional columns for weather and temperature conditions, which we will use to enrich our forecast in </span><a href="B19630_09.xhtml#_idTextAnchor599"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.211.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.212.1">, </span><em class="italic"><span class="koboSpan" id="kobo.213.1">Including Additional Regressors</span></em><span class="koboSpan" id="kobo.214.1">. </span><span class="koboSpan" id="kobo.214.2">Once we have loaded the data, we can see these </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">additional columns:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.216.1">
df = pd.read_csv('divvy_daily.csv')
df.head</span><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.217.1">()</span></pre>
<p><span class="koboSpan" id="kobo.218.1">Running this command in</span><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.219.1"> a Jupyter notebook or IPython instance reveals the </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">following D</span><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.221.1">ataFrame:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer116">
<span class="koboSpan" id="kobo.222.1"><img alt="Figure 5.7 – The Divvy DataFrame" src="image/Fig_5.7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.223.1">Figure 5.7 – The Divvy DataFrame</span></p>
<p><span class="koboSpan" id="kobo.224.1">For now, though, we only need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">date</span></strong><span class="koboSpan" id="kobo.226.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">rides</span></strong><span class="koboSpan" id="kobo.228.1"> columns. </span><span class="koboSpan" id="kobo.228.2">Let’s load those into our Prophet DataFrame with the appropriate column names. </span><span class="koboSpan" id="kobo.228.3">We will work with </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">weather</span></strong><span class="koboSpan" id="kobo.230.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">temperature</span></strong><span class="koboSpan" id="kobo.232.1"> in </span><a href="B19630_09.xhtml#_idTextAnchor599"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.233.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.234.1">, </span><em class="italic"><span class="koboSpan" id="kobo.235.1">Including </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.236.1">Additional Regressors</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
df = df[['date', 'rides']]
df['date'] = pd.to_datetime(df['date'])
df.columns = ['ds', 'y']</span></pre>
<p><span class="koboSpan" id="kobo.239.1">As before, we need to create an instance of the Prophet class before calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">fit</span></strong><span class="koboSpan" id="kobo.241.1"> method. </span><span class="koboSpan" id="kobo.241.2">Note that we are setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">seasonality_mode</span></strong><span class="koboSpan" id="kobo.243.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">'multiplicative</span><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.245.1">'</span></strong><span class="koboSpan" id="kobo.246.1"> because we not</span><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.247.1">iced when plotting the raw data that the seasonality fluctuations grew with the increasing trend. </span><span class="koboSpan" id="kobo.247.2">After fitting the model, we will again create a future DataFrame, with</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.248.1"> a 1-year forecast, and then </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.249.1">call </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">predict</span></strong><span class="koboSpan" id="kobo.251.1"> to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">forecast</span></strong><span class="koboSpan" id="kobo.253.1"> DataFrame and send it to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">plot</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.255.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.256.1">
model = Prophet(seasonality_mode='multiplicative')
model.fit(df)
future = model.make_future_dataframe(periods=365)
forecast = model.predict(future)
fig = model.plot(forecast)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.257.1">After running that code, you should find that Prophet has created the </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">follo</span><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.259.1">wing plot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer117">
<span class="koboSpan" id="kobo.260.1"><img alt="Figure 5.8 – Divvy f﻿orecast" src="image/Fig_5.8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.261.1">Figure 5.8 – Divvy f</span><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.262.1">orecast</span></p>
<p><span class="koboSpan" id="kobo.263.1">We can se</span><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.264.1">e that</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.265.1"> the predicted trend is </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.266.1">indeed increasing along with the actual data and that the yearly seasonality also matches. </span><span class="koboSpan" id="kobo.266.2">Now, let’s plot our components and see what </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">they reveal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
fig2 = model.plot_components(forecast)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.269.1">As you can see in the output plot, Prophet has isolated three components in this dataset: </span><strong class="bold"><span class="koboSpan" id="kobo.270.1">trend</span></strong><span class="koboSpan" id="kobo.271.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.272.1">weekly</span></strong><span class="koboSpan" id="kobo.273.1"> seasonality, and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.274.1">yearly</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.275.1"> s</span><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.276.1">easonality:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer118">
<span class="koboSpan" id="kobo.277.1"><img alt="Figure 5.9 – Divvy components plot" src="image/Fig_5.9.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.278.1">Figure 5.9 – Divvy components plot</span></p>
<p><span class="koboSpan" id="kobo.279.1">By default, Prophet</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.280.1"> will identify a </span><strong class="bold"><span class="koboSpan" id="kobo.281.1">yearly</span></strong><span class="koboSpan" id="kobo.282.1"> seasonality</span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.283.1"> whenever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">'ds'</span></strong><span class="koboSpan" id="kobo.285.1"> column contains at least 2 full years of data. </span><strong class="bold"><span class="koboSpan" id="kobo.286.1">weekly</span></strong><span class="koboSpan" id="kobo.287.1"> seasonality will be included when there are at least 2 weeks of data and the spacing between dates is less than 7 days. </span><span class="koboSpan" id="kobo.287.2">There is also a default daily seasonality, which we saw in the previous chapter, which would be included if the dataset both contained at least 2 days of data (which of course in this case it does) and the spacing between the rows in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">'ds'</span></strong><span class="koboSpan" id="kobo.289.1"> column was less than 1 day (which does not apply in </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">this case).</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">The trend linearly increases relatively rapidly for the first 2 years but then bends and slows slightly for the remaining 2 years, and the forecasted year continues to follow this slope. </span><span class="koboSpan" id="kobo.291.2">We can see that the Divvy network has grown in average usage over this period from about 3,500 rides per day in 2014 to about 8,500 per day by the end</span><a id="_idTextAnchor295"/> <span class="No-Break"><span class="koboSpan" id="kobo.292.1">of 2018.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">The weekly seasonality</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.294.1"> shows that there are about 30% fewer rides per day on the we</span><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.295.1">ekends – maybe all these riders are work commuters – with rides on the weekdays being 10-20% higher than the trend would indicate. </span><span class="koboSpan" id="kobo.295.2">This fits our intuition that weekdays and weekends could reasonably show a </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">different pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">Now, looking at the yearly seasonality</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.298.1"> reveals that rides in the summer are about 60% higher than the trend, while rides in the winter are 80% lower. </span><span class="koboSpan" id="kobo.298.2">Again, this also intuitively makes sense. </span><span class="koboSpan" id="kobo.298.3">Those work commuters are going to drive or take public transport when the weather gets cold </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">and rainy.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">You’ll notice that this yearly seasonality curve is quite </span><em class="italic"><span class="koboSpan" id="kobo.301.1">wavy</span></em><span class="koboSpan" id="kobo.302.1">, just as we noticed in the previous chapter with the hourly Divvy data. </span><span class="koboSpan" id="kobo.302.2">You may have expected a much smoother curve, not one with so many inflection points. </span><span class="koboSpan" id="kobo.302.3">This is a result of our yearly seasonality being too flexible – it has too </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.303.1">many </span><strong class="bold"><span class="koboSpan" id="kobo.304.1">degrees of freedom</span></strong><span class="koboSpan" id="kobo.305.1"> or too many mathematical parameters controlling the curve. </span><span class="koboSpan" id="kobo.305.2">In Prophet, the number of parameters controlling</span><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.306.1"> the seasonality curve is </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.307.1">called t</span><a id="_idTextAnchor298"/><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.308.1">he </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.309.1">Fourier order</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">.</span></span></p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.311.1">Controlling seasonality with the Fourier order</span></h1>
<p><span class="koboSpan" id="kobo.312.1">Seasonality is at the </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.313.1">he</span><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.314.1">art of how Prophet works, and </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.315.1">Fourier series are used to model seasonality. </span><span class="koboSpan" id="kobo.315.2">To understand what a Fourier series is, and how the Fourier order relates to it, I’ll use an analogy from </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">linear regression.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">You may know that increasing the order of a polynomial equation in linear regression will always improve your goodness of fit. </span><span class="koboSpan" id="kobo.317.2">For example, the simple linear regression equation is </span><span class="koboSpan" id="kobo.318.1"><img alt="" src="image/B19630_05_F01.png"/></span><span class="koboSpan" id="kobo.319.1"> , with </span><span class="koboSpan" id="kobo.320.1"><img alt="" src="image/019630_05_F02.png"/></span><span class="koboSpan" id="kobo.321.1"> being the slope of the line and </span><span class="koboSpan" id="kobo.322.1"><img alt="" src="image/019630_05_F03.png"/></span><span class="koboSpan" id="kobo.323.1"> being the </span><span class="koboSpan" id="kobo.324.1"><img alt="" src="image/019630_05_F04.png"/></span><span class="koboSpan" id="kobo.325.1">-intercept. </span><span class="koboSpan" id="kobo.325.2">Increasing the order of your equation to, say, </span><span class="koboSpan" id="kobo.326.1"><img alt="" src="image/019630_05_F05.png"/></span><span class="koboSpan" id="kobo.327.1"> will always improve your fit, at the risk of overfitting and capturing noise. </span><span class="koboSpan" id="kobo.327.2">You can always achieve an </span><span class="koboSpan" id="kobo.328.1"><img alt="" src="image/019630_05_F06.png"/></span><span class="koboSpan" id="kobo.329.1"> value of 1 (perfect fit) by arbitrarily increasing the order of your polynomial equation higher and high</span><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.330.1">er. </span><span class="koboSpan" id="kobo.330.2">The following figure illustra</span><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.331.1">tes how higher-order fits start to become quite unrealistic and </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">overfit, though:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer125">
<span class="koboSpan" id="kobo.333.1"><img alt="Figure 5.10 – Linear regression with higher-order polynomials" src="image/Fig_5.10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.334.1">Figure 5.10 – Linear regression with higher-order polynomials</span></p>
<p><span class="koboSpan" id="kobo.335.1">The</span><a id="_idIndexMarker199"/> <strong class="bold"><span class="koboSpan" id="kobo.336.1">Linear</span></strong><span class="koboSpan" id="kobo.337.1"> solid line does get the upward</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.338.1"> trend of the data correct, but it seems to be missing some subtle detail. </span><span class="koboSpan" id="kobo.338.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">Quadratic</span></strong><span class="koboSpan" id="kobo.340.1"> dashed line is a better fit (indeed, this data was simulated from a quadratic equation with random noise). </span><span class="koboSpan" id="kobo.340.2">However, the </span><strong class="bold"><span class="koboSpan" id="kobo.341.1">Quintic</span></strong><span class="koboSpan" id="kobo.342.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.343.1">Decic</span></strong><span class="koboSpan" id="kobo.344.1"> curves are overfitting to the random noise. </span><span class="koboSpan" id="kobo.344.2">If we sample some more data points from this distribution, they will most likely cause the </span><strong class="bold"><span class="koboSpan" id="kobo.345.1">Quintic</span></strong><span class="koboSpan" id="kobo.346.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.347.1">Decic</span></strong><span class="koboSpan" id="kobo.348.1"> curves to radically change to fit the new data, whereas the </span><strong class="bold"><span class="koboSpan" id="kobo.349.1">Linear</span></strong><span class="koboSpan" id="kobo.350.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.351.1">Quadratic</span></strong><span class="koboSpan" id="kobo.352.1"> curves will only shift slightly. </span><span class="koboSpan" id="kobo.352.2">We may say that the order of a polynomial is proportional to the number of bends the curve can have to fit </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">A Fourier series is simply a sum of sine waves. </span><span class="koboSpan" id="kobo.354.2">By changing the shape of these individual sine waves – the amplitude, or height of the wave; the period, or distance from peak to peak; and the p</span><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.355.1">hase, or where along th</span><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.356.1">e length of the wave the cycle begins – we can create a new and very complex </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">wave shape.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">In the linear </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.359.1">domain, we changed the order of the </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.360.1">polynomial to control the amount of flexibility the curve has, and we changed the </span><em class="italic"><span class="koboSpan" id="kobo.361.1">β</span></em><span class="koboSpan" id="kobo.362.1"> coefficients to control the actual shape of the curve. </span><span class="koboSpan" id="kobo.362.2">Similarly, in the periodic domain, we change the number of sine waves in our Fourier series – this is the Fourier order – to control the flexibility of the final curve and we (or, more accurately, Prophet’s fitting equations) change the amplitude, period, and phase of the individual waves to control the actual shape of our final curve. </span><span class="koboSpan" id="kobo.362.3">You can see how this summation works in the </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">following figur</span><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.364.1">e:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer126">
<span class="koboSpan" id="kobo.365.1"><img alt="Figure 5.11 – Fourier series of order 4" src="image/Fig_5.11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.366.1">Figure 5.11 – Fourier series of order 4</span></p>
<p><span class="koboSpan" id="kobo.367.1">The solid line is simply the sum of each of the four sine waves. </span><span class="koboSpan" id="kobo.367.2">By arbitrarily increasing the Fourier order </span><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.368.1">in our model, we can always achieve</span><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.369.1"> a perfect fit for any set of data. </span><span class="koboSpan" id="kobo.369.2">But just as in the linear domain, this approach will inevitably lead </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">to overfitting.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Remember in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.372.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.373.1">.9</span></em><span class="koboSpan" id="kobo.374.1"> when we plotted the components of the Divvy forecast and the yearly seasonality was too wavy? </span><span class="koboSpan" id="kobo.374.2">This is the result of the Fourier order being too high. </span><span class="koboSpan" id="kobo.374.3">By default, Prophet fits yearly seasonality with an order of 10, weekly seasonality with an order of 3, and daily seasonality (if sub-daily data is provided, of course) with an order of 4. </span><span class="koboSpan" id="kobo.374.4">Usually, these defaults work very well and no tuning is needed. </span><span class="koboSpan" id="kobo.374.5">However, in Divvy’s case, we do need to reduce the Fourier order of the yearly seasonality to achieve a better fit with the data. </span><span class="koboSpan" id="kobo.374.6">Let’s see how to </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">do that.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">We already </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.377.1">have our necessary libraries</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.378.1"> imported and the data loaded into our </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">df</span></strong><span class="koboSpan" id="kobo.380.1"> DataFrame from the previous example, so to continue, we need to instantiate a new Prophet object with a modified yearly seasonality. </span><span class="koboSpan" id="kobo.380.2">As before, we will set the seasonality mode to multiplicative, but this time, we will include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">yearly_seasonality</span></strong><span class="koboSpan" id="kobo.382.1"> argument and set it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">4</span></strong><span class="koboSpan" id="kobo.384.1">. </span><span class="koboSpan" id="kobo.384.2">This is where we set the </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">Fourier order.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">You may experiment with different values on your own; I have found </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">4</span></strong><span class="koboSpan" id="kobo.388.1"> to provide a clean curve without much flexibility in most cases, which is what I want here. </span><span class="koboSpan" id="kobo.388.2">Similarly, if we wanted to change the Fourier order of </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">weekly_seasonality</span></strong><span class="koboSpan" id="kobo.390.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">daily_seasonality</span></strong><span class="koboSpan" id="kobo.392.1">, we would do </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">so here.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">After instantia</span><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.395.1">ting our model, we merely need to fit it to</span><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.396.1"> the data to plot the seasonality. </span><span class="koboSpan" id="kobo.396.2">There is no need to predict in </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">this case:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.398.1">
model = Prophet(seasonality_mode='multiplicative',
                yearly_seasonality=4)
model.fit(df)</span></pre>
<p><span class="koboSpan" id="kobo.399.1">We will use a new function here to plot just the yearly component – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">plot_yearly</span></strong><span class="koboSpan" id="kobo.401.1"> function from Prophet’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">plot</span></strong><span class="koboSpan" id="kobo.403.1"> package. </span><span class="koboSpan" id="kobo.403.2">We need to import </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">it first:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.405.1">
from prophet.plot import plot_yearly</span></pre>
<p><span class="koboSpan" id="kobo.406.1">Note that there is also a </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">plot_weekly</span></strong><span class="koboSpan" id="kobo.408.1"> function, which operates much the same way. </span><span class="koboSpan" id="kobo.408.2">Both functions require the first argument to be the model; here, we will also include the optional figure size argument so that it matches the scale of our previous plot contained in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.409.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.410.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.412.1">
fig3 = plot_yearly(model, figsize=(10.5, 3.25))
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.413.1">Compare this output with the yearly seasonality curve in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.414.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.415.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer127">
<span class="koboSpan" id="kobo.417.1"><img alt="Figure 5.12 – Divvy yearly seasonality with a Fourier order of 4" src="image/Fig_5.12.jpg"/></span>
</div>
</div>
<p class="IMG---Figure"><a id="_idTextAnchor311"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.418.1">Figure 5.12 – Divvy yearly seasonality with a Fourier order of 4</span></p>
<p><span class="koboSpan" id="kobo.419.1">We have </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.420.1">successfully eliminated the waviness of our</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.421.1"> previous attempt, while still maintaining the clear shape of the seasonality. </span><span class="koboSpan" id="kobo.421.2">This seems much </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">more reasonable!</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">So far, we have only</span><a id="_idTextAnchor312"/><span class="koboSpan" id="kobo.424.1"> been working with Prophet’s</span><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.425.1"> default seasonalities. </span><span class="koboSpan" id="kobo.425.2">However, there are many cyclic datasets out there with periods that don’t fall neatly into the yearly, weekly, or daily seasonality bins. </span><span class="koboSpan" id="kobo.425.3">Prophet supports custom seasonalities precisely for this purpose. </span><span class="koboSpan" id="kobo.425.4">Let’s check them out in the </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">next section.</span></span><a id="_idTextAnchor314"/><a id="_idTextAnchor315"/></p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.427.1">Adding custom seasonalities</span></h1>
<p><span class="koboSpan" id="kobo.428.1">So far, the only </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.429.1">seasonalities we have worked with are the defaults in Prophet: yearly, weekly, and daily. </span><span class="koboSpan" id="kobo.429.2">But there is no reason to limit ourselves to these seasonalities. </span><span class="koboSpan" id="kobo.429.3">If your data contains a cycle that is either longer or shorter than the 365.25-day yearly cycle, the 7-day weekly cycle, or the 1-day daily cycle, Prophet makes it easy to model this </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">seasonality yourself.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">A great example of a non-standard seasonality is the 11-year cycle of sunspots. </span><span class="koboSpan" id="kobo.431.2">Sunspots are regions on the Sun’s surface that temporarily exhibit a much-reduced temperature, and hence appear much darker than </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">surrounding areas.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">Beginning in approximately 1609, Galileo Galilei began systematic observation of sunspots and over the last 400+ years, this phenomenon has been constantly recorded. </span><span class="koboSpan" id="kobo.433.2">Sunspots represent the longest continuously recorded time series of any natural phenomenon. </span><span class="koboSpan" id="kobo.433.3">Through these observations, scientists have identified a quasi-periodic cycle of 11 years during which the frequency of sunspot occurrences varies. </span><span class="koboSpan" id="kobo.433.4">They say </span><em class="italic"><span class="koboSpan" id="kobo.434.1">quasi</span></em><span class="koboSpan" id="kobo.435.1">-periodic because the cycle length seems to vary from cycle to cycle – it isn’t perfectly 11 years eac</span><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.436.1">h time. </span><span class="koboSpan" id="kobo.436.2">The average cycle length is 11 years, though, so that is what we will use to </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">model it.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.439.1">Solar Influences Data analysis Center</span></strong><span class="koboSpan" id="kobo.440.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.441.1">SIDC</span></strong><span class="koboSpan" id="kobo.442.1">), a </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.443.1">departme</span><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.444.1">nt of the Royal Observatory of </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.445.1">Belgium in Brussels, provides a dataset of sunspot activity from 1750 to the present day in</span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.446.1"> their </span><strong class="bold"><span class="koboSpan" id="kobo.447.1">World Data Center – Sunspot Index and Long-term Solar Observations</span></strong><span class="koboSpan" id="kobo.448.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.449.1">WDC-SILSO</span></strong><span class="koboSpan" id="kobo.450.1">) project. </span><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.451.1">This dataset will be a good demonstration of how to add a new seasonality to Prophet. </span><span class="koboSpan" id="kobo.451.2">We will begin by loading </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">our data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.453.1">
df = pd.read_csv('sunspots.csv',\
                 usecols=['Date', 'Monthly Mean Total\
                          Sunspot Number'])
df['Date'] = pd.to_datetime(df['Date'])
df.columns = ['ds', 'y']</span></pre>
<p><span class="koboSpan" id="kobo.454.1">Let’s visualize this data to see how </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">it loo</span><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.456.1">ks:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer128">
<span class="koboSpan" id="kobo.457.1"><img alt="Figure 5.13 – Number of sunspots per month" src="image/Fig_5.13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.458.1">Figure 5.13 – Number of sunspots per month</span></p>
<p><span class="koboSpan" id="kobo.459.1">The </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.460.1">data appears rather noisy; there appear to be several outliers and the cycle is not perfectly clean. </span><span class="koboSpan" id="kobo.460.2">Ther</span><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.461.1">e is quite a lot of variation in the peak of each cycle. </span><span class="koboSpan" id="kobo.461.2">To see how Prophet will handle this data, we first need to instantiate our model. </span><span class="koboSpan" id="kobo.461.3">This is count data, so we will choose </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">multiplicative seasonality.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">Another consideration we will take is that the Sun is so large that it hardly feels the minuscule tug of Earth’s gravity as we orbit around our star; therefore, the Sun does not experience what we would call a yearly seasonality at all. </span><span class="koboSpan" id="kobo.463.2">We will instruct Prophet not to attempt to fit a yearly seasonality. </span><span class="koboSpan" id="kobo.463.3">Prophet won’t attempt a weekly or daily seasonality because we are providing </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">monthly data.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">We learned how to adjust the Fourier order of the yearly seasonality earlier in this chapter by passing an integer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">yearly_seasonality</span></strong><span class="koboSpan" id="kobo.467.1"> argument. </span><span class="koboSpan" id="kobo.467.2">This is the same argument we use to turn off a default seasonality; simply pass a Boolean instead. </span><span class="koboSpan" id="kobo.467.3">We pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">yearly_seasonality=False</span></strong><span class="koboSpan" id="kobo.469.1"> to instruct Prophet not to fit </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">yearly seasonality:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.471.1">
model = Prophet(seasonality_mode='multiplicative',
                yearly_seasonality=False)</span></pre>
<p><span class="koboSpan" id="kobo.472.1">Once our model has been instantiated, we can add seasonalities. </span><span class="koboSpan" id="kobo.472.2">We can do this with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">add_seasonality</span></strong><span class="koboSpan" id="kobo.474.1"> method. </span><span class="koboSpan" id="kobo.474.2">This method requires that we pass arguments for the name of the seasonality (we’ll call this one </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">'11-year cycle'</span></strong><span class="koboSpan" id="kobo.476.1">), the period (11 years times 365.25 days, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">period</span></strong><span class="koboSpan" id="kobo.478.1"> is stated in days), and the Fourier order (we’ll use </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">5</span></strong><span class="koboSpan" id="kobo.480.1"> in this case, but feel free to experiment). </span><span class="koboSpan" id="kobo.480.2">This is how it all </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">looks together:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.482.1">
model.add_seasonality(name='11-year cycle',
                      period=11 * 365.25,
                      fourier_order=5)</span></pre>
<p><span class="koboSpan" id="kobo.483.1">Stating the period can be tricky; just remember that it is always counted in days. </span><span class="koboSpan" id="kobo.483.2">So, a seasonality lo</span><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.484.1">nger than a day will have a number greater than 1 and a seasonality shorter than a day will have a period less </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">than 1.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">The rest</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.487.1"> of this example is exactly as in previous ones; we fit on the training DataFrame, create a future DataFrame, and then predict </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">on it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.489.1">
model.fit(df)
future = model.make_future_dataframe(periods=240, freq='M')
forecast = model.predict(future)
fig2 = model.plot_components(forecast)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.490.1">Let’s inspect the components plot to see what </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">we created:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer129">
<span class="koboSpan" id="kobo.492.1"><img alt="Figure 5.14 – Sunspots components plot" src="image/Fig_5.14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.493.1">Figure 5.14 – Sunspots components plot</span></p>
<p><span class="koboSpan" id="kobo.494.1">The plot </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.495.1">shows just the trend and the 11-year cycle, which is exactly what we expected. </span><span class="koboSpan" id="kobo.495.2">The trend has a saw</span><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.496.1">tooth shape; in fact, scientists have named that trough around </span><strong class="bold"><span class="koboSpan" id="kobo.497.1">1814</span></strong><span class="koboSpan" id="kobo.498.1"> the </span><em class="italic"><span class="koboSpan" id="kobo.499.1">Dalton Minimum</span></em><span class="koboSpan" id="kobo.500.1">, named after the English meteorologist John Dalton. </span><span class="koboSpan" id="kobo.500.2">The peak during the 1950s is called the </span><em class="italic"><span class="koboSpan" id="kobo.501.1">Modern Maximum</span></em><span class="koboSpan" id="kobo.502.1">. </span><span class="koboSpan" id="kobo.502.2">But it’s the 11-year cycle that we’re interested </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">in here.</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">With this irregular cycle, Prophet plots the </span><em class="italic"><span class="koboSpan" id="kobo.505.1">x </span></em><span class="koboSpan" id="kobo.506.1">axis in days, so each tick is about 1.5 years later than the previous tick. </span><span class="koboSpan" id="kobo.506.2">The whole cycle is indeed 11 years. </span><span class="koboSpan" id="kobo.506.3">We can see that the low point is a bit </span><em class="italic"><span class="koboSpan" id="kobo.507.1">flatter</span></em><span class="koboSpan" id="kobo.508.1"> than the high point and has about 60% fewer sunspots than the average. </span><span class="koboSpan" id="kobo.508.2">The high point sees about 80% more sunspots </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">than average.</span></span></p>
<p><span class="koboSpan" id="kobo.510.1">To see all of the seasonalities that your model currently has, as well as the parameters controlling that seasonality, simply call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">seasonalities</span></strong><span class="koboSpan" id="kobo.512.1"> attribute of </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">the model:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.514.1">
model.seasonalities</span></pre>
<p><span class="koboSpan" id="kobo.515.1">This</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.516.1"> outputs a dictionary where the keys are the names of the seasonalities and the values are the parameters. </span><span class="koboSpan" id="kobo.516.2">In this example, where we only have one seasonality, this is the </span><a id="_idTextAnchor324"/><span class="No-Break"><span class="koboSpan" id="kobo.517.1">output dictionary:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.518.1">
OrderedDict([('11-year cycle',
              {'period': 4017.75,
               'fourier_order': 5,
               'prior_scale': 10.0,
               'mode': 'multiplicative',
               'condition_name': None})])</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.519.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.520.1">When specifying a period for your seasonality, it is always specified in days. </span><span class="koboSpan" id="kobo.520.2">So, a 10-year seasonality will have a period of 10 (years) x 365.25 (days per year) = 3652.5 days. </span><span class="koboSpan" id="kobo.520.3">An hourly seasonality would be 1 (day) / 24 (hours per day) = </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">0.04167 days.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.522.1">Be careful not to confuse the period of seasonality with the period used in </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">make_future_dataframe</span></strong><span class="koboSpan" id="kobo.524.1">. </span><span class="koboSpan" id="kobo.524.2">The period in seasonality is always specified in days, while the period in </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">make_future_dataframe</span></strong><span class="koboSpan" id="kobo.526.1"> is specified by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">freq</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.528.1"> argument.</span></span></p>
<p><span class="koboSpan" id="kobo.529.1">Adding a seasonality to Prophet that doesn’t exist in the data can cause Prophet to be very slow to fit, as it struggles to find a pattern where none exists. </span><span class="koboSpan" id="kobo.529.2">This can harm your forecast as Prophet will eventually fit the non-existent seasonality to noise. </span><span class="koboSpan" id="kobo.529.3">However, other seasonalities you may find yourself frequently adding include an hourly seasonality, if your data is measured per minute, </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.531.1">
model.add_seasonality(name='hourly',
                      # an hour is 0.04167 days
                      period=1 / 24,
                      # experiment with this value
                      fourier_order=5)</span></pre>
<p><span class="koboSpan" id="kobo.532.1">Seasonality for the quarterly business cycle would be created in the </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">following manner:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
model.add_seasonality(name='quarterly',
                      # a quarter is 91.3125 days
                      period=365.25 / 4
                      # experiment with this value
                      fourier_order=5)</span></pre>
<p><span class="koboSpan" id="kobo.535.1">That’s h</span><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.536.1">ow</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.537.1"> you add custom seasonalities! </span><span class="koboSpan" id="kobo.537.2">We’ll be using this </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">add_seasonality</span></strong><span class="koboSpan" id="kobo.539.1"> method a bit more in this chapter, starting with the next section about seasonalities that depend on </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">other f</span><a id="_idTextAnchor326"/><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.541.1">actors.</span></span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor328"/><span class="koboSpan" id="kobo.542.1">Adding conditional seasonalities</span></h1>
<p><span class="koboSpan" id="kobo.543.1">Suppose you work for </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.544.1">a utility company in a college town and are tasked with forecas</span><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.545.1">ting the electricity usage for the coming year. </span><span class="koboSpan" id="kobo.545.2">The electricity usage is going to depend on the population of the town to some extent, and as a college town, thousands of students are only temporary residents! </span><span class="koboSpan" id="kobo.545.3">How do you set up Prophet to handle this scenario? </span><span class="koboSpan" id="kobo.545.4">Conditional seasonalities exist for </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">this purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">Conditional seasonalities are those that are, in effect, for only a portion of the dates in the training and future DataFrames. </span><span class="koboSpan" id="kobo.547.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.548.1">conditional seasonality</span></strong><span class="koboSpan" id="kobo.549.1"> must have a cycle that is shorter than the period in which it is active. </span><span class="koboSpan" id="kobo.549.2">So, for example, it wouldn’t make sense to have a yearly seasonality that is active for just a </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">few months.</span></span></p>
<p><span class="koboSpan" id="kobo.551.1">Forecasting electricity usage in the college town would require you to set up either daily or weekly seasonalities – and possibly even both; depending on the usage patterns, one daily/weekly seasonality for the summer months when students have returned to their hometowns and another daily/weekly seasonality for the rest of the year. </span><span class="koboSpan" id="kobo.551.2">Ideally, the conditional seasonality would have at least two full cycles each time it </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">is active.</span></span></p>
<p><span class="koboSpan" id="kobo.553.1">To learn how to build a conditional seasonality, we will go back to the hourly Divvy data that we explored in the previous chapter. </span><span class="koboSpan" id="kobo.553.2">Based on the weekly seasonality we observed in that example, we know ridership is significantly lower on weekends than on weekdays, suggesting most riders are commuting </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">to work.</span></span></p>
<p><span class="koboSpan" id="kobo.555.1">We saw in the daily seasonality plot that ridership has usage peaks around 8 a.m. </span><span class="koboSpan" id="kobo.555.2">and 6 p.m., during the morning and evening rush hours. </span><span class="koboSpan" id="kobo.555.3">This may lead you to suspect that the usage throughout the day will follow different patterns on a weekday versus the weekend. </span><span class="koboSpan" id="kobo.555.4">That is, maybe those peaks we see at </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">8 a.m.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1"> and 6 p.m. </span><span class="koboSpan" id="kobo.557.2">and the midday trough will all disappear on weekends, with activity levels more even throughout the day. </span><span class="koboSpan" id="kobo.557.3">To test this hypothesis, let’s build a forecast model using different daily seasonalities for weekends than </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">for weekdays.</span></span></p>
<p><span class="koboSpan" id="kobo.559.1">The basic procedure for adding this conditional seasonality is to add new Boolean columns to your training DataFrame (and later, matching columns in the future DataFrame) in</span><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.560.1">dicating whether that row is a weekend or weekday. </span><span class="koboSpan" id="kobo.560.2">Then, disable the default weekly seasonality and add two new weekly seasonalities that specify those new Boolean columns as conditions. </span><span class="koboSpan" id="kobo.560.3">Let’s see how to </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">do this.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">We have the necessary libraries already loaded, so to begin, we need to create our Prophet DataFrame using the Divvy </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">hourly data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.564.1">
df = pd.read_csv('divvy_hourly.csv')
df['date'] = pd.to_datetime(df['date'])
df.columns = ['ds', 'y']</span></pre>
<p><span class="koboSpan" id="kobo.565.1">Now, this is where we identify the</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.566.1"> condition for our seasonality. </span><span class="koboSpan" id="kobo.566.2">Let’s create a function that outputs </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">True</span></strong><span class="koboSpan" id="kobo.568.1"> if the given date is on a weekend and </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">False</span></strong><span class="koboSpan" id="kobo.570.1"> otherwise. </span><span class="koboSpan" id="kobo.570.2">Then, we’ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">apply</span></strong><span class="koboSpan" id="kobo.572.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">pandas</span></strong><span class="koboSpan" id="kobo.574.1"> to create a new column for weekends and use the tilde (</span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">~</span></strong><span class="koboSpan" id="kobo.576.1">) operator to take the inverse results for another new column for weekdays. </span><span class="koboSpan" id="kobo.576.2">Finally, let’s output the first few rows of our DataFrame at this point just so that we can see what </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">we’ve got:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.578.1">
def is_weekend(ds):
    date = pd.to_datetime(ds)
    return (date.dayofweek == 5 or date.dayofweek == 6)
df['weekend'] = df['ds'].apply(is_weekend)
df['weekday'] = ~df['ds'].apply(is_weekend)
df.head()</span></pre>
<p><span class="koboSpan" id="kobo.579.1">If your functions correctly identified the days, you should see </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">this</span><a id="_idTextAnchor331"/><span class="koboSpan" id="kobo.581.1"> output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer130">
<span class="koboSpan" id="kobo.582.1"><img alt="Figure 5.15 – The Divvy conditional seasonality DataFrame" src="image/Fig_5.15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.583.1">Figure 5.15 – The Divvy conditional seasonality DataFrame</span></p>
<p><span class="koboSpan" id="kobo.584.1">January 1, 2014 was a</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.585.1"> Wednesday, so that output matches what we would expect. </span><span class="koboSpan" id="kobo.585.2">Next, we need to instantiate our model. </span><span class="koboSpan" id="kobo.585.3">Using what we learned earlier in this chapter, we will set the seasonalit</span><a id="_idTextAnchor332"/><span class="koboSpan" id="kobo.586.1">y mode to </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">multiplicative</span></strong><span class="koboSpan" id="kobo.588.1">, as this Divvy data represents count values. </span><span class="koboSpan" id="kobo.588.2">We will also set the Fourier order of both yearly and weekly seasonalities to </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">6</span></strong><span class="koboSpan" id="kobo.590.1">; my testing showed that to be a good value on this dataset. </span><span class="koboSpan" id="kobo.590.2">Finally, because we are adding conditional daily seasonalities, we will disable the default </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">daily seasonality:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.592.1">
model = Prophet(seasonality_mode='multiplicative',
                yearly_seasonality=6,
                weekly_seasonality=6,
                daily_seasonality=False)</span></pre>
<p><span class="koboSpan" id="kobo.593.1">To create conditional seasonalities, we will use the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">add_seasonality</span></strong><span class="koboSpan" id="kobo.595.1"> method that we learned about while modeling the sunspot cycle, but in this case, we will use the optional </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">condition_name</span></strong><span class="koboSpan" id="kobo.597.1"> argument to specify that the new seasonality </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">is conditional.</span></span></p>
<p><span class="koboSpan" id="kobo.599.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">condition_name</span></strong><span class="koboSpan" id="kobo.601.1"> argument must be passed the name of a column in the training DataFrame and consist of Boolean values identifying which rows to apply the seasonality to – our </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">weekend</span></strong><span class="koboSpan" id="kobo.603.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">weekday</span></strong><span class="koboSpan" id="kobo.605.1"> columns. </span><span class="koboSpan" id="kobo.605.2">Just as we did in the sunspots example, we also need to name the seasonality and identify both the period and </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">Fourier order:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.607.1">
model.add_seasonality(name='daily_weekend',
                      period=1,
                      fourier_order=3,
                      condition_name='weekend')
model.add_seasonality(name='daily_weekday',
                      period=1,
                      fourier_order=3,
                      condition_name='weekday')</span></pre>
<p><span class="koboSpan" id="kobo.608.1">That’s it for setti</span><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.609.1">ng up </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.610.1">the model! </span><span class="koboSpan" id="kobo.610.2">Next, we will fit the model on our training data and create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">future</span></strong><span class="koboSpan" id="kobo.612.1"> DataFrame just as before, being careful to set the frequency to </span><em class="italic"><span class="koboSpan" id="kobo.613.1">hourly</span></em><span class="koboSpan" id="kobo.614.1"> now that we are using hourly data. </span><span class="koboSpan" id="kobo.614.2">The last step in setting up conditional seasonalities is to identify where in the future DataFrame the condition </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">will apply.</span></span></p>
<p><span class="koboSpan" id="kobo.616.1">We already created the </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">is_weekend</span></strong><span class="koboSpan" id="kobo.618.1"> function and applied it to our training DataFrame, </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">df</span></strong><span class="koboSpan" id="kobo.620.1">. </span><span class="koboSpan" id="kobo.620.2">We simply need to repeat that procedure on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">future</span></strong><span class="koboSpan" id="kobo.622.1"> DataFrame before calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">predict</span></strong><span class="koboSpan" id="kobo.624.1"> to create </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">our forecast:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.626.1">
model.fit(df)
future = model.make_future_dataframe(periods=365 * 24,
                                     freq='h')
future['weekend'] = future['ds'].apply(is_weekend)
future['weekday'] = ~future['ds'].apply(is_weekend)
forecast = model.predict(future)</span></pre>
<p><span class="koboSpan" id="kobo.627.1">We named our two conditional seasonalities </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">'daily_weekend'</span></strong><span class="koboSpan" id="kobo.629.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">'daily_weekday'</span></strong><span class="koboSpan" id="kobo.631.1">, so let’s import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">plot_seasonality</span></strong><span class="koboSpan" id="kobo.633.1"> function, which we discovered in the previous chapter, and plot these </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">two seasonalities:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.635.1">
from prophet.plot import plot_seasonality
fig3 = plot_seasonality(model, 'daily_weekday',
                        figsize=(10, 3))
plt.show()
fig4 = plot_seasonality(model, 'daily_weekend',
                        figsize=(10, 3))
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.636.1">If </span><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.637.1">everything ran correctly, you should have two </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">n</span><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.639.1">ew plots:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer131">
<span class="koboSpan" id="kobo.640.1"><img alt="Figure 5.16 – Daily weekday component plot" src="image/Fig_5.16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.641.1">Figure 5.16 – Daily weekday component plot</span></p>
<p><span class="koboSpan" id="kobo.642.1">On weekdays, the trend </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.643.1">appears much the same as we saw when we used the default daily seasonality – a peak around 8 a.m., another peak around 6 p.m., and a small hump just after midnight. </span><span class="koboSpan" id="kobo.643.2">We hypothesized that weekends would see a much different pattern, though. </span><span class="koboSpan" id="kobo.643.3">Let’s look at the plo</span><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.644.1">t </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">to see:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer132">
<span class="koboSpan" id="kobo.646.1"><img alt="Figure 5.17 – Daily weekend component plot" src="image/Fig_5.17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.647.1">Figure 5.17 – Daily weekend component plot</span></p>
<p><span class="koboSpan" id="kobo.648.1">And indeed, we do see a difference! </span><span class="koboSpan" id="kobo.648.2">As your intuition might have suggested, on the weekends, Divvy riders tend to get a later start than on weekdays, with a gradual increase in ridership up until noon and then a gradual decrease to midnight. </span><span class="koboSpan" id="kobo.648.3">There is no midday slump as we saw on </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">working days.</span></span></p>
<p><span class="koboSpan" id="kobo.650.1">So far in this cha</span><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.651.1">pter, you used the Air Passengers data to learn the difference between additive and multiplicative seasonality. </span><span class="koboSpan" id="kobo.651.2">Later, you used the Divvy data to learn how to add custom seasonalities and conditional seasonalities. </span><span class="koboSpan" id="kobo.651.3">You also used the Divvy data to discover the Fourier </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.652.1">order and learned how to control the flexibility of the seasonality curve. </span><span class="koboSpan" id="kobo.652.2">However, there is another lever Prophet makes available to you to control </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">seasonality: regul</span><a id="_idTextAnchor338"/><a id="_idTextAnchor339"/><span class="koboSpan" id="kobo.654.1">arization.</span></span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.655.1">Regularizing seasonality</span></h1>
<p><span class="koboSpan" id="kobo.656.1">Often, when</span><a id="_idTextAnchor341"/><span class="koboSpan" id="kobo.657.1"> solving a problem with machine learning, the data involved is so complex that a simple model just isn’t powerful enough to capture the full subtlety of the patterns to be found. </span><span class="koboSpan" id="kobo.657.2">The simple model tends to </span><strong class="bold"><span class="koboSpan" id="kobo.658.1">underfit</span></strong><span class="koboSpan" id="kobo.659.1"> the data. </span><span class="koboSpan" id="kobo.659.2">In contrast, a more complicated model with many parameters and great flexibility can tend to </span><strong class="bold"><span class="koboSpan" id="kobo.660.1">overfit</span></strong><span class="koboSpan" id="kobo.661.1"> the data. </span><span class="koboSpan" id="kobo.661.2">It is not always easy, or possible, to use a simpler model. </span><span class="koboSpan" id="kobo.661.3">In these cases, </span><strong class="bold"><span class="koboSpan" id="kobo.662.1">regularization</span></strong><span class="koboSpan" id="kobo.663.1"> is a </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.664.1">good technique to use to </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">control overfitting.</span></span></p>
<p><span class="koboSpan" id="kobo.666.1">Prophet is such a powerful forecasting tool that without care, it can sometimes be very easy to overfit the data. </span><span class="koboSpan" id="kobo.666.2">That’s why understanding Prophet’s regularization parameters can be </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">quite useful.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.668.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.669.1">A model is said to be </span><em class="italic"><span class="koboSpan" id="kobo.670.1">underfit</span></em><span class="koboSpan" id="kobo.671.1"> if it does not fully capture the true relationship between the input features and the output features. </span><span class="koboSpan" id="kobo.671.2">Performance is low on both the training data and any unseen </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">testing data.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.673.1">A model is said to be </span><em class="italic"><span class="koboSpan" id="kobo.674.1">overfit</span></em><span class="koboSpan" id="kobo.675.1"> if it goes beyond capturing the true relationship and begins to capture random trends in the noise of the data. </span><span class="koboSpan" id="kobo.675.2">Performance can be very high on the training data but low on the unseen </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">testing data.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.677.1">A model with a good fit will perform equally well on both training and </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">testing data.</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">Regularization is a </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.680.1">technique for controlling overfitting by forcing a model to be less flexible. </span><span class="koboSpan" id="kobo.680.2">For example, in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.681.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.682.1">.18</span></em><span class="koboSpan" id="kobo.683.1">, I simulated a set of points with random noise (the true relationship I used is </span><span class="koboSpan" id="kobo.684.1"><img alt="" src="image/019630_05_F07.png"/></span><span class="koboSpan" id="kobo.685.1">)) and fit two lines using 8th-degree polynomial regression (in reality, you would rarely choose such a high order for a regression model; I am using it here merely to exaggerate the point). </span><span class="koboSpan" id="kobo.685.2">One line is not regularized at all, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">other is:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer134">
<span class="koboSpan" id="kobo.687.1"><img alt="Figure 5.18 – Regularization effects" src="image/Fig_5.18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.688.1">Figure 5.18 – Regularization effects</span></p>
<p><span class="koboSpan" id="kobo.689.1">As you can see in the plot, the </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.690.1">unregularized line is overfit and wiggles around the true relation</span><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.691.1">ship while attempting to fit to the noise. </span><span class="koboSpan" id="kobo.691.2">By regularizing, in contrast, the flexibility of the line is constrained and it is forced to trace out a much smoother curve. </span><span class="koboSpan" id="kobo.691.3">With the true curve essentially being </span><span class="koboSpan" id="kobo.692.1"><img alt="" src="image/019630_05_F08.png"/></span><span class="koboSpan" id="kobo.693.1"> , it is clear that the regularized line, while still not perfect, does a better job of approximating the relationship and will perform better on </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">new data.</span></span></p>
<p><span class="koboSpan" id="kobo.695.1">The full Prophet package has several adjustable parameters for regularization. </span><span class="koboSpan" id="kobo.695.2">For seasonali</span><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.696.1">ty, that parameter is called the </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">prior scale.</span></span></p>
<p><span class="koboSpan" id="kobo.698.1">In statistics, you may have an uncertain quantity that you intend to find the value of. </span><span class="koboSpan" id="kobo.698.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.699.1">prior probability distributio</span><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.700.1">n</span></strong><span class="koboSpan" id="kobo.701.1">, often</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.702.1"> just</span><a id="_idTextAnchor345"/><span class="koboSpan" id="kobo.703.1"> called a prior, of that quantity is the probability distribution of values you would expect </span><em class="italic"><span class="koboSpan" id="kobo.704.1">prior to</span></em><span class="koboSpan" id="kobo.705.1"> learning </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">additional information.</span></span></p>
<p><span class="koboSpan" id="kobo.707.1">For example, let’s say I ask you to guess the height of a specific human male. </span><span class="koboSpan" id="kobo.707.2">In your mind, you imagine all the likely heights of males. </span><span class="koboSpan" id="kobo.707.3">That range of heights is the prior probability distribution. </span><span class="koboSpan" id="kobo.707.4">Next, I tell you that the male is an NBA basketball player. </span><span class="koboSpan" id="kobo.707.5">You know basketbal</span><a id="_idTextAnchor346"/><span class="koboSpan" id="kobo.708.1">l players are typically much taller than the average male, so you update that distribution to skew more toward tall heights because the additional information I provided you with better informs </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">your guess.</span></span></p>
<p><span class="koboSpan" id="kobo.710.1">The prior is your starting point, what you believe to be true before receiving additional information. </span><span class="koboSpan" id="kobo.710.2">Let’s learn how to apply this idea to seasonality </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">in Prophet.</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor347"/><a id="_idTextAnchor348"/><span class="koboSpan" id="kobo.712.1">Global seasonality regularization</span></h2>
<p><span class="koboSpan" id="kobo.713.1">The first way </span><a id="_idTextAnchor349"/><span class="koboSpan" id="kobo.714.1">to apply seasonality </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.715.1">regularization is globally, which affects all the seasonalities in your model equally. </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">seasonality_prior_scale</span></strong><span class="koboSpan" id="kobo.717.1"> is an attribute of your Prophet model instance and is set when you instantiate your model. </span><span class="koboSpan" id="kobo.717.2">If you do not set it, the default will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">10</span></strong><span class="koboSpan" id="kobo.719.1">. </span><span class="koboSpan" id="kobo.719.2">Reducing this number will apply more regularization, which will rein in your model’s seasonalities. </span><span class="koboSpan" id="kobo.719.3">Let’s see this </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">in action.</span></span></p>
<p><span class="koboSpan" id="kobo.721.1">We’ll use the Divvy daily data in this example, so we need to begin by loading it into our Prophet DataFrame, as the necessary libraries should already be loaded from </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">previous examples:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.723.1">
df = pd.read_csv('divvy_daily.csv')
df = df[['date', 'rides']]
df['date'] = pd.to_datetime(df['date'])
df.columns = ['ds', 'y']</span></pre>
<p><span class="koboSpan" id="kobo.724.1">Now, we need to instantiate our model, setting the seasonality mode to </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">multiplicative</span></strong><span class="koboSpan" id="kobo.726.1">. </span><span class="koboSpan" id="kobo.726.2">While learning about Fourier order, you went through a forecast with this dataset using the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">seasonality_prior_scale</span></strong><span class="koboSpan" id="kobo.728.1"> value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">10</span></strong><span class="koboSpan" id="kobo.730.1">. </span><span class="koboSpan" id="kobo.730.2">So, let’s use a prior scale this time around of </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">0.01</span></strong><span class="koboSpan" id="kobo.732.1">. </span><span class="koboSpan" id="kobo.732.2">We also found the yearly seasonality to be better modeled with a Fourier order of </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">4</span></strong><span class="koboSpan" id="kobo.734.1">, so we’ll set that as well. </span><span class="koboSpan" id="kobo.734.2">You can refer back to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.735.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.736.1">.8</span></em><span class="koboSpan" id="kobo.737.1"> and </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.738.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.739.1">.9</span></em><span class="koboSpan" id="kobo.740.1"> to see the unregularized model </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">for comparison:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.742.1">
model = Prophet(seasonality_mode='multiplicative',
                yearly_seasonality=4,
                seasonality_prior_scale=.01)</span></pre>
<p><span class="koboSpan" id="kobo.743.1">With</span><a id="_idTextAnchor350"/><span class="koboSpan" id="kobo.744.1"> the regularization set, all</span><a id="_idTextAnchor351"/><span class="koboSpan" id="kobo.745.1"> that is left to do is complete the model, as we </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">did earlier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.747.1">
model.fit(df)
future = model.make_future_dataframe(periods=365)
forecast = model.predict(future)
fig = model.plot(forecast)
plt.show()
fig2 = model.plot_components(forecast)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.748.1">First, we will look</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.749.1"> at the forecast, and then </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">the components:</span></span><a id="_idTextAnchor352"/></p>
<div>
<div class="IMG---Figure" id="_idContainer136">
<span class="koboSpan" id="kobo.751.1"><img alt="Figure 5.19 – Regularized forecast" src="image/Fig_5.19.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.752.1">Figure 5.19 – Regularized forecast</span></p>
<p><span class="koboSpan" id="kobo.753.1">Comparing </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.754.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.755.1">.19</span></em><span class="koboSpan" id="kobo.756.1"> with </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.757.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.758.1">.8</span></em><span class="koboSpan" id="kobo.759.1"> shows that</span><a id="_idTextAnchor353"/><span class="koboSpan" id="kobo.760.1"> the seasonal swings in our forecast have</span><a id="_idTextAnchor354"/><span class="koboSpan" id="kobo.761.1"> indeed been dampened. </span><span class="koboSpan" id="kobo.761.2">Both the annual seasonality and the weekly seasonality show less variation. </span><span class="koboSpan" id="kobo.761.3">The uncertainty intervals between the two models are roughly the same, though, because the variance in the data is now handled in the Prophet model’s noise term instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">seasonality term.</span></span></p>
<p><span class="koboSpan" id="kobo.763.1">Now, let’s look at the</span><a id="_idIndexMarker228"/> <span class="No-Break"><span class="koboSpan" id="kobo.764.1">components plot:</span></span><a id="_idTextAnchor355"/></p>
<div>
<div class="IMG---Figure" id="_idContainer137">
<span class="koboSpan" id="kobo.765.1"><img alt="Figure 5.20 – Regularized components plot" src="image/Fig_5.20.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.766.1">Figure 5.20 – Regularized components plot</span></p>
<p><span class="koboSpan" id="kobo.767.1">Comparing this figure with </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.768.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.769.1">.9</span></em><span class="koboSpan" id="kobo.770.1">, we can see that the trend is very similar. </span><span class="koboSpan" id="kobo.770.2">We only constrained the seasonality, not the trend. </span><span class="koboSpan" id="kobo.770.3">The trend did change a bit (the peak value is a bit higher) because Prophet is attempting to capture some of the seasonal variations with the trend, but the shape is nearly identical. </span><span class="koboSpan" id="kobo.770.4">The weekly and yearly seasonalities appear the same, but their </span><em class="italic"><span class="koboSpan" id="kobo.771.1">y</span></em><span class="koboSpan" id="kobo.772.1"> axes show that the magnitudes have been reduced in the range of one-third to one-quarter of their regularized levels. </span><span class="koboSpan" id="kobo.772.2">This is the effect of seasonality regularization: it reduces the magnitude of the </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">curve’s values.</span></span></p>
<p><span class="koboSpan" id="kobo.774.1">To</span><a id="_idTextAnchor356"/><span class="koboSpan" id="kobo.775.1"> illustrate the effect of </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.776.1">different seasonality prio</span><a id="_idTextAnchor357"/><span class="koboSpan" id="kobo.777.1">r scales, let’s compare the yearly and weekly seasonality curves of this dataset when modeled with different prior scales. </span><span class="koboSpan" id="kobo.777.2">First, here is the yearly </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">seasonality plot:</span></span><a id="_idTextAnchor358"/></p>
<div>
<div class="IMG---Figure" id="_idContainer138">
<span class="koboSpan" id="kobo.779.1"><img alt="Figure 5.21 – Yearly seasonality with different prior scales" src="image/Fig_5.21.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.780.1">Figure 5.21 – Yearly seasonality with different prior scales</span></p>
<p><span class="koboSpan" id="kobo.781.1">And here is the weekly </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">seasonality plot:</span></span></p>
<p class="IMG---Figure"><a id="_idTextAnchor359"/></p>
<div>
<div class="IMG---Figure" id="_idContainer139">
<span class="koboSpan" id="kobo.783.1"><img alt="Figure 5.22 – Weekly seasonality with different prior scales" src="image/Fig_5.22.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.784.1">Figure 5.22 – Weekly seasonality with different prior scales</span></p>
<p><span class="koboSpan" id="kobo.785.1">The solid line in both plots is the default scale of </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">10</span></strong><span class="koboSpan" id="kobo.787.1">; the dashed line and dashed-dotted line </span><a id="_idTextAnchor360"/><span class="koboSpan" id="kobo.788.1">show increasing regularization amounts. </span><span class="koboSpan" id="kobo.788.2">Whereas </span><a id="_idTextAnchor361"/><span class="koboSpan" id="kobo.789.1">modifying the Fourier order helped control the seasonality curve by reducing the number of bends it was allowed to take, modifying the seasonality prior scale helps control seasonality by reducing the amount of variation it</span><a id="_idIndexMarker230"/> <span class="No-Break"><span class="koboSpan" id="kobo.790.1">can achieve.</span></span></p>
<p><span class="koboSpan" id="kobo.791.1">In this section, you learned how to regularize all seasonalities at the same time. </span><span class="koboSpan" id="kobo.791.2">Next, learn see how to regularize the </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">seasonalities individually.</span></span><a id="_idTextAnchor362"/><a id="_idTextAnchor363"/></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor364"/><span class="koboSpan" id="kobo.793.1">Local seasonality regularization</span></h2>
<p><span class="koboSpan" id="kobo.794.1">Let’s say that you are happy </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.795.1">wit</span><a id="_idTextAnchor365"/><span class="koboSpan" id="kobo.796.1">h the yearly seasonalit</span><a id="_idTextAnchor366"/><span class="koboSpan" id="kobo.797.1">y curve with the default regularization setting, but your weekly curve is too extreme and overfitting. </span><span class="koboSpan" id="kobo.797.2">In that case, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">add_seasonality</span></strong><span class="koboSpan" id="kobo.799.1"> method to create a new weekly seasonality with a custom </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">prior scale.</span></span></p>
<p><span class="koboSpan" id="kobo.801.1">Let’s continue and instantiate a new model, again with </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">multiplicative</span></strong><span class="koboSpan" id="kobo.803.1"> seasonality and a Fourier order of </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">4</span></strong><span class="koboSpan" id="kobo.805.1"> applied to the yearly seasonality. </span><span class="koboSpan" id="kobo.805.2">This time, though, we will be adding a new weekly seasonality, so let’s remove the default by setting it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">False</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.807.1">while instantiating:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.808.1">
model = Prophet(seasonality_mode='multiplicative',
                yearly_seasonality=4,
                weekly_seasonality=False)</span></pre>
<p><span class="koboSpan" id="kobo.809.1">As you learned in the </span><em class="italic"><span class="koboSpan" id="kobo.810.1">Adding custom seasonalities</span></em><span class="koboSpan" id="kobo.811.1"> section, we will now add a seasonality with a period of </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">7</span></strong><span class="koboSpan" id="kobo.813.1"> days and name it </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">'weekly'</span></strong><span class="koboSpan" id="kobo.815.1">. </span><span class="koboSpan" id="kobo.815.2">We are happy with the default weekly Fourier order of </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">4</span></strong><span class="koboSpan" id="kobo.817.1">, so we’ll use that again here, but we want more regularization than is the default, so we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">prior_scale</span></strong><span class="koboSpan" id="kobo.819.1"> argument to set it </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">0.01</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.823.1">
model.add_seasonality(name='weekly',
                      period=7,
                      fourier_order=4,
                      prior_scale=0.01)</span></pre>
<p><span class="koboSpan" id="kobo.824.1">Now, as I hope is becomin</span><a id="_idTextAnchor367"/><span class="koboSpan" id="kobo.825.1">g second nature t</span><a id="_idTextAnchor368"/><span class="koboSpan" id="kobo.826.1">o you, we will fit the model and predict on the future DataFrame. </span><span class="koboSpan" id="kobo.826.2">Let’s just plot the components </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">this time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.828.1">
model.fit(df)
future = model.make_future_dataframe(periods=365)
forecast = model.predict(future)
fig2 = model.plot_components(forecast)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.829.1">You should see </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.830.1">this plot, which looks nearly identical to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.831.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.832.1">.20</span><a id="_idTextAnchor369"/></em></span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer140">
<span class="koboSpan" id="kobo.834.1"><img alt="Figure 5.23 – Weekly regularized components plot" src="image/Fig_5.23.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.835.1">Figure 5.23 – Weekly regularized components plot</span></p>
<p><span class="koboSpan" id="kobo.836.1">You’ll now see that the magnitude of the unregularized yearly seasonality matches that of </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.837.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.838.1">.9</span></em><span class="koboSpan" id="kobo.839.1">, but the regularized weekl</span><a id="_idTextAnchor370"/><span class="koboSpan" id="kobo.840.1">y seasonality is reduced b</span><a id="_idTextAnchor371"/><span class="koboSpan" id="kobo.841.1">y about half, as expected. </span><span class="koboSpan" id="kobo.841.2">All of your seasonalities can have different regularization strengths applied, simply with </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.842.1">repeated </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">add_seasonality</span></strong><span class="koboSpan" id="kobo.844.1"> calls. </span><span class="koboSpan" id="kobo.844.2">Reasonable values for these prior scales range from about 10 down to </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">around 0.0</span><a id="_idTextAnchor372"/><a id="_idTextAnchor373"/><span class="koboSpan" id="kobo.846.1">1.</span></span></p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor374"/><span class="koboSpan" id="kobo.847.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.848.1">Seasonality truly is the heart of Prophet. </span><span class="koboSpan" id="kobo.848.2">This chapter covered a lot of ground; the foundations you learned here will be used throughout the remaining chapters of this book. </span><span class="koboSpan" id="kobo.848.3">Indeed, almost any model you build in Prophet will have seasonality considerations, whereas many of the upcoming chapters cover special cases that may or may not apply to your </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">specific problem.</span></span></p>
<p><span class="koboSpan" id="kobo.850.1">You started this chapter by learning the difference between additive and multiplicative seasonality, and how to identify whether your dataset features one or the other. </span><span class="koboSpan" id="kobo.850.2">We then briefly discussed the Fourier series and demonstrated how a partial Fourier sum can build a very complex periodic curve. </span><span class="koboSpan" id="kobo.850.3">Using these ideas, you learned how setting the Fourier order of a seasonality can be used to control its shape by allowing either more or less freedom to bend along </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">its path.</span></span></p>
<p><span class="koboSpan" id="kobo.852.1">Next, you modeled the 11-year cycle of sunspots and learned how to add custom seasonalities. </span><span class="koboSpan" id="kobo.852.2">These custom seasonalities came into use again when you learned how to model the different weekday and weekend behaviors of riders on Divvy’s network using conditional seasonalities. </span><span class="koboSpan" id="kobo.852.3">Finally, we looked at regularization techniques, both globally as applied to all seasonalities together and locally, using yet again the custom seasonalities lesson to apply regularization to just the weekly </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">seasonality alone.</span></span></p>
<p><span class="koboSpan" id="kobo.854.1">In the next chapter, you will learn all about holidays in the Prophet package, which, among many other topics, will also include more detail about regularization as it applies </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">to Prophet.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer142">
</div>
</div>
</body></html>