["```py\nimport UIKit\n    class Stroke{    \n}\n```", "```py\nvar points : [CGPoint] = [CGPoint]()\nvar color : UIColor!\nvar width : CGFloat!\n\ninit(startingPoint:CGPoint,\n     color:UIColor=UIColor.black,\n     width:CGFloat=10.0) {\n    self.points.append(startingPoint)\n    self.color = color\n    self.width = width\n}\n```", "```py\nvar path : CGPath{\n    get{\n        let path = CGMutablePath.init()\n        if points.count > 0{\n            for (idx, point) in self.points.enumerated(){\n                if idx == 0{\n                    path.move(to: point)\n                } else{\n                    path.addLine(to: point)\n                }\n            }\n        }        \n        return path\n    }\n}\n```", "```py\nvar minPoint : CGPoint{\n    get{\n        guard points.count > 0 else{\n            return CGPoint(x: 0, y: 0)\n        }\n\n        let minX : CGFloat = points.map { (cp) -> CGFloat in\n            return cp.x\n            }.min() ?? 0\n\n        let minY : CGFloat = points.map { (cp) -> CGFloat in\n            return cp.y\n            }.min() ?? 0\n\n        return CGPoint(x: minX, y: minY)\n    }\n}\n\nvar maxPoint : CGPoint{\n    get{\n        guard points.count > 0 else{\n            return CGPoint(x: 0, y: 0)\n        }\n\n        let maxX : CGFloat = points.map { (cp) -> CGFloat in\n            return cp.x\n            }.max() ?? 0\n\n        let maxY : CGFloat = points.map { (cp) -> CGFloat in\n            return cp.y\n            }.max() ?? 0\n\n        return CGPoint(x: maxX, y: maxY)\n    }\n}\n```", "```py\nprotocol Sketch : class{\n    var boundingBox : CGRect{ get }\n    var center : CGPoint{ get set }\n    func draw(context:CGContext)\n    func exportSketch(size:CGSize?) -> CIImage?\n}\n```", "```py\nclass StrokeSketch : Sketch{\n    var label : String?  \n    var strokes = [Stroke]()\n    var currentStroke : Stroke?{\n        get{\n            return strokes.count > 0 ? strokes.last : nil \n        }\n    }   \n    func addStroke(stroke:Stroke){\n        self.strokes.append(stroke)\n    }\n}  \n```", "```py\n func draw(context:CGContext){\n    self.drawStrokes(context:context)\n}\n\nfunc drawStrokes(context:CGContext){\n    for stroke in self.strokes{\n        self.drawStroke(context: context, stroke: stroke)\n    }\n}\n\nprivate func drawStroke(context:CGContext, stroke:Stroke){\n    context.setStrokeColor(stroke.color.cgColor)\n    context.setLineWidth(stroke.width)\n    context.addPath(stroke.path)\n    context.drawPath(using: .stroke)\n} \n```", "```py\nvar minPoint : CGPoint{\n    get{\n        guard strokes.count > 0 else{\n            return CGPoint(x: 0, y: 0)\n        }\n\n        let minPoints = strokes.map { (stroke) -> CGPoint in\n            return stroke.minPoint\n        }\n\n        let minX : CGFloat = minPoints.map { (cp) -> CGFloat in\n            return cp.x\n            }.min() ?? 0\n\n        let minY : CGFloat = minPoints.map { (cp) -> CGFloat in\n            return cp.y\n            }.min() ?? 0\n\n        return CGPoint(x: minX, y: minY)\n    }\n}\n\nvar maxPoint : CGPoint{\n    get{\n        guard strokes.count > 0 else{\n            return CGPoint(x: 0, y: 0)\n        }\n\n        let maxPoints = strokes.map { (stroke) -> CGPoint in\n            return stroke.maxPoint\n        }\n\n        let maxX : CGFloat = maxPoints.map { (cp) -> CGFloat in\n            return cp.x\n            }.max() ?? 0\n\n        let maxY : CGFloat = maxPoints.map { (cp) -> CGFloat in\n            return cp.y\n            }.max() ?? 0\n\n        return CGPoint(x: maxX, y: maxY)\n    }\n}\n\nvar boundingBox : CGRect{\n    get{\n        let minPoint = self.minPoint\n        let maxPoint = self.maxPoint\n\n        let size = CGSize(width: maxPoint.x - minPoint.x, height: maxPoint.y - minPoint.y)\n\n        let paddingSize = CGSize(width: 5,\n                                 height: 5)\n\n        return CGRect(x: minPoint.x - paddingSize.width,\n                      y: minPoint.y - paddingSize.height,\n                      width: size.width + (paddingSize.width * 2),\n                      height: size.height + (paddingSize.height * 2))\n    }\n}\n```", "```py\nvar center : CGPoint{\n    get{\n        let bbox = self.boundingBox\n        return CGPoint(x:bbox.origin.x + bbox.size.width/2,\n                       y:bbox.origin.y + bbox.size.height/2)\n    }\n    set{\n        let previousCenter = self.center\n        let newCenter = newValue\n        let translation = CGPoint(x:newCenter.x - previousCenter.x,\n                                  y:newCenter.y - previousCenter.y)\n        for stroke in self.strokes{\n            for i in 0..<stroke.points.count{\n                stroke.points[i] = CGPoint(\n                    x:stroke.points[i].x + translation.x,\n                    y:stroke.points[i].y + translation.y)\n            }\n        }\n    }\n}\n```", "```py\nfunc exportSketch(size:CGSize?=nil) -> CIImage?{\n    let boundingBox = self.boundingBox\n    let targetSize = size ?? CGSize(\n        width: max(boundingBox.width, boundingBox.height),\n        height: max(boundingBox.width, boundingBox.height))\n\n    var scale : CGFloat = 1.0\n\n    if boundingBox.width > boundingBox.height{\n        scale = targetSize.width / (boundingBox.width)\n    } else{\n        scale = targetSize.height / (boundingBox.height)\n    }\n\n    guard boundingBox.width > 0, boundingBox.height > 0 else{\n        return nil\n    }     \n}\n```", "```py\nUIGraphicsBeginImageContextWithOptions(targetSize, true, 1.0)\n\nguard let context = UIGraphicsGetCurrentContext() else{\n    return nil\n}\n\nUIGraphicsPushContext(context)\n\nUIColor.white.setFill()\ncontext.fill(CGRect(x: 0, y: 0,\n                    width: targetSize.width, height: targetSize.height))\n\ncontext.scaleBy(x: scale, y: scale)\n\nlet scaledSize = CGSize(width: boundingBox.width * scale, height: boundingBox.height * scale)\n\ncontext.translateBy(x: -boundingBox.origin.x + (targetSize.width - scaledSize.width)/2,\n                    y: -boundingBox.origin.y + (targetSize.height - scaledSize.height)/2)\n\nself.drawStrokes(context: context)\n\nUIGraphicsPopContext()\n```", "```py\nguard let image = UIGraphicsGetImageFromCurrentImageContext() else{\n    UIGraphicsEndImageContext()\n    return nil\n}\nUIGraphicsEndImageContext()\n\nreturn image.ciImage != nil ? image.ciImage : CIImage(cgImage: image.cgImage!)\n```", "```py\nclass SketchView: UIControl {\n    var clearColor : UIColor = UIColor.white\n    var strokeColor : UIColor = UIColor.black\n    var strokeWidth : CGFloat = 1.0\n    var sketches = [Sketch]()\n    var currentSketch : Sketch?{\n        get{\n            return self.sketches.count > 0 ? self.sketches.last : nil\n        }\n        set{\n            if let newValue = newValue{\n                if self.sketches.count > 0{\n                    self.sketches[self.sketches.count-1] = newValue\n                } else{\n                    self.sketches.append(newValue)\n                }\n            } else if self.sketches.count > 0{\n                self.sketches.removeLast()\n            }\n            self.setNeedsDisplay()\n        }\n    }\n\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n    }\n\n    required init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n\n    func removeAllSketches(){\n        self.sketches.removeAll()\n        self.setNeedsDisplay()\n    }\n}  \n```", "```py\nextension SketchView{ \n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else{ return }\n        self.clearColor.setFill()\n        UIRectFill(self.bounds)\n        // them draw themselves\n        for sketch in self.sketches{\n            sketch.draw(context: context)\n        }\n    }\n}  \n```", "```py\nextension SketchView{\n    override func beginTracking(_ touch: UITouch, \n                                with event: UIEvent?) -> Bool{\n        return true\n    }\n    override func continueTracking(_ touch: UITouch?, \n                                   with event: UIEvent?) -> Bool {\n        return true\n    }\n    override func endTracking(_ touch: UITouch?, \n                              with event: UIEvent?) {        \n    }\n    override func cancelTracking(with event: UIEvent?) { \n    }\n}\n```", "```py\nlet point = touch.location(in: self)\nif sketches.count == 0 || !(sketches.last is StrokeSketch){\n    sketches.append(StrokeSketch())\n}\nguard let sketch = self.sketches.last as? StrokeSketch else {\n    return false\n}\nsketch.addStroke(stroke:Stroke(startingPoint: point,\n                               color:self.strokeColor,\n                               width:self.strokeWidth))\nself.setNeedsDisplay()\nself.sendActions(for: UIControlEvents.editingDidBegin)\nreturn true\n```", "```py\nguard let sketch = self.sketches.last as? StrokeSketch, let touch = touch else{\n    return false\n}\nlet point = touch.location(in: self)\nsketch.currentStroke?.points.append(point)\nself.setNeedsDisplay()\nself.sendActions(for: UIControlEvents.editingChanged)\nreturn true\n```", "```py\nguard let sketch = self.sketches.last as? StrokeSketch, let touch = touch else{\n    return\n}\nlet point = touch.location(in: self)\nsketch.currentStroke?.points.append(point)\nself.setNeedsDisplay()\nself.sendActions(for: UIControlEvents.editingDidEnd)\n```", "```py\nguard let _ = self.sketches.last as? StrokeSketch else{\n    return\n}\nself.setNeedsDisplay()\nself.sendActions(for: UIControlEvents.editingDidEnd)\n```", "```py\noverride func viewDidLoad() {\n        super.viewDidLoad()\n        ...\n        ...\n        self.sketchView.addTarget(self, action:\n #selector(SketchViewController.onSketchViewEditingDidEnd),\n for: .editingDidEnd)\n        queryFacade.delegate = self \n}\n```", "```py\nguard self.sketchView.currentSketch != nil,\n    let sketch = self.sketchView.currentSketch as? StrokeSketch else{\n    return\n} \n\nqueryFacade.asyncQuery(sketch: sketch)\n```", "```py\nlet context = CIContext()\nlet queryQueue = DispatchQueue(label: \"query_queue\")\nvar targetSize = CGSize(width: 256, height: 256)\nweak var delegate : QueryDelegate?\nvar currentSketch : Sketch?{\n    didSet{\n        self.newQueryWaiting = true\n        self.queryCanceled = false\n    }\n}\n\nfileprivate var queryCanceled : Bool = false\nfileprivate var newQueryWaiting : Bool = false\nfileprivate var processingQuery : Bool = false\nvar isProcessingQuery : Bool{\n    get{\n        return self.processingQuery\n    }\n}\n\nvar isInterrupted : Bool{\n    get{\n        return self.queryCanceled || self.newQueryWaiting\n    }\n} \n```", "```py\nfunc asyncQuery(sketch:Sketch){\n    self.currentSketch = sketch\n\n    if !self.processingQuery{\n        self.queryCurrentSketch()\n    }\n}\n\nfileprivate func processNextQuery(){\n    self.queryCanceled = false\n\n    if self.newQueryWaiting && !self.processingQuery{\n        self.queryCurrentSketch()\n    }\n}\n\nfileprivate func queryCurrentSketch(){\n    guard let sketch = self.currentSketch else{\n        self.processingQuery = false\n        self.newQueryWaiting = false\n\n        return\n    }\n\n    self.processingQuery = true\n    self.newQueryWaiting = false\n\n    queryQueue.async {\n\n        DispatchQueue.main.async{\n            self.processingQuery = false\n            self.delegate?.onQueryCompleted(\n                status:self.isInterrupted ? -1 : -1,\n                result:nil)\n            self.processNextQuery()\n        }\n    }\n}\n```", "```py\nlet sketchClassifier = cnnsketchclassifier()\n```", "```py\nfunc classifySketch(sketch:Sketch) -> [(key:String,value:Double)]?{\n    if let img = sketch.exportSketch(size: nil)?\n        .resize(size: self.targetSize).rescalePixels(){\n        return self.classifySketch(image: img)\n    }    \n    return nil\n}\nfunc classifySketch(image:CIImage) -> [(key:String,value:Double)]?{    \n    return nil\n}\n```", "```py\nif let pixelBuffer = image.toPixelBuffer(context: self.context, gray: true){\n    let prediction = try? self.sketchClassifier.prediction(image: pixelBuffer)\n\n    if let classPredictions = prediction?.classLabelProbs{\n        let sortedClassPredictions = classPredictions.sorted(by: { (kvp1, kvp2) -> Bool in\n            kvp1.value > kvp2.value\n        })\n\n        return sortedClassPredictions\n    }\n}\n\nreturn nil\n```", "```py\nfunc downloadImages(searchTerms:[String],\n                    searchTermsCount:Int=4,\n                    searchResultsCount:Int=2) -> [CIImage]?{\n var bingResults = [BingServiceResult]()\n\n for i in 0..<min(searchTermsCount, searchTerms.count){\n let results = BingService.sharedInstance.syncSearch(\n searchTerm: searchTerms[i], count:searchResultsCount)\n\n for bingResult in results{\n bingResults.append(bingResult)\n }\n\n if self.isInterrupted{\n return nil\n }\n }\n}\n```", "```py\nvar images = [CIImage]()\n\nfor bingResult in bingResults{\n    if let image = BingService.sharedInstance.syncDownloadImage(\n        bingResult: bingResult){\n        images.append(image)\n    }\n\n    if self.isInterrupted{\n        return nil\n    }\n}\n\nreturn images\n```", "```py\nqueryQueue.async {\n\n guard let predictions = self.classifySketch(\n sketch: sketch) else{\n DispatchQueue.main.async{\n self.processingQuery = false\n self.delegate?.onQueryCompleted(\n status:-1, result:nil)\n self.processNextQuery()\n }\n return\n }\n\n let searchTerms = predictions.map({ (key, value) -> String in\n return key\n })\n\n guard let images = self.downloadImages(\n searchTerms: searchTerms,\n searchTermsCount: 4) else{\n DispatchQueue.main.async{\n self.processingQuery = false\n self.delegate?.onQueryCompleted(\n status:-1, result:nil)\n self.processNextQuery()\n }\n return\n }\n\n guard let sortedImage = self.sortByVisualSimilarity(\n images: images,\n sketch: sketch) else{\n DispatchQueue.main.async{\n self.processingQuery = false\n self.delegate?.onQueryCompleted(\n status:-1, result:nil)\n self.processNextQuery()\n }\n return\n }\n\n    DispatchQueue.main.async{\n self.processingQuery = false\n self.delegate?.onQueryCompleted(\n status:self.isInterrupted ? -1 : 1,\n result:QueryResult(\n predictions: predictions,\n images: sortedImage))\n self.processNextQuery()\n }\n}\n```", "```py\nfunc onQueryCompleted(status: Int, result:QueryResult?){\n}  \n```", "```py\nguard status > 0 else{\n    return\n}\n\nqueryImages.removeAll()\n\nif let result = result{\n    for cimage in result.images{\n        if let cgImage = self.ciContext.createCGImage(cimage, from:cimage.extent){\n            queryImages.append(UIImage(cgImage:cgImage))\n        }\n    }\n}\n\ntoolBarLabel.isHidden = queryImages.count == 0\ncollectionView.reloadData() \n```", "```py\nclass ImageSketch : Sketch{\n   var image : UIImage!\n   var size : CGSize!\n   var origin : CGPoint!\n   var label : String!\n\n    init(image:UIImage, origin:CGPoint, size:CGSize, label: String) {\n        self.image = image\n        self.size = size\n        self.label = label\n        self.origin = origin\n    }    \n}\n```", "```py\nvar boundingBox : CGRect{\n    get{\n        return CGRect(origin: self.origin, size: self.size)\n    }\n} \n```", "```py\nvar center : CGPoint{\n    get{\n        let bbox = self.boundingBox\n        return CGPoint(x:bbox.origin.x + bbox.size.width/2,\n                       y:bbox.origin.y + bbox.size.height/2)\n    } set{\n        self.origin = CGPoint(x:newValue.x - self.size.width/2,\n                              y:newValue.y - self.size.height/2)\n    }\n}\n```", "```py\nfunc draw(context:CGContext){\n    self.image.draw(in: self.boundingBox)\n}  \n```", "```py\nfunc exportSketch(size:CGSize?) -> CIImage?{\n    guard let ciImage = CIImage(image: self.image) else{\n        return nil\n    }\n\n    if self.image.size.width == self.size.width && self.image.size.height == self.size.height{\n        return ciImage\n    } else{\n        return ciImage.resize(size: self.size)\n    }\n} \n```", "```py\nguard let sketch = self.sketchView.currentSketch else{\n    return\n}\nself.queryFacade.cancel()\nlet image = self.queryImages[indexPath.row] \n```", "```py\n    var origin = CGPoint(x:0, y:0)\n    var size = CGSize(width:0, height:0)\n\n    if bbox.size.width > bbox.size.height{\n        let ratio = image.size.height / image.size.width\n        size.width = bbox.size.width\n        size.height = bbox.size.width * ratio\n    } else{\n        let ratio = image.size.width / image.size.height\n        size.width = bbox.size.height * ratio\n        size.height = bbox.size.height\n    } \n```", "```py\norigin.x = sketch.center.x - size.width / 2\norigin.y = sketch.center.y - size.height / 2\n```", "```py\nself.sketchView.currentSketch = ImageSketch(image:image,\n                                            origin:origin,\n                                            size:size,\n                                            label:\"\")\n```", "```py\nself.queryImages.removeAll()\nself.toolBarLabel.isHidden = queryImages.count == 0\nself.collectionView.reloadData()\n```", "```py\nimport Accelerate\nimport CoreML\n\nlet histogramViewFrame = CGRect(\n    x: 0, y: 0,\n    width: 600, height: 300)\n\nlet heatmapViewFrame = CGRect(\n    x: 0, y: 0,\n    width: 600, height: 600)\n\nlet sketchFeatureExtractor = cnnsketchfeatureextractor()\nlet targetSize = CGSize(width: 256, height: 256)\nlet context = CIContext()\n```", "```py\nfunc extractFeaturesFromImage(image:UIImage) -> MLMultiArray?{\n    guard let image = CIImage(\n        image: image) else{\n        return nil\n    }\n    return extractFeaturesFromImage(image: image)\n}\n\nfunc extractFeaturesFromImage(image:CIImage) -> MLMultiArray?{\n    guard let imagePixelBuffer = image.resize(\n        size: targetSize)\n        .rescalePixels()?\n        .toPixelBuffer(context: context,\n                       gray: true) else {\n        return nil\n    }\n\n    guard let features = try? sketchFeatureExtractor.prediction(\n        image: imagePixelBuffer) else{\n        return nil\n    }\n\n    return features.classActivations\n}\n```", "```py\nvar images = [UIImage]()\nvar imageFeatures = [MLMultiArray]()\nfor i in 1...6{\n    guard let image = UIImage(named:\"images/cat_\\(i).png\"),\n        let features = extractFeaturesFromImage(image:image) else{\n            fatalError(\"Failed to extract features\")\n    }\n\n    images.append(image)\n    imageFeatures.append(features)\n}\n```", "```py\nlet img1 = images[0]\nlet hist1 = HistogramView(frame:histogramViewFrame, data:imageFeatures[0])\n\nlet img2 = images[1]\nlet hist2 = HistogramView(frame:histogramViewFrame, data:imageFeatures[1])\n\n// cat front view\nlet img3 = images[2]\nlet hist3 = HistogramView(frame:histogramViewFrame, data:imageFeatures[2])\n\nlet img4 = images[3]\nlet hist4 = HistogramView(frame:histogramViewFrame, data:imageFeatures[3])\n\n// cats head\nlet img5 = images[4]\nlet hist5 = HistogramView(frame:histogramViewFrame, data:imageFeatures[4])\n\nlet img6 = images[5]\nlet hist6 = HistogramView(frame:histogramViewFrame, data:imageFeatures[5]) \n```", "```py\nfunc dot(vecA: MLMultiArray, vecB: MLMultiArray) -> Double {\n    guard vecA.shape.count == 1 && vecB.shape.count == 1 else{\n        fatalError(\"Expecting vectors (tensor with 1 rank)\")\n    }\n\n    guard vecA.count == vecB.count else {\n        fatalError(\"Excepting count of both vectors to be equal\")\n    }\n\n    let count = vecA.count\n    let vecAPtr = UnsafeMutablePointer<Double>(OpaquePointer(vecA.dataPointer))\n    let vecBPptr = UnsafeMutablePointer<Double>(OpaquePointer(vecB.dataPointer))\n    var output: Double = 0.0\n\n    vDSP_dotprD(vecAPtr, 1, vecBPptr, 1, &output, vDSP_Length(count))\n\n    var x: Double = 0\n\n    for i in 0..<vecA.count{\n        x += vecA[i].doubleValue * vecB[i].doubleValue\n    }\n\n    return x\n}\n\nfunc magnitude(vec: MLMultiArray) -> Double {\n    guard vec.shape.count == 1 else{\n        fatalError(\"Expecting a vector (tensor with 1 rank)\")\n    }\n\n    let count = vec.count\n    let vecPtr = UnsafeMutablePointer<Double>(OpaquePointer(vec.dataPointer))\n    var output: Double = 0.0\n    vDSP_svsD(vecPtr, 1, &output, vDSP_Length(count))\n\n    return sqrt(output)\n} \n```", "```py\nlet vecPtr = UnsafeMutablePointer<Double>(OpaquePointer(vec.dataPointer))\nvar output: Double = 0.0\nvDSP_svsD(vecPtr, 1, &output, vDSP_Length(vec.count))\n```", "```py\nvar similarities = Array(repeating: Array(repeating: 0.0, count: images.count), count: images.count)\n\nfor i in 0..<imageFeatures.count{\n    for j in 0..<imageFeatures.count{\n        let sim = cosineSimilarity(\n            vecA: imageFeatures[i],\n            vecB: imageFeatures[j])\n        similarities[i][j] = sim\n    }\n}\n```", "```py\nlet heatmap = HeatmapView(\n    frame:heatmapViewFrame,\n    images:images,\n    data:similarities)\n```", "```py\nlet sketchFeatureExtractor = cnnsketchfeatureextractor()\n```", "```py\nfunc extractFeaturesFromImage(image:CIImage) -> MLMultiArray?{\n    // obtain the CVPixelBuffer from the image\n    guard let imagePixelBuffer = image\n        .resize(size: self.targetSize)\n        .rescalePixels()?\n        .toPixelBuffer(context: self.context, gray: true) else {\n        return nil\n    }\n\n    guard let features = try? self.sketchFeatureExtractor\n        .prediction(image: imagePixelBuffer) else{\n        return nil\n    }\n\n    return features.classActivations\n}\n\nfunc cosineSimilarity(vecA: MLMultiArray,\n                                  vecB: MLMultiArray) -> Double {\n    return 1.0 - self.dot(vecA:vecA, vecB:vecB) /\n        (self.magnitude(vec: vecA) * self.magnitude(vec: vecB))\n}\n\nfunc dot(vecA: MLMultiArray, vecB: MLMultiArray) -> Double {\n    guard vecA.shape.count == 1 && vecB.shape.count == 1 else{\n        fatalError(\"Expecting vectors (tensor with 1 rank)\")\n    }\n\n    guard vecA.count == vecB.count else {\n        fatalError(\"Excepting count of both vectors to be equal\")\n    }\n\n    let count = vecA.count\n    let vecAPtr = UnsafeMutablePointer<Double>(\n        OpaquePointer(vecA.dataPointer)\n    )\n    let vecBPptr = UnsafeMutablePointer<Double>(\n        OpaquePointer(vecB.dataPointer)\n    )\n    var output: Double = 0.0\n\n    vDSP_dotprD(vecAPtr, 1,\n                vecBPptr, 1,\n                &output,\n                vDSP_Length(count))\n\n    var x: Double = 0\n\n    for i in 0..<vecA.count{\n        x += vecA[i].doubleValue * vecB[i].doubleValue\n    }\n\n    return x\n}\n\nfunc magnitude(vec: MLMultiArray) -> Double {\n    guard vec.shape.count == 1 else{\n        fatalError(\"Expecting a vector (tensor with 1 rank)\")\n    }\n\n    let count = vec.count\n    let vecPtr = UnsafeMutablePointer<Double>(\n        OpaquePointer(vec.dataPointer)\n    )\n    var output: Double = 0.0\n    vDSP_svsD(vecPtr, 1, &output, vDSP_Length(count))\n\n    return sqrt(output)\n}\n```", "```py\nguard let sketchFeatures = self.extractFeaturesFromImage(\n    image: sketchImage) else{\n    return nil\n}\n```", "```py\nvar similatiryScores = Array<Double>(\n    repeating:1.0,\n    count:images.count)\n\nfor i in 0..<images.count{\n    var similarityScore : Double = 1.0\n\n    if let imageFeatures = self.extractFeaturesFromImage(\n        image: images[i]){\n        similarityScore = self.cosineSimilarity(\n            vecA: sketchFeatures,\n            vecB: imageFeatures)\n    }\n\n    similatiryScores[i] = similarityScore\n\n    if self.isInterrupted{\n        return nil\n    }\n}\n```", "```py\nreturn images.enumerated().sorted { (elemA, elemB) -> Bool in\n    return similatiryScores[elemA.offset] < similatiryScores[elemB.offset]\n    }.map { (item) -> CIImage in\n        return item.element\n}\n```"]