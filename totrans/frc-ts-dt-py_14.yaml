- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Productionalizing Prophet
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Prophet 产品化
- en: If you have made it through all of the chapters in this book, congratulations!
    You are well prepared to take on any forecasting assignments Prophet can handle.
    This final chapter will cover a few additional features that can be helpful in
    a production environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经读完了这本书的所有章节，恭喜您！您已经为处理 Prophet 可以处理的任何预测任务做好了充分的准备。最后一章将介绍一些在生产环境中可能很有用的附加功能。
- en: 'In this chapter, you’ll learn how to save a trained model for reuse later and
    you’ll learn how you can speed up model fitting when new data becomes available.
    To close out the chapter, you’ll discover a new series of interactive plots that
    can be used in a web dashboard to share your work with a wider audience. The topics
    covered in this chapter will be the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何保存训练好的模型以便稍后重用，您还将了解当新数据可用时如何加快模型拟合的速度。为了结束本章，您将发现一系列新的交互式图表，这些图表可以用于网络仪表板，以便与更广泛的受众分享您的工作。本章涵盖的主题如下：
- en: Saving a model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存模型
- en: Updating a fitted model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新拟合模型
- en: Making interactive plots with Plotly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Plotly 制作交互式图表
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The data files and code for the examples in this chapter can be found at [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中示例的数据文件和代码可以在 [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition)
    找到。
- en: Saving a model
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存模型
- en: In [*Chapter 11*](B19630_11.xhtml#_idTextAnchor728), *Managing Uncertainty Intervals*,
    you forecast the number of crimes per day in the city of Baltimore, using **Markov
    chain Monte Carlo** (**MCMC**) sampling. This was a long computation, and you
    were only using daily data. Had you used the Divvy hourly data instead, a dataset
    more than 10 times larger, the computation would have been even longer. And these
    two datasets are certainly smaller than many you’ll encounter in the real world.
    If Prophet provided no way to save your work, every time you trained a model,
    you would have to leave the model in your computer’s memory for as long as you
    wanted to use it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 11 章*](B19630_11.xhtml#_idTextAnchor728) *管理不确定性区间* 中，您使用 **马尔可夫链蒙特卡洛**（**MCMC**）抽样预测了巴尔的摩市每天的犯罪数量。这是一个计算量很大的过程，而你只使用了每日数据。如果你使用的是
    Divvy 每小时数据，一个比每日数据大 10 倍的数据集，计算量将会更大。而且这两个数据集肯定比你在现实世界中遇到的大多数数据集都要小。如果 Prophet
    没有提供保存您工作的方法，每次您训练一个模型时，您都必须将模型留在您的计算机内存中，直到您想要使用它为止。
- en: Maybe you’re familiar with the `pickle` module in Python—this works great to
    save your trained models in `sklearn`, for example. However, Prophet uses Stan
    in the backend to build its models and these Stan objects don’t pickle well. Fortunately,
    Prophet includes some functions to serialize your model in JSON and re-open it
    later. So, once your model is trained, you can put it away for the day and bring
    it back later whenever you want to predict a future date.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您熟悉 Python 中的 `pickle` 模块——这对于在 `sklearn` 中保存训练好的模型来说效果很好。然而，Prophet 在后端使用
    Stan 来构建其模型，这些 Stan 对象并不适合 pickle。幸运的是，Prophet 包含了一些将您的模型序列化为 JSON 并稍后重新打开的函数。因此，一旦您的模型训练完成，您就可以将其存放在一边，并在需要预测未来日期时再取出来。
- en: 'We’ll use the Baltimore crime data again to see how to save your model. We’ll
    need to import pandas in order to read the `.csv` file; Prophet, of course, to
    build our model; and we’ll also need to import `json` to save and reopen the file.
    The functions to convert a model object into JSON and back again are imported
    from Prophet’s `serialize` package:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用巴尔的摩犯罪数据来查看如何保存您的模型。我们需要导入 pandas 来读取 `.csv` 文件；当然，导入 Prophet 来构建我们的模型；我们还需要导入
    `json` 来保存和重新打开文件。将模型对象转换为 JSON 并再次转换的函数是从 Prophet 的 `serialize` 包中导入的：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we’ll run through the now-familiar process of opening our data and training
    a model. We’re also discarding the outliers from the data, as we did in [*Chapter
    11*](B19630_11.xhtml#_idTextAnchor728), *Managing* *Uncertainty Intervals*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将熟悉的过程运行一遍，打开我们的数据和训练一个模型。我们也在像在第 11 章 *管理不确定性区间* 中做的那样，丢弃数据中的异常值：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ve now got our trained model. Previously, you would have needed to keep your
    Python kernel running and the model in memory for as long as you wanted to access
    it. At the end of the day, you would want to save it, shut down your machine,
    and go home for the night, but you would lose all that work.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了我们的训练模型。以前，你需要保持你的Python内核运行，并将模型保存在内存中，直到你想访问它为止。在一天结束时，你想要保存它，关闭你的机器，然后回家过夜，但你将失去所有这些工作。
- en: 'In the following code, you’ll use the `with` statement to create a context
    manager so that you can open a JSON file, and Python will automatically close
    it when you’re done. The `''w''` and `''r''` arguments used in the following statements
    merely stand for *write* and *read*. This code block uses Prophet’s `model_to_json`
    function to convert the `model` object into a JSON file, and then it saves it
    to your hard drive:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，你将使用`with`语句创建一个上下文管理器，这样你就可以打开一个JSON文件，Python会在你完成后自动关闭它。以下语句中使用的`'w'`和`'r'`参数仅代表*写入*和*读取*。此代码块使用Prophet的`model_to_json`函数将`模型`对象转换为JSON文件，并将其保存到你的硬盘上：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that the file is saved, you can safely shut down Python. To convert the
    JSON file back into a `model` object, simply use the `json_to_model` function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文件已保存，你可以安全地关闭Python。要将JSON文件转换回`模型`对象，只需使用`json_to_model`函数：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the model reloaded, you can use it just as you would any fitted model;
    for example, you can plot a forecast:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载模型后，你可以像使用任何拟合模型一样使用它；例如，你可以绘制一个预测图：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With no `future` created, this is just the fitted model:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 没有创建`未来`，这只是一个拟合模型：
- en: '![Figure 14.1 – Baltimore crime forecast](img/Fig_14.1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 巴尔的摩犯罪预测](img/Fig_14.1.jpg)'
- en: Figure 14.1 – Baltimore crime forecast
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 巴尔的摩犯罪预测
- en: Saving and re-opening your work can certainly be helpful, but the real value
    is when you keep a model around and every day update it with new data, as we’ll
    do next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并重新打开你的工作当然很有帮助，但真正的价值在于你保留了一个模型，并且每天用新数据更新它，正如我们接下来将要做的。
- en: Updating a fitted model
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新拟合模型
- en: Forecasting is unique among predictive models in that the value of the data
    is its recency and each passing moment creates a new set of valuable data to use.
    A common situation with a forecast model is the need to refit it as more data
    comes in. The city of Baltimore, for example, may use the crime model to predict
    how many crimes they might expect to happen tomorrow, so as to better place their
    officers in advance. Once tomorrow arrives, they can record the actual data, retrain
    their model, and predict for the next day.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 预测在预测模型中是独特的，因为数据的价值在于其新鲜度，每一刻的过去都会产生一组新的、有价值的数据来使用。对于预测模型来说，一个常见的情况是需要随着数据的增加而重新拟合模型。例如，巴尔的摩市可能会使用犯罪模型来预测他们可能期望明天发生的犯罪数量，以便提前更好地部署他们的警官。一旦明天到来，他们可以记录实际数据，重新训练他们的模型，并为第二天进行预测。
- en: Prophet is unable to handle online data, which means it cannot add a single
    new data observation and quickly update the model. Prophet must be trained offline—the
    new observation will be added to the existing data and the model will be completely
    retrained. But it doesn’t have to be completely retrained from scratch and the
    following technique will save a lot of time when retraining.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet无法处理在线数据，这意味着它不能添加单个新的数据观察值并快速更新模型。Prophet必须离线训练——新的观察值将被添加到现有数据中，并且模型将完全重新训练。但不必从头开始完全重新训练，以下技术将在重新训练时节省大量时间。
- en: Prophet is essentially an optimization problem. Deep in the code are some settings
    to pick a set of initial parameters that Prophet believes will be close to the
    actual parameters needed to model the forecast curve. It then creates its curve,
    measures the error with existing data points, updates the parameters to reduce
    the error, and repeats.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet本质上是一个优化问题。在代码深处有一些设置，用于选择一组初始参数，Prophet认为这些参数将接近实际参数，这些参数是建模预测曲线所需的。然后它创建其曲线，用现有数据点测量误差，更新参数以减少误差，并重复。
- en: Many hundreds or thousands of iterations may occur as Prophet attempts to get
    closer and closer to the best set of parameters. You can greatly speed up this
    optimization problem by taking the already-optimized parameters from yesterday’s
    model and using them as better initializations for today’s model. The assumption
    is that today’s data point will not dramatically change the overall model, which
    is generally a very good assumption. Let’s see how this technique works.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当Prophet试图越来越接近最佳参数集时，可能会发生数百或数千次迭代。你可以通过使用昨天模型的已经优化的参数来大大加快这个优化问题，将它们作为今天模型的更好初始化。假设今天的观测点不会显著改变整体模型，这通常是一个非常好的假设。让我们看看这个技术是如何工作的。
- en: 'We’ll begin by creating a DataFrame of the Baltimore crime data with the final
    observation removed. This is *yesterday’s* data:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个包含最终观测值的Baltimore犯罪数据的DataFrame。这是**昨天的**数据：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we’ll fit `model1` on this data:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在这个数据上拟合`model1`：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The city of Baltimore could use this model to make a prediction about the next
    day’s activity, for example. Now, let’s say that the next day has arrived; we
    record the day’s crime level and want to update our model with `df`, *today’s*
    data, which has that final data point included. Let’s first do it from scratch
    and use the IPython `timeit` magic function to see how long it takes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 巴尔的摩市可以使用这个模型来预测第二天活动的预测，例如。现在，假设第二天已经到来；我们记录当天的犯罪水平，并希望用`df`，**今天的**数据更新我们的模型，该数据包含最终的数据点。让我们首先从头开始，并使用IPython的`timeit`魔法函数来查看它需要多长时间：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On my current machine, as I write this, the process took about 865 milliseconds
    according to the output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我写这篇文章的时候，在我的当前机器上，这个过程根据输出大约花费了865毫秒：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s do it again, but instead of starting from scratch, we’ll give Prophet
    a *warm start* by passing it the parameters from yesterday’s model for initialization.
    We first need to define a class to format those parameters correctly:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次尝试，但这次不是从头开始，我们将通过传递昨天的模型参数来为Prophet提供一个**预热启动**。我们首先需要定义一个类来正确格式化这些参数：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This class simply opens up the `model.params` dictionary and saves the relevant
    values in a new dictionary formatted as the Stan backend requires. We now use
    this class to extract the parameters from `model1` and pass this initialization
    to the `fit` method, again timing the process:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只是打开`model.params`字典，并将相关值保存到一个新字典中，该字典格式符合Stan后端的要求。我们现在使用这个类从`model1`中提取参数，并将这个初始化传递给`fit`方法，再次计时这个过程：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When I run that command, I see more than a 4x improvement in training speed:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行那个命令时，我看到了训练速度超过4倍的提升：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 0.195 seconds compared to 0.865 seconds is a dramatic improvement. The amount
    of time saved depends on many factors and will often vary even when you repeat
    the experiment again.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 0.195秒与0.865秒相比是一个显著的改进。节省的时间取决于许多因素，并且即使你再次重复实验，也可能会发生变化。
- en: 'There is one caveat with this method though: if the locations of changepoints
    change, the updated model may actually take *longer* to fit than just fitting
    from scratch. For these reasons, this method works best when adding a very small
    amount of new data relative to the existing data, as we did here by adding one
    day to several years of data.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法有一个注意事项：如果变化点的位置发生变化，更新后的模型实际上可能需要**更长**的时间来拟合，而不是从头开始拟合。因此，当相对于现有数据添加非常少量的新数据时，这种方法效果最好，正如我们在这里通过添加一天的数据到几年的数据中所做的那样。
- en: With MAP estimation, as we just did in the previous example, each iteration
    is an optimization problem. This means that better initialization will speed things
    up considerably. With MCMC sampling, however, each iteration must fully run through
    each link in the Markov chain (refer back to [*Chapter 11*](B19630_11.xhtml#_idTextAnchor728),
    *Managing Uncertainty Intervals*, for a review of the difference between MAP estimation
    and MCMC sampling).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MAP估计，正如我们在上一个例子中所做的那样，每次迭代都是一个优化问题。这意味着更好的初始化将大大加快速度。然而，在使用MCMC采样时，每次迭代必须完全运行通过马尔可夫链中的每个链接（回顾[*第11章*](B19630_11.xhtml#_idTextAnchor728)，*管理不确定性区间*，以了解MAP估计与MCMC采样的区别）。
- en: What this means is that warm-starting will speed up MAP estimation considerably
    but will not speed up MCMC sampling. Warm-starting will, however, increase the
    quality of each Markov chain iteration. So, if you do a warm start with MCMC sampling,
    you can probably get away with fewer `mcmc_samples` without a significant reduction
    in result quality.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着预热将显著加快 MAP 估计的速度，但不会加快 MCMC 样本的速度。然而，预热会增加每个马尔可夫链迭代的品质。所以，如果你使用 MCMC 样本进行预热，你可能会在结果质量显著降低的情况下减少
    `mcmc_samples` 的数量。
- en: 'This reduction in `mcmc_samples` creates an opportunity to speed up MCMC sampling
    on any new model. The idea is to train an initial model with MAP estimation, and
    then use that model to warm start a model with MCMC sampling, but using fewer
    `mcmc_samples` than you would otherwise choose:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 减少 `mcmc_samples` 的数量为加快任何新模型的 MCMC 样本速度创造了机会。想法是使用 MAP 估计训练一个初始模型，然后使用该模型以
    MCMC 样本预热一个模型，但使用的 `mcmc_samples` 比你通常选择的要少：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code block, we created an initial `model1` using MAP estimation
    and all data. We then used the parameters from `model1` to warm start `model2`,
    which uses MCMC sampling, but only `mcmc_samples=200`, instead of the value of
    `300` we chose in [*Chapter 11*](B19630_11.xhtml#_idTextAnchor728), *Managing
    Uncertainty Intervals*. This will result in an MCMC-sampled model with roughly
    the same performance as earlier but trained in two-thirds of the time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用 MAP 估计和所有数据创建了一个初始 `model1`。然后，我们使用 `model1` 的参数预热 `model2`，它使用
    MCMC 样本，但只有 `mcmc_samples=200`，而不是我们在 [*第 11 章*](B19630_11.xhtml#_idTextAnchor728)
    中选择的 `300`，*管理不确定性区间*。这将导致一个具有与之前相似性能的 MCMC 样本模型，但训练时间缩短了三分之二。
- en: In summary, warm starting with MAP estimation (that is, when `mcmc_samples=0`)
    will speed up your model training. Warm starting will not speed up a model when
    `mcmc_samples` is greater than 0 though, but in this case, you can quickly train
    a model with MAP estimation and then warm start your model with `mcmc_samples`
    set to a reduced value, without losing much quality. Now, let’s learn how to use
    Prophet to make interactive plots.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，使用 MAP 估计预热（即当 `mcmc_samples=0` 时）将加快你的模型训练速度。但是，当 `mcmc_samples` 大于 0
    时，预热不会加快模型的速度，但在此情况下，你可以快速使用 MAP 估计训练一个模型，然后将你的模型预热到 `mcmc_samples` 设置为降低的值，而不会损失太多质量。现在，让我们学习如何使用
    Prophet 制作交互式图表。
- en: Making interactive plots with Plotly
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Plotly 制作交互式图表
- en: In this final section, we’ll use the Plotly library to build some interactive
    plots. **Plotly** is a completely separate visualization package from the **Matplotlib**
    package, which we’ve been using throughout this book. A plot made with Plotly
    is richly interactive, allowing tooltips on mouse hover, zooming in and out of
    a plot, and all sorts of other interactivities.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们将使用 Plotly 库构建一些交互式图表。**Plotly** 是一个完全独立的可视化包，与我们在本书中使用的 **Matplotlib**
    包不同。使用 Plotly 制作的图表具有丰富的交互性，允许鼠标悬停时显示工具提示，可以放大和缩小图表，以及所有 sorts 的其他交互性。
- en: If you’re familiar with Tableau or Power BI, Plotly brings similar interactivity
    to Python. Additionally, the Plotly team also built **Dash**, a library for creating
    web-based dashboards. A full tutorial for creating such a dashboard is beyond
    the scope of this book, but I encourage you to learn about this valuable tool
    if you would like to share your Prophet forecasts with a wide audience.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Tableau 或 Power BI，Plotly 将类似的交互性带到了 Python 中。此外，Plotly 团队还构建了 **Dash**，这是一个用于创建基于网页的仪表板的库。创建此类仪表板的全教程超出了本书的范围，但我鼓励你学习这个有价值的工具，如果你希望与更广泛的受众分享你的
    Prophet 预测。
- en: 'Prophet does not automatically install Plotly as a dependency, so before we
    begin, you will need to install it on your machine. It is a simple process and
    can be accomplished through either `conda` or `pip`. Here is the `conda` installation
    command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 不会自动安装 Plotly 作为依赖项，所以在我们开始之前，你需要在你的机器上安装它。这是一个简单的过程，可以通过 `conda` 或
    `pip` 完成。以下是 `conda` 安装命令：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you have not installed Anaconda or Miniconda though, you will have to use
    `pip`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装 Anaconda 或 Miniconda，你将不得不使用 `pip`：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you tend to work in Jupyter Notebook or JupyterLab, you will also want to
    install some support packages. This can be done through `conda`, as shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你倾向于在 Jupyter Notebook 或 JupyterLab 中工作，你还需要安装一些支持包。这可以通过 `conda` 完成，如下所示：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you do not have `conda`, you may also use `pip` instead:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 `conda`，你也可以使用 `pip`：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you have trouble with any of these commands, the best resource is Plotly’s
    own documentation: [https://plotly.com/python/getting-started/](https://plotly.com/python/getting-started/).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到这些命令中的任何问题，最好的资源是Plotly自己的文档：[https://plotly.com/python/getting-started/](https://plotly.com/python/getting-started/)。
- en: You have already learned about many of the plotting functions in Prophet’s `plot`
    package throughout the examples in this book. There are four functions that we
    haven’t touched on yet; these take many of the same keywords as the Matplotlib
    counterparts you have learned already but output a Plotly chart instead.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在本书的例子中学习了Prophet的`plot`包中的许多绘图函数。还有四个我们还没有涉及到的函数；这些函数与你已经学习过的Matplotlib对应函数具有许多相同的参数，但输出的是Plotly图表。
- en: Important note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This book will contain static images of Plotly plots, but if you run the example
    code in a Jupyter notebook, you’ll be able to manipulate the image in a richly
    interactive environment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书将包含Plotly图表的静态图像，但如果你在Jupyter笔记本中运行示例代码，你将能够在丰富交互的环境中操作图像。
- en: To demonstrate these tools, let’s use the Divvy data again, and use temperature
    as an extra regressor. We won’t be using Matplotlib at all in this section, so
    no need to import it. We’ve already got pandas and Prophet imported from the previous
    sections, but we’ll need to make a few more imports here.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些工具，让我们再次使用Divvy数据，并使用温度作为额外的回归器。在这个部分中我们根本不会使用Matplotlib，所以不需要导入它。我们已经从前面的部分中导入了pandas和Prophet，但在这里我们还需要进行一些额外的导入。
- en: 'If you recall from [*Chapter 9*](B19630_09.xhtml#_idTextAnchor599), *Including
    Additional Regressors*, we artificially reduced our training data by 2 weeks so
    that we could forecast 2 weeks ahead while using weather conditions as additional
    regressors. We’ll do that again here, so we need to import `timedelta` to help
    out. Most importantly though, we’ll import `plotly.offline` and initialize notebook
    mode:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得从[*第9章*](B19630_09.xhtml#_idTextAnchor599)中的*包括额外的回归器*，我们人为地减少了我们的训练数据两周，这样我们就可以在同时使用天气条件作为额外回归器的情况下预测两周。我们在这里也会这样做，因此我们需要导入`timedelta`来帮忙。但最重要的是，我们将导入`plotly.offline`并初始化笔记本模式：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let’s read in our data and put it into a DataFrame. We’ll only use one
    additional regressor in this example, `temperature`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们读取我们的数据并将其放入一个数据框中。在这个例子中，我们只会使用一个额外的回归器，即`temperature`：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we just build our model as before. We create a regressor for temperature,
    then fit the model on the data while excluding the final 2 weeks. We next make
    a future forecast of 2 weeks, using those unfitted 2 weeks of `temperature` data
    in the `future` DataFrame:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们就像以前一样构建我们的模型。我们创建一个温度回归器，然后在数据上拟合模型，同时排除最后两周。接下来，我们使用`future`数据框中的未拟合的2周`temperature`数据进行两周的未来预测：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So far, this should all be a review (except for importing and initializing
    Plotly). But now, we’ll import those final four functions from the `plot` package:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这些都应该是复习内容（除了导入和初始化Plotly）。但现在，我们将从`plot`包中导入那四个最终函数：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let’s run through these one by one.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一运行这些函数。
- en: Plotly forecast plot
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Plotly预测图表
- en: 'First up is `plot_plotly`. To use this function, you simply pass in the model
    and the forecast. I’m also including the `trend=True` argument to include the
    trend line in the plot. You could also add `changepoints=True`, and it would completely
    mimic the `add_changepoints_to_plot` Matplotlib function. The `py.iplot(fig)`
    line is analogous to Matplotlib’s `plt.show()`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是`plot_plotly`函数。要使用此函数，你只需传入模型和预测。我还包括`trend=True`参数以在图表中包含趋势线。你也可以添加`changepoints=True`，这将完全模仿Matplotlib的`add_changepoints_to_plot`函数。`py.iplot(fig)`行与Matplotlib的`plt.show()`类似：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This screenshot also displays the tooltip shown on hovering over the point
    for **May** **10, 2015**:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此截图还显示了在悬停在**2015年5月10日**的点上的工具提示：
- en: "![Figure \uFEFF\uFEFF14.2 – Plotly plot](img/Fig_14.2.jpg)"
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – Plotly图表](img/Fig_14.2.jpg)'
- en: Figure 14.2 – Plotly plot
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – Plotly图表
- en: Plotly components plot
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Plotly组件图表
- en: 'Next up, we’ll look at the Plotly components plot. This is much the same as
    the Matplotlib version, but it also includes interactivity. I’m also including
    the `figsize` argument to reduce the size of this one a bit:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看Plotly组件图表。这与Matplotlib版本非常相似，但它还包括交互性。我还包括`figsize`参数来稍微减小这个图表的大小：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This plot shows the same subplots as `plot_components`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表显示了与`plot_components`相同的子图：
- en: "![Figure 14.3 – P\uFEFF\uFEFFlotly components plot](img/Fig_14.3.jpg)"
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – Plotly组件图表](img/Fig_14.3.jpg)'
- en: Figure 14.3 – Plotly components plot
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – Plotly组件图表
- en: Plotly single component plot
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Plotly单个组件图表
- en: 'I wanted to use this Divvy data so that we could use the extra temperature
    regressor. We could have plotted any of the subplots in *Figure 14**.3* using
    this next function, but all of them can be handled with other functions, except
    for extra regressors. Plotting those alone requires the use of the `plot_forecast_components_plotly`
    function. Here, we pass in the `''``temp''` component:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我想使用这些 Divvy 数据，这样我们就可以使用额外的温度回归器。我们可以使用这个下一个函数在 *图 14.3* 中的任何子图上绘制，但所有这些都可以用其他函数处理，除了额外的回归器。仅绘制这些回归器需要使用
    `plot_forecast_components_plotly` 函数。在这里，我们传递了 `'temp'` 组件：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As with the other plots in this section, a static image does not do them justice.
    Plotly was intended to be used in an interactive environment; these plots beg
    to be placed on a dashboard, not printed in a book. Here, I’m showing a hover
    tooltip again:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与本节中的其他图表一样，静态图像并不能完全展示它们的魅力。Plotly 是为了在交互式环境中使用；这些图表迫切需要放置在仪表板上，而不是打印在书中。在这里，我再次展示了悬停工具提示：
- en: "![Figure 14.4 –\uFEFF\uFEFF Plotly temperature plot](img/Fig_14.4.jpg)"
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: "![图 14.4 –\uFEFF\uFEFF Plotly 温度图](img/Fig_14.4.jpg)"
- en: Figure 14.4 – Plotly temperature plot
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – Plotly 温度图
- en: Plotly seasonality plot
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Plotly 季节性图
- en: 'In the final Plotly function, we’ll plot the yearly seasonality using the `plot_seasonality_plotly`
    function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终的 Plotly 函数中，我们将使用 `plot_seasonality_plotly` 函数绘制年度季节性：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The Plotly toolbar has been left out of the components plot to save space but
    is included in all the others; you can see it at the upper right of *Figures 14.2*,
    *14.4*, and *14.5*. In the following seasonality plot, I’ve used the **Toggle
    Spike Lines** and **Compare Data** buttons from this toolbar to add further information
    to the hover tooltip, seen here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，Plotly 工具栏被省略在组件图中，但包含在其他所有图表中；您可以在 *图 14.2*、*14.4* 和 *14.5* 的右上角看到它。在下面的季节性图中，我使用了工具栏中的
    **切换峰值线** 和 **比较数据** 按钮来向悬停工具提示添加更多信息，如下所示：
- en: "![Figure 14.5 – Plotly seasonality \uFEFFplot](img/Fig_14.5.jpg)"
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: "![图 14.5 –\uFEFF\uFEFF Plotly 季节性 \uFEFF图](img/Fig_14.5.jpg)"
- en: Figure 14.5 – Plotly seasonality plot
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – Plotly 季节性图
- en: I strongly encourage you to explore these plots in a Jupyter notebook, and if
    you find them useful, consider putting them together in a dashboard using Dash.
    There are plenty of tutorials available online.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您在 Jupyter 笔记本中探索这些图表，如果您觉得它们很有用，可以考虑使用 Dash 将它们组合到一个仪表板中。网上有很多相关的教程。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This last chapter in the book was the most optional of all of them, but for
    those of you who often work in a production environment, these tools will be invaluable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的最后一章是所有章节中最可选的，但对于那些经常在生产环境中工作的人来说，这些工具将非常有价值。
- en: In this chapter, you learned how to save a model to your hard drive using JSON
    serialization, so you can share it or open it up later without requiring the model
    to be retrained. You also learned how to update a model that has already been
    fitted, another procedure designed to save you time. Finally, you examined a new
    plot format, an impressive tool to make your plots interactive in a browser, and
    hopefully, you saw the potential of packaging this information into a dashboard.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用 JSON 序列化将模型保存到您的硬盘上，这样您就可以在以后无需重新训练模型的情况下分享或打开它。您还学习了如何更新已经拟合好的模型，这是另一种旨在节省您时间的程序。最后，您考察了一种新的图表格式，这是一个令人印象深刻的工具，可以使您的图表在浏览器中交互式显示，希望您已经看到了将这些信息打包到仪表板中的潜力。
- en: Together, what you learned in this chapter will help you to update your model
    as time progresses and new data comes in, and share that model via live, web-based
    interactive dashboards.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所学的内容将帮助您随着时间的推移和新数据的到来更新您的模型，并通过基于网络的交互式仪表板共享该模型。
