["```py\n[[0, -0.25, 0],\n [-0.25, 1, -0.25],\n [0, -0.25, 0]]\n```", "```py\nimport cv2\nimport numpy as np\nfrom scipy import ndimage\n\nkernel_3x3 = np.array([[-1, -1, -1],\n                   [-1,  8, -1],\n                   [-1, -1, -1]])\n\nkernel_5x5 = np.array([[-1, -1, -1, -1, -1],\n                       [-1,  1,  2,  1, -1],\n                       [-1,  2,  4,  2, -1],\n                       [-1,  1,  2,  1, -1],\n                       [-1, -1, -1, -1, -1]])\n```", "```py\nimg = cv2.imread(\"../images/color1_small.jpg\", 0)\n\nk3 = ndimage.convolve(img, kernel_3x3)\nk5 = ndimage.convolve(img, kernel_5x5)\n\nblurred = cv2.GaussianBlur(img, (11,11), 0)\ng_hpf = img - blurred\n\ncv2.imshow(\"3x3\", k3)\ncv2.imshow(\"5x5\", k5)\ncv2.imshow(\"g_hpf\", g_hpf)\ncv2.waitKey()\ncv2.destroyAllWindows()\n```", "```py\nimport cv2\nimport numpy\nimport utils\n```", "```py\nimport cv2\nimport numpy\nimport scipy.interpolate\n```", "```py\ndef strokeEdges(src, dst, blurKsize = 7, edgeKsize = 5):\n    if blurKsize >= 3:\n        blurredSrc = cv2.medianBlur(src, blurKsize)\n        graySrc = cv2.cvtColor(blurredSrc, cv2.COLOR_BGR2GRAY)\n    else:\n        graySrc = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)\n    cv2.Laplacian(graySrc, cv2.CV_8U, graySrc, ksize = edgeKsize)\n    normalizedInverseAlpha = (1.0 / 255) * (255 - graySrc)\n    channels = cv2.split(src)\n    for channel in channels:\n        channel[:] = channel * normalizedInverseAlpha\n    cv2.merge(channels, dst)\n```", "```py\nkernel = numpy.array([[-1, -1, -1],\n                      [-1,  9, -1],\n                      [-1, -1, -1]])\n```", "```py\ncv2.filter2D(src, -1, kernel, dst)\n```", "```py\nclass VConvolutionFilter(object):\n    \"\"\"A filter that applies a convolution to V (or all of BGR).\"\"\"\n\n    def __init__(self, kernel):\n        self._kernel = kernel\n\n    def apply(self, src, dst):\n        \"\"\"Apply the filter with a BGR or gray source/destination.\"\"\"\n        cv2.filter2D(src, -1, self._kernel, dst)\n\nclass SharpenFilter(VConvolutionFilter):\n    \"\"\"A sharpen filter with a 1-pixel radius.\"\"\"\n\n    def __init__(self):\n        kernel = numpy.array([[-1, -1, -1],\n                              [-1,  9, -1],\n                              [-1, -1, -1]])\n        VConvolutionFilter.__init__(self, kernel)\n```", "```py\nclass FindEdgesFilter(VConvolutionFilter):\n    \"\"\"An edge-finding filter with a 1-pixel radius.\"\"\"\n\n    def __init__(self):\n        kernel = numpy.array([[-1, -1, -1],\n                              [-1,  8, -1],\n                              [-1, -1, -1]])\n        VConvolutionFilter.__init__(self, kernel)\n```", "```py\nclass BlurFilter(VConvolutionFilter):\n    \"\"\"A blur filter with a 2-pixel radius.\"\"\"\n\n    def __init__(self):\n        kernel = numpy.array([[0.04, 0.04, 0.04, 0.04, 0.04],\n                              [0.04, 0.04, 0.04, 0.04, 0.04],\n                              [0.04, 0.04, 0.04, 0.04, 0.04],\n                              [0.04, 0.04, 0.04, 0.04, 0.04],\n                              [0.04, 0.04, 0.04, 0.04, 0.04]])\n        VConvolutionFilter.__init__(self, kernel)\n```", "```py\nclass EmbossFilter(VConvolutionFilter):\n    \"\"\"An emboss filter with a 1-pixel radius.\"\"\"\n\n    def __init__(self):\n        kernel = numpy.array([[-2, -1, 0],\n                              [-1,  1, 1],\n                              [ 0,  1, 2]])\n        VConvolutionFilter.__init__(self, kernel)\n```", "```py\nimport cv2\nimport filters\nfrom managers import WindowManager, CaptureManager\n\nclass Cameo(object):\n\n    def __init__(self):\n        self._windowManager = WindowManager('Cameo',\n                                            self.onKeypress)\n        self._captureManager = CaptureManager(\n            cv2.VideoCapture(0), self._windowManager, True)\n self._curveFilter = filters.BGRPortraCurveFilter()\n\n    def run(self):\n        \"\"\"Run the main loop.\"\"\"\n        self._windowManager.createWindow()\n        while self._windowManager.isWindowCreated:\n            self._captureManager.enterFrame()\n            frame = self._captureManager.frame\n\n filters.strokeEdges(frame, frame)\n self._curveFilter.apply(frame, frame)\n\n            self._captureManager.exitFrame()\n            self._windowManager.processEvents()\n\n    # ... The rest is the same as in Chapter 2.\n```", "```py\nimport cv2\nimport numpy as np\n\nimg = cv2.imread(\"../images/statue_small.jpg\", 0)\ncv2.imwrite(\"canny.jpg\", cv2.Canny(img, 200, 300))\ncv2.imshow(\"canny\", cv2.imread(\"canny.jpg\"))\ncv2.waitKey()\ncv2.destroyAllWindows()\n```", "```py\nimport cv2\nimport numpy as np\n\nimg = np.zeros((200, 200), dtype=np.uint8)\nimg[50:150, 50:150] = 255\n\nret, thresh = cv2.threshold(img, 127, 255, 0)\nimage, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\ncolor = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\nimg = cv2.drawContours(color, contours, -1, (0,255,0), 2)\ncv2.imshow(\"contours\", color)\ncv2.waitKey()\ncv2.destroyAllWindows()\n```", "```py\nimport cv2\nimport numpy as np\n\nimg = cv2.pyrDown(cv2.imread(\"hammer.jpg\", cv2.IMREAD_UNCHANGED))\n\nret, thresh = cv2.threshold(cv2.cvtColor(img.copy(), cv2.COLOR_BGR2GRAY) , 127, 255, cv2.THRESH_BINARY)\nimage, contours, hier = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\nfor c in contours:\n  # find bounding box coordinates\n  x,y,w,h = cv2.boundingRect(c)\n  cv2.rectangle(img, (x,y), (x+w, y+h), (0, 255, 0), 2)\n\n  # find minimum area\n  rect = cv2.minAreaRect(c)\n  # calculate coordinates of the minimum area rectangle\n  box = cv2.boxPoints(rect)\n  # normalize coordinates to integers\n  box = np.int0(box)\n  # draw contours\n  cv2.drawContours(img, [box], 0, (0,0, 255), 3)\n\n  # calculate center and radius of minimum enclosing circle\n  (x,y),radius = cv2.minEnclosingCircle(c)\n  # cast to integers\n  center = (int(x),int(y))\n  radius = int(radius)\n  # draw the circle\n  img = cv2.circle(img,center,radius,(0,255,0),2)\n\ncv2.drawContours(img, contours, -1, (255, 0, 0), 1)\ncv2.imshow(\"contours\", img)\n```", "```py\nx,y,w,h = cv2.boundingRect(c)\n```", "```py\n  cv2.rectangle(img, (x,y), (x+w, y+h), (0, 255, 0), 2)\n```", "```py\nrect = cv2.minAreaRect(c)\nbox = cv2.boxPoints(rect)\n  box = np.int0(box)\n```", "```py\ncv2.drawContours(img, [box], 0, (0,0, 255), 3)\n```", "```py\n  (x,y),radius = cv2.minEnclosingCircle(c)\n  center = (int(x),int(y))\n  radius = int(radius)\n  img = cv2.circle(img,center,radius,(0,255,0),2)\n```", "```py\nepsilon = 0.01 * cv2.arcLength(cnt, True)\napprox = cv2.approxPolyDP(cnt, epsilon, True)\n```", "```py\nhull = cv2.convexHull(cnt)\n```", "```py\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('lines.jpg')\ngray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)\nedges = cv2.Canny(gray,50,120)\nminLineLength = 20\nmaxLineGap = 5\nlines = cv2.HoughLinesP(edges,1,np.pi/180,100,minLineLength,maxLineGap)\nfor x1,y1,x2,y2 in lines[0]:\n  cv2.line(img,(x1,y1),(x2,y2),(0,255,0),2)\n\ncv2.imshow(\"edges\", edges)\ncv2.imshow(\"lines\", img)\ncv2.waitKey()\ncv2.destroyAllWindows()\n```", "```py\nimport cv2\nimport numpy as np\n\nplanets = cv2.imread('planet_glow.jpg')\ngray_img = cv2.cvtColor(planets, cv2.COLOR_BGR2GRAY)\nimg = cv2.medianBlur(gray_img, 5)\ncimg = cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)\n\ncircles = cv2.HoughCircles(img,cv2.HOUGH_GRADIENT,1,120,\n                            param1=100,param2=30,minRadius=0,maxRadius=0)\n\ncircles = np.uint16(np.around(circles))\n\nfor i in circles[0,:]:\n    # draw the outer circle\n    cv2.circle(planets,(i[0],i[1]),i[2],(0,255,0),2)\n    # draw the center of the circle\n    cv2.circle(planets,(i[0],i[1]),2,(0,0,255),3)\n\ncv2.imwrite(\"planets_circles.jpg\", planets)\ncv2.imshow(\"HoughCirlces\", planets)\ncv2.waitKey()\ncv2.destroyAllWindows()\n```"]