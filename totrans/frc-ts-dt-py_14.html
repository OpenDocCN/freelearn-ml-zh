<html><head></head><body>
<div id="_idContainer286">
<h1 class="chapter-number" id="_idParaDest-152"><a id="_idTextAnchor927"/><a id="_idTextAnchor928"/><a id="_idTextAnchor929"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-153"><a id="_idTextAnchor930"/><span class="koboSpan" id="kobo.2.1">Productionalizing Prophet</span></h1>
<p><span class="koboSpan" id="kobo.3.1">If you have made it through all of the chapters in this book, congratulations! </span><span class="koboSpan" id="kobo.3.2">You are well prepared to take on any forecasting assignments Prophet can handle. </span><span class="koboSpan" id="kobo.3.3">This final chapter will cover a few additional features that can be helpful in a </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">production environment.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, you’ll learn how to save a trained model for reuse later and you’ll learn how you can speed up model fitting when new data becomes available. </span><span class="koboSpan" id="kobo.5.2">To close out the chapter, you’ll discover a new series of interactive plots that can be used in a web dashboard to share your work with a wider audience. </span><span class="koboSpan" id="kobo.5.3">The topics covered in this chapter will be </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Saving </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">a model</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Updating a </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">fitted model</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Making interactive plots </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">with Plotly</span></span></li>
</ul>
<h1 id="_idParaDest-154"><a id="_idTextAnchor931"/><a id="_idTextAnchor932"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.14.1">The data files and code for the examples in this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">at </span></span><a href="https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition"><span class="No-Break"><span class="koboSpan" id="kobo.16.1">https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.17.1">.</span></span></p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor933"/><a id="_idTextAnchor934"/><span class="koboSpan" id="kobo.18.1">Saving a model</span></h1>
<p><span class="koboSpan" id="kobo.19.1">In </span><a href="B19630_11.xhtml#_idTextAnchor728"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.20.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.21.1">, </span><em class="italic"><span class="koboSpan" id="kobo.22.1">Managing Uncertainty Intervals</span></em><span class="koboSpan" id="kobo.23.1">, you forecast the number of crimes per day in the city of Baltimore, using </span><strong class="bold"><span class="koboSpan" id="kobo.24.1">Markov chain Monte Carlo</span></strong><span class="koboSpan" id="kobo.25.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.26.1">MCMC</span></strong><span class="koboSpan" id="kobo.27.1">) sampling. </span><span class="koboSpan" id="kobo.27.2">This was a </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.28.1">long computation, and</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.29.1"> you were onl</span><a id="_idTextAnchor935"/><span class="koboSpan" id="kobo.30.1">y using daily data. </span><span class="koboSpan" id="kobo.30.2">Had y</span><a id="_idTextAnchor936"/><span class="koboSpan" id="kobo.31.1">ou used the Divvy hourly data instead, a dataset more than 10 times larger, the computation would have been even longer. </span><span class="koboSpan" id="kobo.31.2">And these two datasets are certainly smaller than many you’ll encounter in the real world. </span><span class="koboSpan" id="kobo.31.3">If Prophet provided no way to save your work, every time you trained a model, you would have to leave the model in your computer’s memory for as long as you wanted to </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">use it.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">Maybe you’re</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.34.1"> familiar with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">pickle</span></strong><span class="koboSpan" id="kobo.36.1"> module in Python—this works great to save your trained models in </span><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">sklearn</span></strong><span class="koboSpan" id="kobo.38.1">, for example. </span><span class="koboSpan" id="kobo.38.2">However, Prophet uses Stan in the backend to build its models and these Stan objects don’t pickle well. </span><span class="koboSpan" id="kobo.38.3">Fortunately, Prophet includes some functions to serialize your model in JSON and re-open it later. </span><span class="koboSpan" id="kobo.38.4">So, once your model is trained, </span><a id="_idTextAnchor937"/><span class="koboSpan" id="kobo.39.1">you can put it away for the day and bring it back later whenever you want to predict a </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">future date.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">We’ll use the Baltimore crime data again to see how to save your model. </span><span class="koboSpan" id="kobo.41.2">We’ll need to import pandas in order to read the </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">.csv</span></strong><span class="koboSpan" id="kobo.43.1"> file; Prophet, of course, to build our model; and we’ll also need to import </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">json</span></strong><span class="koboSpan" id="kobo.45.1"> to save and reopen the file. </span><span class="koboSpan" id="kobo.45.2">The functions to convert a model object into JSON and back again are imported from Prophet’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">serialize</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.47.1"> package:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.48.1">
import pandas as pd
from prophet import Prophet
import json
from prophet.serialize import model_to_json, \
model_from_json</span></pre>
<p><span class="koboSpan" id="kobo.49.1">Now, we’ll run through the now-familiar process of opening our data and training a model. </span><span class="koboSpan" id="kobo.49.2">We’re also discarding the outliers from the data, as we did in </span><a href="B19630_11.xhtml#_idTextAnchor728"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.50.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.51.1">, </span><em class="italic"><span class="koboSpan" id="kobo.52.1">Managing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.53.1">Uncertainty Intervals</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.55.1">
df = pd.read_csv('baltimore_crime.csv')
df.columns = ['ds', 'y']
df.loc[df['y'] &gt; 250, 'y'] = None
model = Prophet()
model.fit(df)</span></pre>
<p><span class="koboSpan" id="kobo.56.1">We’ve now got our trained model. </span><span class="koboSpan" id="kobo.56.2">Previously, you would have needed to keep your Python kernel running and the model in memory for as long as you wanted to access it. </span><span class="koboSpan" id="kobo.56.3">At the end of the day, you would want to save it, shut down your machine, and go home for the night, but you would lose all </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">that work.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">In the following code, you’ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">with</span></strong><span class="koboSpan" id="kobo.60.1"> statement to create a context manager so that you can open a JSON file, and Python will automatically close it when you’re done. </span><span class="koboSpan" id="kobo.60.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">'w'</span></strong><span class="koboSpan" id="kobo.62.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">'r'</span></strong><span class="koboSpan" id="kobo.64.1"> arguments used in the following statements merely stand for </span><em class="italic"><span class="koboSpan" id="kobo.65.1">write</span></em><span class="koboSpan" id="kobo.66.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.67.1">read</span></em><span class="koboSpan" id="kobo.68.1">. </span><span class="koboSpan" id="kobo.68.2">This code block u</span><a id="_idTextAnchor938"/><span class="koboSpan" id="kobo.69.1">ses Prophet’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">model_to_json</span></strong><span class="koboSpan" id="kobo.71.1"> function to convert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">model</span></strong><span class="koboSpan" id="kobo.73.1"> object into a JSON file, and then it saves it to your </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">hard drive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.75.1">
with open('baltimore_crime_model.json', 'w') as file_out:
    json.dump(model_to_json(model), file_out)</span></pre>
<p><span class="koboSpan" id="kobo.76.1">Now that</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.77.1"> the file is saved, you can safely shut down Python. </span><span class="koboSpan" id="kobo.77.2">To convert the JSON file back into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">model</span></strong><span class="koboSpan" id="kobo.79.1"> object, simply use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">json_to_model</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.81.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.82.1">
with open('baltimore_crime_model.json', 'r') as file_in:
    model = model_from_json(json.load(file_in))</span></pre>
<p><span class="koboSpan" id="kobo.83.1">With the model reloaded, you can use it just as you would any fitted model; for example, you can plot </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">a forecast:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.85.1">
forecast = model.predict()
fig = model.plot(forecast)</span></pre>
<p><span class="koboSpan" id="kobo.86.1">With no </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">future</span></strong><span class="koboSpan" id="kobo.88.1"> created, this is just the </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">fitted mode</span><a id="_idTextAnchor939"/><span class="koboSpan" id="kobo.90.1">l:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer281">
<span class="koboSpan" id="kobo.91.1"><img alt="Figure 14.1 – Baltimore crime forecast" src="image/Fig_14.1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.92.1">Figure 14.1 – Baltimore crime forecast</span></p>
<p><span class="koboSpan" id="kobo.93.1">Saving and re-opening y</span><a id="_idTextAnchor940"/><span class="koboSpan" id="kobo.94.1">our work can certainly be helpful, but the real value is when you keep a model around and every day update it with new data, as we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">do nex</span><a id="_idTextAnchor941"/><a id="_idTextAnchor942"/><span class="koboSpan" id="kobo.96.1">t.</span></span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor943"/><span class="koboSpan" id="kobo.97.1">Updating a fitted model</span></h1>
<p><span class="koboSpan" id="kobo.98.1">Forecasting is </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.99.1">un</span><a id="_idTextAnchor944"/><span class="koboSpan" id="kobo.100.1">ique among predictive models in that the value of the data is its recency and each passing moment creates a new set of valuable data to use. </span><span class="koboSpan" id="kobo.100.2">A common situation with a forecast model is the need to refit it as more data comes in. </span><span class="koboSpan" id="kobo.100.3">The city of Baltimore, for example, may use the crime model to predict how many crimes they might expect to happen tomorrow, so as to better place their officers in advance. </span><span class="koboSpan" id="kobo.100.4">Once tomorrow arrives, they can record the actual data, retrain their model, and predict for the </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">next day.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">Prophet is unable to handle online data, which means it cannot add a single new data observation and quickly update the model. </span><span class="koboSpan" id="kobo.102.2">Prophet must be trained offline—the new observation will be added to the existing data and the model will be completely retrained. </span><span class="koboSpan" id="kobo.102.3">But it doesn’t have to be completely retrained from scratch and the following technique will save a lot of time </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">when retraining.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">Prophet is essentially an optimization problem. </span><span class="koboSpan" id="kobo.104.2">Deep in the code are some settings to pick a set of initial parameters that Prophet believes will be close to the actual parameters needed to model the forecast curve. </span><span class="koboSpan" id="kobo.104.3">It then creates its curve, measures the error with existing data points, updates the parameters to reduce the error, </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">and repeats.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">Many hundreds or thousands of iterations may occur as Prophet attempts to get closer and closer to the best set</span><a id="_idTextAnchor945"/><span class="koboSpan" id="kobo.107.1"> of parameters. </span><span class="koboSpan" id="kobo.107.2">You can greatly speed up this optimization problem by taking the already-optimized parameters from yesterday’s model and using them as better initializations for today’s model. </span><span class="koboSpan" id="kobo.107.3">The assumption is that today’s data point will not dramatically change the overall model, which is generally a very good assumption. </span><span class="koboSpan" id="kobo.107.4">Let’s see how this </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">technique works.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">We’ll begin by creating a DataFrame of the Baltimore crime data with the final observation removed. </span><span class="koboSpan" id="kobo.109.2">This is </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.110.1">yesterday’s</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.111.1"> data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.112.1">
df_yesterday = df[df['ds'] &lt; df['ds'].max()]</span></pre>
<p><span class="koboSpan" id="kobo.113.1">Now, we’ll fit </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">model1</span></strong><span class="koboSpan" id="kobo.115.1"> on </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">this data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.117.1">
model1 = Prophet().fit(df_yesterday)</span></pre>
<p><span class="koboSpan" id="kobo.118.1">The city of Baltimore could use this model to make a prediction about the next day’s activity, for example. </span><span class="koboSpan" id="kobo.118.2">Now, let’s say that the next day has arrived; we record the day’s crime level and want to update our model with </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">df</span></strong><span class="koboSpan" id="kobo.120.1">, </span><em class="italic"><span class="koboSpan" id="kobo.121.1">today’s</span></em><span class="koboSpan" id="kobo.122.1"> data, which has that final data point included. </span><span class="koboSpan" id="kobo.122.2">Let’s first do it from scratch and use the IPython </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">timeit</span></strong><span class="koboSpan" id="kobo.124.1"> magic function to see how long </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">it takes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.126.1">
%timeit model2 = Prophet().fit(df)</span></pre>
<p><span class="koboSpan" id="kobo.127.1">On my current</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.128.1"> machine, as I write this, the process took about 865 milliseconds according to </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">the output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.130.1">
865 ms ± 183 ms per loop (mean ± std. </span><span class="koboSpan" id="kobo.130.2">dev. </span><span class="koboSpan" id="kobo.130.3">of 7 runs, \
                          1 loop each)</span></pre>
<p><span class="koboSpan" id="kobo.131.1">Now, let’s do it again, but instead of starting from scratch, we’ll give Prophet a </span><em class="italic"><span class="koboSpan" id="kobo.132.1">warm start</span></em><span class="koboSpan" id="kobo.133.1"> by passing it the parameters from yesterday’s model for initialization. </span><span class="koboSpan" id="kobo.133.2">We first need to define a class to format t</span><a id="_idTextAnchor946"/><span class="koboSpan" id="kobo.134.1">hose </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">parameters correctly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.136.1">
import numpy as np
class StanInit:
    def __init__(self, model):
        self.params = {
            'k': np.mean(model.params['k']),
            'm': np.mean(model.params['m']),
            'sigma_obs': \
             np.mean(model.params['sigma_obs']),
            'delta': np.mean(model.params['delta'],
                             axis=0),
            'beta': np.mean(model.params['beta'], axis=0)
        }
    def __call__(self):
        return self.params</span></pre>
<p><span class="koboSpan" id="kobo.137.1">This class simply opens up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">model.params</span></strong><span class="koboSpan" id="kobo.139.1"> dictionary and saves the relevant values in a new dictionary formatted as the Stan backend requires. </span><span class="koboSpan" id="kobo.139.2">We now use this class to extract</span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.140.1"> the parameters from </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">model1</span></strong><span class="koboSpan" id="kobo.142.1"> and pass this initialization to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">fit</span></strong><span class="koboSpan" id="kobo.144.1"> method, again timing </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">the process:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.146.1">
%timeit model2 = Prophet().fit(
     df,
     inits=StanInit(model1)())</span></pre>
<p><span class="koboSpan" id="kobo.147.1">When I run that command, I see more than a 4x improvement in </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">training speed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.149.1">
195 ms ± 90 ms per loop (mean ± std. </span><span class="koboSpan" id="kobo.149.2">dev. </span><span class="koboSpan" id="kobo.149.3">of 7 runs, \
                         1 loop each)</span></pre>
<p><span class="koboSpan" id="kobo.150.1">0.195 seconds compared to 0.865 seconds is a dramatic improvement. </span><span class="koboSpan" id="kobo.150.2">The amount of time saved depends on many factors and will often vary even when you repeat the </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">experiment again.</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">There is one caveat with this method though: if the locations of changepoints change, the updated model may actually take </span><em class="italic"><span class="koboSpan" id="kobo.153.1">longer</span></em><span class="koboSpan" id="kobo.154.1"> to fit than just fitting from scratch. </span><span class="koboSpan" id="kobo.154.2">For these reasons, this method works best when adding a very small amount of new data relative to the existing data, as we did here by adding one day to several years </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">of data.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">With MAP estimatio</span><a id="_idTextAnchor947"/><span class="koboSpan" id="kobo.157.1">n, as we just did in the previous example, each iteration is an optimization problem. </span><span class="koboSpan" id="kobo.157.2">This means that better initialization will speed things up considerably. </span><span class="koboSpan" id="kobo.157.3">With MCMC sampling, however, each iteration must fully run through each link in the Markov chain (refer back to </span><a href="B19630_11.xhtml#_idTextAnchor728"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.158.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.159.1">, </span><em class="italic"><span class="koboSpan" id="kobo.160.1">Managing Uncertainty Intervals</span></em><span class="koboSpan" id="kobo.161.1">, for a review of the difference between MAP estimation and </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">MCMC sampling).</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">What this means is that warm-starting will speed up MAP estimation considerably but will not speed up MCMC sampling. </span><span class="koboSpan" id="kobo.163.2">Warm-starting will, however, increase the quality of each Markov chain iteration. </span><span class="koboSpan" id="kobo.163.3">So, if you do a warm start with MCMC sampling, you can probably get away with fewer </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">mcmc_samples</span></strong><span class="koboSpan" id="kobo.165.1"> without a significant reduction in </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">result quality.</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">This reduction in </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">mcmc_samples</span></strong><span class="koboSpan" id="kobo.169.1"> creates an opportunity to speed up MCMC sampling on any new model. </span><span class="koboSpan" id="kobo.169.2">The idea is to train an initial model with MAP estimation, and then use that model to warm start a model with MCMC sampling, but using fewer </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">mcmc_samples</span></strong><span class="koboSpan" id="kobo.171.1"> than you would </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">otherwise choose:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.173.1">
model1 = Prophet().fit(df)
model2 =
Prophet(mcmc_samples=200).fit(
    df,
    inits=StanInit(model1)())</span></pre>
<p><span class="koboSpan" id="kobo.174.1">In the </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.175.1">preceding code block, we created an initial </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">model1</span></strong><span class="koboSpan" id="kobo.177.1"> using MAP estimation and all data. </span><span class="koboSpan" id="kobo.177.2">We then used the parameters from </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">model1</span></strong><span class="koboSpan" id="kobo.179.1"> to warm start </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">model2</span></strong><span class="koboSpan" id="kobo.181.1">, which uses MCMC sampling, but only </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">mcmc_samples=200</span></strong><span class="koboSpan" id="kobo.183.1">, instead of the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">300</span></strong><span class="koboSpan" id="kobo.185.1"> we chose in </span><a href="B19630_11.xhtml#_idTextAnchor728"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.186.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.187.1">, </span><em class="italic"><span class="koboSpan" id="kobo.188.1">Managing Uncertainty Intervals</span></em><span class="koboSpan" id="kobo.189.1">. </span><span class="koboSpan" id="kobo.189.2">This will result in an MCMC-sampled model with roughly the same performance as earlier but trained in two-thirds of </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">the time.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">In summary, warm starting with MAP estimation (that is, when </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">mcmc_samples=0</span></strong><span class="koboSpan" id="kobo.193.1">) will speed up your model training. </span><span class="koboSpan" id="kobo.193.2">Warm starting will not speed up a model when </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">mcmc_samples</span></strong><span class="koboSpan" id="kobo.195.1"> is greater than 0 though, but in this case, you can quickly train a model with MAP estimation and then warm start your model with </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">mcmc_samples</span></strong><span class="koboSpan" id="kobo.197.1"> set to a reduced value, </span><a id="_idTextAnchor948"/><span class="koboSpan" id="kobo.198.1">without losing much quality. </span><span class="koboSpan" id="kobo.198.2">Now, let’s learn how to use Prophet to make </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">interactive </span><a id="_idTextAnchor949"/><a id="_idTextAnchor950"/><span class="koboSpan" id="kobo.200.1">plots.</span></span></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor951"/><span class="koboSpan" id="kobo.201.1">Making interactive plots with Plotly</span></h1>
<p><span class="koboSpan" id="kobo.202.1">In this</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.203.1"> final section</span><a id="_idTextAnchor952"/><span class="koboSpan" id="kobo.204.1">, we’ll use the Plotly library to build some</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.205.1"> interactive plots. </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">Plotly</span></strong><span class="koboSpan" id="kobo.207.1"> is a c</span><a id="_idTextAnchor953"/><span class="koboSpan" id="kobo.208.1">ompletely </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.209.1">separate visualization package from </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.210.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.211.1">Matplotlib</span></strong><span class="koboSpan" id="kobo.212.1"> package, which we’ve been using throughout this book. </span><span class="koboSpan" id="kobo.212.2">A plot made wit</span><a id="_idTextAnchor954"/><span class="koboSpan" id="kobo.213.1">h Plotly is richly interactiv</span><a id="_idTextAnchor955"/><span class="koboSpan" id="kobo.214.1">e, allowing tooltips on mouse hover, zooming in and out of a plot, and all sorts of </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">other interactivities.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">If you’re familiar with Tableau or Power BI, Plotly brings similar interactivity to Python. </span><span class="koboSpan" id="kobo.216.2">Additionally, the </span><a id="_idTextAnchor956"/><span class="koboSpan" id="kobo.217.1">Plotly team also built </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">Dash</span></strong><span class="koboSpan" id="kobo.219.1">, a library</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.220.1"> for creating web-based dashboards. </span><span class="koboSpan" id="kobo.220.2">A full tutorial for creating such a dashboard is beyond the scope of this book, but I encourage you to learn about this valuable tool if you would like to share your Prophet forecasts with a </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">wide audience.</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">Prophet does not automatically install Plotly as a dependency, so before we begin, you will need to install it on your machine. </span><span class="koboSpan" id="kobo.222.2">It is a simple process and can be accomplished through either </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">conda</span></strong><span class="koboSpan" id="kobo.224.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">pip</span></strong><span class="koboSpan" id="kobo.226.1">. </span><span class="koboSpan" id="kobo.226.2">Here is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">conda</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.228.1">installation command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.229.1">
conda install -c plotly plotly=5.11.0</span></pre>
<p><span class="koboSpan" id="kobo.230.1">If you have not installed Anaconda or Miniconda though, you will have to </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">pip</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.234.1">
pip install plotly==5.11.0</span></pre>
<p><span class="koboSpan" id="kobo.235.1">If you</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.236.1"> tend</span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.237.1"> to work in Jupyter Notebook or JupyterLab, you will also want to install some support packages. </span><span class="koboSpan" id="kobo.237.2">This can be done through </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">conda</span></strong><span class="koboSpan" id="kobo.239.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
# Jupyter Notebook support
conda install "notebook&gt;=5.3" "ipywidgets&gt;=7.5"
# JupyterLab support
conda install "jupyterlab&gt;=3" "ipywidgets&gt;=7.6"
# JupyterLab renderer support
jupyter labextension install jupyterlab-plotly@5.11.0
# OPTIONAL: Jupyter widgets extension
jupyter labextension install @jupyter-widgets/jupyterlab-\
manager plotlywidget@5.11.0</span></pre>
<p><span class="koboSpan" id="kobo.242.1">If you do not have </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">conda</span></strong><span class="koboSpan" id="kobo.244.1">, you may also use </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">pip</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.246.1"> instead:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.247.1">
# Jupyter Notebook support
pip install "notebook&gt;=5.3" "ipywidgets&gt;=7.5"
# JupyterLab support
pip install "jupyterlab&gt;=3" "ipywidgets&gt;=7.6"
# JupyterLab renderer support
jupyter labextension install jupyterlab-plotly@5.11.0
# OPTIONAL: Jupyter widgets extension
jupyter labextension install @jupyter-widgets/jupyterlab-\
manager plotlywidget@5.11.0</span></pre>
<p><span class="koboSpan" id="kobo.248.1">If you have trouble with any of these commands, the best resource is Plotly’s own </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">documentation: </span></span><a href="https://plotly.com/python/getting-started/"><span class="No-Break"><span class="koboSpan" id="kobo.250.1">https://plotly.com/python/getting-started/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.251.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">Yo</span><a id="_idTextAnchor957"/><span class="koboSpan" id="kobo.253.1">u have</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.254.1"> already learned about many of the plotting </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.255.1">functions in Prophet’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">plot</span></strong><span class="koboSpan" id="kobo.257.1"> package throughout the examples in this book. </span><span class="koboSpan" id="kobo.257.2">There are fou</span><a id="_idTextAnchor958"/><span class="koboSpan" id="kobo.258.1">r functions that we haven’t touched on yet; these take many of the same keywords as the Matplotlib counterparts you have learned already but output a Plotly </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">chart instead.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.260.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.261.1">This book will contain static images of Plotly plots, but if you run the example code in a Jupyter notebook, you’ll be able to manipulate the image in a richly </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">interactive environment.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">To demonstrate these tools, let’s use the Divvy data again, and use temperature as an extra regressor. </span><span class="koboSpan" id="kobo.263.2">We won’t be using Matplotlib at all in this section, so no need to import it. </span><span class="koboSpan" id="kobo.263.3">We’ve already got pandas and Prophet imported from the previous sections, but we’ll need to make a few more </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">imports here.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">If you recall from </span><a href="B19630_09.xhtml#_idTextAnchor599"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.266.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.267.1">, </span><em class="italic"><span class="koboSpan" id="kobo.268.1">Including Additional Regressors</span></em><span class="koboSpan" id="kobo.269.1">, we artificially reduced our training data by 2 weeks so that we could forecast 2 weeks ahead while using weather conditions as additional regressors. </span><span class="koboSpan" id="kobo.269.2">We’ll do that again here, so we need to import </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">timedelta</span></strong><span class="koboSpan" id="kobo.271.1"> t</span><a id="_idTextAnchor959"/><span class="koboSpan" id="kobo.272.1">o help out. </span><span class="koboSpan" id="kobo.272.2">Most importantly though, we’ll import </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">plotly.offline</span></strong><span class="koboSpan" id="kobo.274.1"> and initialize </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">notebook mode:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.276.1">
from datetime import timedelta
import plotly.offline as py
py.init_notebook_mode()</span></pre>
<p><span class="koboSpan" id="kobo.277.1">Now, l</span><a id="_idTextAnchor960"/><span class="koboSpan" id="kobo.278.1">et’s read in our data and put it into a DataFrame. </span><span class="koboSpan" id="kobo.278.2">We’ll only use one additional regressor in this </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">example, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">temperature</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.282.1">
df = pd.read_csv('divvy_daily.csv')
df = df[['date', 'rides', 'temperature']]
df['date'] = pd.to_datetime(df['date'])
df.columns = ['ds', 'y', 'temp']</span></pre>
<p><span class="koboSpan" id="kobo.283.1">Finally, we </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.284.1">just build our model as before. </span><span class="koboSpan" id="kobo.284.2">We create a regressor</span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.285.1"> for temperature, then fit the model on the data while excluding the final 2 weeks. </span><span class="koboSpan" id="kobo.285.2">We next make a future forecast of 2 weeks, using those unfitted 2 weeks of </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">temperature</span></strong><span class="koboSpan" id="kobo.287.1"> data in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">future</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.289.1"> DataFrame:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.290.1">
model = Prophet(seasonality_mode='multiplicative',
                yearly_seasonality=6)
model.add_regressor('temp')
model.fit(df[df['ds'] &lt; df['ds'].max() - \
          timedelta(weeks=2)])
future = model.make_future_dataframe(periods=14)
future['temp'] = df['temp']
forecast = model.predict(future)</span></pre>
<p><span class="koboSpan" id="kobo.291.1">So far, thi</span><a id="_idTextAnchor961"/><span class="koboSpan" id="kobo.292.1">s should all be a review (except for importing and initiali</span><a id="_idTextAnchor962"/><span class="koboSpan" id="kobo.293.1">zing Plotly). </span><span class="koboSpan" id="kobo.293.2">But now, we’ll import those final four functions from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">plot</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.295.1"> package:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.296.1">
from prophet.plot import (
    plot_plotly,
    plot_components_plotly,
    plot_forecast_component_plotly,
    plot_sea</span><a id="_idTextAnchor963"/><a id="_idTextAnchor964"/><span class="koboSpan" id="kobo.297.1">sonality_plotly
)</span></pre>
<p><span class="koboSpan" id="kobo.298.1">Let’s run through these one </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">by one.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor965"/><span class="koboSpan" id="kobo.300.1">Plotly forecast plot</span></h2>
<p><span class="koboSpan" id="kobo.301.1">First </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.302.1">up is </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">plot_plotly</span></strong><span class="koboSpan" id="kobo.304.1">. </span><span class="koboSpan" id="kobo.304.2">To use this function, you simply pass</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.305.1"> in the model and the forecast. </span><span class="koboSpan" id="kobo.305.2">I’m also including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">trend=True</span></strong><span class="koboSpan" id="kobo.307.1"> argument to include the trend line in the plot. </span><span class="koboSpan" id="kobo.307.2">You could also add </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">changepoints=True</span></strong><span class="koboSpan" id="kobo.309.1">, and it would completely mimic the </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">add_changepoints_to_plot</span></strong><span class="koboSpan" id="kobo.311.1"> Matplotlib function. </span><span class="koboSpan" id="kobo.311.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">py.iplot(fig)</span></strong><span class="koboSpan" id="kobo.313.1"> line is analogous to </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">Matplotlib’s </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">plt.show()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.317.1">
fig = plot_plotly(model, forecast, trend=True)
py.iplot(fig)</span></pre>
<p><span class="koboSpan" id="kobo.318.1">This screenshot also displays the tooltip shown on hovering over the point</span><a id="_idTextAnchor966"/><span class="koboSpan" id="kobo.319.1"> for </span><strong class="bold"><span class="koboSpan" id="kobo.320.1">May </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.321.1">10, 2015</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer282">
<span class="koboSpan" id="kobo.323.1"><img alt="Figure ﻿﻿14.2 – Plotly plot" src="image/Fig_14.2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.324.1">Figure </span><a id="_idTextAnchor967"/><a id="_idTextAnchor968"/><span class="koboSpan" id="kobo.325.1">14.2 – Plotly plot</span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor969"/><span class="koboSpan" id="kobo.326.1">Plotly components plot</span></h2>
<p><span class="koboSpan" id="kobo.327.1">Next up, we’ll </span><a id="_idTextAnchor970"/><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.328.1">look at the Plotly components</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.329.1"> plot. </span><span class="koboSpan" id="kobo.329.2">This is much the same as the Matplotlib version, but it also includes interactivity. </span><span class="koboSpan" id="kobo.329.3">I’m also including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">figsize</span></strong><span class="koboSpan" id="kobo.331.1"> argument to reduce the size of this one </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">a bit:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.333.1">
fig = plot_components_plotly(model, forecast ,
                             figsize=(800, 175))
py.iplot(fig)</span></pre>
<p><span class="koboSpan" id="kobo.334.1">This </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.335.1">plot</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.336.1"> shows the same subplot</span><a id="_idTextAnchor971"/><span class="koboSpan" id="kobo.337.1">s </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">plot_components</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer283">
<span class="koboSpan" id="kobo.341.1"><img alt="Figure 14.3 – P﻿﻿lotly components plot" src="image/Fig_14.3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.342.1">Figure 14.3 – P</span><a id="_idTextAnchor972"/><a id="_idTextAnchor973"/><span class="koboSpan" id="kobo.343.1">lotly components plot</span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor974"/><span class="koboSpan" id="kobo.344.1">Plotly single component plot</span></h2>
<p><span class="koboSpan" id="kobo.345.1">I </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.346.1">wanted</span><a id="_idIndexMarker561"/><a id="_idTextAnchor975"/><span class="koboSpan" id="kobo.347.1"> to use this Divvy data so that we could use the extra temperature regressor. </span><span class="koboSpan" id="kobo.347.2">We could have plotted any of the subplots in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.348.1">Figure 14</span></em></span><em class="italic"><span class="koboSpan" id="kobo.349.1">.3</span></em><span class="koboSpan" id="kobo.350.1"> using this next function, but all of them can be handled with other functions, except for extra regressors. </span><span class="koboSpan" id="kobo.350.2">Plotting those alone requires the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">plot_forecast_components_plotly</span></strong><span class="koboSpan" id="kobo.352.1"> function. </span><span class="koboSpan" id="kobo.352.2">Here, we pass in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">'</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">temp'</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.355.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.356.1">
fig = plot_forecast_component_plotly(model, forecast,
                                     'temp')
py.iplot(fig)</span></pre>
<p><span class="koboSpan" id="kobo.357.1">As </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.358.1">with</span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.359.1"> the other plots in this section, a static image does not do them justice. </span><span class="koboSpan" id="kobo.359.2">Plotly was</span><a id="_idTextAnchor976"/><span class="koboSpan" id="kobo.360.1"> intended to be used in an interactive environment; these plots beg to be placed on a dashboard, not printed in a book. </span><span class="koboSpan" id="kobo.360.2">Here, I’m showin</span><a id="_idTextAnchor977"/><span class="koboSpan" id="kobo.361.1">g a hover </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">tooltip again:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer284">
<span class="koboSpan" id="kobo.363.1"><img alt="Figure 14.4 –﻿﻿ Plotly temperature plot" src="image/Fig_14.4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.364.1">Figure 14.4 –</span><a id="_idTextAnchor978"/><a id="_idTextAnchor979"/><span class="koboSpan" id="kobo.365.1"> Plotly temperature plot</span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor980"/><span class="koboSpan" id="kobo.366.1">Plotly seasonality plot</span></h2>
<p><span class="koboSpan" id="kobo.367.1">In the </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.368.1">final Plotly</span><a id="_idTextAnchor981"/><span class="koboSpan" id="kobo.369.1"> function, we’ll plot the yearly </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.370.1">seasonality using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">plot_seasonality_plotly</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.372.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.373.1">
fig = plot_seasonality_plotly(model, 'yearly')
py.iplot(fig)</span></pre>
<p><span class="koboSpan" id="kobo.374.1">The Plotly toolbar has been left out of the components plot to save space but is included in all the others; you can see it at the upper right of </span><em class="italic"><span class="koboSpan" id="kobo.375.1">Figures 14.2</span></em><span class="koboSpan" id="kobo.376.1">, </span><em class="italic"><span class="koboSpan" id="kobo.377.1">14.4</span></em><span class="koboSpan" id="kobo.378.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.379.1">14.5</span></em><span class="koboSpan" id="kobo.380.1">. </span><span class="koboSpan" id="kobo.380.2">In the following seasonality plot, I’ve used the </span><strong class="bold"><span class="koboSpan" id="kobo.381.1">Toggle Spike Lines</span></strong><span class="koboSpan" id="kobo.382.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.383.1">Compare Data</span></strong><span class="koboSpan" id="kobo.384.1"> buttons from this toolbar to add further information to the </span><a id="_idTextAnchor982"/><span class="koboSpan" id="kobo.385.1">hover tooltip, </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">seen here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer285">
<span class="koboSpan" id="kobo.387.1"><img alt="Figure 14.5 – Plotly seasonality ﻿plot" src="image/Fig_14.5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.388.1">Figure 14.5 – Plotly seasonality </span><a id="_idTextAnchor983"/><span class="koboSpan" id="kobo.389.1">plot</span></p>
<p><span class="koboSpan" id="kobo.390.1">I strongly</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.391.1"> encourage you to explore these plots in a</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.392.1"> Jupyter notebook, and if you find them useful, consider putting them together in a dashboard using Dash. </span><span class="koboSpan" id="kobo.392.2">There are plenty of </span><a id="_idTextAnchor984"/><a id="_idTextAnchor985"/><span class="koboSpan" id="kobo.393.1">tutorials </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">available online.</span></span></p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor986"/><span class="koboSpan" id="kobo.395.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.396.1">This last chapter in the book was the most optional of all of them, but for those of you who often work in a production environment, these tools will </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">be invaluable.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">In this chapter, you learned how to save a model to your hard drive using JSON serialization, so you can share it or open it up later without requiring the model to be retrained. </span><span class="koboSpan" id="kobo.398.2">You also learned how to update a model that has already been fitted, another procedure designed to save you time. </span><span class="koboSpan" id="kobo.398.3">Finally, you examined a new plot format, an impressive tool to make your plots interactive in a browser, and hopefully, you saw the potential of packaging this information into </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">a dashboard.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">Together, what you learned in this chapter will help you to update your model as time progresses and new data comes in, and share that model via live, web-based </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">interactive dashboards.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer287">
</div>
</div>
</body></html>