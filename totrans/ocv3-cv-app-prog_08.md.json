["```py\n    // Detect Harris Corners \n    cv::Mat cornerStrength; \n    cv::cornerHarris(image,          // input image \n                     cornerStrength, // image of cornerness \n                     3,              // neighborhood size \n                     3,              // aperture size \n                     0.01);          // Harris parameter \n\n    // threshold the corner strengths \n    cv::Mat harrisCorners; \n    double threshold= 0.0001; \n    cv::threshold(cornerStrength,harrisCorners, \n                  threshold,255,cv::THRESH_BINARY); \n\n```", "```py\n    class HarrisDetector { \n\n      private: \n\n      // 32-bit float image of corner strength \n      cv::Mat cornerStrength; \n      // 32-bit float image of thresholded corners \n      cv::Mat cornerTh; \n      // image of local maxima (internal) \n      cv::Mat localMax; \n      // size of neighborhood for derivatives smoothing \n      int neighborhood; \n      // aperture for gradient computation \n      int aperture; \n      // Harris parameter \n      double k; \n      // maximum strength for threshold computation \n      double maxStrength; \n      // calculated threshold (internal) \n      double threshold; \n      // size of neighborhood for non-max suppression \n      int nonMaxSize; \n      // kernel for non-max suppression \n      cv::Mat kernel; \n\n      public: \n\n      HarrisDetector(): neighborhood(3), aperture(3),  \n                        k(0.01), maxStrength(0.0),  \n                        threshold(0.01), nonMaxSize(3) { \n\n         // create kernel used in non-maxima suppression \n         setLocalMaxWindowSize(nonMaxSize); \n      } \n\n```", "```py\n    // Compute Harris corners \n    void detect(const cv::Mat& image) { \n\n      // Harris computation \n      cv::cornerHarris(image,cornerStrength,                   \n                       neighbourhood,// neighborhood size \n                       aperture,     // aperture size \n                       k);           // Harris parameter \n\n      // internal threshold computation \n      cv::minMaxLoc(cornerStrength,0,&maxStrength); \n\n      // local maxima detection \n      cv::Mat dilated;  //temporary image \n      cv::dilate(cornerStrength,dilated,cv::Mat()); \n      cv::compare(cornerStrength,dilated, localMax, cv::CMP_EQ); \n    } \n\n```", "```py\n    // Get the corner map from the computed Harris values \n    cv::Mat getCornerMap(double qualityLevel) { \n\n      cv::Mat cornerMap; \n\n      // thresholding the corner strength \n      threshold= qualityLevel*maxStrength; \n      cv::threshold(cornerStrength,cornerTh, threshold, 255,\n                    cv::THRESH_BINARY); \n\n      // convert to 8-bit image \n      cornerTh.convertTo(cornerMap,CV_8U); \n\n      // non-maxima suppression \n      cv::bitwise_and(cornerMap,localMax,cornerMap); \n\n      return cornerMap; \n    } \n\n```", "```py\n    // Get the feature points from the computed Harris values \n    void getCorners(std::vector<cv::Point> &points, double qualityLevel) { \n\n      // Get the corner map \n      cv::Mat cornerMap= getCornerMap(qualityLevel); \n      // Get the corners \n      getCorners(points, cornerMap); \n    } \n\n    // Get the feature points from the computed corner map \n    void getCorners(std::vector<cv::Point> &points,\n                    const cv::Mat& cornerMap) { \n\n      // Iterate over the pixels to obtain all features \n      for( int y = 0; y < cornerMap.rows; y++ ) { \n\n        const uchar* rowPtr = cornerMap.ptr<uchar>(y); \n\n        for( int x = 0; x < cornerMap.cols; x++ ) { \n\n          // if it is a feature point \n          if (rowPtr[x]) { \n\n            points.push_back(cv::Point(x,y)); \n          } \n        } \n      } \n    } \n\n```", "```py\n    // Draw circles at feature point locations on an image \n    void drawOnImage(cv::Mat &image,  \n                     const std::vector<cv::Point> &points,  \n                     cv::Scalar color= cv::Scalar(255,255,255),  \n                     int radius=3, int thickness=1) { \n      std::vector<cv::Point>::const_iterator it= points.begin(); \n\n      // for all corners \n      while (it!=points.end()) { \n\n        // draw a circle at each corner location \n        cv::circle(image,*it,radius,color,thickness); \n        ++it; \n      } \n    } \n\n```", "```py\n    // Create Harris detector instance \n    HarrisDetector harris; \n    // Compute Harris values \n    harris.detect(image); \n    // Detect Harris corners \n    std::vector<cv::Point> pts; \n    harris.getCorners(pts,0.02); \n    // Draw Harris corners \n    harris.drawOnImage(image,pts); \n\n```", "```py\n    cv::dilate(cornerStrength, dilated,cv::Mat()); \n\n```", "```py\n    cv::compare(cornerStrength, dilated, localMax,cv::CMP_EQ); \n\n```", "```py\n    // Compute good features to track \n    std::vector<cv::KeyPoint> keypoints; \n    // GFTT detector \n    cv::Ptr<cv::GFTTDetector> ptrGFTT =  \n        cv::GFTTDetector::create( \n                        500,   // maximum number of keypoints\n                        0.01,  // quality level \n                        10);   //minimum allowed distance between points \n    // detect the GFTT \n    ptrGFTT->detect(image,keypoints); \n\n```", "```py\n    void detect( cv::InputArray image,  \n                 std::vector<KeyPoint>& keypoints,  \n                 cv::InputArray mask ); \n\n    void detect( cv::InputArrayOfArrays images,                 \n                 std::vector<std::vector<KeyPoint> >& keypoints,          \n                 cv::InputArrayOfArrays masks ); \n\n```", "```py\n    // vector of keypoints \n    std::vector<cv::KeyPoint> keypoints; \n    // FAST detector with a threshold of 40 \n    cv::Ptr<cv::FastFeatureDetector> ptrFAST =\n            cv::FastFeatureDetector::create(40); \n    // detect the keypoints \n    ptrFAST->detect(image,keypoints); \n\n```", "```py\n    cv::drawKeypoints(image,                      // original image \n          keypoints,                              // vector of keypoints \n          image,                                  // the output image \n          cv::Scalar(255,255,255),                // keypoint color \n          cv::DrawMatchesFlags::DRAW_OVER_OUTIMG);// drawing flag \n\n```", "```py\n    if (numberOfPoints < keypoints.size()) \n      std::nth_element(keypoints.begin(),\n                       keypoints.begin() + numberOfPoints,\n                       keypoints.end(),\n                       [](cv::KeyPoint& a, cv::KeyPoint& b) { \n                       return a.response > b.response; }); \n\n```", "```py\n    // The final vector of keypoints \n    keypoints.clear(); \n    // detect on each grid \n    for (int i = 0; i < vstep; i++) \n      for (int j = 0; j < hstep; j++) { \n        // create ROI over current grid \n        imageROI = image(cv::Rect(j*hsize, i*vsize, hsize, vsize)); \n        // detect the keypoints in grid \n        gridpoints.clear(); \n        ptrFAST->detect(imageROI, gridpoints); \n\n        // get the strongest FAST features \n        auto itEnd(gridpoints.end()); \n        if (gridpoints.size() > subtotal) {  \n          // select the strongest features \n          std::nth_element(gridpoints.begin(),\n                           gridpoints.begin() + subtotal, \n                           gridpoints.end(),\n                           [](cv::KeyPoint& a,\n                           cv::KeyPoint& b) { \n            return a.response > b.response; }); \n          itEnd = gridpoints.begin() + subtotal; \n        } \n\n        // add them to the global keypoint vector \n        for (auto it = gridpoints.begin(); it != itEnd; ++it) { \n          // convert to image coordinates \n          it->pt += cv::Point2f(j*hsize, i*vsize);  \n          keypoints.push_back(*it); \n      } \n    } \n\n```", "```py\n    // Construct the SURF feature detector object \n    cv::Ptr<cv::xfeatures2d::SurfFeatureDetector> ptrSURF =   \n                cv::xfeatures2d::SurfFeatureDetector::create(2000.0); \n    // detect the keypoints \n    ptrSURF->detect(image, keypoints); \n\n```", "```py\n    // Draw the keypoints with scale and orientation information \n    cv::drawKeypoints(image,                     // original image \n               keypoints,                        // vector of keypoints \n               featureImage,                     // the resulting image \n               cv::Scalar(255,255,255),          // color of the points \n               cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS); \n\n```", "```py\n    // Construct the SIFT feature detector object \n    cv::Ptr<cv::xfeatures2d::SiftFeatureDetector> ptrSIFT =    \n                         cv::xfeatures2d::SiftFeatureDetector::create(); \n    // detect the keypoints \n    ptrSIFT->detect(image, keypoints); \n\n```", "```py\n    // Construct the BRISK feature detector object \n    cv::Ptr<cv::BRISK> ptrBRISK = cv::BRISK::create(); \n    // detect the keypoints \n    ptrBRISK->detect(image, keypoints); \n\n```", "```py\n    // Construct the ORB feature detector object \n    cv::Ptr<cv::ORB> ptrORB =  \n      cv::ORB::create(75,  // total number of keypoints \n                      1.2, // scale factor between layers \n                      8);  // number of layers in pyramid \n    // detect the keypoints \n    ptrORB->detect(image, keypoints); \n\n```"]