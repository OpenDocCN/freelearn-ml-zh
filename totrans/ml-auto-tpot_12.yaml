- en: '*Chapter 9*: Using the Deployed TPOT Model in Production'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've made it to the final chapter – congratulations! So far, you've learned
    the basics of TPOT by solving classification and regression tasks, how TPOT works
    with Dask and neural networks, and how to deploy machine learning models both
    locally and to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will serve as icing on the cake, as you'll learn how to communicate
    with your deployed models to build something even a 5-year-old could use. To be
    more precise, you'll learn how to communicate with your API through a notebook
    environment and a simple GUI web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Making predictions in a notebook environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a simple GUI web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making predictions in a GUI environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the last chapter in the book, so some prior knowledge is assumed. You
    need to know how to build basic machine learning models with TPOT to deploy them.
    It's assumed that your model is deployed to the AWS virtual machine created in
    [*Chapter 8*](B16954_08_Final_SK_ePub.xhtml#_idTextAnchor093)*, TPOT Model Deployment*.
    If that's not the case, please revisit that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be quite code-heavy, so you can refer to the official GitHub
    repository if you get stuck: [https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter09](https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: Making predictions in a notebook environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you took a day''s (or a few days'') break after the previous chapter, it''s
    likely that your connection to the remote virtual machine ended. Because of that,
    you''ll need to reconnect and start the API once again. There are ways to make
    your API always running, but that''s out of the scope of this book. Furthermore,
    if you''ve moved the `TPOT_Book_KeyPair.pem` file to some other folder, you''ll
    have to reset the permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, execute the first command line from the following snippet,
    only if you have to reset the permissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your API is running now. The next step is to open a JupyterLab or Jupyter Notebook
    environment and make a request. You''ll need the `requests` library to do so,
    so here''s how to import it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s declare a couple of variables next. These will hold the values for the
    host name, port, and endpoint:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From there, we can easily concatenate these three variables into a single one
    to form a URL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s how it should look:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.1 – URL connection string'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_09_1.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.1 – URL connection string
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Yours will be a bit different due to the difference in the hostname.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we''ll declare a dictionary that will serve as input data. It will be
    identical to the data sent in the previous chapter through Postman. Here''s the
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's all we need to make a request. Let's do that next.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can use the `post()` function from the `requests` package to make a POST
    request. Two parameters are required – the URL and the data in JSON format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results are displayed in the following figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s how the response looks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.3 – API response as a string'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_09_3.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.3 – API response as a string
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, the prediction is returned successfully but not in the desired
    format by default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To change that, you''ll need to transform the response string to a JSON object.
    You can use the `loads()` function from the `json` package to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here are the results:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.4 – API response as a JSON object'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_09_4.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.4 – API response as a JSON object
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can access the predicted class (or any other property) just as you would
    for a normal dictionary object. Here''s an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And here''s what''s returned:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.5 – API predicted class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_09_5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – API predicted class
  prefs: []
  type: TYPE_NORMAL
- en: And that's essentially how you can obtain predictions from a deployed REST API
    with Python! In the next section, you'll build a basic interactive web application
    around this API to make it utterly simple for anyone to use.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a simple GUI web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section aims to demonstrate how the `Flask` framework can be used to develop
    a simple web application. The focus is shifted toward building an application
    that captures form data, which is then passed to our deployed machine learning
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: To start, create the following directory structure:![Figure 9.6 – Web application
    directory structure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16954_09_6.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.6 – Web application directory structure
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Most of the logic is handled in `app.py`, and the `templates` folder is used
    to store HTML files for the app – more on that in a bit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This time we''ll organize the code a bit better, so you''ll need to create
    an additional file for storing the environment variables. Inside the root directory
    (`webapp`), create a file called `.env` – and populate it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating a separate file like this is considered to be a best practice when
    developing any sort of web application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To use these environment variables, you''ll have to install an additional package
    to your virtual environment:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s build the basic structure of the application now. Open the `app.py`
    file and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you were to run the application now, you wouldn''t get an error, but nothing
    would be displayed on the screen. The reason is simple – we haven''t handled the
    `index.html` file yet. Before we do so, let''s discuss the only potentially unfamiliar
    part of code: the `render_template()` function. Put simply, this function will
    display an HTML file instead of showing merely a string or value returned from
    the function. There''s a way to pass parameters, but more on that later.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Onto the `index.html` now – here''s the code you can paste inside the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Don't worry if you haven't written a line of HTML before – it's a simple markup
    language. Think of everything you see here as boilerplate. It's what's inside
    the `<body></body>` tag that we're interested in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you were to run your application now, here''s how it would look:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Iris prediction application (v1)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_09_7.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.7 – Iris prediction application (v1)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It's a simple and utterly boring web application, but at least it works.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As mentioned before, our web application has to handle form data somehow, so
    let''s start working on that. There''s a dedicated package for handling form data
    with `Flask` called `Flask-WTF`. Here''s how you can install it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: from flask_wtf import FlaskForm
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from wtforms import FloatField, SubmitField
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from wtforms.validators import DataRequired
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'class IrisForm(FlaskForm):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sepal_length = FloatField(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: label='Sepal Length', validators=[DataRequired()]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sepal_width = FloatField(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: label='Sepal Width', validators=[DataRequired()]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: petal_length = FloatField(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: label='Petal Length', validators=[DataRequired()]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: petal_width = FloatField(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: label='Petal Width', validators=[DataRequired()]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: submit = SubmitField(label='Predict')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Onto the `app.py` now. A couple of changes are required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Flask-WTF` forms need a secret key configured to work. You can add it by accessing
    the `.env` file. What you declare as a value is entirely arbitrary.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Our index route now needs to allow for both POST and GET methods since it will
    handle forms. Inside the `index()` function, you'll have to instantiate the previously
    written `IrisForm` class and return relevant results if there are no validation
    errors once the submit button is clicked.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `validate_on_submit()` function to check. If the check is passed,
    the input data is returned in a heading format (we'll see how to show predictions
    later). If not, the `index.html` template is returned.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A call to `render_template()` now passes a parameter to our HTML file – `iris_form`.
    This gives access to form data to our HTML file. You'll see how to deal with it
    in a minute.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s how your file should look once the changes are made:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We're almost there. Let's tweak the `index.html` file next.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`index.html` is the last file you''ll need to tweak to have a working application.
    The only thing we need inside it is a form that displays the fields declared earlier.
    It''s also mandatory to protect your app from **Cross-Site Request Forgery** (**CSRF**)
    attacks. To do so, you''ll have to place a token before the form fields.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s how the HTML file should look:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, to access parameters sent from the Python file, you have to
    surround the code with double curly brackets.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you were to launch the application now, here''s what you''d see on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Iris prediction application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_09_8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – Iris prediction application
  prefs: []
  type: TYPE_NORMAL
- en: And that's a frontend for your machine learning application! It's a bit ugly,
    but we'll style it later. Let's test the functionality first.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t want the form submitted if any of the input values are empty. Here''s
    what happens if the button is pressed immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Iris prediction application form validation (1)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_09_9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – Iris prediction application form validation (1)
  prefs: []
  type: TYPE_NORMAL
- en: 'Validation test 1 – check. Let''s see what happens if only one input field
    remains empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Iris prediction application form validation (2)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_09_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.10 – Iris prediction application form validation (2)
  prefs: []
  type: TYPE_NORMAL
- en: The same message occurs, just as you would expect. To conclude, the form can't
    be submitted if any of the input fields are empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue, fill out all of the fields, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Iris prediction application form values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_09_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – Iris prediction application form values
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to click on the button now, here''s the result you''d see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Iris prediction application results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_09_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – Iris prediction application results
  prefs: []
  type: TYPE_NORMAL
- en: So far, everything works, but there's still one step we should do before connecting
    the application to our Iris prediction API – styling. This step is optional, as
    the application will still work if you decide to jump to the API connection part
    immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting adequate styles to your Flask application will require a bit of work
    and refactoring. You''ll find the entire list of steps here. Keep in mind that
    this book assumes no HTML and CSS knowledge. You''re free to copy and paste the
    content of these files but are encouraged to explore further on your own:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with `app.py`. Instead of returning an `H2` tag with input values
    printed as a single long string, we'll return an HTML template that will show
    a table. For now, we'll fill out the input data only and set dummy values for
    prediction and prediction probability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s how the file should look after the changes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's create a template file while we're at it. Under `/templates`, create a
    `predicted.html` file. As mentioned earlier, this file will contain a table showing
    the API response (once we implement it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s how the file should look:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we've utilized the power of parameter passing to show the data
    going in and out of the predictive model. If you're wondering what the deal is
    with CSS file linking in the document head – don't worry about it for now. We
    still need to work on one thing before dealing with CSS.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, let''s reformat `index.html`. This file will need only minor changes
    – a couple of CSS classes and a couple of `div` elements. Here is the entire code
    snippet for the reformatted version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We're almost there. So far, you've refactored every file that needed refactoring,
    and now you'll create an additional folder and file. Inside the root directory,
    create a folder named `static`. Once created, make an additional folder inside
    it called `css`. This folder will contain all stylings for our application. Inside
    the `css` folder, create a file called `main.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To summarize, here''s how your directory structure should look once you have
    created these folders and file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.13 – New directory structure'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_09_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And we're done. Let's run the application to see how it looks now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you were to re-run the application now, you''d see the stylings taking effect.
    The following figure shows how the input form looks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Styled Iris prediction application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_09_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 – Styled Iris prediction application
  prefs: []
  type: TYPE_NORMAL
- en: 'The application by no means looks perfect now, but it''s at least in a presentable
    form. Let fill it out as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Styled Iris prediction application (2)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_09_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.15 – Styled Iris prediction application (2)
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, let''s click on the **Predict** button to see how the other page
    looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Iris prediction application predictions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_09_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.16 – Iris prediction application predictions
  prefs: []
  type: TYPE_NORMAL
- en: Let's call it a day stylings-wise. The application is at a pretty decent point
    now, but you're free to tweak it further.
  prefs: []
  type: TYPE_NORMAL
- en: And there you have it – how to build and style a `Flask` application built around
    a machine learning model. The next section will connect the app to our API, making
    the app fully functional. See you there.
  prefs: []
  type: TYPE_NORMAL
- en: Making predictions in a GUI environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the last section of the book. This section will tie our simple web
    application to an already-deployed machine learning API. This closely resembles
    a production environment, where you have one or more machine learning models deployed,
    and the application development team wants to use them in their application. The
    only difference is that you're both the data science and application development
    team.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we''ll have to make a couple of changes to the application structure:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the simpler part. Inside the root directory, create a Python
    file called `predictor.py`. This file will hold a single function that implements
    the logic discussed at the beginning of this chapter when we made predictions
    in the notebook environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put simply, this function has to make a POST request to the API and return a
    response in JSON format.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here''s the entire code snippet for the file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Keep in mind that the URL parameter's value will be different on your machine,
    so please change it accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's no point in further explaining this code snippet, as it is nearly identical
    to the code you've seen and written before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's make a couple of changes in `app.py` now. We'll import this file and call
    the `predict()` function right after the input fields are validated. Once the
    response is returned, its values are passed as parameters to the corresponding
    field of the `return` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the entire code snippet for the `app.py` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the prediction probability is converted to a percentage and
    rounded to two decimal points. The only reason for doing so is to have nicer-formatted
    output in the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And now the fun part – testing. Open the application and enter some data into
    the form. Here''s an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Iris prediction application final test'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_09_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.17 – Iris prediction application final test
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click on the **Predict** button, you''ll see the following results
    on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Iris prediction application final results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_09_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.18 – Iris prediction application final results
  prefs: []
  type: TYPE_NORMAL
- en: And there you have it – a complete and fully working GUI web application based
    on a deployed machine learning model.
  prefs: []
  type: TYPE_NORMAL
- en: Not including the summary that follows, this was the last section of the chapter,
    but also the entire book. You now know how to deploy machine learning models and
    build simple web applications around a deployed model. Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter fell into the category of extensive hands-on chapters, but I hope
    you've managed to follow along. If you have, you've learned a lot – from how to
    make predictions in a notebook environment to making predictions in a simple and
    custom-built web application.
  prefs: []
  type: TYPE_NORMAL
- en: Not only that, but you've also completed the entire book. Congratulations! You've
    learned a lot throughout these nine chapters. We started with the basics of machine
    learning through basic regression and classification examples, and from there
    slowly built our knowledge of TPOT. You've also learned how TPOT works with parallel
    training and with neural networks. But probably the most important new skill you've
    acquired is model deployment. Without it, your models are useless, as no one can
    use them to create value.
  prefs: []
  type: TYPE_NORMAL
- en: As always, feel free to explore TPOT and every amazing functionality it has
    to offer on your own. This book should serve you as a great starting point, as
    it took you from zero to building web applications around your deployed automated
    machine learning models in only a couple of hundred pages. Now that's something
    you can be proud of!
  prefs: []
  type: TYPE_NORMAL
- en: Q&A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which Python library can you use to make requests to deployed REST APIs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In which format is data provided when making a POST request?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the Flask extension used to build and work with forms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to validate web application forms if we're talking about
    data going into a machine learning model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you pass parameters to HTML template files through Flask? If so, how can
    you display their values in HTML?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the process of linking CSS files to Flask applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain why there's no point in leaving machine learning models sitting idle
    on your PC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
