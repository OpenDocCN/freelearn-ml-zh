<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Assessments</h1>
                </header>
            
            <article>
                


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 1 </h1>
                </header>
            
            <article>
                
<p><strong>What are the benefits of using design patterns?</strong></p>
<p>Design patterns help the programmer apply already-proven approaches to common problems. There will be less time wasted in searching for the proper solution or fixing a design issue after a sub-optimal implementation. Anti-patterns provide additional guidance for avoiding common design flaws.</p>
<p><strong>What are some of the key design principles?</strong></p>
<p>The key design principles include SOLID, DRY, KISS, POLA, YAGNI, and POLP. These principles are widely recognized as good guidance for object-oriented programming, but they can be applied equally well in other programming paradigms.</p>
<p><strong>What problem does the open/closed principle solve?</strong></p>
<p>The open/closed principle encourages the programmer to design a system that is easy to extend without having to modify the component that is being extended. It promotes better reusability of software components.  </p>
<p><strong>Why is interface segregation important for software reusability?</strong></p>
<p>Interface segregation promotes a minimalistic design for interfaces so that software components can implement the respective interfaces more easily. A large, complex interface is difficult to implement and it makes the component less reusable.</p>
<p>What are the simplest ways to develop maintainable software?</p>
<p>The simplest way to is to adhere to the general design principles such as KISS, DRY, POLA, and SOLID.</p>
<p><strong>What is a good practice for avoiding over-engineering and bloated software?</strong></p>
<p>The best way to avoid over-engineering and bloated software is to only implement functionalities that are absolutely necessary according to the YAGNI principle. Also, keep it simple (KISS) and avoid duplicate code (DRY).</p>
<p><strong>How does memory usage affect system performance?</strong></p>
<p>When the system allocates more memory, it also triggers the <strong>Garbage Collector</strong> (<strong>GC</strong>) more frequently. Garbage collection is a relatively expensive operation and, hence, it can slow down the system. Avoiding over memory allocation is usually one of the best ways to optimize application performance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 2</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>How do we create a new namespace?</strong></p>
<p class="mce-root">A namespace is created using a module block. Typically, a module is defined as part of a Julia package.</p>
<p class="mce-root"><strong>How do we expose the functions of a module to the outside world?</strong></p>
<p class="mce-root">Functions and other objects defined within a module can be exposed using an export statement.</p>
<p class="mce-root"><strong>How do we reference the proper function when the same function name is exported from different packages?</strong></p>
<p class="mce-root">We can just prefix the function name with the package name. As an alternative, we can use a <kbd>using</kbd> statement for one package, and an import statement for the other, so that we can use the function name directly for the first package but use the prefix syntax for the other.</p>
<p class="mce-root"><strong>When do we separate code into multiple modules?</strong></p>
<p class="mce-root">It is time to consider separating code into modules when the code becomes too big and too difficult to manage. We expect some refactoring to ensure the proper level of coupling between modules.</p>
<p class="mce-root"><strong>Why is semantic versioning important in managing package dependencies?</strong></p>
<p class="mce-root">Semantic versioning defines a clear contract about when a breaking change is introduced in a new version. When used properly and consistently, it helps programmers to determine whether the change is compatible with the existing software and whether additional testing is required.</p>
<p class="mce-root"><strong>How is defining functional behavior for abstract types useful?</strong></p>
<p class="mce-root">It is useful to define functional behavior for abstract types because the same behavior can be applied for the respective subtypes.</p>
<p class="mce-root"><strong>When should we make a type mutable?</strong></p>
<p class="mce-root">It is appropriate to make a type mutable when some parts of the data type are expected to be changed. It is also useful when memory allocation needs to be reduced for performance reasons.</p>
<p class="mce-root"><strong>How are parametric types useful?</strong></p>
<p class="mce-root">Parametric types allow a concrete type to be defined without hardcoding the type of its fields, so the same type can be used to generate new variations for different purposes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 3</h1>
                </header>
            
            <article>
                
<p><strong>How are positional arguments different from keyword arguments?</strong></p>
<p>Position arguments must be passed in the same order as they are defined in the function signature. They are typically mandatory, but can be made optional when default values are provided. Keyword arguments can be passed in any order that they are written, and they are optional when default value is not provided.</p>
<p><strong>What is the difference between splatting and slurping?</strong></p>
<p>Splatting and slurping have the same syntax but mean different things in different contexts. Splatting refers to the automatic assignment of function arguments from a tuple or array. Slurping refers to the process of passing multiple function arguments, which becomes a single tuple variable accessible from the body of the function.</p>
<p><strong>What is the purpose of do-syntax?</strong></p>
<p>Do-syntax is a convenient way of formatting a block of code that is needed to be wrapped as an anonymous function and passed to another function. It makes the code much more readable.</p>
<p><strong>What tool is available for detecting method ambiguities as related to multiple dispatch?</strong></p>
<p>The <kbd>detect_ambiguities</kbd> function from the <kbd>Test</kbd> package can be used to detect method ambiguities within a single module or across multiple modules.</p>
<p><strong>How do we ensure that the same concrete type is passed to a function in a parametric method?</strong></p>
<p>A convenient way to ensure that the same concrete type is passed for the arguments of a function is to designate these arguments as a type parameter (for example, <kbd>T</kbd>). Note that this works as long as the type parameter is used as a standalone type rather than part of a parametric type, for example,<span> </span><kbd>AbstractVector{T}</kbd>.</p>
<p><strong>How are interfaces implemented without any formal language syntax?</strong></p>
<p>Interfaces can be implemented according to the contract specified by the designer of the interface even though there is no formal syntax in Julia for specifying interfaces.</p>
<p><strong>How do we implement traits, and how are traits useful?</strong></p>
<p>A trait can be implemented by a function that takes the specific data type(s) and returns a flag. Normally, a trait is defined to return a Boolean value, that is, whether the trait exists or not. However, it can also be designed to return multiple values to indicate various kinds of trait. Traits are useful if the developer needs to programmatically figure out whether a data type (or combination of data types) exhibits a specific behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 4</h1>
                </header>
            
            <article>
                
<p><strong>What are the two ways to quote expressions so the code can be manipulated later?</strong></p>
<p>One way is to enclose an expression with<span> </span><kbd>:(</kbd><span> </span>and<span> </span><kbd>)</kbd>. Another way is to put the code between<span> </span><kbd>quote</kbd><span> </span>and<span> </span><kbd>end</kbd><span> </span>keywords. In general, a quote block is used for multiline expressions.</p>
<p><strong>In which scope does the<span> </span><kbd>eval</kbd><span> </span>function execute the code on?</strong></p>
<p>The <kbd>eval</kbd> function evaluates the code in the global scope. So, if it is used from a function inside a module, then the code that is evaluated will be within the scope of the module.</p>
<p><strong>How do we interpolate physical symbols into quoted expressions rather than being misinterpreted as source code?</strong></p>
<p>To interpolate symbols into quoted expressions, create a<span> </span><kbd>QuoteNode</kbd><span> </span>object and interpolate that object normally.</p>
<p><strong>What is the naming convention for a macro where it defines non-standard string literals?</strong></p>
<p>Non-standard string literals are defined as macros having names ending with<span> </span><kbd>_str</kbd>. For example, when an<span> </span><kbd>ip_str</kbd><span> </span>macro is defined for an IP address, it can be written: <kbd>ip"192.168.1.1"</kbd>.</p>
<p><strong>When do we use the<span> </span><kbd>esc</kbd><span> </span>function?</strong></p>
<p>The<span> </span><kbd>esc</kbd><span> </span>function is needed to ensure that the quoted expression is evaluated at the call site, which could be in the local scope of a function.</p>
<p><strong>How are generated functions different from macros?</strong></p>
<p>Generated functions have access to the types of the arguments. They are functions by definition so, unlike macros, they do not have access to the source code. Macros operate at the syntax level and do not have any runtime information. Both generated functions and macros are expected to return expressions.</p>
<p><strong>How do we debug metaprogramming code?</strong></p>
<p>Debugging macros can be challenging. It comes down to making sure that the expression being returned is correct. We can use the<span> </span><kbd>@macroexpand</kbd><span> </span>macro (or the corresponding<span> </span><kbd>macroexpand</kbd><span> </span>function) to verify results. Also, because a macro or generated function is defined using regular Julia code, the same debugging technique, such as<span> </span><kbd>println</kbd><span>, </span>can be used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 5</h1>
                </header>
            
            <article>
                
<p><strong>How does delegation pattern work?</strong></p>
<p>Delegation pattern can be implemented by wrapping a parent object in a new object. The function for the new objects can be forwarded (or delegated) to the parent object. </p>
<p><strong>What is the purpose of traits?</strong></p>
<p>The purpose of traits is to formally define the behavior of certain objects. Once a trait is defined, we can programmatically examine whether an object exhibits the trait.</p>
<p><strong>Are traits always binary?</strong></p>
<p>Traits are typically binary, but there is no mandatory requirement. It would be fine as long as the traits are mutually exclusive. Julia's <kbd>Base.IteratorSize</kbd> trait is a good example of a multi-valued trait.</p>
<p><strong>Can traits be used for objects from a different type hierarchy?</strong></p>
<p>Yes, <span>traits are not restricted by how the abstract type hierarchy is defined. The same trait can be assigned to objects coming from different type hierarchies.</span></p>
<p><strong>What are the benefits of parametric types?</strong></p>
<p>Parametric types allow us to define a template for data types. New data types can be created programmatically by filling in parameters. The primary benefit of parametric type is that the code becomes shorter because we do not need to spell out every possible concrete type.</p>
<p><strong>How do we store information with a parametric type?</strong></p>
<p>Additional information can be <em>stored</em> in the type itself as a parameter. It is quite convenient to access such data because it is first-class and is available in the function that takes parametric type arguments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 6</h1>
                </header>
            
            <article>
                
<p><strong>Why does the use of global variables impact performance?</strong></p>
<p>Global variables are not typed. Whenever it is used, the compiler must generate code that handles any possible data types that it may encounter. Hence, the compiler cannot generate highly-optimized code.</p>
<p><strong>What would be a good alternative to using a global variable when it cannot be replaced by a constant?</strong></p>
<p>We can define a typed global constant as a placeholder. The <kbd>Ref</kbd> type may also be used to hold a single value for the variable. Because <kbd>Ref</kbd> contains the type of data, the compiler can generate more optimized code.</p>
<p><strong>Why does a struct of arrays perform better than an array of structs?</strong></p>
<p>Modern CPUs can perform many numerical calculations in parallel. When the memory is aligned and packed together as in an array, the hardware cache can quickly look them up. An array of structs may have the objects scattered around in memory, which hurts performance.</p>
<p><strong>What are the limitations of</strong> <kbd>SharedArray</kbd><strong>?</strong></p>
<p><kbd>SharedArray</kbd> only supports bit types. If we need to process non-bits type data in parallel, then we cannot use SharedArrays.</p>
<p><strong>What is an alternative to multi-core computation instead of using parallel processes?</strong></p>
<p>An alternative is to use the multithreading facility. The Julia 1.3 release implemented a state-of-the-art multi-threading scheduler that supports multiple levels of parallelism.</p>
<p><strong>What kind of care must be taken when using the memoization pattern?</strong></p>
<p>Memoization trades space with time. The use of a cache demands more memory space. Depending on the function result, it may or may not impact the memory footprint of the application. If memory is already constrained in the system, it may not be the best option.</p>
<p><strong>What is the magic behind the barrier function in improving performance?</strong></p>
<p>When using the <kbd>barrier</kbd> function, the compiler can specialize the function based upon the types of arguments being passed to the function. Even though the type of argument is unstable, when a new type is encountered, a new specialized function is compiled automatically.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 7</h1>
                </header>
            
            <article>
                
<p><strong>What are afferent and efferent couplings?</strong></p>
<p>Afferent coupling represents how many external components are depending on the current component. By contrast, efferent coupling represents how many external components the current one depends on. These measurements are useful in determining how tightly the current component is coupled with other ones.</p>
<p class="mce-root"><strong>Why are bi-directional dependencies bad from a maintainability perspective?</strong></p>
<p class="mce-root">Bi-directional dependencies tend to introduce messy, spaghetti code. To comprehend a single component, the developer must work through and understand the other components  that it both uses and depends on.</p>
<p class="mce-root"><strong>What is an easy way to generate code on the fly?</strong></p>
<p class="mce-root">The <kbd>@eval</kbd> macro can be used to generate code. For example, it can be used inside a <kbd>for</kbd> loop so that variables can be interpolated into the definition of a function. The result is that multiple functions are defined, and they are all similar in terms of code structure and logic.</p>
<p class="mce-root"><strong>What would be an alternative to code generation?</strong></p>
<p class="mce-root">Sometimes, code generation is not needed. Instead, the developer can choose to use a functional programming technique, such as closure, to reuse existing logic. Code generation may increase the program footprint and makes the program more difficult to debug. So, it would be prudent for a developer to consider other options before plunging into code generation technique.</p>
<p class="mce-root"><strong>When and why should we consider building a domain-specific language?</strong></p>
<p class="mce-root">A <strong>Domain-Specific Language</strong> (<strong>DSL</strong>) is often used for writing code that is clean and easy to understand for people in that particular domain. For example, the <kbd>DifferentialEquations</kbd> package allows the developer to write code in a syntax that is very similar to the corresponding mathematical equations. Because the syntax is user friendly, it allows the developer to focus on mathematic modeling rather than the coding aspect.</p>
<p class="mce-root"><strong>What are the tools available for developing a domain-specific language?</strong></p>
<p class="mce-root">The <kbd>MacroTools</kbd> package provides several convenient macros that are very helpful in writing macros and, in particular, domain-specific languages. The <kbd>@capture</kbd> macro allows users to perform pattern matching and parse source code. The <kbd>prewalk</kbd> and <kbd>postwalk</kbd> functions allow us to surgically replace expressions in an abstract syntax tree. The combination of <kbd>@capture</kbd> and <kbd>prewalk</kbd>/<kbd>postwalk</kbd> makes it a very powerful tool for developing domain-specific languages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 8</h1>
                </header>
            
            <article>
                
<p><strong>What are the benefits of developing assessor functions?</strong></p>
<p>Assessor functions are a great way to provide an official API to users of the particular object. The underlying implementation is therefore decoupled from the interface. Should there be any changes to the implementation, there will be zero impact on users of the object as long as the contract of the assessor functions is unchanged.</p>
<p><strong>What would be an easy way to discourage the use of internal fields of an object?</strong></p>
<p>The easiest way to discourage the use of internal fields of an object is to have a special naming convention. A commonly used convention is to have an underscore as the prefix of the field name. If the programmer tries to use the field, then they are reminded that the field is supposed to be private.</p>
<p><strong>Which functions may be extended as part of the property interface?</strong></p>
<p>There are three functions from the <kbd>Base</kbd> package that can be extended to provide specific functionalities to the dot notation for field access. The functions are <kbd>getproperty</kbd>, <kbd>setproperty!</kbd>, and <kbd>propertynames</kbd>. An important point to remember is that once these functions are defined, all direct field access has to be changed to <kbd>getfield</kbd> and <kbd>setfield!</kbd> to avoid the recursion problem.</p>
<p><strong>How can we capture the stack trace from a catch-block after an exception has been caught?</strong></p>
<p>Once an exception is caught, we can use the <kbd>catch_backtrace</kbd> function to capture the stack frames right before the exception was caught. We can then pass the result to the <kbd>stacktrace</kbd> function to retrieve an array of <kbd>StackFrame</kbd> objects.</p>
<p><strong>What is the best way to avoid the performance impact of a try-catch block for a system that requires optimal performance?</strong></p>
<p>The best way to avoid the performance impact of a try-catch block is to not use it at all. We should find other ways to handle exceptions. For example, we can check for any condition that might cause a subsequent function to fail. In that case, we can proactively handle such a scenario. Another option is to catch the exception outside of a loop; hence, we would handle the exception at a higher level.</p>
<p><strong>What are the benefits of using the <kbd>retry</kbd> function?</strong></p>
<p>The <kbd>retry</kbd> function is a great way to automatically repeat an operation that may fail. Doing this ensures that important tasks are guaranteed to be completed, barring other types of unrecoverable exceptions.  </p>
<p><strong>How do we hide away global variables and functions that are used internally in a module?</strong></p>
<p>We can use a let-block so that global variables are bound as part of the let-block and not exposed to the global scope of the module. Functions that are defined inside the let-block can be declared as global when we need to expose them to the module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 9</h1>
                </header>
            
            <article>
                
<p><strong>What predefined data type can be used to conveniently create new singleton types?</strong></p>
<p>The built-in <kbd>Val</kbd> type can be used to create new singleton types easily. The <kbd>Val</kbd><span> </span><span>constructor function </span><span>can accept any bits-type value and return a singleton of type</span> <kbd>Val{X}</kbd><span>, where</span> <kbd>X</kbd> <span>is the value being passed to the constructor function.</span></p>
<p><strong>What are the benefits of using singleton type dispatch?</strong></p>
<p>Using singleton type dispatch, we can eliminate conditional statements that depend on the data type. It also allows us to add new functionalities by just defining new functions, without having to modify an existing function. Because Julia does the dispatch natively, there is no need to create any custom function just for dispatch.</p>
<p><strong>Why do we want to create stubs?</strong></p>
<p>Stubs are very useful indeed in automated testing. First, if a function requires connecting to a remote web service, then it can be inconvenient or even costly to connect to the live service all of the time. In that case, a stub can be used to replace the service. Second, a stub can be designed to exercise all positive and negative scenarios so that desired tests can be included in the <span>automated testing process.</span></p>
<p><strong>What is the difference between mocking and stubbing?</strong></p>
<p>Stubbing focuses on state verification, that is, what comes out of the <strong>Function Under Test</strong> (<strong>FUT</strong>) after the stub is used. Mocking, on the other hand, focuses on behavior verification, that is, how the mocked function <span>was</span><span> </span><span>used by the FUT. In general, mocking also includes state verification just like stubs.  </span></p>
<p><strong>What does composability mean?</strong></p>
<p>Composability means how easy functions can be combined to create something greater. Composable functions allow applications to be built by reusing existing code. Because functions are first-class in Julia, they can be combined easily, as long as the functions accept only a single argument.</p>
<p><strong>What is the primary constraint for using functional pipes?</strong></p>
<p>The primary constraint of functional pipes is that functions participating in the pipe can only accept a single argument. Functions that need more than one argument can be transformed to a <kbd>curried</kbd> function such that the higher-order function can participate in the pipe.</p>
<p><strong>How are functional pipes useful?</strong></p>
<p>Functional pipes can be useful for data processing pipelines, especially if the process is linear in nature. The syntax is easy to read for some people.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 10</h1>
                </header>
            
            <article>
                
<p><strong>What are the risks and potential benefits of Type I piracy?</strong></p>
<p>Type I piracy refers to a situation where a third-party function is redefined with a custom implementation. The risk is that custom implementation may not conform to the contract as expected by the third-party module. Coded incorrectly, the system may become unstable and crash.</p>
<p><strong>What kind of problems can arise due to Type II piracy?</strong></p>
<p>Type II piracy refers to a situation where a third-party function is extended without using your own types in the function arguments. It can be problematic because there is no guarantee that another dependent package also implements Type II piracy, conflicting with your pirate function. The result can be an unstable system.</p>
<p><strong>How does Type III piracy cause trouble?</strong></p>
<p>Type III piracy refers to a situation where a third-party function is extended with your own types but for a different purpose. While the function is defined using a custom type in the argument, there is no guarantee that the third-party module does not end up using your own function due to duck typing. Hence, your pirate function leaks into the third-party module and causes unexpected results.</p>
<p><strong>What should we watch out for when specifying function arguments?</strong></p>
<p>When specifying function arguments, we should avoid making the argument types too narrow. Arguments that are too narrow limit the reusability of the function.</p>
<p><strong>How is system performance affected by using abstract function arguments?</strong></p>
<p>System performance is not affected when function arguments are specified with abstract types. Julia always <span>specifies</span> the function depending on the type that is passed into the function. Hence, there is no runtime overhead.</p>
<p><strong>How is system performance affected by using abstract field types for composite types?</strong></p>
<p>System performance is affected negatively when abstract types are used for fields in a composite type. The Julia compiler must store pointers in memory for these objects because it has to support any data types relevant to those fields. Because pointers must be dereferenced to get to the data, system performance can be degraded greatly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 11</h1>
                </header>
            
            <article>
                
<p><strong>What technique can we use to implement the abstract factory pattern?</strong></p>
<p>To implement the abstract factory pattern, we can create a hierarchy of abstract types. Then, we can implement concrete functions that take a singleton type in the argument. By way of multiple dispatches, we should be able to call the right function for the right platform or environment.  </p>
<p><strong>How do we avoid a singleton from being initialized multiple times in a multithreaded application?</strong></p>
<p>To avoid multiple initializations of a singleton, we can use a reentrant lock to synchronize the threads. The first thread would be able to obtain the lock and initialize the singleton, while the other threads should wait until the initialization is finished. The lock must be released at the end of the initialization.  </p>
<p><strong>What Julia feature is essential for implementing the observer pattern?</strong></p>
<p>We can implement the<span> </span><kbd>setproperty!</kbd><span> </span>function so that all updates to an object's field can be monitored and additional actions can be triggered.</p>
<p><strong>How can we customize an operation using the template method pattern?</strong></p>
<p>We can design the template function to take in customized functions via keyword arguments. A keyword argument may be defaulted to a standard implementation, and at the same time a custom function can be passed by the caller. The expected interface of the function should be clearly documented.</p>
<p><strong>How do we make an adapter to implement a target interface?</strong></p>
<p>We can make an adapter by creating a new type that wraps the original type. Then, we can implement the expected interface on the new type. Using a delegation pattern, the new type can reuse existing functionality by forwarding specific functions to the original type.</p>
<p><strong>What are the benefits of the flyweight pattern and what strategy can we use to achieve that?</strong></p>
<p>We can potentially save a lot of memory space when using the flyweight pattern because objects are shared. The general technique is to maintain a reference table that uses a more compact data element as a lookup key. The key is used to look up the more memory-intensive objects.</p>
<p><strong>What Julia feature can we use to implement the strategy pattern?</strong></p>
<p>We can implement the strategy pattern using singleton types as functional arguments. The function with the proper algorithm (strategy) is automatically selected at runtime by multiple dispatch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 12</h1>
                </header>
            
            <article>
                
<p><strong>How does implementation inheritance differ from behavior subtyping?</strong></p>
<p>Implementation inheritance allows a subclass to inherit both fields and methods from a super-class. Behavior subtyping allows a subtype to inherit methods defined for a super-type.  </p>
<p><strong>What are some major issues associated with implementation inheritance?</strong></p>
<p>Implementation inheritance is problematic because sometimes, the subclass may not want to inherit the fields from a super-class even when it makes logical sense to define the parent-child relationship. As demonstrated from the square-rectangle problem, a subclass may be more restrictive and take away features rather than adding new functionality on top of the super-class. Second, implementation inheritance suffers from the fragile base class issue, for which changes to the super-class may unintentionally modify the behavior of the subclass.</p>
<p><strong>What is duck typing?</strong></p>
<p>Duck typing is a dynamic feature that allows a method to be dispatched without strong type checking. A function may be dispatched as long as it adheres to the expected interface contract.</p>
<p><strong>What is the variance of method arguments and why?</strong></p>
<p>Method arguments are covariant as they are consistent with the Liskov Substitution Principle, which states that a function that is defined to accept type <em>S</em> should be able to work with any subtype of <em>S</em>.</p>
<p><strong>Why are parametric types invariant in Julia?</strong></p>
<p>Parametric types are invariant in Julia for a very practical reason. The type parameter unambiguously determines the memory layout of the underlying container. When it is invariant, there is an opportunity to achieve high performance by compacting storage data consecutively without having to dereference pointers.</p>
<p><strong>When does the diagonal rule apply?</strong></p>
<p>The diagonal rule is applied whenever a type variable occurs more than once in a covariance position. There is an exception to the rule when the same type variable is unambiguously determined from an invariant position such as in a parametric type.</p>


            </article>

            
        </section>
    </body></html>