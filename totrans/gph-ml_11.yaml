- en: Chapter 8:Graph Analysis for Credit Card Transactions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：信用卡交易图分析
- en: Analysis of financial data is one of the most common and important domains in
    big data and data analysis. Indeed, due to the increasing number of mobile devices
    and the introduction of a standard platform for online payment, the amount of
    transactional data that banks are producing and consuming is increasing exponentially.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 财务数据分析是大数据和数据分析中最常见和最重要的领域之一。确实，由于移动设备的数量不断增加以及在线支付标准的引入，银行产生的交易数据量呈指数级增长。
- en: As a consequence, new tools and techniques are needed to exploit as much as
    we can from this huge amount of information in order to better understand customers'
    behavior and support data-driven decisions in business processes. Data can also
    be used to build better mechanisms to improve security in the online payment process.
    Indeed, as online payment systems are becoming increasingly popular due to e-commerce
    platforms, at the same time, cases of fraud are also increasing. An example of
    a fraudulent transaction is a transaction performed with a stolen credit card.
    Indeed, in this case, the fraudulent transactions will be different from the transactions
    made by the original owner of the credit card.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要新的工具和技术来充分利用这些大量信息，以便更好地理解客户行为并支持业务流程中的数据驱动决策。数据还可以用来构建更好的机制，以改善在线支付过程中的安全性。确实，由于电子商务平台的普及，在线支付系统越来越受欢迎，同时，欺诈案件也在增加。一个欺诈交易的例子是使用被盗信用卡进行的交易。确实，在这种情况下，欺诈交易将与信用卡原始持卡人进行的交易不同。
- en: However, building automatic procedures to detect fraudulent transactions could
    be a complex problem due to the large number of variables involved.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于涉及大量变量，构建自动检测欺诈交易的程序可能是一个复杂问题。
- en: In this chapter, we will describe how we can represent credit card transaction
    data as a graph in order to automatically detect fraudulent transactions using
    machine learning algorithms. We will start processing the dataset by applying
    some of the techniques and algorithms we described in previous chapters to build
    a fraud detection algorithm.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述如何将信用卡交易数据表示为图，以便使用机器学习算法自动检测欺诈交易。我们将通过应用之前章节中描述的一些技术和算法来处理数据集，从而构建一个欺诈检测算法。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Generating a graph from credit card transactions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从信用卡交易生成图
- en: Extraction of properties and communities from the graph
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从图中提取属性和社区
- en: Application of supervised and unsupervised machine learning algorithms to fraud
    classification
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将监督和无监督机器学习算法应用于欺诈分类
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will be using *Jupyter* notebooks with *Python* 3.8 for all of our exercises.
    The following is a list of Python libraries that will be installed for this chapter
    using `pip`. For example, run `pip install networkx==2.5` on the command line:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用带有Python 3.8的*Jupyter*笔记本进行所有练习。以下是本章将使用`pip`安装的Python库列表。例如，在命令行中运行`pip
    install networkx==2.5`：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the rest of this book, unless clearly stated to the contrary, we will refer
    to `nx` as the results of the Python `import networkx as nx` command.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，除非明确指出相反，我们将把`nx`称为Python `import networkx as nx`命令的结果。
- en: All code files relevant to this chapter are available at [https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter08](https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter08).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章相关的所有代码文件可在以下网址找到：[https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter08](https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter08)。
- en: Overview of the dataset
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据集概述
- en: 'The dataset used in this chapter is the *Credit Card Transactions Fraud Detection
    Dataset* available on *Kaggle* at the following URL: [https://www.kaggle.com/kartik2112/fraud-detection?select=fraudTrain.csv](https://www.kaggle.com/kartik2112/fraud-detection?select=fraudTrain.csv).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的数据集是可在*Kaggle*上找到的*Credit Card Transactions Fraud Detection Dataset*，以下为URL：[https://www.kaggle.com/kartik2112/fraud-detection?select=fraudTrain.csv](https://www.kaggle.com/kartik2112/fraud-detection?select=fraudTrain.csv)。
- en: 'The dataset is made up of simulated credit card transactions containing legitimate
    and fraudulent transactions for the period January 1, 2019 – December 31, 2020\.
    It includes the credit cards of 1,000 customers performing transactions with a
    pool of 800 merchants. The dataset was generated using *Sparkov Data Generation*.
    More information about the generation algorithm is available at the following
    URL: [https://github.com/namebrandon/Sparkov_Data_Generation](https://github.com/namebrandon/Sparkov_Data_Generation).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据集由2019年1月1日至2020年12月31日期间的合法和欺诈性信用卡交易组成。它包括1,000名客户与800家商户的交易池进行的交易。该数据集使用*Sparkov数据生成*生成。有关生成算法的更多信息，请访问以下网址：[https://github.com/namebrandon/Sparkov_Data_Generation](https://github.com/namebrandon/Sparkov_Data_Generation)。
- en: 'For each transaction, the dataset contains 23 different features. In the following
    table, we will show only the information that will be used in this chapter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每笔交易，数据集包含23个不同的特征。在以下表中，我们将仅展示本章将使用的信息：
- en: '![Table 8.1 – List of variables used in the dataset'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![表8.1 – 数据集中使用的变量列表'
- en: '](img/B16069_08_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B16069_08_01.jpg](img/B16069_08_01.jpg)'
- en: Table 8.1 – List of variables used in the dataset
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 – 数据集中使用的变量列表
- en: For the purposes of our analysis, we will use the `fraudTrain.csv` file. As
    already suggested, take a look at the dataset by yourself. It is strongly suggested
    to explore and become as comfortable as possible with the dataset before starting
    any machine learning task. We also suggest that you investigate two other datasets
    that will not be covered in this chapter. The first one is the Czech Bank's Financial
    Analysis dataset, available at https://github.com/Kusainov/czech-banking-fin-analysis.
    This dataset came from an actual Czech bank in 1999, for the period covering 1993
    – 1998\. The data pertaining to clients and their accounts consists of directed
    relations. Unfortunately, there are no labels on the transactions, making it impossible
    to train a fraud detection engine using machine learning techniques. The second
    dataset is the paysim1 dataset, available at [https://www.kaggle.com/ntnu-testimon/paysim1](https://www.kaggle.com/ntnu-testimon/paysim1).
    This dataset comprises simulated mobile money transactions based on a sample of
    real transactions extracted from one month of financial logs from a mobile money
    service implemented in an African country. The original logs were provided by
    a multinational company, which is the provider of the mobile financial service
    and is currently running in more than 14 countries across the globe. This dataset
    also contains labels on fraudulent/genuine transactions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的分析目的，我们将使用`fraudTrain.csv`文件。正如之前所建议的，请自己查看数据集。强烈建议在开始任何机器学习任务之前，探索并尽可能熟悉数据集。我们还建议您调查本章未涵盖的两个其他数据集。第一个是捷克银行金融分析数据集，可在https://github.com/Kusainov/czech-banking-fin-analysis找到。该数据集来自1999年的一家实际捷克银行，涵盖1993年至1998年的时期。关于客户及其账户的数据包括有向关系。不幸的是，交易上没有标签，这使得无法使用机器学习技术训练欺诈检测引擎。第二个数据集是paysim1数据集，可在[https://www.kaggle.com/ntnu-testimon/paysim1](https://www.kaggle.com/ntnu-testimon/paysim1)找到。该数据集基于从非洲国家实施的一个移动货币服务的一个月财务日志中提取的真实交易样本模拟的移动货币交易。原始日志由一家跨国公司提供，该公司是移动金融服务提供商，目前在全球14多个国家运营。该数据集还包含欺诈/真实交易的标签。
- en: Loading the dataset and graph building using networkx
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用networkx加载数据集和构建图
- en: 'The first step of our analysis will be to load the dataset and build a graph.
    Since the dataset represents a simple list of transactions, we need to perform
    several operations to build the final credit card transaction graph. The dataset
    is a simple CSV file; we can use `pandas` to load the data as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析的第一步将是加载数据集并构建一个图。由于数据集代表的是一个简单的交易列表，我们需要执行几个操作来构建最终的信用卡交易图。数据集是一个简单的CSV文件；我们可以使用`pandas`如下加载数据：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In order to help the reader deal with the dataset, we selected 20% of the genuine
    transactions and all of the fraudulent transactions. As a result, from a total
    of 1,296,675 transactions, we will only use 265,342 transactions. Moreover, we
    can also investigate the number of fraudulent and genuine transactions in our
    dataset as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助读者处理数据集，我们选择了20%的真实交易和所有的欺诈交易。因此，从总共1,296,675笔交易中，我们只将使用265,342笔交易。此外，我们还可以调查数据集中欺诈和真实交易的数量如下：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By way of a result, we get the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结果，我们得到以下内容：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In other words, from a total of 265,342 transactions, only `7506` (2.83 %) are
    fraudulent transactions, while the others are genuine.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，从总共 265,342 笔交易中，只有 `7506` 笔（2.83%）是欺诈交易，其余都是真实的。
- en: 'The dataset can be represented as a graph using the `networkx` library. Before
    starting with the technical description, we will start by specifying how the graph
    is built from the data. We used two different approaches to build the graph, namely,
    the bipartite and tripartite approaches, as described in the paper *APATE: A Novel
    Approach for Automated Credit Card Transaction Fraud Detection Using Network-Based
    Extensions*, available at https://www.scinapse.io/papers/614715210.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `networkx` 库可以将数据集表示为图。在开始技术描述之前，我们将首先指定如何从数据构建图。我们使用了两种不同的方法来构建图，即二分法和三分法，如论文
    *APATE：使用基于网络的扩展的自动信用卡交易欺诈检测的新方法* 所述，该论文可在 https://www.scinapse.io/papers/614715210
    找到。
- en: For the **bipartite approach**, we build a weighted bipartite graph ![](img/B16069_08_001.png)
    where ![](img/B16069_08_002.png), where each node ![](img/B16069_08_003.png) represents
    a customer, and each node ![](img/B16069_08_004.png) represents a merchant. An
    edge ![](img/B16069_08_005.png) is created if a transaction exists from the customer,
    ![](img/B16069_08_006.png), to the merchant, ![](img/B16069_08_007.png). Finally,
    to each edge of the graph, we assign an (always positive) weight representing
    the amount (in US dollars) of the transaction. In our formalization, we allow
    both directed and undirected graphs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**二分法**，我们构建了一个加权二分图 ![img/B16069_08_001.png]，其中 ![img/B16069_08_002.png]，其中每个节点
    ![img/B16069_08_003.png] 代表一个客户，每个节点 ![img/B16069_08_004.png] 代表一个商家。如果存在从客户 ![img/B16069_08_006.png]，到商家
    ![img/B16069_08_007.png] 的交易，则创建一条边 ![img/B16069_08_005.png]。最后，我们为图中的每条边分配一个（始终为正的）权重，表示交易的金额（以美元计）。在我们的形式化中，我们允许使用有向和无向图。
- en: 'Since the dataset represents temporal transactions, multiple interactions can
    happen between a customer and a merchant. In both our formalizations, we decided
    to collapse all that information in a single graph. In other words, if multiple
    transactions are present between a customer and a merchant, we will build a single
    edge between the two nodes with its weight given by the sum of all the transaction
    amounts. A graphical representation of the direct bipartite graph is visible in
    *Figure 8.1*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据集表示时间序列交易，客户和商家之间可能发生多次交互。在我们的两种形式化中，我们都决定将所有这些信息合并到一个图中。换句话说，如果客户和商家之间存在多笔交易，我们将在这两个节点之间构建一条单边，其权重为所有交易金额的总和。直接二分图的图形表示可见于
    *图 8.1*：
- en: '![Figure 8.1 – Bipartite graph generated from the input dataset'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 从输入数据集生成的二分图'
- en: '](img/B16069_08_011.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_08_011.jpg]'
- en: Figure 8.1 – Bipartite graph generated from the input dataset
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 从输入数据集生成的二分图
- en: 'The bipartite graph we defined can be built using the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的二分图可以使用以下代码构建：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code is quite simple. To build the bipartite credit card transaction graph,
    we use different `networkx` functions. To go more in depth, the operations we
    performed in the code are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简单。为了构建二分信用卡交易图，我们使用了不同的 `networkx` 函数。要深入了解，我们在代码中执行的操作如下：
- en: We built a map to assign a `node_id` to each merchant or customer.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们构建了一个映射，为每个商家或客户分配一个 `node_id`。
- en: Multiple transactions are aggregated in a single transaction.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多笔交易被汇总为单笔交易。
- en: The `networkx` function, `nx.from_edgelist`, is used to build the networkx graph.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `networkx` 函数 `nx.from_edgelist` 来构建 networkx 图。
- en: Two attributes, namely, `weight` and `label`, are assigned to each edge. The
    former represents the total number of transactions between the two nodes, whereas
    the latter indicates whether the transaction is genuine or fraudulent.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每条边分配了两个属性，即 `weight` 和 `label`。前者表示两个节点之间的交易总数，而后者表示交易是真实的还是欺诈的。
- en: 'As we can also see from the code, we can select whether we want to build a
    directed or an undirected graph. We can build an undirected graph by calling the
    following function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，我们可以选择是否构建有向或无向图。我们可以通过调用以下函数来构建无向图：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can instead build a direct graph by calling the following function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过调用以下函数来构建直接图：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The only difference is given by the second parameter we pass in the constructor.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别在于我们传递给构造函数的第二个参数。
- en: The **tripartite approach** is an extension of the previous one, also allowing
    the transactions to be represented as a vertex. If, on the one hand, this approach
    drastically increases network complexity, on the other hand, it allows extra node
    embeddings to be built for merchants and cardholders and every transaction. Formally
    for this approach, we build a weighted tripartite graph, ![](img/B16069_08_008.png),
    where ![](img/B16069_08_009.png), where each node ![](img/B16069_08_010.png) represents
    a customer, each node ![](img/B16069_08_011.png) represents a merchant, and each
    node ![](img/B16069_08_012.png) is a transaction. Two edges ![](img/B16069_08_013.png)
    and ![](img/B16069_08_014.png) are created for each transaction, ![](img/B16069_08_015.png),
    from customer ![](img/B16069_08_016.png) to the merchant ![](img/B16069_08_017.png).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**三分法**是之前方法的扩展，也允许将交易表示为顶点。一方面，这种方法大大增加了网络复杂性，另一方面，它允许为商家和持卡人以及每笔交易构建额外的节点嵌入。正式来说，对于这种方法，我们构建一个加权三分图，![](img/B16069_08_008.png)，其中![](img/B16069_08_009.png)，其中每个节点![](img/B16069_08_010.png)代表一个客户，每个节点![](img/B16069_08_011.png)代表一个商家，每个节点![](img/B16069_08_012.png)代表一笔交易。对于每笔交易![](img/B16069_08_015.png)，创建两个边![](img/B16069_08_013.png)和![](img/B16069_08_014.png)，从客户![](img/B16069_08_016.png)到商家![](img/B16069_08_017.png)。'
- en: 'Finally, to each edge of the graph, we assign an (always positive) weight representing
    the amount (in US dollars) of the transaction. Since, in this case, we create
    a node for each transaction, we do not need to aggregate multiple transactions
    from a customer to a merchant. Moreover, as for the other approach, in our formalization,
    we allow both directed and undirected graphs. A graphical representation of the
    direct bipartite graph is visible in *Figure 8.2*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为图中的每条边分配一个（始终为正的）权重，表示交易金额（以美元计）。由于在这种情况下，我们为每笔交易创建一个节点，因此我们不需要从客户到商家的多笔交易的聚合。此外，与其他方法相比，在我们的形式化中，我们允许使用有向和无向图。直接二分图的图形表示可见于*图8.2*：
- en: '![Figure 8.2 – Tripartite graph generated from the input dataset'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.2 – 从输入数据集生成的三分图]'
- en: '](img/B16069_08_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_08_02.jpg]'
- en: Figure 8.2 – Tripartite graph generated from the input dataset
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 8.2 – 从输入数据集生成的三分图
- en: 'The tripartite graph we defined can be built using the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的三分图可以使用以下代码构建：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code is quite simple. To build the tripartite credit card transaction graph,
    we use different `networkx` functions. To go more in depth, the operations we
    performed in the code are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简单。为了构建三分信用卡交易图，我们使用不同的`networkx`函数。要深入了解，我们在代码中执行的操作如下：
- en: We built a map to assign a `node_id` to each merchant, customer, and transaction.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们构建了一个映射，为每个商家、客户和交易分配一个`node_id`。
- en: The `networkx` function, `nx.from_edgelist`, is used to build the networkx graph,
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`networkx`函数`nx.from_edgelist`用于构建networkx图，'
- en: Two attributes, namely, `weight` and `label`, are assigned to each edge. The
    former represents the total number of transactions between the two nodes, whereas
    the latter indicates whether the transaction is genuine or fraudulent.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每条边分配了两个属性，即`weight`和`label`。前者表示两个节点之间的总交易次数，而后者表示交易是否为真实或欺诈。
- en: 'As we can also see from the code, we can select whether we want to build a
    directed or an undirected graph. We can build an undirected graph by calling the
    following function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从代码中也可以看到，我们可以选择是否要构建有向图或无向图。我们可以通过调用以下函数来构建一个无向图：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can instead build a direct graph by calling the following function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用以下函数来构建一个直接图：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The only difference is given by the second parameter we pass in the constructor.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别在于我们传递给构造函数的第二个参数。
- en: In the formalized graph representation that we introduced, the real transactions
    are represented as edges. According to this structure for both bipartite and tripartite
    graphs, the classification of fraudulent/genuine transactions is described as
    an edge classification task. In this task, the goal is to assign to a given edge
    a label (`0` for genuine, `1` for fraudulent) describing whether the transaction
    the edge represents is fraudulent or genuine.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们引入的形式化图表示中，实际交易被表示为边。根据这种结构，对于二分图和三分图，欺诈/真实交易的分类被描述为边分类任务。在这个任务中，目标是给定的边分配一个标签（`0`表示真实，`1`表示欺诈），描述该边所代表的交易是欺诈还是真实。
- en: In the rest of this chapter, we use for our analysis both bipartite and tripartite
    undirected graphs, denoted by the Python variables `G_bu` and `G_tu`, respectively.
    We will leave it to you, as an exercise, an extension of the analyses proposed
    in this chapter to direct graphs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们使用二部图和三部图的无向图进行分析，分别用Python变量`G_bu`和`G_tu`表示。我们将把本章提出的分析扩展到有向图的练习留给你们。
- en: 'We begin our analysis with a simple check to validate whether our graph is
    a real bipartite graph using the following line:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过以下行进行简单检查，以验证我们的图是否为真正的二部图：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As result, we get `True`. This check gives us the certainty that the two graphs
    are actually bipartite/tripartite graphs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们得到`True`。这个检查让我们确信这两个图实际上是二部图/三部图。
- en: 'Moreover, using the following command, we can get some basic statistics:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用以下命令，我们可以得到一些基本统计信息：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By way of a result, we get the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个结果，我们得到以下：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see, the two graphs differ in both, the number of nodes and the number
    of edges. The bipartite undirected graph has 1,676, equal to the number of customers
    plus the number of merchants with a high number of edges (201,725). The tripartite
    undirected graph has 267,016, equal to the number of customers plus the number
    of merchants plus all the transactions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，两个图在节点数量和边数量上都有所不同。二部图无向图有1,676个节点，等于客户数量加上拥有大量边（201,725）的商家数量。三部图无向图有267,016个节点，等于客户数量加上商家数量加上所有交易。
- en: In this graph, the number of nodes, as expected, is higher (530,680) compared
    to the bipartite graph. The interesting difference in this comparison is given
    by the average degree of the two graphs. Indeed, the average degree of the bipartite
    graph is higher compared to the tripartite graph, as expected. Indeed, since,
    in the tripartite graph, the connections are "split" by the presence of the transaction
    nodes, the average degree is lower.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，正如预期的那样，节点的数量（530,680）比二部图要高。在这个比较中，有趣的不同之处在于两个图的平均度。确实，正如预期的那样，二部图的平均度比三部图要高。实际上，由于在三部图中，交易节点的存在将连接“分割”开来，因此平均度较低。
- en: In the next section, we will describe how we can now use the transaction graphs
    generated to perform a more complete statistical analysis.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将描述如何现在可以使用生成的交易图进行更完整的统计分析。
- en: Network topology and community detection
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络拓扑和社区检测
- en: In this section, we are going to analyze some graph metrics to have a clear
    picture of the general structure of the graph. We will be using `networkx` to
    compute most of the useful metrics we have seen in [*Chapter 1*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014),
    *Getting Started with Graphs*. We will try to interpret the metrics to gain insights
    into the graph.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析一些图度量子，以便对图的一般结构有一个清晰的了解。我们将使用`networkx`来计算我们在[*第一章*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014)，“开始使用图”中看到的大部分有用度量子。我们将尝试解释这些度量子，以获得对图的洞察。
- en: Network topology
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络拓扑
- en: A good starting point for our analysis is the extraction of simple graph metrics
    to have a general understanding of the main properties of bipartite and tripartite
    transaction graphs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析的一个好的起点是提取简单的图度量子，以便对二部图和三部交易图的主要属性有一个一般性的了解。
- en: 'We start by looking at the distribution of the degree for both bipartite and
    tripartite graphs using the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过以下代码查看二部图和三部图的度分布：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'By way of a result, we get the plot in the following diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个结果，我们得到了以下图表：
- en: '![Figure 8.3 – Degree distribution for bipartite (left) and tripartite (right)
    graphs'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – 二部图（左）和三部图（右）的度分布'
- en: '](img/B16069_08_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16069_08_03.jpg)'
- en: Figure 8.3 – Degree distribution for bipartite (left) and tripartite (right)
    graphs
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 二部图（左）和三部图（右）的度分布
- en: From *Figure 8.3*, it is possible to see how the distribution of nodes reflects
    the average degree we previously saw. In greater detail, the bipartite graph has
    a more variegate distribution, with a peak of around 300\. For the tripartite
    graph, the distribution has a big peak for degree 2, while the other part of the
    tripartite degree distribution is similar to the bipartite distribution. These
    distributions completely reflect the differences in how the two graphs were defined.
    Indeed, if bipartite graphs are made by connections from the customer to the merchant,
    in the tripartite graph, all the connections pass through the transaction nodes.
    Those nodes are the majority in the graph, and they all have a degree of 2 (an
    edge from a custom and an edge to a merchant). As a consequence, the frequency
    in the bin representing degree 2 is equal to the number of transaction nodes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图8.3*中，我们可以看到节点分布如何反映了我们之前看到的平均度。更详细地说，二部图有一个更多样化的分布，峰值约为300。对于三部图，分布有一个2度的峰值，而三部图度分布的其他部分与二部图分布相似。这些分布完全反映了两个图定义方式的不同。实际上，如果二部图是通过客户到商家的连接来构建的，那么在三部图中，所有连接都通过交易节点。这些节点是图中的大多数，它们都具有2度（一个来自客户的边和一个指向商家的边）。因此，代表2度频率的箱子的频率等于交易节点的数量。
- en: 'We will continue our investigation by analyzing the `edges weight` distribution:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续通过分析`边权重`分布来继续我们的研究：
- en: 'We begin by computing the quantile distribution:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先计算分位数分布：
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By way of a result, we get the following:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为结果，我们得到以下：
- en: '[PRE15]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using the same command as before, we can also plot (in log scale) the distribution
    of `edges weight`, cut to the 90th percentile. The result is visible in the following
    diagram:![Figure 8.4 – Edge weight distribution for bipartite (left) and tripartite
    (right) graphs
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前的相同命令，我们也可以绘制（对数尺度）`边权重`的分布，切割到90百分位数。结果在以下图表中可见：![图8.4 – 二部图（左侧）和三部图（右侧）的边权重分布
- en: '](img/B16069_08_04.jpg)'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16069_08_04.jpg)'
- en: Figure 8.4 – Edge weight distribution for bipartite (left) and tripartite (right)
    graphs
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.4 – 二部图（左侧）和三部图（右侧）的边权重分布
- en: We can see how, due to the aggregation of the transaction having the same customer
    and merchant, the distribution of the bipartite graph is shifted to the right
    (high values) compared to the tripartite graph, where edge weights were not computed,
    aggregating multiple transactions.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '我们可以看到，由于具有相同客户和商家的交易聚合，与没有计算边权重、聚合多个交易的三部图相比，二部图的分布向右（高值）偏移。 '
- en: 'We will now investigate the `betweenness centrality` metric. It measures how
    many shortest paths pass through a given node, giving an idea of how *central*
    that node is for the spreading of information inside the network. We can compute
    the distribution of node centrality by using the following command:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将研究`介数中心性`指标。它衡量有多少最短路径通过一个给定的节点，从而给出了该节点在信息在网络内部传播中的*中心性*。我们可以通过以下命令计算节点中心性的分布：
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As result, we get the following distributions:![Figure 8.5 – Betweenness centrality
    distribution for bipartite (left) and tripartite (right) graphs
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为结果，我们得到以下分布：![图8.5 – 二部图（左侧）和三部图（右侧）的介数中心性分布
- en: '](img/B16069_08_05.jpg)'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16069_08_05.jpg)'
- en: Figure 8.5 – Betweenness centrality distribution for bipartite (left) and tripartite
    (right) graphs
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.5 – 二部图（左侧）和三部图（右侧）的介数中心性分布
- en: As expected, for both graphs, the betweenness centrality is low. This can be
    understood due to the large number of non-bridging nodes inside the network. Similar
    to what we saw for the degree distribution, the distribution of betweenness centrality
    values is different in the two graphs. Indeed, if the bipartite graph has a more
    variegate distribution with a mean of 0.00072, in the tripartite graph, the transaction
    nodes are the ones that mainly move the distribution values and lower the mean
    to 1.38e-05\. Also, in this case, we can see that the distribution for the tripartite
    graph has a big peak, representing the transaction nodes, and the rest of the
    distribution is quite similar to the bipartite distribution.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如预期，对于两个图，中间中心性都较低。这可以通过网络内部大量非桥接节点来理解。与我们所看到的度分布类似，中间中心性值的分布在这两个图中是不同的。实际上，如果二分图有一个更分散的分布，平均值为0.00072，那么在三分图中，交易节点是主要移动分布值并降低平均值到1.38e-05的节点。在这种情况下，我们还可以看到三分图的分布有一个大峰值，代表交易节点，其余的分布与二分图分布相当相似。
- en: 'We can finally compute the assortativity of the two graphs using the following
    code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们终于可以使用以下代码来计算两个图的相似性：
- en: '[PRE17]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By way of a result, we get the following:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这种方式，我们得到以下结果：
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we can observe how both graphs have a negative assortativity, likely showing
    that well-connected individuals associate with poor-connected individuals. For
    the bipartite graph, the value is low (-0.14), since customers who have a low
    degree are only connected with merchants who have high degrees due to the high
    number of incoming transactions. The assortativity is even lower (-0.81) for the
    tripartite graph. This behavior is expected due to the presence of the transaction
    nodes. Indeed, those nodes always have a degree of 2, and they are linked to customers
    and merchants represented by highly connected nodes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以观察到两个图都具有负相似性，这很可能表明联系紧密的人与联系较差的人联系在一起。对于二分图，由于低度数的客户仅与高度数的商家相连，因为交易数量众多，所以值较低（-0.14）。对于三分图，相似性甚至更低（-0.81）。由于存在交易节点，这种表现是可以预期的。实际上，这些节点总是具有2度，并且与代表高度连接节点的客户和商家相连。
- en: Community detection
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社区检测
- en: 'Another interesting analysis we can perform is community detection. This analysis
    can help to identify specific fraudulent patterns:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可以进行的有趣分析是社区检测。这种分析有助于识别特定的欺诈模式：
- en: 'The code to perform community extraction is as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行社区提取的代码如下：
- en: '[PRE19]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this code, we simply use the `community` library to extract the communities
    in the input graph. We then print the communities detected by the algorithms,
    sorted according to the number of nodes contained.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码中，我们简单地使用`community`库从输入图中提取社区。然后我们按包含的节点数量对算法检测到的社区进行排序并打印出来。
- en: 'For the bipartite graph, we obtain the following output:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于二分图，我们得到以下输出：
- en: '[PRE20]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For the tripartite graph, we obtain the following output:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于三分图，我们得到以下输出：
- en: '[PRE21]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Due to a large number of nodes in the tripartite graph, we found 106 communities
    (we reported just a subset of them), while, for the bipartite graph, only 12 communities
    were found. As consequence, to have a clear picture, for the tripartite graph,
    it is better to plot the distribution of the nodes contained in the different
    communities using the following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于三分图中有大量节点，我们发现了106个社区（我们只报告了其中的一部分），而对于二分图，只发现了12个社区。因此，为了有一个清晰的图像，对于三分图，最好使用以下命令绘制不同社区中包含的节点分布：
- en: '[PRE22]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By way of a result, we get the following:![Figure 8.6 – Distribution of communities'
    node size
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这种方式，我们得到以下结果：![图8.6 – 社区节点大小的分布
- en: '](img/B16069_08_06.jpg)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16069_08_06.jpg)'
- en: Figure 8.6 – Distribution of communities' node size
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.6 – 社区节点大小的分布
- en: From the diagram, it is possible to see how the peak is reached around 2,500\.
    This means that more than 30 large communities have more than 2,000 nodes. From
    the plot, it is also possible to see that a few communities have fewer than 1,000
    nodes and more than 3,000 nodes.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从图中可以看到，峰值在约2,500处。这意味着有30多个大型社区拥有超过2,000个节点。从图中还可以看到，一些社区拥有少于1,000个节点和超过3,000个节点。
- en: 'For each set of communities detected by the algorithm, we can compute the percentage
    of fraudulent transactions. The goal of this analysis is to identify specific
    sub-graphs where there is a high concentration of fraudulent transactions:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于算法检测到的每一组社区，我们可以计算欺诈交易的百分比。分析的目标是识别欺诈交易高度集中的特定子图：
- en: '[PRE23]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The code simply generates a node-induced subgraph by using the nodes contained
    in a specific community. The graph is used to compute the percentage of fraudulent
    transactions as a ratio of the number of fraudulent edges over the number of all
    the edges in the graph. We can also plot a node-induced subgraph detected by the
    community detection algorithm by using the following code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码简单地通过使用特定社区中的节点生成节点诱导子图。该图用于计算欺诈交易的百分比，即欺诈边数与图中所有边数的比率。我们还可以使用以下代码绘制社区检测算法检测到的节点诱导子图：
- en: '[PRE24]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Given a particular community index, `gId`, the code extracts the node-induced
    subgraph, using the node available in the `gId` community index, and plots the
    graph obtained.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给定特定的社区索引`gId`，代码提取包含在`gId`社区索引中的节点，并绘制得到的图。
- en: 'By running the two algorithms on the bipartite graph, we will obtain the following:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在二分图上运行两个算法，我们将得到以下结果：
- en: '[PRE25]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For each community, we have the percentage of its fraudulent edges. To have
    a better description of the subgraph, we can plot community 10 by executing the
    previous line of code using `gId=10`. As a result, we get the following:![Figure
    8.7 – Induced subgraph of community 10 for the bipartite graph
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个社区，我们都有其欺诈边的百分比。为了更好地描述子图，我们可以通过执行上一行代码并使用`gId=10`来绘制社区10。结果如下：![图8.7 –
    二分图中社区10的诱导子图
- en: '](img/B16069_08_07.jpg)'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16069_08_07.jpg)'
- en: Figure 8.7 – Induced subgraph of community 10 for the bipartite graph
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.7 – 二分图中社区10的诱导子图
- en: 'The image of the induced subgraph allows us to better understand whether specific
    patterns are visible in the data. Running the same algorithms on the tripartite
    graph, we obtain the following output:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 诱导子图的图像使我们能够更好地理解数据中是否存在特定模式。在三分图上运行相同的算法，我们得到以下输出：
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Due to the large number of communities, we can plot the distribution of the
    fraudulent over genuine ratio with the following command:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于社区数量众多，我们可以使用以下命令绘制欺诈与真实比率分布图：
- en: '[PRE27]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By way of a result, we get the following:![Figure 8.8 – Distribution of communities'
    fraudulent/genuine edge ratio
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果如下：![图8.8 – 社区欺诈/真实边比率分布
- en: '](img/B16069_08_08.jpg)'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16069_08_08.jpg)'
- en: Figure 8.8 – Distribution of communities' fraudulent/genuine edge ratio
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.8 – 社区欺诈/真实边比率分布
- en: From the diagram, we can observe that a large part of the distribution is around
    communities having a ratio of between 2 and 4\. There are a few communities with
    a low ratio (<1) and with a high ratio (>5).
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从图中，我们可以观察到大部分分布集中在比率为2到4之间的社区。有几个社区比率较低（<1）和比率较高（>5）。
- en: 'Also, for the tripartite graph, we can plot community 6 (with a ratio of 6.86),
    made by 1,935 nodes, by executing the previous line of code using `gId=6`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，对于三分图，我们可以通过执行上一行代码并使用`gId=6`来绘制由1,935个节点组成的社区6（比率为6.86）：
- en: '![Figure 8.9 – Induced subgraph of community 6 for the tripartite graph'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9 – 三分图中社区6的诱导子图'
- en: '](img/B16069_08_09.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16069_08_09.jpg)'
- en: Figure 8.9 – Induced subgraph of community 6 for the tripartite graph
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 三分图中社区6的诱导子图
- en: As for the bipartite use case, in this image, we can see an interesting pattern
    that could be used to perform a deeper exploration of some important graph sub-regions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二分图用例，在这张图像中，我们可以看到一个有趣的模式，可以用来深入探索一些重要的图子区域。
- en: In this section, we perform some explorative tasks to better understand the
    graphs and their properties. We also gave an example describing how a community
    detection algorithm can be used to spot patterns in the data. In the next section,
    we will describe how machine learning can be used to automatically detect fraudulent
    transactions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们执行一些探索性任务，以更好地理解图及其属性。我们还提供了一个示例，说明如何使用社区检测算法来发现数据中的模式。在下一节中，我们将描述如何使用机器学习自动检测欺诈交易。
- en: Embedding for supervised and unsupervised fraud detection
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监督和无监督欺诈检测嵌入
- en: 'In this section, we will describe how the bipartite and tripartite graphs described
    previously can be used by graph machine learning algorithms to build automatic
    procedures for fraud detection using supervised and unsupervised approaches. As
    we already discussed at the beginning of this chapter, transactions are represented
    by edges, and we then want to classify each edge in the correct class: fraudulent
    or genuine.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述如何使用之前描述的二分图和三分图，通过图机器学习算法利用监督和无监督方法构建自动的欺诈检测程序。正如我们在本章开头所讨论的，交易由边表示，我们接下来想要将每个边分类到正确的类别：欺诈或真实。
- en: 'The pipeline we will use to perform the classification task is the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于执行分类任务的流程如下：
- en: A sampling procedure for the imbalanced task
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不平衡任务的采样程序
- en: The use of an unsupervised embedding algorithm to create a feature vector for
    each edge
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无监督嵌入算法为每个边缘创建特征向量
- en: The application of supervised and unsupervised machine learning algorithms to
    the feature space defined in the previous point
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将监督和无监督机器学习算法应用于前一点定义的特征空间
- en: Supervised approach to fraudulent transaction identification
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监督方法用于欺诈交易识别
- en: 'Since our dataset is strongly imbalanced, with fraudulent transactions representing
    2.83% of total transactions, we need to apply some techniques to deal with unbalanced
    data. In this use case, we will apply a simple random undersampling strategy.
    Going into more depth, we will take a subsample of the majority class (genuine
    transactions) to match the number of samples of the minority class (fraudulent
    transactions). This is just one of the many techniques available in literature.
    It is also possible to use outlier detection algorithms, such as isolation forest,
    to detect fraudulent transactions as outliers in the data. We leave it to you,
    as an exercise, to extend the analyses using other techniques to deal with imbalanced
    data, such as random oversampling or using cost-sensitive classifiers for the
    classification task. Specific techniques for node and edge sampling that can be
    directly applied to the graph will be described in [*Chapter 10*](B16069_10_Final_JM_ePub.xhtml#_idTextAnchor150),
    *Novel Trends on Graphs*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的数据集高度不平衡，欺诈交易占总交易的 2.83%，我们需要应用一些技术来处理不平衡数据。在这个用例中，我们将应用简单的随机欠采样策略。更深入地说，我们将从多数类（真实交易）中抽取子样本以匹配少数类（欺诈交易）的样本数量。这只是文献中许多技术中的一种。也有可能使用异常检测算法，如隔离森林，将欺诈交易检测为数据中的异常。我们将这个任务留给你作为练习，使用其他技术来处理不平衡数据，例如随机过采样或使用成本敏感分类器进行分类任务。可以直接应用于图的节点和边缘采样的特定技术将在[*第10章*](B16069_10_Final_JM_ePub.xhtml#_idTextAnchor150)中描述，*图的新趋势*：
- en: 'The code we use for random undersampling is as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用于随机欠采样的代码如下：
- en: '[PRE28]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The code is straightforward. We applied the `resample` function of the `sklearn`
    package to filter the `downsample` function of the original data frame. We then
    build a graph using the function defined at the beginning of the chapter. To create
    the tripartite graph, the `build_graph_tripartite` function should be used. As
    the next step, we split the dataset into training and validation with a ratio
    of 80/20:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码很简单。我们应用了 `sklearn` 包中的 `resample` 函数来过滤原始数据框中的 `downsample` 函数。然后，我们使用本章开头定义的函数构建一个图。为了创建三分图，应使用
    `build_graph_tripartite` 函数。作为下一步，我们将数据集分为训练集和验证集，比例为 80/20：
- en: '[PRE29]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As before, also in this case, the code is straightforward since we simply apply
    the `train_test_split` function of the `sklearn` package.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与之前一样，在这种情况下，代码也很简单，因为我们只是应用了 `sklearn` 包中的 `train_test_split` 函数。
- en: 'We can now build the feature space using the `Node2Vec` algorithm as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `Node2Vec` 算法如下构建特征空间：
- en: '[PRE30]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `node2vec` results are used to build, as described in [*Chapter 3*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Unsupervised Graph Learning*, the edge embedding that will generate the final
    feature space used by the classifier.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如[*第3章*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046)中所述，使用 `node2vec` 结果构建边缘嵌入，这将生成分类器使用的最终特征空间，该嵌入属于*无监督图学习*。
- en: 'The code to perform this task is the following:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此任务的代码如下：
- en: '[PRE31]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Different steps are performed compared to the previous code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的代码相比，执行了不同的步骤：
- en: For each `Edge2Vec` algorithm, the previously computed `Node2Vec` algorithm
    is used to generate the feature space.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个 `Edge2Vec` 算法，都使用先前计算出的 `Node2Vec` 算法来生成特征空间。
- en: A `RandomForestClassifier` from the `sklearn` Python library is trained on the
    feature set generated in the previous step.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步生成的特征集上，使用`sklearn` Python库中的`RandomForestClassifier`进行训练。
- en: Different performance metrics, namely, precision, recall, and F1-score, are
    computed on the validation test.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在验证测试上计算了不同的性能指标，即精确度、召回率和F1分数。
- en: 'We can apply the code we previously described to both bipartite and tripartite
    graphs to solve the fraud detection task. In the following table, we report the
    performances for the bipartite graph:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将之前描述的代码应用于二分图和三分图来解决欺诈检测任务。在下面的表中，我们报告了二分图的性能：
- en: '![Table 8.2 – Supervised fraud edge classification performances for a bipartite
    graph'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![表8.2 – 二分图的监督欺诈边缘分类性能'
- en: '](img/B16069_08_021.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16069_08_021.jpg)'
- en: Table 8.2 – Supervised fraud edge classification performances for a bipartite
    graph
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2 – 二分图的监督欺诈边缘分类性能
- en: 'In the following table, we report the performances for the tripartite graph:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的表中，我们报告了三分图的性能：
- en: '![Table 8.3 – Supervised fraud edge classification performances for a tripartite
    graph'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![表8.3 – 三分图的监督欺诈边缘分类性能'
- en: '](img/B16069_08_031.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16069_08_031.jpg)'
- en: Table 8.3 – Supervised fraud edge classification performances for a tripartite
    graph
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.3 – 三分图的监督欺诈边缘分类性能
- en: In *Table 8.2* and *Table 8.3*, we reported the classification performances
    obtained using bipartite and tripartite graphs. As we can see from the results,
    the two methods, in terms of F1-score, precision, and recall, show significant
    differences. Since, for both graph types, Hadamard and average edge embedding
    algorithms give the most interesting results, we are going to focus our attention
    on those two. Going into more detail, the tripartite graph has a better precision
    compared to the bipartite graph (0.89 and 0.74 for the tripartite graph versus
    0.73 and 0.71 for the bipartite graph).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在*表8.2*和*表8.3*中，我们报告了使用二分图和三分图获得的分类性能。从结果中可以看出，这两种方法在F1分数、精确度和召回率方面存在显著差异。由于对于两种图类型，Hadamard和平均边嵌入算法给出了最有趣的结果，我们将重点关注这两个算法。更详细地说，三分图的精确度比二分图更好（三分图的精确度为0.89和0.74，而二分图的精确度为0.73和0.71）。
- en: In contrast, the bipartite graph has a better recall compared to the tripartite
    graph (0.76 and 0.79 for the bipartite graph versus 0.29 and 0.45 for the tripartite
    graph). We can therefore conclude that in this specific case, the use of a bipartite
    graph could be a better choice since it achieves high performances in terms of
    F1 with a smaller graph (in terms of nodes and edges) compared to the tripartite
    graph.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，二分图的召回率比三分图更好（二分图的召回率为0.76和0.79，而三分图的召回率为0.29和0.45）。因此，我们可以得出结论，在这种情况下，使用二分图可能是一个更好的选择，因为它在F1分数方面实现了较高的性能，并且与三分图相比，图的大小（节点和边）更小。
- en: Unsupervised approach to fraudulent transaction identification
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无监督欺诈交易识别方法
- en: 'The same approach can also be applied in unsupervised tasks using k-means.
    The main difference is that the generated feature space will not undergo a train-validation
    split. Indeed, in the following code, we will compute the `Node2Vec` algorithm
    on the entire graph generated following the downsampling procedure:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法也可以应用于使用k-means的无监督任务。主要区别在于生成的特征空间将不会经历训练-验证分割。实际上，在下面的代码中，我们将对按照下采样过程生成的整个图上的`Node2Vec`算法进行计算：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As previously defined for the supervised analysis, when building the node feature
    vectors, we can use different `Egde2Vec` algorithms to run the k-means algorithm
    as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在构建节点特征向量时，我们可以使用不同的`Egde2Vec`算法来运行k-means算法，如下所示：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Different steps are performed in the previous code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中执行了不同的步骤：
- en: For each `Edge2Vec` algorithm, the previously computed `Node2Vec` algorithm
    on train and validation sets is used to generate the feature space.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个`Edge2Vec`算法，使用之前在训练和验证集上计算的`Node2Vec`算法来生成特征空间。
- en: A `KMeans` clustering algorithm from the `sklearn` Python library is fitted
    on the feature set generated in the previous step.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步生成的特征集上，使用`sklearn` Python库中的`KMeans`聚类算法进行拟合。
- en: Different performance metrics, namely, adjusted **mutual information** (**MNI**),
    homogeneity, completeness, and v-measure scores.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不同的性能指标，即调整后的**互信息**（**MNI**）、同质性、完整性和v-measure分数。
- en: 'We can apply the code described previously to both bipartite and tripartite
    graphs to solve the fraud detection task using the unsupervised algorithm. In
    the following table, we report the performances for the bipartite graph:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 8.4 – Unsupervised fraud edge classification performances for the bipartite
    graph'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_08_041.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.4 – Unsupervised fraud edge classification performances for the bipartite
    graph
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table, we report the performances for the tripartite graph:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 8.5 – Unsupervised fraud edge classification performances for the tripartite
    graph'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_08_051.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.5 – Unsupervised fraud edge classification performances for the tripartite
    graph
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: In *Table 8.4* and *Table 8.5*, we reported the classification performances
    obtained using bipartite and tripartite graphs with the application of an unsupervised
    algorithm. As we can see from the results, the two methods show significant differences.
    It is also worth noticing that, in this case, the performances obtained with the
    Hadamard embedding algorithm clearly outperform all other approaches.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: As shown by *Table 8.4* and *Table 8.5*, also for this task, the performances
    obtained with the tripartite graph outstrip those obtained with the bipartite
    graph. In the unsupervised case, we can see how the introduction of the transaction
    nodes improves overall performance. We can assert, that, in the unsupervised setting,
    for this specific use case and using as a reference the results obtained in *Table
    8.4* and *Table 8.5*, use of the tripartite graph could be a better choice since
    it enables the attainment of superior performances compared with the bipartite
    graph.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described how a classical fraud detection task can be described
    as a graph problem and how the techniques described in the previous chapter can
    be used to tackle the problem. Going into more detail, we introduced the dataset
    we used and described the procedure to transform the transactional data into two
    types of graph, namely, bipartite and tripartite undirected graphs. We then computed
    local (along with their distributions) and global metrics for both graphs, comparing
    the results.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, a community detection algorithm was applied to the graphs in order
    to spot and plot specific regions of the transaction graph where the density of
    fraudulent transactions is higher compared to the other communities.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we solved the fraud detection problem using supervised and unsupervised
    algorithms, comparing the performances of the bipartite and tripartite graphs.
    As the first step, since the problem was unbalanced with a higher presence of
    genuine transactions, we performed simple downsampling. We then applied different
    Edge2Vec algorithms in combination with a random forest, for the supervised task,
    and k-means for an unsupervised task, achieving good classification performances.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes the series of examples that are used to show how graph
    machine learning algorithms can be applied to problems belonging to different
    domains, such as social network analysis, text analytics, and credit card transaction
    analysis.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了用于展示图机器学习算法如何应用于不同领域问题的示例系列，例如社交网络分析、文本分析和信用卡交易分析。
- en: In the next chapter, we will describe some practical uses for graph databases
    and graph processing engines that are useful for scaling out the analysis to large
    graphs.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将描述一些图数据库和图处理引擎的实际应用，这些工具对于将分析扩展到大型图非常有用。
