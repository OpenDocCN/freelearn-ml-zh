<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer048">
			<h1 id="_idParaDest-57" class="chapter-number"><a id="_idTextAnchor056"/>4</h1>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Vertex AI Workbench – a One-Stop Tool for AI/ML Development Needs</h1>
			<p><strong class="bold">Machine learning</strong> (<strong class="bold">ML</strong>) projects are <a id="_idIndexMarker170"/>complex in nature and require an entirely different type of development environment from normal software applications. When the data is huge, a data scientist may want to use several big data tools for <a id="_idIndexMarker171"/>quick wrangling or preprocessing needs, and a <strong class="bold">deep learning</strong> (<strong class="bold">DL</strong>) model might require several GPUs for fast training and experimentation. Additionally, dedicated compute resources are required for hosting models in production, and even more to scale them up to the enterprise level. Acquiring such resources and tools is quite costly, and even if we manage to buy and set things up, it takes a lot of effort and technical knowledge to bring them together into a project pipeline. Even after doing all that, there are risks of downtime and <span class="No-Break">data security.</span></p>
			<p>Nowadays, cloud-based solutions are very popular and take care of all the technical hassle, scaling, and security aspects for us. These solutions let ML developers focus more on project development and experimentation without worrying about infrastructure <a id="_idIndexMarker172"/>and other low-level things. As an <strong class="bold">artificial intelligence</strong> (<strong class="bold">AI</strong>)-first company, Google brings all the important resources required for ML project development under one umbrella called Vertex AI. In this chapter, we will learn about Vertex AI Workbench, a managed solution for Jupyter Notebook kernels that can help us bring our ML projects from prototype to production many <span class="No-Break">times faster.</span></p>
			<p>This chapter covers the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>What is <span class="No-Break">Jupyter Notebooks?</span></li>
				<li>Vertex <span class="No-Break">AI Workbench</span></li>
				<li>Custom containers for Vertex <span class="No-Break">AI Workbench</span></li>
				<li>Scheduling notebooks in <span class="No-Break">Vertex AI</span></li>
			</ul>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>What is Jupyter Notebook?</h1>
			<p>Jupyter Notebook is an open source web-based application for writing and sharing live code, documentation, visualizations, and so on. Jupyter Notebooks are very popular among ML practitioners <a id="_idIndexMarker173"/>as they provide the flexibility to run code dynamically and collaborate, provide fast visualizations, and can also be used for presentations. Most data scientists and ML practitioners prefer Jupyter Notebook as their primary tool for exploring, visualizing, and preprocessing data using powerful Python libraries <a id="_idIndexMarker174"/>such as pandas and NumPy. Jupyter Notebooks are very useful for <strong class="bold">exploratory data analysis</strong> (<strong class="bold">EDA</strong>) as they let us run small code blocks dynamically and also draw quick plots to understand data statistically. Notebooks can also be used for doing quick ML modeling experiments. Another good thing about Jupyter Notebooks is that they let us write Markdown cells as well. Using Markdown, we can explain each code block inside the notebook and turn it into a tutorial. Jupyter Notebooks are popular among ML communities to share and collaborate on projects on platforms such as GitHub <span class="No-Break">and Kaggle.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Getting started with Jupyter Notebook</h2>
			<p>The Jupyter Notebook <a id="_idIndexMarker175"/>application can be installed in local systems using a simple <strong class="source-inline">pip</strong> command (shown next). For quick experiments, we can also utilize web-based notebook kernels such as Colab and Kaggle, where everything is already set and we can run the Python code directly. As these kernels are public, we can’t use them if our data is confidential, and we will have to install the Jupyter Notebook application on <span class="No-Break">our system.</span></p>
			<p>We can install the Jupyter application on our local system by using the following <span class="No-Break"><strong class="source-inline">pip</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
$ pip install jupyter</pre>			<p>Once the application is installed, it can be launched through the terminal by typing the following command, and it will automatically open the Jupyter application in a <span class="No-Break">browser tab:</span></p>
			<pre class="console">
$ jupyter notebook</pre>			<p>If it doesn’t open the browser tab automatically, we can launch the application by typing the following URL: <a href="http://localhost:8888/tree">http://localhost:8888/tree</a>. By default, the Jupyter server starts on port <strong class="source-inline">8888</strong>, but if this port is unavailable, it finds the next available port. If we are interested in using a custom port, we can launch Jupyter by passing a custom <span class="No-Break">port number.</span></p>
			<p>Here is a terminal command for launching the Jupyter application on custom port <span class="No-Break">number </span><span class="No-Break"><strong class="source-inline">9999</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$ jupyter notebook --port 9999</pre>			<p class="callout-heading">Note</p>
			<p class="callout">In some cases, the Jupyter server may ask for a token (maybe in the case of a non-default browser) when we try to hit the aforementioned URL manually. In such cases, we can copy the URL from the terminal output that provides the token within the URL. Alternatively, we can obtain a token by running the <strong class="source-inline">jupyter notebook list</strong> command in <span class="No-Break">the terminal.</span></p>
			<p>Once we are <a id="_idIndexMarker176"/>able to launch the application server in a browser, the Jupyter server looks something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B17792_04_1.jpg" alt="Figure 4.1 – Jupyter application server UI" width="1210" height="352"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Jupyter application server UI</p>
			<p>Now, we can launch a Jupyter Notebook instance by clicking on the <strong class="bold">New</strong> button. It creates a new notebook and saves it in the same directory where we started the Jupyter Notebook from the terminal. We can now open that notebook in a new tab and start running scripts. The following screenshot shows an <span class="No-Break">empty notebook:</span></p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B17792_04_2.jpg" alt="Figure 4.2 – A Jupyter Notebook instance" width="1208" height="382"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – A Jupyter Notebook instance</p>
			<p>As we can see in the previous screenshot, the web UI provides multiple options to manipulate notebooks, code, cells, kernels, and so on. A notebook cell can execute code or can be converted into a Markdown cell by changing its type from the drop-down menu. There are <a id="_idIndexMarker177"/>also options for exporting notebooks into different formats such as HTML, PDF, Markdown, LaTeX, and so on for creating reports or presentations. Going further in the book, we will be working with notebooks a lot for data wrangling, modeling, and <span class="No-Break">so on.</span></p>
			<p>Now that we have some basic understanding of Jupyter Notebooks in general, let’s see how Vertex AI Workbench provides a more enriched experience of working with a Jupyter <span class="No-Break">Notebook-based environment.</span></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/>Vertex AI Workbench</h1>
			<p>While working <a id="_idIndexMarker178"/>on an ML project, if we are running a Jupyter Notebook in a local environment, or using a web-based Colab- or Kaggle-like kernel, we can perform some quick experiments and get some initial accuracy or results from ML algorithms very fast. But we hit a wall when it comes to performing large-scale experiments, launching long-running jobs, hosting a model, and also in the case of model monitoring. Additionally, if the data related to a project requires some more granular permissions on security and privacy (fine-grained control over who can view/access the data), it’s not feasible in local or Colab-like environments. All these challenges can be solved just by moving to the cloud. Vertex AI Workbench within Google Cloud is a JupyterLab-based environment that can be leveraged for all kinds of development needs of a typical data science project. The JupyterLab environment is very similar to the Jupyter Notebook environment, and thus we will be using these terms interchangeably throughout <span class="No-Break">the book.</span></p>
			<p>Vertex AI Workbench <a id="_idIndexMarker179"/>has options for creating <em class="italic">managed notebook instances</em> as well as <em class="italic">user-managed notebook instances</em>. User-managed notebook instances give more control to the user, while managed notebooks come with some key extra features. We will discuss more about these later in this section. Some key features of <a id="_idIndexMarker180"/>the Vertex AI Workbench notebook suite include <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Fully managed</span><strong class="bold">–</strong>Vertex AI Workbench provides a Jupyter Notebook-based fully managed environment that provides enterprise-level scale without managing infrastructure, security, and <span class="No-Break">user-management capabilities.</span></li>
				<li>Interactive experience–Data exploration and model experiments are easier as managed notebooks can easily interact with other Google Cloud services such as storage systems, big data solutions, and <span class="No-Break">so on.</span></li>
				<li>Prototype to production AI–Vertex AI notebooks can easily interact with other Vertex AI tools and Google Cloud services and thus provide an environment to run end-to-end ML projects from development to deployment with <span class="No-Break">minimal transition.</span></li>
				<li>Multi-kernel support–Workbench provides multi-kernel support in a single managed notebook instance including kernels for tools such as TensorFlow, PyTorch, Spark, and R. Each of these kernels comes with pre-installed useful ML libraries and lets us install additional libraries <span class="No-Break">as required.</span></li>
				<li>Scheduling notebooks–Vertex AI Workbench lets us schedule notebook runs on an ad hoc and recurring basis. This functionality is quite useful in setting up and running large-scale experiments quickly. This feature is available through managed notebook instances. More information will be provided on this in the <span class="No-Break">coming sections.</span></li>
			</ul>
			<p>With this background, we can now start working with Jupyter Notebooks on Vertex AI Workbench. The next section provides basic guidelines for getting started with notebooks on <span class="No-Break">Vertex AI.</span></p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Getting started with Vertex AI Workbench</h2>
			<p>Go to the Google Cloud console and open <strong class="bold">Vertex AI</strong> from the products menu on the left pane or by using <a id="_idIndexMarker181"/>the search bar on the top. Inside Vertex AI, click on <strong class="bold">Workbench</strong>, and it will open a page very similar to the one shown in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.3</em>. More information on this is available in the official <span class="No-Break">documentation (</span><a href="https://cloud.google.com/vertex-ai/docs/workbench/introduction"><span class="No-Break">https://cloud.google.com/vertex-ai/docs/workbench/introduction</span></a><a href="https://cloud.google.com/vertex-ai/docs/workbench/introduction):"/><span class="No-Break">).</span></p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B17792_04_3.jpg" alt="Figure 4.3 – Vertex AI Workbench UI within the Google Cloud console" width="1273" height="576"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Vertex AI Workbench UI within the Google Cloud console</p>
			<p>As we can see, Vertex AI Workbench is basically Jupyter Notebook as a service with the flexibility of working with managed as well as user-managed notebooks. User-managed notebooks are suitable for use cases where we need a more customized environment with relatively higher control. Another good thing about user-managed notebooks is that we can choose <a id="_idIndexMarker182"/>a suitable Docker container based on our development needs; these notebooks also let us change the type/size of the instance later on with <span class="No-Break">a restart.</span></p>
			<p>To choose the best Jupyter Notebook option for a particular project, it’s important to know about the common differences between the two solutions. <em class="italic">Table 4.1</em> describes some common differences between fully managed and <span class="No-Break">user-managed notebooks:</span></p>
			<table id="table001-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Vertex </strong><span class="No-Break"><strong class="bold">AI-managed notebooks</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Vertex AI </strong><span class="No-Break"><strong class="bold">user-managed notebooks</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Google-managed environment with integrations and features that provide us with an end-to-end notebook-based production environment without setting up anything <span class="No-Break">by hand.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Heavily customizable VM instances (with prebuilt DL images) that are ideal for users who need a lot of control over <span class="No-Break">the environment.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Scaling up and down (for vCPUs and RAM) can be performed from within the notebook itself without needing to restart <span class="No-Break">the environment.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Changing the size/memory of an instance requires stopping the instance in the Workbench UI and restarting it <span class="No-Break">every time.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Managed notebooks let us browse data from <strong class="bold">Google Cloud Storage</strong> (<strong class="bold">GCS</strong>) and BigQuery without leaving the Jupyter environment (with GCS and <span class="No-Break">BigQuery integrations).</span></p>
						</td>
						<td class="No-Table-Style">
							<p>UI-level data browsing is not supported in user-managed notebooks. However, we can read the data using Python in a notebook cell and <span class="No-Break">view it.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Automated notebook runs are supported with one-time and recurring schedules. The executor runs scheduled tasks and saves results even when an instance is in a <span class="No-Break">shutdown state.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Automated runs are not yet supported in a <span class="No-Break">user-managed environment.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Less control over networking <span class="No-Break">and security.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Option to implement desired networking and security features and VPC service controls on a <span class="No-Break">per-need basis.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Not much control for a DL-based environment while setting <span class="No-Break">up notebooks.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>User-managed instances provide multiple DL VM options to choose from during <span class="No-Break">notebook creation.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.1 – Differences between managed and user-managed notebook instances</p>
			<p>Let’s create <a id="_idIndexMarker183"/>one user-managed notebook to check the <span class="No-Break">available options:</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B17792_04_4.jpg" alt="Figure 4.4 – Jupyter Notebook kernel configurations" width="1206" height="626"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Jupyter Notebook kernel configurations</p>
			<p>As we can see in the preceding screenshot, user-managed notebook instances come with several customized image options to choose from. Along with the support of tools such as TensorFlow Enterprise, PyTorch, JAX, and so on, it also lets us decide whether we want to work with GPUs (which can be changed later, of course, as per needs). These customized images come with all useful libraries pre-installed for the desired framework, plus provide the flexibility to install any third-party packages within <span class="No-Break">the instance.</span></p>
			<p>After choosing the appropriate image, we get more options to customize things such as notebook name, notebook <a id="_idIndexMarker184"/>region, operating system, environment, machine types, accelerators, and so on (see the <span class="No-Break">following screenshot):</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B17792_04_5.jpg" alt="Figure 4.5 – Configuring a new user-managed Jupyter Notebook" width="1116" height="1178"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Configuring a new user-managed Jupyter Notebook</p>
			<p>Once we click on the <strong class="bold">CREATE</strong> button, it can take a couple of minutes to create a notebook instance. Once it is ready, we can launch the Jupyter instance in a browser tab using the link provided inside Workbench (see <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.6</em>). We also get the option to stop the notebook <a id="_idIndexMarker185"/>for some time when we are not using it (to <span class="No-Break">reduce cost):</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B17792_04_6.jpg" alt="Figure 4.6 – A running Jupyter Notebook instance" width="1187" height="324"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – A running Jupyter Notebook instance</p>
			<p>This Jupyter instance can be accessed by all team members having access to Workbench, which helps in collaborating and sharing progress with other teammates. Once we click on <strong class="bold">OPEN JUPYTERLAB</strong>, it opens a familiar Jupyter environment in a new tab (see <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B17792_04_7.jpg" alt="Figure 4.7 – A user-managed JupyterLab instance in Vertex AI Workbench" width="1039" height="951"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – A user-managed JupyterLab instance in Vertex AI Workbench</p>
			<p>A <a id="_idIndexMarker186"/>Google-managed JupyterLab instance also looks very similar (see <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B17792_04_8.jpg" alt="Figure 4.8 – A Google-managed JupyterLab instance in Vertex AI Workbench" width="1210" height="1313"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – A Google-managed JupyterLab instance in Vertex AI Workbench</p>
			<p>Now that we <a id="_idIndexMarker187"/>can access the notebook instance in the browser, we can launch a new Jupyter Notebook or terminal and get started on the project. After providing sufficient permissions to the service account, many useful Google Cloud services such as BigQuery, GCS, Dataflow, and so on can be accessed from the Jupyter Notebook itself using SDKs. This makes Vertex AI Workbench a one-stop tool for every ML <span class="No-Break">development need.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">We should stop Vertex AI Workbench instances when we are not using them or don’t plan to use them for a long period of time. This will help prevent us from incurring costs from running them unnecessarily for a long period <span class="No-Break">of time.</span></p>
			<p>In the <a id="_idIndexMarker188"/>next sections, we will learn how to create notebooks using custom containers and how to schedule notebooks with Vertex <span class="No-Break">AI Workbench.</span></p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Custom containers for Vertex AI Workbench</h1>
			<p>Vertex AI Workbench gives us the flexibility of creating notebook instances based on a custom container as well. The main advantage of a custom container-based notebook is that it lets <a id="_idIndexMarker189"/>us customize the notebook environment based on our specific needs. Suppose we want to work with a new TensorFlow <a id="_idIndexMarker190"/>version (or any other library) that is currently not available as a predefined kernel. We can create a custom Docker container with the required version and launch a Workbench instance using this container. Custom containers are supported by both managed and <span class="No-Break">user-managed notebooks.</span></p>
			<p>Here is how to launch a user-managed notebook instance using a <span class="No-Break">custom container:</span></p>
			<ol>
				<li>The first step is to create a custom container based on the requirements. Most of the time, a derivative container (a container based on an existing DL container image) would be easy to set up. See the following example Dockerfile; here, we are first pulling an existing TensorFlow GPU image and then installing a new TensorFlow version from <span class="No-Break">the source:</span><pre class="source-code">
FROM gcr.io/deeplearning-platform-release/tf-gpu:latest
RUN pip install -y tensorflow</pre></li>				<li>Next, build and push the container image to <strong class="bold">Container Registry</strong>, such that it should be <a id="_idIndexMarker191"/>accessible to the <strong class="bold">Google Compute Engine</strong> (<strong class="bold">GCE</strong>) service account. See the following source to build and push the <span class="No-Break">container image:</span><pre class="source-code">
export PROJECT=$(gcloud config list project --format     "value(core.project)")
docker build . -f Dockerfile.example -t "gcr.io/${PROJECT}/tf-custom:latest"
docker push "gcr.io/${PROJECT}/tf-custom:latest"</pre><p class="list-inset">Note that <a id="_idIndexMarker192"/>the service account <a id="_idIndexMarker193"/>should be provided with sufficient permissions to build and push the image to the container registry, and the respective APIs should <span class="No-Break">be enabled.</span></p></li>				<li>Go to the <strong class="bold">User-managed notebooks</strong> page, click on the <strong class="bold">New Notebook</strong> button, and then select <strong class="bold">Customize</strong>. Provide a notebook name and select an appropriate <strong class="bold">Region</strong> and <span class="No-Break"><strong class="bold">Zone</strong></span><span class="No-Break"> value.</span></li>
				<li>In the <strong class="bold">Environment</strong> field, select <span class="No-Break"><strong class="bold">Custom Container</strong></span><span class="No-Break">.</span></li>
				<li>In the <strong class="bold">Docker Container Image</strong> field, enter the address of the custom image; in our case, it would look <span class="No-Break">like this:</span><pre class="source-code">
gcr.io/${PROJECT}/tf-custom:latest</pre></li>				<li>Make the remaining appropriate selections and click the <span class="No-Break"><strong class="bold">Create</strong></span><span class="No-Break"> button.</span></li>
			</ol>
			<p>We are all set now. While launching the notebook, we can select the custom container as a kernel and start working on the <span class="No-Break">custom environment.</span></p>
			<p>We can now successfully launch Vertex AI notebooks and also create custom container-based environments if required. In the next section, we will learn how to schedule notebook runs within <span class="No-Break">Vertex AI.</span></p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Scheduling notebooks in Vertex AI</h1>
			<p>Jupyter Notebook environments are great for doing some initial experiments. But when it comes to launching long-running jobs, multiple training trials with different input parameters (such as hyperparameter tuning jobs), or adding accelerators to training jobs, we usually copy our code into a Python file and launch experiments using custom Docker containers <a id="_idIndexMarker194"/>or managed pipelines such as Vertex AI pipelines. Considering this situation and to minimize the duplication of efforts, Vertex AI-managed notebook instances provide us with the functionality of scheduling notebooks on an ad hoc or recurring basis. This feature allows us to execute our scheduled notebook cell by cell on Vertex AI. It provides us with the flexibility to seamlessly scale our processing power and choose suitable hardware for the task. Additionally, we can pass different input parameters for <span class="No-Break">experimentation purposes.</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Configuring notebook executions</h2>
			<p>Let’s try to configure notebook executions to check the various options it provides. Imagine we are <a id="_idIndexMarker195"/>building a toy application that takes two parameters–<strong class="source-inline">user_name</strong> and <strong class="source-inline">frequency</strong>–and when executed, it prints the <strong class="source-inline">user_name</strong> parameter as many times as the <strong class="source-inline">frequency</strong> parameter. Now, let’s launch a managed notebook and create our application, <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B17792_04_9.jpg" alt="Figure 4.9 – A simple Python application within Jupyter Notebook" width="921" height="351"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – A simple Python application within Jupyter Notebook</p>
			<p>Next, put all the parameters into a single cell and click on the gear-like button at the top-right <a id="_idIndexMarker196"/>corner. Assign this cell with tag <em class="italic">parameters</em>. See the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B17792_04_10.jpg" alt="Figure 4.10 – Tagging parameters within a Jupyter Notebook cell" width="1204" height="292"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – Tagging parameters within a Jupyter Notebook cell</p>
			<p>Our toy application is now ready. Once you click on the <strong class="bold">Execute</strong> button from the toolbar, it provides us with the options for customizing machine type, accelerators, environment (which can be a custom Docker container), and execution type–one-time or recurring. See the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B17792_04_11.jpg" alt="Figure 4.11 – Configuring notebook execution for Python application" width="800" height="966"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Configuring notebook execution for Python application</p>
			<p>Next, let’s <a id="_idIndexMarker197"/>change the parameters for our one-time execution by clicking on the <strong class="bold">ADVANCED OPTIONS </strong>Here, we can provide key-value pairs for parameter names and values. Check the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B17792_04_12.jpg" alt="Figure 4.12 – Setting up parameters for one-time execution" width="743" height="940"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Setting up parameters for one-time execution</p>
			<p>Finally, click <a id="_idIndexMarker198"/>the <strong class="bold">SUBMIT</strong> button. It will then display the following <span class="No-Break">dialog box:</span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B17792_04_13.jpg" alt="Figure 4.13 – One-time execution scheduled" width="911" height="208"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – One-time execution scheduled</p>
			<p>We have <a id="_idIndexMarker199"/>now successfully scheduled our notebook run with custom parameters on Vertex AI. We can find it under the <strong class="bold">EXECUTIONS</strong> section in the Vertex <span class="No-Break">AI UI:</span></p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B17792_04_14.jpg" alt="Figure 4.14 – Checking the EXECUTIONS section for executed notebook instances" width="1204" height="338"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14 – Checking the EXECUTIONS section for executed notebook instances</p>
			<p>We can now check the results by clicking on <strong class="bold">VIEW RESULT</strong>. Check the following screenshot for how it overrides the <span class="No-Break">input parameters:</span></p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B17792_04_15.jpg" alt="Figure 4.15 – Checking the results of the execution" width="891" height="600"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15 – Checking the results of the execution</p>
			<p>Similarly, we can schedule large one-time or recurring experiments without moving our code out of the notebook and take advantage of the cloud <span class="No-Break">platform’s scalability.</span></p>
			<p>We just <a id="_idIndexMarker200"/>saw how easy it is to configure and schedule notebook runs within Vertex AI Workbench. This capability allows us to do seamless experiments while keeping our code in the notebook. This is also helpful in setting up recurring jobs in the <span class="No-Break">development environment.</span></p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Summary</h1>
			<p>In this chapter, we learned about Vertex AI Workbench, a managed platform for launching the Jupyter Notebook application on Google Cloud. We talked about the benefits of having notebooks in a cloud-based environment as compared to a local environment. Having Jupyter Notebook in the cloud makes it perfect for collaboration, scaling, adding security, and launching long-running jobs. We also discussed additional features of Vertex AI Workbench that are pretty useful while working on different aspects of ML <span class="No-Break">project development.</span></p>
			<p>After reading this chapter, we should be able to successfully deploy, manage, and use Jupyter Notebooks on the Vertex AI platform for our ML development needs. As we understand the difference between managed and user-managed notebook instances, we should be in good shape to choose the best solution for our development needs. We should also be able to create custom Docker container-based notebooks if required. Most importantly, we should now be able to schedule notebook runs for recurring as well as one-time execution based on the requirements. Notebook scheduling is also quite useful for launching multiple model training experiments in parallel with different input parameters. Now that we have a good background in Vertex AI Workbench, it will be easier for us to follow the code samples in the <span class="No-Break">upcoming chapters.</span></p>
		</div>
	</div>
</div>
</body></html>