<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Getting Started with Robot Operating System</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Started with Robot Operating System</h1>
                </header>
            
            <article>
                
<p>The main aim of this book is to teach you how to build an autonomous mobile robot from scratch. The robot will be programmed using ROS and its operations will be simulated using a simulator called Gazebo. You will also see the robot's mechanical design, circuit design, embedded programming, and high-level software programming using ROS in the upcoming chapters.</p>
<p>In this chapter, we will start with the basics of ROS, how to install it, how to write a basic application using ROS and Python, and the basics of Gazebo. This chapter will be the foundation of your autonomous robotics project. If you are already aware of the basics of ROS, and already have it installed on your system, you may skip this chapter. However, you can still go through this chapter later to refresh your memory as to the basics of ROS.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Introduction to ROS</li>
<li>Installing ROS Kinetic on Ubuntu 16.04.3</li>
<li>Introducing, installing, and testing Gazebo</li>
</ul>
<p>Let's start programming robots using Python and Robot Operating System (ROS).</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To get the complete code that is mentioned in this chapter, you can clone the following link:</p>
<p><a href="https://github.com/qboticslabs/learning_robotics_2nd_ed">https://github.com/qboticslabs/learning_robotics_2nd_ed</a></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction to ROS</h1>
                </header>
            
            <article>
                
<p><strong>ROS</strong> is a software framework used for creating robotic applications. The main aim of the ROS framework is to provide the capabilities that you can use to create powerful robotics applications that can be reused for other robots. ROS has a collection of software tools, libraries, and collection of packages that makes robot software development easy.</p>
<p>ROS is a complete open source project licensed under the BSD (<a href="https://opensource.org/licenses/BSD-3-Clause">https://opensource.org/licenses/BSD-3-Clause</a>) license. We can use it for research and commercial applications. Even though ROS stands for Robot Operating System, it is not a real operating system. Rather, it is a meta-operating system, which provides the features of a real operating system. Here are the major features that ROS provides:</p>
<ul>
<li><strong>Message passing interface</strong>: This is the core feature of ROS, and it enables interprocess communication. Using this message-passing capability, the ROS program can communicate with its linked systems and exchange data. We will learn more technical terms concerning the exchange of data between ROS programs/nodes in the coming sections and chapters.</li>
<li><strong>Hardware abstraction</strong>: ROS has a degree of abstraction that enables developers to create robot-agnostic applications. These kinds of application can be used with any robot; the developers need only worry about the underlying robot hardware.</li>
<li><strong>Package management</strong>: The ROS nodes are organized in packages called ROS packages. ROS packages consist of source codes, configuration files, build files, and so on. We create the package, build the package, and install the package. There is a build system in ROS that helps to build these packages. The package management in ROS makes ROS development more systematic and organized.</li>
<li><strong>Third-party library integration:</strong> The ROS framework is integrated with many third-party libraries, such as Open-CV, PCL, OpenNI, and so on. This helps developers to create all kinds of application in ROS.</li>
<li><strong>Low-level device control</strong>: When we work with robots, we may need to work with low-level devices, such as those that control I/O pins, sending data through serial ports, and so on. This can also be done using ROS.</li>
<li><strong>Distributed computing</strong>: The amount of computation required to process the data from robot sensors is very high. Using ROS, we can easily distribute the computation to a cluster of computing nodes. This distributes the computing power and allows you to process the data faster than you could using a single computer.</li>
<li><strong>Code reuse</strong>: The main goal of ROS is code reuse. Code reuse enables the growth of a good research and development community around the world. ROS executables are called nodes. These executables can be grouped into a single entity called a ROS package. A group of packages is called a meta package, and both packages and meta packages can be shared and distributed.</li>
<li><strong>Language independence</strong>: The ROS framework can be programmed using popular languages (such as Python, C++, and Lisp). The nodes can be written in any language and can communicate through ROS without any issues.</li>
<li><strong>Easy testing</strong>: ROS has a built-in unit/integration test framework called rostest to test ROS packages.</li>
<li><strong>Scaling</strong>: ROS can be scaled to perform complex computation in robots.</li>
<li><strong>Free and open source</strong>: The source code of ROS is open and it's absolutely free to use. The core part of ROS is licensed under a BSD license, and it can be reused in commercial and closed source products.</li>
</ul>
<p>ROS is a combination of plumbing (message passing), tools, capabilities, and ecosystem. There are powerful tools in ROS to debug and visualize the robot data. There are inbuilt robot capabilities in ROS, such as robot navigation, localization, mapping, manipulation, and so on. They help to create powerful robotics applications.</p>
<p>The following image shows the ROS equation:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/3a99e07a-d3a9-4346-b54e-a3c6395c6165.png" style="width:40.67em;height:7.83em;"/></div>
<div class="packt_figure">
<div class="CDPAlignCenter CDPAlign packt_figref">The ROS equation</div>
</div>
<div class="packt_infobox">Refer to <a href="http://wiki.ros.org/ROS/Introduction"><span class="URLPACKT">http://wiki.ros.org/ROS/Introduction</span></a> for more information on ROS.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">ROS concepts</h1>
                </header>
            
            <article>
                
<p>There are three main organizational levels in ROS:</p>
<ul>
<li>The ROS filesystem</li>
<li>The ROS computation graph</li>
<li>The ROS community</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The ROS filesystem</h1>
                </header>
            
            <article>
                
<p><span class="URLPACKT">The ROS filesystem mainly covers how ROS files are organized on the disk. The following are the main terms that we have to understand when working with the ROS filesystem:</span></p>
<ul>
<li><strong>Packages</strong>: ROS packages are the individual unit of the ROS software framework. A ROS package may contain source code, third-party libraries, configuration files, and so on. ROS packages can be reused and shared.</li>
<li><strong>Package manifests</strong>: The manifests (<kbd>package.xml</kbd>) file will have all the details of the packages, including the name, description, license, and, more importantly, the dependencies of the package.</li>
<li><strong>Message (msg) types</strong>: Message descriptions are stored in the <kbd>msg</kbd> folder in a package. ROS messages are data structures for sending data through ROS's message-passing system. Message definitions are stored in a file with the <kbd>.msg</kbd> extension.</li>
<li><strong>Service (srv) types</strong>: Service descriptions are stored in the <kbd>srv</kbd> folder with the <kbd>.srv</kbd> extension. The <kbd>srv</kbd> file defines the request and response data structure for the service in ROS.</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The ROS Computation Graph</h1>
                </header>
            
            <article>
                
<p>The ROS Computation Graph is the peer-to-peer network of ROS systems that processes data. The basic features of ROS Computation Graph are nodes, ROS Master, the parameter server, messages, and services:</p>
<ul>
<li><strong>Nodes</strong>: The ROS node is a process that uses ROS functionalities to process the data. A node basically computes. For example, a node can process the laser scanner data to check whether there is any collision. A ROS node is written with the help of an ROS client library (such as <kbd>roscpp</kbd> and <kbd>rospy</kbd><em>),</em> <em>which will be discussed in the upcoming section</em>.</li>
<li><strong>ROS Master</strong>: The ROS nodes can connect to each other using a program called ROS Master. This provides the name, registration, and lookup to the rest of the computation graph. Without starting the master, the nodes will not find each other and send messages.</li>
<li><strong>Parameter server</strong>: The ROS parameters are static values that are stored in a global location called the parameter server. From the parameter server, all the nodes can access these values. We can even set the scope of the parameter server as private or public so that it can access one node or access all nodes.</li>
<li><strong>ROS topics</strong>: The ROS nodes communicate with each other using a named bus called ROS topic. The data flows through the topic in the form of messages. The sending of messages over a topic is called publishing, and receiving the data through a topic is called subscribing.</li>
<li><strong>Messages</strong>: A ROS message is a data type that can consist of primitive data types, such as integers, floating points, and Booleans. The ROS messages flow through the ROS topic. A topic can only send/receive one type of message at a time. We can create our own message definition and send it through the topics.</li>
<li><strong>Services</strong>: We have seen that the publish/subscribe model using ROS topics is a very easy way of communicating. This communication method is a one-to-many mode of communication, meaning that a topic can be subscribed to by any number of nodes. In some cases, we may also require a request/reply kind of interaction, which is usually used in distributed systems. This kind of interaction can be done using ROS services. The ROS services work in a similar way to ROS topics in that they have a message type definition. Using that message definition, we can send the service request to another node that provides the service. The result of the service will be sent as a reply. The node has to wait until the result is received from the other node.</li>
<li><strong>Bags</strong>: These are formats in which to save and play back the ROS topics. ROS bags are an important tool to log the sensor data and the processed data. These bags can be used later for testing our algorithm offline.</li>
</ul>
<p>The following diagram shows how topics and services work between the nodes and the Master:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/d964ad3e-9445-41b6-823b-610fa20927aa.png" style="width:33.08em;height:20.75em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Communication between the ROS nodes and the ROS Master</div>
<p>In the preceding diagram, you can see two ROS nodes with the ROS Master in between them. One thing we have to remember is, before starting any nodes in ROS, you should start the ROS Master. The ROS Master acts like a mediator between nodes for exchanging information about other ROS nodes in order to establish communication. Say that Node 1 wants to publish a topic called <kbd>/xyz</kbd> with message type <kbd>abc</kbd>. It will first approach the ROS Master, and says <kbd>I am going to publish a topic called /xyz with message type abc and share its details</kbd>. When another node, say Node 2, wants to subscribe to the same topic of <kbd>/xyz</kbd> with the message type of <kbd>abc</kbd>, the Master will share the information about Node 1 and allocate a port to start communication between these two nodes directly without communicating with the ROS Master.</p>
<p>The ROS services works in the same way. The ROS Master is a kind of DNS server, which can share the node details when the second node requests a topic or service from the first node. The communication protocol ROS uses is TCPROS (<a href="http://wiki.ros.org/ROS/TCPROS">http://wiki.ros.org/ROS/TCPROS</a>), which basically uses TCP/IP sockets for the communication.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The ROS community level</h1>
                </header>
            
            <article>
                
<p>The ROS community consists of ROS developers and researchers who can create and maintain packages and exchange new information related to existing packages, newly released packages, and other news related to the ROS framework. The ROS community provides the following services:</p>
<ul>
<li><strong>Distributions</strong>: A ROS distribution has a set of packages that come with a specific version. The distribution that we are using in this book is ROS Kinetic. There are other versions available, such as ROS Lunar and Indigo, which has a specific version that we can install. It is easier to maintain the packages in each distribution. In most cases, the packages inside a distribution will be relatively stable.</li>
<li><strong>Repositories</strong>: The online repositories are the locations where we keep our packages. Normally, developers keep a set of similar packages called meta packages in a repository. We can also keep an individual package in a single repository. We can simply clone these repositories and build or reuse the packages.</li>
<li><strong>The ROS wiki</strong>: The ROS wiki is the place where almost all the documentation of ROS is available. You can learn about ROS, from its most basic concepts to the most advanced programming, using the ROS wiki <span class="URLPACKT">(<a href="http://wiki.ros.org">http://wiki.ros.org</a></span>).</li>
<li><strong>Mailing lists</strong>: If you want to get updates regarding ROS, you can subscribe to the ROS mailing list (<a href="http://lists.ros.org/mailman/listinfo/ros-users"><span class="URLPACKT">http://lists.ros.org/mailman/listinfo/ros-users</span></a>). You can also get the latest ROS news from ROS Discourse (<a href="https://discourse.ros.org"><span class="URLPACKT">https://discourse.ros.org</span></a>).</li>
<li><strong>ROS answers</strong>: This is very similar to the Stack Overflow website. You can ask questions related to ROS in this portal, and you might get support from developers across the world (<a href="https://answers.ros.org/questions/"><span class="URLPACKT">https://answers.ros.org/questions/</span></a>).</li>
</ul>
<p>There are many other features available in ROS; you can refer to the ROS official website at <span class="URLPACKT">www.ros.org</span> for more information. For now, we will move on to the installation procedure of ROS.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing ROS on Ubuntu</h1>
                </header>
            
            <article>
                
<p>As per our previous discussion, we know that ROS is a metaoperating system that is installed on a host system. ROS is completely supported on Ubuntu /Linux and in the experimental stages on Windows and OS X. Some of the latest ROS distributions are as follows:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>Distribution</p>
</td>
<td>
<p>Release date</p>
</td>
</tr>
<tr>
<td>
<p>ROS Melodic Morenia</p>
</td>
<td>
<p>May 23 2018</p>
</td>
</tr>
<tr>
<td>
<p>ROS Lunar Loggerhead</p>
</td>
<td>
<p>May 23 2017</p>
</td>
</tr>
<tr>
<td>
<p>ROS Kinetic Kame</p>
</td>
<td>
<p>May 23 2016</p>
</td>
</tr>
<tr>
<td>
<p>ROS Indigo Igloo</p>
</td>
<td>
<p>July 22 2014</p>
</td>
</tr>
</tbody>
</table>
<p>&#160;</p>
<p>We will now look at the installation procedure of the stable, long-term support (LTS) distribution of ROS called Kinetic on Ubuntu 16.04.3 LTS. ROS Kinetic Kame will be primarily targeted at Ubuntu 16.04 LTS. You can also find instructions to set up ROS in the latest LTS Melodic Morenia on Ubuntu 18.04 LTS after looking at the following instructions. If you are a Windows or OS X user, you can install Ubuntu in a VirtualBox application before installing ROS on it. The link to download VirtualBox is <a href="https://www.virtualbox.org/wiki/Downloads"><span class="URLPACKT">https://www.virtualbox.org/wiki/Downloads</span></a>.</p>
<p>You can find the complete instructions for doing this at <a href="http://wiki.ros.org/kinetic/Installation/Ubuntu">http://wiki.ros.org/kinetic/Installation/Ubuntu</a>.</p>
<p>The steps are as follows:</p>
<ol>
<li>Configure your Ubuntu repositories to allow <span class="packt_screen">restricted</span>, <span class="packt_screen">universe</span>, and <span class="packt_screen">multiverse</span> downloadable files. We can configure it using Ubuntu's <span class="packt_screen">Software &amp; Update</span> tool. We can get this tool by simply searching on the Ubuntu Unity search menu and ticking the shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/384d0cc9-fbb5-4f3d-aa60-58b4e9017233.png" style="width:42.50em;height:24.75em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Ubuntu's Software &amp; Update tool</div>
<ol start="2">
<li>Set up your system to accept ROS packages from <kbd><span class="URLPACKT">packages.ros.org</span></kbd>. ROS Kinetic is supported only on Ubuntu 15.10 and 16.04. The following command will store <kbd>packages.ros.org</kbd> in Ubuntu's <kbd>apt</kbd> repository list:</li>
</ol>
<pre style="padding-left: 60px">    <strong>$ sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list'</strong></pre>
<ol start="3">
<li>Next, we have to add apt-keys. An <kbd>apt-key</kbd> is used to manage the list of keys used by apt to authenticate the packages. Packages that have been authenticated using these keys will be considered trusted. The following command will add apt-keys for the ROS packages:</li>
</ol>
<pre style="padding-left: 60px">    <strong>sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116</strong>  </pre>
<ol start="4">
<li>After adding the apt-keys, we have to update the Ubuntu package list. The following command will add and update the ROS packages, along with the Ubuntu packages:</li>
</ol>
<pre>    <strong>$ sudo apt-get update</strong></pre>
<ol start="5">
<li>After updating the ROS packages, we can install the packages. The following command will install all the necessary packages, tools, and libraries of ROS:</li>
</ol>
<pre><strong>      <span class="URLPACKT">$ sudo apt-get install ros-kinetic-desktop-full</span></strong> </pre>
<ol start="6">
<li>We may need to install additional packages even after the desktop full installation. Each additional installation will be mentioned in the appropriate section. The desktop full install will take some time. After the installation of ROS, you will almost be done. The next step is to initialize <kbd>rosdep</kbd>, which enables you to easily install the system dependencies for ROS source packages:</li>
</ol>
<pre style="padding-left: 90px"><strong>$ sudo rosdep init    </strong><br/><strong>$ rosdep update  </strong></pre>
<ol start="7">
<li>To access ROS's tools and commands on the current bash shell, we can add ROS environmental variables to the <kbd>.bashrc</kbd> file. This will execute at the beginning of each bash session. The following is a command to add the ROS variable to <kbd>.bashrc</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    <strong>echo "source /opt/ros/kinetic/setup.bash" &gt;&gt; ~/.bashrc </strong>  </pre>
<p style="padding-left: 90px">The following command will execute the <kbd>.bashrc</kbd> script on the current shell to generate the change in the current shell:</p>
<pre style="padding-left: 60px">    <strong>source ~/.bashrc</strong>  </pre>
<ol start="8">
<li>A useful tool to install the dependency of a package is <kbd>rosinstall</kbd>. This tool has to be installed separately. It enables you to easily download many source trees for the ROS package with one command:</li>
</ol>
<pre style="padding-left: 60px">    <strong>$ sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential</strong>  </pre>
<div class="packt_infobox">The installation of the latest LTS Melodic is similar to the preceding instructions. You can install Melodic along with Ubuntu 18.04 LTS. You can find the complete instructions at <a href="http://wiki.ros.org/melodic/Installation/Ubuntu">http://wiki.ros.org/melodic/Installation/Ubuntu</a>.</div>
<p>After the installation of ROS, we will discuss how to create a sample package in ROS. Before creating the package, we have to create a ROS workspace. The packages are created in the ROS workspace. We will use the catkin build system, which is a set of tools that is used to build packages in ROS. The catkin build system generates an executable or shared library from the source code. ROS Kinetic uses the catkin build system to build packages. Let's look at what catkin is.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing catkin</h1>
                </header>
            
            <article>
                
<p><strong>Catkin</strong> is the official build system of ROS. Before catkin, ROS used the <strong>rosbuild</strong> system to build packages. Its replacement is catkin on the latest ROS version. Catkin combines CMake macros and Python scripts to provide the same normal workflow that CMake produces. Catkin provides better distribution of packages, better cross-compilation, and better portability than the rosbuild system. For more information, refer to <span class="URLPACKT">wiki.ros.org/catkin</span>.</p>
<p>Catkin workspace is a folder where you can modify, build, and install catkin packages.</p>
<p>Let's check how to create an ROS catkin workspace.</p>
<p>The following command will create a parent directory called <kbd>catkin_ws</kbd> and a subfolder called <kbd>src</kbd>:</p>
<pre>    <strong>$ mkdir -p ~/catkin_ws/src</strong>  </pre>
<p>Switch directory to the <kbd>src</kbd> folder using the following command. We will create our packages in the <kbd>src</kbd> folder:</p>
<pre>    <strong>$ cd ~/catkin_ws/src</strong>  </pre>
<p>Initialize the catkin workspace using the following command:</p>
<pre>    <strong>$ catkin_init_workspace</strong>  </pre>
<p>After you initialize the catkin workspace, you can simply build the package (even if there is no source file) using the following command:</p>
<pre>    <strong>$ cd ~/catkin_ws/</strong>
    <strong>$ catkin_make</strong>  </pre>
<p>The <kbd>catkin_make</kbd> command is used to build packages inside the <kbd>src</kbd> directory. After building the packages, we will see a <kbd>build</kbd> and <kbd>devel</kbd> folder in <kbd>catkin_ws</kbd> The executables are stored in the <kbd>build</kbd> folder. In the <kbd>devel</kbd> folder, there are shell script files to add the workspace on the ROS environment.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a ROS package</h1>
                </header>
            
            <article>
                
<p>In this section, we will look at how to create a sample package that contains two Python nodes. One of the nodes is used to publish a <span class="packt_screen">Hello World</span> string message on a topic called <kbd>/hello_pub</kbd> and the other node will subscribe to this topic.</p>
<p>A catkin ROS package can be created using the <kbd>catkin_create_pkg</kbd> command in ROS.</p>
<p>The package is created inside the <kbd>src</kbd> folder that we created during the creation of the workspace. Before creating the packages, switch to the <kbd>src</kbd> folder using the following command:</p>
<pre>    <strong>$ cd ~/catkin_ws/src</strong>  </pre>
<p>The following command will create a <kbd>hello_world</kbd> package with <kbd>std_msgs</kbd> dependencies, which contain standard message definitions. The <kbd>rospy</kbd> is the Python client library for ROS:</p>
<pre>    <strong>$ catkin_create_pkg hello_world std_msgs rospy</strong>  </pre>
<p>This is the message we get upon a successful creation:</p>
<pre>    <strong>Created file hello_world/package.xml </strong>
    <strong>Created file hello_world/CMakeLists.txt </strong>
    <strong>Created folder hello_world/src </strong>
    <strong>Successfully created files in /home/lentin/catkin_ws/src/hello_world. <br/> Please adjust the values in package.xml.</strong>  </pre>
<p>After the successful creation of the <kbd>hello_world</kbd> package, we need to add two Python nodes or scripts to demonstrate the subscribing and publishing of topics.</p>
<p>First, create a folder named <kbd>scripts</kbd> in the <kbd>hello_world</kbd> package using the following command:</p>
<pre>    <strong>$ mkdir scripts</strong>  </pre>
<p>Switch to the <kbd>scripts</kbd> folder and create a script named <kbd>hello_world_publisher.py</kbd> and another script called <kbd>hello_world_subscriber.py</kbd> to publish and subscribe to the <span class="packt_screen">hello world</span> message. The following section covers the code and function of these scripts or nodes:</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Hello_world_publisher.py</h1>
                </header>
            
            <article>
                
<p>The <kbd>hello_world_publisher.py</kbd> node basically publishes a greeting message called <span class="packt_screen">hello world</span> to a topic called <kbd>/hello_pub</kbd>. The greeting message is published to the topic at a rate of 10 Hz.</p>
<p>Here is a diagram that shows how the interaction between the two ROS nodes works:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/9a59240f-72a5-4062-94e5-bee52f248330.png" style="width:36.83em;height:25.58em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Communication between the publisher and subscriber node</div>
<div class="packt_infobox">The full code of this book is available at <a href="https://github.com/qboticslabs/learning_robotics_2nd_ed"><span class="URLPACKT">https://github.com/qboticslabs/learning_robotics_2nd_ed</span></a>.</div>
<p>The step-by-step explanation of how this code works is as follows:</p>
<ol>
<li>We need to import <kbd>rospy</kbd> if we are writing a ROS Python node. It contains Python APIs to interact with ROS topics, services, and so on.</li>
<li>To send the <span class="packt_screen">hello world</span> message, we have to import a <kbd>String</kbd> message data type from the <kbd>std_msgs</kbd> package. The <kbd>std_msgs</kbd> package has the message definition for standard data types. We can import using the following lines of code:</li>
</ol>
<pre>    <strong>#!/usr/bin/env python </strong>
    <strong>import rospy </strong>
    <strong>from std_msgs.msg import String </strong></pre>
<ol start="3">
<li>The following line of code creates a publisher object to a topic called <kbd>hello_pub</kbd>. The message type is <kbd>String</kbd> and the <kbd>queue_size</kbd> value is <kbd>10</kbd>. If the subscriber is not fast enough to receive the data, we can use the <kbd>queue_size</kbd> option to buffer it:</li>
</ol>
<pre style="padding-left: 60px">    <strong>def talker():</strong>
    <strong>    pub = rospy.Publisher('hello_pub', String, queue_size=10) </strong>  </pre>
<ol start="4">
<li>The following line of code initializes a ROS node. It will also assign a name to the node. If two nodes are running with the same node name, one will shut down. If we want to run both, use anonymous<kbd>=True</kbd> flag as shown in the following code:</li>
</ol>
<pre style="padding-left: 60px">    <strong>rospy.init_node('hello_world_publisher', anonymous=True)</strong>  </pre>
<ol start="5">
<li>The following line creates a rate object called <kbd>r</kbd>. Using a <kbd>sleep()</kbd> method in the <kbd>Rate</kbd> object, we can update the loop at the desired rate. Here, we are giving the rate the value of <kbd>10</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    <strong>r = rospy.Rate(10) # 10hz </strong>  </pre>
<ol start="6">
<li>The following loop will check whether <kbd>rospy</kbd> constructs the <kbd>rospy.is_shutdown()</kbd> flag. Then, it executes the loop. If we click on <em><span class="KeyPACKT">Ctrl</span></em> + <em><span class="KeyPACKT">C</span></em>, this loop will exit.</li>
</ol>
<p style="padding-left: 90px">Inside the loop, a <span class="packt_screen">hello world</span> message is printed on the Terminal and published on the <kbd>hello_pub</kbd> topic with a rate of 10 Hz:</p>
<pre style="padding-left: 60px">    while not rospy.is_shutdown():  
        str = "hello world %s"%rospy.get_time()  
        rospy.loginfo(str)  
        pub.publish(str)  
        r.sleep() </pre>
<ol start="7">
<li>The following code has Python _<kbd>_main__</kbd> check and calls the <kbd>talker()</kbd> function. The code will keep on executing the talker(), and when <span class="KeyPACKT">Ctrl</span> + <span class="KeyPACKT">C</span> is pressed the node will get shut down:</li>
</ol>
<pre style="padding-left: 60px">if __name__ == '__main__':  
    try:  
        talker()  
    except rospy.ROSInterruptException: pass </pre>
<p>After publishing the topic, we will see how to subscribe to it. The following section covers the code needed to subscribe to the <kbd>hello_pub</kbd> topic.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Hello_world_subscriber.py</h1>
                </header>
            
            <article>
                
<p>The subscriber code is as follows:</p>
<pre>#!/usr/bin/env python 
import rospy 
from std_msgs.msg import String </pre>
<p>The following code is a callback function that is executed when a message reaches the <kbd>hello_pub</kbd> topic. The <kbd>data</kbd> variable contains the message from the topic, and it will print using <kbd>rospy.loginfo()</kbd>:</p>
<pre>def callback(data): 
    rospy.loginfo(rospy.get_caller_id()+"I heard %s",data.data) 
 </pre>
<p>The following steps will start the node with a <kbd>hello_world_subscriber</kbd> name and start subscribing to the <kbd>/hello_pub</kbd> topic:</p>
<ol>
<li>The data type of the message is <kbd>String</kbd>, and when a message arrives on this topic, a method called callback will be called:</li>
</ol>
<pre style="padding-left: 60px">    def listener(): 
       rospy.init_node('hello_world_subscriber', <br/>          anonymous=True) 
       rospy.Subscriber("hello_pub", String, callback) </pre>
<ol start="2">
<li>The following code will keep your node from exiting until the node is shut down:</li>
</ol>
<pre>       rospy.spin() </pre>
<ol start="3">
<li>The following is the main section of the Python code. The main section will call the <kbd>listener()</kbd> method, which will subscribe to the <kbd>/hello_pub</kbd> topic:</li>
</ol>
<pre style="padding-left: 60px">if __name__ == '__main__': 
    listener() </pre>
<ol start="4">
<li>After saving two Python nodes, you need to change the permission to executable using the <kbd>chmod</kbd> commands:</li>
</ol>
<pre style="padding-left: 60px">    <strong>chmod +x hello_world_publisher.py</strong>
    <strong>chmod +x hello_world_subscriber.py</strong></pre>
<ol start="5">
<li>After changing the file permission, build the package using the <kbd>catkin_make</kbd> command:</li>
</ol>
<pre style="padding-left: 60px">    <strong>cd ~/catkin_ws</strong>
    <strong>catkin_make</strong></pre>
<ol start="6">
<li>The following command adds the current ROS workspace path in all terminals so that we can access the ROS packages inside this workspace:</li>
</ol>
<pre style="padding-left: 60px">    <strong>echo "source ~/catkin_ws/devel/setup.bash" &gt;&gt; ~/.bashrc</strong>
    <strong>source ~/.bashrc</strong>  </pre>
<p>The following is the output of the subscriber and publisher nodes:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/f021e994-89e3-4c64-a21f-9ad70db20cd1.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Output of the hello world node</div>
<ol>
<li>First, we need to run <kbd>roscore</kbd> before starting the nodes. The <kbd>roscore</kbd> command or ROS master is needed to communicate between nodes. So, the first command is as follows:</li>
</ol>
<pre style="padding-left: 60px">    <strong>$ roscore</strong></pre>
<ol start="2">
<li>After executing <kbd>roscore</kbd>, run each node using the following commands:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li>The following command will run the publisher:</li>
</ul>
</li>
</ul>
<pre style="padding-left: 120px">    <strong>$ rosrun hello_world hello_world_publisher.py</strong>  </pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>The following command will run the subscriber node. This node subscribes to the <kbd>hello_pub</kbd> topic, as shown in the following code:</li>
</ul>
</li>
</ul>
<pre style="padding-left: 120px">    <strong>$ rosrun hello_world hello_world_subscriber.py</strong>  </pre>
<p>We have covered some of the basics of ROS. Now, we will see what Gazebo is and how we can work with Gazebo using ROS.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing Gazebo</h1>
                </header>
            
            <article>
                
<p><strong>Gazebo</strong> is a free and open source robot simulator in which we can test our own algorithms, design robots, and test robots in different simulated environments. Gazebo can accurately and efficiently simulate complex robots in indoor and outdoor environments. Gazebo is built with a physics engine with which we can create high-quality graphics and rendering.</p>
<p>The features of Gazebo are as follows:</p>
<ul>
<li><strong>Dynamic simulation</strong>: Gazebo can simulate the dynamics of a robot using physics engines such as <strong>Open Dynamics Engine</strong> (<strong>ODE</strong>). (<a href="http://opende.sourceforge.net/"><span class="URLPACKT">http://opende.sourceforge.net/</span></a>), Bullet (<a href="http://bulletphysics.org/wordpress/"><span class="URLPACKT">http://bulletphysics.org/wordpress/</span></a>), Simbody (<a href="https://simtk.org/home/simbody/"><span class="URLPACKT">https://simtk.org/home/simbody/</span></a>), and DART (<a href="http://dartsim.github.io/"><span class="URLPACKT">http://dartsim.github.io/</span></a>).</li>
<li><strong>Advanced 3D graphics</strong>: Gazebo provides high-quality rendering, lighting, shadows, and texturing using the OGRE framework (<a href="http://www.ogre3d.org/"><span class="URLPACKT">http://www.ogre3d.org/</span></a>).</li>
<li><strong>Sensor support</strong>: Gazebo supports a wide range of sensors, including laser range finders, Kinect-style sensors, 2D/3D cameras, and so on. We can also use it to simulate noise to test audio sensors.</li>
<li><strong>Plugins</strong>: We can develop custom plugins for the robot, sensors, and environmental controls. Plugins can access Gazebo's API.</li>
<li><strong>Robot models</strong>: Gazebo provides models for popular robots, such as PR2, Pioneer 2 DX, iRobot Create, and TurtleBot. We can also build custom models of robots.</li>
<li><strong>TCP/IP transport</strong>: We can run simulations on a remote machine and a Gazebo interface through a socket-based message-passing service.</li>
<li><strong>Cloud simulation</strong>: We can run simulations on the cloud server using the CloudSim framework (<a href="http://cloudsim.io/"><span class="URLPACKT">http://cloudsim.io/</span></a>).</li>
<li><strong>Command-line tools</strong>: Extensive command-line tools are used to check and log simulations.</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Gazebo</h1>
                </header>
            
            <article>
                
<p>Gazebo can be installed as a standalone application or an integrated application along with ROS. In this chapter, we will use Gazebo along with ROS to simulation a robot's behavior and to test our written code using the ROS framework.</p>
<p>If you want to try the latest Gazebo simulator yourself, you can follow the steps given at <a href="http://gazebosim.org/download."><span class="URLPACKT">http://gazebosim.org/download</span></a>.<a href="http://gazebosim.org/download."></a></p>
<p>To work with Gazebo and ROS, we don't need to install them separately because Gazebo comes with the ROS desktop full installation.</p>
<p>The ROS package that integrates Gazebo with ROS is called <kbd>gazebo_ros_pkgs</kbd>. There are wrappers around the standalone Gazebo. This package provides the necessary interface to simulate a robot in Gazebo using ROS message services.</p>
<p>The complete <kbd>gazebo_ros_pkgs</kbd> can be installed in ROS Indigo using the following command:</p>
<pre>    <strong>$ sudo apt-get install ros-kinetic-gazebo-ros-pkgs ros-kinetic-<br/>   ros-control</strong>  </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing Gazebo with the ROS interface</h1>
                </header>
            
            <article>
                
<p>Assuming that the ROS environment is properly set up, we can start <kbd>roscore</kbd> before starting Gazebo using the following command:</p>
<pre>    <strong>$ roscore</strong>  </pre>
<p><span class="URLPACKT">The following command will run Gazebo using ROS:</span></p>
<pre>    <strong>$ rosrun gazebo_ros gazebo</strong>  </pre>
<p>Gazebo runs two executables-the Gazebo server and the Gazebo client. The Gazebo server will execute the simulation process and the Gazebo client can be the Gazebo GUI. Using the previous command, the Gazebo client and server will run in parallel.</p>
<p>The Gazebo GUI is shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/b6dfeeb9-3bbb-4f5c-9d3d-698aa123cb3e.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The Gazebo simulator</div>
<p>After starting Gazebo, the following topics will be generated:</p>
<pre>$ rostopic list  
/gazebo/link_states  
/gazebo/model_states  
/gazebo/parameter_descriptions  
/gazebo/parameter_updates  
/gazebo/set_link_state  
/gazebo/set_model_state  </pre>
<p>We can run the server and client separately using the following commands:</p>
<ul>
<li>Run the Gazebo server using the following command:</li>
</ul>
<pre>    <strong>$ rosrun gazebo_ros gzserver</strong>  </pre>
<ul>
<li>Run the Gazebo client using the following command:</li>
</ul>
<pre>    <strong>$ rosrun gazebo_ros gzclient</strong>  </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter was an introduction to Robot Operating System. The main goal of this chapter was to give you an overview of ROS, its features, how to install it, the basic concepts of ROS, and how to program it using Python. Along with this, we have looked at a robotics simulator called Gazebo, which can work with ROS. We have seen how to install and run Gazebo. In the next chapter, we will look at the basic concepts of differential drive robots.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the important features of ROS?</li>
<li>What are the different levels of concepts in ROS?</li>
<li>What is ROS catkin build system?</li>
<li>What are ROS topics and messages?</li>
<li>What are the different concepts of the ROS Computation Graph?</li>
<li>What is the main function of the ROS Master?</li>
<li>What are the important features of Gazebo?</li>
</ol>


            </article>

            
        </section>
    </div>
</body>
</html>