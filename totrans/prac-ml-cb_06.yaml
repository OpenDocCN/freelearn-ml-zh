- en: Chapter 6. Supervised Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Decision tree learning - Advance Health Directive for patients with chest pain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decision tree learning - income-based distribution of real estate values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decision tree learning - predicting the direction of stock movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naive Bayes - predicting the direction of stock movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random forest - currency trading strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support vector machine - currency trading strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stochastic gradient descent - adult income
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Decision tree learning**: Decision trees are very popular tools for classification
    and prediction problems. A decision tree is a classifier which recursively partitions
    the instance space or the variable set. Decision trees are represented as a tree
    structure where each node can be classified as either a leaf node or a decision
    node. A leaf node holds the value of the target attribute, while a decision node
    specifies the rule to be implemented on a single attribute-value. Each decision
    node splits the instance space into two or more sub-spaces according to a certain
    discrete function of the input attributes-values. Each test considers a single
    attribute, such that the instance space is partitioned according to the attribute''s
    value. In the case of numeric attributes, the condition refers to a range. After
    implementing the rule on the decision node, a sub-tree is an outcome. Each of
    the leaf nodes holds a probability vector indicating the probability of the target
    attribute having a certain value. Instances are classified by navigating them
    from the root of the tree down to a leaf, according to the outcome of the tests
    along the path.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key requirements to mine data with decision trees are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attribute-value description**: The object can be expressed as a fixed set
    of properties or attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Predefined classes**: The categories to which examples are to be assigned
    must be supervised data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sufficient data**: Use of multiple training cases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Naive Bayes**:The naive Bayes is a supervised learning method. It is a linear
    classifier. It is based on the Bayes'' theorem, which states that the presence
    of a particular feature of a class is unrelated to the presence of any other feature.
    It is a robust and efficient algorithm. Bayesian classifiers can predict class
    membership probabilities such as the probability that a given tuple belongs to
    a particular class. Bayesian belief networks is joint conditional probability
    distribution. It allows class-conditional independencies to be defined between
    subsets of variables. It provides a graphical model of a causal relationship on
    which learning can be performed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Random forest**: Random forests are collections of decision trees that provide
    predictions into the structure of data. They are a tool that pulls the power of
    multiple decision trees in judicious randomization, and ensemble learning to produce
    predictive models. They provide variable rankings, missing values, segmentations,
    and reporting for each record to ensure deep data understanding. After each tree
    is built, all the data is run down the tree. For each of the pairs of cases, vicinities
    are computed. If two cases occupy the same terminal node, their vicinities are
    increased by one. At the end of the run, normalization is carried out by dividing
    by the number of trees. Proximities are used in replacing missing data, locating
    outliers, and producing to reveal low-dimensional understandings of the data.
    The training data, which is out-of-bag data, is used to estimate classification
    error and to calculate the importance of variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Random forests run very efficiently on large databases, producing accurate results.
    They handle multiple variables without deletion, giving estimates of the importance
    of the variables to solve the classification problems. They generate an internal
    unbiased estimate of the generalization error as the forest building progresses.
    A random forest is an effective method for estimating missing data, and maintains
    accuracy when a large proportion of the data is missing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Support vector machines**: Machine learning algorithms use right set of features
    to solve learning problems. SVMs make use of a (nonlinear) mapping function φ
    which transforms data in the input space to data in the feature space in such
    a way as to render a problem linearly separable. The SVM then discovers the optimal
    separating hyperplane which is then mapped back into input space via φ-1\. Among
    the possible hyperplanes, we select the one where the distance of the hyperplane
    from the closest data points (the margin) is as large as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Decision tree learning - Advance Health Directive for patients with chest pain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Advance Health Directive document states the directions regarding the future
    health care for an individual on various medical conditions. It guides an individual
    to make the right decision in case of emergency or as required. The document helps
    an individual to understand the nature and consequences of their health care decisions,
    understand the nature and effect of the directive, freely and voluntarily make
    these decisions, and communicate the decisions in some way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform decision tree classification, we will be using a dataset
    collected from the heart patients dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dataset titled `Heart.csv` which is available in CSV format, will be used. The
    dataset is in standard format. There are 303 rows of data. There are 15 variables.
    The numeric variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Age`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RestBP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fbs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RestECG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaxHR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExAng`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Oldpeak`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slope`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ca`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The non-numeric variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ChestPain`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AHD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following packages need to be loaded as the first step to be carried out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.3.0 (2016-05-03).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the data and understand the relationships between the variables.
    We''ll begin by importing the CSV data file named `Heart.csv`. We will be saving
    the data to the `AHD_data` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the internal structure of the `AHD_data` data frame. The `str()`
    function displays the internal structure of the data frame. The `AHD_data` is
    passed as an R object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the `AHD_data` data frame. The `head()` function returns the first
    part of the `AHD_data` data frame. The `AHD_data` data frame is passed as an input
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_06_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the dimensions of the `AHD_data` data frame. The `dim()` function
    returns the dimensions of the `AHD_data` frame. The `AHD_data` data frame is passed
    as an input parameter. The result clearly states that there are 303 rows of data
    and 15 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - preparing the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data needs to be prepared for carrying out the model building and testing.
    Data is split into two parts--one for building the model and the other for testing
    the model which will be prepared.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `createDataPartition()` function is used for creating splits of the data.
    `AHD_data` is passed as an argument to the function. Random sampling takes place.
    The percentage of data that goes to training is denoted by `p`. Here, the value
    of `p` is `0.5`, which means that 50% of the data is used for the training. `List
    = ''FALSE''` avoids returning the data as a list. The result is then stored in
    the data frame split :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to the data frame `split` displays training set data for training
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing the data](img/image_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The training data will be created. The `split` data frame is used to create
    the training data. The `train` data frame is used to store the values of the training
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the training data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing the data](img/image_06_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The testing data will be created. The `split` data frame is used to create
    the testing data. The `-` sign before the `split` data frame denotes all those
    rows of data which have not been considered for training purposes. The test data
    frame is used to store the values of the testing data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the testing data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing the data](img/image_06_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - training the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The model will now be prepared and trained on the training dataset. Decision
    trees are used when datasets are divided into groups, as compared to investigating
    a numerical response and its relationship to a set of descriptor variables. The
    implementation of classification trees in R is carried out using the `tree()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tree()` function is used to implement classification trees. A tree is
    grown by binary recursive partitioning. The `AHD` field on the training dataset
    is used to form classification trees. The resulting data frame is stored in the
    `trees` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A graphical version of the trees data frame will be displayed. The `plot()`
    function is a generic function for the plotting of R objects. The trees data frame
    is passed as a function value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - training the model](img/image_06_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Find the deviance or number of misclassifications by running a cross-validation
    experiment. The `cv.tree()` function will be used. The `trees` data frame object
    is passed. `FUN=prune.misclass` obtains a nested sequence of subtrees of the supplied
    data frame trees by recursively snipping off the least important splits. The result
    is stored in the `cv.trees` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the results of data frame `cv.trees`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `$dev` field gives the deviance for each K.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - training the model](img/image_06_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the `plot()` function data frame, `cv.trees` is displayed. The `$dev`
    value is on the *y* axis (right side). The `$k` value is on the top. The `$size`
    value is on the *x* axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be clearly seen, when `$size = 1`, `$k = 30.000000`, `$dev = 1`. We
    plot the data frame using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - training the model](img/image_06_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5- improving the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us improve the model by splitting the tree with the lowest deviance. The
    `prune.misclass()` function is called to split the tree. `prune.misclass` obtains
    a nested sequence of subtrees of the supplied data frame trees by recursively
    snipping off the least important splits. The result is stored in the `prune.trees`
    data frame. `best=4` indicates the size (for example, the number of terminal nodes)
    of a specific subtree in the cost-complexity sequence that is to be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `plot()` function data frame, `prune.trees` is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5- improving the model](img/image_06_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Adding the text to the preceding pruned tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5- improving the model](img/image_06_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to predict the value based on a linear model object, we will use the
    `predict()` function. `prune.trees` is passed as an object. The `test` data object
    is passed as an object in which to look for variables with which to predict. The
    result will be stored in the `tree.pred` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the variable `test.pred` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5- improving the model](img/image_06_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Summarizing the results of the model. The `confusionMatrix()` calculates the
    cross-tabulation of the observed and predicted classes. `tree.pred` is passed
    as a factor of predicted classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5- improving the model](img/image_06_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Decision tree learning - income-based distribution of real estate values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Income has been an essential component of the attractive long-term total returns
    provided by real estate as an asset class. The annual income returns generated
    from investing in real estate have been more than 2.5 times higher than stocks
    and lagged bonds by only 50 basis points. Real estate often provides a steady
    source of income based on the rent paid by tenants.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform decision tree classification, we will be using a dataset
    collected from the real estate dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dataset titled `RealEstate.txt` will be used. This dataset is available
    in TXT format, titled `RealEstate.txt`. The dataset is in standard format. There
    are 20,640 rows of data. The 9 numerical variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MedianHouseValue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MedianIncome`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MedianHouseAge`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TotalRooms`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TotalBedrooms`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Population`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Households`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Latitude`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Longitude`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following package needs to be loaded as the first step to be carried out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.3.0 (2016-05-03).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the data and understand the relationships between the variables.
    We''ll begin by importing the TXT data file named `RealEstate.txt`. We will be
    saving the data to the `realEstate` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the dimensions of the `realEstate` data frame. The `dim()` function
    returns the dimensions of the `realEstate` frame. The `realEstate` data frame
    is passed as an input parameter. The result clearly states that there are 20,640
    rows of data and 9 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_06_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the internal structure of the `realEstate` data frame. The `str()`
    function displays the internal structure of the data frame. The `realEstate` is
    passed as an R object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_06_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the `realEstate` data frame. The `head()` function returns the first
    part of the `realEstate` data frame. The `realEstate` data frame is passed as
    an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_06_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the summary of the `realEstate` data frame. The `summary()` function
    is a multipurpose function. `summary()` is a generic function that provides a
    summary of the data related to the individual object or data frame. The `realEstate`
    data frame is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_06_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - training the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The model will now be prepared on the dataset. Decision trees are a tool for
    classification and prediction. They represent rules which can be understood by
    humans and used in knowledge systems such as a database. They classify instances
    by starting at the root of the tree and moving through it until they reach a leaf
    node. The node specifies a test on a single attribute, the leaf indicates the
    value of the target attribute, and the edge splits off one attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The `tree()` function is used to implement classification trees. A tree is grown
    by binary recursive partitioning. These models are computationally intensive techniques,
    since they recursively partition response variables into subsets based on their
    relationship to one or more predictor variables.
  prefs: []
  type: TYPE_NORMAL
- en: The formula expression is based on the sum of the variables `Latitude` and `Longitude`.
    The result of the sum is stored in the log value of `MedianHouseValue`. `data=realEstate`
    represents the data frame in which to preferentially interpret formula, weights,
    and subset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting data frame is stored in data frame `treeModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A summary of the `treeModel` will be displayed. The summary displays the formula
    used, along with the number of terminal nodes or leaves in the trees. The statistical
    distribution of the residuals is also displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The `summary()` function is used to display the statistical summary of `treeModel`.
    It is a generic that is used to produce the summaries of the results for various
    fitting functions. The data frame on which the summary is desired is `treeModel`,
    which is passed as an input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deviance here means the mean squared error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - training the model](img/image_06_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A graphical version of the `treeModel` data frame will be displayed. The `plot()`
    function is a generic function for plotting R objects. The `treeModel` data frame
    is passed as a function value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - training the model](img/image_06_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the graphical version of the `treeModel` data frame is displayed, text
    needs to be inserted to display the value at each node and the leaves. The `text()`
    function is used to insert strings given in the labels vector at the given coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - training the model](img/image_06_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - comparing the predictions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comparing the predictions with the dataset which reflect the global price trend.
    We wish to summarize the frequency distribution of `MedianHouseValue` for ease
    of reporting or comparison. The most direct method is to use quantiles. Quantiles
    are points in a distribution that relate to the rank order of values in that distribution.
    The quantiles will divide the `MedianHouseValue` distribution such that there
    is a given proportion of an observation below the quantile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `quantile()` function produces sample quantiles corresponding to the given
    probabilities. `realEstate$MedianHouseValue` is the numeric vector whose sample
    quantiles are wanted. The `quantile()` function returns `priceDecilesas` a vector
    of length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the value of the `priceDeciles` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - comparing the predictions](img/image_06_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, a summary of the `priceDeciles` will be displayed. The `summary()` function
    is used to display the statistical summary of the `priceDeciles`. The data frame
    for which the summary is desired is `priceDeciles`, which is passed as an input
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - comparing the predictions](img/image_06_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Dividing the `priceDeciles` vector into different ranges. The `cut()` function
    divides the range of intervals according to which interval they fall into. The
    numeric vector `MedianHouseValue` of the `realEstate` data frame is to be converted
    to a factor by cutting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `cutPrices` data frame. The `head()` function returns the first
    part of the `cutPrices` data frame. The `cutPrices` data frame is passed as an
    input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - comparing the predictions](img/image_06_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A summary of `cutPrices` will be displayed. The `summary()` function is used
    to display the statistical summary of the `treeModel`. The data frame on which
    the summary is desired is `cutPrices`, which is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - comparing the predictions](img/image_06_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting the value of the `cutPrices`. The `plot()` function is a generic function
    for the plotting of R objects. The `cutPrices` data frame is passed as a function
    value. The longitude variable of the `realEstate` dataset represents the *x* coordinates
    of points in the plot. The latitude variable of the `realEstate` dataset represents
    the *y* coordinates of points in the plot. `col=grey(10:2/11)` represents the
    plot color. `pch=20` represents the size of the symbol to be used as the default
    in plotting points. `xlab="Longitude"` represents the title for the x axis, while
    `ylab="Latitude"` represents the title for the *y* axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - comparing the predictions](img/image_06_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A summary of `Longitude` will be displayed. The `summary()` function is used
    to display the statistical summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - comparing the predictions](img/image_06_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the `Longitude` data frame. The `head()` function returns the first
    part of the `Longitude` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - comparing the predictions](img/image_06_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A summary of `Latitude` will be displayed. The `summary()` function is used
    to display the statistical summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - comparing the predictions](img/image_06_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the `Latitude` data frame. The `head()` function returns the first
    part of the `Latitude` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - comparing the predictions](img/image_06_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `partition.tree()` function is used to partition a tree where two or more
    variables are involved. `treeModel` is passed as a tree object. `ordvars=c("Longitude","Latitude")`
    indicates the ordering in which the variables are to be used to plot. Longitude
    represents the *x* axis, while `Latitude` represents the y axis. `add=TRUE` means
    adding to the existing plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - comparing the predictions](img/image_06_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 - improving the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The number of leaves in a tree controls the flexibility of the tree. The number
    of leaves indicates how many cells they partition the tree into. Each node has
    to contain a certain number of points, and adding a node has to reduce the error
    by at least a certain amount. The default value for `min.dev` is 0.01.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will reduce the value of `min.dev` to 0.001.
  prefs: []
  type: TYPE_NORMAL
- en: The `tree()` function is used to implement classification trees. The formula
    expression is based on the sum of the variables `Latitude` and `Longitude`. The
    result of the sum is stored in the log value of `MedianHouseValue`. `data=realEstate`
    represents the data frame in which to preferentially interpret formula, weights,
    and subset. The value for `min.dev` denotes the deviance that must be at least
    0.001 times of the root node for the node to be split.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting data frame is stored in the `treeModel2` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: A summary of the `treeModel2` will be displayed. The summary displays the formula
    used, along with the number of terminal nodes or the leaves in the trees. The
    statistical distribution of the residuals is also displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The `summary()` function is used to display the statistical summary of the `treeModel2`.
    The data frame on which the summary is desired is `treeModel2`, which is passed
    as an input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deviance here means the mean squared error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - improving the model](img/image_06_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When compared with the summary of `treeModel`, the value of leaves in `treeModel2`
    increases from 12 to 68\. The value of deviance changes from 0.1666 to 0.1052
    for `treeModel` and `treeModel2`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'A graphical version of the `treeModel2` data frame will be displayed. The `plot()`
    function is a generic function for plotting R objects. The `treeModel2` data frame
    is passed as a function value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - improving the model](img/image_06_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the graphical version of the `treeModel2` data frame is displayed, text
    needs to be inserted to display the value at each node and the leaves. The `text()`
    function is used to insert strings given in the vector labels at the given coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - improving the model](img/image_06_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Including all the variables in the formula extension.
  prefs: []
  type: TYPE_NORMAL
- en: The `tree()` function is used to implement classification trees. The formula
    expression is based on all the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting data frame is stored in the `treeModel3` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: A summary of `treeModel3` will be displayed. The summary displays the formula
    used along with the number of terminal nodes or the leaves in the trees. The statistical
    distribution of the residuals is also displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The `summary()` function is used to display the statistical summary of `treeModel3`.
    The data frame on which the summary is desired is `treeModel3`, which is passed
    as an input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deviance here means the mean squared error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - improving the model](img/image_06_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The formula clearly states that all the variables of the `realEstate` dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'A graphical version of `treeModel3` data frame will be displayed. The `plot()`
    function is a generic function for plotting R objects. The `treeModel3` data frame
    is passed as a function value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - improving the model](img/image_06_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After a graphical version of the `treeModel3` data frame is displayed, text
    needs to be inserted to display the value at each node and the leaves. The `text()`
    function is used to insert strings given in the vector labels at the given coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - improving the model](img/image_06_036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Decision tree learning - predicting the direction of stock movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stock trading is one of the most challenging problems statisticians are trying
    to solve. There are multiple technical indicators, such as trend direction, momentum
    or lack of momentum in the market, volatility for profit potential, and volume
    measures to monitor the popularity in the market, to name a few. These indicators
    can be used to create strategy to high-probability trading opportunities. Days/weeks/months
    can be spent discovering the relationships between technical indicators. An efficient
    and less time-consuming tool, such as a decision tree, can be used. The main advantage
    of a decision tree is that it is a powerful and easily interpretable algorithm,
    which gives a good head start.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform decision tree classification, we will be using a dataset
    collected from the stock markets dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dataset to be used is the Bank of America's daily closing stock value between
    1^(st) January, 2012 and 1^(st) January, 2014\. This dataset is freely available
    on [https://yahoo.com/](https://yahoo.com/), from where we will be downloading
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following package needs to be loaded as the first step to be carried out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.3.0 (2016-05-03).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the preceding libraries needs to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Let's download the data. We will begin by marking the start and end date for
    the time period in which the data is desired.
  prefs: []
  type: TYPE_NORMAL
- en: The `as.Date()` function is used to convert the character representation and
    objects of the `Date` class, which represents the calendar dates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The start date for the dataset is stored in `startDate`, which represents the
    character vector representation of the calendar date. The format for representation
    is *YYYY-MM-DD*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The end date for the dataset is stored in `endDate`, which represents the character
    vector representation of the calendar date. The format for representation is *YYYY-MM-DD*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the data using the `getSymbols()` function. The function loads data from
    multiple sources, either local or remote. Data is fetched and saved in the `env`
    specified. The default value is `.GlobalEnv` for `env`. `BAC` is the character
    vector that specifies the name of the symbol to be loaded. `src = yahoo` specifies
    the sourcing method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Step 3 - calculating the indicators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Relative Strength Index is calculated. It is a ratio of recent upward price
    movements to the absolute price movement. The `RSI()` function is used to calculate
    the Relative Strength Index. The `BAC` symbol is used as a price series. `n =
    3` represents the number of periods for moving averages. The result is then stored
    in the `relativeStrengthIndex3` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `relativeStrengthIndex3` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_06_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Calculating the moving averages. The **exponential moving average** is used
    for technical analysis and as a technical indicator. In a **simple moving average**,
    each value in the series carries equal weight. The values outside of the time
    series are not included in the average. However, the exponential moving average
    is a cumulative calculation, including all data. There is a diminishing value
    of the past data, while the more recent data values have greater contribution.
  prefs: []
  type: TYPE_NORMAL
- en: '`EMA()` uses the `BAC` symbol and is used as a price series. `n = 5` represents
    the time period to average over. The result is then stored in the `exponentialMovingAverage5`
    data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `exponentialMovingAverage5` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_06_038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the dimensions of the `exponentialMovingAverage5` data frame. The
    `dim()` function returns the dimensions of the `exponentialMovingAverage5` frame.
    The `exponentialMovingAverage5` data frame is passed as an input parameter. The
    result clearly states that there are 502 rows of data and 1 column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_06_039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the internal structure of the `exponentialMovingAverage5` data frame.
    The `str()` function displays the internal structure of the data frame. The `exponentialMovingAverage5`
    is passed as an R object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_06_040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Calculating the difference between the price and our calculated `exponentialMovingAverage5`,
    for example, the five-year exponential moving average values. The result is stored
    in the `exponentialMovingAverageDiff` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparing the fast-moving average of a BAC series with a slow-moving average
    of a BAC series. `BAC` is passed as the price matrix. `fast = 12` represents the
    periods for fast-moving average, `slow = 26` represents the periods for slow-moving
    average, `signal = 9` represents the signal for moving average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the MACD value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_06_041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the MACD data frame. The `head()` function returns the first part
    of the `MACD` data frame. The `MACD` data frame is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_06_042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Grabbing the signal line to use as an indicator. The result is stored in the
    `MACDsignal` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `MACDsignal` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_06_043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Determining the close to the midpoint of the high/low range. In order to determine
    the location of each day's close relative to the high/low range, a stochastic
    oscillator is used. The `SMI()` function is used for the momentum indicator.
  prefs: []
  type: TYPE_NORMAL
- en: '`BAC` is the matrix which contains high-low-close prices. `n = 13` indicates
    the number of periods. `slow=25` indicates the number of periods for double smoothing.
    `fast=2` indicates the number of periods for initial smoothing. `signal=9` indicates
    the number of periods for the signal line. The results are stored in the `stochasticOscillator`
    data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `stochasticOscillator` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_06_044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Grabbing the oscillator to use as an indicator. The result is stored in the `stochasticOscillatorSignal`
    data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `stochasticOscillatorSignal` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_06_045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - preparing variables to build datasets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Calculating the difference between the closing and opening prices. `Cl` stands
    for closing prices and `Op` for opening prices. The results are stored in the
    `PriceChange` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `PriceChange` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a binary classification variable. The `ifelse()` function uses a test
    expression to return the value, which is itself a vector, and is of the same length
    as the test expression. The vector returned has an element from `x` if the corresponding
    value of the `test` expression `is TRUE`, or from `y` if the corresponding value
    of `test` expression `is FALSE.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `PriceChange>0` is the test function, which is to be tested in a logical
    mode.`UP` and `DOWN` perform the logical test. The result is then stored in the `binaryClassification` data
    frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `binaryClassification` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the internal structure of the `binaryClassification` data frame.
    The `str()` function displays the internal structure of the data frame. `binaryClassification` is
    passed as an R object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the dataset to be used. The `data.frame()` function is used to create
    data frames based on a tightly coupled set of variables. These variables share
    the properties of matrices. The variables passed as parameters to `data.frame()`
    are `relativeStrengthIndex3`, `exponentialMovingAverageDiff`, `MACDsignal`, `stochasticOscillator`,
    and `binaryClassification`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is then stored in the `DataSet` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `DataSet` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the `DataSet` data frame. The `head()` function returns the first
    part of the `DataSet` data frame. The `DataSet` data frame is passed as an input
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the internal structure of the `DataSet` data frame. The `str()` function
    displays the internal structure of the data frame. The `DataSet` is passed as
    an R object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Naming the columns. The `c()` function is used to combine the arguments into
    vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variables passed as parameters to `c()` are `relativeStrengthIndex3`, `exponentialMovingAverageDiff`,
    `MACDsignal`, `stochasticOscillator`, and `binaryClassification`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `colnames(DataSet)` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Eliminating the data where the indicators are to be calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `DataSet` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the `DataSet` data frame. The `head()` function returns the first
    part of the `DataSet` data frame. The `DataSet` data frame is passed as an input
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the internal structure of the `DataSet` data frame. The `str()` function
    displays the internal structure of the data frame. The `DataSet` is passed as
    an R object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the dimensions of the `DataSet` data frame. The `dim()` function
    returns the dimensions of the `DataSet` frame. The `DataSet` data frame is passed
    as an input parameter. The result clearly states that there are 469 rows of data
    and 5 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_056.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building a training dataset. Two-thirds of the elements in the `DataSet` data
    frame will be used as a training dataset, while one-third of the elements in the
    `DataSet` data frame will be used as a testing dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The training dataset will be stored in `TrainingDataSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `TrainingDataSet` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the internal structure of the `TrainingDataSet` data frame. The `str()`
    function displays the internal structure of the data frame. The `TrainingDataSet`
    is passed as an R object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The training dataset will be stored in `TestDataSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `TestDataSet` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the internal structure of the `TestDataSet` data frame. The `str()`
    function displays the internal structure of the data frame. The `TestDataSet`
    is passed as an R object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 - building the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Building the tree model by specifying the indicators. The `rpart()` function
    will be used. It will fit the model. `binaryClassification` is the outcome, using
    the sum of `relativeStrengthIndex3`, `exponentialMovingAverageDiff`, `MACDsignal`,
    and `stochasticOscillator` as the predictors. `data=TrainingDataSet` represents
    the data frame. `cp=.001` represents the complexity parameter. The main role of
    the parameter is to save computing time by pruning off splits. The result is then
    stored in the `DecisionTree` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting the tree model. The `prp()` function will be used to plot the `DecisionTree`
    data frame. `type=2` shifts alternate nodes vertically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - building the model](img/B04714_06_61.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Displaying the `cp` table for the `DecisionTree` data frame. The `printcp()`
    function is used. `DecisionTree` is passed as an input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - building the model](img/image_06_062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting the geometric mean for trees. `plotcp()` function is used. It provides
    the visual representation of the cross-validation results of the `DecisionTree`
    data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - building the model](img/image_06_063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 6 - improving the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Improving the model after pruning the tree. `prune()` is the function used.
    `DecisionTree` is the data frame that is passed as an input. `cp=0.041428` has
    been taken, since this is the lowest cross-validation error value (x error):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting the `tree` model. The `prp()` function will be used to plot the `DecisionTree`
    data frame. `type=4` shifts alternate nodes vertically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving the model](img/image_06_064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Testing the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving the model](img/image_06_065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Naive Bayes - predicting the direction of stock movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stock trading is one of the most challenging problems statisticians are trying
    to solve. There are multiple technical indicators, such as trend direction, momentum
    or lack of momentum in the market, volatility for profit potential, and volume
    measures to monitor the popularity in the market, to name a few. These indicators
    can be used to create strategy to high-probability trading opportunities. Days/weeks/months
    can be spent discovering the relationships between technical indicators. An efficient
    and less time-consuming tool, such as a decision tree, can be used. The main advantage
    of a decision tree is that it is a powerful and easily interpretable algorithm,
    which gives a good head start.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform naive Bayes, we will be using a dataset collected from the
    stock markets dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dataset to be used is the Apple Inc. daily closing stock value between January
    1, 2012 and January 1, 2014\. This dataset is freely available on [https://www.yahoo.com/](https://www.yahoo.com/),
    from where we will be downloading the data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following packages need to be loaded as the first step to be carried out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.3.0 (2016-05-03)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the following libraries needs to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Let's download the data. We will begin by marking the start and end date for
    the time period in which the data is desired.
  prefs: []
  type: TYPE_NORMAL
- en: The `as.Date()` function is used to convert the character representation and
    objects of the *Date* class, which represents the calendar dates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The start date for the dataset is stored in `startDate`, which represents the
    character vector representation of the calendar date. The format for representation
    is *YYYY-MM-DD*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The end date for the dataset is stored in `endDate`, which represents the character
    vector representation of the calendar date. The format for representation is YYYY-MM-DD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Loading the data using the `getSymbols()` function. The function loads data
    from multiple sources, either local or remote. Data is fetched and saved in the
    `env` specified. The default value is `.GlobalEnv` for `env`. `AAPL` is the character
    vector, which specifies the name of the symbol to be loaded. `src = yahoo` specifies
    the sourcing method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '![Step 2 - exploring the data](img/image_06_066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the days of the week when data is available. The `wday()` function
    is used. The function returns the day of the week in decimal format. `AAPL` represents
    the data frame. `label = TRUE` displays the day of the week as a character string,
    for example, Sunday. The result is then stored in the `weekDays` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `weekDays` data frame. The `head()` function returns the first
    part of the `weekDays` data frame. The `weekDays` data frame is passed as an input
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_06_067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - preparing variables to build datasets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Calculating the difference between closing and opening prices. `Cl` stands
    for closing prices and `Op` for opening prices. The results are stored in the
    `changeInPrices` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `changeInPrices` data frame. The `head()` function returns the
    first part of the `changeInPrices` data frame. The `changeInPrices` data frame
    is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the summary of change in prices. The `summary()` function is used.
    The function provides a range of descriptive statistics to produce result summaries
    of the `changeInPrices` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the dimensions of the `changeInPrices` data frame. The `dim()` function
    returns the dimensions of the `changeInPrices` frame. The `changeInPrices` data
    frame is passed as an input parameter. The result clearly states that there are
    502 rows of data and 1 column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a binary classification variable. The `ifelse()` function uses a test
    expression to return the value, which is itself a vector, and is of the same length
    as the test expression. The vector returned has an element from `x` if the corresponding
    value of the test expression is `TRUE`, or from `y` if the corresponding value
    of the test expression is `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `changeInPrices>0` is the test function which is to test a logical mode. `UP`
    and `DOWN` perform the logical test. The result is then stored in the `binaryClassification` data
    frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `binaryClassification` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the summary of change in prices. The `summary()` function is used.
    The function provides a range of descriptive statistics to produce result summaries
    of the `binaryClassification` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the dataset to be used. The `data.frame()` function is used to create
    data frames based on a tightly coupled set of variables. These variables share
    the properties of matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variables passed as parameters to `data.frame()` are `weekDays` and  `binaryClassification`.
    The result is then stored in the `DataSet` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `AAPLDataSet` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the `AAPLDataSet` data frame. The `head()` function returns the first
    part of the `AAPLDataSet` data frame. The `AAPLDataSet` data frame is passed as
    an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_074.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the dimensions of the `AAPLDataSet` data frame. The `dim()` function
    returns the dimensions of the `AAPLDataSet` data frame. The `AAPLDataSet` data
    frame is passed as an input parameter. The result clearly states that there are
    502 rows of data and 2 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - building the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Building the naives Bayes classifier by specifying the indicators. The `naiveBayes()`
    function will be used. It uses the Bayes rule to compute posterior probabilities
    for a given set of class variables given independent predictor variables. The
    function assumes a Gaussian distribution of metric predictors. `NaiveBayesclassifier`
    is the outcome of the function, where the independent variable is `AAPLDataSet[,1]`
    and the dependent variable is `AAPLDataSet[,2]` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `NaiveBayesclassifier` result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - building the model](img/image_06_076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The result is over the entire dataset, and shows the probability of a price
    increase or decrease. It is bearish in nature.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 - creating data for a new, improved model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Developing a sophisticated strategy, looking ahead more than a day. Calculating
    moving average to the model for a period of 5 years. `EMA()` uses the AAPL symbol
    as a price series. `n = 5` represents the time period to average over. The result
    is then stored in the `exponentialMovingAverage5` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `exponentialMovingAverage5` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - creating data for a new, improved model](img/image_06_077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the summary of change in prices. The `summary()` function is used.
    The function provides a range of descriptive statistics to produce result summaries
    of the `exponentialMovingAverage5` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - creating data for a new, improved model](img/image_06_078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Calculating moving average to the model for a period of 10 years.
  prefs: []
  type: TYPE_NORMAL
- en: '`EMA()` uses the AAPL symbol as a price series. `n = 10` represents the time
    period to average over. The result is then stored in the `exponentialMovingAverage10`
    data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `exponentialMovingAverage10` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - creating data for a new, improved model](img/image_06_079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the summary of change in prices. The `summary()` function is used.
    The function provides a range of descriptive statistics to produce result summaries
    of the `exponentialMovingAverage10` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - creating data for a new, improved model](img/image_06_080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the dimensions of the `exponentialMovingAverage10` data frame. The
    `dim()` function returns the dimensions of the `exponentialMovingAverage10` frame.
    The `exponentialMovingAverage10` data frame is passed as an input parameter. The
    result clearly states that there are 502 rows of data and 1 column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - creating data for a new, improved model](img/image_06_081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Calculating the difference between `exponentialMovingAverage5` and `exponentialMovingAverage10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `exponentialMovingAverageDiff` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - creating data for a new, improved model](img/image_06_082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the summary of change in prices. The `summary()` function is used.
    The function provides a range of descriptive statistics to produce result summaries
    of the `exponentialMovingAverageDiff` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - creating data for a new, improved model](img/image_06_083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Rounding off the `exponentialMovingAverageDiff` data frame to two significant
    digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the summary of change in prices. The `summary()` function is used.
    The function provides a range of descriptive statistics to produce result summaries
    of the `exponentialMovingAverageDiffRound` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - creating data for a new, improved model](img/image_06_084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 6 - improving the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating the dataset to be used. The `data.frame()` function is used to create
    data frames based on a tightly coupled set of variables. These variables share
    the properties of matrices. The variables passed as parameters to `data.frame()`
    are `weekDays`, `exponentialMovingAverageDiffRound`, and `binaryClassification`.
    The result is then stored in the `AAPLDataSetNew` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `AAPLDataSetNew` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving the model](img/image_06_086.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the summary of change in prices. The `summary()` function is used.
    The function provides a range of descriptive statistics to produce result summaries
    of the `AAPLDataSetNew` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving the model](img/image_06_087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving the model](img/image_06_088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the summary of change in prices. The `summary()` function is used.
    The function provides a range of descriptive statistics to produce result summaries
    of the `AAPLDataSetNew` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving the model](img/image_06_089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the dimensions of the `AAPLDataSetNew` data frame. The `dim()` function
    returns the dimensions of the `AAPLDataSetNew` frame. The `AAPLDataSetNew` data
    frame is passed as an input parameter. The result clearly states that there are
    492 rows of data and 3 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving the model](img/image_06_090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building a training dataset. Two-thirds of the elements in the `AAPLDataSetNew`
    data frame will be used as the training dataset, while one-third of the elements
    in the `AAPLDataSetNew` data frame will be used as the testing dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The training dataset will be stored in the `trainingDataSet` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the dimensions of the `trainingDataSet` data frame. The `dim()` function
    returns the dimensions of the `trainingDataSet` data frame. The `trainingDataSet`
    data frame is passed as an input parameter. The result clearly states that there
    are 328 rows of data and 3 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving the model](img/image_06_091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the summary of change in prices. The `trainingDataSet()` function
    is used. The function provides a range of descriptive statistics to produce result
    summaries of the `trainingDataSet` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving the model](img/image_06_092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The training dataset will be stored in the `TestDataSet` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the dimensions of the `TestDataSet` data frame. The `dim()` function
    returns the dimensions of the `TestDataSet` frame. The `TestDataSet` data frame
    is passed as an input parameter. The result clearly states that there are 164
    rows of data and 3 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving the model](img/image_06_093.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving the model](img/image_06_094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building the naives Bayes classifier by specifying the indicators. The `naiveBayes()`
    function will be used. It uses the Bayes rule to compute posterior probabilities
    for a given set of class variables given independent predictor variables. The
    function assumes a Gaussian distribution of metric predictors.
  prefs: []
  type: TYPE_NORMAL
- en: '`exponentialMovingAverageDiffRoundModel` is the outcome of the function, where
    the independent variable is `trainingDataSet[,1:2]` and the dependent variable
    is `trainingDataSet[,3]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the `exponentialMovingAverageDiffRoundModel` result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving the model](img/image_06_095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Testing the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving the model](img/image_06_096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Random forest - currency trading strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of forecasting future price trends for forex markets can be scientifically
    achieved after carrying out technical analysis. Forex traders develop strategies
    based on multiple technical analyses such as market trend, volume, range, support
    and resistance levels, chart patterns and indicators, as well as conducting a
    multiple time frame analysis using different time-frame charts. Based on statistics
    of past market action, such as past prices and past volume, a technical analysis
    strategy is created for evaluating the assets. The main goal for analysis is not
    to measure an asset's underlying value but to calculate future performance of
    markets indicated by the historical performance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform random forest, we will be using a dataset collected from
    the US Dollar and GB Pound dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dataset titled `PoundDollar.csv` will be used. The dataset is in standard
    format. There are 5,257 rows of data and 6 variables. The numeric variables are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Open`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`High`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Low`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Close`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Volume`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following packages need to be loaded as the first step to be carried out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.3.0 (2016-05-03).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the following libraries needs to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explore the data and understand the relationships between the variables.
    We''ll begin by importing the CSV data file named `PoundDollar.csv`. We will be
    saving the data to the `PoundDollar` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `PoundDollar` data frame. The `head()` function returns the first
    part of the `PoundDollar` data frame. The `PoundDollar` data frame is passed as
    an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_06_097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the summary of the `PoundDollar` data frame. The `summary()` function
    is a multipurpose function. `summary()` is a generic function, which provides
    a summary of the data related to the individual object or data frame. The `PoundDollar`
    data frame is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_06_098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the dimensions of the `PoundDollar` data frame. The `dim()` function
    returns the dimensions of the `PoundDollar` frame. The `PoundDollar` data frame
    is passed as an input parameter. The result clearly states that there are 5,257
    rows of data and 7 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_06_099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - preparing variables to build datasets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Representing calendar dates and times. The `as.POSIXlt()` function manipulates
    the objects to represent date and time. `PoundDollar` is passed as an argument.
    `format="%m/%d/%y %H:%M` represents the date-time format. The results are stored
    in the `DateAndTime` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Capturing the `High`, `Low`, and `Close` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PoundDollar` data frame captures the `High`, `Low`, and `Close` values
    located in the fourth, fifth, and sixth columns. Printing the `HighLowClose` data
    frame. The `head()` function returns the first part of the `HighLowClose` data
    frame. The `HighLowClose` data frame is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the summary of the `HighLowClose` data frame. The `summary()` function
    is a multipurpose function. `summary()` is a generic function, which provides
    a summary of the data related to the individual object or data frame. The `HighLowClose`
    data frame is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the internal structure of the `HighLowClose` data frame. The `str()`
    function displays the internal structure of the data frame. The `HighLowClose`
    is passed as an R object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating the dataset to be used. The `data.frame()` function is used to create
    data frames based on a tightly coupled set of variables. These variables share
    the properties of matrices. The variable passed as parameter to `data.frame()`
    is `HighLowClose`. The result is then stored in the `HighLowClosets` data frame.
    `row.names=DateAndTime` represents a single integer string specifying a column
    to be used as row names. The result is stored in the `HighLowClose` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Describing the dataset. The `describe()` function provides the item analysis.
    `HighLowClosets` is passed as an input argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_103.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating time series objects. The `as.xts()` function is used. It converts
    the data objects of arbitrary classes to class `xts` without losing any attributes
    of the original format. `HighLowClosets` is passed as an input object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculating the Bollinger Bands. Bollinger Bands are range-bound indicators
    that calculate standard deviation from the moving average. Bollinger Bands operate
    under the logic that a currency pair''s price is most likely to gravitate toward
    its average, and hence when it strays too far, such as two standard deviations
    away, it is due to retrace back to its moving average. The `BBands()` function
    is used to calculate Bollinger Bands. `HighLowClosexts` is passed as an object
    that is changed to a matrix, which contains high-low-close prices. `n=20` indicates
    the number of periods for moving average. SMA names the function to be called.
    `sd=2` indicates two standard deviations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Describing the dataset. The `describe()` function provides item analysis. `BollingerBands`
    is passed as an input argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_104.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Building the upper band:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the summary of the `Upper` data frame. The `summary()` function is
    a multipurpose function. `summary()` is a generic function, which provides a summary
    of the data related to the individual object or data frame. The `Upper` data frame
    is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_105.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Building the lower band:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the summary of the `Lower` data frame. The `summary()` function is
    a multipurpose function. `summary()` is a generic function, which provides a summary
    of the data related to the individual object or data frame. The Lower data frame
    is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_106.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Building the middle band:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the summary of the `Middle` data frame. The `summary()` function is
    a multipurpose function. `summary()` is a generic function which provides a summary
    of the data related to the individual object or data frame. The `Middle` data
    frame is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_107.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Calculating the percentage change. The `Delt()` function is used to calculate
    the percentage change from one period to another of a given series. `k=1` indicates
    the change over the periods. The result is stored in the `PercentageChngpctB`
    data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Describing the dataset. The `describe()` function provides item analysis. `PercentageChngpctB`
    is passed as an input argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_108.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Calculating the percentage change of the `Upper` data frame. `k=1` indicates
    the change over the periods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'Describing the dataset. The `describe()` function provides item analysis. `PercentageChngUp`
    is passed as an input argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_109.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Calculating the percentage change of the `Lower` data frame. `k=1` indicates
    the change over the periods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Describing the dataset. The `describe()` function provides item analysis. `PercentageChngLow`
    is passed as an input argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_110.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Calculating the percentage change of the `Middle` data frame. `k=1` indicates
    the change over the periods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Describing the dataset. The `describe()` function provides item analysis. `PercentageChngMid` is
    passed as an input argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing variables to build datasets](img/image_06_111.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Calculating the percentage change of the `HighLowClosexts$Close` variable.
    `k=1` indicates the change over the periods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 - building the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a binary classification variable. The `ifelse()` function uses a test
    expression to return the value, which is itself a vector, and is of the same length
    as the test expression. The vector returned has an element from `x` if the corresponding
    value of the test expression is `TRUE`, or from `y` if the corresponding value
    of the test expression is `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `Returns>0` is the test function, which is to be tested in a logical
    mode. `UP` and `DOWN` perform the logical test. The result is then stored in the `binaryClassification` data
    frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the summary of change in prices. The `summary()` function is used.
    The function provides a range of descriptive statistics to produce result summaries
    of the `binaryClassification` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - building the model](img/image_06_112.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Shifting class back one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Combining all the features. The `data.frame()` function is used to create data
    frames based on a tightly coupled set of variables. These variables share the
    properties of matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variables passed as parameters to `data.frame()` are `Upper`, `Lower` , 
    `Middle`, `BollingerBands$pctB`, `PercentageChngpctB`, `PercentageChngUp`, `PercentageChngLow`,
    and `PercentageChngMid`. The result is then stored in the `FeaturesCombined` data
    frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the summary of change in prices. The `summary()` function is used.
    The function provides a range of descriptive statistics to produce result summaries
    of the `FeaturesCombined` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - building the model](img/image_06_113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Matching the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining the `FeaturesShifted` and `ClassShifted` data frames. The variables
    passed as parameters to `data.frame()` are `FeaturesShifted` and `ClassShifted`.
    The result is then stored in the `FeaturesClassData` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the summary of change in prices. The `summary()` function is used.
    The function provides a range of descriptive statistics to produce result summaries
    of the `FeaturesClassData` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - building the model](img/image_06_114.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Calculated indicators being removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Naming the columns. The `c()` function is used to combine the arguments into
    vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the internal structure of the `FinalModelData` data frame. The `str()`
    function displays the internal structure of the data frame. The `FinalModelData`
    is passed as an R object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - building the model](img/image_06_115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Setting initial random variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Evaluating the features (columns 1 to 9) using the class (column 9) to find
    the optimal number of features per tree. `FinalModelData[,-9]` indicates the data
    frame of predictor variables, and `FinalModelData[,9]` indicates the data frame
    of response variables. `ntreeTry=100` indicates the number of trees used at the
    tuning step. `stepFactor=1.5` indicates each iteration; `mtry` is inflated (or
    deflated) by this value, and `improve=0.01` means the (relative) improvement in
    out-of-bag error must be by this much for the search to continue. `trace=TRUE`
    indicates whether to print the progress of the search. `dobest=FALSE` means whether
    to run a forest using the optimal `mtry` found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'Using all the features to predict the class, with two features per tree. The
    `randomForest()` function is used. `data=FinalModelData` indicates the data frame
    containing the variables in the model. `mtry=2` indicates the number of variables
    randomly sampled as candidates at each split. `ntree=2000` indicates the number
    of trees to grow. `keep.forest=TRUE` indicates that the forest will be retained
    in the output object. `importance=TRUE` indicates the importance of predictors
    to be assessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - building the model](img/image_06_116.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting the random forest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - building the model](img/image_06_117.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Support vector machine - currency trading strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The forex market is an international trading market where the currencies of
    every country are sold and bought freely. The price of one currency determined
    only by market participants is driven by supply and demand. The trading is conducted
    through individual contracts. The standard contract size (also called a lot) is
    usually 100,000 units. This means that for every standard contract acquired, the
    control is of 100,000 units of the base currency. For this contract size, each
    pip (the smallest price increment) is worth $10\. Depending on the trading strategy
    of a trader, a position can be maintained for a very short time or for longer
    periods, even years. There are several tools that allow the trader to be able
    to understand and make decisions on the market, grouped basically under fundamental
    or technical analysis. Fundamental analysis takes into account the constant exchange
    of political and economic information. Technical analysis is based essentially
    on prices, time, and volume--the lowest and highest prices that a currency has
    reached, time of period, number of transactions performed, and so on. Technical
    analysis also assumes the repetitiveness of the market, which it most probably
    will perform again in the future as it has already performed in the past. It analyzes
    past quotes and predicts the prices to come based on statistical and mathematical
    calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform Support Vector Machine, we will be using a dataset collected
    from the US Dollar and GB Pound dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dataset titled `PoundDollar.csv` will be used. The dataset is in standard
    format. There are 5,257 rows of data and 6 variables. The numeric variables are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Open`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`High`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Low`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Close`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Volume`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following packages need to be loaded as the first step to be carried out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.3.0 (2016-05-03).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the following libraries needs to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explore the data and understand the relationships between the variables.
    We''ll begin by importing the CSV data file named `PoundDollar.csv`. We will be
    saving the data to the `PoundDollar` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `PoundDollar` data frame. The `head()` function returns the first
    part of the `PoundDollar` data frame. The `PoundDollar` data frame is passed as
    an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_06_118.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the internal structure of the `PoundDollar` data frame. The `str()`
    function displays the internal structure of the data frame. The `PoundDollar`
    is passed as an R object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_06_119.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - calculating the indicators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Relative Strength Index is calculated. It is a ratio of recent upward price
    movements to absolute price movement. The `RSI()` function is used to calculate
    the Relative Strength Index. The `PoundDollar` data frame is used as a price series.
    `n = 3` represents the number of the period for moving averages. The result is
    then stored in the `relativeStrengthIndex3` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the summary of change in prices. The `summary()` function is used.
    The function provides a range of descriptive statistics to produce result summaries
    of the `relativeStrengthIndex3` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_06_120.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Calculating **moving averages** (**MA**) of the `PoundDollar` series. `SMA`
    calculates the arithmetic mean of the series over the past set of observations.
    `n=50` indicates the number of periods to average over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the summary of the `SeriesMeanAvg50` data frame. The `summary()` function
    is a multipurpose function. `summary()` is a generic function, which provides
    a summary of the data related to the individual object or data frame. The `SeriesMeanAvg50`
    data frame is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_06_121.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Describing the dataset. The `describe()` function provides the item analysis.
    `SeriesMeanAvg50` is passed as an input argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_06_122.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Measuring the trend. Finding the difference between opening price and the 50-period
    simple moving average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the summary of the `SeriesMeanAvg50` data frame. The `Trend` data
    frame is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_06_123.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Calculating the price difference between closing and opening prices. The result
    is stored in the data frame `PriceDiff`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the summary of the `PriceDiff` data frame. The `Trend` data frame
    is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_06_124.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - preparing variables to build datasets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a binary classification variable. The `ifelse()` function uses a test
    expression to return the value, which is itself a vector and is of the same length
    as the test expression. The vector returned has an element from `x` if the corresponding
    value of the test expression is `TRUE`, or from `y` if the corresponding value
    of the test expression is `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `PriceChange>0` is the test function, which is to be tested in a logical
    mode. `UP` and `DOWN` perform the logical test. The result is then stored in the
    `binaryClassification` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the summary of the `binaryClassification` data frame. The `Trend`
    data frame is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_125.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Combining the relative `StrengthIndex3`, `Trend`, and `binaryClassification`
    data frames. The variables passed as parameters to `data.frame()` are `relativeStrengthIndex3`,
    `Trend`, and `binaryClassification`. The result is then stored in the `DataSet` data
    frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the summary of the `DataSet` data frame. The `Trend` data frame is
    passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_126.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the internal structure of the `DataSet` data frame. The `str()` function
    displays the internal structure of the data frame. The `DataSet` is passed as
    an R object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_127.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Calculating the indicators, creating a dataset, and removing the points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the dimensions of the `DataSet` data frame. The `dim()` function
    returns the dimensions of the `DataSet` frame. The `DataSet` data frame is passed
    as an input parameter. The result clearly states that there are 5,208 rows of
    data and 3 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_128.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Separating the training dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the dimensions of the `TrainingDataSet` data frame. The `dim()` function
    returns the dimensions of the `TrainingDataSet` frame. The `TrainingDataSet` data
    frame is passed as an input parameter. The result clearly states that there are
    4,528 rows of data and 3 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_129.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the summary of the `TrainingDataSet` data frame. The `TrainingDataSet`
    data frame is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_130.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Separating the testing dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the dimensions of the `TestDataSet` data frame. The `dim()` function
    returns the dimensions of the `TestDataSet` frame. The `TestDataSet` data frame
    is passed as an input parameter. The result clearly states that there are 1,510
    rows of data and 3 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '![Step 4 - preparing variables to build datasets](img/image_06_131.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the summary of the `TestDataSet` data frame. The `TestDataSet` data
    frame is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing variables to build datasets](img/image_06_132.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 - building the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Building support vector machines using the `svm()` function. `binaryClassification~relativeStrengthIndex3+Trend`
    is used as the formula. `data=TrainingDataSet` is used as a data frame which contains
    the variables of the model. `kernel="radial"` means that the radial basis kernel
    function is used in training and predicting. `cost=1` indicates the cost of constraints
    violation. `gamma=1/2` indicates the parameter needed for all kernel functions
    except linear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the summary of the `SVM` data frame. The `SVM` data frame is passed
    as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - building the model](img/image_06_133.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to predict the value based on the model object, we will use the `predict()`
    function. `SVM` is passed as an object. The `TrainingDataSet` data object is passed
    as an object in which to look for variables with which to predict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the summary of the `TrainingPredictions` data frame. The `SVM` data
    frame is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - building the model](img/image_06_134.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Describing the dataset. The `describe()` function provides item analysis. `TrainingPredictions`
    is passed as an input argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - building the model](img/image_06_135.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Combining the `TrainingDataSet` and `TrainingPredictions` data frames. The
    variables passed as parameters to `data.frame()` are `TrainingDataSet` and `TrainingPredictions`.
    The result is then stored in the `TrainingDatadata` frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the summary of the `TrainingData` data frame. The `TrainingData` data
    frame is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - building the model](img/image_06_136.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the `TrainingData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - building the model](img/image_06_137.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Stochastic gradient descent - adult income
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Stochastic gradient descent** also known as **incremental** gradient descent,
    is a stochastic approximation of the gradient descent optimization method for
    minimizing an objective function that is written as a sum of differentiable functions.
    It tries to find minima or maxima by iteration. In stochastic gradient descent,
    the true gradient of *Q(w)* is approximated by a gradient at a single example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stochastic gradient descent - adult income](img/B04714_06_new.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the algorithm sweeps through the training set, it performs the above update
    for each training example. Several passes can be made over the training set until
    the algorithm converges. If this is done, the data can be shuffled for each pass
    to prevent cycles. Typical implementations may use an adaptive learning rate so
    that the algorithm converges.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform stochastic gradient descent, we will be using a dataset
    collected from census data to predict income.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dataset titled `adult.txt` will be used. The dataset is in standard format.
    There are 32,561 rows of data and 15 variables. The numeric variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`age`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fnlwgt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`education-num`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`capital-gain`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`capital-loss`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hours-per-week`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The non-numeric variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`workclass`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`education`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`marital-status`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`occupation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`relationship`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`race`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`native-country`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`incomerange`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each of the following libraries is required to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.3.0 (2016-05-03).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the data and understand the relationships between the variables.
    We''ll begin by importing the TXT data file named `adult.txt`. We will be saving
    the data to the labels data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the internal structure of the `allData` data frame. The `str()` function
    displays the internal structure of the data frame. `allData` is passed as an R
    object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_06_138.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - preparing the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Grabbing the labels from the main file. The `as.factor()` function is used
    to encode the `allData[,15]` vector as a factor. This is to ensure format compatibility.
    The result is then stored in the `labels` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'Grabbing all the features of the data after removing the labels. The result
    is stored in the `allFeatures` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `allFeatures` data frame. The `head()` function returns the first
    part of the `allFeatures` data frame. The `allFeatures` data frame is passed as
    an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing the data](img/image_06_139.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Normalizing the features. The mean and scale are converted to `z` scores so
    that the `variance = 1`. `scale()` function''s default method centers and/or scales
    the columns of a numeric matrix. `continuousFeatures` is the numeric matrix. The
    result is then stored in the `continuousFeatures` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `continuousFeatures` data frame. The `head()` function returns
    the first part of the `continuousFeatures` data frame. The `continuousFeatures`
    data frame is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing the data](img/image_06_140.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Converting labels into a `1` or `-1`. The `rep()` function is used to replicate
    values. The result is then stored in the `labels.n` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'Separating training datasets. The `createDataPartition()` function creates
    a set of training data partitions. `y=labels` indicates the vector for outcomes.
    `p=.8` means 80% of the data is used for training datasets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the dimensions of the `trainingData` data frame. The `dim()` function
    returns the dimensions of the `trainingData` frame. The `trainingData` data frame
    is passed as an input parameter. The result clearly states that there are 26,049
    rows of data and a single column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing the data](img/image_06_141.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating training features and training labels of the `trainingData` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 'Figuring out the remaining 20% of data for testing and validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Creating the testing features and testing labels of the `trainingData` data
    frame. Of the 20% data, 50% of that data is used for testing purposes, while the
    remaining 50% is used for validation purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `createDataPartition()` function creates a set of training data partitions.
    `y= remainingLabels` indicates the vector for outcomes. `p=.5` means 50% of the
    data is used for training datasets. The result is then stored in the `testingData` data
    frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating validation features and testing labels of the `testingData` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining the accuracy measure required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 - building the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Setting up the initial parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining a set of arguments. The result is stored in the `lambda_vals` data
    frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the internal structure of the `lambda_vals` data frame. The `str()`
    function displays the internal structure of the data frame. The `lambda_vals`
    is passed as an R object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - building the model](img/image_06_142.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating a matrix for each epoch from a given set of values. The `matrix()`
    function is used. `nrow = (numStepsPerEpoch/nStepsPerPlot)*numEpochs+1` denotes
    the number of rows of the matrix, and `ncol = length(lambda_vals)` denotes the
    number of columns of the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a matrix for accuracy on a validation set from a given set of values.
    The `matrix()` function is used. `nrow = (numStepsPerEpoch/nStepsPerPlot)*numEpochs+1`
    denotes the number of rows of the matrix, and `ncol = length(lambda_vals)` denotes
    the number of columns of the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting up the classifier model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#createDataPartition()` function creates a set of training data partitions.
    `y= trainingLabels` indicates the vector for outcomes. `p = (1 - evalidationSetSize/length(trainingLabels))` %
    of data is used for training datasets. The result is then stored in the `etrainingData` data
    frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'Logging in the accuracy. `getAccuracy()` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculating the accuracy of the model. `getAccuracy()`, as defined previously,
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Step 5 - plotting the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Plotting the accuracy of the model during training. The `c()` function is used
    to combine the arguments into vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the vectors to be used in the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a generic vector. `list()` is called, which concatenates the `accMat`
    and `accMatv` data frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'The `# plot()` function is a generic function for plotting R objects. The `stepValues`
    data frame is passed as a function value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting graph will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_06_143.jpg)'
  prefs: []
  type: TYPE_IMG
