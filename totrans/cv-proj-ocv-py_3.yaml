- en: Reading License Plates with OpenCV
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenCV读取车牌
- en: This chapter provides an overview of how to extract and display license plate
    characters in any sample photo with a license plate in it. OpenCV and its plate
    utility functions help us find the characters on a license plate, and give us
    a good taste of how computer vision and image processing work.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了如何从任何包含车牌的样本照片中提取和显示车牌字符。OpenCV及其车牌实用函数帮助我们找到车牌上的字符，并让我们对计算机视觉和图像处理的工作有良好的了解。
- en: 'In this chapter, we will learn about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: The steps needed to read license plates
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取车牌所需的步骤
- en: Plate utility functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 车牌实用函数
- en: Finding plate characters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找车牌字符
- en: Finding and reading license plates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找和读取车牌
- en: Identifying the license plate
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别车牌
- en: In this project, we are going to detect and read license plates in photos of
    cars. We will be performing multiple steps, from locating the license plate to
    displaying the characters in the located license plate.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将检测和读取汽车照片中的车牌。我们将执行多个步骤，从定位车牌到显示定位车牌中的字符。
- en: 'Let''s refer to the code in Jupyter Notebook needed to analyze our sample images:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们参考Jupyter Notebook中分析我们的样本图像所需的代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We get the following photo when we run the code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码后，我们得到以下照片：
- en: '![](img/fcf031dc-bfee-453c-8480-c869cd11721f.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fcf031dc-bfee-453c-8480-c869cd11721f.png)'
- en: We have a photo of a car, with its license plate clearly visible and readable.
    The challenge is to locate the license plate, isolate it from the rest of the
    photo, and extract the characters from it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一张汽车的照片，车牌清晰可见且可读。挑战在于定位车牌，将其从照片的其余部分中分离出来，并从中提取字符。
- en: 'We can now take a closer look at the license plate using the available utility
    functions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更仔细地查看车牌，使用可用的实用函数：
- en: '![](img/f8b01357-ab91-49a4-898d-bdaab043cde7.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8b01357-ab91-49a4-898d-bdaab043cde7.png)'
- en: 'There are many algorithms that can help us carry out both these tasks. For
    example, object detectors such as YOLO: Real-Time Object Detection can do a very
    good job using the relevant machine learning methods for performing such tasks.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多算法可以帮助我们完成这两项任务。例如，YOLO：实时目标检测等对象检测器可以使用相关的机器学习方法执行此类任务，并做得非常好。
- en: However, we will be looking at a straightforward approach, using conventional
    image processing and computer vision techniques, instead of complex machine learning
    techniques such as deep learning and TensorFlow.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将采用一种简单的方法，使用传统的图像处理和计算机视觉技术，而不是复杂的机器学习技术，如深度学习和TensorFlow。
- en: The algorithm we will be using will help us learn computer vision and image
    processing techniques, giving us a better understanding of the project. Let's
    start with our code and check the plate utility functions we will be using.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的算法将帮助我们学习计算机视觉和图像处理技术，从而更好地理解项目。让我们从我们的代码开始，检查我们将使用的车牌实用函数。
- en: Plate utility functions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 车牌实用函数
- en: Let's jump to our code in Jupyter Notebook, in order to understand plate utility
    functions. We will first embed the imports with our utilities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳转到Jupyter Notebook中的代码，以便了解车牌实用函数。我们首先将导入我们的实用工具。
- en: 'We will be importing the following libraries:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入以下库：
- en: OpenCV (version 3.4)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV（版本3.4）
- en: NumPy
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy
- en: Pickle, which lets us save Python data and case functions
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pickle，它允许我们保存Python数据和案例函数
- en: 'Import the libraries as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式导入库：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will be using these libraries to load the k-nearest neighbors classifier
    for reading characters, which implicitly depends on scikit-learn.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些库来加载用于读取字符的k最近邻分类器，这隐式地依赖于scikit-learn。
- en: We will now discuss the utilities that will be used in our code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论我们代码中将使用的实用工具。
- en: The gray_thresh_img function and morphological functions
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灰度阈值图像函数和形态学函数
- en: The `gray_thresh_img` function takes an input image and converts it to grayscale.
    We need the image in grayscale, as color images may cause ambiguity, given that
    the color of license plates differs depending on the area. The `gray_thres_img`
    function gives us a binarized image.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`gray_thresh_img` 函数接受一个输入图像并将其转换为灰度。我们需要灰度图像，因为彩色图像可能会引起歧义，因为车牌的颜色会根据地区而有所不同。`gray_thres_img`
    函数为我们提供了一个二值化图像。'
- en: We can use morphological operations for pre-processing, as this will help us
    reduce noise and gaps. This will de-noise our image and remove extraneous features.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用形态学操作进行预处理，因为这有助于我们减少噪声和间隙。这将去除图像中的噪声并移除多余的特征。
- en: Kernels
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核
- en: A kernel is a three-by-three square on which we will be using `tophat`, `blackhat`,
    and `graytop` operations to create a grayscale image. This will also help us to
    de-noise the image—noise is usually present in natural images, and is not preferable
    for computer vision. The image can also be de-noised using Gaussian blur.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 内核是一个三乘三的正方形，我们将在这个正方形上使用`tophat`、`blackhat`和`graytop`操作来创建灰度图像。这也有助于我们去除图像噪声——噪声通常存在于自然图像中，对于计算机视觉来说并不理想。图像也可以使用高斯模糊进行去噪。
- en: We will use adaptive thresholding, which looks at local statistics and averages
    in an image to check whether it is bright or dim relative to its neighborhood.
    This is preferred over hard thresholding, as it will binarize our images in a
    better way.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用自适应阈值，它检查图像中的局部统计和平均值，以确定它相对于其邻域是亮还是暗。与硬阈值相比，这是更好的选择，因为它将以更好的方式二值化我们的图像。
- en: 'We use the `return` function to get the gray image and binarized image, as
    follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`return`函数来获取灰度图像和二值化图像，如下所示：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The matching character function
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配字符函数
- en: 'Let''s look at our next function to get the matching characters:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一个函数来获取匹配的字符：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `getmatchingchars` function helps us find our character candidate based
    on the following criteria:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`getmatchingchars`函数帮助我们根据以下标准找到我们的字符候选：'
- en: Size
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小
- en: Relative distance
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对距离
- en: Angle
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角度
- en: Area
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面积
- en: If the potential character is a reasonable distance from its neighbors, the
    angle is not too large compared to the JSON characters, and the area is not too
    big, we say that the possible character is a *character candidate*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果潜在的字符与其邻居的距离合理，角度与JSON字符相比不是太大，面积也不是太大，那么我们可以说可能的字符是一个*字符候选*。
- en: 'The following code will return a list of characters that are part of a license
    plate, and then create a container class that will contain objects such as the
    width, height, center, diagonal distance or hypotenuse, and aspect ratio of the
    character sub-images within our complete image:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将返回一个包含车牌字符的列表，然后创建一个容器类，该类将包含对象，如字符子图像的宽度、高度、中心、对角距离或斜边，以及宽高比：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The k-nearest neighbors digit classifier
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: k-最近邻数字分类器
- en: 'The pre-trained scikit-learn **k-nearest neighbors** (**k-nn**) digit classifier
    also needs to be loaded, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 预训练的scikit-learn **k-最近邻**（**k-nn**）数字分类器也需要加载，如下所示：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The k-nn classifier compares a small image to a series of images already known
    to it, to find the closest match.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: k-nn分类器将一个小图像与它已知的一系列图像进行比较，以找到最接近的匹配。
- en: We are not using complex algorithms for this, because characters in a license
    plate are similar. This is why we can use the k-nn method, which will make a pixel-by-pixel
    comparison to find the closest match. The characters on a license plate are not
    handwritten digits where the font might differ, which would need more computation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个例子中并没有使用复杂的算法，因为车牌上的字符是相似的。这就是为什么我们可以使用k-nn方法，它将进行像素级的比较以找到最接近的匹配。车牌上的字符不是手写的数字，字体可能不同，这需要更多的计算。
- en: In the classifier, `p` stands for Pickle, which is how Python stores data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在分类器中，`p`代表Pickle，这是Python存储数据的方式。
- en: Finding plate characters
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找车牌字符
- en: Next, we carry out our initial search to find plate characters. First, we find
    characters roughly, and then find candidates based on specific criteria.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行初始搜索以找到车牌字符。首先，我们找到大致的字符，然后根据特定标准找到候选者。
- en: 'Let''s start with the following line in our Notebook:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Notebook中的以下行开始：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now execute our function cell for imports, utilities, and to load our
    libraries:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以执行我们的函数单元，用于导入、工具和加载我们的库：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can now load our input image, which will be used for analysis. We use the
    `plt` function here instead of OpenCV, as OpenCV by default loads images in **blue
    green red** (**BGR**) format rather than **red green blue** (**RGB**) format.
    This is important for your custom projects, but it does not matter for our project
    since we will be converting the image to grayscale.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以加载我们的输入图像，它将被用于分析。在这里我们使用`plt`函数而不是OpenCV，因为OpenCV默认以**蓝绿红**（**BGR**）格式而不是**红绿蓝**（**RGB**）格式加载图像。这对于你的自定义项目很重要，但对我们项目来说并不重要，因为我们将会将图像转换为灰度。
- en: 'Let''s load our image:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载我们的图像：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the output photo:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出照片：
- en: '![](img/644c259c-32e2-4af2-bb38-54331f147e32.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/644c259c-32e2-4af2-bb38-54331f147e32.png)'
- en: 'Let''s take a closer look at the license plate of this car:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这辆车的车牌：
- en: '![](img/baf74a28-f1b2-4e53-af3b-cad48e8a11ce.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/baf74a28-f1b2-4e53-af3b-cad48e8a11ce.png)'
- en: We will find the characters from this image. However, we first need to remove
    the background, which is not important for us. Here, we need to carry out initial
    pre-processing on the image, using the `gray_thresh_img`, `blurred`, and `morphology`
    functions, which will help us get rid of the background.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这张图像中找到字符。然而，我们首先需要移除背景，这对我们来说并不重要。在这里，我们需要对图像进行初始预处理，使用 `gray_thresh_img`、`blurred`
    和 `morphology` 函数，这将帮助我们去除背景。
- en: 'Here is the code for the initial pre-processing:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是初始预处理的代码：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s look at our main code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的主要代码：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will give the image shape, which is going to return the height, width, and
    RGB depth of the photo. We don't need RGB depth right now, so we will extract
    only `2` elements; height and width. Since we will be working on grayscale images
    and not colored ones, we'll call our handy `gray_thresh_img` function, which will
    return the gray and binarized thresholded image.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将给出图像形状，这将返回照片的高度、宽度和 RGB 深度。我们现在不需要 RGB 深度，所以我们只提取 `2` 个元素；高度和宽度。由于我们将处理灰度图像而不是彩色图像，我们将调用我们方便的
    `gray_thresh_img` 函数，该函数将返回灰度和二值化的阈值图像。
- en: To find the contours, we need sub-images within the image that correspond to
    the character and then correspond to contours. We will use the `findContours`
    built-in algorithm from OpenCV to find details of complex shapes such as contours
    that could possibly be characters and work as our k-nn. We will then initialize
    our `char_cands` and `plate_candidates` variables.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到轮廓，我们需要图像中的子图像，这些子图像对应于字符，然后对应于轮廓。我们将使用 OpenCV 的内置算法 `findContours` 来找到可能作为字符和作为我们的
    k-nn 使用的复杂形状的轮廓细节。然后我们将初始化我们的 `char_cands` 和 `plate_candidates` 变量。
- en: 'Let''s take our first pass at finding the characters:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试第一次寻找字符：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will be using the characters to find the license plate, which is a different
    approach to other machine learning algorithms. This approach will help us understand
    the process of finding characters better.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用字符来寻找车牌，这是一种与其他机器学习算法不同的方法。这种方法将帮助我们更好地理解寻找字符的过程。
- en: We will iterate over all the contours and use the `charclass` class (which we
    have already defined). This automatically extracts centers, diagonal length, and
    aspect ratio to determine whether the image is too big or too small, or if the
    aspect ratio is too skewed From this, we can infer that the character is not a
    letter or number that will be on the license plate. This helps us consider only
    contours that meet the geometric criteria.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遍历所有轮廓，并使用我们已定义的 `charclass` 类（`charclass` 类）。这个类会自动提取中心、对角线长度和宽高比，以确定图像是否过大或过小，或者宽高比是否过于倾斜。从这个推断中，我们可以得出结论，该字符不是车牌上的字母或数字。这有助于我们仅考虑符合几何标准的轮廓。
- en: Finding matches and groups of characters
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找匹配的字符和字符组
- en: 'Once the first pass is done, we will refine our matches to find a group of
    characters that potentially could belong to a license plate. Refer to the following
    code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦第一次遍历完成，我们将细化我们的匹配，以找到可能属于车牌的一组字符。参考以下代码：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will iterate over all the potential characters by calling the `getmatchingchars`
    function we used before, which provides additional filtering based on the criteria.
    It depends on the angles, trigonometry, width, and height compared to neighboring
    characters, and also on the kind of neighbors. These criteria help us achieve
    uniformity.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过调用之前使用的 `getmatchingchars` 函数遍历所有潜在的字符，该函数根据标准提供额外的过滤。它取决于与相邻字符的角、三角学、宽度和高度的比较，以及邻居的类型。这些标准帮助我们实现一致性。
- en: Once we have our plate candidates, we can create a `blank` object. So, we have
    a `blank` object with no attributes and create a list of them. We first sort from
    the center of those characters, which will help us sort from leftmost to rightmost
    going through the matches.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了车牌候选者，我们可以创建一个 `blank` 对象。因此，我们有一个没有任何属性的 `blank` 对象，并创建了一个列表。我们首先按字符的中心排序，这将帮助我们按从左到右的顺序通过匹配进行排序。
- en: The `sum_char_h` summation will help us find the average height and width of
    the characters.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum_char_h` 的求和将帮助我们找到字符的平均高度和宽度。'
- en: 'Let''s look at the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The ideal position of the license plate is perpendicular to the camera. If the
    license plate is at an angle greater than a particular acceptable angle, or upside
    down, there is a possibility that we will not be able to read the license plate.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 车牌的理想位置是垂直于摄像头的。如果车牌的角度大于特定的可接受角度，或者颠倒，那么我们可能无法读取车牌。
- en: We find our `x` and `y` from the code, and correct the angle for the license
    plate if it is within a reasonable angle.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从代码中找到`x`和`y`，并校正车牌的角度，如果它在合理的角度范围内。
- en: 'We then figure out the plate location, and store it for computation later using
    `rotationMatrix`. We can do this in one step, based on the angle that we found
    here. We want to rotate it about the center of the plate, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们根据这里找到的角度确定车牌位置，并使用`rotationMatrix`将其存储起来，以便稍后进行计算。我们可以一步完成，因为我们已经找到了这个角度。我们希望围绕车牌的中心旋转，如下所示：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We create our rotated image here, and the `cv2.wrapAffine` function will help
    us with stretching, skewing, rotating, and translation, as well as higher-order
    transformations such as scaling, stretching, and rotating:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建旋转后的图像，`cv2.wrapAffine`函数将帮助我们进行拉伸、倾斜、旋转和平移，以及更高阶的变换，如缩放、拉伸和旋转：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once we have our sub-image, which is rotated and centered around plate candidates,
    we save it to our plate candidates list, which we initiated earlier. We now have
    our characters and our initial guess for our plate candidates, using which we
    are ready to find and read our license plate candidates.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了旋转并围绕车牌候选中心对齐的子图像，我们就将其保存到我们之前初始化的车牌候选列表中。现在我们有了字符和车牌候选的初始猜测，利用这些我们可以找到并读取车牌候选。
- en: Finding and reading license plates with OpenCV
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenCV查找和读取车牌
- en: We have already found our characters, which are license plate candidates. Now
    we need to determine which characters match, so that we can extract the text data
    and map the characters within the license plates.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经找到了字符，它们是车牌候选。现在我们需要确定哪些字符匹配，以便我们可以提取文本数据并将字符映射到车牌中。
- en: First, we run each plate candidate through our `gray_thresh_img` function, which
    does our de-noising and binarization. In this case, we get a cleaner output because
    we are using a sub-image and not the complete image.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们运行每个车牌候选通过我们的`gray_thresh_img`函数，该函数执行我们的去噪和二值化。在这种情况下，我们得到更干净的输出，因为我们使用的是子图像而不是完整图像。
- en: 'This is the extraction code we will use:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要使用的提取代码：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will need our characters to be of the same size, since we will be using the
    k-nn approach, which is case-sensitive. If the size differs, we will receive garbage
    values. After we have the images sized, we need to perform thresholding, for which
    we will use the `OTSU` method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要字符具有相同的大小，因为我们将会使用k-nn方法，它是区分大小写的。如果大小不同，我们将收到垃圾值。在将图像调整到大小后，我们需要进行阈值处理，我们将使用`OTSU`方法。
- en: 'We then need to find contours within our sub-image, and do a sanity check to
    make sure that the contours we found within our sub-image meet certain criteria
    where the size and aspect ratio are reasonable, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在子图像中找到轮廓，并进行合理性检查，以确保我们找到的子图像中的轮廓满足某些标准，其中大小和宽高比是合理的，如下所示：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the contours do not meet the criteria, it means that we are either not looking
    at a license plate or not getting good characters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果轮廓不符合标准，这意味着我们可能没有看到车牌，或者没有得到好的字符。
- en: 'Once the sanity check is complete, we run our `getmatchingchars` function,
    which will ensure we get a good group of characters that are roughly of the same
    size:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成合理性检查，我们就运行`getmatchingchars`函数，这将确保我们得到一组大小大致相同的良好字符：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a redundancy check, but is necessary for achieving clean and reliable
    results. We iterate over all the characters from left to right, in order, to check
    that the characters are sufficiently far apart. We do this because, conceivably,
    near contours that overlap each other could be characters that overlap, which
    would never happen in a real license plate.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个冗余检查，但对于获得干净和可靠的结果是必要的。我们按顺序从左到右迭代所有字符，以检查字符是否足够远。我们这样做是因为，理论上，重叠的轮廓可能是重叠的字符，这在现实中的车牌中是不会发生的。
- en: 'We need to make sure that the characters are far apart, as we''re not detecting
    the same thing over and over again; we are doing multiple `for` loops here and
    comparing characters to each other as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保字符之间距离足够远，因为我们不是在重复检测相同的东西；在这里我们执行多个`for`循环，并将字符相互比较，如下所示：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We need to make sure that everything is centered within our region of interest,
    so that characters are not lost when we perform actions such as scaling, rotation,
    and translation while we find our k-nn.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保所有内容都在感兴趣的区域中心，这样在执行缩放、旋转和平移等操作时，字符就不会丢失，因为我们正在寻找k-nn。
- en: 'In this code, we go through each character in our character list and each thresholded
    region, to make sure we resize the region to `20` by `30`, which matches our k-nn
    prediction:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们遍历我们的字符列表中的每个字符和每个阈值区域，以确保我们将区域调整到`20`乘以`30`，这与我们的k-nn预测相匹配：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, all these regions are of length 600\. NumPy's `reshape` function will map
    the region by some dimensions for a two-dimensional input, to get 1/600.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有这些区域长度都是600。NumPy的`reshape`函数将二维输入的区域通过某些维度映射，以得到1/600。
- en: The `thischar` function is actually an empty string at the start, but will keep
    getting populated as we find our k-nn.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`thischar`函数最初实际上是一个空字符串，但随着我们找到k-nn，它将不断被填充。'
- en: 'Also, we need to make sure that our `plate_candidates` are not blank, while
    we find our best candidate:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们寻找最佳候选者时，我们需要确保我们的`plate_candidates`不是空的：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You may find multiple plate candidates for a given image, but often they're
    the same thing. You might have just found something with four characters, when
    there are actually six, or something like that. The one that has the most characters
    is probably right, but you can take a look at the other candidates as well.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的图像，您可能会找到多个车牌候选者，但通常它们是同一件事。您可能只是找到了四个字符，而实际上有六个，或者类似的情况。具有最多字符的那个可能是正确的，但您也可以查看其他候选者。
- en: We'll extract and sort by the length of the string again, find the `best_plate`,
    and print out the results.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次按字符串长度提取并排序，找到`best_plate`，并打印出结果。
- en: Result analysis
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结果分析
- en: 'When we run our code using the best candidate code block, we get the following
    result:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用最佳候选代码块运行我们的代码时，我们得到以下结果：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once we get our output, we can display our result using the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到输出，我们可以使用以下代码显示我们的结果：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The displayed image will be as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的图像如下：
- en: '![](img/29224956-b4cf-4893-8da4-65719bf221b2.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29224956-b4cf-4893-8da4-65719bf221b2.png)'
- en: Although there is an extra character, we can see that our displayed image is
    very close to the plate characters. We can, check it with our other possible plate
    characters to get the closest result.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个多余的字符，但我们可以看到我们的显示图像与车牌字符非常接近。我们可以用我们的其他可能的车牌字符来检查，以获得最接近的结果。
- en: 'Let''s try one more license plate, to check how our code works:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一个车牌，以检查我们的代码如何工作：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And here''s the output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '![](img/57f183fe-8a9b-4ad1-8ba9-ffb6f0a7792e.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57f183fe-8a9b-4ad1-8ba9-ffb6f0a7792e.png)'
- en: 'The photo displayed is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的照片如下：
- en: '![](img/7b28522d-8233-4afb-878e-0093dadb36d1.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b28522d-8233-4afb-878e-0093dadb36d1.png)'
- en: 'If you just want the sub-image of the plate, you can get it using the following
    code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想获取车牌的子图像，可以使用以下代码：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](img/11243ab0-18fc-481a-bf19-2fa2ebb7ed64.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11243ab0-18fc-481a-bf19-2fa2ebb7ed64.png)'
- en: 'We can find the location of the result as well:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以找到结果的位置：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You get the following location in the output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中您得到以下位置：
- en: '![](img/cb45ca54-91ea-4b91-9409-287cfeeaa58e.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb45ca54-91ea-4b91-9409-287cfeeaa58e.png)'
- en: So, here we have the `x` and `y` coordinates, width, height, and some offset
    information.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里我们有`x`和`y`坐标，宽度，高度和一些偏移信息。
- en: 'We can try other available functions, such as the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试其他可用的函数，如下所示：
- en: '![](img/f1a092ba-ec2b-41ae-ba6e-b1bb4da83729.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1a092ba-ec2b-41ae-ba6e-b1bb4da83729.png)'
- en: 'Let''s look at another example where the license plate is not clearly visible:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子，其中车牌号码不够清晰：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This gives us the following output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '![](img/065f0342-9089-4974-baa9-8e318f920fbd.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/065f0342-9089-4974-baa9-8e318f920fbd.png)'
- en: 'Let''s take a closer look at the license plate:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看车牌：
- en: '![](img/450aade3-a977-4687-8bdc-380bf9ff769f.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/450aade3-a977-4687-8bdc-380bf9ff769f.png)'
- en: 'Our `display` function gives us a pretty good result, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`display`函数给出了相当不错的结果，如下所示：
- en: '![](img/3ae5a073-5b57-4c78-9103-5542367fa5d2.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ae5a073-5b57-4c78-9103-5542367fa5d2.png)'
- en: 'Let''s look at our final example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的最后一个例子：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here''s the view:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是视图：
- en: '![](img/2cfe4a47-732f-4e28-afa4-3846c3e99449.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cfe4a47-732f-4e28-afa4-3846c3e99449.png)'
- en: 'The following screenshot shows the output:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/1ee92e1c-609b-4dbb-ab44-7b1d24bcb9e3.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ee92e1c-609b-4dbb-ab44-7b1d24bcb9e3.png)'
- en: 'And the resulting photo is displayed as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 结果照片显示如下：
- en: '![](img/cf337289-29d2-427e-9641-7c8d1098083c.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf337289-29d2-427e-9641-7c8d1098083c.png)'
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to perform license plate recognition using OpenCV,
    giving us a good taste of how computer vision and image processing work.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用OpenCV进行车牌识别，这让我们对计算机视觉和图像处理的工作原理有了很好的了解。
- en: We first learned the different plate utility functions, which helped us find
    our plate characters. We then found possible candidates for our license plate
    characters using OpenCV. Finally, we analyzed our results to check the efficiency
    of our algorithm.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先学习了不同的车牌效用函数，这帮助我们找到了车牌特征。然后，我们使用OpenCV找到了车牌字符的可能候选者。最后，我们分析了我们的结果，以检查我们算法的效率。
- en: In the next chapter, [Chapter 4](489ca4bf-4851-4f79-9de8-0b326ab68a70.xhtml),
    *Human Pose Estimation with TensorFlow*, we're going to use the DeeperCut algorithm,
    and ArtTrack models for human pose estimation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[第4章](489ca4bf-4851-4f79-9de8-0b326ab68a70.xhtml)，*使用TensorFlow进行人体姿态估计*，我们将使用DeeperCut算法和ArtTrack模型进行人体姿态估计。
