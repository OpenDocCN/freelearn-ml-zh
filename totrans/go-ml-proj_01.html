<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to Solve All Machine Learning Problems</h1>
                </header>
            
            <article>
                
<p class="mce-root">Welcome to the book <em>Go <span>Machine Learning Projects</span></em>.<br/>
<br/>
This is a rather odd book. It's not a book about how <strong>machine learning</strong> (<strong>ML</strong>) works. In fact, <span>originally it was decided that we will assume that the readers are familiar with the <strong>machine learning</strong> (<strong>ML</strong>)</span> algorithms I am to introduce in these chapters. Doing so would yield a rather empty book, I feared. If the reader knows the ML algorithm, what happens next is to simply apply the ML algorithm in the correct context of the problem! The ten or so chapters in this book would be completed in under 30 pages—anyone who's written a grant report for government agencies would have experience writing such things.</p>
<p class="mce-root">So what is this book going to be about?</p>
<p class="mce-root">It's going to be about applying ML algorithms within a specific, given context of the problem. These problems are concrete, and are specified by me on a whim. But in order to explore the avenues of the application of ML algorithms to problems, the reader must first be familiar with algorithms and the problems! So, this book has to strike a very delicate balance between understanding the problem, and understanding the specific algorithm used to solve the problem.</p>
<p class="mce-root">But before we go too far, what is a problem? And what do I mean when I say <em>algorithm</em>? And what's with this <em>machine learning</em> business?</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is a problem? </h1>
                </header>
            
            <article>
                
<p class="mce-root">In colloquial use, a problem is something to be overcome. When people say they have money problems, the problem may be overcome simply by having more money. When someone has a mathematical problem, the problem may be overcome by mathematics. The thing or process used to overcome a problem is called a <strong>solution</strong>.</p>
<p class="mce-root">At this point, it may seem a little strange for me to define what is a common word. Ah, but precision and clarity of mind are required in order to solve problems with ML. You have to be precise about what exactly you are trying to solve.</p>
<p class="mce-root">Problems can be broken down into subproblems. But at some point, it no longer makes sense to break down those problems any further. I put it to the reader that there are different types of problems out there. So numerous are the types of problems that it is not worthwhile enumerating them all. Nonetheless, the urgency of a problem should be considered.</p>
<p class="mce-root">If you're building a photo organization tool (perhaps you are planning to rival Google Photos or Facebook), then recognizing faces in a photo is less urgent than knowing where to store, and how to retrieve a photo. If you do not know how to solve the latter, all the knowledge in the world to solve the former would be wasted.</p>
<p class="mce-root">I argue that urgency, despite its subjectivity, is a good metric to use when considering subproblems of the larger problem. To use a set of more concrete examples, consider three scenarios that all require some sort of ML solutions, but the solutions required are of different urgency. These examples are clearly made up examples, and have little or no bearing on real life. Their entire purpose is to make a point.</p>
<p class="mce-root">First, consider a real estate intelligence business. The entire survival of the business depends on being able to correctly predict the prices of houses to be sold, although perhaps they also make their money on some form of second market. To them, the ML problem faced is <strong>urgent</strong>. They would have to fully understand the ins and outs of the solution, otherwise they risk going out of business. In the view of the popular urgency/importance split, the ML problem can also be considered <strong>important</strong> and <strong>urgent</strong>.</p>
<p class="mce-root">Second, consider an online supermarket. They would like to know which groupings of products sell best together so they can bundle them to appear more competitive. This is not the core business activity, hence the ML problem faced is less urgent than the previous example. Some knowledge about how the solution works would be necessary. Imagine their algorithm says that they should bundle diarrhea medication with their home brand food products. They'd need to be able to understand how the solution came to that.</p>
<p class="mce-root">Lastly, consider the aforementioned photo application. Facial recognition is a nice <em>bonus</em> feature, but not the main feature. Therefore, the ML problem is least urgent amongst the three.</p>
<p class="mce-root">Different urgencies lead to different requirements when it comes to solving the problems.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is an algorithm? </h1>
                </header>
            
            <article>
                
<p class="mce-root">The previous section has been pretty diligent in the use of the term <em>algorithm</em>. Throughout this book, the term is liberally sprinkled, but is always used judiciously. But what is an algorithm?</p>
<p class="mce-root">To answer that, well, we must first ask, what is a program? A program is a series of steps to be performed by the computer. An algorithm is a set of rules that will solve the problem. A ML algorithm is hence a set of rules to solve a problem. They are implemented as a program on a computer.</p>
<p class="mce-root">One of the most eye-opening moments in truly and deeply understanding what exactly an algorithm is for me was an experience I had about 15 years ago. I was staying over at a friend's place. My friend had a seven year old child, and the friend was exasperated at trying to get her child to learn programming as her child had been too stubborn to learn the discipline of syntax. The root cause, I surmised, was that the child had not understood the idea of an algorithm. So the following morning, we tasked the child to make his own breakfast. Except he wasn't to make his own breakfast. He was to write down a series of steps that his mother was to follow to the letter.</p>
<p class="mce-root">The breakfast was simple—a bowl of cornflakes in milk. Nonetheless, it took the child some eleven attempts to get a bowl of cereal. It ended in tears and plenty of milk and cereal on the countertop, but it was a lesson well learned for the child.</p>
<p class="mce-root">This may seem like wanton child abuse. but it served me well too. In particular, the child said to his mother and me, in paraphrase, <em>But you already know how to make cereal; why do you need instructions to do so?</em> His mum responded, <em>think of this as teaching me how to to make computer games</em>. Here we have a meta notion of an algorithm. The child giving instructions on how to make cereal is teaching the child how to program; is itself an algorithm!</p>
<p class="mce-root">A ML algorithm can refer to the algorithm that is learned, or the algorithm that teaches the machine to use the correct algorithm. For the most part of this book, we shall refer to the latter, but it's quite useful to think of the former as well, if only as a mental exercise of sorts. For the most parts since Turing, we can substitute algorithm with machine.</p>
<p class="mce-root">Take some time to go through these sentences after reading the following section. It will help in clarifying what I mean upon a second read.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is machine learning? </h1>
                </header>
            
            <article>
                
<p class="mce-root">So what then is ML? As the word may hint, it's the ML to do something. Machines cannot learn the same way as humans can, but they can definitely emulate some parts of human learning. But what are they supposed to learn? Different algorithms learn different things, but the shared themes are that the machines learn a program. Or to put in less specific terms, the machine learns to <em>do</em> the correct thing.</p>
<p class="mce-root">What then is the correct thing? Not wanting to open a philosophical can of worms, the correct thing is what we, as human programmers of the computer, define as the correct thing.</p>
<p class="mce-root">There are multiple classification schemes of ML systems, but amongst the most common classification schemes, is one that splits ML into two types: supervised learning and unsupervised learning. Throughout this book we will see examples of both, but it's my opinion that such forms of classification are squarely in the <em>good to know but not operationally important</em> area of the brain. I say so because outside of a few well-known algorithms, unsupervised learning is still very much under active research. Supervised learning algorithms are too, but have been used in industry for longer than the unsupervised algorithms. That is not to say that unsupervised learning is not of value—a few have escaped the ivory towers of academia and have proven to be quite useful. We shall explore <strong>K-means</strong> and <strong>k-Nearest Neighbors</strong> (<strong>KNN</strong>) in one of the chapters.</p>
<p>Let's suppose for now we have a machine learning algorithm. The algorithm is a black box - we don't know what goes on inside. We feed it some data. And through its internal mechanisms, it produces an output. The output may not be correct. So it checks for whether the output is correct or not. If the output is not correct, it changes its internal mechanism, and tries again and again until the output is correct. This is how machine learning algorithms work in general. This is called <strong>training</strong>.</p>
<p>There are notions of what "correct" means of course. In supervised learning situations, we, the humans provide the machine with examples of correct data. In unsupervised learning situations, the notion of correctness relies on other metrics like distances between values. Each algorithm has its own specifics, but in general machine learning algorithms are as described.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Do you need machine learning?</h1>
                </header>
            
            <article>
                
<p>Perhaps the most surprising question to ask, is whether you need machine learning to solve your problem. There is after all, a good reason why this section is the fourth in the chapter—we must understand what exactly is a problem is; and understand what an algorithm is before we can raise the question: do you need machine learning?</p>
<p>The first question to ask is of course: do you have a problem you need to solve? I assume the answer is yes, because we live in the world and are part of the world. Even ascetics have problems they need solved. But perhaps the question should be more specific: do you have a problem that can be solved with machine learning?</p>
<p>I've consulted a fair bit, and in my early days of consulting, I'd eagerly say yes to most enquiries. Ah, the things one does when one is young and inexperienced. The problems would often show up after I said yes. It turns out many of these consulting enquiries would be better served by having a more thorough understanding of the business domain and a more thorough understanding of computer science in general.</p>
<p>A common variant of a problem that is brought to me often requires information retrieval solutions, not machine learning solutions. Consider the following request I received several years ago:</p>
<div class="packt_quote">Hi Xuanyi,<br/>
I am XXXX. We met at YYYY meetup a few months ago. My company is currently building a machine learning system that extracts relationships between entities. Wondering if you may be interested to catch up for coffee?</div>
<p>Naturally, this piqued my interest—relationship extraction is a particularly challenging task in machine learning. I was young, and ever so eager to get my hands on tough problems. So I sat down with the company, and we worked out what was needed based on surface information. I suggested several models, all of which were greeted with enthusiasm. We finally settled on an SVM-based model. Then I got to work.</p>
<p>The first step in any machine learning project is to collect data. So I did. Much to my surprise, the data was already neatly classified, and entities already identified. Further, the entities have a static, unchanging relationship. One type of entity would have a permanent relationship with another type of entity. What was the machine learning problem?</p>
<p>I brought this up after one and a half month's worth of data gathering. What was going on? We have clean data, we have clean relationships. All new data had clean relationships. Where is the need for machine learning?</p>
<p>It later emerged that the data came from manual data input, which was at the time required by law. The entity relationships were defined fairly strictly. The only data requirement they really needed was a cleaned up database entity-relationship diagram. Because their database structure was so convoluted, they could not really see that all they needed to do was to define a foreign-key relationship to enforce the relationship. When I had requested the data, the data had came from individual SQL queries. There was no need for machine learning!</p>
<p>To their DBA's credit, that was what their DBA had been saying all along.</p>
<p>This taught me a lesson: Always find out if someone really needs machine learning solutions before spending time working on it.</p>
<p>I've since settled on a very easy way of determining if someone needs machine learning. These are my rules of thumb</p>
<ol>
<li>Can the problem in this form: "Given X, I want to predict Y" </li>
<li>A what-question is generally suspect. A what question looks like this: "I want to know what is our conversion rate for XYZ product"</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The general problem solving process</h1>
                </header>
            
            <article>
                
<p>Only if the general rules of thumbs are fulfilled then will I engage to further. The general problem solving process goes as follows for me:</p>
<ol>
<li>Identify clearly the problems.</li>
<li>Translate the problems into a more concrete statement.</li>
<li>Gather data</li>
<li>Perform exploratory data analysis</li>
<li>Determine the correct machine learning solution to use</li>
<li>Build a model.</li>
<li>Train the model.</li>
<li>Test the model.</li>
</ol>
<p>Throughout the chapters in this book, the pattern above will be followed. The exploratory data analysis sections will be only done for the first few chapters. It's implicit that those would have been done in the later chapters. </p>
<p>I have attempted to be clear in the section headings on what exactly are we trying to solve, but writing is a difficult task, so I may miss some.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is a model?</h1>
                </header>
            
            <article>
                
<div class="packt_quote CDPAlignLeft CDPAlign"><strong>All models are wrong; but some are useful.</strong><br/>
<br/>
Now it would be very remarkable if any system existing in the real world could be<span> </span>exactly<span> </span>represented by any simple model. However, cunningly chosen parsimonious models often do provide remarkably useful approximations. For example, the law <img class="fm-editor-equation" src="Images/e38bd216-7a23-49a8-a7bc-d7b57fbd5cb9.png" style="width:5.42em;height:1.08em;" width="800" height="160"/> relating pressure <img class="fm-editor-equation" src="Images/69e846db-b496-4c31-8c87-d999f5dd8cd3.png" style="width:1.00em;height:1.17em;" width="140" height="160"/>, volume <img class="fm-editor-equation" src="Images/ce303fd4-6e01-4d71-9a0b-98191ffe55c8.png" style="width:0.92em;height:1.08em;" width="140" height="160"/>and temperature <img class="fm-editor-equation" src="Images/16692458-a958-4fcd-935c-6abb17dd6bff.png" style="width:0.92em;height:1.17em;" width="130" height="160"/>of an "ideal" gas via a constant R is not exactly true for any real gas, but it frequently provides a useful approximation and furthermore its structure is informative since it springs from a physical view of the behavior of gas molecules.<br/>
<br/>
For such a model there is no need to ask the question "Is the model true?". If "truth" is to be the "whole truth" the answer must be "No". The only question of interest is "Is the model illuminating and useful?".</div>
<div class="packt_quote CDPAlignRight CDPAlign">- George Box (1978)</div>
<p>Model train are a fairly common hobby, despite being lampooned by the likes of The Big Bang Theory. A model train is not a real train. For one, the sizes are different. Model trains do not work exactly the same way a real train does. There are gradations of model trains, each being more similar to actual trains than the previous. </p>
<p>A model is in that sense a representation of reality. What do we represent it with? By and large, numbers. A model is a bunch of numbers that describes reality, and a bit more.</p>
<p>Every time I try to explain what a model is I inevitably get responses along the lines of "You can't just reduce us to a bunch of numbers!". So what do I mean "numbers"?</p>
<p>Consider the following right angle triangle:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-553 image-border" src="Images/2175de40-79f6-4240-81e4-4ce91476d7e6.png" style="width:18.92em;height:16.08em;" width="440" height="374"/></p>
<p>How do we describe <em>all</em> right angle triangles? We might say something like this:</p>
<p><img class="fm-editor-equation" src="Images/0e78b35e-6940-4502-a75b-1143e54c59dd.png" style="width:63.67em;height:3.25em;" width="7640" height="390"/></p>
<p>This says that the sum of all angles in a right angle adds up to 180 degrees, and there exists an angle that is 90 degrees. This is sufficient to describe <em>all</em> right angle triangles in Cartesian space.</p>
<p>But is the description the triangle itself? It is not. This issue has plagued philosophers ever since the days of Aristotle.  We shall not enter into a philosophical discussion for such a discussion will only serve to prolong the agony of this chapter. </p>
<p>So for our purposes in this chapter, we'll say that a model is the values that describe reality, <em>and</em> the algorithm that produces those values. These values are typically numbers, though they may be of other types as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is a good model?</h1>
                </header>
            
            <article>
                
<p>A model is a bunch of values that describe the world, alongside the program that produces these values. That much, we have concluded from the previous section. Now we have to pass some value judgments on models - whether a model is good or bad.</p>
<p>A good model needs to describe the world accurately. This is said in the most generic way possible. Described thus, this statement about a good model encompasses many notions. We shall have to make this abstract idea a bit more concrete to proceed.</p>
<p>A machine learning algorithm is trained on a bunch of data. To the machine, this bunch of data is the world. But to us, the data that we feed the machine in for training is not the world. To us humans, there is much more to the world than what the machine may know about. So when I say "a good model needs to describe the world accurately", there are two senses to the word "world" that applies - the world as the machine knows, and the world as we know it.</p>
<p>The machine has only seen portions of the world as we know it. There are parts of the world the machine has not seen. So it is then a good machine learning model when it is able to provide the correct outputs for inputs it has not seen yet.</p>
<p>As a concrete example, let's once again suppose that we have a machine learning algorithm that determines if an image is that of a hot dog or not. We feed the model images of hot dogs and hamburgers. To the machine, the world are simply images of hot dogs and hamburgers. What happens when we pass in as input, an image of vegetables? A good model would be able to <strong>generalize</strong> and say it's not a hot dog. A poor model would simply crash.</p>
<p>And thus with this analogy, we have defined a good model to be one that generalizes well to unknown situations.</p>
<p>Often, as part of the process of building machine learning systems, we would want to put this notion to test. So we would have to split our dataset into testing and training datasets. The machine would be trained on the training dataset, and to test how good the model is once the training has completed, we will then feed in the testing dataset to the machine. It's assumed of course that the machine has never seen the testing dataset. A good machine learning model hence would be able to generate the correct output for the testing dataset, despite never having seen it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">On writing and chapter organization </h1>
                </header>
            
            <article>
                
<p class="mce-root">A note on the writing in this book. As you may already have guessed, I have decided to settle upon a more conversational tone. I find this tone to be friendlier to the reader who may be intimidated by machine algorithms. I am also, if you have not yet noticed, quite opinionated in my writing. I strive to make clear, through my writing, what is and what ought to be. Application of Hume's fork is at the discretion at the reader. But as a quick guide, when talking about algorithms and how they work, they are <kbd>is</kbd> statements. When talking about what should be done, and organization of code, they are ought statements.</p>
<p class="mce-root">There are two general patterns in the design of the chapters of this book. First, the problems get harder as the chapters go on. Second, one may optionally want to mentally divide the chapters into three different parts. Part 1—<a href="12c81095-6fcf-4da9-b554-6367d45b34f8.xhtml" target="_blank" rel="noopener noreferrer"/><a href="12c81095-6fcf-4da9-b554-6367d45b34f8.xhtml" target="_blank" rel="noopener noreferrer">Chapters 2</a>, <em>Linear Regression - House Price Prediction</em>, <a href="d0447032-8c26-4198-a13c-b41ec20c02e8.xhtml" target="_blank" rel="noopener noreferrer"/><a href="d0447032-8c26-4198-a13c-b41ec20c02e8.xhtml" target="_blank" rel="noopener noreferrer">Chapter 3</a>, <em>Classification - Spam Email Detection</em>, <a href="fdb27bce-1c0b-4264-94bd-6c56382b36bc.xhtml" target="_blank" rel="noopener noreferrer">Chapter 4</a>, <em>Decomposing CO2 Trends Using Time Series Analysis</em>, <a href="4c71e400-fde5-467f-a1ee-52300e326504.xhtml" target="_blank" rel="noopener noreferrer">Chapter 7</a>, <em>Convolutional Neural Networks - MNIST Handwriting Recognition</em>, <a href="26529196-995f-4689-91d7-0039b62337e9.xhtml" target="_blank" rel="noopener noreferrer">Chapter 8</a>, <em>Basic Facial Detection</em>) correspond to readers who have an urgent ML problem. Part 2—<a href="d6a6876a-eca1-44f0-8ee6-9d949e694b6e.xhtml" target="_blank" rel="noopener noreferrer">Chapters 5</a>, <em>Clean Up Your Personal Twitter Timeline by Clustering Tweets</em>, <a href="c0a3360f-762c-49b4-a013-d1a99a23fcfa.xhtml" target="_blank" rel="noopener noreferrer"/><a href="c0a3360f-762c-49b4-a013-d1a99a23fcfa.xhtml" target="_blank" rel="noopener noreferrer">Chapter 9</a>, <em>Hot Dog or Not Hot Dog - Using External Services</em>, <a href="d54b14d1-3403-4f2a-a98e-dd12adfe585a.xhtml" target="_blank" rel="noopener noreferrer">Chapter 6</a>, <em>Neural Networks; MNIST Handwriting Recognition</em>, <a href="4c71e400-fde5-467f-a1ee-52300e326504.xhtml" target="_blank" rel="noopener noreferrer">Chapter 7</a>, <em>Convolutional Neural Networks - MNIST Handwriting Recognition</em>, <a href="26529196-995f-4689-91d7-0039b62337e9.xhtml" target="_blank" rel="noopener noreferrer">Chapter 8</a>, <em>Basic Facial Detection</em>) are for those who have ML problems akin to the second example. Part 3, the last two chapters, are for people whose machine learning problems are not as urgent, but still require a solution.</p>
<p class="mce-root">Up to <a href="26529196-995f-4689-91d7-0039b62337e9.xhtml" target="_blank" rel="noopener noreferrer">Chapter 8</a>, <em>Basic Facial Detection</em>, for each chapter there will typically be one or two sections dedicated to the explanation of the algorithm itself. I strongly believe that one cannot write any meaningful program without at least a basic understanding of the algorithms they are using. Sure, you may <strong>use</strong> an algorithm that has been provided by someone else, but, without a proper understanding, it's <strong>meaningless</strong>. Sometimes meaningless programs may produce results, just as sometimes an elephant may appear to know how to do arithmetic, or a pet dog may appear to do a sophisticated feat, like speak.</p>
<p class="mce-root">This also means that I may sound rather dismissive of some ideas. For example, I am dismissive of using ML algorithms to predict stock prices. I do not believe that doing so will be a productive endeavor, because of an understanding of the basic processes that generate prices in a stock market, and the confounding effects of time.</p>
<p class="mce-root">Time, however, will tell if I am right or wrong. It may well be that one day someone will invent a ML algorithm that will work perfectly well on dynamical systems, but not right now, right here. We are at the dawn of a new era of computation, and we must strive to understand things as best as we can. Often you can learn quite a bit from history. Therefore, I also strive to insert important historical anecdotes on how certain things came to be. These are by no means a comprehensive survey. In fact, it is done without much regularity. However, I do rather hope that it adds to the flavor of the book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Why Go? </h1>
                </header>
            
            <article>
                
<p class="mce-root">This book is a book on ML using Go. Go is a rather opinionated programming language. There's the Go way, or no other way at all. This may sound rather fascist, but it has resulted in a very enjoyable programming experience. It also makes working in teams rather efficient.</p>
<p class="mce-root">Further, Go is a fairly efficient language when compared to Python. I have moved on almost exclusively to using Go to do my ML and data science work.</p>
<p class="mce-root">Go also has the benefit of working well cross-platform. At work, developers may choose to work on different operating systems. Go works well across all of them. The programs that are written in Go can be trivially cross-compiled for other platforms. This makes deployment a lot easier. There's no unnecessary mucking around with Docker or Kubernetes.</p>
<p class="mce-root">Are there drawbacks when using Go for ML? Only as a library author. In general, <strong>using</strong> Go ML libraries is painless. But in order for it to be painless, you must let go of any previous ways you programmed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Quick start</h1>
                </header>
            
            <article>
                
<p class="mce-root">First install Go, which can be found at <a href="https://golang.org" target="_blank" rel="noopener noreferrer">https://golang.org</a>. It provides comprehensive guides to Go. And now, quick start.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functions</h1>
                </header>
            
            <article>
                
<p class="mce-root">Functions are the main way that anything is computed in Go.</p>
<p class="mce-root">This is a function:</p>
<pre class="mce-root">func addInt(a, b int) int { return a + b }</pre>
<p class="mce-root">We call <kbd>func addInt(a, b int) int</kbd>, which is the <strong>function signature</strong>. The function signature is composed of the function name, parameters, and return type(s).</p>
<p class="mce-root">The name of the function is <kbd>addInt</kbd>. Note the formatting being used. The function name is in camelCase—this is the preferred casing of names in Go. The first letter of any name, when capitalized, like <kbd>AddInt</kbd> indicates that it should be exported. By and large in this book we shan't worry about exported or unexported names, as we will be mostly using functions. But if you are writing a package, then it matters. Exported names are available from outside a package.</p>
<p class="mce-root">Next, note that <kbd>a</kbd> and <kbd>b</kbd> are parameters, and both have the type <kbd>int</kbd>. We'll discuss types in a bit, but the same function can also be written as:</p>
<pre class="mce-root">func addInt(a int, b int) int { return a + b }</pre>
<p class="mce-root">Following that, this is what the function returns. This function <kbd>addInt</kbd> returns an <kbd>int</kbd>. This means when a function is called correctly, like so:</p>
<pre class="mce-root"> z := addInt(1, 2) </pre>
<p class="mce-root"><kbd>z</kbd> will have a type <kbd>int</kbd>.</p>
<p class="mce-root">After the return type is defined, <kbd>{...}</kbd> denotes the body. When <kbd>{...}</kbd> is written in this book, it means the content of the function body is not as important for the discussion at hand. Some parts of the book may have snippets of function bodies, but without the signature <kbd>func foo(...)</kbd>. Again those snippets are the snippets under discussion. It's expected that the reader will piece together the function from context in the book.</p>
<p class="mce-root">A Go function may return multiple results. The function signature looks something like this:</p>
<pre class="mce-root"> func divUint(a, b uint) (uint, error) { ... }<br/> func divUint(a, b uint) (retVal uint, err error) { ... }</pre>
<p class="mce-root">Again, the difference is mainly in naming the return values. In the second example, the return values are named <kbd>retVal</kbd> and <kbd>err</kbd> respectively. <kbd>retVal</kbd> is of type <kbd>uint</kbd> and <kbd>err</kbd> is of type <kbd>error</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Variables</h1>
                </header>
            
            <article>
                
<p class="mce-root">This is a variable declaration:</p>
<pre class="mce-root">var a int</pre>
<p class="mce-root">It says <kbd>a</kbd> is an <kbd>int</kbd>.  That means <kbd>a</kbd> can contain any value that has the type <kbd>int</kbd>. Typical <kbd>int</kbd> would be like <kbd>0</kbd>, <kbd>1</kbd>, <kbd>2</kbd>, and so on and so forth. It may seem odd to read the previous sentence, but <em>typically</em> is used correctly. All values of type <kbd>int</kbd> are typically <kbd>int</kbd>.</p>
<p class="mce-root">This is a variable declaration, followed by putting a value into the variable:</p>
<pre class="mce-root">s := "Hello World"</pre>
<p class="mce-root">Here, we're saying, define <kbd>s</kbd> as a <kbd>string</kbd>, and let the value be <kbd>"Hello World"</kbd>. The <kbd>:=</kbd> syntax can only be used within a function body. The main reason for this is not to cause the programmer to have to type <kbd>var s string = "Hello World"</kbd>.</p>
<p class="mce-root">A note about the use of variables: variables in Go should be thought of as buckets with a name on them, in that they hold values. The names are important insofar as they inform the readers about<span> </span><span>the values they are supposed to hold. However, names do not necessarily have to cross barriers. I frequently name my return values with <kbd>retVal</kbd>, but give it a different name elsewhere. A concrete example is shown:</span></p>
<pre class="mce-root"> func foo(...) (retVal int) { ... return retVal }<br/> func main() {<br/>     something := foo()<br/>     ...<br/> }</pre>
<p class="mce-root">I have taught programming and ML for a number of years now, and I believe that this is a hump every programmer has got to get over. Frequently students or junior team members may get confused by the difference in naming. They would rather prefer something like this:</p>
<pre class="mce-root"> func foo(...) (something int) { ... return something }<br/> func main() {<br/>     something := foo()<br/>     ...<br/> }</pre>
<p class="mce-root">This is fine. However again, speaking strictly from experience, this tends to dampen the ability to think abstractly, which is a useful skill to have, especially in ML. My advice is, get used to using different names, it makes you think more abstractly.</p>
<p class="mce-root">In particular, names do not persist past what my friend James Koppel calls an <strong>abstraction barrier</strong>. What is an abstraction barrier? A function is an abstraction barrier. Whatever happens inside the function body, happens inside the function body and cannot be accessed by other things in the language. Therefore if you name a value <kbd>fooBar</kbd> inside the function body, the meaning of <kbd>fooBar</kbd> is only valid within the function.</p>
<p class="mce-root">Later we will see another form of abstraction barrier—the package.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Values </h1>
                </header>
            
            <article>
                
<p class="mce-root">A value is what a program deals with. If you wrote a calculator program, then the values of the program are numbers. If you wrote a text search program, then the values are strings.</p>
<p class="mce-root">The programs we deal with nowadays as programmers are much more complicated than calculators. We deal with different types of values, ranging from number types (<kbd>int</kbd>, <kbd>float64</kbd>, and so on) to text (string).</p>
<p class="mce-root">A variable holds a value:</p>
<pre class="mce-root">var a int = 1</pre>
<p class="mce-root">The preceding line indicates that <kbd>a</kbd> is a variable that holds an <kbd>int</kbd> with the value <kbd>1</kbd>. We've seen previous examples with the <kbd>"Hello World"</kbd> string.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Types </h1>
                </header>
            
            <article>
                
<p class="mce-root">Like all major programming languages (yes, including Python and JavaScript), values in Go are typed. Unlike Python or JavaScript however, Go's functions and variables are also typed, and strongly so. What this means is that the following code will cause the program not to compile:</p>
<pre class="mce-root">var a int<br/>a = "Hello World"</pre>
<p class="mce-root">This sort of behavior is known outside the academic world as <em>strongly-typed</em>. Within academic circles, <em>strongly-typed</em> is generally meaningless.</p>
<p class="mce-root">Go allows programmers to define their own types too:</p>
<pre class="mce-root"> type email string</pre>
<p class="mce-root">Here, we're defining a new type <kbd>email</kbd>. The underlying kind of data is a <kbd>string</kbd>.</p>
<p class="mce-root">Why would you want to do this? Consider this function:</p>
<pre class="mce-root"> func emailSomeone(address, person string) { ... }</pre>
<p class="mce-root">If both are <kbd>string</kbd>, it would be very easy to make a mistake—we might accidentally do something like this:</p>
<pre class="mce-root">var address, person string<br/>address = "John Smith"<br/>person = "john@smith.com"<br/>emailSomeone(address, person)</pre>
<p class="mce-root">In fact, you could even do this: <kbd>emailSomeone(person, address)</kbd> and the program would still compile correctly!</p>
<p class="mce-root">Imagine, however, if <kbd>emailSomeone</kbd> is defined thus:</p>
<pre class="mce-root">func emailSomeone(address email, person string) {...}</pre>
<p class="mce-root">Then the following will fail to compile:</p>
<pre class="mce-root">var address email<br/>var person string<br/>person = "John Smith"<br/>address = "john@smith.com"<br/>emailSomeone(person, address)</pre>
<p class="mce-root">This is a good thing—it prevents bad things from happening. No more shall be said on this matter.</p>
<p class="mce-root">Go also allows programmers to define their own complex types:</p>
<pre class="mce-root">type Record struct {<br/>     Name string<br/>     Age int<br/> }</pre>
<p class="mce-root">Here, we defined a new type called <kbd>Record</kbd>. It's a <kbd>struct</kbd> that contains two values: <kbd>Name</kbd> of type <kbd>string</kbd> and <kbd>Age</kbd> of type <kbd>int</kbd>.</p>
<p class="mce-root">What is a <kbd>struct</kbd>?  Simply put, a <kbd>struct</kbd> is a data structure. The <kbd>Name</kbd> and <kbd>Age</kbd> in <kbd>Record</kbd> are called the <strong>fields of the</strong> <kbd>struct</kbd>.</p>
<p class="mce-root">A <kbd>struct</kbd>, if you come from Python, is equivalent to a tuple, but acts as a <kbd>NamedTuple</kbd>, if you are familiar with those. The closest equivalent in JavaScript is that it's an object. Likewise the closest equivalent in Java is that it's a plain old Java object. The closest equivalent in C# would be a plain old CLR object. In C++, the equivalent would be plain old data.</p>
<p class="mce-root">Note my careful use of the words <em>closest equivalent</em> and <em>equivalent</em>. The reason why I have delayed introduction to <kbd>struct</kbd> is because in most modern languages that the reader is likely to come from, it may have some form of Java-esque object orientation. A <kbd>struct</kbd> is not a class. It's just a definition of how data is arranged in the CPU. Hence the comparison with Python's tuples instead of Python's classes, or even Python's new data classes.</p>
<p class="mce-root">Given a value that is of type <kbd>Record</kbd>, one might want to extract its inner data. This can be done as so:</p>
<pre class="mce-root"> r := Record {<br/>     Name: "John Smith",<br/>     Age: 20,<br/> }<br/> r.Name</pre>
<p>The snippet here showcases a few things:</p>
<ul>
<li>How to write a struct—kinded value—simply write the name of the type, and then fill in the fields.</li>
<li>How to read the fields of a struct—the <kbd>.Name</kbd>  syntax is used.</li>
</ul>
<p>Throughout this book, I shall use <kbd>.FIELDNAME</kbd> as a notation to get the field name of a particular data structure. It is expected that the reader is able to understand which data structure I am talking about from context. Occasionally I may use a full term, like <kbd>r.Name</kbd>, to make it clear which fields I am talking about.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Methods </h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's say we wrote these functions, and we have defined <kbd>email</kbd> as before:</p>
<pre class="mce-root"> type email string<br/> <br/> func check(a email) { ... }<br/> func send(a email, msg string) { ... }</pre>
<p class="mce-root">Observe that <kbd>email</kbd> is always the first type in the function parameters.</p>
<p class="mce-root">Calling the functions look something like this:</p>
<pre class="mce-root">e := "john@smith.com"<br/>check(e)<br/>send(e, "Hello World")</pre>
<p class="mce-root">We may want to make that into a method of the <kbd>email</kbd> type. We can do so as follows:</p>
<pre class="mce-root">type email string<br/> <br/>func (e email) check() { ... }<br/>func (e email) send(msg string) { ... }</pre>
<p class="mce-root"><kbd>(e email)</kbd> is called the <strong>receiver</strong> of the method.</p>
<p class="mce-root">Having defined the methods thus, we may then proceed to call them:</p>
<pre class="mce-root">e := "john@smith.com"<br/>e.check()<br/>e.send("Hello World")</pre>
<p class="mce-root">Observe the difference between the functions and methods. <kbd>check(e)</kbd> becomes <kbd>e.check()</kbd>. <kbd>send(e, "Hello World")</kbd> becomes <kbd>e.send("Hello World")</kbd>. What's the difference other than syntactic difference? The answer is, not much.</p>
<p class="mce-root">A method in Go is exactly the same as a function in Go, with the receiver of the method as the first parameter of the function. It is unlike methods of classes in object-oriented programming languages.</p>
<p class="mce-root">So why bother with methods? For one, it solves the expression problem quite neatly. To see how, we'll look at the feature of Go that ties everything together nicely: interfaces.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interfaces</h1>
                </header>
            
            <article>
                
<p class="mce-root">An interface is a set of methods. We can define an interface by listing out the methods it's expected to support. For example, consider the following interface:</p>
<pre class="mce-root">var a interface {<br/>     check()<br/> }</pre>
<p class="mce-root">Here we are defining <kbd>a</kbd> to be a variable that has the type <kbd>interface{ check() }</kbd>. What on earth does that mean?</p>
<p class="mce-root">It means that you can put any value into <kbd>a</kbd>, as long as the value has a type that has a method called <kbd>check()</kbd>.</p>
<p class="mce-root">Why is this valuable? It's valuable when considering multiple types that do similar things. Consider the following:</p>
<pre class="mce-root"> type complicatedEmail struct {...}<br/> <br/> func (e complicatedEmail) check() {...}<br/> func (e complicatedEmail) send(a string) {...}<br/> <br/> type simpleEmail string<br/> <br/> func (e simpleEmail) check() {...}<br/> func (e simpleEmail) send(a string) {...}</pre>
<p class="mce-root">Now we want to write a function <kbd>do</kbd>, which does two things:<br/></p>
<ul>
<li class="mce-root">Check that an email address is correct</li>
<li class="mce-root">Send <kbd>"Hello World"</kbd> to the email</li>
</ul>
<p>You would need two <kbd>do</kbd> functions:</p>
<pre class="mce-root">func doC(a complicatedEmail) {<br/>     a.check()<br/>     a.send("Hello World")<br/> }<br/> <br/>func doS(a simpleEmail) {<br/>     a.check()<br/>     a.send("Hello World")<br/> }</pre>
<p class="mce-root">Instead, if that's all the bodies of the functions are, we may opt to do this:</p>
<pre class="mce-root">func do(a interface{<br/>     check()<br/>     send(a string)<br/>     }) {<br/>         a.check()<br/>         a.send("Hello World")<br/>     }</pre>
<p class="mce-root">This is quite hard to read. So let's give the interface a name:</p>
<pre class="mce-root">type checkSender interface{<br/>     check()<br/>     send(a string)<br/> }</pre>
<p class="mce-root">Then we can simply redefine <kbd>do</kbd> to be the following:</p>
<pre class="mce-root">func do(a checkSender) {<br/>     a.check()<br/>     a.send("Hello World")<br/> }</pre>
<p class="mce-root">A note on naming interfaces in Go. It is customary to name interfaces with a <kbd>-er</kbd> suffix. If a type implements <kbd>check()</kbd>, then the interface name should be called <kbd>checker</kbd>. This encourages the interfaces to be small. An interface should only define a small number of methods—larger interfaces are signs of poor program design.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Packages and imports</h1>
                </header>
            
            <article>
                
<p class="mce-root">Finally, we come to the concept of packages and imports. For the majority of the book, the projects described live in something called a <kbd>main</kbd> package. The <kbd>main</kbd> package is a special package. Compiling a <kbd>main</kbd> package will yield an executable file that you can run.</p>
<p class="mce-root">Having said that, it's also often a good idea to organize your code into multiple packages. Packages are a form of abstraction barrier that we discussed previously with regards to variables and names. Exported names are accessible from outside the package. Exported fields of structs are also accessible from outside the package.</p>
<p class="mce-root">To import a package, you need to invoke an import statement at the top of the file:</p>
<pre class="mce-root">package main<br/>import "PACKAGE LOCATION"</pre>
<p class="mce-root">Throughout this book I will be explicit in what to import, especially with external libraries that cannot be found in the Go standard library. We will be using a number of those, so I will be explicit.</p>
<p class="mce-root">Go enforces code hygiene. If you import a package and don't use it, your program will not compile. Again, this is a good thing as it makes it less likely to confuse yourself at a later point in time. I personally use a tool called <kbd>goimports</kbd> to manage my imports for me. Upon saving my file, <kbd>goimports</kbd> adds the import statements for me, and removes any unused packages from my import statements.</p>
<p class="mce-root">To install <kbd>goimports</kbd>, run the following command in your Terminal:</p>
<pre class="mce-root">go get golang.org/x/tools/cmd/goimports</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Let's Go! </h1>
                </header>
            
            <article>
                
<p>In this chapter we've covered what a problem is and how to model a problem as a machine learning problem. Then we learned the basics of using Go. In the next chapter we will dive into our first problem: linear regression.</p>
<p class="mce-root">I highly encourage you to practice some Go beforehand. But if you already know how to use Go, well, let's Go!</p>


            </article>

            
        </section>
    </div>



  </body></html>