- en: Chapter 1. Playing with Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will get you started with the `OpenCV` library. You will
    learn how to perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the OpenCV library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading, displaying, and saving images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the cv::Mat data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining regions of interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will teach you the basic elements of OpenCV and will show you
    how to accomplish the most fundamental image processing tasks: reading, displaying,
    and saving images. However, before you can start with OpenCV, you need to install
    the library. This is a simple process that is explained in the first recipe of
    this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: All your computer vision applications will involve the processing of images.
    This is why the most fundamental tool that OpenCV offers you is a data structure
    to handle images and matrices. It is a powerful data structure, with many useful
    attributes and methods. It also incorporates an advanced memory management model
    that greatly facilitates the development of applications. The last two recipes
    of this chapter will teach you how to use this important data structure of OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the OpenCV library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV is an open source library for developing computer vision applications
    that run on Windows, Linux, Android, and Mac OS. It can be used in both academic
    and commercial applications under a BSD license that allows you to freely use,
    distribute, and adapt it. This recipe will show you how to install the library
    on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you visit the OpenCV official website at [http://opencv.org/](http://opencv.org/),
    you will find the latest release of the library, the online documentation, and
    many other useful resources on OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the OpenCV website, go to the **DOWNLOADS** page that corresponds to the
    platform of your choice (Unix/Windows or Android). From there, you will be able
    to download the OpenCV package. You will then need to uncompress it, normally
    under a directory with a name that corresponds to the library version (for example,
    in Windows, you can save the uncompressed directory under `C:\OpenCV2.4.9`). Once
    this is done, you will find a collection of files and directories that constitute
    the library at the chosen location. Notably, you will find the `sources` directory
    here, which contains all the source files. (Yes, it is open source!) However,
    in order to complete the installation of the library and have it ready for use,
    you need to undertake an additional step: generating the binary files of the library
    for the environment of your choice. This is indeed the point where you have to
    make a decision on the target platform that you will use to create your OpenCV
    applications. Which operating system should you use? Windows or Linux? Which compiler
    should you use? Microsoft VS2013 or MinGW? 32-bit or 64-bit? The **Integrated
    Development Environment** (**IDE**) that you will use in your project development
    will also guide you to make these choices.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you are working under Windows with Visual Studio, the executable
    installation package will, most probably, not only install the library sources,
    but also install all of the precompiled binaries needed to build your applications.
    Check for the `build` directory; it should contain the `x64` and `x86` subdirectories
    (corresponding to the 64-bit and 32-bit versions). Within these subdirectories,
    you should find directories such as `vc10`, `vc11`, and `vc12`; these contain
    the binaries for the different versions of MS Visual Studio. In that case, you
    are ready to start using OpenCV. Therefore, you can skip the compilation step
    described in this recipe, unless you want a customized build with specific options.
  prefs: []
  type: TYPE_NORMAL
- en: To complete the installation process and build the OpenCV binaries, you need
    to use the **CMake** tool, available at [http://cmake.org](http://cmake.org).
    CMake is another open source software tool designed to control the compilation
    process of a software system using platform-independent configuration files. It
    generates the required **makefiles** or **workspaces** needed for compiling a
    software library in your environment. Therefore, you need to download and install
    CMake. You can then run it using the command line, but it is easier to use CMake
    with its GUI (`cmake-gui`). In the latter case, all you need to do is specify
    the folder containing the OpenCV library source and the one that will contain
    the binaries. You need to click on **Configure** in order to select the compiler
    of your choice and then click on **Configure** again.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You are now ready to generate your project files by clicking on the **Generate**
    button. These files will allow you to compile the library. This is the last step
    of the installation process, which will make the library ready to be used under
    your development environment. For example, if you have selected Visual Studio,
    then all you need to do is to open the top-level solution file that CMake has
    created for you (most probably, the `OpenCV.sln` file). You then issue the `Build
    Solution` command in Visual Studio. To get both a `Release` and a `Debug` build,
    you will have to repeat the compilation process twice, one for each configuration.
    The `bin` directory that is created contains the dynamic library files that your
    executable will call at runtime. Make sure to set your system `PATH` environment
    variable from the control panel such that your operating system can find the `dll`
    files when you run your applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In Linux environments, you will use the generated makefiles by running your
    `make` utility command. To complete the installation of all the directories, you
    also have to run a `Build INSTALL` or `sudo make INSTALL` command.
  prefs: []
  type: TYPE_NORMAL
- en: However, before you build the libraries, make sure to check what the OpenCV
    installer has installed for you; the built library that you are looking for might
    already be there, which will save you the compilation step. If you wish to use
    Qt as your IDE, the *There's more...* section of this recipe describes an alternative
    way to compile the OpenCV project.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since Version 2.2, the OpenCV library is divided into several modules. These
    modules are built-in library files located in the `lib` directory. Some of the
    commonly-used modules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `opencv_core` module that contains the core functionalities of the library,
    in particular, basic data structures and arithmetic functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `opencv_imgproc` module that contains the main image processing functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `opencv_highgui` module that contains the image and video reading and writing
    functions along with some user interface functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `opencv_features2d` module that contains the feature point detectors and
    descriptors and the feature point matching framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `opencv_calib3d` module that contains the camera calibration, two-view geometry
    estimation, and stereo functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `opencv_video` module that contains the motion estimation, feature tracking,
    and foreground extraction functions and classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `opencv_objdetect` module that contains the object detection functions such
    as the face and people detectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library also includes other utility modules that contain machine learning
    functions (`opencv_ml`), computational geometry algorithms (`opencv_flann`), contributed
    code (`opencv_contrib`), obsolete code (`opencv_legacy`), and gpu-accelerated
    code (`opencv_gpu`). You will also find other specialized libraries that implement
    higher-level functions, such as `opencv_photo` for computational photography and
    `opencv_stitching` for image-stitching algorithms. There is also a library module,
    called `opencv_nonfree`, which contains functions that have a potential limitation
    in use. When you compile your application, you will have to link your program
    with the libraries that contain the OpenCV functions you are using. Most likely,
    these will be the first three functions of the list given previously plus some
    of the others depending on the scope of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these modules have a header file associated with them (located in the `include`
    directory). A typical OpenCV C++ code will, therefore, start by including the
    required modules. For example (and this is the suggested declaration style):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might see an OpenCV code starting with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is because it uses the old style, before the library was restructured into
    modules. Finally, note that OpenCV will be restructured in the future; so, if
    you download a more recent version than 2.4, you will probably not see the same
    module subdivision.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OpenCV website at [http://opencv.org/](http://opencv.org/) contains detailed
    instructions on how to install the library. It also contains a complete online
    documentation that includes several tutorials on the different components of the
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Using Qt for OpenCV developments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Qt is a cross-platform IDE for C++ applications developed as an open source
    project. It is offered under the LPGL open source license as well as under a commercial
    (and paid) license for the development of proprietary projects. It is composed
    of two separate elements: a cross-platform IDE called Qt creator and a set of
    Qt class libraries and development tools. Using Qt to develop C++ applications
    has the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It is an open source initiative developed by the Qt community, which gives you
    access to the source code of the different Qt components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a cross-platform IDE, meaning that you can develop applications that can
    run on different operating systems, such as Windows, Linux, Mac OS X, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It includes a complete and cross-platform GUI library that follows an effective
    object-oriented and event-driven model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt also includes several cross-platform libraries that help you to develop multimedia,
    graphics, databases, multithreading, web applications, and many other interesting
    building blocks useful for designing advanced applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download Qt from [http://qt-project.org/](http://qt-project.org/). When
    you install it, you will be offered the choice of different compilers. Under Windows,
    MinGW is an excellent alternative to the Visual Studio compilers.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the OpenCV library with Qt is particularly easy because it can read
    CMake files. Once OpenCV and CMake have been installed, simply select **Open File**
    or **Project...** from the Qt menu and open the `CMakeLists.txt` file that you
    will find under the `sources` directory of OpenCV. This will create an OpenCV
    project that you build using the `Build Project` Qt command.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Qt for OpenCV developments](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You might get a few warnings, but these are without consequences.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenCV developer site
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenCV is an open source project that welcomes user contributions. You can access
    the developer site at [http://code.opencv.org](http://code.opencv.org). Among
    other things, you can access the currently developed version of OpenCV. The community
    uses Git as their version control system. You then have to use it to check out
    the latest version of OpenCV. Git is also a free and open source software system;
    it is probably the best tool you can use to manage your own source code. You can
    download it from [http://git-scm.com/](http://git-scm.com/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: My website ([www.laganiere.name](http://www.laganiere.name)) also presents step-by-step
    instructions on how to install the latest versions of the OpenCV library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *There's more...* section of the next recipe explains how to create an OpenCV
    project with Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading, displaying, and saving images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is now time to run your first OpenCV application. Since OpenCV is about processing
    images, this task will show you how to perform the most fundamental operations
    needed in the development of imaging applications. These are loading an input
    image from a file, displaying an image on a window, applying a processing function,
    and storing an output image on a disk.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using your favorite IDE (for example, MS Visual Studio or Qt), create a new
    console application with a `main` function that is ready to be filled.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do is to include the header files, declaring the classes
    and functions you will use. Here, we simply want to display an image, so we need
    the core library that declares the image data structure and the `highgui` header
    file that contains all the graphical interface functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our main function starts by declaring a variable that will hold the image.
    Under OpenCV 2, define an object of the `cv::Mat` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This definition creates an image of the size `0 x 0`. This can be confirmed
    by accessing the `cv::Mat` size attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, a simple call to the reading function will read an image from the file,
    decode it, and allocate the memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You are now ready to use this image. However, you should first check whether
    the image has been correctly read (an error will occur if the file is not found,
    if the file is corrupted, or if it is not in a recognizable format). The validity
    of the image is tested using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `empty` method returns `true` if no image data has been allocated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you might want to do with this image is to display it. You
    can do this using the functions of the `highgui` module. Start by declaring the
    window on which you want to display the images, and then specify the image to
    be shown on this special window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the window is identified by a name. You can reuse this window
    to display another image later, or you can create multiple windows with different
    names. When you run this application, you will see an image window as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, you would normally apply some processing to the image. OpenCV offers a
    wide selection of processing functions, and several of them are explored in this
    book. Let''s start with a very simple one that flips an image horizontally. Several
    image transformations in OpenCV can be performed **in-place**, meaning that the
    transformation is applied directly on the input image (no new image is created).
    This is the case of the flipping method. However, we can always create another
    matrix to hold the output result, and that is what we will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is displayed on another window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since it is a console window that will terminate when it reaches the end of
    the `main` function, we add an extra `highgui` function to wait for a user key
    before ending the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then see that the output image is displayed on a distinct window, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, you will probably want to save the processed image on your disk. This
    is done using the following `highgui` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The file extension determines which codec will be used to save the image. Other
    popular supported image formats are JPG, TIFF, and PNG.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All classes and functions in the C++ API of OpenCV are defined within the `cv`
    namespace. You have two ways to access them. First, precede the `main` function''s
    definition with the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, prefix all OpenCV class and function names with the namespace
    specification, that is, `cv::`, as we will do so in this book. The use of this
    prefix makes the OpenCV classes and functions easier to identify.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `highgui` module contains a set of functions that allow you to easily visualize
    and interact with your images. When you load an image with the `imread` function,
    you also have the option to read it as a gray-level image. This is very advantageous
    since several computer vision algorithms require gray-level images. Converting
    an input color image on the fly as you read it will save you time and minimize
    your memory usage. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce an image made of unsigned bytes (`unsigned char` in C++)
    that OpenCV designates with the `CV_8U` defined constant. Alternatively, it is
    sometimes necessary to read an image as a 3-channel color image even if it has
    been saved as a gray-level image. This can be achieved by calling the `imread`
    function with a positive second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, an image made of 3 bytes per pixel will be created, designated as
    `CV_8UC3` in OpenCV. Of course, if your input image has been saved as a gray-level
    image, all three channels will contain the same value. Finally, if you wish to
    read the image in the format in which it has been saved, then simply input a negative
    value as the second argument. The number of channels in an image can be checked
    by using the `channels` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention when you open an image with `imread` without specifying a full
    path (as we did here). In that case, the default directory will be used. When
    you run your application from the console, this directory is obviously the one
    of your executable file. However, if you run the application directly from your
    IDE, the default directory will most often be the one that contains your project
    file. Consequently, make sure that your input image file is located in the right
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: When you use `imshow` to display an image made up of integers (designated as
    `CV_16U` for 16-bit unsigned integers, or as `CV_32S` for 32-bit signed integers),
    the pixel values of this image will be divided by 256 first, in an attempt to
    make it displayable with 256 gray shades. Similarly, an image made of floating
    points will be displayed by assuming a range of possible values between 0.0 (displayed
    as black) and 1.0 (displayed as white). Values outside this defined range are
    displayed in white (for values above 1.0) or black (for values below 1.0).
  prefs: []
  type: TYPE_NORMAL
- en: The `highgui` module is very useful to build quick prototypal applications.
    When you are ready to produce a finalized version of your application, you will
    probably want to use the GUI module offered by your IDE in order to build an application
    with a more professional look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, our application uses both input and output images. As an exercise, you
    should rewrite this simple program such that it takes advantage of the function''s
    in-place processing, that is, by not declaring the output image and writing it
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `highgui` module contains a rich set of functions that help you to interact
    with your images. Using these, your applications can react to mouse or key events.
    You can also draw shapes and write text on images.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can program your mouse to perform specific operations when it is over one
    of the image windows you created. This is done by defining an appropriate **callback**
    function. A callback function is a function that you do not explicitly call but
    which is called by your application in response to specific events (here, the
    events that concern the mouse interacting with an image window). To be recognized
    by applications, callback functions need to have a specific signature and must
    be registered. In the case of the mouse event handler, the callback function must
    have the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is an integer that is used to specify which type of mouse
    event has triggered the call to the callback function. The other two parameters
    are simply the pixel coordinates of the mouse location when the event occurred.
    The flags are used to determine which button was pressed when the mouse event
    was triggered. Finally, the last parameter is used to send an extra parameter
    to the function in the form of a pointer to any object. This callback function
    can be registered in the application through the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `onMouse` function is associated with the image window
    called **Original Image**, and the address of the displayed image is passed as
    an extra parameter to the function. Now, if we define the `onMouse` callback function
    as shown in the following code, then each time the mouse is clicked, the value
    of the corresponding pixel will be displayed on the console (here, we assume that
    it is a gray-level image):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that in order to obtain the pixel value at `(x,y)`, we used the `at` method
    of the `cv::Mat` object here; this has been discussed in [Chapter 2](part0019_split_000.html#page
    "Chapter 2. Manipulating Pixels"), *Manipulating Pixels*. Other possible events
    that can be received by the mouse event callback function include `CV_EVENT_MOUSEMOVE,
    CV_EVENT_LBUTTONUP`, `CV_EVENT_RBUTTONDOWN`, and `CV_EVENT_RBUTTONUP`.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing on images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OpenCV also offers a few functions to draw shapes and write text on images.
    The examples of basic shape-drawing functions are `circle`, `ellipse`, `line`,
    and `rectangle`. The following is an example of how to use the `circle` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cv::Point` structure is often used in OpenCV methods and functions to
    specify a pixel coordinate. Note that here we assume that the drawing is done
    on a gray-level image; this is why the color is specified with a single integer.
    In the next recipe, you will learn how to specify a color value in the case of
    color images that use the `cv::Scalar` structure. It is also possible to write
    text on an image. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling these two functions on our test image will then result in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing on images](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Running the example with Qt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you wish to use Qt to run your OpenCV applications, you will need to create
    project files. For the example of this recipe, here is how the project file (`loadDisplaySave.pro`)
    will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This file shows you where to find the `include and library` files. It also lists
    the library modules that are used by the example. Make sure to use the library
    binaries compatible with the compiler that Qt is using. Note that if you download
    the source code of the examples of this book, you will find the `CMakeLists` files
    that you can open with Qt (or CMake) in order to create the associated projects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `cv::Mat` class is the data structure that is used to hold your images (and
    obviously, other matrix data). This data structure is at the core of all OpenCV
    classes and functions; the next recipe offers a detailed explanation of this data
    structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the source code of the examples of this book from [https://github.com/laganiere/](https://github.com/laganiere/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the cv::Mat data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, you were introduced to the `cv::Mat` data structure.
    As mentioned, this is a key element of the library. It is used to manipulate images
    and matrices (in fact, an image is a matrix from a computational and mathematical
    point of view). Since you will be using this data structure extensively in your
    application developments, it is imperative that you become familiar with it. Notably,
    you will learn in this recipe that this data structure incorporates an elegant
    memory management mechanism, allowing efficient usage.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write the following test program that will allow us to test the different
    properties of the `cv::Mat` data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this program and take a look at the following images produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `cv::Mat` data structure is essentially made up of two parts: a header
    and a data block. The header contains all the information associated with the
    matrix (size, number of channels, data type, and so on). The previous recipe showed
    you how to access some of the attributes of this structure contained in its header
    (for example, by using `cols`, `rows`, or `channels`). The data block holds all
    the pixel values of an image. The header contains a pointer variable that points
    to this data block; it is the `data` attribute. An important property of the `cv::Mat`
    data structure is the fact that the memory block is only copied when explicitly
    requested for. Indeed, most operations will simply copy the `cv::Mat` header such
    that multiple objects will point to the same data block at the same time. This
    memory management model makes your applications more efficient while avoiding
    memory leaks, but its consequences have to be understood. The examples of this
    recipe illustrate this fact.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `cv::Mat` objects have a zero size when they are created, but
    you can also specify an initial size as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you also need to specify the type of each matrix element; `CV_8U`
    here, which corresponds to 1-byte pixel images. The letter `U` means it is unsigned.
    You can also declare signed numbers by using the letter `S`. For a color image,
    you would specify three channels (`CV_8UC3`). You can also declare integers (signed
    or unsigned) of size 16 and 32 (for example, `CV_16SC3`). You also have access
    to 32-bit and 64-bit floating-point numbers (for example, `CV_32F`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each element of an image (or a matrix) can be composed of more than one value
    (for example, the three channels of a color image); therefore, OpenCV has introduced
    a simple data structure that is used when pixel values are passed to functions.
    It is the `cv::Scalar` structure, which is generally used to hold one value or
    three values. For example, to create a color image initialized with red pixels,
    you will write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the initialization of the gray-level image could also have been done
    using this structure by writing `cv::Scalar(100)`.
  prefs: []
  type: TYPE_NORMAL
- en: The image size also often needs to be passed to functions. We have already mentioned
    that the `cols` and `rows` attributes can be used to get the dimensions of a `cv::Mat`
    instance. The size information can also be provided through the `cv::Size` structure
    that simply contains the height and width of the matrix. The `size()` method allows
    you to obtain the current matrix size. This is the format that is used in many
    methods where a matrix size must be specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, an image could be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The data block of an image can always be allocated or re-allocated using the
    `create` method. When an image has been previously allocated, its old content
    is de-allocated first. For reasons of efficiency, if the new proposed size and
    type matches the already existing size and type, then no new memory allocation
    is performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When no more references point to a given `cv::Mat` object, the allocated memory
    is automatically released. This is very convenient because it avoids the common
    memory leak problems often associated with dynamic memory allocation in C++. This
    is a key mechanism in OpenCV 2 that is accomplished by having the `cv::Mat` class
    implement reference counting and shallow copy. Therefore, when an image is assigned
    to another one, the image data (that is, the pixels) is not copied; both the images
    will point to the same memory block. This also applies to images passed by value
    or returned by value. A reference count is kept such that the memory will be released
    only when all the references to the image will be destructed or assigned to another
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Any transformation applied to one of the preceding images will also affect
    the other images. If you wish to create a deep copy of the content of an image,
    use the `copyTo` method. In that case, the `create` method is called on the destination
    image. Another method that produces a copy of an image is the `clone` method,
    which creates a new identical image as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to copy an image into another image that does not necessarily have
    the same data type, you have to use the `convertTo` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the source image is copied into a floating-point image. The
    method includes two optional parameters: a scaling factor and an offset. Note
    that both the images must, however, have the same number of channels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The allocation model for the `cv::Mat` objects also allows you to safely write
    functions (or class methods) that return an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also call this function from our `main` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If we do this, then the `gray` variable will now hold the image created by the
    function without extra memory allocation. Indeed, as we explained, only a shallow
    copy of the image will be transferred from the returned `cv::Mat` instance to
    the `gray` image. When the `ima` local variable goes out of scope, this variable
    is de-allocated, but since the associated reference counter indicates that its
    internal image data is being referred to by another instance (that is, the `gray`
    variable), its memory block is not released.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting that in the case of classes, you should be careful and not
    return image class attributes. Here is an example of an error-prone implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, if a function calls the method of this class, it obtains a shallow copy
    of the image attributes. If later this copy is modified, the `class` attribute
    will also be surreptitiously modified, which can affect the subsequent behavior
    of the class (and vice versa). To avoid these kinds of errors, you should instead
    return a clone of the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are manipulating the `cv::Mat` class, you will discover that OpenCV
    also includes several other related classes. It will be important for you to become
    familiar with them.
  prefs: []
  type: TYPE_NORMAL
- en: The input and output arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you look at the OpenCV documentation, you will see that many methods and
    functions accept parameters of the `cv::InputArray` type as the input. This type
    is a simple proxy class introduced to generalize the concept of arrays in OpenCV,
    and thus avoid the duplication of several versions of the same method or function
    with different input parameter types. It basically means that you can supply a
    `cv::Mat` object or other compatible types as an argument. This class is just
    an interface, so you should never declare it explicitly in your code. It is interesting
    to know that `cv::InputArray` can also be constructed from the popular `std::vector`
    class. This means that such objects can be used as the input to OpenCV methods
    and functions (as long as it makes sense to do so). Other compatible types are
    the `cv::Scalar` and the `cv::Vec`; this later structure will be presented in
    the next chapter. There is also a `cv::OutputArray` proxy class that is used to
    designate the arrays returned by some methods or functions.
  prefs: []
  type: TYPE_NORMAL
- en: The old IplImage structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With Version 2 of OpenCV, a new C++ interface has been introduced. Previously,
    C-like functions and structures were used (and can still be used). In particular,
    images were manipulated using the `IplImage` structure. This structure was inherited
    from the **IPL** library (that is, the **Intel Image Processing** library), now
    integrated with the **IPP** library (the **Intel Integrated Performance Primitive**
    library). If you use the code and libraries that have been created with the old
    C interface, you might need to manipulate those `IplImage` structures. Fortunately,
    there is a convenient way to convert an `IplImage` structure into a `cv::Mat`
    object, which is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cvLoadImage` function is the C-interface function to load images. The
    second parameter in the constructor of the `cv::Mat` object indicates that the
    data will not be copied (set this to `true` if you want a new copy; `false` is
    the default value, so it could have been omitted), that is, both `IplImage` and
    `image` will share the same image data. Here, you need to be careful to not create
    dangling pointers. For this reason, it is safer to encapsulate the `IplImage`
    pointer in the reference-counting pointer class provided by OpenCV 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, if you need to de-allocate the memory pointed out by your `IplImage`
    structure, you need to do it explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you should avoid using this deprecated data structure. Instead,
    always use the `cv::Mat` data structure.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complete OpenCV documentation can be found at [http://docs.opencv.org/](http://docs.opencv.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 2](part0019_split_000.html#page "Chapter 2. Manipulating Pixels"),
    *Manipulating Pixels*, will show you how to efficiently access and modify the
    pixel values of an image represented by the `cv::Mat` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next recipe, which will explain how to define a region of interest inside
    an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining regions of interest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, a processing function needs to be applied only to a portion of an
    image. OpenCV incorporates an elegant and simple mechanism to define a subregion
    in an image and manipulate it as a regular image. This recipe will teach you how
    to define a region of interest inside an image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we want to copy a small image onto a larger one. For example, let''s
    say we want to insert the following small logo in our test image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To do this, a **Region Of Interest** (**ROI**) can be defined over which the
    copy operation can be applied. As we will see, the position of the ROI will determine
    where the logo will be inserted in the image.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step consists of defining the ROI. Once defined, the ROI can be manipulated
    as a regular `cv::Mat` instance. The key is that the ROI is indeed a `cv::Mat`
    object that points to the same data buffer as its parent image and has a header
    that specifies the coordinates of the ROI. Inserting the logo would then be accomplished
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `image` is the destination image, and `logo` is the logo image (of a
    smaller size). The following image is then obtained by executing the previous
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to define an ROI is to use a `cv::Rect` instance. As the name indicates,
    it describes a rectangular region by specifying the position of the upper-left
    corner (the first two parameters of the constructor) and the size of the rectangle
    (the width and height are given in the last two parameters). In our example, we
    used the size of the image and the size of the logo in order to determine the
    position where the logo would cover the bottom-right corner of the image. Obviously,
    the ROI should always be completely inside the parent image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ROI can also be described using row and column ranges. A range is a continuous
    sequence from a start index to an end index (excluding both). The `cv::Range`
    structure is used to represent this concept. Therefore, an ROI can be defined
    from two ranges; in our example, the ROI could have been equivalently defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `operator()` function of `cv ::Mat` returns another `cv::Mat`
    instance that can then be used in subsequent calls. Any transformation of the
    ROI will affect the original image in the corresponding area because the image
    and the ROI share the same image data. Since the definition of an ROI does not
    include the copying of data, it is executed in a constant amount of time, no matter
    the size of the ROI.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to define an ROI made of some lines of an image, the following
    call can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for an ROI made of some image columns, the following can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OpenCV methods and functions include many optional parameters that are not
    discussed in the recipes of this book. When you wish to use a function for the
    first time, you should always take the time to look at the documentation to learn
    more about the possible options that this function offers. One very common option
    is the possibility to define image masks.
  prefs: []
  type: TYPE_NORMAL
- en: Using image masks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some OpenCV operations allow you to define a mask that will limit the applicability
    of a given function or method, which is normally supposed to operate on all the
    image pixels. A mask is an 8-bit image that should be nonzero at all locations
    where you want an operation to be applied. At the pixel locations that correspond
    to the zero values of the mask, the image is untouched. For example, the `copyTo`
    method can be called with a mask. We can use it here to copy only the white portion
    of the logo shown previously, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image is obtained by executing the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using image masks](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The background of our logo was black (therefore, it had the value 0); therefore,
    it was easy to use it as both the copied image and the mask. Of course, you can
    define the mask of your choice in your application; most OpenCV pixel-based operations
    give you the opportunity to use masks.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `row` and `col` methods that will be used in the *Scanning an image with
    neighbor access* recipe of [Chapter 2](part0019_split_000.html#page "Chapter 2. Manipulating
    Pixels"), *Manipulating Pixels*. These are a special case of the `rowRange` and
    `colRange` methods in which the start and end indexes are equal in order to define
    a single-line or single-column ROI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
