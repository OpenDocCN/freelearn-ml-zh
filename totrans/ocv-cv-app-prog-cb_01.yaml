- en: Chapter 1. Playing with Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 玩转图像
- en: 'In this chapter, we will get you started with the `OpenCV` library. You will
    learn how to perform the following tasks:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将带你开始使用 `OpenCV` 库。你将学习如何执行以下任务：
- en: Installing the OpenCV library
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 OpenCV 库
- en: Loading, displaying, and saving images
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载、显示和保存图像
- en: Exploring the cv::Mat data structure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 cv::Mat 数据结构
- en: Defining regions of interest
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义感兴趣区域
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'This chapter will teach you the basic elements of OpenCV and will show you
    how to accomplish the most fundamental image processing tasks: reading, displaying,
    and saving images. However, before you can start with OpenCV, you need to install
    the library. This is a simple process that is explained in the first recipe of
    this chapter.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教授你 OpenCV 的基本元素，并展示如何完成最基本图像处理任务：读取、显示和保存图像。然而，在开始使用 OpenCV 之前，你需要安装这个库。这是一个简单的过程，在第一章的第一个菜谱中有解释。
- en: All your computer vision applications will involve the processing of images.
    This is why the most fundamental tool that OpenCV offers you is a data structure
    to handle images and matrices. It is a powerful data structure, with many useful
    attributes and methods. It also incorporates an advanced memory management model
    that greatly facilitates the development of applications. The last two recipes
    of this chapter will teach you how to use this important data structure of OpenCV.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你所有的计算机视觉应用程序都将涉及图像的处理。这就是为什么 OpenCV 提供给你的最基本工具是一个用于处理图像和矩阵的数据结构。这是一个功能强大的数据结构，具有许多有用的属性和方法。它还包含一个高级内存管理模型，这极大地简化了应用程序的开发。本章的最后两个菜谱将教你如何使用这个重要的
    OpenCV 数据结构。
- en: Installing the OpenCV library
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 OpenCV 库
- en: OpenCV is an open source library for developing computer vision applications
    that run on Windows, Linux, Android, and Mac OS. It can be used in both academic
    and commercial applications under a BSD license that allows you to freely use,
    distribute, and adapt it. This recipe will show you how to install the library
    on your machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 是一个开源库，用于开发在 Windows、Linux、Android 和 Mac OS 上运行的计算机视觉应用程序。它可以在学术和商业应用程序下使用
    BSD 许可证，该许可证允许你自由使用、分发和修改它。本菜谱将向你展示如何在你的机器上安装库。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: When you visit the OpenCV official website at [http://opencv.org/](http://opencv.org/),
    you will find the latest release of the library, the online documentation, and
    many other useful resources on OpenCV.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问 OpenCV 官方网站 [http://opencv.org/](http://opencv.org/) 时，你将找到库的最新版本、在线文档以及许多其他关于
    OpenCV 的有用资源。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'From the OpenCV website, go to the **DOWNLOADS** page that corresponds to the
    platform of your choice (Unix/Windows or Android). From there, you will be able
    to download the OpenCV package. You will then need to uncompress it, normally
    under a directory with a name that corresponds to the library version (for example,
    in Windows, you can save the uncompressed directory under `C:\OpenCV2.4.9`). Once
    this is done, you will find a collection of files and directories that constitute
    the library at the chosen location. Notably, you will find the `sources` directory
    here, which contains all the source files. (Yes, it is open source!) However,
    in order to complete the installation of the library and have it ready for use,
    you need to undertake an additional step: generating the binary files of the library
    for the environment of your choice. This is indeed the point where you have to
    make a decision on the target platform that you will use to create your OpenCV
    applications. Which operating system should you use? Windows or Linux? Which compiler
    should you use? Microsoft VS2013 or MinGW? 32-bit or 64-bit? The **Integrated
    Development Environment** (**IDE**) that you will use in your project development
    will also guide you to make these choices.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从 OpenCV 网站进入对应你选择平台（Unix/Windows 或 Android）的 **下载** 页面。从那里，你可以下载 OpenCV 软件包。然后你需要解压它，通常在一个与库版本相对应的目录下（例如，在
    Windows 中，你可以在 `C:\OpenCV2.4.9` 下保存未解压的目录）。完成此操作后，你将在选择的位置找到构成库的文件和目录集合。值得注意的是，你将在这里找到
    `sources` 目录，它包含所有源文件。（是的，它是开源的！）然而，为了完成库的安装并使其准备好使用，你需要进行一个额外的步骤：为你的选择环境生成库的二进制文件。这确实是你要决定将用于创建你的
    OpenCV 应用程序的目标平台的时候。你应该使用哪个操作系统？Windows 还是 Linux？你应该使用哪个编译器？Microsoft VS2013 还是
    MinGW？32 位还是 64 位？你将在项目开发中使用的 **集成开发环境**（**IDE**）也将指导你做出这些选择。
- en: Note that if you are working under Windows with Visual Studio, the executable
    installation package will, most probably, not only install the library sources,
    but also install all of the precompiled binaries needed to build your applications.
    Check for the `build` directory; it should contain the `x64` and `x86` subdirectories
    (corresponding to the 64-bit and 32-bit versions). Within these subdirectories,
    you should find directories such as `vc10`, `vc11`, and `vc12`; these contain
    the binaries for the different versions of MS Visual Studio. In that case, you
    are ready to start using OpenCV. Therefore, you can skip the compilation step
    described in this recipe, unless you want a customized build with specific options.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你在Windows操作系统下使用Visual Studio进行工作，可执行安装包很可能会不仅安装库源代码，还会安装构建你的应用程序所需的所有预编译的二进制文件。请检查`build`目录；它应该包含`x64`和`x86`子目录（对应64位和32位版本）。在这些子目录中，你应该找到如`vc10`、`vc11`和`vc12`这样的目录；这些目录包含不同版本MS
    Visual Studio的二进制文件。在这种情况下，你就可以开始使用OpenCV了。因此，你可以跳过本食谱中描述的编译步骤，除非你想使用特定选项进行定制构建。
- en: To complete the installation process and build the OpenCV binaries, you need
    to use the **CMake** tool, available at [http://cmake.org](http://cmake.org).
    CMake is another open source software tool designed to control the compilation
    process of a software system using platform-independent configuration files. It
    generates the required **makefiles** or **workspaces** needed for compiling a
    software library in your environment. Therefore, you need to download and install
    CMake. You can then run it using the command line, but it is easier to use CMake
    with its GUI (`cmake-gui`). In the latter case, all you need to do is specify
    the folder containing the OpenCV library source and the one that will contain
    the binaries. You need to click on **Configure** in order to select the compiler
    of your choice and then click on **Configure** again.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成安装过程并构建OpenCV的二进制文件，你需要使用可在[http://cmake.org](http://cmake.org)找到的**CMake**工具。CMake是另一个开源软件工具，它使用平台无关的配置文件来控制软件系统的编译过程。它为你生成编译软件库所需的环境中的**makefiles**或**工作空间**。因此，你需要下载并安装CMake。然后你可以通过命令行运行它，但使用CMake的GUI（`cmake-gui`）会更简单。在后一种情况下，你只需要指定包含OpenCV库源代码的文件夹和将包含二进制文件的文件夹。你需要点击**Configure**来选择你选择的编译器，然后再次点击**Configure**。
- en: '![How to do it...](img/00002.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00002.jpeg)'
- en: You are now ready to generate your project files by clicking on the **Generate**
    button. These files will allow you to compile the library. This is the last step
    of the installation process, which will make the library ready to be used under
    your development environment. For example, if you have selected Visual Studio,
    then all you need to do is to open the top-level solution file that CMake has
    created for you (most probably, the `OpenCV.sln` file). You then issue the `Build
    Solution` command in Visual Studio. To get both a `Release` and a `Debug` build,
    you will have to repeat the compilation process twice, one for each configuration.
    The `bin` directory that is created contains the dynamic library files that your
    executable will call at runtime. Make sure to set your system `PATH` environment
    variable from the control panel such that your operating system can find the `dll`
    files when you run your applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过点击**Generate**按钮来生成你的项目文件。这些文件将允许你编译库。这是安装过程的最后一步，它将使库在你的开发环境中准备好使用。例如，如果你选择了Visual
    Studio，那么你只需要打开CMake为你创建的顶级解决方案文件（最可能是`OpenCV.sln`文件）。然后你在Visual Studio中发出`Build
    Solution`命令。为了得到`Release`和`Debug`两种构建，你将不得不重复编译过程两次，一次针对每个配置。创建的`bin`目录包含你的可执行文件在运行时将调用的动态库文件。请确保从控制面板设置你的系统`PATH`环境变量，以便你的操作系统可以在你运行应用程序时找到`dll`文件。
- en: '![How to do it...](img/00003.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00003.jpeg)'
- en: In Linux environments, you will use the generated makefiles by running your
    `make` utility command. To complete the installation of all the directories, you
    also have to run a `Build INSTALL` or `sudo make INSTALL` command.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux环境中，你将通过运行你的`make`实用工具命令来使用生成的makefiles。为了完成所有目录的安装，你还需要运行`Build INSTALL`或`sudo
    make INSTALL`命令。
- en: However, before you build the libraries, make sure to check what the OpenCV
    installer has installed for you; the built library that you are looking for might
    already be there, which will save you the compilation step. If you wish to use
    Qt as your IDE, the *There's more...* section of this recipe describes an alternative
    way to compile the OpenCV project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在您构建库之前，请确保检查 OpenCV 安装程序为您安装了什么；您正在寻找的构建库可能已经存在，这将节省您编译步骤。如果您希望使用 Qt 作为您的
    IDE，本食谱的 “更多...” 部分描述了编译 OpenCV 项目的另一种方法。
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Since Version 2.2, the OpenCV library is divided into several modules. These
    modules are built-in library files located in the `lib` directory. Some of the
    commonly-used modules are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2.2 版本以来，OpenCV 库被分为几个模块。这些模块是位于 `lib` 目录中的内置库文件。以下是一些常用模块：
- en: The `opencv_core` module that contains the core functionalities of the library,
    in particular, basic data structures and arithmetic functions
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含库的核心功能，特别是基本数据结构和算术函数的 `opencv_core` 模块
- en: The `opencv_imgproc` module that contains the main image processing functions
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含主要图像处理函数的 `opencv_imgproc` 模块
- en: The `opencv_highgui` module that contains the image and video reading and writing
    functions along with some user interface functions
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含图像和视频读写函数以及一些用户界面函数的 `opencv_highgui` 模块
- en: The `opencv_features2d` module that contains the feature point detectors and
    descriptors and the feature point matching framework
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含特征点检测器、描述符和特征点匹配框架的 `opencv_features2d` 模块
- en: The `opencv_calib3d` module that contains the camera calibration, two-view geometry
    estimation, and stereo functions
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含相机标定、双视图几何估计和立体功能的 `opencv_calib3d` 模块
- en: The `opencv_video` module that contains the motion estimation, feature tracking,
    and foreground extraction functions and classes
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含运动估计、特征跟踪和前景提取函数和类的 `opencv_video` 模块
- en: The `opencv_objdetect` module that contains the object detection functions such
    as the face and people detectors
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含人脸和人物检测等对象检测函数的 `opencv_objdetect` 模块
- en: The library also includes other utility modules that contain machine learning
    functions (`opencv_ml`), computational geometry algorithms (`opencv_flann`), contributed
    code (`opencv_contrib`), obsolete code (`opencv_legacy`), and gpu-accelerated
    code (`opencv_gpu`). You will also find other specialized libraries that implement
    higher-level functions, such as `opencv_photo` for computational photography and
    `opencv_stitching` for image-stitching algorithms. There is also a library module,
    called `opencv_nonfree`, which contains functions that have a potential limitation
    in use. When you compile your application, you will have to link your program
    with the libraries that contain the OpenCV functions you are using. Most likely,
    these will be the first three functions of the list given previously plus some
    of the others depending on the scope of your application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该库还包括其他实用模块，这些模块包含机器学习函数（`opencv_ml`）、计算几何算法（`opencv_flann`）、贡献代码（`opencv_contrib`）、过时代码（`opencv_legacy`）和
    GPU 加速代码（`opencv_gpu`）。您还会找到其他专门库，它们实现了更高级的功能，例如 `opencv_photo` 用于计算摄影和 `opencv_stitching`
    用于图像拼接算法。还有一个名为 `opencv_nonfree` 的库模块，其中包含在使用上可能存在潜在限制的函数。当您编译应用程序时，您必须将程序链接到包含您使用的
    OpenCV 函数的库。很可能是前面列出的前三个函数以及一些其他函数，具体取决于您应用程序的范围。
- en: 'All these modules have a header file associated with them (located in the `include`
    directory). A typical OpenCV C++ code will, therefore, start by including the
    required modules. For example (and this is the suggested declaration style):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些模块都与它们相关的头文件相关联（位于 `include` 目录中）。因此，典型的 OpenCV C++ 代码将首先包含所需的模块。例如（这是建议的声明风格）：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册以直接将文件通过电子邮件发送给您。
- en: 'You might see an OpenCV code starting with the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会看到以下命令开始的 OpenCV 代码：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is because it uses the old style, before the library was restructured into
    modules. Finally, note that OpenCV will be restructured in the future; so, if
    you download a more recent version than 2.4, you will probably not see the same
    module subdivision.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为它使用了旧式风格，在库被重构为模块之前。最后，请注意，OpenCV将来将会进行重构；因此，如果你下载的版本比2.4更新，你可能不会看到相同的模块划分。
- en: There's more...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The OpenCV website at [http://opencv.org/](http://opencv.org/) contains detailed
    instructions on how to install the library. It also contains a complete online
    documentation that includes several tutorials on the different components of the
    library.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV网站[http://opencv.org/](http://opencv.org/)包含了关于如何安装库的详细说明。它还包含了一份完整的在线文档，其中包括关于库不同组件的几个教程。
- en: Using Qt for OpenCV developments
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Qt进行OpenCV开发
- en: 'Qt is a cross-platform IDE for C++ applications developed as an open source
    project. It is offered under the LPGL open source license as well as under a commercial
    (and paid) license for the development of proprietary projects. It is composed
    of two separate elements: a cross-platform IDE called Qt creator and a set of
    Qt class libraries and development tools. Using Qt to develop C++ applications
    has the following benefits:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Qt是一个用于C++应用程序的跨平台IDE，作为一个开源项目开发。它提供LPGL开源许可证以及商业（付费）许可证，用于开发专有项目。它由两个独立的元素组成：一个名为Qt
    Creator的跨平台IDE以及一组Qt类库和开发工具。使用Qt开发C++应用程序有以下好处：
- en: It is an open source initiative developed by the Qt community, which gives you
    access to the source code of the different Qt components
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个由Qt社区开发的开源倡议，它为你提供了访问不同Qt组件源代码的权限。
- en: It is a cross-platform IDE, meaning that you can develop applications that can
    run on different operating systems, such as Windows, Linux, Mac OS X, and so on
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个跨平台IDE，这意味着你可以开发可以在不同操作系统上运行的应用程序，例如Windows、Linux、Mac OS X等。
- en: It includes a complete and cross-platform GUI library that follows an effective
    object-oriented and event-driven model
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含了一个完整且跨平台的GUI库，遵循有效的面向对象和事件驱动模型。
- en: Qt also includes several cross-platform libraries that help you to develop multimedia,
    graphics, databases, multithreading, web applications, and many other interesting
    building blocks useful for designing advanced applications
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt还包括几个跨平台库，这些库可以帮助你开发多媒体、图形、数据库、多线程、Web应用程序以及许多其他用于设计高级应用程序的有趣构建块。
- en: You can download Qt from [http://qt-project.org/](http://qt-project.org/). When
    you install it, you will be offered the choice of different compilers. Under Windows,
    MinGW is an excellent alternative to the Visual Studio compilers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[http://qt-project.org/](http://qt-project.org/)下载Qt。当你安装它时，你会被提供选择不同编译器的选项。在Windows下，MinGW是Visual
    Studio编译器的优秀替代品。
- en: Compiling the OpenCV library with Qt is particularly easy because it can read
    CMake files. Once OpenCV and CMake have been installed, simply select **Open File**
    or **Project...** from the Qt menu and open the `CMakeLists.txt` file that you
    will find under the `sources` directory of OpenCV. This will create an OpenCV
    project that you build using the `Build Project` Qt command.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Qt编译OpenCV库特别容易，因为它可以读取CMake文件。一旦安装了OpenCV和CMake，只需从Qt菜单中选择**打开文件**或**项目...**，然后打开你将在OpenCV的`sources`目录下找到的`CMakeLists.txt`文件。这将创建一个OpenCV项目，你可以使用Qt的`构建项目`命令来构建它。
- en: '![Using Qt for OpenCV developments](img/00004.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![使用Qt进行OpenCV开发](img/00004.jpeg)'
- en: You might get a few warnings, but these are without consequences.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会得到一些警告，但这些没有后果。
- en: The OpenCV developer site
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenCV开发者网站
- en: OpenCV is an open source project that welcomes user contributions. You can access
    the developer site at [http://code.opencv.org](http://code.opencv.org). Among
    other things, you can access the currently developed version of OpenCV. The community
    uses Git as their version control system. You then have to use it to check out
    the latest version of OpenCV. Git is also a free and open source software system;
    it is probably the best tool you can use to manage your own source code. You can
    download it from [http://git-scm.com/](http://git-scm.com/).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV是一个开源项目，欢迎用户贡献。你可以在[http://code.opencv.org](http://code.opencv.org)访问开发者网站。在其他方面，你可以访问目前正在开发的OpenCV版本。社区使用Git作为他们的版本控制系统。然后你必须使用它来检出OpenCV的最新版本。Git也是一个免费的开源软件系统；它可能是你可以用来管理你自己的源代码的最佳工具。你可以从[http://git-scm.com/](http://git-scm.com/)下载它。
- en: See also
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: My website ([www.laganiere.name](http://www.laganiere.name)) also presents step-by-step
    instructions on how to install the latest versions of the OpenCV library
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的网站 ([www.laganiere.name](http://www.laganiere.name)) 也展示了如何逐步安装 OpenCV 库的最新版本
- en: The *There's more...* section of the next recipe explains how to create an OpenCV
    project with Qt
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个菜谱的 *还有更多...* 部分解释了如何使用 Qt 创建 OpenCV 项目
- en: Loading, displaying, and saving images
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载、显示和保存图像
- en: It is now time to run your first OpenCV application. Since OpenCV is about processing
    images, this task will show you how to perform the most fundamental operations
    needed in the development of imaging applications. These are loading an input
    image from a file, displaying an image on a window, applying a processing function,
    and storing an output image on a disk.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候运行你的第一个 OpenCV 应用程序了。由于 OpenCV 是关于图像处理的，这个任务将向你展示如何在图像应用程序开发中执行最基本操作。这些操作包括从文件中加载输入图像，在窗口中显示图像，应用处理函数，以及在磁盘上存储输出图像。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Using your favorite IDE (for example, MS Visual Studio or Qt), create a new
    console application with a `main` function that is ready to be filled.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你喜欢的 IDE（例如，MS Visual Studio 或 Qt），创建一个新的控制台应用程序，其中包含一个准备填充的 `main` 函数。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The first thing to do is to include the header files, declaring the classes
    and functions you will use. Here, we simply want to display an image, so we need
    the core library that declares the image data structure and the `highgui` header
    file that contains all the graphical interface functions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是包含头文件，声明你将使用的类和函数。在这里，我们只想显示一个图像，因此我们需要包含声明图像数据结构的核心库和包含所有图形界面函数的 `highgui`
    头文件：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our main function starts by declaring a variable that will hold the image.
    Under OpenCV 2, define an object of the `cv::Mat` class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主函数首先声明一个将保存图像的变量。在 OpenCV 2 中，定义 `cv::Mat` 类的对象：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This definition creates an image of the size `0 x 0`. This can be confirmed
    by accessing the `cv::Mat` size attributes:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义创建了一个大小为 `0 x 0` 的图像。这可以通过访问 `cv::Mat` 的大小属性来确认：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, a simple call to the reading function will read an image from the file,
    decode it, and allocate the memory:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一个简单的读取函数调用将从一个文件中读取图像，对其进行解码，并分配内存：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You are now ready to use this image. However, you should first check whether
    the image has been correctly read (an error will occur if the file is not found,
    if the file is corrupted, or if it is not in a recognizable format). The validity
    of the image is tested using the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用这个图像了。然而，你应该首先检查图像是否被正确读取（如果文件找不到，如果文件损坏，或者如果它不是可识别的格式，将发生错误）。图像的有效性通过以下代码进行测试：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `empty` method returns `true` if no image data has been allocated.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`empty` 方法在未分配任何图像数据时返回 `true`。'
- en: 'The first thing you might want to do with this image is to display it. You
    can do this using the functions of the `highgui` module. Start by declaring the
    window on which you want to display the images, and then specify the image to
    be shown on this special window:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先想用这个图像做的是显示它。你可以使用 `highgui` 模块中的函数来完成这个操作。首先，声明你想要显示图像的窗口，然后指定要在该特殊窗口上显示的图像：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, the window is identified by a name. You can reuse this window
    to display another image later, or you can create multiple windows with different
    names. When you run this application, you will see an image window as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，窗口是通过名称来标识的。你可以重用这个窗口来稍后显示另一个图像，或者你可以创建具有不同名称的多个窗口。当你运行这个应用程序时，你会看到一个图像窗口，如下所示：
- en: '![How to do it...](img/00005.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00005.jpeg)'
- en: 'Now, you would normally apply some processing to the image. OpenCV offers a
    wide selection of processing functions, and several of them are explored in this
    book. Let''s start with a very simple one that flips an image horizontally. Several
    image transformations in OpenCV can be performed **in-place**, meaning that the
    transformation is applied directly on the input image (no new image is created).
    This is the case of the flipping method. However, we can always create another
    matrix to hold the output result, and that is what we will do:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你通常会对此图像应用一些处理。OpenCV 提供了广泛的处理函数，本书中探讨了其中的一些。让我们从一个非常简单的例子开始，这个例子可以水平翻转图像。OpenCV
    中的几个图像变换可以在**原地**执行，这意味着变换直接应用于输入图像（不会创建新图像）。翻转方法就是这种情况。然而，我们总是可以创建另一个矩阵来保存输出结果，这正是我们将要做的：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result is displayed on another window:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在另一个窗口中显示：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since it is a console window that will terminate when it reaches the end of
    the `main` function, we add an extra `highgui` function to wait for a user key
    before ending the program:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个在到达`main`函数的末尾时会终止的控制台窗口，我们在程序结束前添加了一个额外的`highgui`函数来等待用户按键：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can then see that the output image is displayed on a distinct window, as
    shown in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注意到，输出图像显示在一个独立的窗口中，如下面的截图所示：
- en: '![How to do it...](img/00006.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/00006.jpeg)'
- en: 'Finally, you will probably want to save the processed image on your disk. This
    is done using the following `highgui` function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能想要将处理后的图像保存到你的磁盘上。这是使用以下`highgui`函数完成的：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The file extension determines which codec will be used to save the image. Other
    popular supported image formats are JPG, TIFF, and PNG.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 文件扩展名决定了将使用哪个编解码器来保存图像。其他流行的支持图像格式包括JPG、TIFF和PNG。
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'All classes and functions in the C++ API of OpenCV are defined within the `cv`
    namespace. You have two ways to access them. First, precede the `main` function''s
    definition with the following declaration:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV的C++ API中的所有类和函数都在`cv`命名空间内定义。你有两种方法可以访问它们。首先，在`main`函数的定义之前加上以下声明：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Alternatively, prefix all OpenCV class and function names with the namespace
    specification, that is, `cv::`, as we will do so in this book. The use of this
    prefix makes the OpenCV classes and functions easier to identify.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用命名空间指定来前缀所有OpenCV类和函数名，即`cv::`，正如我们将在本书中所做的那样。使用这个前缀可以使OpenCV类和函数更容易识别。
- en: 'The `highgui` module contains a set of functions that allow you to easily visualize
    and interact with your images. When you load an image with the `imread` function,
    you also have the option to read it as a gray-level image. This is very advantageous
    since several computer vision algorithms require gray-level images. Converting
    an input color image on the fly as you read it will save you time and minimize
    your memory usage. This can be done as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`highgui`模块包含一系列函数，允许你轻松地可视化和与你的图像交互。当你使用`imread`函数加载图像时，你也可以选择将其作为灰度图像读取。这非常有优势，因为许多计算机视觉算法需要灰度图像。在读取图像时即时转换输入的彩色图像可以节省你的时间并最小化你的内存使用。这可以通过以下方式完成：'
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will produce an image made of unsigned bytes (`unsigned char` in C++)
    that OpenCV designates with the `CV_8U` defined constant. Alternatively, it is
    sometimes necessary to read an image as a 3-channel color image even if it has
    been saved as a gray-level image. This can be achieved by calling the `imread`
    function with a positive second argument:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个由无符号字节（C++中的`unsigned char`）组成的图像，OpenCV使用定义的常量`CV_8U`来指定。或者，有时即使图像被保存为灰度图像，也必须以3通道彩色图像的形式读取图像。这可以通过调用带有正第二个参数的`imread`函数来实现：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This time, an image made of 3 bytes per pixel will be created, designated as
    `CV_8UC3` in OpenCV. Of course, if your input image has been saved as a gray-level
    image, all three channels will contain the same value. Finally, if you wish to
    read the image in the format in which it has been saved, then simply input a negative
    value as the second argument. The number of channels in an image can be checked
    by using the `channels` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，将创建一个每个像素由3个字节组成的图像，在OpenCV中指定为`CV_8UC3`。当然，如果你的输入图像已经被保存为灰度图像，所有三个通道将包含相同的值。最后，如果你希望以保存的格式读取图像，只需将第二个参数输入为负值。可以通过使用`channels`方法检查图像中的通道数：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Pay attention when you open an image with `imread` without specifying a full
    path (as we did here). In that case, the default directory will be used. When
    you run your application from the console, this directory is obviously the one
    of your executable file. However, if you run the application directly from your
    IDE, the default directory will most often be the one that contains your project
    file. Consequently, make sure that your input image file is located in the right
    directory.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`imread`打开一个未指定完整路径的图像时（就像我们在这里做的那样），请注意。在这种情况下，将使用默认目录。当你从控制台运行你的应用程序时，这个目录显然是你的可执行文件所在的目录。然而，如果你直接从你的IDE运行应用程序，默认目录通常是你项目文件所在的目录。因此，请确保你的输入图像文件位于正确的目录中。
- en: When you use `imshow` to display an image made up of integers (designated as
    `CV_16U` for 16-bit unsigned integers, or as `CV_32S` for 32-bit signed integers),
    the pixel values of this image will be divided by 256 first, in an attempt to
    make it displayable with 256 gray shades. Similarly, an image made of floating
    points will be displayed by assuming a range of possible values between 0.0 (displayed
    as black) and 1.0 (displayed as white). Values outside this defined range are
    displayed in white (for values above 1.0) or black (for values below 1.0).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`imshow`显示由整数组成的图像（指定为`CV_16U`表示16位无符号整数，或`CV_32S`表示32位有符号整数）时，该图像的像素值首先会被除以256，试图使其可以用256种灰度级别显示。同样，由浮点数组成的图像将通过假设0.0（显示为黑色）和1.0（显示为白色）之间的可能值范围来显示。超出此定义范围的值将以白色（对于大于1.0的值）或黑色（对于小于1.0的值）显示。
- en: The `highgui` module is very useful to build quick prototypal applications.
    When you are ready to produce a finalized version of your application, you will
    probably want to use the GUI module offered by your IDE in order to build an application
    with a more professional look.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`highgui`模块对于构建快速原型应用非常有用。当您准备好生成应用程序的最终版本时，您可能会想使用IDE提供的GUI模块来构建一个外观更专业的应用程序。'
- en: 'Here, our application uses both input and output images. As an exercise, you
    should rewrite this simple program such that it takes advantage of the function''s
    in-place processing, that is, by not declaring the output image and writing it
    instead:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的应用程序同时使用输入和输出图像。作为一个练习，您应该重写这个简单的程序，使其利用函数的就地处理功能，也就是说，不声明输出图像，而是直接写入它：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's more...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: The `highgui` module contains a rich set of functions that help you to interact
    with your images. Using these, your applications can react to mouse or key events.
    You can also draw shapes and write text on images.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`highgui`模块包含了一组丰富的函数，这些函数可以帮助您与图像进行交互。使用这些函数，您的应用程序可以响应鼠标或键盘事件。您还可以在图像上绘制形状和写入文本。'
- en: Clicking on images
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 点击图像
- en: 'You can program your mouse to perform specific operations when it is over one
    of the image windows you created. This is done by defining an appropriate **callback**
    function. A callback function is a function that you do not explicitly call but
    which is called by your application in response to specific events (here, the
    events that concern the mouse interacting with an image window). To be recognized
    by applications, callback functions need to have a specific signature and must
    be registered. In the case of the mouse event handler, the callback function must
    have the following signature:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将鼠标编程为在悬停在您创建的图像窗口之一上时执行特定操作。这是通过定义一个合适的**回调**函数来完成的。回调函数是一个您不明确调用的函数，但您的应用程序会根据特定事件（在此处，涉及鼠标与图像窗口交互的事件）来调用它。为了被应用程序识别，回调函数需要具有特定的签名并且必须进行注册。在鼠标事件处理程序的情况下，回调函数必须具有以下签名：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first parameter is an integer that is used to specify which type of mouse
    event has triggered the call to the callback function. The other two parameters
    are simply the pixel coordinates of the mouse location when the event occurred.
    The flags are used to determine which button was pressed when the mouse event
    was triggered. Finally, the last parameter is used to send an extra parameter
    to the function in the form of a pointer to any object. This callback function
    can be registered in the application through the following call:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个整数，用于指定哪种类型的鼠标事件触发了回调函数的调用。其他两个参数简单地是事件发生时鼠标位置的像素坐标。标志用于确定在鼠标事件触发时哪个按钮被按下。最后，最后一个参数用于将一个额外的参数以任何对象的指针形式发送到函数。此回调函数可以通过以下调用在应用程序中注册：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this example, the `onMouse` function is associated with the image window
    called **Original Image**, and the address of the displayed image is passed as
    an extra parameter to the function. Now, if we define the `onMouse` callback function
    as shown in the following code, then each time the mouse is clicked, the value
    of the corresponding pixel will be displayed on the console (here, we assume that
    it is a gray-level image):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`onMouse`函数与称为**原始图像**的图像窗口相关联，并且显示的图像地址作为额外参数传递给函数。现在，如果我们定义如以下代码所示的`onMouse`回调函数，那么每次鼠标点击时，相应像素的值将在控制台上显示（这里我们假设它是一个灰度图像）：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that in order to obtain the pixel value at `(x,y)`, we used the `at` method
    of the `cv::Mat` object here; this has been discussed in [Chapter 2](part0019_split_000.html#page
    "Chapter 2. Manipulating Pixels"), *Manipulating Pixels*. Other possible events
    that can be received by the mouse event callback function include `CV_EVENT_MOUSEMOVE,
    CV_EVENT_LBUTTONUP`, `CV_EVENT_RBUTTONDOWN`, and `CV_EVENT_RBUTTONUP`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了获取 `(x,y)` 处的像素值，我们在这里使用了 `cv::Mat` 对象的 `at` 方法；这已在 [第2章](part0019_split_000.html#page
    "第2章. 操作像素") 中讨论过，*操作像素*。鼠标事件回调函数还可以接收其他一些事件，包括 `CV_EVENT_MOUSEMOVE, CV_EVENT_LBUTTONUP`,
    `CV_EVENT_RBUTTONDOWN`, 和 `CV_EVENT_RBUTTONUP`。
- en: Drawing on images
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在图像上绘制
- en: 'OpenCV also offers a few functions to draw shapes and write text on images.
    The examples of basic shape-drawing functions are `circle`, `ellipse`, `line`,
    and `rectangle`. The following is an example of how to use the `circle` function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 还提供了一些在图像上绘制形状和写入文本的函数。基本形状绘制函数的示例有 `circle`, `ellipse`, `line`, 和 `rectangle`。以下是如何使用
    `circle` 函数的示例：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `cv::Point` structure is often used in OpenCV methods and functions to
    specify a pixel coordinate. Note that here we assume that the drawing is done
    on a gray-level image; this is why the color is specified with a single integer.
    In the next recipe, you will learn how to specify a color value in the case of
    color images that use the `cv::Scalar` structure. It is also possible to write
    text on an image. This can be done as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::Point` 结构通常在 OpenCV 方法和函数中用于指定像素坐标。请注意，在这里我们假设绘制是在灰度图像上进行的；这就是为什么颜色用单个整数指定。在下一菜谱中，您将学习如何在使用
    `cv::Scalar` 结构的颜色图像中指定颜色值。您还可以在图像上写入文本。可以这样做：'
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Calling these two functions on our test image will then result in the following
    screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试图像上调用这两个函数将产生以下截图：
- en: '![Drawing on images](img/00007.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![在图像上绘制](img/00007.jpeg)'
- en: Running the example with Qt
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Qt 运行示例
- en: 'If you wish to use Qt to run your OpenCV applications, you will need to create
    project files. For the example of this recipe, here is how the project file (`loadDisplaySave.pro`)
    will look:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用 Qt 运行您的 OpenCV 应用程序，您需要创建项目文件。对于本菜谱的示例，以下是项目文件 (`loadDisplaySave.pro`)
    的样子：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This file shows you where to find the `include and library` files. It also lists
    the library modules that are used by the example. Make sure to use the library
    binaries compatible with the compiler that Qt is using. Note that if you download
    the source code of the examples of this book, you will find the `CMakeLists` files
    that you can open with Qt (or CMake) in order to create the associated projects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件显示了您可以在哪里找到 `include and library` 文件。它还列出了示例中使用的库模块。请确保使用与 Qt 所使用的编译器兼容的库二进制文件。请注意，如果您下载了本书示例的源代码，您将找到可以与
    Qt（或 CMake）一起打开的 `CMakeLists` 文件，以便创建相关项目。
- en: See also
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `cv::Mat` class is the data structure that is used to hold your images (and
    obviously, other matrix data). This data structure is at the core of all OpenCV
    classes and functions; the next recipe offers a detailed explanation of this data
    structure.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv::Mat` 类是用于存储您的图像（以及显然，其他矩阵数据）的数据结构。这个数据结构是所有 OpenCV 类和函数的核心；下一菜谱将详细介绍这个数据结构。'
- en: You can download the source code of the examples of this book from [https://github.com/laganiere/](https://github.com/laganiere/).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从 [https://github.com/laganiere/](https://github.com/laganiere/) 下载本书示例的源代码。
- en: Exploring the cv::Mat data structure
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 cv::Mat 数据结构
- en: In the previous recipe, you were introduced to the `cv::Mat` data structure.
    As mentioned, this is a key element of the library. It is used to manipulate images
    and matrices (in fact, an image is a matrix from a computational and mathematical
    point of view). Since you will be using this data structure extensively in your
    application developments, it is imperative that you become familiar with it. Notably,
    you will learn in this recipe that this data structure incorporates an elegant
    memory management mechanism, allowing efficient usage.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，您已经了解了 `cv::Mat` 数据结构。正如所提到的，这是库的关键元素。它用于操作图像和矩阵（实际上，从计算和数学的角度来看，图像是一个矩阵）。由于您将在应用程序开发中广泛使用此数据结构，因此熟悉它是必不可少的。值得注意的是，您将在本菜谱中了解到，此数据结构包含一个优雅的内存管理机制，允许高效使用。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s write the following test program that will allow us to test the different
    properties of the `cv::Mat` data structure:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写以下测试程序，以便我们可以测试 `cv::Mat` 数据结构的不同属性：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run this program and take a look at the following images produced:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序并查看以下生成的图像：
- en: '![How to do it...](img/00008.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00008.jpeg)'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `cv::Mat` data structure is essentially made up of two parts: a header
    and a data block. The header contains all the information associated with the
    matrix (size, number of channels, data type, and so on). The previous recipe showed
    you how to access some of the attributes of this structure contained in its header
    (for example, by using `cols`, `rows`, or `channels`). The data block holds all
    the pixel values of an image. The header contains a pointer variable that points
    to this data block; it is the `data` attribute. An important property of the `cv::Mat`
    data structure is the fact that the memory block is only copied when explicitly
    requested for. Indeed, most operations will simply copy the `cv::Mat` header such
    that multiple objects will point to the same data block at the same time. This
    memory management model makes your applications more efficient while avoiding
    memory leaks, but its consequences have to be understood. The examples of this
    recipe illustrate this fact.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::Mat` 数据结构本质上由两部分组成：一个头和一个数据块。头包含了与矩阵相关联的所有信息（大小、通道数、数据类型等）。前面的食谱向您展示了如何访问该结构头中包含的一些属性（例如，通过使用
    `cols`、`rows` 或 `channels`）。数据块包含了一个图像的所有像素值。头中包含一个指针变量，它指向这个数据块；它是 `data` 属性。`cv::Mat`
    数据结构的一个重要特性是内存块仅在明确请求时才会被复制。确实，大多数操作只是简单地复制 `cv::Mat` 头部，这样多个对象将同时指向相同的数据块。这种内存管理模型使您的应用程序更高效，同时避免了内存泄漏，但必须理解其后果。本食谱的示例说明了这一点。'
- en: 'By default, the `cv::Mat` objects have a zero size when they are created, but
    you can also specify an initial size as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`cv::Mat` 对象在创建时具有零大小，但您也可以指定初始大小如下：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, you also need to specify the type of each matrix element; `CV_8U`
    here, which corresponds to 1-byte pixel images. The letter `U` means it is unsigned.
    You can also declare signed numbers by using the letter `S`. For a color image,
    you would specify three channels (`CV_8UC3`). You can also declare integers (signed
    or unsigned) of size 16 and 32 (for example, `CV_16SC3`). You also have access
    to 32-bit and 64-bit floating-point numbers (for example, `CV_32F`).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您还需要指定每个矩阵元素的类型；这里为 `CV_8U`，对应于1字节像素图像。字母 `U` 表示它是无符号的。您也可以通过使用字母 `S`
    来声明有符号数字。对于彩色图像，您将指定三个通道（`CV_8UC3`）。您还可以声明大小为16和32的整数（例如，`CV_16SC3`）。您还可以访问32位和64位浮点数（例如，`CV_32F`）。
- en: 'Each element of an image (or a matrix) can be composed of more than one value
    (for example, the three channels of a color image); therefore, OpenCV has introduced
    a simple data structure that is used when pixel values are passed to functions.
    It is the `cv::Scalar` structure, which is generally used to hold one value or
    three values. For example, to create a color image initialized with red pixels,
    you will write the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图像（或矩阵）的每个元素可以由多个值组成（例如，彩色图像的三个通道）；因此，OpenCV 引入了一种简单的数据结构，用于在将像素值传递给函数时使用。它是
    `cv::Scalar` 结构，通常用于存储一个或三个值。例如，要创建一个初始化为红色像素的彩色图像，您将编写以下代码：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Similarly, the initialization of the gray-level image could also have been done
    using this structure by writing `cv::Scalar(100)`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，灰度图像的初始化也可以使用此结构通过编写 `cv::Scalar(100)` 来完成。
- en: The image size also often needs to be passed to functions. We have already mentioned
    that the `cols` and `rows` attributes can be used to get the dimensions of a `cv::Mat`
    instance. The size information can also be provided through the `cv::Size` structure
    that simply contains the height and width of the matrix. The `size()` method allows
    you to obtain the current matrix size. This is the format that is used in many
    methods where a matrix size must be specified.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图像大小也经常需要传递给函数。我们已经提到，`cols` 和 `rows` 属性可以用来获取 `cv::Mat` 实例的维度。大小信息也可以通过包含矩阵高度和宽度的
    `cv::Size` 结构提供。`size()` 方法允许您获取当前矩阵的大小。这是在许多必须指定矩阵大小的函数中使用的一种格式。
- en: 'For example, an image could be created as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以创建图像如下：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The data block of an image can always be allocated or re-allocated using the
    `create` method. When an image has been previously allocated, its old content
    is de-allocated first. For reasons of efficiency, if the new proposed size and
    type matches the already existing size and type, then no new memory allocation
    is performed:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的数据块始终可以使用`create`方法进行分配或重新分配。当一个图像已经被分配时，其旧内容首先被释放。出于效率的考虑，如果新提议的大小和类型与已存在的类型和大小匹配，则不会执行新的内存分配：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When no more references point to a given `cv::Mat` object, the allocated memory
    is automatically released. This is very convenient because it avoids the common
    memory leak problems often associated with dynamic memory allocation in C++. This
    is a key mechanism in OpenCV 2 that is accomplished by having the `cv::Mat` class
    implement reference counting and shallow copy. Therefore, when an image is assigned
    to another one, the image data (that is, the pixels) is not copied; both the images
    will point to the same memory block. This also applies to images passed by value
    or returned by value. A reference count is kept such that the memory will be released
    only when all the references to the image will be destructed or assigned to another
    image:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有更多引用指向给定的`cv::Mat`对象时，分配的内存将自动释放。这非常方便，因为它避免了与C++中动态内存分配相关的常见内存泄漏问题。这是OpenCV
    2中的一个关键机制，通过`cv::Mat`类实现引用计数和浅拷贝来完成。因此，当一个图像被赋值给另一个图像时，图像数据（即像素）不会被复制；两个图像将指向相同的内存块。这也适用于按值传递或按值返回的图像。保持引用计数，以便仅在所有对图像的引用都被销毁或赋值给另一个图像时才释放内存：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Any transformation applied to one of the preceding images will also affect
    the other images. If you wish to create a deep copy of the content of an image,
    use the `copyTo` method. In that case, the `create` method is called on the destination
    image. Another method that produces a copy of an image is the `clone` method,
    which creates a new identical image as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对前面图像之一应用任何转换也将影响其他图像。如果您想创建图像内容的深度副本，请使用`copyTo`方法。在这种情况下，`create`方法将在目标图像上调用。另一个可以创建图像副本的方法是`clone`方法，它按照以下方式创建一个全新的相同图像：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you need to copy an image into another image that does not necessarily have
    the same data type, you have to use the `convertTo` method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要将图像复制到另一个不一定具有相同数据类型的图像中，您必须使用`convertTo`方法：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, the source image is copied into a floating-point image. The
    method includes two optional parameters: a scaling factor and an offset. Note
    that both the images must, however, have the same number of channels.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，源图像被复制到一个浮点图像中。该方法包括两个可选参数：缩放因子和偏移量。请注意，然而，两个图像必须具有相同数量的通道。
- en: 'The allocation model for the `cv::Mat` objects also allows you to safely write
    functions (or class methods) that return an image:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::Mat`对象的分配模型还允许您安全地编写返回图像的函数（或类方法）：'
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also call this function from our `main` function as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从我们的`main`函数中调用此函数，如下所示：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If we do this, then the `gray` variable will now hold the image created by the
    function without extra memory allocation. Indeed, as we explained, only a shallow
    copy of the image will be transferred from the returned `cv::Mat` instance to
    the `gray` image. When the `ima` local variable goes out of scope, this variable
    is de-allocated, but since the associated reference counter indicates that its
    internal image data is being referred to by another instance (that is, the `gray`
    variable), its memory block is not released.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，那么`gray`变量现在将包含由该函数创建的图像，而不需要额外的内存分配。确实，正如我们解释的那样，只有图像的浅拷贝将从返回的`cv::Mat`实例传输到`gray`图像。当`ima`局部变量超出作用域时，这个变量将被释放，但由于相关的引用计数器指示其内部图像数据被另一个实例（即`gray`变量）引用，其内存块不会被释放。
- en: 'It''s worth noting that in the case of classes, you should be careful and not
    return image class attributes. Here is an example of an error-prone implementation:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在类的情况下，您应该小心，不要返回图像类属性。以下是一个容易出错实现的示例：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, if a function calls the method of this class, it obtains a shallow copy
    of the image attributes. If later this copy is modified, the `class` attribute
    will also be surreptitiously modified, which can affect the subsequent behavior
    of the class (and vice versa). To avoid these kinds of errors, you should instead
    return a clone of the attribute.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果一个函数调用这个类的这个方法，它会获得图像属性的浅拷贝。如果稍后这个拷贝被修改，`class`属性也会被偷偷修改，这可能会影响类的后续行为（反之亦然）。为了避免这些错误，你应该返回属性的克隆。
- en: There's more...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: When you are manipulating the `cv::Mat` class, you will discover that OpenCV
    also includes several other related classes. It will be important for you to become
    familiar with them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你操作`cv::Mat`类时，你会发现OpenCV还包括其他几个相关类。熟悉它们对你来说将非常重要。
- en: The input and output arrays
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入和输出数组
- en: If you look at the OpenCV documentation, you will see that many methods and
    functions accept parameters of the `cv::InputArray` type as the input. This type
    is a simple proxy class introduced to generalize the concept of arrays in OpenCV,
    and thus avoid the duplication of several versions of the same method or function
    with different input parameter types. It basically means that you can supply a
    `cv::Mat` object or other compatible types as an argument. This class is just
    an interface, so you should never declare it explicitly in your code. It is interesting
    to know that `cv::InputArray` can also be constructed from the popular `std::vector`
    class. This means that such objects can be used as the input to OpenCV methods
    and functions (as long as it makes sense to do so). Other compatible types are
    the `cv::Scalar` and the `cv::Vec`; this later structure will be presented in
    the next chapter. There is also a `cv::OutputArray` proxy class that is used to
    designate the arrays returned by some methods or functions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看OpenCV文档，你会看到许多方法和函数接受`cv::InputArray`类型的参数作为输入。这个类型是一个简单的代理类，用于泛化OpenCV中数组的概念，从而避免重复几个具有不同输入参数类型的方法或函数的多个版本。这基本上意味着你可以提供一个`cv::Mat`对象或其他兼容类型作为参数。这个类只是一个接口，所以你永远不应该在代码中显式声明它。有趣的是，`cv::InputArray`也可以从流行的`std::vector`类构建。这意味着这样的对象可以用作OpenCV方法和函数的输入（只要这样做有意义）。其他兼容类型是`cv::Scalar`和`cv::Vec`；这个结构将在下一章中介绍。还有一个`cv::OutputArray`代理类，用于指定某些方法或函数返回的数组。
- en: The old IplImage structure
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旧的IplImage结构
- en: 'With Version 2 of OpenCV, a new C++ interface has been introduced. Previously,
    C-like functions and structures were used (and can still be used). In particular,
    images were manipulated using the `IplImage` structure. This structure was inherited
    from the **IPL** library (that is, the **Intel Image Processing** library), now
    integrated with the **IPP** library (the **Intel Integrated Performance Primitive**
    library). If you use the code and libraries that have been created with the old
    C interface, you might need to manipulate those `IplImage` structures. Fortunately,
    there is a convenient way to convert an `IplImage` structure into a `cv::Mat`
    object, which is shown in the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenCV的版本2中，引入了一个新的C++接口。之前，使用了类似C的函数和结构（并且仍然可以使用）。特别是，图像是通过`IplImage`结构来操作的。这个结构是从**IPL**库（即**Intel
    Image Processing**库）继承的，现在已集成到**IPP**库（**Intel Integrated Performance Primitive**库）中。如果你使用的是用旧C接口创建的代码和库，你可能需要操作这些`IplImage`结构。幸运的是，有一个方便的方法可以将`IplImage`结构转换为`cv::Mat`对象，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `cvLoadImage` function is the C-interface function to load images. The
    second parameter in the constructor of the `cv::Mat` object indicates that the
    data will not be copied (set this to `true` if you want a new copy; `false` is
    the default value, so it could have been omitted), that is, both `IplImage` and
    `image` will share the same image data. Here, you need to be careful to not create
    dangling pointers. For this reason, it is safer to encapsulate the `IplImage`
    pointer in the reference-counting pointer class provided by OpenCV 2:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`cvLoadImage`函数是用于加载图像的C接口函数。`cv::Mat`对象构造函数中的第二个参数表示数据不会被复制（如果你想要一个新的副本，请将其设置为`true`；默认值为`false`，因此可以省略），也就是说，`IplImage`和`image`将共享相同的数据。在这里，你需要小心不要创建悬空指针。因此，将`IplImage`指针封装在OpenCV
    2提供的引用计数指针类中更安全：'
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Otherwise, if you need to de-allocate the memory pointed out by your `IplImage`
    structure, you need to do it explicitly:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果你需要显式地释放由你的`IplImage`结构指向的内存，你需要这样做：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Remember that you should avoid using this deprecated data structure. Instead,
    always use the `cv::Mat` data structure.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你应该避免使用这个已弃用的数据结构。相反，始终使用`cv::Mat`数据结构。
- en: See also
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The complete OpenCV documentation can be found at [http://docs.opencv.org/](http://docs.opencv.org/)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的OpenCV文档可以在[http://docs.opencv.org/](http://docs.opencv.org/)找到
- en: '[Chapter 2](part0019_split_000.html#page "Chapter 2. Manipulating Pixels"),
    *Manipulating Pixels*, will show you how to efficiently access and modify the
    pixel values of an image represented by the `cv::Mat` class'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第二章](part0019_split_000.html#page "第二章. 操作像素")，*操作像素*，将向您展示如何高效地访问和修改由`cv::Mat`类表示的图像的像素值'
- en: The next recipe, which will explain how to define a region of interest inside
    an image
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个菜谱将解释如何在图像内部定义感兴趣区域
- en: Defining regions of interest
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义感兴趣区域
- en: Sometimes, a processing function needs to be applied only to a portion of an
    image. OpenCV incorporates an elegant and simple mechanism to define a subregion
    in an image and manipulate it as a regular image. This recipe will teach you how
    to define a region of interest inside an image.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，需要将处理函数仅应用于图像的一部分。OpenCV集成了一个优雅且简单的机制来定义图像中的子区域，并将其作为普通图像进行操作。本菜谱将教你如何在图像内部定义感兴趣区域。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Suppose we want to copy a small image onto a larger one. For example, let''s
    say we want to insert the following small logo in our test image:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将一个小图像复制到一个较大的图像上。例如，让我们假设我们想要在我们的测试图像中插入以下小标志：
- en: '![Getting ready](img/00009.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/00009.jpeg)'
- en: To do this, a **Region Of Interest** (**ROI**) can be defined over which the
    copy operation can be applied. As we will see, the position of the ROI will determine
    where the logo will be inserted in the image.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，可以在一个**感兴趣区域**（**ROI**）上定义复制操作。正如我们将看到的，ROI的位置将决定标志将插入图像的位置。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The first step consists of defining the ROI. Once defined, the ROI can be manipulated
    as a regular `cv::Mat` instance. The key is that the ROI is indeed a `cv::Mat`
    object that points to the same data buffer as its parent image and has a header
    that specifies the coordinates of the ROI. Inserting the logo would then be accomplished
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义ROI。一旦定义，ROI就可以像普通的`cv::Mat`实例一样进行操作。关键是ROI确实是一个指向其父图像相同数据缓冲区的`cv::Mat`对象，并且有一个头文件指定ROI的坐标。然后，插入标志的操作可以按照以下方式进行：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, `image` is the destination image, and `logo` is the logo image (of a
    smaller size). The following image is then obtained by executing the previous
    code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`image`是目标图像，而`logo`是标志图像（尺寸较小）。执行前面的代码后，可以得到以下图像：
- en: '![How to do it...](img/00010.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00010.jpeg)'
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: One way to define an ROI is to use a `cv::Rect` instance. As the name indicates,
    it describes a rectangular region by specifying the position of the upper-left
    corner (the first two parameters of the constructor) and the size of the rectangle
    (the width and height are given in the last two parameters). In our example, we
    used the size of the image and the size of the logo in order to determine the
    position where the logo would cover the bottom-right corner of the image. Obviously,
    the ROI should always be completely inside the parent image.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 定义ROI的一种方法是通过使用`cv::Rect`实例。正如其名所示，它通过指定左上角的位置（构造函数的前两个参数）和矩形的尺寸（宽度在最后两个参数中给出）来描述一个矩形区域。在我们的例子中，我们使用了图像的大小和标志的大小来确定标志将覆盖图像右下角的位置。显然，ROI应该始终完全位于父图像内部。
- en: 'The ROI can also be described using row and column ranges. A range is a continuous
    sequence from a start index to an end index (excluding both). The `cv::Range`
    structure is used to represent this concept. Therefore, an ROI can be defined
    from two ranges; in our example, the ROI could have been equivalently defined
    as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ROI也可以使用行和列的范围来描述。范围是从起始索引到结束索引（不包括两者）的连续序列。`cv::Range`结构用于表示这个概念。因此，ROI可以通过两个范围来定义；在我们的例子中，ROI可以等效地定义为以下内容：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this case, the `operator()` function of `cv ::Mat` returns another `cv::Mat`
    instance that can then be used in subsequent calls. Any transformation of the
    ROI will affect the original image in the corresponding area because the image
    and the ROI share the same image data. Since the definition of an ROI does not
    include the copying of data, it is executed in a constant amount of time, no matter
    the size of the ROI.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`cv::Mat`的`operator()`函数返回另一个`cv::Mat`实例，然后可以在后续调用中使用它。任何对ROI的转换都会影响原始图像的相应区域，因为图像和ROI共享相同的数据。由于ROI的定义不包括数据的复制，它以恒定的时间执行，无论ROI的大小如何。
- en: 'If you want to define an ROI made of some lines of an image, the following
    call can be used:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要定义由图像的一些行组成的ROI，可以使用以下调用：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Similarly, for an ROI made of some image columns, the following can be used:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于由图像的一些列组成的ROI，可以使用以下方法：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There's more...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The OpenCV methods and functions include many optional parameters that are not
    discussed in the recipes of this book. When you wish to use a function for the
    first time, you should always take the time to look at the documentation to learn
    more about the possible options that this function offers. One very common option
    is the possibility to define image masks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV的方法和函数包括许多在本书的食谱中未讨论的可选参数。当你第一次使用一个函数时，你应该花时间查看文档，以了解更多这个函数提供的可能选项。一个非常常见的选项是定义图像掩码的可能性。
- en: Using image masks
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用图像掩码
- en: 'Some OpenCV operations allow you to define a mask that will limit the applicability
    of a given function or method, which is normally supposed to operate on all the
    image pixels. A mask is an 8-bit image that should be nonzero at all locations
    where you want an operation to be applied. At the pixel locations that correspond
    to the zero values of the mask, the image is untouched. For example, the `copyTo`
    method can be called with a mask. We can use it here to copy only the white portion
    of the logo shown previously, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一些OpenCV操作允许你定义一个掩码，该掩码将限制给定函数或方法的应用范围，该函数或方法通常应在所有图像像素上操作。掩码是一个8位图像，你应该在你想应用操作的所有位置上设置非零值。在对应于掩码零值的像素位置，图像保持不变。例如，可以使用掩码调用`copyTo`方法。我们可以在这里使用它来复制之前显示的标志的白色部分，如下所示：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following image is obtained by executing the previous code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像是通过执行前面的代码获得的：
- en: '![Using image masks](img/00011.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![使用图像掩码](img/00011.jpeg)'
- en: The background of our logo was black (therefore, it had the value 0); therefore,
    it was easy to use it as both the copied image and the mask. Of course, you can
    define the mask of your choice in your application; most OpenCV pixel-based operations
    give you the opportunity to use masks.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们标志的背景是黑色（因此，它具有值0）；因此，它很容易被用作复制的图像和掩码。当然，你可以在你的应用程序中定义你选择的掩码；大多数基于像素的OpenCV操作都给你使用掩码的机会。
- en: See also
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `row` and `col` methods that will be used in the *Scanning an image with
    neighbor access* recipe of [Chapter 2](part0019_split_000.html#page "Chapter 2. Manipulating
    Pixels"), *Manipulating Pixels*. These are a special case of the `rowRange` and
    `colRange` methods in which the start and end indexes are equal in order to define
    a single-line or single-column ROI.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](part0019_split_000.html#page "第2章. 操作像素")的“使用邻接访问扫描图像”食谱中将要使用的`row`和`col`方法，*操作像素*。这些是`rowRange`和`colRange`方法的特殊情况，其中起始和结束索引相等，以便定义单行或单列的ROI。
