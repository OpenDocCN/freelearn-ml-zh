- en: Chapter 9. Adding Specialized Searches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter explored the relationship between academic papers and journals,
    and we learned how to search for academic papers. This chapter moves on to the
    last of the top-level APIs, Search. In this chapter, we will learn how to search
    for web content. We will see how we can search for the latest news with certain
    keywords or categories. Further on, we will search for images and videos, and
    learn how to automatically suggest search queries for the end user. By the end
    of this chapter, we will be introduced to Bing Visual Search and find out how
    to create customized search experiences by using Bing Custom Search.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to search for web pages and documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to search for news articles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to search for images and videos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add autosuggestions in applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to filter search results based on safe search policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching the web using the smart-house application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Bing Web Search API provides us with a search experience similar to what
    we find at [http://bing.com/search](http://bing.com/search). It returns results
    that are relevant to any queries.
  prefs: []
  type: TYPE_NORMAL
- en: A response for any request to this API will contain web pages, images, videos,
    and news articles. In a typical scenario, this is the API you would use for any
    of these searches.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in a real-life scenario, all requests should be made from a server-side
    application, not from a client, as we do in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have not already done so, sign up for the Bing Web Search API at [https://portal.azure.com](https://portal.azure.com).
    You can read more on the API at [https://azure.microsoft.com/en-us/services/cognitive-services/bing-web-search-api/](https://azure.microsoft.com/en-us/services/cognitive-services/bing-web-search-api/).
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the application for web searches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into the required technicalities for web searches, we are going
    to prepare our smart-house application.
  prefs: []
  type: TYPE_NORMAL
- en: Add a new View in the `Views` folder called `BingSearchView.xaml`. At the very
    least, this should contain two `Combobox` elements, one for the search type and
    one for the search filter. We need one `TextBox` element for our search query,
    as well as one `Button` element to execute the search. Finally, we need a `TextBox`
    element to display the search result.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accompany the search types and search filter, we need to add a new file,
    called `BingSearchTypes.cs`, in the `Model` folder. Add the following two `enums`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Adding this allows us to use both the Bing Web Search and Bing News Search APIs.
    The latter will be discussed later. The second `enum`, `SafeSearch`, will also
    be discussed in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: We need a new ViewModel. Add a new file called `BingSearchViewModel.cs`, to
    the `ViewModels` folder. In this, we need to add two `string` properties for our
    search query and the search results. We will also need one property of type `BingSearchType`
    to represent the selected search type. Also needed is a property of type `SafeSearch`
    to represent the selected safe-search filter. An `ICommand` property is needed
    for our button.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we need to be able to display the values from the previously created
    `SafeSearch enums`. This can be achieved by adding the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We get all the values from each `enum`, and return them as an `IEnumerable`.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, none of the search APIs have any NuGet client packages,
    so we need to make the web requests ourselves. Copy the `WebRequest.cs` file we
    used in earlier chapters into the `Model` folder. Rename the file `BingWebRequest.cs`
    and the class `BingWebRequest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As all API calls are `GET` requests, we can simplify this class a bit. Remove
    the URL parameter from the constructor, and remove the `_endpoint` member completely.
    Doing so allows us to simplify the `MakeRequest` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We do not need a request body, and have removed the `TRequest` and corresponding
    code. We have also hardcoded the HTTP method, and said that we will specify the
    complete URL endpoint when calling the function. The rest of the function should
    stay the same.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to add references to `System.Web` and `System.Runtime.Serialization`.
  prefs: []
  type: TYPE_NORMAL
- en: With that in place, we can move on. Make sure that the code compiles and executes
    before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Searching the web
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to use Bing Web Search, we need to create a new class. Add a new
    file called `BingSearch.cs`, to the `Model` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a member of type `BingWebRequest`, which we will create in the
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new function called `SearchWeb`. This should accept two parameters,
    a string for the search query and a `SafeSearch` parameter. The function should
    be marked as `async` and return a `Task<WebSearchResponse>`. `WebSearchResponse`
    is a data contract we will learn more about presently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First, we construct our endpoint, which points us to the web search service.
    We make sure that we specify the query, `q`, the `safeSearch` selection, and the
    market, `mkt`. The latter two will be discussed presently in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only required parameter is the query string. This should not exceed a length
    of 1,500 characters. Other optional parameters are described in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `responseFilter` | A **comma-delimited** list of the result types to include
    in the response. If not specified, results will contain all types. Legal values
    include `Computation`, `Images`, `News`, `RelatedSearches`, `SpellSuggestions`,
    `TimeZone`, `Videos`, and `WebPages`. |'
  prefs: []
  type: TYPE_TB
- en: '| `setLang` | A two-letter language code to specify the language for user interface
    strings. |'
  prefs: []
  type: TYPE_TB
- en: '| `textDecorations` | Specifies whether or not the query term is highlighted
    in the results. Defaults to false. |'
  prefs: []
  type: TYPE_TB
- en: '| `textFormat` | The type of formatting to apply to display strings. Can be
    either raw or HTML, with raw being the default. |'
  prefs: []
  type: TYPE_TB
- en: There are a few more parameters apart from these ones. They are, however, common
    to all searches and will be discussed at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the endpoint in place, we can move on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With the newly constructed endpoint, we call `MakeRequest` on the `_webRequest`
    object. We specify the API key and endpoint as parameters to this call, and we
    expect a `WebSearchResponse` object as a response.
  prefs: []
  type: TYPE_NORMAL
- en: '`WebSearchResponse` is a data contract, which we get by deserializing the JSON
    response from the API service. The top-level object will contain objects with
    the different result types. Look in the code samples provided in the file called
    `BingSearchResponse.cs` for a complete data contract.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete list of response objects from Bing Web Search, visit [https://msdn.microsoft.com/en-us/library/dn760794.aspx#searchresponse](https://msdn.microsoft.com/en-us/library/dn760794.aspx#searchresponse).
  prefs: []
  type: TYPE_NORMAL
- en: 'Heading back to the `BingSearchViewModel.cs` file, we can add `BingSearch`
    as a member. The constructor should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CanSearch` parameter should return true if we have any text entered into
    the search query text field. `Search` should, for now, look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the `SearchWeb` function on the `_bingSearch` object, passing on the
    `SearchQuery` and `SelectedSafeSearchFilter` properties as parameters. With a
    successful response, we send the response to a new function, `ParseWebSearch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When we interpret the results from a web search, we are interested in the resulting
    `webPages`. For each web page, we want to output the name, the display URL, and
    a descriptive snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful test run with the web search should present us with the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Searching the web](img/B12373_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Result objects from a web search contain a `RankingResponse` object. This will
    identify how the results will typically be displayed on a search website, ordered
    in a mainline and sidebar. In a production system, you should always aim to display
    results in the order specified by `RankingResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: This can be done in two ways. One is to use the specified ID field to rank all
    of the results. The other way is a bit more complex. It involves splitting the
    results based on answer types and the result index.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the queries we have seen up to now, we can also query for computations
    (for instance, 2 + 2), time zone calculations, and related searches. These queries
    will result in JSON responses, which is a bit different from a regular web search.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the news
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the Bing News Search API, we can search for news in several ways. There
    are three endpoints we can use for this API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/news`: Get top news articles, based on category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/news/search`: Get news articles based on a search query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/news/trendingtopics`: Get top trending news topics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our smart-house application, we will add the first two, while we will only
    cover the last one theoretically.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have not already done so, sign up for the Bing News Search API at [https://portal.azure.com](https://portal.azure.com).
  prefs: []
  type: TYPE_NORMAL
- en: News from queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of the groundwork for query-based news searches has already been done
    in the web search sample. To search for news based on given queries, we need to
    add a new function in the `BingSearch` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `BingSearch.cs` file and add a new function called `SearchNews`. This
    should accept a `string` and a `SafeSearch` parameter. The function should be
    marked as `async`, and return a `Task<BingNewsResponse>` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We will construct an endpoint consisting of the URL, the search query, and the
    `safeSearch` parameter. Notice how we specify the market, `mkt`, while limiting
    the `count` to 5\. Both of these parameters will be described presently in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The only required parameter is the query string, `q`. Apart from parameters
    described for web searches (`setLang`, `textDecorations`, and `textFormat`), we
    can also specify a parameter called `originalImg`. This is a Boolean value, which,
    if set to true, will provide a URL to the original image (for any image in the
    article). If that is set to false, which is the default, a URL for the thumbnail
    is provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an endpoint in place, we can call the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We call `MakeRequest`, on the `_webRequest` object, passing on the endpoint
    as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: A successful call will result in a JSON response, which we deserialize into
    a `BingNewsResponse` object. This object needs to be created as a data contract.
  prefs: []
  type: TYPE_NORMAL
- en: The `BingNewsResponse` object will contain an array of news articles. Each item
    in this array will contain the article name, URL, image, description, publishing
    date, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For full details of each item in the news article array, visit [https://msdn.microsoft.com/en-us/library/dn760793.aspx#newsarticle](https://msdn.microsoft.com/en-us/library/dn760793.aspx#newsarticle).
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in place, we can head back into the `BingSearchViewModel.cs` file
    and modify the `Search` function. We do so by adding a case for `BingSearchType.News`
    inside the `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A successful response will be parsed and displayed in the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We are mostly interested in the news article name, the date it is published,
    and a description.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good test run of this should present us with the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![News from queries](img/B12373_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: News from categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we want to get the top articles for certain categories, we go through a
    similar procedure as we did for regular news queries. The difference lies in the
    endpoint we construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new function, `SearchNewsCategory`, in the `BingSearch` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a category parameter, with the topic we wish to search for. This
    is an optional parameter. If it is empty, we will get the top news article for
    all categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this search, we can specify two different markets, `en-GB` and `en-US`.
    Each of these comes with a list of pre-defined categories that are currently supported:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete list of supported categories, visit [https://msdn.microsoft.com/en-us/library/dn760793.aspx#categoriesbymarket](https://msdn.microsoft.com/en-us/library/dn760793.aspx#categoriesbymarket).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With the newly constructed endpoint, we call `MakeRequest` on the `_webRequest`
    object. This should result in the same response object as for regular news queries.
    In our ViewModel, we add a `case` for this search type in the `Search` function.
    With the response, we utilize the already created `ParseNewsResponse` to get the
    data we want.
  prefs: []
  type: TYPE_NORMAL
- en: Trending news
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The search for trending news is only available for the `en-US` and `zh-CN`
    markets. To execute this search, make a request to the following URL: [https://api.cognitive.microsoft.com/bing/v7.0/news/trendingtopics](https://api.cognitive.microsoft.com/bing/v7.0/news/trendingtopics).'
  prefs: []
  type: TYPE_NORMAL
- en: No parameters are required by this call, but you can add filters, such as the
    common filters we will discuss later. The only exception is the `freshness` filter,
    which will not work for this request.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful call to this endpoint will result in a `TrendingTopicAnswer` object
    that will contain an array of trending topics. Each item in this array will contain
    the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data field | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `image` | A link to a related image |'
  prefs: []
  type: TYPE_TB
- en: '| `isBreakingNews` | A Boolean indicating whether this topic is considered
    breaking news |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | The title of the topic |'
  prefs: []
  type: TYPE_TB
- en: '| `query` | A query string that will return this topic |'
  prefs: []
  type: TYPE_TB
- en: '| `webSearchUrl` | A URL to the Bing search results for this topic |'
  prefs: []
  type: TYPE_TB
- en: '| `webSearchUrlPingSuffix` | A query string fragment to identify the `webSearchUrl`
    |'
  prefs: []
  type: TYPE_TB
- en: Searching for images and videos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Bing Image Search API and Bing Video Search API allow us to search directly
    for images or videos. These APIs should be used only if you need image or video
    content. There is a possibility that calling these APIs will affect performance
    and relevance negatively, and as such, one should aim to use the Bing Web Search
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have not already done so, sign up for the Bing Image Search API and the
    Bing Video Search API at [https://portal.azure.com](https://portal.azure.com).
  prefs: []
  type: TYPE_NORMAL
- en: Using a common user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we do not need image or video search in our smart-house application, we will
    go on to create a new project. Create this project using the MVVM template that
    we created in [Chapter 1](ch01.html "Chapter 1. Getting Started with Microsoft
    Cognitive Services"), *Getting Started with Microsoft Cognitive Services*.
  prefs: []
  type: TYPE_NORMAL
- en: These APIs do not come with any client packages. Like we did previously, we
    should really make these calls from the server-side application not the client
    application. In any case, we need to copy the `BingWebRequest.cs` file from the
    smart-house application to the `Model` folder. Make sure to change the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to add references to `System.Web` and `System.Runtime.Serialization`.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to install the `Newtonsoft.Json` NuGet package for our deserialization
    to work. Do so through the NuGet package manager.
  prefs: []
  type: TYPE_NORMAL
- en: As we will output some of the results as text, we can get away with one common
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainView.xaml` file. Add two `TextBox` elements, one for the search
    query and one for the result. We need a `ComboBox` element to select between search
    types. Finally, we need to add a `Button` element for our search command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MainViewModel.xaml` file, we need to add an `enum` with the search
    types. Add the following at the bottom of the file, beneath the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We are only interested in image and video searches with queries. In addition
    to these search forms, both APIs can search for trending images and videos. The
    Bing Video Search API also allows us to get more detail on any given video we
    have already searched for.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MainViewModel` class, we need to add two `string` properties corresponding
    to our `TextBox` elements. We will also need a property of type `SearchType` to
    indicate the selected search type. To indicate what search types we have available,
    we add an `IEnumerable` property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The last property we need to add to our ViewModel is the `ICommand` property,
    which will be bound to our `Button` element.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to create a new class, so create a new file called `BingSearch.cs`,
    in the `Model` folder. This will be responsible for constructing the correct endpoints
    and executing both search types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to add a member of type `BingWebRequest`. This should be created
    in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That is all we need to do here for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the ViewModel, we need to add a member of type `BingSearch`. With that
    in place, we can create our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With the ViewModel in place, we can do some searches.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our example, we will only be executing the image search based on user queries.
    To allow for this, we will need to add a function in the `BingSearch` class. Call
    the function `SearchImages` and let it accept a string as a parameter. The function
    should return `Task<ImageSearchResponse>` and be marked as `async`. `ImageSearchResponse`
    will, in this case, be a data contract object, with data deserialized from our
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We will start by constructing our endpoint. In this case, we only specify the
    query parameter, `q`. This is a required parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the common query parameters, which we will see presently, we can
    also add the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cab` | Bottom coordinate of the region to crop, in a value from 0.0 to 1.0\.
    Measured from the top-left corner. |'
  prefs: []
  type: TYPE_TB
- en: '| `cal` | The left coordinate of the region to crop, in a value from 0.0 to
    1.0. |'
  prefs: []
  type: TYPE_TB
- en: '| `car` | The right coordinate of the region to crop, in a value from 0.0 to
    1.0. |'
  prefs: []
  type: TYPE_TB
- en: '| `cat` | The top coordinate of the region to crop, in a value from 0.0 to
    1.0. |'
  prefs: []
  type: TYPE_TB
- en: '| `ct` | The crop type to use. Currently, the only legal value is 0 - Rectangular.
    |'
  prefs: []
  type: TYPE_TB
- en: 'In addition, we can specify the following parameters as filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Filter name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `aspect` | Filter images by aspect ratio. Legal values are `Square`, `Wide`,
    `Tall`, and `All`. |'
  prefs: []
  type: TYPE_TB
- en: '| `color` | Filter images by specific colors. |'
  prefs: []
  type: TYPE_TB
- en: '| `imageContent` | Filter images by image content. Legal values are `Face`
    and `Portrait`. |'
  prefs: []
  type: TYPE_TB
- en: '| `imageType` | Filter images by image types. Legal values are `AnimatedGif`,
    `Clipart`, `Line`, `Photo`, and `Shopping`. |'
  prefs: []
  type: TYPE_TB
- en: '| `license` | Filter images by license that apply to the image. Legal values
    are `Public`, `Share`, `ShareCommercially`, `Modify`, `ModifyCommercially`, and
    `All`. |'
  prefs: []
  type: TYPE_TB
- en: '| `size` | Filter images by size. Legal values are `Small` (< 200 x 200 pixels),
    `Medium` (200 x 200 to 500 x 500 pixels), `Large` (>500 x 500 pixels), `Wallpaper`,
    and `All`. |'
  prefs: []
  type: TYPE_TB
- en: '| `height` | Only get results with a specific height. |'
  prefs: []
  type: TYPE_TB
- en: '| `width` | Only get results with a specific width. |'
  prefs: []
  type: TYPE_TB
- en: 'With the endpoint in place, we can execute the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We will call `MakeRequest` on the `_webRequest` object, passing on the endpoint
    as a parameter. A successful call will result in an `ImageSearchResponse`, which
    is the deserialized data contract object from the JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting object will contain a lot of data. Among that data is an array
    that contains information about images. Each item in that array contains data,
    such as an image name, date published, URL, and image ID.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete list of the data available in a response, visit [https://msdn.microsoft.com/en-us/library/dn760791.aspx#images](https://msdn.microsoft.com/en-us/library/dn760791.aspx#images).
  prefs: []
  type: TYPE_NORMAL
- en: 'Heading over to `MainViewModel.cs`, we can now create the `Search` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With a successful response, we parse the `imageResponse`. Normally, this would
    mean displaying images in a list or similar, but we will take the easier option
    by outputting textual information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We will print out the number of matches in the search. Then, we will loop through
    the image array, printing the name, size, host, and URL of each image.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful test run should present us with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Searching for images](img/B12373_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the query-based image search, we can also search for trending
    images. To do so, you will have to call the following endpoint: [https://api.cognitive.microsoft.com/bing/v7.0/images/trending](https://api.cognitive.microsoft.com/bing/v7.0/images/trending).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, this is only available for the following markets: `en-US`, `en-CA`,
    and `en-AU`. A successful call to this endpoint will result in an array of categories.
    Each item in this array will contain an array of trending images, as well as the
    title of the category.'
  prefs: []
  type: TYPE_NORMAL
- en: Searching for videos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Searching for videos is nearly the same process as for images. The only real
    difference is how we construct the endpoint and the response we get.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add a new function in the `BingSearch` class to accompany a
    video search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there is only one required parameter: the query string, `q`.
    We can also specify a few optional parameters that are common to all the search
    APIs, which will be described later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from common filters, video can also filter results based on the following
    filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Filter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pricing` | Filter videos by price. Legal values are Free, Paid, and All.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `resolution` | Filter by resolution. Legal values are 480p, 720p, 1080p,
    and All. |'
  prefs: []
  type: TYPE_TB
- en: '| `videoLength` | Filter videos by length. Legal values is `Short` (< 5 minutes),
    `Medium` (5 to 20 minutes), `Long` (> 20 minutes), and `All`. |'
  prefs: []
  type: TYPE_TB
- en: 'With the endpoint in place, we call the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We will call `MakeRequest` on the `_webRequest` object, passing on the endpoint
    as a parameter. A successful call will result in a `VideoSearchResponse` object.
    This is a data contract, deserialized from the JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: Among other data, it will contain an array of videos. Each item in this array
    contains a video name, description, publisher, duration, URL, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete list of data available in the search response, visit [https://msdn.microsoft.com/en-US/library/dn760795.aspx#videos](https://msdn.microsoft.com/en-US/library/dn760795.aspx#videos).
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to search for videos, we add a new case in the `Search` function,
    in `MainViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the newly created `SearchVideos`, passing on the search query as a
    parameter. If the call succeeds, we go on to parse the video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As for images, we just show video information textually. In our example, we
    choose to show the video name, duration, URL, and all publishers of a video.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful video search should give the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Searching for videos](img/B12373_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the query-based video search, we can also search for trending
    videos. To do so, you would have to call the following endpoint: [https://api.cognitive.microsoft.com/bing/v7.0/videos/trending](https://api.cognitive.microsoft.com/bing/v7.0/videos/trending).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, this is only available for the following markets: `en-US`, `en-CA`,
    and `en-AU`. A successful call to this endpoint will result in an array of categories
    and tiles. Each item in the category array will contain a title and an array of
    subcategories. Each subcategory will contain an array of tiles and the title.
    Each item in a tile array will contain the video thumbnail and a query to use
    to get the specific video.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to get more information about any video, we can query the following
    endpoint: [https://api.cognitive.microsoft.com/bing/v7.0/videos/details](https://api.cognitive.microsoft.com/bing/v7.0/videos/details).'
  prefs: []
  type: TYPE_NORMAL
- en: This requires us to specify an `id` so that we can identify a video. We can
    also specify the `modulesRequested`. This is a comma-separated list of the details
    we want. Currently, the legal values are `All`, `RelatedVideos`, and `VideoResult`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete list of data available in the response from a details query,
    visit [https://msdn.microsoft.com/en-US/library/dn760795.aspx#video](https://msdn.microsoft.com/en-US/library/dn760795.aspx#video).
  prefs: []
  type: TYPE_NORMAL
- en: Helping the user with autosuggestions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Autosuggestions are a great way to enhance user experience. The typical use
    case is where, whenever a user enters some text into a text field, a list of suggested
    words is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have not already done so, sign up for the Bing Autosuggest API at [https://portal.azure.com](https://portal.azure.com).
  prefs: []
  type: TYPE_NORMAL
- en: Adding autosuggest to the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As textboxes in WPF do not contain any autosuggestion features, we need to add
    some on our own. We are going to use a third-party package, so install the `WPFTextBoxAutoComplete`
    package through the NuGet package manager, in our example project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MainView.xaml` file, add the following attribute to the starting `Window`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to make sure that the `TextBox` binding for our search query
    updates whenever the user enters data. This can be done by making sure that the
    `Text` attribute looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same `TextBox` element, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the ViewModel, in the `MainViewModel.cs` file, we need the corresponding
    property. This should be an `IEnumerable<string>` object. This will be updated
    with the result from the autosuggest query we will perform presently.
  prefs: []
  type: TYPE_NORMAL
- en: Suggesting queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get autosuggestions, we first add a new class. Add a new file called `BingAutoSuggest.cs`,
    to the `Model` folder. The `BingAutoSuggest` class should have a member of type
    `BingWebRequest`, which should be created in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new function called `Suggest`. This should accept a `string` as a parameter,
    returning a `Task<List<string>>` object. Mark the function as `async`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by constructing an endpoint, where we specify the query string,
    `q`. This field is required. We also specify the market, `mkt`, although this
    is not required. We do not need any other parameters. Before we execute the API
    call, we will create a list of suggestions, which we will return to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will make a call to `MakeRequest` on the `_webRequest` object, passing on
    the endpoint as a parameter. If the call succeeds, we expect the JSON response
    to deserialize into a `BingAutoSuggestResponse` object. This object will contain
    an array of `suggestionGroups`, where each item contains an array of `SearchSuggestions`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each item of `SearchSuggestion` contains a URL, display text, a query string,
    and a search kind. We are interested in the display text, which we add to the
    `suggestionResult` list. This list is returned to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete description of response data, go to [https://msdn.microsoft.com/en-us/library/mt711395.aspx#suggestions](https://msdn.microsoft.com/en-us/library/mt711395.aspx#suggestions).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MainViewModel.cs` file, we want to get suggestions as we type. We will
    create a new function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will call the newly created `Suggest` function, with the current value
    of the `SearchQuery`. If any results are returned, we assign them to the `SuggestionsIEnumerable`
    that we created earlier. Make sure to call this function when we set the value
    in the `SearchQuery` property.
  prefs: []
  type: TYPE_NORMAL
- en: In the UI, this will have the first suggestion automatically populated in the
    search-query field. This is not ideal for users, but it will do for our test example.
  prefs: []
  type: TYPE_NORMAL
- en: Search commonalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For all the APIs we have covered, there are a few similarities. We will cover
    these now.
  prefs: []
  type: TYPE_NORMAL
- en: Languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is highly recommended to specify which market you want results for. Searches
    will typically return results for the local market and language of the user, based
    on the current location. As you can imagine, this is not always what the user
    wants. By specifying the market, you can tailor the search results for the user.
  prefs: []
  type: TYPE_NORMAL
- en: How you choose to solve this technically is dependent on the requirements of
    your application. For a smart-house application, you would probably allow the
    user to set the market in the settings. For a web application created only for
    French users in France, you would probably not allow the user to change the market.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the market is done by adding the `mkt` parameter to the `GET` request.
    This should then specify the market code, for example, `en-US` for English in
    the United States.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While any API may support a specific market, some features may not support a
    given market.
  prefs: []
  type: TYPE_NORMAL
- en: A subset of the languages supported is English, Spanish, German, Dutch, French,
    Portuguese, Traditional Chinese, Italian, Russian, and Arabic.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we can specify a `cc` parameter to the `GET` request. This specifies
    a country (typically, the country the user is in). This parameter should be in
    the form of a two-letter country code, for instance, GB for United Kingdom.
  prefs: []
  type: TYPE_NORMAL
- en: A wide variety of countries can be specified, and the list is continuously subject
    to change.
  prefs: []
  type: TYPE_NORMAL
- en: Pagination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some searches may yield a large number of results. In these cases, you may want
    to perform pagination. This can be achieved by specifying the `count` and `offset`
    parameters in the GET request.
  prefs: []
  type: TYPE_NORMAL
- en: If you want 10 results per page, you would start by setting the count to 10,
    and the offset to 0 for the first page. When the user navigates to the next page,
    you would keep the `count` at 10, but increase the `offset` to 10\. For the next
    page, you would increase the `offset` to 20, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The maximum number of results returned in each query (the count parameter)
    varies for each API. See the following table for the current maximum count per
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '| API | Maximum search results | Default search results |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Bing News Search | 100 | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Bing Web Search | 50 | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Bing Image Search | 150 | 35 |'
  prefs: []
  type: TYPE_TB
- en: '| Bing Video Search | 105 | 35 |'
  prefs: []
  type: TYPE_TB
- en: Filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen some filters for individual APIs. In addition to these, there are
    a couple of filters which can be applied to all searches.
  prefs: []
  type: TYPE_NORMAL
- en: Safe search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The safe search filter can be used to filter search results for adult content.
    This parameter is added in the request URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `safeSearch` parameter can be one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Off**: All result items will be returned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Moderate**: Result items can contain adult text, but no adult images or videos
    will be included'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strict**: No adult text, images, or videos are included in the result items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that, if the IP address of the user indicates a location that requires
    the Strict safe search, this setting will be ignored. Bing will, in this case,
    default to the Strict policy.
  prefs: []
  type: TYPE_NORMAL
- en: If the parameter has not been set, it defaults to moderate.
  prefs: []
  type: TYPE_NORMAL
- en: Freshness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By adding the `freshness` parameter to a request, you can filter search results
    based on the age of result items. The values that can be specified are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day**: Results from the last 24 hours'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Week**: Results from the last 7 days'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Month**: Results from the last 30 days'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Among all the APIs we have covered, there are a few possible response codes
    that you may receive for each request. The following table describes all of the
    possible response codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `200` | Successful request. |'
  prefs: []
  type: TYPE_TB
- en: '| `400` | One or more required query parameters are missing, or one of the
    parameters is invalid. More details are described in the `ErrorResponse` field.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `401` | The provided subscription key is invalid or missing. |'
  prefs: []
  type: TYPE_TB
- en: '| `403` | Typically returned if the monthly quota is exceeded. Can also be
    used if the caller does not have permission to access the requested resource.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `410` | The HTTP protocol has been used instead of HTTPS, which is the only
    supported protocol. |'
  prefs: []
  type: TYPE_TB
- en: '| `429` | The quota per second has been exceeded. |'
  prefs: []
  type: TYPE_TB
- en: Searching for visual content using Bing Visual Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the **Bing Visual Search** API, one can interpret images. This API allows
    us to gain insights about images. This includes finding visually similar images,
    searches, and shopping sources. It can also identify people, places, and objects,
    as well as text.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will typically upload an image to the API to retrieve insights on it. In
    addition, you can pass on an URL to an image.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The endpoint you should use to query the Bing Visual Search API is [https://api.cognitive.microsoft.com/bing/v7.0/images/visualsearch](https://api.cognitive.microsoft.com/bing/v7.0/images/visualsearch).
  prefs: []
  type: TYPE_NORMAL
- en: 'In either scenario, the following query parameters can be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '**cc**: The two-letter language code of the country where the results should
    come from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mkt**: The market where the results come from. This should always be specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**safeSearch**: The filter used to filter adult content. Can be *Off*, *Moderate*,
    or *Strict*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setLang**: The language to use for user interface strings, that is, a two-letter
    language code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, two content headers must be specified. These are `Content-Type`
    and `Ocp-Apim-Subscription-Key`. The first one must be set to `multipart/form-data;boundary={BOUNDARY}`.
    The latter must specify the API key.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on content headers, please visit [https://docs.microsoft.com/en-us/azure/cognitive-services/bing-visual-search/overview#content-form-types](https://docs.microsoft.com/en-us/azure/cognitive-services/bing-visual-search/overview#content-form-types).
  prefs: []
  type: TYPE_NORMAL
- en: Receiving a response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the request has gone through, a JSON object will be returned as a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'This object will contain two objects: an array of `tags` and an `image` string.
    The image string is simply the insights token for the image. The list of `tags`
    contains a `tag` name and a list of `actions` (insights). A tag, in this context,
    means category. For instance, if an actor is recognized in the image, the tag
    for this might be *Actor*.'
  prefs: []
  type: TYPE_NORMAL
- en: Each action, or insight, describes something of the image. It might describe
    text in the image or different products discovered in the image. Each action includes
    a whole variety of data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see a full list of default insights, please visit [https://docs.microsoft.com/en-us/azure/cognitive-services/bing-visual-search/default-insights-tag](https://docs.microsoft.com/en-us/azure/cognitive-services/bing-visual-search/default-insight).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bing Custom Search gives you the opportunity to add a powerful, tailored search
    experience to your own applications. It allows you to search specifically for
    topics you care about.
  prefs: []
  type: TYPE_NORMAL
- en: By using the portal at [https://www.customsearch.ai/](https://www.customsearch.ai/),
    you can create a custom view of the web.
  prefs: []
  type: TYPE_NORMAL
- en: Typical workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to build a custom search web page, the following steps describe
    the typical workflow.
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a custom search instance**: This can be done at the portal linked
    in the previous section.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add active entries**: This is a list of sites that should be included in
    the search results.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add blocked entries**: This is a list of sites that should be excluded from
    the search results.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add pinned entries**: If any search term should have websites pinned to the
    top of the search result, it should be specified in the pinned entries section.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configure hosted UI**: Set the layout, color theme, and other options for
    the hosted UI.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Publish the search instance**: Publish the custom search instance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consuming the search instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are three ways to consume the custom search instance.
  prefs: []
  type: TYPE_NORMAL
- en: The first, and easiest option, is to integrate a JavaScript snippet. Once you
    have published the search instance, you will be provided with a pre-configured
    JavaScript snippet, rendering the hosted UI. This can be pasted into your existing
    web page. This will render the search form on your website.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to link to the custom HTML site directly. This is the link
    used in a JavaScript snippet, but it is only used directly.
  prefs: []
  type: TYPE_NORMAL
- en: The last option is to use the REST API directly from your own code. We will
    not go into deeper details on this in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at the different Bing Search APIs. We started
    by looking at how we can use the Bing Web Search API to search for all kinds of
    content. Next, we found the latest news, based on query strings and categories.
    From there, we moved on to image and video searches. In addition, we looked at
    how to enhance the user experience by adding autosuggestions. We did this by using
    the Bing Autosuggestion API. Finally, we briefly introduced you to Bing Visual
    Search and Bing Custom Search.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we will wrap things up. We will complete our
    smart-house application by connecting the pieces. We will also take a look at
    the road ahead.
  prefs: []
  type: TYPE_NORMAL
