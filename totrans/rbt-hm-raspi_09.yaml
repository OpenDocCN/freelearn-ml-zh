- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Teleoperating a Raspberry Pi Pico Robot with Bluetooth LE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We intend for the robot we are building to be mobile. We already have the robot
    driving on the floor and able to sense and respond to its surroundings. However,
    we either rely on it blindly or are tethered to it with a laptop. Neither is quite
    what we want. What if we could get feedback while it’s untethered and roaming
    the floor?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll see how Bluetooth **Low Energy** (**LE**) is well suited
    to this task, allowing us to get data from the robot, use an app to graph data,
    and even remotely control our robot from our smartphone!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Wireless robot connection options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting Bluetooth LE to Raspberry Pi Pico
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a Bluetooth LE sensor feed on Raspberry Pi Pico
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teleoperating the robot with Bluetooth LE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The robot from [*Chapter 8*](B18001_08.xhtml#_idTextAnchor166), *Sensing Distances
    to Detect Objects* *with Pico*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Adafruit Bluefruit LE UART Friend ADA2479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x eight-way single-row 2.54-mm header (included with the module)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5 x male-to-female jump wires with a 2.54-mm DuPont connector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to an Android or iOS smartphone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Velcro hook and loop dots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code from previous chapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Raspberry Pi Pico code editor such as Mu or Thonny
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB micro cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-09](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-09).
  prefs: []
  type: TYPE_NORMAL
- en: Wireless robot connection options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we’ve been working with the robot tethered to our computer. We send
    code to it and use the REPL tools to see what it is doing or printing out. While
    the REPL tools can be convenient, having a wire between the computer and the robot
    is not so convenient and limits how far the robot can drive or has you running
    behind it with the laptop. The following diagram shows how we could do things:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Robot connections ](img/Figure_9.01_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Robot connections
  prefs: []
  type: TYPE_NORMAL
- en: The top part of the diagram shows things tethered with a wire. But the bottom
    part shows that the computer and the robot are not physically wired together.
    Instead, they are using wireless to send data to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are wireless, we can also consider a smartphone coming in as an alternative
    item. We can use a wireless medium to send data from the robot’s sensors or code
    to see what is going on and monitor it. We can also send control signals to take
    control and drive our robot.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different wireless protocols we can use. All require our robot
    to have a **transceiver** – transmitter and receiver – board.
  prefs: []
  type: TYPE_NORMAL
- en: While some robot controllers, such as Raspberry Pi 4, have onboard transceivers,
    Raspberry Pi Pico does not. Therefore, we will need to add a breakout. In addition,
    they come with different protocols and different implementations of those protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which transceiver boards might we choose and why? The following table shows
    the comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.1 – Transceiver modules for Pico ](img/Table_9.01_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 9.1 – Transceiver modules for Pico
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding table, I’ve picked boards that come with onboard software stacks,
    reducing the amount of code we need. We are less concerned with speed as we don’t
    intend to send camera data; however, latency is important as we want our robot
    to respond quickly to commands and send up-to-date sensor data.
  prefs: []
  type: TYPE_NORMAL
- en: Support is important – we want to choose modules with good support from their
    vendors and the community. For example, Adafruit has excellent support and documentation
    for their modules, with online communities on Discord and other forums and all
    their code available on GitHub, which gives their modules a lot of credibility
    over cheaper and less well-supported options.
  prefs: []
  type: TYPE_NORMAL
- en: An honorable mention must go to Raspberry Pi Pico W – a Pico with an onboard
    Wi-Fi chip. This has excellent support from the Raspberry Pi community. It has
    the added complexity of requiring you to serve up a graphing web frontend, however
    it may make a very good alternative.
  prefs: []
  type: TYPE_NORMAL
- en: The HM-10 modules are widely available and may even be super cheap, but their
    unusual protocols mean connecting with them needs more code.
  prefs: []
  type: TYPE_NORMAL
- en: The choice with the most going for it here is the Adafruit Bluefruit LE board.
    It has low current usage and is small. There is a **Serial Peripheral Interface**
    (**SPI**) and a **Universal Asynchronous Receiver/Transmitter** (**UART**; defined
    in more detail as follows) version of this board. **Bluetooth LE** is a low-energy
    variant of Bluetooth, ideal for short-range communications between devices such
    as a robot and a controller. It has a range of up to 100 m. Bluetooth LE has two-thirds
    of the data rate compared to regular Bluetooth but consumes half the current when
    active. Smart software profiles allow it to frequently use low-power modes, and
    rapidly wake up when needed.
  prefs: []
  type: TYPE_NORMAL
- en: UART doesn’t need much configuration and only uses two wires (as opposed to
    the three or more wires SPI or I2C uses). There is no clock line (just an agreement
    on speeds) and no address, just one-to-one device communication. We have already
    been using a USB-based UART to communicate with Raspberry Pi Pico.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Adafruit Bluefruit LE UART Friend board for simplicity in our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: It is widely available through Adafruit directly or through distributors such
    as Pimoroni and Mouser Electronics.
  prefs: []
  type: TYPE_NORMAL
- en: Adafruit Bluefruit is an ecosystem of Bluetooth LE-based development boards,
    so there’s lots of compatible code. In addition, it works with computers and phones
    that have built-in Bluetooth LE transceivers, and Adafruit makes apps for both
    computers and phones to communicate with them. These apps will save us time, as
    other solutions require you to build your apps.
  prefs: []
  type: TYPE_NORMAL
- en: We now know which module we will use. So we can make use of it, let’s take the
    Bluefruit LE UART board and connect it to our robot!
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Bluetooth LE to Raspberry Pi Pico
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Bluefruit LE UART Friend is relatively simple to wire in. First, the module
    will need headers soldered onto it, and then we can look at how to attach it to
    the robot physically and how to wire it. We will then connect to it from our robot
    and a smartphone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding Bluetooth LE will result in our robot having a block diagram as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Robot block diagram with Bluetooth ](img/Figure_9.02_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Robot block diagram with Bluetooth
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the robot blocks with the additional Adafruit Bluefruit
    LE UART Friend (marked as a Bluefruit module) connected via UART to Raspberry
    Pi Pico.
  prefs: []
  type: TYPE_NORMAL
- en: Solder a set of male headers onto the board using the same techniques used for
    the modules in [*Chapter 8*](B18001_08.xhtml#_idTextAnchor166), *Sensing Distances
    to Detect Objects* *with Pico*.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the Bluetooth module to the robot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to place the module above devices that are most likely to restrict and
    interfere with the Bluetooth. We created a breakout shelf in [*Chapter 7*](B18001_07.xhtml#_idTextAnchor139),
    *Planning and Shopping for More Devices*, for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following photo shows how the headers should be attached:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Adafruit Bluetooth LE UART Friend with headers ](img/Figure_9.03_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Adafruit Bluetooth LE UART Friend with headers
  prefs: []
  type: TYPE_NORMAL
- en: The previous figure shows the device with the headers. They should be soldered
    so they are standing above the pin names, facing the same way as the switch. The
    switch should be in UART mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the attachment to be good enough not to slide around or stick out awkwardly
    due to cable tension. You could make a more permanent connection by drilling the
    appropriate holes in the shelf, but a convenient way for quick prototype platforms
    is to use Velcro (hook and loop) dots. Look at the following photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Bluefruit module Velcro connection ](img/Figure_9.04_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Bluefruit module Velcro connection
  prefs: []
  type: TYPE_NORMAL
- en: The previous photo shows the Bluetooth breakout module with a Velcro dot ready
    to attach to the Velcro dot already attached to the robot’s shelf.
  prefs: []
  type: TYPE_NORMAL
- en: The Velcro gives us a convenient way to attach/detach the module without it
    sliding off.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to wire the Bluetooth breakout into Raspberry Pi Pico.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the Bluetooth breakout to Raspberry Pi Pico
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Wiring the Adafruit Bluefruit LE UART Friend module requires only five wires.
    The following photo shows the connections you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Connecting the Bluefruit LE module to Pico ](img/Figure_9.05_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Connecting the Bluefruit LE module to Pico
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows, as a schematic, the connection between the Bluefruit
    module and Raspberry Pi Pico.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, connect the module to power and ground, with the VIN going to 3.3V power.
    Next, the CTS pin needs to be connected to ground to send and receive data via
    UART. The next figure shows how the TX and RX pins interact:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Transmit and receive pins ](img/Figure_9.06_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Transmit and receive pins
  prefs: []
  type: TYPE_NORMAL
- en: Pay close attention to the transmit and receive pins (shown in *Figure 9**.5*)
    on the UART. TX (transmit) on one device always goes to RX (receive) on the other.
    The most common wiring failure is to confuse these pins.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the RXI (receive input) pin on the Bluefruit to PIN12, the TX (transmit)
    pin 12 on Pico, and TXD (transmit data) from Bluefruit to the RX pin 13 on Pico.
  prefs: []
  type: TYPE_NORMAL
- en: You should have now made five connections. The Bluetooth LE device is ready
    to turn on. Let’s try some code to connect to it over UART.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the Bluefruit LE device with UART
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have the board connected and a smartphone ready to talk to it, how can
    we get our Raspberry Pi Pico to communicate? Let’s start by making a Hello Bluetooth
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder named `bluetooth-hello-world`. In a slight departure from our
    previous examples, we can name the main file `code.py`, and we only need to drag
    and drop the content of our example folders onto the CircuitPy volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start `bluetooth-hello-world/code.py` with imports for the board, and `busio`,
    which has code for the UART bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the IO pins from `board` to create a UART object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that we could have multiple UARTs on different pin combinations for other
    sensors and devices. We have specified the `9600` is the default for this device,
    as specified in its datasheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this in a loop to check for any input – this is how we know something
    is connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In every loop, we try reading up to 32 bytes. If we get anything (it’s not showing
    `None`), then we respond with a `hello` message. The `uart.write` method sends
    bytes, not strings, so we must encode the string to send it. Also, note the `\n`
    character at the end – this is a new line in the output.
  prefs: []
  type: TYPE_NORMAL
- en: Copy this over to Pico, and it will now be running, waiting for something to
    connect. So, let’s connect something to our Pico via Bluetooth LE!
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a smartphone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A smartphone makes a great client to connect to the robot and see what is going
    on. You can use an Android/iOS smartphone to connect to the Bluefruit by finding
    the Bluefruit LE Connect app on the app store appropriate to that phone.
  prefs: []
  type: TYPE_NORMAL
- en: This app is free. Alternatives are available at [https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/software-resources](https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/software-resources),
    including desktop apps with similar functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the Bluefruit LE Connect app. The following screenshots show what you’ll
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.7 – Connecting to Bluetooth LE UART devices ](img/Figure_9.07_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Connecting to Bluetooth LE UART devices
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshots, the panel on the left shows the app. With your
    robot powered on and the Adafruit Bluefruit LE connected, you should see the device
    in the list on the app. There may be many Bluetooth devices; you can turn on the
    **Must have UART Service** toggle to filter these. You can then click the **Connect**
    button to connect to the device.
  prefs: []
  type: TYPE_NORMAL
- en: When doing so, you should see a solid blue light on the Bluefruit board on the
    robot. You will also see the screen on the right. Bluefruit LE Connect may ask
    you to perform an update on the Bluetooth device; if so, please follow the onscreen
    instructions and accept this before proceeding. This may take a short while.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **UART** button in the menu to send and receive data. You should
    see screens like those shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Interacting over Bluetooth UART ](img/Figure_9.08_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Interacting over Bluetooth UART
  prefs: []
  type: TYPE_NORMAL
- en: The UART screen, shown in the preceding screenshot, lets you interact with and
    see output from the module. The left panel shows me typing `hello`. Try this yourself
    and hit the **Send** button to send data to the module – our code will respond
    when you send something to it.
  prefs: []
  type: TYPE_NORMAL
- en: The right panel shows the robot responding with the message. It may take around
    a second to respond here. It may send the message twice if you send more than
    32 characters.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be in contact with the module. If not, try the following troubleshooting
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting the Bluefruit module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following should get you up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: When it is powered up, there should be a red light on the Bluefruit module.
    If not, disconnect the power immediately and verify the power (3.3V) and ground
    wiring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should see a solid blue light when you connect to the Bluefruit device from
    the smartphone. If not, verify that you have connected to the correct device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you cannot see the `Hello, Bluetooth World!` message, please verify that
    the TX and RX wiring is correct; reversing them is a common issue with the wiring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should now have this module connected and able to send data from the robot
    to a listening device. Let’s make use of this to send sensor data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting sensor data over Bluetooth LE on Raspberry Pi Pico
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you’ve tested the sensor-based examples, seeing their output in the
    console by connecting your laptop to it. However, building on our `hello world`
    example and the distance sensing in [*Chapter 8*](B18001_08.xhtml#_idTextAnchor166),
    *Sensing Distances to Detect Objects with Pico*, we can not only see the sensor
    output over UART as text but also plot in in a graph. So, let’s get into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll put this code in a folder named `bluetooth-distance-sensors`. Copy in
    the `robot.py` and `pio_encoder.py` files. We will add `code.py`. Let’s start
    with the imports, combining the sensors and bus setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With the UART now prepared, we can prepare the sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve set both sensors ranging and in the correct mode. We can now start a
    loop and fetch the sensor data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We wait until the data is ready before fetching the distance, and we store
    the distance from both sensors. We can now send the data to the UART:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We use an f-string to format the data from both sensors into one line, separated
    by a comma. We must also include the end-of-line, `\n`, character again and encode
    it into bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must then ensure the sensors on the robot are ready to take another reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can wait for a little time before trying again. Add the following code outside
    the `if` block but inside the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This sleep completes the code for this example. As an overview, this loop will
    read the sensors, send data when it has a reading, and then send this over the
    UART, and it will sleep for a little time and go again.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you copy this code to the robot and connect the phone with the **UART**
    menu option, you will be able to see the two numbers vary as you move things in
    front of the sensors. The following screenshot shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – The sensor output as text ](img/Figure_9.09_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – The sensor output as text
  prefs: []
  type: TYPE_NORMAL
- en: The previous screenshot shows how the data is output as plain text numbers.
    You can disconnect the computer and put the robot on independent battery power,
    and you should still be able to connect to it and see the sensor readings.
  prefs: []
  type: TYPE_NORMAL
- en: This data feed is great as we have a remote view of the robot. However, we can
    now go one better and graph this data.
  prefs: []
  type: TYPE_NORMAL
- en: Graphing the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The phone app has the built-in ability to graph data in comma-separated format.
    We can use this for the output of numeric data to quickly visualize what is going
    on.
  prefs: []
  type: TYPE_NORMAL
- en: From the UART screen, click on the back button to go back to the options menu
    for this connection. Then, click the **Plotter** button to access the plot mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshots show how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.10 – Enabling graphing ](img/Figure_9.10_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Enabling graphing
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshots show how to access the graph functionality and an
    example sensor data graph.
  prefs: []
  type: TYPE_NORMAL
- en: The app will use any comma-separated numeric data, and I’ve tested it with six
    columns of data so far. If the output seems patchy, please ensure you allow the
    app to make an over-the-air update of the Bluetooth device, as this significantly
    improves the throughput.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how to get robot sensor data and use it to plot what is going on
    with the sensors. However, we might also want to use our Bluetooth services to
    take control of the robot. Let’s see how in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the robot with Bluetooth LE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bluetooth LE is a two-way medium. In this section, we’ll see how to receive
    data from the UART and, better yet, how to decode that data into control signals.
    By the end of this section, you’ll be able to drive your robot with a smartphone!
  prefs: []
  type: TYPE_NORMAL
- en: Printing what we got
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we try to decode control packets, let’s just make a simple app to echo
    whatever shows on the Bluefruit UART out onto the Raspberry Pi Pico console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put the following code in `bluetooth-print-incoming/code.py`. We start by importing
    and setting up the UART port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The one difference here is that I’ve added a short timeout. Without the short
    timeout, the port will wait a full second for the number of bytes read. You might
    have noticed with the Hello world example that it took a second before you got
    the output, and this will be why. We want to get control data as soon as possible.
    There’s also a `print` statement, so we know it’s ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have the main loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This loop reads data from the port. First, it checks whether there is data waiting,
    then tries to read up to 32 bytes and immediately prints what we got, then tries
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go back to the **UART** menu option in the phone app, you will be able
    to type messages on the phone and see them appear in the Pico console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Echoing incoming Bluetooth UART messages on the Pico console
    ](img/Figure_9.11_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Echoing incoming Bluetooth UART messages on the Pico console
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.11* shows a screenshot of the phone on the left, ready to send
    a message. The screenshot on the right shows the message appearing in the Raspberry
    Pi Pico console. Notice the `b` prefix. This prefix means it’s a raw byte message.
    We will be able to extract our button data from this.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let’s see how the smartphone app can use this for control.
  prefs: []
  type: TYPE_NORMAL
- en: Button control mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the phone app, there were several different menu modes for interacting with
    the robot. One of these is **Controller** mode. The following screenshots show
    how this looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Bluefruit app Controller mode ](img/Figure_9.12_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Bluefruit app Controller mode
  prefs: []
  type: TYPE_NORMAL
- en: The screenshots show the controller mode. The leftmost screenshot shows the
    initial **Controller** app screen; from this, we pick **Control Pad**.
  prefs: []
  type: TYPE_NORMAL
- en: The screenshot in the middle shows the control pad. In this screenshot, on the
    left is a directional pad, and on the right is a set of numeric buttons. We can
    send both signals to the robot.
  prefs: []
  type: TYPE_NORMAL
- en: The third, rightmost screenshot shows how the control signals look when printed.
    This output looks like some strange text, but that is because it is data encoded
    into a data **packet**. A packet is a chunk of data on a bus.
  prefs: []
  type: TYPE_NORMAL
- en: These control signal packets encode the button that changed and whether it was
    pressed or released. Try pressing a button now with the `print-incoming` app,
    and you will see a set of control codes. They aren’t particularly human-readable,
    so we’ll need to decode them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make some code to detect and decode button control packets.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding button control packets to drive the robot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adafruit has a library for specifically handling and decoding these packets.
    Copy the `adafruit_bluefruit_connect` folder from the CircuitPython bundle into
    your Pico at `CIRCUITY/lib`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can import this into our code and use it to drive the robot. Create a folder
    called `bluetooth-teleoperation` on your computer. Copy the most recent `robot.py`
    and `pio_encoder.py` files into this. We’ll start a `code.py` file with the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The imports are mostly familiar, but we’ve added the button packet type so we
    can decode control pad buttons. We also set up the UART to receive data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys send a keypress and key release. What we don’t want is for the robot
    to receive nothing from the phone and keep driving, so we will have a stop time.
    We are also going to set an overall driving speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now get into the app’s main loop. The first thing we’ll do is check
    for waiting data, and if there is some, decode it as button presses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `from_stream` function will decode a button packet directly from the UART.
    It frees us from considering the byte size of that packet by trying to read the
    right number of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a packet, we can check whether the button was pressed or released
    and ensure we stop the robot if it is released:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code first checks whether you’ve pressed the button. We then started
    matching the button code with different buttons and changing motor speeds to drive
    or turn depending on which you pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to consider timeouts. If we have pressed a button, we should
    reset the timeout, and in the outer loop, we should check the timeout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the `if` packet block, we add 3 seconds to the current time; this
    will be when we time out. Then, at the bottom of the `while` loop, if we’ve passed
    the `stop_at` time, we stop the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Copy this over to CircuitPython on Pico, and you will now be able to use the
    buttons to drive the robot. You can disconnect it from the computer, turn on battery
    power, and drive it.
  prefs: []
  type: TYPE_NORMAL
- en: You can now use control pad buttons to drive the robot. Press and hold a button
    and it will drive for up to 3 seconds without a further keypress; you’ll need
    to press multiple times to drive further. This 3-second timeout is a compromise
    between ensuring it doesn’t run away and making it fun to drive.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the robot is not responding and you have been through the previous examples,
    try this troubleshooting method.
  prefs: []
  type: TYPE_NORMAL
- en: In code like this, adding `print` statements will help. When you have the robot
    connected to the computer, you can just use `print`. Otherwise, use `uart.write(message.encode())`.
    Try adding these before the `while` loop starts and in places where the code handles
    buttons.
  prefs: []
  type: TYPE_NORMAL
- en: By printing before the `while` loop, we know our code started (if not, we can
    connect it to the computer to look for error messages). Likewise, we can tell
    that button signals are being decoded by printing when it handles buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Printing like this lets us narrow down where the problem is. By checking the
    lines around any output we fail to see, we can see what might be incorrect or
    whether there is wiring to verify.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a remote-controllable robot!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to hook a Bluefruit LE transceiver to our
    robot and then use it to send and receive data. We’ve seen the robot data go to
    a smartphone and data go from a smartphone back to Pico on the robot.
  prefs: []
  type: TYPE_NORMAL
- en: We then took this up a level and sent formatted data to plot sensor information
    on the phone, allowing us to remotely visualize the robot’s state.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used the smartphone app to control and drive the robot. In the next
    chapter, we will look at the PID algorithm, a neat way to tie sensor data and
    outputs together in a feedback loop, and we’ll use our new remote data plotting
    ability to tune it!
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These exercises let you extend the functionality of your robot code and deepen
    your understanding of the topics:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Bluetooth control app, there are four numeric buttons. Could you extend
    the control program to use these to control the robot’s speed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Bluetooth control pad app also has a little window to show messages. Try
    sending messages back from the robot code to the app to show in this window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Could you use the plotting code with the encoder counts and plot these? Perhaps
    divide their total counts by elapsed time in the code, or reset the encoder counts
    and reread them to plot a rate per second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adafruit’s great support for the Bluefruit UART LE Friend includes a product
    page with dimensions – [https://www.adafruit.com/product/2479](https://www.adafruit.com/product/2479).
    In addition, they have content on the Adafruit learn website at [https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/](https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/),
    including material on more ways to connect and use the device, complete datasheets
    and specifications, along with additional software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adafruit also has a `#help-with-radio` channel on their Discord with a community
    that specifically helps with problems, questions, and ideas about their transceiver
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: For further information on Bluetooth LE, check out *Building Bluetooth Low Energy
    Systems* by Muhammad Usama bin Aftab. This book has a detailed dive into wireless
    network communication systems suitable for use in **Internet of Things** (**IoT**).
    IoT concepts translate well into robotics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Adding More Robotic Behaviors to Raspberry Pi Pico'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve seen some sensors, we can add more interesting robot behaviors.
    We will learn robot algorithms to make more use of the distance sensors and encoders.
    Then we introduce the Inertial Measurement unit. Finally, we will look at how
    to use the sensors to locate a robot in a known space.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18001_10.xhtml#_idTextAnchor210), *Using the PID Algorithm
    to Follow Walls*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18001_11.xhtml#_idTextAnchor233), *Controlling Motion with
    Encoders on Raspberry Pi Pico*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18001_12.xhtml#_idTextAnchor252), *Detecting Orientation with
    an IMU on Raspberry Pi Pico*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B18001_13.xhtml#_idTextAnchor274), *Determining Position using
    Monte Carlo Localization*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B18001_14.xhtml#_idTextAnchor302), *Continuing Your Journey
    – Your Next Robot*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
