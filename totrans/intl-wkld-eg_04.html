<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer029">
			<h1 id="_idParaDest-33"><em class="italic"><a id="_idTextAnchor032"/>Chapter 2</em>: Foundations of Edge Workloads</h1>
			<p>This chapter will explore the next level of detail regarding <strong class="bold">edge workloads</strong> and your first hands-on activity. You will learn how <strong class="bold">AWS IoT Greengrass</strong> meets the needs for designing and delivering modern edge ML solutions. You will learn how to prepare your edge device to work with AWS by deploying a tool that checks your device for compatible requirements. Additionally, you will learn how to install the IoT Greengrass core software and deploy your first IoT Greengrass core device. You will learn about the structure of components, examine the fundamental unit of software in IoT Greengrass, and write your first edge workload component. </p>
			<p>By the end of this chapter, you should start to feel comfortable with the basics of IoT Greengrass and its local development life cycle. </p>
			<p>In this chapter, we are going to cover the following main topics:</p>
			<ul>
				<li>The anatomy of an edge ML solution</li>
				<li>IoT Greengrass for the win</li>
				<li>Checking compatibility with IoT Device Tester</li>
				<li>Installing IoT Greengrass</li>
				<li>Your first edge component</li>
			</ul>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Technical requirements</h1>
			<p>The technical requirements for this chapter are the same as those described in the Hands-on prerequisites section in <a href="B17595_01_Final_SS_ePub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a><em class="italic">, Introduction to the Data-Driven Edge with Machine Learning</em>. Please refer to the full requirements mentioned in that chapter. As a reminder, you will need the following:</p>
			<ul>
				<li>A Linux-based system to deploy the IoT Greengrass software. A Raspberry Pi 3B, or later, is recommended. The installation instructions are similar to other Linux-based systems. Please refer to the following GitHub repository for further guidance when the hands-on steps differ for systems other than a Raspberry Pi.</li>
				<li>A system to install and use the AWS <strong class="bold">Command-Line Interface</strong> (<strong class="bold">CLI</strong>), enabling access to the AWS Management Console website (typically, your PC/laptop).</li>
			</ul>
			<p>You can access this chapter's technical resources from the GitHub repository, under the <strong class="source-inline">chapter2</strong> folder, at <a href="https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter2">https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter2</a>.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>The anatomy of an edge ML solution</h1>
			<p>The previous <a id="_idIndexMarker081"/>chapter introduced the concept of an edge solution along with the three key kinds of tools that define an edge solution with ML applications. This chapter provides more detail regarding the layers of an edge solution. The three<a id="_idIndexMarker082"/> layers addressed in this section are as follows:</p>
			<ul>
				<li>The <strong class="bold">business logic layer</strong> includes the customized code that dictates the solution's behavior.</li>
				<li>The <strong class="bold">physical interface layer</strong> connects your solution to the analog world with sensors and actuators.</li>
				<li>The <strong class="bold">network interface layer</strong> connects your solution to other digital entities in the wider network. </li>
			</ul>
			<p>Learning more about these layers is important because they will inform how you, as the IoT architect, make trade-offs when designing your edge ML solution. First, we'll start by defining the business logic layer.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Designing code for business logic</h2>
			<p>The <a id="_idIndexMarker083"/>business<a id="_idIndexMarker084"/> logic layer is where all the code of your edge solution lives. This code can take many shapes, such as <em class="italic">precompiled binaries</em> (such as a C program), <em class="italic">shell scripts</em>, <em class="italic">code evaluated by a runtime</em> (such as a Java or Python program), and <em class="italic">ML models</em>. Additionally, code can be organized in a few different ways such as shipping everything into a monolithic application, splitting up code into services or libraries, or bundling code to run in a container. All of these options come with implications for architecting and shipping an edge ML solution, such as security, cost, consistency, productivity, and durability. Some of the challenges of delivering code for the business logic layer are as follows:</p>
			<ul>
				<li>Writing and testing code that will run on your edge hardware platforms. For example, writing code that will work on variations of hardware platforms as incremental new versions are rolled out. You will want to minimize the number of forks of code you maintain that meet the needs of all your hardware platforms.</li>
				<li>Designing a robust edge solution that encompasses many features. For example, bundling features to process new sensor data, analyze data, and communicate with web services that do not create conflicts with common dependencies or local resources.</li>
				<li>Writing code with a team of people all working on an aggregate edge solution. For example, a monolithic application with many contributors can require each author to fully know the solution to make an incremental change.</li>
			</ul>
			<p>To address <a id="_idIndexMarker085"/>the challenges of writing your business <a id="_idIndexMarker086"/>layer logic, the best practice for shipping code to the edge is to use <strong class="bold">isolated services</strong> where practical.</p>
			<h3>Isolated services</h3>
			<p>On <a id="_idIndexMarker087"/>your <em class="italic">Home Base Solutions hub device</em> (the fictional product we are creating from the story in <a href="B17595_01_Final_SS_ePub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to the Data-Driven Edge with Machine Learning</em>), code will be deployed and run as isolated services. In this context, a <strong class="bold">service</strong> is a self-contained unit of business logic that is either invoked by another entity to perform a task or performs a task on its own. <strong class="bold">Isolation</strong> means that the service will bundle with it the code, resources, and dependencies it needs for its operation. For example, a service you will create in <a href="B17595_07_Final_SS_ePub.xhtml#_idTextAnchor138"><em class="italic">Chapter 7</em></a>, <em class="italic">Machine Learning Workloads at the Edge</em>, will run code to read from a data source or collection of images, periodically compute inferences using a bundled ML model, then publish any inference results to a local stream or the cloud. This pattern of isolated services is selected for two reasons: </p>
			<ul>
				<li>The first reason is that a <strong class="bold">service-oriented architecture</strong> enables architects to design capabilities<a id="_idIndexMarker088"/> that are decoupled from one another. <strong class="bold">Decoupling</strong> means <a id="_idIndexMarker089"/>we use data structures, such as buffers, queues, and streams, to add a layer of abstraction between our services, reducing dependencies to allow services to run independently. <p>You can deploy updates to individual services without touching other running services and, therefore, reduce the risk of impact on them. Decoupled, service-oriented architecture is a best practice for designing well-architected cloud solutions that are also a good fit for edge ML solutions where multiple services are simultaneously running and emphasize a need for reliability. For example, a service that interfaces a sensor writes new measurements to a data structure and nothing more; it has a single job and doesn't need to be aware of how the data is consumed by a later capability. </p></li>
				<li>The second reason is that the <strong class="bold">isolation</strong> of code enables developers to focus on what that <a id="_idIndexMarker090"/>code does instead of where the code is going or how dependencies are managed at the destination. By using principles of isolation to bundle runtime dependencies and resources with code, we get stronger consistency that code will work deterministically wherever it is deployed. Developers free up the effort required for dependency management and have more confidence that the code will work the same way on the edge platform, which is likely different than their development environment. That's not to say an edge solution developer won't need to test the behavior of their code against physical interfaces such as sensors and actuators. However, it does mean that development teams can deliver self-contained services that work independently regardless of the rest of the services deployed in the aggregate edge solution. <p>Examples of isolation include <strong class="bold">Python</strong> virtual environments, which explicitly specify a Python runtime version and package, and <strong class="bold">Docker Engine</strong>, which uses containers to bundle dependencies, resources, and achieve process isolation on the host. The following diagram illustrates the separation of concerns achieved with isolated services:</p></li>
			</ul>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="Images/B17595_02_001.jpg" alt="Figure 2.1 – An edge solution using decoupled, isolated services&#13;&#10;" width="1650" height="790"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – An edge solution using decoupled, isolated services</p>
			<p>In tandem, the patterns of isolation and services offer compelling benefits for edge ML solutions. Of course, every decision in development comes with trade-offs. The solution would be simpler if deployed as a singular monolith of code and faster to derive a minimum viable product. We opt for more architectural complexity because this leads to better <a id="_idIndexMarker091"/>resiliency and a scaling up of the solution over time. We lean on strong patterns and good tooling to balance that complexity. </p>
			<p>IoT Greengrass is designed with this pattern in mind. Later, in this chapter and throughout the book, you will learn how to use this pattern with IoT Greengrass to develop well-architected edge ML solutions. </p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Physical interfaces</h2>
			<p>A cyber-physical <a id="_idIndexMarker092"/>solution is<a id="_idIndexMarker093"/> defined by the use of physical interfaces to interact with the analog world. These interfaces come in two classifications: <em class="italic">sensors for taking measurements from the analog world</em> and <em class="italic">actuators for exerting change back upon it</em>. Some machines do both, such as a refrigerator that senses internal temperature and activates its compressor to cycle a refrigerant through coils. In these cases, the aggregation of sensing and actuating is logical, meaning the sensor and actuator have a relationship but are functionally independent and are coordinated via a mechanism such as a switch, circuit, or microcontroller.</p>
			<p>Sensors that perform analog-to-digital conversion do so by sampling the voltage from an electrical signal and converting it into a digital value. These digital values are interpreted by code to derive data such as temperature, light, and pressure. Actuators convert digital signals into analog actions, typically, by manipulating the voltage going to a switch or circuit. A command to engage a motor is interpreted as raising a voltage to the level that activates the circuit. Diving deeper into the electrical engineering of physical interfaces is beyond the scope of this book. Please refer to the <em class="italic">References</em> section for recommendations on deeper dives on that topic. The following diagram shows a simple analog example of a <a id="_idIndexMarker094"/>refrigerator and the relationship between the thermostat (sensor), switch (controller), and <a id="_idIndexMarker095"/>compressor (actuator):</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="Images/B17595_02_002.jpg" alt="Figure 2.2 – An analog controller with a sensor and an actuator&#13;&#10;" width="780" height="345"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – An analog controller with a sensor and an actuator</p>
			<p>It's important to understand the patterns of input and output delivered by a cyber-physical solution and the relationship to a higher-level outcome delivered through an edge ML solution. Throughout the project delivered in this book, you will gain hands-on experience applying these patterns. Some of the services of the Home Base Solutions hub device will serve as interfaces to the physical layer, providing new measurements from the sensors and converting the commands to change the state of local devices. If you are working with a physical edge device, such as the Raspberry Pi, you will get some experience of <a id="_idIndexMarker096"/>using<a id="_idIndexMarker097"/> code to interact with the physical interfaces of that device.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Network interfaces</h2>
			<p>The third<a id="_idIndexMarker098"/> layer <a id="_idIndexMarker099"/>to introduce for our edge solution anatomy is the <em class="italic">network interface</em>. A differentiator between our definitions of cyber-physical solutions and edge solutions is that an edge solution will, at some point, interact with another entity over a network. For example, the design of our new appliance monitoring kit for Home Base Solutions uses wireless communication between the monitoring kit and the hub device. There is no physical connection between the two for the purposes of analog-to-digital signal conversion from the monitor's sensors. </p>
			<p>Similarly, the hub device will also exchange messages with a cloud service to store telemetry to use in the training of the ML model, to deploy new resources to the device, and to alert customers of recognized events. The following diagram illustrates the flow of messages and the relationships between a <strong class="bold">Sensor</strong>, <strong class="bold">Actuator</strong>, hub device (<strong class="bold">Gateway</strong>), and the cloud service:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="Images/B17595_02_003.jpg" alt="Figure 2.3 – An edge device exchanging messages with local sensors, actuators, and the cloud&#13;&#10;" width="1229" height="384"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – An edge device exchanging messages with local sensors, actuators, and the cloud</p>
			<p>Wireless communications are common in IoT solutions, and specific implementations enable connectivity at a wide range of distances. Each specification and implementation makes trade-offs for range, data transmission rate, hardware cost, and energy consumption. Short-range radio <a id="_idIndexMarker100"/>specifications such as <strong class="bold">Zigbee</strong> (IEEE 802.15.4), <strong class="bold">Bluetooth</strong> (IEEE 802.15.1), and <strong class="bold">WiFi</strong> (IEEE 802.11) are suitable for bridging devices within personal and local area networks. Long-range radio specifications such as conventional cellular networks (for example, <strong class="bold">GSM</strong>, <strong class="bold">CDMA</strong>, and <strong class="bold">LTE</strong>) and <strong class="bold">low-power wide-area networks</strong> (<strong class="bold">LPWANs</strong>) such<a id="_idIndexMarker101"/> as <strong class="bold">LoRaWAN</strong> and <strong class="bold">NB-IoT</strong> deliver connectivity<a id="_idIndexMarker102"/> options for devices deployed (either static or roaming) across a particular campus, city, or region. </p>
			<p>Wired communications are still common for connecting edge devices such as TVs, game consoles, and PCs to home network solutions such as switches and routers over <strong class="bold">Ethernet</strong>. Wired connectivity is less common in smart home products due to the limited number of Ethernet ports on home networking routers (typically, there are only 1–8 ports), the restrictions regarding where the device can be placed, and the burden of adding wires throughout the home. </p>
			<p>For example, the Home Base Solutions appliance monitoring kit would likely use a Zigbee, or equivalent implementation, and a battery to balance energy consumption with the anticipated data rate. If the kit required a power supply from a nearby outlet, Wi-Fi becomes more of an option; however, it would limit the overall product utility as the placement of the kinds of appliances to monitor don't always have a spare outlet. Additionally, it wouldn't make sense to use Ethernet to connect the kits to the hub directly since customers likely wouldn't find all of the extra wires running throughout the home appealing. The hub device that communicates with the kit could use Ethernet or Wi-Fi to bridge to the customer's local network to gain access to the public internet. </p>
			<p>Now that <a id="_idIndexMarker103"/>you<a id="_idIndexMarker104"/> have a better understanding of the three layers of an edge solution, let's evaluate the selected edge runtime solution and how it implements each layer.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>IoT Greengrass for the win</h1>
			<p>The most important <a id="_idIndexMarker105"/>question to answer in a book about using IoT Greengrass to deliver edge ML solutions is <em class="italic">why IoT Greengrass?</em> When evaluating the unique challenges of edge ML solutions and the key tools required to deliver them, you want to select tools that solve as many problems for you as possible while staying out of your way in terms of being productive. IoT Greengrass is a purpose-built tool with IoT and ML solutions at the forefront of the value proposition. </p>
			<p>IoT Greengrass is prescriptive in how it solves the problem of the <em class="italic">undifferentiated heavy lifting</em> of common requirements while remaining non-prescriptive in how you implement your business logic. This means that the out-of-box experience yields many capabilities for rapid iteration without being obstructive about how you use them to reach your end goals. The following is a list of some of the capabilities that IoT Greengrass<a id="_idIndexMarker106"/> has to offer:</p>
			<ul>
				<li><strong class="bold">Security at the edge</strong>: IoT Greengrass is installed with root permissions and uses operating system user permissions to protect the code and resources deployed at the edge from tampering.</li>
				<li><strong class="bold">Security to the cloud</strong>: IoT Greengrass uses mutual <strong class="bold">transport layer security</strong> (<strong class="bold">TLS</strong>) with <a id="_idIndexMarker107"/>public key infrastructure to exchange messages between the edge and the cloud. Resources are fetched during deployments using HTTPS and AWS Signature Version 4 to verify the identity of the requester and protect data in transit. </li>
				<li><strong class="bold">Runtime orchestration</strong>: Developers can design applications however they prefer (with monoliths, services, or containers) and deploy them to the edge with ease. IoT Greengrass provides hooks for smartly integrating with component life cycle events, or developers can ignore them and simply bootstrap applications with a single command. Individual components can be added or updated without interrupting other running services. A dependency tree allows developers to abstract out the installation of libraries and configuration activities to decouple from code artifacts. </li>
				<li><strong class="bold">Logging and monitoring</strong>: By default, IoT Greengrass creates logs for each component and allows developers to indicate which log files should be synchronized to the cloud for operational purposes. Additionally, the cloud service keeps track of device health automatically, making it easier for team members to identify and respond to unhealthy devices. </li>
				<li><strong class="bold">Scaling up the fleet</strong>: Deploying updates to one device is not much different than deploying updates to a fleet of devices. It is easy to define groups, classify similar devices together, and then push updates to groups of devices using a managed deployment service. </li>
				<li><strong class="bold">Native integrations</strong>: AWS provides many components to deploy into IoT Greengrass solutions that augment the baseline functionality and also for integrating with other AWS services. A stream management component enables you to define, write to, and consume streams at the edge. A Docker application manager allows you to download Docker images from public repositories or private <a id="_idIndexMarker108"/>repositories in <strong class="bold">Amazon Elastic Container Registry</strong>. Pretrained and optimized <a id="_idIndexMarker109"/>ML models are available for tasks such as object detection and<a id="_idIndexMarker110"/> image<a id="_idIndexMarker111"/> classification with <strong class="bold">Deep Learning Runtime</strong> and <strong class="bold">TensorFlow Lite</strong>.</li>
			</ul>
			<p>In playing your role as the Home Base Solutions architect with a solution to build, you could propose that the engineering team invest the time and resources to build out all this functionality and test that it is production-ready. However, the IoT Greengrass baseline services and optional add-ons are ready to accelerate the development life cycle and come vetted by AWS, where <em class="italic">security is the top priority</em>. </p>
			<p>IoT Greengrass does not do everything for you. In fact, a fresh installation of IoT Greengrass doesn't do anything but wait for further instruction in the form of a deployment. Think<a id="_idIndexMarker112"/> of it as a blank canvas, paint, and brush. It's everything you need to get started, but you have to develop the solution that it runs. Let's review the operating model for IoT Greengrass, both at the edge and within the cloud.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Reviewing IoT Greengrass architecture </h2>
			<p>IoT Greengrass<a id="_idIndexMarker113"/> is both a managed service running on AWS and an edge runtime tool. The managed service is where your devices are defined individually and in groups. When you want to push a new deployment to the edge, you are, in fact, invoking an API in the managed service that is then responsible for communicating with the edge runtime to coordinate the delivery of that deployment. Here is a sequence diagram showing the process of you, as the developer, configuring a component and requesting that a device running the IoT Greengrass core software receive and run that component:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="Images/B17595_02_004.jpg" alt="Figure 2.4 – Pushing a deployment through IoT Greengrass&#13;&#10;" width="742" height="310"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – Pushing a deployment through IoT Greengrass</p>
			<p>The <strong class="bold">component</strong> is the fundamental unit of functionality that is deployed to a device running IoT <a id="_idIndexMarker114"/>Greengrass. Components are defined by a manifest file, called<a id="_idIndexMarker115"/> a <strong class="bold">recipe</strong>, which tells IoT Greengrass what the name, version, dependencies, and instructions are for that component. In addition to this, a component can define zero or more <strong class="bold">artifacts</strong> that are fetched during deployment. These artifacts can be binaries, source code, compiled code, archives, images, or data files; really any kind of file or resource that is stored on disk. Component recipes can define dependencies on other components that get resolved via a graph by the IoT Greengrass software. </p>
			<p>During a deployment activity, one or more components are added or updated in that deployment. The component's artifacts are downloaded to the local device from the cloud; then, the component is started by way of evaluating life cycle instructions. A life cycle instruction could be something that happens during startup; it could be the main command to run, such as starting a Java application or something to do after the component has concluded running. Components might continue in the running state indefinitely or perform a task and exit. The following diagram provides an example of the component graph:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="Images/B17595_02_005.jpg" alt="Figure 2.5 – An example graph of components showing the life cycle and dependencies&#13;&#10;" width="632" height="395"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – An example graph of components showing the life cycle and dependencies</p>
			<p>That's everything we need to cover before taking your first steps toward readying your edge device to run a solution with IoT Greengrass! </p>
			<p>In the following sections, you will validate that your edge device is ready to run the IoT Greengrass <a id="_idIndexMarker116"/>software, install the software, and then author your first component. In addition to this, you will get a closer look at components and deployments through the hands-on activities to come.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>Checking compatibility with IoT Device Tester</h1>
			<p><strong class="bold">IoT Device Tester </strong>(<strong class="bold">IDT</strong>) is a software<a id="_idIndexMarker117"/> client provided by AWS to assess device readiness for use in AWS IoT solutions. It assists developers by running a series of qualification tests to validate whether the destination system is ready to run the IoT Greengrass core software. Additionally, it runs a series of tests to prove that edge capabilities are already present, such as establishing MQTT connections to AWS and running ML models locally. IDT works for one device you are testing locally or scales up to run customized test suites against any number of device groups, so long as they are accessible over the network.</p>
			<p>In the context of your role as the IoT architect at Home Base Solutions, you should use IDT to prove that your target edge device platform (in this case, platform refers to hardware and software) is capable of running the runtime orchestration tool of choice, IoT Greengrass. This pattern of using tools to prove compatibility is a best practice over manually evaluating the target platform and/or assuming that a certain combination of listed requirements is met. For example, a potential device platform might advertise that its hardware requirements and operating system meet your needs, but it could be missing a critical library dependency that doesn't surface until later in the development life cycle. It is best to prove early that everything you need is present and accounted for.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">IDT does more than qualify hardware for running IoT Greengrass core software. The tool can also qualify hardware running FreeRTOS to validate that the device is capable of interoperating with AWS IoT Core. Developers can write their own custom tests and bundle them into suites to incorporate into your <strong class="bold">software development life cycle</strong> (<strong class="bold">SDLC</strong>). </p>
			<p>The following steps will enable you to prepare your Raspberry Pi device for use as the edge system (that is, the Home Base Solutions hub device in our fictional project) and configure<a id="_idIndexMarker118"/> your AWS account before finally running the IDT software. Optionally, you can skip the <em class="italic">Booting the Raspberry Pi</em> and <em class="italic">Configuring the AWS account and permissions</em> sections if you already have a device and AWS account configured for use. If you are using a different platform for your edge device, you just need to ensure you can reach the device over SSH with a system user that has root permissions from your command-and-control device.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Booting the Raspberry Pi</h2>
			<p>The<a id="_idIndexMarker119"/> following <a id="_idIndexMarker120"/>steps were run on a Raspberry Pi 3B with a clean installation of the May 2021 release of the Raspberry Pi OS. Please refer to <a href="https://www.raspberrypi.org/software/">https://www.raspberrypi.org/software/</a> for the <strong class="bold">Raspberry Pi Imager</strong> tool. Use your command-and-control system to run the imaging tool to flash a Micro SD card with a fresh image of the Raspberry Pi OS. For this book's project, we recommended that you use a blank slate to avoid any unforeseen consequences of preexisting software and configuration changes. Here is a screenshot of the Raspberry Pi Imager tool and the image to select:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="Images/B17595_02_006.jpg" alt="Figure 2.6 – The Raspberry Pi Imager tool and the image to select&#13;&#10;" width="837" height="549"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – The Raspberry Pi Imager tool and the image to select</p>
			<p>The following is <a id="_idIndexMarker121"/>a list of steps to perform after<a id="_idIndexMarker122"/> flashing the Micro SD card with the Imager tool:</p>
			<ol>
				<li>Insert the Micro SD card into the Raspberry Pi.</li>
				<li>Turn on the Raspberry Pi by plugging in the power source.</li>
				<li>Complete the first-time boot wizard. Update the default password, set your locale preferences, and connect to Wi-Fi (this is optional if you are using Ethernet).</li>
				<li>Open the Terminal app and run <strong class="source-inline">sudo apt-get update</strong> and <strong class="source-inline">sudo apt-get upgrade</strong>.</li>
				<li>Reboot the Pi.</li>
				<li>Open the Terminal app and run the <strong class="source-inline">hostname</strong> command. Copy the value and make a note of it; for example, write it in a scratch file on your command-and-control system. On Raspberry Pi devices, the default is <strong class="source-inline">raspberrypi</strong>.</li>
				<li>Open the Raspberry Pi preferences app and enable the SSH interface. This must be enabled for the IDT to access the device. Open <strong class="bold">Preferences</strong>, choose <strong class="bold">Raspberry Pi Configuration</strong>, choose <strong class="bold">Interfaces</strong>, and enable SSH.</li>
			</ol>
			<p>At this milestone, your Raspberry Pi device is configured to join the same local network of your command-and-control system and can be accessed via a remote shell session. If you are using a different device or a virtual machine as your edge device for the hands-on project, you should be able to access that device via SSH. A good test to check whether this<a id="_idIndexMarker123"/> is working properly is to try connecting<a id="_idIndexMarker124"/> to your edge device from your command-and-control system using a Terminal application (or <strong class="bold">PuTTY</strong> on Windows), with <strong class="source-inline">ssh pi@raspberrypi</strong>. Replace <strong class="source-inline">raspberrypi</strong> if you have a different hostname from <em class="italic">step 6</em>. Next, you will configure your AWS account in order to run IDT on your edge device.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Configuring the AWS account and permissions</h2>
			<p>Complete all <a id="_idIndexMarker125"/>of the <a id="_idIndexMarker126"/>steps <a id="_idIndexMarker127"/>in this section on your command-and-control system. For readers who don't yet have an AWS account (skip to <em class="italic">step 5</em> if you already have access to an account), perform the following:</p>
			<ol>
				<li value="1">Create your AWS account. Navigate to <a href="https://portal.aws.amazon.com/billing/signup">https://portal.aws.amazon.com/billing/signup</a> in your web browser and complete the prompts. You will require an email address, phone number, and credit card.</li>
				<li>Sign in to the AWS Management Console using your root login and navigate to the <strong class="bold">Identity and Access Management</strong> (<strong class="bold">IAM</strong>) service. You<a id="_idIndexMarker128"/> can find this at <a href="https://console.aws.amazon.com/iam/">https://console.aws.amazon.com/iam/</a>.</li>
				<li>Use the IAM service console to set up your administrative group and user account. It is a best practice to create a new user for yourself instead of continuing to use the root user login. You will use that new user to complete any later AWS steps using the AWS management console or AWS CLI:<ol><li>Create a new user called <strong class="bold">Admin</strong>. Select both the <strong class="bold">Programmatic access</strong> and <strong class="bold">AWS Management Console access</strong> types. Skip the sections for permissions and tags. Choose <strong class="bold">Create user</strong> in the <strong class="bold">Review</strong> section. In the confirmation section, make a note in your scratch file of the dedicated sign-in link for your account. Ensure that you download the CSV file with your AWS credentials, referred<a id="_idIndexMarker129"/> to<a id="_idIndexMarker130"/> as <strong class="bold">Access Key</strong> and <strong class="bold">Secret Key</strong>, which you will<a id="_idIndexMarker131"/> use <a id="_idIndexMarker132"/>to <a id="_idIndexMarker133"/>interact with the AWS CLI. Note that the CSV file also includes the user's password that is later used to log in to the AWS management console (instead of the current root user).</li><li>Create a new user group called <strong class="bold">Administrators</strong>, add the <strong class="bold">Admin</strong> user to it, and attach to it the policy named <strong class="source-inline">AdministratorAccess</strong> (it is easier to use the filter field and type that in). This policy is managed by AWS to grant administrator-level permissions to users. The best practice is to relate permissions to groups and then assign users to groups to inherit permissions. This makes it easier to audit permissions and understand the kinds of access that users have from well-named groups. </li></ol></li>
				<li>Log out of the AWS management console.<p class="callout-heading">Note</p><p class="callout">At this point, you should have access to an AWS account with an administrative user. Complete the following steps to set up the AWS CLI (please skip to <em class="italic">step 7</em> if you already have the AWS CLI configured with your admin user).</p></li>
				<li>Install the AWS CLI. Platform-specific instructions can be found at <a href="https://aws.amazon.com/cli/">https://aws.amazon.com/cli/</a>. In this book, the AWS CLI steps will use AWS CLI v2.</li>
				<li>Once installed, configure the AWS CLI and use the credentials you downloaded for the <strong class="bold">Admin</strong> user. This user will be stored as the <em class="italic">default</em> profile in your local AWS settings:<ol><li>In your Terminal or PowerShell application, run <strong class="source-inline">aws configure</strong>.</li><li>When prompted for <strong class="bold">AWS Access Key ID</strong> and <strong class="bold">AWS Secret Access Key</strong>, use the values from the downloaded credentials file in <em class="italic">step 3A</em>. Do not use the password value here.</li><li>When <a id="_idIndexMarker134"/>prompted <a id="_idIndexMarker135"/>for <a id="_idIndexMarker136"/>a default region, you can specify the AWS region you want to use by default for any commands. Note that some of the AWS CLI steps mentioned in this book require you to provide an explicit region in the command. at other times, the region is implicitly selected from this configuration step. In this book, the steps will use region <strong class="bold">us-west-2</strong> by default and remind readers to substitute when applicable.</li><li>When prompted for a default output format, you can choose any of [<strong class="source-inline">json</strong>, <strong class="source-inline">yaml</strong>, <strong class="source-inline">text</strong>, <strong class="source-inline">table</strong>]. The author's preference is <strong class="source-inline">json</strong> and will be reflected in any examples of AWS CLI output that appear in the book.</li></ol><p>Next, you will use your <strong class="source-inline">Admin</strong> user to create a few more resources in preparation for the following sections to use the IDT and install the IoT Greengrass core software. These are permissions resources, similar to your <strong class="source-inline">Admin</strong> user, which will be used by IDT and IoT Greengrass software to interact with AWS on your behalf.</p></li>
				<li>Log in to the AWS management console using your custom sign-in link from <em class="italic">step 3A</em>. Use the <strong class="source-inline">Admin</strong> username and password provided in the CSV file containing credentials.</li>
				<li>Return to the IAM service console, which can be found at <a href="https://console.aws.amazon.com/iam/">https://console.aws.amazon.com/iam/</a>.</li>
				<li>Create a new user named <strong class="source-inline">idtgg</strong> (short for <em class="italic">IDT and Greengrass</em>) and select the <strong class="bold">Programmatic access</strong> type. This user will not require a password for management console access. Skip the permissions and tags sections. Make sure that you download the CSV file containing the credentials for this user as well.</li>
				<li>Create a new policy. The first step is to define the permissions for the policy. Choose the <strong class="bold">JSON</strong> tab and paste the contents from this accompanying file into the book resources repository: <strong class="source-inline">chapter2/policies/idtgg-policy.json</strong>. Skip the tags section. In the review section, enter the name of <strong class="source-inline">idt-gg-permissions</strong>, enter the description of <strong class="bold">permissions for IoT Device Tester and IoT Greengrass</strong>, and choose <strong class="bold">Create policy</strong>.</li>
				<li>Create a<a id="_idIndexMarker137"/> new<a id="_idIndexMarker138"/> user<a id="_idIndexMarker139"/> group with the name of <strong class="bold">Provision-IDT-Greengrass</strong>, select the <strong class="source-inline">idt-gg-permissions</strong> policy, and select the <strong class="source-inline">idtgg</strong> user. Choose <strong class="bold">Create group</strong>. You have now set up a new group, attached permissions, and assigned the programmatic access user that will serve as authentication and authorization for the IDT client and IoT Greengrass provisioning tool.</li>
				<li>In your Terminal or PowerShell application, configure a new AWS CLI profile for this new user:<ol><li>Run <strong class="source-inline">aws configure --profile idtgg</strong>.</li><li>When prompted for access keys and secret keys, use the new values from the credentials CSV file downloaded in <em class="italic">step 9</em>. </li><li>When prompted for the default region, use the book's default of <strong class="bold">us-west-2</strong> or the AWS region you are using for all of the projects in this book.</li></ol></li>
			</ol>
			<p>That concludes all of the preparatory steps to configure your AWS account, permissions, and CLI. The next<a id="_idIndexMarker140"/> milestone is to install the IDT client and prepare it to test the Home Base<a id="_idIndexMarker141"/> Solutions<a id="_idIndexMarker142"/> prototype hub device.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Configuring IDT</h2>
			<p>You will<a id="_idIndexMarker143"/> run the IDT software from your command-and-control system, and the IDT will access the edge device system remotely through SSH to run the tests.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The following steps reflect the configuration and use of IDT at the time of writing. If you get stuck, it might be that the latest version differs from the version that we used at the time of writing. You can check the AWS documentation for IDT for the latest guidance on installation, configuration, and use. Please refer to <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/device-tester-for-greengrass-ug.html">https://docs.aws.amazon.com/greengrass/v2/developerguide/device-tester-for-greengrass-ug.html</a>.</p>
			<p>Follow these steps to use IDT to verify the edge device system is ready to run IoT Greengrass. All of the following steps are completed on macOS using IoT Greengrass core software v2.4.0 and IDT v4.2.0 with test suite GGV2Q_2.0.1. For Windows, Linux, or later AWS software versions, please alter the commands and directories as needed:</p>
			<ol>
				<li value="1">On your command-and-control system, open a web browser and navigate to <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/dev-test-versions.html">https://docs.aws.amazon.com/greengrass/v2/developerguide/dev-test-versions.html</a>.</li>
				<li>Underneath <strong class="bold">Latest IDT version for AWS IoT Greengrass</strong> and <strong class="bold">IDT software downloads</strong>, click on the link for the platform that matches your system. This will open a file download prompt. Save the archive to your local file system; for example, <strong class="source-inline">C:\projects\idt</strong> on Windows or <strong class="source-inline">~/projects/idt</strong> on macOS and Linux:<div id="_idContainer024" class="IMG---Figure"><img src="Images/B17595_02_007.jpg" alt="Figure 2.7 – The AWS documentation website for downloading IDT; exact text and versions might differ&#13;&#10;" width="697" height="384"/></div><p class="figure-caption">Figure 2.7 – The AWS documentation website for downloading IDT; exact text and versions might differ</p></li>
				<li>Unzip the <a id="_idIndexMarker144"/>archive contents in place in the directory. In a file explorer, double-click on the archive to extract them. If using Terminal, use a command such as <strong class="source-inline">unzip devicetester_greengrass_v2_4.0.2_testsuite_1.1.0_mac.zip</strong>. This is what the directory looks like on macOS:<div id="_idContainer025" class="IMG---Figure"><img src="Images/B17595_02_008.jpg" alt="Figure 2.8 – macOS Finder showing the directory contents after unzipping the IDT archive&#13;&#10;" width="528" height="493"/></div><p class="figure-caption">Figure 2.8 – macOS Finder showing the directory contents after unzipping the IDT archive</p></li>
				<li>Open a <a id="_idIndexMarker145"/>new tab in your browser and paste the following link to prompt a download of the latest IoT Greengrass core software: <a href="https://d2s8p88vqu9w66.cloudfront.net/releases/greengrass-2.4.0.zip">https://d2s8p88vqu9w66.cloudfront.net/releases/greengrass-2.4.0.zip</a> (if this link doesn't work, you can find the latest guidance at <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/quick-installation.html#download-greengrass-core-v2">https://docs.aws.amazon.com/greengrass/v2/developerguide/quick-installation.html#download-greengrass-core-v2</a>).</li>
				<li>Rename the downloaded file as <strong class="source-inline">aws.greengrass.nucleus.zip</strong> and move it to an IDT directory such as <strong class="source-inline">~/projects/idt/devicetester_greengrass_v2_mac/products/aws.greengrass.nucleus.zip</strong>:<div id="_idContainer026" class="IMG---Figure"><img src="Images/B17595_02_009.jpg" alt="Figure 2.9 – The IoT Greengrass software in place to be used by IDT&#13;&#10;" width="431" height="427"/></div><p class="figure-caption">Figure 2.9 – The IoT Greengrass software in place to be used by IDT</p></li>
				<li>Open a<a id="_idIndexMarker146"/> text file such as <strong class="source-inline">~/projects/idt/devicetester_greengrass_v2_mac/configs/config.json</strong> and update the following values:<ol><li>(Optionally) update <strong class="source-inline">awsRegion</strong> if you are not using the book's default of <strong class="source-inline">us-west-2</strong>.</li><li>To use the <strong class="source-inline">idtgg</strong> profile that you configured earlier, set the value of <strong class="source-inline">auth</strong> as follows:</li></ol><p class="source-code"><strong class="bold"> "auth": {</strong></p><p class="source-code"><strong class="bold">   "method": "file",</strong></p><p class="source-code"><strong class="bold">   "credentials": {</strong></p><p class="source-code"><strong class="bold">     "profile": "idtgg"</strong></p><p class="source-code"><strong class="bold">   }</strong></p><p class="source-code"><strong class="bold"> }</strong></p></li>
				<li>Open a text file such as <strong class="source-inline">~/projects/idt/devicetester_greengrass_v2_mac/configs/device.json</strong> and update the following values:<ol><li><strong class="source-inline">"id": "pool1"</strong>.</li><li><strong class="source-inline">"sku": "hbshub"</strong> (<strong class="source-inline">hbshub</strong> stands for Home Base Solutions hub).</li><li>Underneath <strong class="source-inline">"features"</strong>, for the name-value pair named <strong class="source-inline">"arch"</strong>, set <strong class="source-inline">"value": "armv7l"</strong> (this is for Raspberry Pi devices; alternatively, you can <a id="_idIndexMarker147"/>choose the appropriate architecture for your device).</li><li>Underneath <strong class="source-inline">"features"</strong>, for the remaining name-value pairs such as <strong class="source-inline">"ml"</strong>, <strong class="source-inline">"docker"</strong>, and <strong class="source-inline">"streamManagement"</strong>, set <strong class="source-inline">"value": "no"</strong>. For now, we will disable these tests because we have no immediate plans to use the tested features. Feel free to enable them if you'd like to evaluate your device's compatibility, although expect the tests to fail on a freshly imaged Raspberry Pi. </li><li>Underneath <strong class="source-inline">"devices"</strong>, set <strong class="source-inline">"id": "raspberrypi"</strong> (or any device ID you prefer).</li><li>Underneath <strong class="source-inline">"connectivity"</strong>, set the value of <strong class="source-inline">"ip"</strong> to the IP address of your edge device (for Raspberry Pi users, the value is the output of <em class="italic">step 6</em> from the <em class="italic">Booting the Raspberry Pi</em> section).</li><li>Underneath <strong class="source-inline">"auth"</strong>, set <strong class="source-inline">"method": "password"</strong>.</li><li>Underneath <strong class="source-inline">"credentials"</strong>, set the value of <strong class="source-inline">"user"</strong> to the username used to SSH to the edge device (typically, this will be <strong class="source-inline">"pi"</strong> for Raspberry Pi users).</li><li>Underneath <strong class="source-inline">"credentials"</strong>, set the value of <strong class="source-inline">"password"</strong> to the password used to SSH to the edge device.</li><li>Underneath <strong class="source-inline">"credentials"</strong>, delete the line for <strong class="source-inline">"privKeyPath"</strong>.</li><li>Save the changes to this file. You can view a sample version of this file in the book's<a id="_idIndexMarker148"/> GitHub repository at <strong class="source-inline">chapter2/policies/idt-device-sample.json</strong>.</li></ol></li>
				<li>Open a text file such as <strong class="source-inline">~/projects/idt/devicetester_greengrass_v2_mac/configs/userdata.json</strong> and update the following values. Ensure that you specify absolute paths instead of relative paths:<ol><li><strong class="source-inline">"TempResourcesDirOnDevice": "/tmp/idt"</strong>.</li><li><strong class="source-inline">"InstallationDirRootOnDevice": "/greengrass"</strong>.</li><li><strong class="source-inline">"GreengrassNucleusZip": "Users/ryan/projects/idt/devicetester_greengrass_v2_mac/products/aws.greengrass.nucleus.zip"</strong> (update this based on where you stored the <strong class="source-inline">aws.greengrass.nucleus.zip</strong> file in <em class="italic">step 5</em> of this section).</li><li>Save the changes to this file. You can view a sample version of this file in the book's GitHub repository at <strong class="source-inline">chapter2/policies/idt-userdata-sample.json</strong>.</li></ol></li>
				<li>Open an application such as Terminal on macOS/Linux or PowerShell on Windows.</li>
				<li>Change your present working directory to where the IDT launcher is located:<ol><li><strong class="source-inline">~/projects/idt/devicetester_greengrass_v2_mac/bin</strong> on macOS</li><li><strong class="source-inline">~/projects/idt/devicetester_greengrass_v2_linux/bin</strong> on Linux</li><li><strong class="source-inline">C:\projects\idt\devicetester_greengrass_v2_win\bin</strong> on Windows</li></ol></li>
				<li>Run the command to start IDT:<ol><li><strong class="source-inline">./devicetester_mac_x86-64 run-suite --userdata userdata.json</strong> on macOS</li><li><strong class="source-inline">./devicetester_linux_x86-64 run-suite --userdata userdata.json</strong> on Linux</li><li><strong class="source-inline">devicetester_win_x86-64.exe run-suite --userdata userdata.json</strong> on Windows</li></ol><p>Running IDT <a id="_idIndexMarker149"/>will start a local application that connects to your edge device over SSH and completes the series of tests. It will stop upon encountering the first failed test case or run until all test cases have passed. If you are running IDT against a fresh installation of your Raspberry Pi, as defined by previous steps, you should observe an output similar to the following: </p><p class="source-code"><strong class="bold">========== Test Summary ==========</strong></p><p class="source-code"><strong class="bold">Execution Time:   3s</strong></p><p class="source-code"><strong class="bold">Tests Completed:   2</strong></p><p class="source-code"><strong class="bold">Tests Passed:     1</strong></p><p class="source-code"><strong class="bold">Tests Failed:     1</strong></p><p class="source-code"><strong class="bold">Tests Skipped:     0</strong></p><p class="source-code"><strong class="bold">----------------------------------</strong></p><p class="source-code"><strong class="bold">Test Groups:</strong></p><p class="source-code"><strong class="bold">    pretestvalidation:     PASSED</strong></p><p class="source-code"><strong class="bold">    coredependencies:     FAILED</strong></p><p class="source-code"><strong class="bold">----------------------------------</strong></p><p class="source-code"><strong class="bold">Failed Tests:</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">Group Name: coredependencies</strong></p><p class="source-code"><strong class="bold">        Test Name: javaversion</strong></p><p class="source-code"><strong class="bold">            Reason: Encountered error while fetching java version on the device: Failed to run Java version command with error: Command '{java -version 2&gt;&amp;1 map[] 30s}' exited with code 127. Error output: .</strong></p><p>The step to install Java on the Raspberry Pi was intentionally left out in order to demonstrate how IDT identifies missing dependencies; apologies for the deception! If you ran the IDT test suite and passed all of the test cases, then you are ahead of schedule and can skip to the <em class="italic">Installing IoT Greengrass</em> section.</p></li>
				<li>To fix this<a id="_idIndexMarker150"/> missing dependency, return to your Raspberry Pi interface and open the Terminal app.</li>
				<li>Install Java on the Pi using <strong class="source-inline">sudo apt-get install default-jdk</strong>.</li>
				<li>Return to your command-and-control system and run IDT again (repeat the command in <em class="italic">step 11</em>).</li>
			</ol>
			<p>Your test suite should now pass the Java requirement test. If you encounter other failures, you will need to use the test report and logs in the <strong class="source-inline">idt/devicetester_greengrass_v2_mac/results</strong> folder to triage and fix them. Some common missteps include missing AWS credentials, AWS credentials without sufficient permissions, and incorrect paths to resources defined in <strong class="source-inline">userdata.json</strong>. A fully passed suite of test cases looks like this:</p>
			<p class="source-code">========== Test Summary ==========</p>
			<p class="source-code">Execution Time:   22m59s</p>
			<p class="source-code">Tests Completed:   7</p>
			<p class="source-code">Tests Passed:     7</p>
			<p class="source-code">Tests Failed:     0</p>
			<p class="source-code">Tests Skipped:     0</p>
			<p class="source-code">----------------------------------</p>
			<p class="source-code">Test Groups:</p>
			<p class="source-code">    pretestvalidation:   PASSED</p>
			<p class="source-code">    coredependencies:   PASSED</p>
			<p class="source-code">    version:       PASSED</p>
			<p class="source-code">    component:       PASSED</p>
			<p class="source-code">    lambdadeployment:   PASSED</p>
			<p class="source-code">    mqtt:         PASSED</p>
			<p class="source-code">----------------------------------</p>
			<p>This concludes the introductory use of IDT to analyze and assist in preparing your devices to use IoT Greengrass. Here, the best practice is to use software tests, not just for your own code but to assess whether the edge device itself is ready to work with your solution. Lean on tools such as IDT that do the heavy lifting of proving that the device is ready to use and validate this for each new type of device enrolled or major solution version<a id="_idIndexMarker151"/> released. You should be able to configure IDT for your next project and qualify a new device or group of devices to run IoT Greengrass. In the next section, you will learn how to install IoT Greengrass on your device in order to configure your first edge component.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Installing IoT Greengrass</h1>
			<p>Now that <a id="_idIndexMarker152"/>you have used IDT to validate that your edge device is compatible with IoT Greengrass, the next milestone in this chapter is to install IoT Greengrass.</p>
			<p>From your edge device (that is, the prototype Home Base Solutions hub), open the Terminal app, or use your command-and-control device to remotely access it using SSH:</p>
			<ol>
				<li value="1">Change the directory to your user's home directory: <strong class="source-inline">cd ~/</strong>.</li>
				<li>Download the IoT Greengrass core software: <strong class="source-inline">curl -s </strong><a href="https://d2s8p88vqu9w66.cloudfront.net/releases/greengrass-nucleus-latest.zip">https://d2s8p88vqu9w66.cloudfront.net/releases/greengrass-nucleus-latest.zip</a> &gt; greengrass-nucleus-latest.zip.</li>
				<li>Unzip the archive: <strong class="source-inline">unzip greengrass-nucleus-latest.zip -d greengrass &amp;&amp; rm greengrass-nucleus-latest.zip</strong>.</li>
				<li>Your edge device requires AWS credentials in order to provision cloud resources on your behalf. You can use the same credentials that you created for the <strong class="source-inline">idtgg</strong> user in the previous <em class="italic">Configuring the AWS account and permissions</em> section:<ol><li><strong class="source-inline">export AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE</strong></li><li><strong class="source-inline">export AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY</strong></li></ol></li>
				<li>Install the IoT<a id="_idIndexMarker153"/> Greengrass core software using the following command. If you are using an AWS region other than <strong class="source-inline">us-west-2</strong>, update the value of the <strong class="source-inline">--aws-region</strong> argument. You can copy and paste this command from <strong class="source-inline">chapter2/commands/provision-greengrass.sh</strong>:<p class="source-code"><strong class="bold">sudo -E java -Droot="/greengrass/v2" -Dlog.store=FILE \</strong></p><p class="source-code"><strong class="bold">  -jar ./greengrass/lib/Greengrass.jar \</strong></p><p class="source-code"><strong class="bold">  --aws-region us-west-2 \</strong></p><p class="source-code"><strong class="bold">  --thing-name hbshub001 \</strong></p><p class="source-code"><strong class="bold">  --thing-group-name hbshubprototypes \</strong></p><p class="source-code"><strong class="bold">  --tes-role-name GreengrassV2TokenExchangeRole \</strong></p><p class="source-code"><strong class="bold">  --tes-role-alias-name GreengrassCoreTokenExchangeRoleAlias \</strong></p><p class="source-code"><strong class="bold">  --component-default-user ggc_user:ggc_group \</strong></p><p class="source-code"><strong class="bold">  --provision true \</strong></p><p class="source-code"><strong class="bold">  --setup-system-service true \</strong></p><p class="source-code"><strong class="bold">  --deploy-dev-tools true</strong></p></li>
				<li>That's it! The last few lines of output from this provisioning command should look like this:<p class="source-code"><strong class="bold">Created device configuration</strong></p><p class="source-code"><strong class="bold">Successfully configured Nucleus with provisioned resource details!</strong></p><p class="source-code"><strong class="bold">Creating a deployment for Greengrass first party components to the thing group</strong></p><p class="source-code"><strong class="bold">Configured Nucleus to deploy aws.greengrass.Cli component</strong></p><p class="source-code"><strong class="bold">Successfully set up Nucleus as a system service</strong></p></li>
			</ol>
			<p>The installation of the IoT Greengrass core software and the provisioning of the initial resources is <a id="_idIndexMarker154"/>much smoother after validating compatibility with the IDT suite. Now your edge device has the first fundamental tool installed: the runtime orchestrator. Let's review the resources that have been created at the edge and in AWS from this provisioning step.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Reviewing what has been created so far</h2>
			<p>On your edge<a id="_idIndexMarker155"/> device, the IoT Greengrass software was installed in the <strong class="source-inline">/greengrass/v2</strong> file path. In that directory, the public and private keypairs are generated for connecting to AWS, service logs, a local repository of packages for recipes and artifacts, and a directory for past and present deployments pushed to this device. Feel free to explore the directory at <strong class="source-inline">/greengrass/v2</strong> to get familiar with what is stored on the device; though, you will need to escalate permissions using <strong class="source-inline">sudo</strong> to browse everything.</p>
			<p>The installation added the first <strong class="bold">component</strong> to your IoT Greengrass environment, named <strong class="source-inline">aws.greengrass.Nucleus</strong>. The nucleus component is the foundation of IoT Greengrass; it is the only mandatory component, and it facilitates key functionality such as deployments, orchestration, and life cycle management for all other components. Without the nucleus component, there is no IoT Greengrass.</p>
			<p>Additionally, the installation created the first <strong class="bold">deployment</strong> made to your device through the use of the <strong class="source-inline">--deploy-dev-tools true</strong> argument. That deployment installed a component named <strong class="source-inline">aws.greengrass.Cli</strong>. This second component includes a script, called <strong class="source-inline">greengrass-cli</strong>, that is used for local development tasks such as reviewing deployments, components, and logs. It can also be used to create new components and deployments. Remember, with IoT Greengrass, you can work locally on the device or push deployments remotely to it through AWS. Remote deployments are introduced in <a href="B17595_04_Final_SS_ePub.xhtml#_idTextAnchor073"><em class="italic">Chapter 4</em></a>, <em class="italic">Extending the Cloud to the Edge</em>.</p>
			<p>In AWS, a few <a id="_idIndexMarker156"/>different resources were created. First, a new <strong class="bold">thing</strong> was added to the <strong class="bold">thing registry</strong> in IoT Core. A thing is a logical representation of a physical device to which credentials, metadata, and other configuration are attached. The name of the created thing is <strong class="source-inline">hbshub001</strong> from the IoT Greengrass provisioning argument, <strong class="source-inline">--thing-name</strong>. Similarly, a new <strong class="bold">thing group</strong> was also created in the registry, named <strong class="source-inline">hbshubprototypes</strong>, from the <strong class="source-inline">--thing-group-name</strong> provisioning argument. A thing group contains zero or more things and thing groups. The design of IoT Greengrass uses thing groups to identify sets of edge devices that should have the same deployments running on them. For example, if you provisioned another hub prototype device, you would add it to the same <strong class="source-inline">hbshubprototypes</strong> thing group such that the new prototype deployments would travel to all of your prototype devices.</p>
			<p>Additionally, your <strong class="source-inline">hbshub001</strong> thing has an entity attached to it <a id="_idIndexMarker157"/>called a <strong class="bold">certificate</strong>. The certificate is the record stored in IoT Core that was generated with the <strong class="bold">x.509 public and private keypair</strong> by the installation of IoT Greengrass. The keypair is stored on your device in the <strong class="source-inline">/greengrass/v2</strong> directory and is used to establish mutually authenticated connections to AWS. The certificate is how AWS recognizes the device when it connects with its private key (the certificate is attached to the <strong class="source-inline">hbshub001</strong> thing record) and knows how to look up permissions for the device. Those permissions are defined in another resource<a id="_idIndexMarker158"/> called the <strong class="bold">IoT policy</strong>.</p>
			<p>An IoT policy is similar to an AWS IAM policy in that it defines explicit permissions for what an actor is allowed to do when interacting with AWS. In the case of an IoT policy, the actor is the device and permissions are for actions such as opening a connection, publishing and receiving messages, and accessing static resources defined in deployments. Devices get their permissions through their certificate, meaning a thing is attached to the certificate, and the certificate is attached to one or more policies. Here's a sketch of how these basic resources are related in the edge and the cloud:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="Images/B17595_02_010.jpg" alt="Figure 2.10 – Illustrating the relationships between the IoT Core thing registry and edge resources&#13;&#10;" width="468" height="316"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – Illustrating the relationships between the IoT Core thing registry and edge resources</p>
			<p>In the cloud <a id="_idIndexMarker159"/>service of IoT Greengrass, a few more resources were defined for the initial provisioning of your device and its first deployment. An IoT Greengrass <strong class="bold">core</strong> is a mapping of a device (which is also known as a thing), the components and deployments running on the device, and the associated thing group the device is in. Additionally, a core stores metadata such as the version of IoT Greengrass core software installed and the status of the last known health check. Here is an alternate view of the relationship graph with IoT Greengrass resources included:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="Images/B17595_02_011.jpg" alt="Figure 2.11 – Illustrating the relationships between IoT Core, IoT Greengrass, and the edge device&#13;&#10;" width="529" height="275"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.11 – Illustrating the relationships between IoT Core, IoT Greengrass, and the edge device</p>
			<p>Now that you have installed IoT Greengrass and have an understanding of the resources created on<a id="_idIndexMarker160"/> provisioning, let's review what a component looks like when deployed to inform your implementation of the <em class="italic">Hello, world</em> component. </p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Creating your first edge component</h1>
			<p>The most basic <a id="_idIndexMarker161"/>milestone of any developer education is the <em class="italic">Hello, world</em> example. For your first edge component deployed to IoT Greengrass, you will create a simple <em class="italic">Hello, world</em> application in order to reinforce concepts such as component definition, a dependency graph, and how to create a new deployment. </p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Reviewing an existing component</h2>
			<p>Before you <a id="_idIndexMarker162"/>get started with drafting a new component, take a moment to familiarize yourself with the existing components that have already been deployed by using the IoT Greengrass CLI. This CLI was installed by the <strong class="source-inline">--deploy-dev-tools true</strong> argument that was passed in during the installation. This tool is designed to help you with a local development loop; however, as a best practice, it is not installed in production solutions. It is installed at <strong class="source-inline">/greengrass/v2/bin/greengrass-cli</strong>. The following steps demonstrate how to use this tool:</p>
			<ol>
				<li value="1">Try invoking the <strong class="source-inline">help</strong> command. In the Terminal app of your edge device, run <strong class="source-inline">/greengrass/v2/bin/greengrass-cli help</strong>.</li>
				<li>You should view the output of the <strong class="source-inline">help</strong> command, including references to the <strong class="source-inline">component</strong>, <strong class="source-inline">deployment</strong>, and <strong class="source-inline">logs</strong> commands. Try invoking the <strong class="source-inline">help</strong> command on the <strong class="source-inline">component</strong> command: <strong class="source-inline">/greengrass/v2/bin/greengrass-cli help component</strong>.</li>
				<li>You should view instructions regarding how to use the <strong class="source-inline">component</strong> command. Next, try invoking the <strong class="source-inline">component list</strong> command to show all of the locally installed <a id="_idIndexMarker163"/>components, <strong class="source-inline">/greengrass/v2/bin/greengrass-cli component list</strong>:<p class="source-code"><strong class="bold">pi@raspberrypi:~ $ /greengrass/v2/bin/greengrass-cli component list</strong></p><p class="source-code"><strong class="bold">java.lang.RuntimeException: Unable to create ipc client</strong></p><p class="source-code"><strong class="bold">  at com.aws.greengrass.cli.adapter.impl.NucleusAdapterIpcClientImpl.getIpcClient(NucleusAdapterIpcClientImpl.java:260)</strong></p><p class="source-code"><strong class="bold">…</strong></p><p class="source-code"><strong class="bold">  at com.aws.greengrass.cli.CLI.main(CLI.java:57)</strong></p><p class="source-code"><strong class="bold">Caused by: java.io.IOException: Not able to find auth information in directory: /greengrass/v2/cli_ipc_info. Please run CLI as authorized user or group.</strong></p><p>Uh oh, what happened in this step? This command failed with a Java stack trace and errors such as <strong class="source-inline">java.lang.RuntimeException: Unable to create ipc client</strong> and <strong class="source-inline">Please run CLI as authorized user or group</strong>. This is an example of IoT Greengrass security principles at work. By default, the IoT Greengrass software is installed as the root system user. Only the root user, or a system user added to <strong class="source-inline">/etc/sudoers</strong>, can interact with the IoT Greengrass core software, even through the IoT Greengrass CLI. Components are run as the default system user identified in the configuration (please refer to the <strong class="source-inline">--component-default-user</strong> argument in the installation command), or each component can define an override system user to run as. Run the command again using <strong class="source-inline">sudo</strong> (<em class="italic">superuser do</em>):</p></li>
				<li><strong class="source-inline">sudo /greengrass/v2/bin/greengrass-cli component list</strong><p class="callout-heading">Note</p><p class="callout">There is a shortcut you can add to avoid typing the full path of <strong class="source-inline">/greengrass/v2/bin/greengrass-cli</strong> every time you want to use the CLI. You can add the <strong class="source-inline">/greengrass/v2/bin</strong> directory to your <strong class="source-inline">sudoers secure_path</strong> so that the <strong class="source-inline">greengrass-cli</strong> script can be used by typing in the name of the script. Use <strong class="source-inline">visudo</strong> to append the path to the <strong class="source-inline">Defaults secure_path</strong> list. This results in the use of a CLI such as <strong class="source-inline">sudo greengrass-cli component list</strong> as your system user in the sudo group.</p><p>Now you <a id="_idIndexMarker164"/>can view the list of components, including the <strong class="source-inline">aws.greengrass.Cli</strong> component that installed the very CLI you are using! The CLI script can be run by any system user; however, it will only successfully interact with the local IoT Greengrass installation when run as root (via <strong class="source-inline">sudo</strong>) or a system user belonging to a system group defined in the component's configuration <strong class="source-inline">AuthorizedPosixGroups</strong> (which defaults to <strong class="source-inline">null</strong>). Note that even the nucleus component appears in the list:</p><p class="source-code"><strong class="bold">Component Name: aws.greengrass.Cli</strong></p><p class="source-code"><strong class="bold">    Version: 2.4.0</strong></p><p class="source-code"><strong class="bold">    State: RUNNING</strong></p><p class="source-code"><strong class="bold">    Configuration: {"AuthorizedPosixGroups":null}</strong></p><p>The preceding output shows you the status of the component as a brief summary. You can view the current state the component is in; in this case, this is <strong class="source-inline">RUNNING</strong>, indicating the component's life cycle is either <strong class="source-inline">on</strong> or <strong class="source-inline">available</strong>. That makes sense because the CLI should always be available to us while the component is being deployed. Components that run once, perform a task, and close would show a state of <strong class="source-inline">FINISHED</strong> after they have completed their life cycle tasks.</p><p>That's just the component's status, so next, let's take a look at the component's recipe and artifacts. As defined earlier, a component is made up of two resources: a recipe file and a set of artifacts. So what does the recipe file for the CLI component look like? You can find this in the <strong class="source-inline">/greengrass/v2/packages/recipes</strong> directory.</p></li>
				<li>You don't need to run the following <em class="italic">A</em> and <em class="italic">B</em> commands. They are included here to show you <a id="_idIndexMarker165"/>how to find the file contents later on:<strong class="source-inline"> </strong><ol><li>To find the recipe file, use <strong class="source-inline">sudo ls /greengrass/v2/packages/recipes/</strong>.</li><li>To inspect the file, use <strong class="source-inline">sudo</strong> <strong class="source-inline">less /greengrass/v2/recipes/rQVjcR-rX_XGFHg0WYKAnptIez3HKwtctL_2BKKZegM@2.4.0.recipe.yaml</strong> (note that your filename will be different):</li></ol><p class="source-code">Selection of recipe.yaml for aws.greengrass.C--</p><p class="source-code">RecipeFormatVersion: "2020-01-25"</p><p class="source-code">ComponentName: "aws.greengrass.Cli"</p><p class="source-code">ComponentVersion: "2.4.0"</p><p class="source-code">ComponentType: "aws.greengrass.plugin"</p><p class="source-code">ComponentDescription: "The Greengrass CLI component provides a local command-line interface that you can use on Greengrass core devices to develop and debug components locally. The Greengrass CLI lets you create local deployments and restart components on the Greengrass core device, for example."</p><p class="source-code">ComponentPublisher: "AWS"</p><p class="source-code">ComponentDependencies:</p><p class="source-code">  aws.greengrass.Nucleus:</p><p class="source-code">    VersionRequirement: "&gt;=2.4.0 &lt;2.5.0"</p><p class="source-code">    DependencyType: "SOFT"</p><p class="source-code">Manifests:</p><p class="source-code">- Platform:</p><p class="source-code">    os: "linux"</p><p class="source-code">  Lifecycle: {}</p><p class="source-code">  Artifacts:</p><p class="source-code">  - Uri: "greengrass:UbhqXXSJj65QLVH5UqL6nBRterSKIhQu5FKeVAStZGc=/aws.greengrass.cli.client.zip"</p><p class="source-code">    Digest: "uziZS73Z6dKgQgB0tna9WCJ1KhtyhsAb/DSv2Eaev8I="</p><p class="source-code">    Algorithm: "SHA-256"</p><p class="source-code">    Unarchive: "ZIP"</p><p class="source-code">    Permission:</p><p class="source-code">      Read: "ALL"</p><p class="source-code">      Execute: "ALL"</p><p class="source-code">  - Uri: "greengrass:2U_cb2X7-GFaXPMsXRutuT_zB6CdImClH0DSNVvzy1Y=/aws.greengrass.Cli.jar"</p><p class="source-code">    Digest: "UpynbTgG+wYShtkcAr3X+l8/9QerGwaMw5U4IiicrMc="</p><p class="source-code">    Algorithm: "SHA-256"</p><p class="source-code">    Unarchive: "NONE"</p><p class="source-code">    Permission:</p><p class="source-code">      Read: "OWNER"</p><p class="source-code">      Execute: "NONE"</p><p class="source-code">Lifecycle: {}</p></li>
			</ol>
			<p>There are a few important observations to review in this file:</p>
			<ul>
				<li>Component names use a reverse domain scheme that is similar to the <strong class="source-inline">namespacing</strong> Java package. Your custom components in this book's project will start with <strong class="source-inline">com.hbs.hub</strong>, signifying components written for the Home Base Solutions hub product.</li>
				<li>This component is tied to specific versions of the IoT Greengrass nucleus, which is why the<a id="_idIndexMarker166"/> version is 2.4.0. Your components can specify any version here, and the best practice is to follow the semantic versioning specification.</li>
				<li>The <strong class="source-inline">ComponentType</strong> property is only used by AWS plugins such as this CLI. Your custom components will not define this property.</li>
				<li>This component only works with a specific version of the nucleus, so it defines a soft dependency on the <strong class="source-inline">aws.greengrass.nucleus</strong> component. Your custom components do not need to specify a nucleus dependency by default. This is where you will define dependencies on other components, for example, a component that ensures Python3 is installed before loading a component with a Python application.</li>
				<li>This component defines no specific life cycle activities, either at the global level or specific to the <strong class="source-inline">linux</strong> platform version of the manifest. </li>
				<li>The artifacts defined are for specific IoT Greengrass service files. You can view these files on disk in the <strong class="source-inline">/greengrass/v2/packages/artifacts</strong> directory. Your artifact URIs will use the <strong class="source-inline">s3://path/to/my/file</strong> pattern when deploying them from the cloud. During local development, your manifest does not need to define artifacts, as they are expected to already be on disk.</li>
				<li>Note the permissions on the two artifacts. The ZIP file can be read by any system user. In comparison, the JAR file can only be read by the <strong class="source-inline">OWNER</strong>, which in this scenario, means the default system user that was defined at installation, for example, the <strong class="source-inline">ggc_user</strong> user.</li>
			</ul>
			<p>With this review of the component structure, it's time to write your own component with an <a id="_idIndexMarker167"/>artifact and a recipe.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Writing your first component</h2>
			<p>As mentioned <a id="_idIndexMarker168"/>earlier, the first component that we wish to create is a simple "Hello, world" application. In this component, you will create a shell script that prints <strong class="source-inline">Hello, world</strong> with the <strong class="source-inline">echo</strong> command. That shell script is an artifact for your component. Additionally, you will write a recipe file that tells IoT Greengrass how to use that shell script as a component. Finally, you will use the local IoT Greengrass CLI to deploy this component and check it works.</p>
			<p>Local component development uses artifacts and recipe files available on the local disk, so you will need to create some folders for your working files. There is no folder in <strong class="source-inline">/greengrass/v2</strong> that is designed to store your working files. Therefore, you will create a simple folder tree and add your component files there:</p>
			<ol>
				<li value="1">From the Terminal app of your edge device, change the directory to your user's home directory: <strong class="source-inline">cd ~/</strong>.</li>
				<li>Create a new folder to hold your local component resources: <strong class="source-inline">mkdir -p hbshub/{artifacts,recipes}</strong>.</li>
				<li>Next, create the path for a new artifact and add a shell script to its folder. Let's choose the component name of <strong class="source-inline">com.hbs.hub.HelloWorld</strong> and start the version at 1.0.0. Change the directory to the artifacts folder: <strong class="source-inline">cd hbshub/artifacts</strong>.</li>
				<li>Make a new directory for your component's artifacts: <strong class="source-inline">mkdir -p com.hbs.hub.HelloWorld/1.0.0</strong>.</li>
				<li>Create a new file for the shell script: <strong class="source-inline">touch com.hbs.hub.HelloWorld/1.0.0/hello.sh</strong>.</li>
				<li>Give this file write permissions: <strong class="source-inline">chmod +x com.hbs.hub.HelloWorld/1.0.0/hello.sh</strong>.</li>
				<li>Open the file in an editor: <strong class="source-inline">nano com.hbs.hub.HelloWorld/1.0.0/hello.sh</strong>.</li>
				<li>Inside this editor, add the following content (this is also available in this chapter's GitHub repository):<p class="SC---Heading" lang="en-US" xml:lang="en-US">hello.sh</p><p class="source-code">#!/bin/bash</p><p class="source-code">if [ -z $1 ]; then</p><p class="source-code">        target="world"</p><p class="source-code">else</p><p class="source-code">        target=$1</p><p class="source-code">fi</p><p class="source-code">echo "Hello, $target"</p></li>
				<li>Test your <a id="_idIndexMarker169"/>script with and without an argument. The script will print <strong class="source-inline">Hello, world</strong> unless provided with an argument to substitute for <strong class="source-inline">world</strong>:<ol><li><strong class="source-inline">./com.hbs.hub.HelloWorld/1.0.0/hello.sh</strong></li><li><strong class="source-inline">./com.hbs.hub.HelloWorld/1.0.0/hello.sh friend</strong></li></ol></li>
				<li>That's all you need for your component's artifact. Next, you will learn how to take advantage of passing in arguments from inside the recipe file. Change the directory to the recipes directory: <strong class="source-inline">cd ~/hbshub/recipes</strong>.</li>
				<li>Open the editor to create the recipe file: <strong class="source-inline">nano com.hbs.hub.HelloWorld-1.0.0.json</strong>.</li>
				<li>Add the following content to the file. You can also copy this file from the book's GitHub <a id="_idIndexMarker170"/>repository:<p class="SC---Heading" lang="en-US" xml:lang="en-US">com.hbs.hub.HelloWorld-1.0.0.json</p><p class="source-code">{</p><p class="source-code">  "RecipeFormatVersion": "2020-01-25",</p><p class="source-code">  "ComponentName": "com.hbs.hub.HelloWorld",</p><p class="source-code">  "ComponentVersion": "1.0.0",</p><p class="source-code">  "ComponentDescription": "My first AWS IoT Greengrass component.",</p><p class="source-code">  "ComponentPublisher": "Home Base Solutions",</p><p class="source-code">  "ComponentConfiguration": {</p><p class="source-code">    "DefaultConfiguration": {</p><p class="source-code">      "Message": "world!"</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  "Manifests": [</p><p class="source-code">    {</p><p class="source-code">      "Platform": {</p><p class="source-code">        "os": "linux"</p><p class="source-code">      },</p><p class="source-code">      "Lifecycle": {</p><p class="source-code">        "Run": ". {artifacts:path}/hello.sh '{configuration:/Message}'"</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  ]</p><p class="source-code">}</p><p>This recipe is straightforward: it defines a life cycle step to run our <strong class="source-inline">hello.sh</strong> script that it will find in the deployed artifacts path. One new addition that has not yet been covered is the component configuration. The <strong class="source-inline">ComponentConfiguration</strong> object allows developers to define arbitrary key-value pairs that can be referenced in the rest of the recipe file. In this scenario, we define a default value to pass as an argument to the script. This value can be overridden when deploying a component to customize how each edge device<a id="_idIndexMarker171"/> uses the deployed component.</p><p>So, how do you test a component now that you've written the recipe and provided the artifacts? The next step is to create a new deployment that tells the local IoT Greengrass environment to load your new component and start evaluating life cycle events for it. This is where the IoT Greengrass CLI can help.</p></li>
				<li>Use the following command to create a new deployment that includes your new component: <p class="source-code"><strong class="bold">sudo /greengrass/v2/bin/greengrass-cli deployment create   --recipeDir ~/hbshub/recipes --artifactDir ~/hbshub/artifacts --merge "com.hbs.hub.HelloWorld=1.0.0"</strong></p></li>
				<li>You should view a response similar to the following:<p class="source-code"><strong class="bold">Local deployment submitted! Deployment Id: b0152914-869c-4fec-b24a-37baf50f3f69</strong></p></li>
				<li>You can verify that the component was successfully deployed (and has already finished running) with <strong class="source-inline">sudo /greengrass/v2/bin/greengrass-cli component list</strong>:<p class="source-code"><strong class="bold">Components currently running in Greengrass:</strong></p><p class="source-code"><strong class="bold">Component Name: com.hbs.hub.HelloWorld</strong></p><p class="source-code"><strong class="bold">    Version: 1.0.0</strong></p><p class="source-code"><strong class="bold">    State: FINISHED</strong></p><p class="source-code"><strong class="bold">    Configuration: {"Message":"world!"}</strong></p></li>
				<li>You can view the output of this component in its log file: <strong class="source-inline">sudo less /greengrass/v2/logs/com.hbs.hub.HelloWorld.log</strong> (remember, the <strong class="source-inline">/greengrass/v2 directory</strong> is owned by root, so the log files must also be<a id="_idIndexMarker172"/> accessed with <strong class="source-inline">sudo</strong>):<p class="source-code"><strong class="bold">2021-05-26T22:22:02.325Z [INFO] (pool-2-thread-32) com.hbs.hub.HelloWorld: shell-runner-start. {scriptName=services.com.hbs.hub.HelloWorld.lifecycle.Run, serviceName=com.hbs.hub.HelloWorld, currentState=STARTING, command=["/greengrass/v2/packages/artifacts/com.hbs.hub.HelloWorld/1.0.0/hello.sh 'world..."]}</strong></p><p class="source-code"><strong class="bold">2021-05-26T22:22:02.357Z [INFO] (Copier) com.hbs.hub.HelloWorld: stdout. Hello, world!. {scriptName=services.com.hbs.hub.HelloWorld.lifecycle.Run, serviceName=com.hbs.hub.HelloWorld, currentState=RUNNING}</strong></p><p class="source-code"><strong class="bold">2021-05-26T22:22:02.365Z [INFO] (Copier) com.hbs.hub.HelloWorld: Run script exited. {exitCode=0, serviceName=com.hbs.hub.HelloWorld, currentState=RUNNING}</strong></p></li>
			</ol>
			<p>Congratulations! You have written and deployed your first component to your Home Base Solutions prototype hub using IoT Greengrass. In the log output, you can observe two noteworthy observations. First, you can view the chronology of the component's life cycle change state from <strong class="source-inline">STARTING</strong> to <strong class="source-inline">RUNNING</strong> before reporting a successful exit code back to IoT Greengrass. The component concludes at that point, so we don't view an entry in the log that shows it move to the <strong class="source-inline">FINISHED</strong> state, although that is visible in the <strong class="source-inline">greengrass.log</strong> file. </p>
			<p>Second, you can view the message written to <strong class="source-inline">STDOUT</strong> with an exclamation point included (<strong class="source-inline">world!</strong>). This means that the script received your component's default configuration instead of falling back on the default built into <strong class="source-inline">hello.sh</strong> (<strong class="source-inline">world</strong>). You could also override the default configuration value of "world!" in the recipe file with a custom value included in the deployment command. You'll learn how to use that technique to<a id="_idIndexMarker173"/> configure fleets in <a href="B17595_04_Final_SS_ePub.xhtml#_idTextAnchor073"><em class="italic">Chapter 4</em></a><em class="italic">, Extending the Cloud to the Edge</em>.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Summary</h1>
			<p>In this chapter, you learned the basics regarding a specific tool we will use throughout this book that satisfies one of the key needs of any edge ML solution, that is, the runtime orchestrator. IoT Greengrass provides out-of-the-box features to focus developers on their business solutions instead of the undifferentiated work to architect a flexible, resilient edge runtime and deployment mechanism. You learned that the fundamental unit of software in IoT Greengrass is the component, which is made up of a recipe and a set of artifacts, and components make their way to the solution via deployments. You learned how to validate that a device is ready to work with IoT Greengrass using the IDT. You learned how to install IoT Greengrass, develop your first component, and get it running in the local environment. </p>
			<p>In the next chapter, we will take a deeper dive into how IoT Greengrass works by exploring how it enables gateway functionality, common protocols used at the edge, security best practices, and builds out new components used to sense and actuate in a cyber-physical solution. </p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/>Knowledge check</h1>
			<p>Before moving on to the next chapter, test your knowledge by answering these questions. The answers can be found at the end of the book:</p>
			<ol>
				<li value="1">Which of the following is the best practice for how to organize code in edge ML solutions? A monolithic application or isolated services? </li>
				<li>What is the benefit of decoupling services in your edge architecture?</li>
				<li>What is the benefit of isolating your code and dependencies from other services?</li>
				<li>What is one trade-off to consider when choosing between wired and wireless networking implementations in IoT solutions?</li>
				<li>What is an example of a smart home device that uses both a sensor and an actuator?</li>
				<li>What are the two kinds of resources that define an IoT Greengrass component?</li>
				<li>True or false: A component must define at least one artifact in its recipe.</li>
				<li>Why is it a good design principle that, by default, only the root system user can interact with files in the IoT Greengrass directory?</li>
				<li>True or false: Components can be deployed to IoT Greengrass devices either locally or remotely.</li>
				<li>Can you think of three different methods that you could use to update the behavior of your <strong class="source-inline">Hello, world</strong> component to print <strong class="source-inline">Hello, Home Base Solutions customer!</strong>?</li>
			</ol>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>References</h1>
			<p>Please refer to the following resources for additional information on the concepts discussed in this chapter:</p>
			<ul>
				<li>The semantic versioning specification at <a href="https://semver.org">https://semver.org</a>.</li>
				<li><em class="italic">Service-Oriented Architecture: Analysis and Design for Services and Microservices</em> by Erl Thomas, Pearson, 2016.</li>
				<li><em class="italic">Foundations of Analog and Digital Electric Circuits</em> by Anant Agarwal, Jeffrey H. Lang, and Morgan Kaufmann, 2005.</li>
			</ul>
		</div>
	</div></body></html>