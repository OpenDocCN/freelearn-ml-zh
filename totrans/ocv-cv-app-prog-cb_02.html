<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Manipulating Pixels</h1></div></div></div><p class="calibre8">In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem">Accessing pixel values</li><li class="listitem">Scanning an image with pointers</li><li class="listitem">Scanning an image with iterators</li><li class="listitem">Writing efficient image-scanning loops</li><li class="listitem">Scanning an image with neighbor access</li><li class="listitem">Performing simple image arithmetic</li><li class="listitem">Remapping an image</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec13" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre8">In order to build computer vision applications, you need to be able to access the image content and eventually modify or create images. This chapter will teach you how to manipulate the picture<a id="id88" class="calibre1"/> elements (also known as <strong class="calibre2">pixels</strong>). You will learn how to scan an image and process each of its pixels. You will also learn how to do this efficiently, since even images of modest dimensions can contain hundreds of thousands of pixels.</p><p class="calibre8">Fundamentally, an image is a matrix of numerical values. This is why, as we learned in <a class="calibre1" title="Chapter 1. Playing with Images" href="part0014_split_000.html#page">Chapter 1</a>, <em class="calibre9">Playing with Images</em>, OpenCV 2 manipulates them using the <code class="email">cv::Mat</code> data structure. Each element of the matrix represents one pixel. For a gray-level image (a black-and-white image), pixels are unsigned 8-bit values where <code class="email">0</code> corresponds to black and <code class="email">255</code> corresponds to white. In the case of color images, three primary color values are required in order to reproduce the different visible colors. This is a consequence of the fact that our human visual system is <a id="id89" class="calibre1"/>
<strong class="calibre2">trichromatic</strong>; three types of cone cells on our retinae convey the color information to our brain. This means that for a color image, three values must be associated to each pixel. In photography and digital imaging, the commonly used primary color channels are red, green, and blue. A matrix element is, therefore, made of a triplet of 8-bit values in this case.</p><p class="calibre8">Note that even if 8-bit channels are generally sufficient, there are specialized applications where 16-bit channels are required (medical imaging, for example).</p><p class="calibre8">As we saw in the previous chapter, OpenCV also allows you to create matrices (or images) with pixel values of other types, for example, integer (<code class="email">CV_32U</code> or <code class="email">CV_32S</code>) and floating point (<code class="email">CV_32F</code>) numbers. These are very useful to store, for example, intermediate values in some image-processing tasks. Most operations can be applied on matrices of any type; others require a specific type or work only with a given number of channels. Therefore, a good understanding of a function's or method's preconditions is essential in order to avoid common programming errors.</p><p class="calibre8">Throughout this chapter, we use the following color image as the input (refer to the book's graphics PDF to view this image in color):</p><div><img src="img/00012.jpeg" alt="Introduction" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec14" class="calibre1"/>Accessing pixel values</h1></div></div></div><p class="calibre8">In order<a id="id90" class="calibre1"/> to access each individual element of a matrix, you just need to specify its row and column numbers. The corresponding element, which can be a single numerical value or a vector of values in the case of a multi-channel image, will be returned.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec26" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">To illustrate the direct access to pixel values, we will create a simple function that adds <strong class="calibre2">salt-and-pepper noise</strong><a id="id91" class="calibre1"/> to an image. As the name suggests, salt-and-pepper noise is a particular type of noise in which some randomly selected pixels are replaced by a white or a black pixel. This type of noise can occur in faulty communications when the value of some pixels is lost during the transmission. In our case, we will simply randomly select a few pixels and assign them a white color.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec27" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">We create a function that receives an input image. This is the image that will be modified by our function. The second parameter is the number of pixels on which we want to overwrite white values:</p><div><pre class="programlisting">void salt(cv::Mat image, int n) {

  int i,j;
  for (int k=0; k&lt;n; k++) {

    // rand() is the random number generator
    i= std::rand()%image.cols;
    j= std::rand()%image.rows;


    if (image.type() == CV_8UC1) { // gray-level image

      image.at&lt;uchar&gt;(j,i)= 255; 

    } else if (image.type() == CV_8UC3) { // color image

      image.at&lt;cv::Vec3b&gt;(j,i)[0]= 255; 
      image.at&lt;cv::Vec3b&gt;(j,i)[1]= 255; 
      image.at&lt;cv::Vec3b&gt;(j,i)[2]= 255; 
    }
  }
}</pre></div><p class="calibre8">The preceding function is made of a single loop that assigns <code class="email">n</code> times the value <code class="email">255</code> to randomly selected <a id="id92" class="calibre1"/>pixels. Here, the pixel column <code class="email">i</code> and row <code class="email">j</code> are selected using a random number generator. Note that using the <code class="email">type</code> method, we distinguish the two cases of gray-level and color images. In the case of a gray-level image, the number <code class="email">255</code> is assigned to the single 8-bit value. For a color image, you need to assign <code class="email">255</code> to the three primary color channels in order to obtain a white pixel.</p><p class="calibre8">You can call this function by passing it an image you have previously opened. Refer to the following code:</p><div><pre class="programlisting">   // open the image
   cv::Mat image= cv::imread("boldt.jpg");

   // call function to add noise
   salt(image,3000);

   // display image
   cv::namedWindow("Image");
   cv::imshow("Image",image);</pre></div><p class="calibre8">The resulting image will look as follows:</p><div><img src="img/00013.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec28" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">The <code class="email">cv::Mat</code> class<a id="id93" class="calibre1"/> includes several methods to access the different attributes of an image. The public member variables, <code class="email">cols</code> and <code class="email">rows</code>, give you the number of columns and rows in <a id="id94" class="calibre1"/>the image. For element access, <code class="email">cv::Mat</code> has the <code class="email">at</code> (<code class="email">int y</code>, <code class="email">int x</code>) method. However, the type returned by a method must be known at compile time, and since <code class="email">cv::Mat</code> can hold elements of any type, the programmer needs to specify the return type that is expected. This is why the <code class="email">at</code> method has been implemented as a template method. So, when you call it, you must specify the image element type as follows:</p><div><pre class="programlisting">         image.at&lt;uchar&gt;(j,i)= 255;</pre></div><p class="calibre8">It is important to note that it is the programmer's responsibility to make sure that the type specified matches the type contained in the matrix. The <code class="email">at</code> method does not perform any type conversion.</p><p class="calibre8">In color images, each pixel is associated with three components: the red, green, and blue channels. Therefore, a <code class="email">cv::Mat</code> class that contains a color image will return a vector of three 8-bit values. OpenCV has defined a type for such short vectors, and it is<a id="id95" class="calibre1"/> called <code class="email">cv::Vec3b</code>. This is a vector of three <a id="id96" class="calibre1"/>
<strong class="calibre2">unsigned characters</strong>. This explains why the element access to the pixels of a color pixel is written as follows:</p><div><pre class="programlisting">         image.at&lt;cv::Vec3b&gt;(j,i)[channel]= value; </pre></div><p class="calibre8">The<a id="id97" class="calibre1"/> <code class="email">channel</code> index designates one of the three color channels. OpenCV stores the channel values in the order blue, green, and red (blue is, therefore, channel <code class="email">0</code>).</p><p class="calibre8">Similar vector types also exist for 2-element and 4-element vectors (<code class="email">cv::Vec2b</code> and <code class="email">cv::Vec4b</code>) as well as for other element types. For example, for a 2-element float vector, the last letter of the type name would be replaced by an f, that is, <code class="email">cv::Vec2f</code>. In the case of a short integer, the last letter is replaced with <code class="email">s</code>, with <code class="email">i</code> for an integer, and with <code class="email">d</code> for a double precision floating point vector. All of these types are defined using the <code class="email">cv::Vec&lt;T,N&gt;</code> template class, where <code class="email">T</code> is the type and <code class="email">N</code> is the number of vector elements.</p><p class="calibre8">As a last note, you might have been surprised by the fact that our image-modifying function uses a pass-by-value image parameter. This works because when images are copied, they still share the same image data. So, you do not have to necessarily transmit images by references when you want to modify their content. Incidentally, pass-by-value parameters often make code optimization easier for the compiler.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec29" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre8">The <code class="email">cv::Mat</code> class has been made generic by defining it using C++ templates.</p><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec09" class="calibre1"/>The cv::Mat_ template class</h3></div></div></div><p class="calibre8">Using the <code class="email">at</code> method <a id="id98" class="calibre1"/>of the <code class="email">cv::Mat</code> class can sometimes be cumbersome because the returned type must be specified as a template argument in each call. In cases where the matrix type is known, it is possible to use the <code class="email">cv::Mat_</code> class, which is a template subclass of <code class="email">cv::Mat</code>. This class defines a few extra methods but no new data attributes so that pointers or references to one class can be directly converted to another class. Among the extra methods, there is <code class="email">operator()</code>, which allows direct access to matrix elements. Therefore, if <code class="email">image</code> is a <code class="email">cv::Mat</code> variable that corresponds to a <code class="email">uchar</code> matrix, then you can write the following code:</p><div><pre class="programlisting">  // use image with a Mat_ template
  cv::Mat_&lt;uchar&gt; im2(image);
  im2(50,100)= 0; // access to row 50 and column 100</pre></div><p class="calibre8">Since the type of the <code class="email">cv::Mat_</code> elements is declared when the variable is created, the <code class="email">operator()</code> method knows at compile time which type is to be returned. Other than the fact that it is shorter to write, using the <code class="email">operator()</code> method provides exactly the same result as the <code class="email">at</code> method.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec30" class="calibre1"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em class="calibre9">There's more…</em> section of the <em class="calibre9">Scanning an image with pointers</em> recipe explains how to create a function with input and output parameters</li><li class="listitem">The <em class="calibre9">Writing efficient image-scanning loops</em> recipe proposes a discussion on the efficiency of this method</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec15" class="calibre1"/>Scanning an image with pointers</h1></div></div></div><p class="calibre8">In most<a id="id99" class="calibre1"/> image-processing tasks, you need to scan all pixels of the image in order to perform a computation. Considering <a id="id100" class="calibre1"/>the large number of pixels that will need to be visited, it is essential that you perform this task in an efficient way. This recipe, and the next one, will show you different ways of implementing efficient scanning loops. This recipe uses the <a id="id101" class="calibre1"/>pointer arithmetic.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec31" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">We will illustrate the image-scanning process by accomplishing a simple task: reducing the number of colors in an image.</p><p class="calibre8">Color images are composed of 3-channel pixels. Each of these channels corresponds to the intensity value of one of the three primary colors, red, green, and blue. Since each of these values is an 8-bit unsigned character, the total number of colors is <code class="email">256x256x256</code>, which is more than 16 million colors. Consequently, to reduce the complexity of an analysis, it is sometimes <a id="id102" class="calibre1"/>useful to reduce the number of colors in an image. One way to achieve this goal is to simply subdivide the <a id="id103" class="calibre1"/>RGB space into cubes of equal sizes. For example, if you reduce the number of colors in each dimension by <code class="email">8</code>, then you would obtain a total of <code class="email">32x32x32</code> colors. Each color in the original image is then assigned a new color value in the color-reduced image that corresponds to the value in the center of the cube to which it belongs.</p><p class="calibre8">Therefore, the basic color reduction algorithm is simple. If <code class="email">N</code> is the reduction factor, then divide the value by <code class="email">N</code> (the integer division, therefore, the reminder is lost) for each pixel in the image and for each channel of this pixel. Then, multiply the result by <code class="email">N</code>; this will give you the multiple of <code class="email">N</code> just below the input pixel value. Just add <code class="email">N/2</code> and you obtain the central position of the interval between two adjacent multiples of <code class="email">N</code>. If you repeat this process for each 8-bit channel value, then you will obtain a total of <code class="email">256/N x 256/N x 256/N </code>possible color values.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec32" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">The <a id="id104" class="calibre1"/>signature of our color reduction function will be as follows:</p><div><pre class="programlisting">void colorReduce(cv::Mat image, int div=64);</pre></div><p class="calibre8">The user provides an image and the per-channel reduction factor. Here, the processing is done<a id="id105" class="calibre1"/> <strong class="calibre2">in-place</strong>, that is, the pixel values of the input image are modified by the function. See the <em class="calibre9">There's more…</em> section of this recipe for a more general function signature with input and output arguments.</p><p class="calibre8">The processing is simply done by creating a double loop that goes over all pixel values as follows:</p><div><pre class="programlisting">void colorReduce(cv::Mat image, int div=64) {

     int nl= image.rows; // number of lines
     // total number of elements per line
     int nc= image.cols * image.channels(); 
              
     for (int j=0; j&lt;nl; j++) {

        // get the address of row j
        uchar* data= image.ptr&lt;uchar&gt;(j);

        for (int i=0; i&lt;nc; i++) {

            // process each pixel ---------------------

            data[i]=    data[i]/div*div + div/2;

            // end of pixel processing ----------------

        } // end of line
     }
}</pre></div><p class="calibre8">This<a id="id106" class="calibre1"/> function can be tested using the following code snippet:</p><div><pre class="programlisting">   // read the image
   image= cv::imread("boldt.jpg");
   // process the image
   colorReduce(image,64);
   // display the image
   cv::namedWindow("Image");
   cv::imshow("Image",image);</pre></div><p class="calibre8">This will <a id="id107" class="calibre1"/>give you, for example, the following image (refer to the book's graphics PDF to view this image in color):</p><div><img src="img/00014.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec33" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">In a <a id="id108" class="calibre1"/>color image, the <a id="id109" class="calibre1"/>first three bytes of the image data buffer give values of the upper-left pixel to the 3-color channel, the next three bytes are the values of the second pixel of the first row, and so on (remember that OpenCV uses, by default, the BGR channel order). An image of width <code class="email">W</code> and height <code class="email">H</code> would then require a memory block of <code class="email">WxHx3</code> <code class="email">uchars</code>. However, for efficiency reasons, the length of a row can be padded with a few extra pixels. This is because some multimedia processor chips (for example, the Intel MMX architecture) can process images more efficiently when their rows are multiples of 4 or 8. Obviously, these extra pixels are not displayed or saved; their exact values are ignored. OpenCV designates the length of a padded row as the effective width. Obviously, if the image has not been padded with extra pixels, the effective width will be equal to the real image width. We have already learned that the <code class="email">cols</code> and <code class="email">rows</code> attributes give you the image's width and height; similarly, the <code class="email">step</code> data attribute gives you the effective width in number of bytes. Even if your image is of a type other than <code class="email">uchar</code>, the <code class="email">step</code> data will still give you the number of bytes in a row. The size of a pixel element is given by the <code class="email">elemSize</code> method (for example, for a 3-channel short integer matrix (<code class="email">CV_16SC3</code>), <code class="email">elemSize</code> will return <code class="email">6</code>). Recall that the number of channels in the image is given by the <code class="email">nchannels</code> method (which will be <code class="email">1</code> for a gray-level image and <code class="email">3</code> for a color image). Finally, the <code class="email">total</code> method returns the total number of pixels (that is, the matrix entries) in the matrix.</p><p class="calibre8">The number of pixel values per row is then given by the following code:</p><div><pre class="programlisting">     int nc= image.cols * image.channels();</pre></div><p class="calibre8">To <a id="id110" class="calibre1"/>simplify <a id="id111" class="calibre1"/>the computation of the pointer arithmetic, the <code class="email">cv::Mat</code> class offers a method that directly gives you the address of an image row. This is the <code class="email">ptr</code> method. It is a template method that returns the address of row number <code class="email">j</code>:</p><div><pre class="programlisting">     uchar* data= image.ptr&lt;uchar&gt;(j);</pre></div><p class="calibre8">Note that in the processing statement, we could have equivalently used the pointer arithmetic to move from column to column. So, we could have written the following code:</p><div><pre class="programlisting">     *data= *data/div*div + div2; data++;</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec34" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre8">The color reduction function<a id="id112" class="calibre1"/> presented in this recipe provides just one way of accomplishing this task. You could also use other color reduction formulas. A more general version of the function would also allow the specification of distinct input and output images. The image scanning can also be made more efficient by taking into account the continuity of the image data. Finally, it is also possible to use regular low-level pointer arithmetic to scan the image buffer. All of these elements are discussed in the following subsections.</p><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec10" class="calibre1"/>Other color reduction formulas</h3></div></div></div><p class="calibre8">In our example, color reduction<a id="id113" class="calibre1"/> is achieved by taking advantage of an integer division that floors the division result to the nearest lower integer as follows:</p><div><pre class="programlisting">     data[i]= (data[i]/div)*div + div/2;</pre></div><p class="calibre8">The reduced color could have also been computed using the modulo operator that brings us to the nearest multiple of <code class="email">div</code> (the per-channel reduction factor) as follows:</p><div><pre class="programlisting">     data[i]= data[i] – data[i]%div + div/2;</pre></div><p class="calibre8">Another option would be to use bitwise operators. Indeed, if we restrict the reduction factor to a power of <code class="email">2</code>, that is, <code class="email">div=pow(2,n)</code>, then masking the first <code class="email">n</code> bits of the pixel value would give us the nearest lower multiple of <code class="email">div</code>. This mask would be computed by a simple bit shift as follows:</p><div><pre class="programlisting">     // mask used to round the pixel value
     uchar mask= 0xFF&lt;&lt;n; // e.g. for div=16, mask= 0xF0</pre></div><p class="calibre8">The color reduction would be given by the following code:</p><div><pre class="programlisting">      *data &amp;= mask;      // masking
      *data++ += div&gt;&gt;1;  // add div/2</pre></div><p class="calibre8">In general, bitwise <a id="id114" class="calibre1"/>operations might lead to very efficient code, so they could constitute a powerful alternative when efficiency is a requirement.</p></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec11" class="calibre1"/>Having input and output arguments</h3></div></div></div><p class="calibre8">In our color reduction<a id="id115" class="calibre1"/> example, the transformation is directly applied to the input image, which is called an in-place transformation. This way, no extra image is required to hold the output result, which could save on the memory <a id="id116" class="calibre1"/>usage when it is a concern. However, in some applications, the user might want to keep the original image intact. The user would then be forced to create a copy of the image before calling the function. Note that the easiest way to create an identical deep copy of an image is to call the <code class="email">clone</code> method; for example, take a look at the following code:</p><div><pre class="programlisting">   // read the image
   image= cv::imread("boldt.jpg");
   // clone the image
   cv::Mat imageClone= image.clone();
   // process the clone
   // orginal image remains untouched
   colorReduce(imageClone);
   // display the image result
   cv::namedWindow("Image Result");
   cv::imshow("Image Result",imageClone);</pre></div><p class="calibre8">This extra overload can be avoided by defining a function that gives the user the option to either use or not use in-place processing. The signature of the method would then be as follows:</p><div><pre class="programlisting">void colorReduce(const cv::Mat &amp;image, // input image 
                 cv::Mat &amp;result,      // output image
                 int div=64);</pre></div><p class="calibre8">Note that the input image is now passed as a <code class="email">const</code> reference, which means that this image will not be modified by the function. The output image is passed as a reference such that the calling function will see the output argument modified by this call. When in-place processing is preferred, the same image is specified as the input and output:</p><div><pre class="programlisting">colorReduce(image,image);</pre></div><p class="calibre8">If not, another <code class="email">cv::Mat</code> instance can be provided; for example, take a look at the following code:</p><div><pre class="programlisting">cv::Mat result;   
colorReduce(image,result);</pre></div><p class="calibre8">The key here is to first verify whether the output image has an allocated data buffer with a size and pixel<a id="id117" class="calibre1"/> type that matches the one of the input image. Very conveniently, this check is encapsulated inside the <code class="email">create</code> method of <code class="email">cv::Mat</code>. This is the <a id="id118" class="calibre1"/>method that is to be used when a matrix must be reallocated with a new size and type. If, by chance, the matrix already has the size and type specified, then no operation is performed and the method simply returns without touching the instance.</p><p class="calibre8">Therefore, our function should simply start with a call to <code class="email">create</code> that builds a matrix (if necessary) of the same size and type as the input image:</p><div><pre class="programlisting">     result.create(image.rows,image.cols,image.type());</pre></div><p class="calibre8">The allocated memory block has a size of <code class="email">total()*elemSize()</code>. The looping is then done with two pointers:</p><div><pre class="programlisting">   for (int j=0; j&lt;nl; j++) {

        // get the addresses of input and output row j
        const uchar* data_in= image.ptr&lt;uchar&gt;(j);
        uchar* data_out= result.ptr&lt;uchar&gt;(j);

        for (int i=0; i&lt;nc*nchannels; i++) {

            // process each pixel ---------------------

            data_out[i]= data_in[i]/div*div + div/2;

            // end of pixel processing ----------------

        } // end of line
  }</pre></div><p class="calibre8">In the case where the same image is provided as the input and output, this function becomes completely equivalent to the first version presented in this recipe. If another image is provided as the output, the function will work correctly irrespective of whether the image has or has not been allocated prior to the function call.</p></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec12" class="calibre1"/>Efficient scanning of continuous images</h3></div></div></div><p class="calibre8">We previously<a id="id119" class="calibre1"/> explained that, for efficiency reasons, an image can be padded with extra pixels at the end of each row. However, it is interesting to note that when the image is unpadded, it can also be seen as a long one-dimensional array of <code class="email">WxH</code> pixels. A convenient <code class="email">cv::Mat</code> method can tell us whether the image has been padded or not. This is the <code class="email">isContinuous</code> method that returns <code class="email">true</code> if the image does not include padded pixels. Note that we could also check the continuity of the matrix by writing the following test:</p><div><pre class="programlisting">// check if size of a line (in bytes)
// equals the number of columns times pixel size in bytes
image.step == image.cols*image.elemSize();</pre></div><p class="calibre8">To be complete, this test should also check whether the matrix has only one line; in which case, it is continuous by definition. Nevertheless, always use the <code class="email">isContinuous</code> method to test the continuity condition. In some specific processing algorithms, you can take advantage of the continuity of the image by processing it in one single (longer) loop. Our processing function would then be written as follows:</p><div><pre class="programlisting">void colorReduce(cv::Mat &amp;image, int div=64) {

     int nl= image.rows; // number of lines
     int nc= image.cols * image.channels(); 

     if (image.isContinuous()) 
     {
        // then no padded pixels
        nc= nc*nl; 
        nl= 1;  // it is now a long 1D array
     }

     // this loop is executed only once
     // in case of continuous images
     for (int j=0; j&lt;nl; j++) { 

          uchar* data= image.ptr&lt;uchar&gt;(j);

          for (int i=0; i&lt;nc; i++) {

            // process each pixel ---------------------
                
            data[i]= data[i]/div*div + div/2;

            // end of pixel processing ----------------

          } // end of line                   
     }
}</pre></div><p class="calibre8">Now, when the continuity test tells us that the image does not contain padded pixels, we eliminate the outer loop<a id="id120" class="calibre1"/> by setting the width to <code class="email">1</code> and the height to <code class="email">WxH</code>. Note that there is also a <code class="email">reshape</code> method that could have been used here. You would write the following in this case:</p><div><pre class="programlisting">     if (image.isContinuous()) 
     {
        // no padded pixels
        image.reshape(1,   // new number of channels
                      1); // new number of rows
     }

     int nl= image.rows; // number of lines
     int nc= image.cols * image.channels(); </pre></div><p class="calibre8">The <code class="email">reshape</code> method changes the matrix dimensions without requiring any memory copying or reallocation. The first parameter is the new number of channels and the second one is the new number of rows. The number of columns is readjusted accordingly.</p><p class="calibre8">In these implementations, the inner loop processes all image pixels in a sequence. This approach is mainly advantageous when several small images are scanned simultaneously into the same loop.</p></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec13" class="calibre1"/>Low-level pointer arithmetics</h3></div></div></div><p class="calibre8">In the <code class="email">cv::Mat</code> class, the image <a id="id121" class="calibre1"/>data is contained in a memory block of unsigned chars. The address of the first element of this memory block is given by the data attribute that returns an unsigned char pointer. So, to start your loop at the beginning of the image, you could have written the following code:</p><div><pre class="programlisting">uchar *data= image.data;</pre></div><p class="calibre8">Moving from one row to the next could have been done by moving your row pointer using the effective width as follows:</p><div><pre class="programlisting">data+= image.step;  // next line</pre></div><p class="calibre8">The <code class="email">step</code> method gives you the total number of bytes (including the padded pixels) in a line. In general, you can obtain the address of the pixel at row <code class="email">j</code> and column <code class="email">i</code> as follows:</p><div><pre class="programlisting">// address of pixel at (j,i) that is &amp;image.at(j,i)     
data= image.data+j*image.step+i*image.elemSize();    </pre></div><p class="calibre8">However, even<a id="id122" class="calibre1"/> if this would work in our example, it is not recommended that you proceed this way.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec35" class="calibre1"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em class="calibre9">Writing efficient image-scanning loops</em> recipe in this chapter proposes a discussion on the efficiency of the scanning methods presented here</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec16" class="calibre1"/>Scanning an image with iterators</h1></div></div></div><p class="calibre8">In object-oriented programming, looping<a id="id123" class="calibre1"/> over a data collection is usually done using iterators. Iterators are specialized classes<a id="id124" class="calibre1"/> that are built to go over each element of a collection, hiding how the iteration over each element is specifically done for a given collection. This application of the information-hiding principle makes scanning a collection easier and safer. In addition, it makes it similar in form no matter what type of collection is used. The <a id="id125" class="calibre1"/>
<strong class="calibre2">Standard Template Library</strong> (<strong class="calibre2">STL</strong>) has an iterator class associated with each of its collection classes. OpenCV then offers a <code class="email">cv::Mat</code> iterator class that is compatible with the standard iterators found in the C++ STL.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec36" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">In this recipe, we again use the color reduction example described in the previous recipe.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec37" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">An iterator object for a <code class="email">cv::Mat</code> instance can be obtained by first creating a <code class="email">cv::MatIterator_</code> object. As is the case with <code class="email">cv::Mat_</code>, the underscore indicates that this is a template subclass. Indeed, since image iterators are used to access the image elements, the return type must be known at the time of compilation. The iterator is then declared as follows:</p><div><pre class="programlisting">     cv::MatIterator_&lt;cv::Vec3b&gt; it;</pre></div><p class="calibre8">Alternatively, you can also use the <code class="email">iterator</code> type defined inside the <code class="email">Mat_</code> template class as follows:</p><div><pre class="programlisting">     cv::Mat_&lt;cv::Vec3b&gt;::iterator it;</pre></div><p class="calibre8">You then loop over the pixels using the usual <code class="email">begin</code> and <code class="email">end</code> iterator methods, except that these ones are, again, template methods. Consequently, our color reduction function is now written as follows:</p><div><pre class="programlisting">void colorReduce(cv::Mat &amp;image, int div=64) {

     // obtain iterator at initial position
     cv::Mat_&lt;cv::Vec3b&gt;::iterator it= 
               image.begin&lt;cv::Vec3b&gt;();
     // obtain end position
     cv::Mat_&lt;cv::Vec3b&gt;::iterator itend= 
               image.end&lt;cv::Vec3b&gt;();

     // loop over all pixels
     for ( ; it!= itend; ++it) {
        // process each pixel ---------------------

       (*it)[0]= (*it)[0]/div*div + div/2;
       (*it)[1]= (*it)[1]/div*div + div/2;
       (*it)[2]= (*it)[2]/div*div + div/2;

        // end of pixel processing ----------------
     }
}</pre></div><p class="calibre8">Remember<a id="id126" class="calibre1"/> that the<a id="id127" class="calibre1"/> iterator here returns a <code class="email">cv::Vec3b</code> instance because we are processing a color image. Each color channel element is accessed using the dereferencing operator <code class="email">[]</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec38" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Working with iterators always follows the same pattern no matter what kind of collection is scanned.</p><p class="calibre8">First, you create your iterator object using the appropriate specialized class, which in our example is <code class="email">cv::Mat_&lt;cv::Vec3b&gt;::iterator</code> (or <code class="email">cv::MatIterator_&lt;cv::Vec3b&gt;</code>).</p><p class="calibre8">You then obtain an iterator initialized at the starting position (in our example, the upper-left corner of the image). This is done using a <code class="email">begin</code> method. With a <code class="email">cv::Mat</code> instance, you obtain it as <code class="email">image.begin&lt;cv::Vec3b&gt;()</code>. You can also use arithmetic on the iterator. For example, if you wish to start at the second row of an image, you can initialize your <code class="email">cv::Mat </code>iterator at <code class="email">image.begin&lt;cv::Vec3b&gt;()+image.cols</code>. The end position of your collection is obtained similarly but using the <code class="email">end</code> method. However, the iterator thus obtained is just outside your collection. This is why your iterative process must stop when it reaches the end position. You can also use arithmetic on this iterator; for example, if you wish to stop before the last row, your final iteration would stop when the iterator reaches <code class="email">image.end&lt;cv::Vec3b&gt;()-image.cols</code>.</p><p class="calibre8">Once your<a id="id128" class="calibre1"/> iterator is initialized, you create a loop that goes over all elements until the end is reached. A typical <code class="email">while</code> loop will look like the following code: </p><div><pre class="programlisting">     while (it!= itend) { 

        // process each pixel ---------------------
         

        // end of pixel processing ----------------

        ++it;
     }</pre></div><p class="calibre8">The <code class="email">++</code> operator<a id="id129" class="calibre1"/> is the one that is to be used to move to the next element. You can also specify the larger step size. For example, <code class="email">it+=10</code> would process the image every <code class="email">10</code> pixels.</p><p class="calibre8">Finally, inside <a id="id130" class="calibre1"/>the processing loop, you use the dereferencing operator <code class="email">*</code> in order to access the current element, using which, you can read (for example, <code class="email">element= *it;</code>) or write (for example, <code class="email">*it= element;</code>). Note that it is also possible to create constant iterators that you use if you receive a reference to <code class="email">const</code> <code class="email">cv::Mat</code> or if you wish to signify that the current loop does not modify the <code class="email">cv::Mat</code> instance. These are declared as follows:</p><div><pre class="programlisting">     cv::MatConstIterator_&lt;cv::Vec3b&gt; it;</pre></div><p class="calibre8">Or, they are declared as follows:</p><div><pre class="programlisting">     cv::Mat_&lt;cv::Vec3b&gt;::const_iterator it;</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec39" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre8">In this recipe, the start and end positions of the iterator were obtained using the <code class="email">begin</code> and <code class="email">end</code> template methods. As we did in the first recipe of this chapter, we could have also obtained them using a reference to a <code class="email">cv::Mat_</code> instance. This would avoid the need to specify the iterator type in the <code class="email">begin</code> and <code class="email">end</code> methods since this one is specified when the <code class="email">cv::Mat_</code> reference is created.</p><div><pre class="programlisting">     cv::Mat_&lt;cv::Vec3b&gt; cimage(image);
     cv::Mat_&lt;cv::Vec3b&gt;::iterator it= cimage.begin();
     cv::Mat_&lt;cv::Vec3b&gt;::iterator itend= cimage.end();</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec40" class="calibre1"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em class="calibre9">Writing efficient image-scanning loops</em> recipe proposes a discussion on the efficiency of iterators when scanning an image.</li><li class="listitem">Also, if you are not familiar with the concept of iterators in object-oriented programming and how they are implemented in ANSI C++, you should read a tutorial on STL iterators. Simply search the Web with the keywords "STL Iterator" and you will find numerous references on the subject.</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec17" class="calibre1"/>Writing efficient image-scanning loops</h1></div></div></div><p class="calibre8">In the <a id="id131" class="calibre1"/>previous recipes of this chapter, we presented different ways of scanning an image in order to process its pixels. In this recipe, we will compare the efficiency of these different approaches.</p><p class="calibre8">When you write an image-processing function, efficiency is often a concern. When you design your function, you will frequently need to check the computational efficiency of your code in order to detect any bottleneck in your processing that might slow down your program.</p><p class="calibre8">However, it is important to note that unless necessary, optimization should not be done at the price of reducing the program clarity. Simple code is indeed always easier to debug and maintain. Only code portions that are critical to a program's efficiency should be heavily optimized.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec41" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">In order to measure the execution time of a function or a portion of code, there exists a very convenient OpenCV function <a id="id132" class="calibre1"/>called <code class="email">cv::getTickCount()</code>. This function gives you the number of clock cycles that have occurred since the last time you started your computer. Since we want the execution time of a code portion given in seconds, we use another <a id="id133" class="calibre1"/>method, <code class="email">cv::getTickFrequency()</code>. This gives us the number of cycles per second. The usual pattern to be used in order to obtain the computational time of a given function (or portion of code) would then be as follows:</p><div><pre class="programlisting">const int64 start = cv::getTickCount();
colorReduce(image); // a function call
// elapsed time in seconds
double duration = (cv::getTickCount()-start)/
                               cv::getTickFrequency();</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec42" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">The execution<a id="id134" class="calibre1"/> times of the different implementations of the <code class="email">colorReduce</code> function from this chapter are reported here. The absolute runtime numbers would differ from one machine to another (here, we used a 2.40 GHz machine equipped with a 64-bit Intel Core i7). It is rather interesting to look at their relative difference. These results are also dependent on the specific compiler that is used to produce the executable file. Our tests report the average time to reduce the colors of an image that has a resolution of 4288 x 2848 pixels.</p><p class="calibre8">First, we compare the three ways of computing the color reduction as presented in the <em class="calibre9">There's more...</em> section of the <em class="calibre9">Scanning an image with pointers</em> recipe. It is interesting to observe that the formula that uses the bitwise operator is much faster than the others at 9.5ms. The one using the integer division is at 26ms. The version based on the modulo operator is, however, at 33 ms. This represents a factor of more than 3 between the fastest and the slowest! It is therefore important to take the time to identify the most efficient way of computing a result in an image loop, as the net impact can be very significant.</p><p class="calibre8">When an output image that needs to be reallocated is specified instead of in-place processing, the execution time becomes 29 ms. The extra duration represents the overhead for memory allocation.</p><p class="calibre8">In a loop, you should avoid repetitive computations of values that could be precomputed instead. This consumes time, obviously. For example, you take the following inner loop of the color reduction function:</p><div><pre class="programlisting"> int nc= image.cols * image.channels();
 uchar div2= div&gt;&gt;1; 
 
 for (int i=0; i&lt;nc; i++) {</pre></div><p class="calibre8">Then, you replace it with the following one:</p><div><pre class="programlisting"> for (int i=0; i&lt;image.cols * image.channels(); i++) {
 // . . .
 *data++ += div&gt;&gt;1;</pre></div><p class="calibre8">The preceding code is a loop where you need to compute the total number of elements in a line and the <code class="email">div&gt;&gt;1</code> result again and again; you will obtain a runtime of 52 ms, which is significantly slower than the original version at 26 ms. Note, however, that some compilers might be able to optimize these kinds of loops and still obtain efficient code.</p><p class="calibre8">The version of the color reduction function that uses iterators, as shown in the <em class="calibre9">Scanning an image with iterators</em> recipe, gives slower results at 52 ms. The main objective of iterators is to simplify the image-scanning process and make it less prone to errors.</p><p class="calibre8">For completeness, we also implemented a version of the function that uses the <code class="email">at</code> method for pixel access. The main loop of this implementation would then simply read as follows:</p><div><pre class="programlisting">for (int j=0; j&lt;nl; j++) {
  for (int i=0; i&lt;nc; i++) {

    // process each pixel ---------------------
                 
    image.at&lt;cv::Vec3b&gt;(j,i)[0]=
               image.at&lt;cv::Vec3b&gt;(j,i)[0]/div*div + div/2;
    image.at&lt;cv::Vec3b&gt;(j,i)[1]=    
              image.at&lt;cv::Vec3b&gt;(j,i)[1]/div*div + div/2;
    image.at&lt;cv::Vec3b&gt;(j,i)[2]=    
              image.at&lt;cv::Vec3b&gt;(j,i)[2]/div*div + div/2;

    // end of pixel processing ----------------

  } // end of line
}</pre></div><p class="calibre8">This implementation is much slower when a runtime of 53 ms is obtained. This method should then be used only for the random access of image pixels but never when scanning an image.</p><p class="calibre8">A shorter loop <a id="id135" class="calibre1"/>with few statements is generally more efficiently executed than a longer loop over a single statement even if the total number of elements processed is the same. Similarly, if you have <code class="email">N </code>different computations to apply to a pixel, apply all of them in one loop rather than writing <code class="email">N</code> successive loops, one for each computation. </p><p class="calibre8">We also performed the continuity test that produces one loop in the case of continuous images instead of the regular double loop over lines and columns. For a very large image, like the one we used in our tests, this optimization is not significant (25 ms instead of 26 ms), but in general, it is always a good practice to use this strategy, since it can lead to a significant gain in speed.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec43" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre8">Multithreading is another way to increase the efficiency of your algorithms, especially since the advent of multicore processors. <strong class="calibre2">OpenMP</strong><a id="id136" class="calibre1"/> and the <strong class="calibre2">Intel Threading Building Blocks</strong> (<strong class="calibre2">TBB</strong>)<a id="id137" class="calibre1"/> are two popular APIs that are used in concurrent programming to create and manage your threads. In addition, C++11 now offers built-in support for threads.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec44" class="calibre1"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em class="calibre9">Performing simple image arithmetic</em> recipe presents an implementation of the color-reduction function (described in the <em class="calibre9">There's more...</em> section) that uses the OpenCV 2 arithmetic image operators and has a runtime of 25 ms.</li><li class="listitem">The <em class="calibre9">Applying look-up tables to modify image appearance</em> recipe of <a class="calibre1" title="Chapter 4. Counting the Pixels with Histograms" href="part0032_split_000.html#page">Chapter 4</a>, <em class="calibre9">Counting the Pixels with Histograms</em> describes an implementation of the color-reduction function based on a look-up table. The idea is to precompute all intensity reduction values that lead to a runtime of 22 ms.</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>Scanning an image with neighbor access</h1></div></div></div><p class="calibre8">In image <a id="id138" class="calibre1"/>processing, it is common to have a processing function that computes a value at each pixel location based on the value of the neighboring pixels. When<a id="id139" class="calibre1"/> this neighborhood includes pixels of the previous and next lines, you then need to simultaneously scan several lines of the image. This recipe shows you how to do it.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec45" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">To illustrate this recipe, we will apply a processing function that sharpens an image. It is based on the Laplacian operator (which will be discussed in <a class="calibre1" title="Chapter 6. Filtering the Images" href="part0047_split_000.html#page">Chapter 6</a>, <em class="calibre9">Filtering the Images</em>). It is indeed a well-known result in image processing that if you subtract the Laplacian from an image, the image edges are amplified, thereby giving a sharper image.</p><p class="calibre8">This sharpened value is computed as follows:</p><div><pre class="programlisting">sharpened_pixel= 5*current-left-right-up-down;</pre></div><p class="calibre8">Here, <code class="email">left</code> is the pixel that is immediately on the left-hand side of the current one, <code class="email">up</code> is the corresponding one on the previous line, and so on.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec46" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">This time, the processing cannot be accomplished in-place. Users need to provide an output image. The image scanning is done using three pointers, one for the current line, one for the line above, and another one for the line below. Also, since each pixel computation requires access to the neighbors, it is not possible to compute a value for the pixels of the first and last row of the image as well as the pixels of the first and last column. The loop can then be written as follows:</p><div><pre class="programlisting">void sharpen(const cv::Mat &amp;image, cv::Mat &amp;result) {

   // allocate if necessary
  result.create(image.size(), image.type()); 
  int nchannels= image.channels(); // get number of channels

   // for all rows (except first and last)
  for (int j= 1; j&lt;image.rows-1; j++) { 

    const uchar* previous= 
        image.ptr&lt;const uchar&gt;(j-1);     // previous row
    const uchar* current= 
        image.ptr&lt;const uchar&gt;(j);       // current row
    const uchar* next= 
        image.ptr&lt;const uchar&gt;(j+1);     // next row

    uchar* output= result.ptr&lt;uchar&gt;(j); // output row

    for (int i=nchannels; i&lt;(image.cols-1)*nchannels; i++) {

       *output++= cv::saturate_cast&lt;uchar&gt;(
                  5*current[i]-current[i-nchannels]-
                  current[i+nchannels]-previous[i]-next[i]); 
    }
  }

  // Set the unprocessed pixels to 0
  result.row(0).setTo(cv::Scalar(0));
  result.row(result.rows-1).setTo(cv::Scalar(0));
  result.col(0).setTo(cv::Scalar(0));
  result.col(result.cols-1).setTo(cv::Scalar(0));
}</pre></div><p class="calibre8">Note <a id="id140" class="calibre1"/>how we <a id="id141" class="calibre1"/>wrote the function such that it would work on both gray-level and color images. If we apply this function on a gray-level version of our test image, the following result is obtained:</p><div><img src="img/00015.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec47" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">In order to<a id="id142" class="calibre1"/> access the neighboring pixels of the previous and next row, you must simply define additional pointers that are jointly incremented. You then access the pixels of these lines inside the scanning loop.</p><p class="calibre8">In the computation <a id="id143" class="calibre1"/>of the output pixel value, the <code class="email">cv::saturate_cast</code> template function is called on the result of the operation. This is because it often happens that a mathematical expression applied on pixels leads to a result that goes outside the range of the permitted pixel values (that is, below 0 or over 255). The solution is then to bring the values back inside this 8-bit range. This is done by changing negative values to <code class="email">0</code> and values over <code class="email">255</code> to <code class="email">255</code>. This is exactly what the <code class="email">cv::saturate_cast&lt;uchar&gt;</code> function is doing. In addition, if the input argument is a floating point number, then the result is rounded to the nearest integer. You can obviously use this function with other types in order to guarantee that the result will remain within the limits defined by this type.</p><p class="calibre8">Border pixels that cannot be processed because their neighborhood is not completely defined need to be handled separately. Here, we simply set them to <code class="email">0</code>. In other cases, it could be possible to perform a special computation for these pixels, but most of the time, there is no point in spending time to process these very few pixels. In our function, these border pixels are set to <code class="email">0</code> using two special methods. The first one is <code class="email">row</code> and its dual is <code class="email">col</code>. They return a special <code class="email">cv::Mat</code> instance composed of a single-line ROI (or a single-column ROI) as <a id="id144" class="calibre1"/>specified in a parameter (remember, we <a id="id145" class="calibre1"/>discussed region of interest in the previous chapter). No copy is made here because if the elements of this 1D matrix are modified, they will also be modified in the original image. This is what we do when the <code class="email">setTo</code> method is called. This method assigns a value to all elements of a matrix. Take a look at the following statement:</p><div><pre class="programlisting">   result.row(0).setTo(cv::Scalar(0));</pre></div><p class="calibre8">The preceding statement assigns the value of <code class="email">0</code> to all pixels of the first line of the result image. In the case of a 3-channel color image, you would use <code class="email">cv::Scalar(a,b,c)</code> to specify the three values to be assigned to each channel of the pixel.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec48" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre8">When a computation is done over a pixel neighborhood, it is common to represent this with a kernel matrix. This kernel describes how the pixels involved in the computation are combined in order to obtain the desired result. For the sharpening filter used in this recipe, the kernel would be as follows:</p><div><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/></colgroup><tbody class="calibre16"><tr class="calibre17"><td valign="top" class="calibre18">
<p class="calibre19">0</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">-1</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">0</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre18">
<p class="calibre19">-1</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">5</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">-1</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre18">
<p class="calibre19">0</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">-1</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">0</p>
</td></tr></tbody></table></div><p class="calibre8">Unless stated otherwise, the current pixel corresponds to the center of the kernel. The value in each cell of the kernels represents a factor that multiplies the corresponding pixel. The result of the application of the kernel on a pixel is then given by the sum of all these multiplications. The size of the kernel corresponds to the size of the neighborhood (here, 3 x 3). Using this representation, it can be seen that, as required by the sharpening filter, the four horizontal and vertical neighbors of the current pixel are multiplied by -1, while the current one is multiplied by 5. Applying a kernel to an image is more than a convenient representation; it is the basis for the concept of convolution in signal processing. The kernel defines a filter that is applied to the image.</p><p class="calibre8">Since filtering is a common operation in image processing, OpenCV has defined a special function that performs this task: the <code class="email">cv::filter2D</code> function. To use this, you just need to define a kernel (in the form of a matrix). The function is then called with the image and the kernel, and it returns the filtered image. Using this function, it is therefore, easy to redefine our sharpening function as follows:</p><div><pre class="programlisting">void sharpen2D(const cv::Mat &amp;image, cv::Mat &amp;result) {

   // Construct kernel (all entries initialized to 0)
   cv::Mat kernel(3,3,CV_32F,cv::Scalar(0));
   // assigns kernel values
   kernel.at&lt;float&gt;(1,1)= 5.0;
   kernel.at&lt;float&gt;(0,1)= -1.0;
   kernel.at&lt;float&gt;(2,1)= -1.0;
   kernel.at&lt;float&gt;(1,0)= -1.0;
   kernel.at&lt;float&gt;(1,2)= -1.0;

   //filter the image
   cv::filter2D(image,result,image.depth(),kernel);
}</pre></div><p class="calibre8">This implementation <a id="id146" class="calibre1"/>produces exactly the same result as the previous one (and with the same efficiency). If <a id="id147" class="calibre1"/>you input a color image, then the same kernel will be applied to all three channels. Note that it is particularly advantageous to use the <code class="email">filter2D</code> function with a large kernel, as it uses, in this case, a more efficient algorithm.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec49" class="calibre1"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem"><a class="calibre1" title="Chapter 6. Filtering the Images" href="part0047_split_000.html#page">Chapter 6</a>, <em class="calibre9">Filtering the Images</em>, provides more explanations on the concept of image filtering</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec19" class="calibre1"/>Performing simple image arithmetic</h1></div></div></div><p class="calibre8">Images <a id="id148" class="calibre1"/>can be combined in different ways. Since they are regular matrices, they can be added, subtracted, multiplied, or divided. OpenCV offers various <a id="id149" class="calibre1"/>image arithmetic operators, and their use is discussed in this recipe.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec50" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Let's work with a second image that we will combine to our input image using an arithmetic operator. The following represents this second image:</p><div><img src="img/00016.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec51" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">Here, we add two images. This is useful when we want to create some special effects or to overlay<a id="id150" class="calibre1"/> information over an image. We do this by calling the <code class="email">cv::add</code> function, or more precisely here, the <code class="email">cv::addWeighted</code> function, since we want a weighted sum as follows:</p><div><pre class="programlisting">   cv::addWeighted(image1,0.7,image2,0.9,0.,result);</pre></div><p class="calibre8">The operation results in a new image, as seen in the following screenshot:</p><div><img src="img/00017.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec52" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">All binary arithmetic functions work the same way. Two inputs are provided and a third parameter specifies<a id="id151" class="calibre1"/> the output. In some cases, weights that are used as scalar multipliers in the operation can be specified. Each of these functions comes in several flavors; <code class="email">cv::add</code><a id="id152" class="calibre1"/> is a good example of a function that is available in many forms:</p><div><pre class="programlisting">   // c[i]= a[i]+b[i];
   cv::add(imageA,imageB,resultC); 
   // c[i]= a[i]+k;
   cv::add(imageA,cv::Scalar(k),resultC); 
   // c[i]= k1*a[1]+k2*b[i]+k3; 
   cv::addWeighted(imageA,k1,imageB,k2,k3,resultC);
   // c[i]= k*a[1]+b[i]; 
   cv::scaleAdd(imageA,k,imageB,resultC);</pre></div><p class="calibre8">For some functions, you can also specify a mask:</p><div><pre class="programlisting">   // if (mask[i]) c[i]= a[i]+b[i];
   cv::add(imageA,imageB,resultC,mask);</pre></div><p class="calibre8">If you apply a mask, the operation is performed only on pixels for which the mask value is not null (the mask must be 1-channel). Have a<a id="id153" class="calibre1"/> look at the different <a id="id154" class="calibre1"/>forms of <code class="email">cv::subtract</code>, <code class="email">cv::absdiff</code>, <code class="email">cv::multiply</code>, and <code class="email">cv::divide</code> <a id="id155" class="calibre1"/>functions. Bit-wise operators (operators applied to<a id="id156" class="calibre1"/> each<a id="id157" class="calibre1"/> individual <a id="id158" class="calibre1"/>bit of the pixels' binary representation) are also<a id="id159" class="calibre1"/> available: <code class="email">cv::bitwise_and</code>, <code class="email">cv::bitwise_or</code>, <code class="email">cv::bitwise_xor</code>, and <code class="email">cv::bitwise_not</code>. The <a id="id160" class="calibre1"/>
<code class="email">cv::min</code> and <code class="email">cv::max</code> operators, which <a id="id161" class="calibre1"/>find the per-element maximum <a id="id162" class="calibre1"/>or minimum pixel value, are also very useful.</p><p class="calibre8">In all <a id="id163" class="calibre1"/>cases, the<a id="id164" class="calibre1"/> <code class="email">cv::saturate_cast</code> function (see the preceding recipe) is always used to make sure that the results stay within the defined pixel value domain (that is, to avoid overflow or underflow).</p><p class="calibre8">The images must have the same size and type (the output image will be reallocated if it does not match the input size). Also, since the operation is performed per-element, one of the input images can be used as the output.</p><p class="calibre8">Several operators that take a single image as the input are also<a id="id165" class="calibre1"/> available: <code class="email">cv::sqrt</code>, <code class="email">cv::pow</code>, <code class="email">cv::abs</code>, <code class="email">cv::cuberoot</code>, <code class="email">cv::exp</code>, and <code class="email">cv::log</code>. In fact, there<a id="id166" class="calibre1"/> exists <a id="id167" class="calibre1"/>an OpenCV function for almost any <a id="id168" class="calibre1"/>operation<a id="id169" class="calibre1"/> you have<a id="id170" class="calibre1"/> to apply on image pixels.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec53" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre8">It is also possible to use the usual C++ arithmetic operator on the <code class="email">cv::Mat</code> instances or on the individual channels of <code class="email">cv::Mat</code> instances. The two following subsections explain how to do this.</p><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec14" class="calibre1"/>Overloaded image operators</h3></div></div></div><p class="calibre8">Very<a id="id171" class="calibre1"/> conveniently, most arithmetic functions have their corresponding operator overloaded in OpenCV 2. Consequently, the call to <code class="email">cv::addWeighted</code> can be written as follows:</p><div><pre class="programlisting">result= 0.7*image1+0.9*image2;</pre></div><p class="calibre8">The preceding code is a more compact form that is also easier to read. These two ways of writing the weighted sum are equivalent. In particular, the <a id="id172" class="calibre1"/>
<code class="email">cv::saturate_cast</code> function will still be called in both cases.</p><p class="calibre8">Most C++ operators have been overloaded. Among them are the bitwise operators <code class="email">&amp;</code>, <code class="email">|</code>, <code class="email">^</code>, and <code class="email">~</code>; the <code class="email">min</code>, <code class="email">max</code>, and <code class="email">abs</code> functions. The comparison operators <code class="email">&lt;</code>, <code class="email">&lt;=</code>, <code class="email">==</code>,<code class="email">!=</code>, <code class="email">&gt;</code>, and <code class="email">&gt;=</code> have also been overloaded, and they return an 8-bit binary image. You will also find the <code class="email">m1*m2</code> matrix multiplication (where <code class="email">m1</code> and <code class="email">m2</code> are both <code class="email">cv::Mat</code> instances), the <code class="email">m1.inv()</code> matrix inversion, the <code class="email">m1.t()</code> transpose, the <code class="email">m1.determinant()</code> determinant, the <code class="email">v1.norm()</code> vector norm, the <code class="email">v1.cross(v2)</code> cross-product, the <code class="email">v1.dot(v2)</code> dot product, and so on. When this makes sense, you also have the corresponding compound assignment operator defined (the <code class="email">+=</code> operator, as an example).</p><p class="calibre8">In the <em class="calibre9">Writing efficient image-scanning loops</em> recipe, we presented a color-reduction function that was written using loops that scan the image pixels to perform some arithmetic <a id="id173" class="calibre1"/>operations on them. From what we learned here, this function could be rewritten simply using arithmetic operators on the input image as follows:</p><div><pre class="programlisting">     image=(image&amp;cv::Scalar(mask,mask,mask))
                  +cv::Scalar(div/2,div/2,div/2);</pre></div><p class="calibre8">The use of <code class="email">cv::Scalar</code><a id="id174" class="calibre1"/> is due to the fact that we are manipulating a color image. Performing the same test as we did in the <em class="calibre9">Writing efficient image-scanning loops</em> recipe, we obtain an execution time of 53 ms. Using the image operators makes the code so simple, and the programmer so productive, that you should consider their use in most situations.</p></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec15" class="calibre1"/>Splitting the image channels</h3></div></div></div><p class="calibre8">You'll sometimes <a id="id175" class="calibre1"/>want to process the different channels of an image independently. For example, you might want to perform an operation only on one channel of the image. You can, of course, achieve this in an image-scanning loop. However, you can also use the <code class="email">cv::split</code> function that will copy the three channels of a color image into three distinct <code class="email">cv::Mat</code> instances. Suppose we want to add our rain image to the blue channel only. The following is how we would proceed:</p><div><pre class="programlisting">   // create vector of 3 images
   std::vector&lt;cv::Mat&gt; planes;
   // split 1 3-channel image into 3 1-channel images
   cv::split(image1,planes);
   // add to blue channel
   planes[0]+= image2;
   // merge the 3 1-channel images into 1 3-channel image
   cv::merge(planes,result);</pre></div><p class="calibre8">The <code class="email">cv::merge</code> function<a id="id176" class="calibre1"/> performs the inverse operation, that is, it creates a color image from three 1-channel images.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec20" class="calibre1"/>Remapping an image</h1></div></div></div><p class="calibre8">In the recipes <a id="id177" class="calibre1"/>of this chapter, you learned how to read and modify the<a id="id178" class="calibre1"/> pixel values of an image. The last recipe will teach you how to modify the appearance of an image by moving its pixels. The pixel values are not changed by this process; it is rather the position of each pixel that is remapped to a new location. This is useful in order to create special effects on an image or to correct image distortions caused, for example, by a lens.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec54" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">In order to use the OpenCV <code class="email">remap</code> function, you simply have to first define the map to be used in the remapping process. Second, you have to apply this map on an input image. Obviously, it is the way you define your map that will determine the effect that will be produced. In our example, we define a transformation function that will create a wavy effect on the image:</p><div><pre class="programlisting">// remapping an image by creating wave effects
void wave(const cv::Mat &amp;image, cv::Mat &amp;result) {

  // the map functions
  cv::Mat srcX(image.rows,image.cols,CV_32F);
  cv::Mat srcY(image.rows,image.cols,CV_32F);

  // creating the mapping
  for (int i=0; i&lt;image.rows; i++) {
    for (int j=0; j&lt;image.cols; j++) {

      // new location of pixel at (i,j)
      srcX.at&lt;float&gt;(i,j)= j; // remain on same column
                // pixels originally on row i are now
                // moved following a sinusoid
      srcY.at&lt;float&gt;(i,j)= i+5*sin(j/10.0);
    }
  }

  // applying the mapping
  cv::remap(image, result, srcX, srcY, cv::INTER_LINEAR);
}</pre></div><p class="calibre8">The result is as follows:</p><div><img src="img/00018.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec55" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">The objective <a id="id179" class="calibre1"/>of remapping is to produce a new version of an image in which <a id="id180" class="calibre1"/>pixels have changed in position. To construct this new image, we need to know what the original position for each pixel in the destination image in the source image is. The mapping function that is needed is therefore the one that will give us the original pixel positions as a function of the new pixel positions. This is called <strong class="calibre2">backward</strong> <strong class="calibre2">mapping</strong><a id="id181" class="calibre1"/> because the transformation describes how the pixels of the new images are mapped back to the original image. In OpenCV, backward mapping is described using two maps: one for the x-coordinates and one for the y-coordinates. They are both represented by floating point <code class="email">cv::Mat</code> instances:</p><div><pre class="programlisting">  // the map functions
  cv::Mat srcX(image.rows,image.cols,CV_32F); // x-map
  cv::Mat srcY(image.rows,image.cols,CV_32F); // y-map</pre></div><p class="calibre8">The size of these matrices will define the size of the destination image. The value of the <code class="email">(i,j)</code> pixel of the destination image can then be read in the source image using the following line of code:</p><div><pre class="programlisting">  ( srcX.at&lt;float&gt;(i,j) , srcY.at&lt;float&gt;(i,j) )</pre></div><p class="calibre8">For example, a simple image flip effect like the one we demonstrated in <a class="calibre1" title="Chapter 1. Playing with Images" href="part0014_split_000.html#page">Chapter 1</a>, <em class="calibre9">Playing with Images</em>, can be created by the following maps:</p><div><pre class="programlisting">  // creating the mapping
  for (int i=0; i&lt;image.rows; i++) {
    for (int j=0; j&lt;image.cols; j++) {

      // horizontal flipping
      srcX.at&lt;float&gt;(i,j)= image.cols-j-1;
      srcY.at&lt;float&gt;(i,j)= i;
    }
  }</pre></div><p class="calibre8">To generate <a id="id182" class="calibre1"/>the resulting image, you simply call the OpenCV <code class="email">remap</code> function:</p><div><pre class="programlisting">  // applying the mapping
  cv::remap(image,             // source image
            result,            // destination image
            srcX,              // x map
            srcY,              // y map
            cv::INTER_LINEAR); // interpolation method</pre></div><p class="calibre8">It is interesting<a id="id183" class="calibre1"/> to note that the two maps contain floating-point values. Consequently, a pixel in the destination can map back to a non-integral value (that is, a location between pixels). This is very convenient because this allows us to define the mapping function of our choice. For instance, in our remapping example, we used a <code class="email">sinusoidal</code> function to define our transformation. However, this also means that we have to interpolate the value of virtual pixels in between real pixels. There exist different ways of performing pixel interpolation, and the last parameter of the <code class="email">remap</code> function allows us to select the method that will be used. Pixel interpolation is an important concept in image processing; this subject will be discussed in <a class="calibre1" title="Chapter 6. Filtering the Images" href="part0047_split_000.html#page">Chapter 6</a>, <em class="calibre9">Filtering the Images</em>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec56" class="calibre1"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em class="calibre9">There's more...</em> section of the <em class="calibre9">Filtering images using low-pass filters</em> recipe of <a class="calibre1" title="Chapter 6. Filtering the Images" href="part0047_split_000.html#page">Chapter 6</a>, <em class="calibre9">Filtering the Images</em>, explains the concept of pixel interpolation</li><li class="listitem">The <em class="calibre9">Calibrating a camera</em> recipe of <a class="calibre1" title="Chapter 10. Estimating Projective Relations in Images" href="part0067_split_000.html#page">Chapter 10</a>, <em class="calibre9">Estimating Projective Relations in Images</em>, uses remapping to correct lens distortions in an image</li><li class="listitem">The <em class="calibre9">Computing a homography between two images</em> recipe of <a class="calibre1" title="Chapter 10. Estimating Projective Relations in Images" href="part0067_split_000.html#page">Chapter 10</a>, <em class="calibre9">Estimating Projective Relations in Images</em>, uses perspective image warping to build an image panorama</li></ul></div></div></div></body></html>