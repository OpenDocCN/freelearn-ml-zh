<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Macros and Metaprogramming Techniques</h1>
                </header>
            
            <article>
                
<p>This chapter will discuss two of the most powerful facilities in the Julia programming language: macros and metaprogramming.</p>
<p>In a nutshell, metaprogramming is a technique for writing code that generates code—that's why it has the prefix <em>meta</em>. It may sound esoteric, but it is a fairly common practice in many programming languages today. For example, C compiler uses a preprocessor to read source code and produce new source code, and then the new source code is compiled into a binary executable. For example<span>, you can define a <kbd>MAX</kbd> macro, as in </span><kbd>#define MAX(a,b) ((a) &gt; (b) ? (a) : (b))</kbd><span>, and this means that every time we use </span><kbd>MAX(a,b)</kbd><span>, it is replaced with </span><span><kbd>((a) &gt; (b) ? (a) : (b))</kbd>. Note that <kbd>MAX(a,b)</kbd> is much easier to read than the longer form.</span></p>
<p><span>The history of metaprogramming is quite long. As far back as the 1970s, it was already popular among the LISP programming language community. Interestingly, the LISP language is designed in such a way that the source code is structured like data—for example, a function call in LISP looks like <kbd>(sumprod x y z)</kbd></span><span>, where the first element is the name of the function and the rest are arguments. Since it is really just a list of four symbols—<kbd>sumprod</kbd>, <kbd>x</kbd>, <kbd>y</kbd>, and <kbd>z</kbd></span>—<span>we can take this code and manipulate it in any way—for example, we can expand it so it calculates both the sum and product of the numbers, so the generated code becomes <kbd>(list (+ x y z) (* x y z))</kbd>. </span></p>
<p>You may wonder whether we can just write a function for that. The answer is, yes: in both of the examples that we just looked at, there is no need to use a metaprogramming technique. The examples were there only to illustrate how metaprogramming works. In general, we can say that metaprogramming is not needed 99% of the time; however, there is still that remaining 1% of cases where metaprogramming would be very useful. The first section will explore use cases where we would want to use metaprogramming.</p>
<p><span>In this chapter, we will learn several metaprogramming facilities in Julia. </span><span>The following topics will be covered in particular:</span></p>
<ul>
<li>Understanding the need for metaprogramming</li>
<li>Working with expressions</li>
<li>Developing macros</li>
<li>Using generated functions</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The sample source code is located at <a href="https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter04">https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter04</a>.<a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-Julia-1.0/tree/master/Chapter04"/></p>
<p>The code is tested in a Julia 1.3.0 environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the need for metaprogramming</h1>
                </header>
            
            <article>
                
<p>At the beginning of the chapter, we boldly claimed that metaprogramming is not needed 99% of the time. That is indeed not a made-up number. At the JuliaCon 2019 conference, Professor Steven Johnson from MIT delivered a keynote speech regarding metaprogramming. He did some research about the Julia language's own source code. From his study, Julia version 1.1.0 contains 37,000 methods, 138 macros (0.4%), and 14 generated functions (0.04%). So metaprogramming code comprises less than 1% of Julia's own implementation. While this is just one example of metaprogramming's role in one language, it is representative enough that even the smartest software engineers would not use metaprogramming most of the time.</p>
<p>So the next question is: When do you need to use metaprogramming techniques? Generally speaking, there are several reasons for using such techniques:</p>
<ol>
<li>They may allow a solution to be expressed more concisely and in a way that is easier to understand. Writing code without metaprogramming would otherwise look ugly and be difficult to comprehend.</li>
<li>It may reduce the development time because the source code can be generated rather than written out; boilerplate code, especially, can be eliminated.</li>
<li><span>It may improve performance because the code is spelled out rather than executed via other higher-level programming constructs, such as looping.</span></li>
</ol>
<p>We will now look at some examples of how metaprogramming is used in the real world.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Measuring performance with the @time macro</h1>
                </header>
            
            <article>
                
<p>Julia comes with a useful macro called <kbd>@time</kbd>, which measures the time required to execute code. For example, to measure how long it takes to calculate the sum of 10 million random numbers, we can do the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/79626f6a-ec00-4d63-8032-f414bbcc0024.png" style="width:30.17em;height:3.17em;"/></p>
<p>The macro works by inserting code around the code that is being measured. The resulting code may look something like the following:</p>
<pre>begin<br/>    t1 = now()<br/>    result = sum(rand(10_000_000))<br/>    t2 = now()<br/>    elapsed = t2 - t1<br/>    println("It took ", elapsed)<br/>    result<br/>end</pre>
<p>The new code uses the <kbd>now()</kbd> function to take the current time. Then, it executes the user-provided code and captures the result. It takes the current time again, calculates the elapsed time, prints the timing information to the console, and then it returns the result.</p>
<p>Can this be done without metaprogramming? Perhaps we can give that a try. Let's define a function called <kbd>timeit</kbd> as follows:</p>
<pre>function timeit(func)<br/>    t1 = now()<br/>    result = func()<br/>    t2 = now()<br/>    elapsed = t2 - t1<br/>    println("It took ", elapsed)<br/>    result<br/>end</pre>
<p>To use this timing facility, we need to wrap the expression in a function.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d8f1db6b-774b-4099-8398-baaa18c3f2a8.png" style="width:21.67em;height:7.42em;"/></p>
<p>This function works fairly well, but the problem is that we have to wrap the code in a separate function before we can measure its performance, which is a hugely inconvenient thing to do. Because of this, we can conclude that having a <kbd>@time</kbd> macro is more appropriate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unrolling loops</h1>
                </header>
            
            <article>
                
<p>Another use case of macros is to unroll loops into repeating code fragments. Loop unrolling is a performance optimization technique. The premise behind it is that there is always some overhead that is required to execute code in a loop. The reason is that, every time an iteration is finished, the loop must check for a condition and decide whether it should exit or continue with the next iteration. Now, if we know exactly how many times the loop needs to run the code, then we can <em>unroll</em> it by writing out the code in a repeated fashion.</p>
<p>Consider a simple loop<span> as follows</span>:</p>
<pre>for i in 1:3<br/>    println("hello: ", i)<br/>end</pre>
<p>We can unroll the loop into three lines of code that do the exact same job:</p>
<pre>println("hello: ", 1)<br/>println("hello: ", 2)<br/>println("hello: ", 3)</pre>
<p>But it would be quite a boring and mundane task to have to unroll loops manually. Furthermore, the amount of work grows linearly with the number of iterations required in the loop. With the help of <kbd>Unroll.jl</kbd>, we can define a function using the <kbd>@unroll</kbd> macro, as follows:</p>
<pre>using Unrolled<br/><br/>@unroll function hello(xs)<br/>    @unroll for i in xs<br/>        println("hello: ", i)<br/>    end<br/>end</pre>
<p>The code looks as clean as it should be, and the <kbd>@unroll</kbd> macro is inserted in front of the function as well as the <kbd>for</kbd> loop. First, we should check that the code works properly:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6616ec0d-2ed2-4231-8acc-b7b32bd53a40.png" style="width:14.58em;height:8.50em;"/></p>
<p>Now, we should question whether the <kbd>@unroll</kbd> macro actually did anything. A good way to check whether the loop was unrolled is to use the <kbd>@code_lowered</kbd> macro: </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e54b3954-bdea-413c-9fe4-16a48708327d.png" style="width:39.83em;height:24.17em;"/></p>
<p>The lowered code clearly contains three <kbd>println</kbd> statements rather than a single <kbd>for</kbd> loop.</p>
<div class="packt_infobox">What is lowered code? The Julia compiler must go through a series of processes before source code is compiled to binaries. The very first step is to parse the code into an <strong>abstract syntax tree</strong> <span>(</span><strong>AST</strong><span>) </span>format, which we will learn about in the next session. After that, it goes through a <em>lowering</em> process to expand the macros and convert the code into concrete execution steps.</div>
<p>Now that we have seen some examples and know the power of metaprogramming, we shall move forward and learn how to create these macros ourselves.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with expressions</h1>
                </header>
            
            <article>
                
<p class="mce-root">Julia represents the source code of any runnable program as a tree structure. This is called an <strong>abstract syntax tree</strong> (<strong>AST</strong>). It is referred to as <em>abstract</em> as the tree only captures the structure of the code rather than the real syntax. </p>
<p class="mce-root">For example, the expression <kbd>x + y</kbd> can be represented with a tree where the parent node identifies itself as a function call and the child nodes include the operator function <kbd>+</kbd> and the <kbd>x</kbd> and <kbd>y</kbd> <span>arguments.</span> The following is an implementation of this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/63989de7-d8b6-4b30-9fde-8c4e264f696c.png" style="width:14.83em;height:9.50em;"/></p>
<p>The slightly more complex expression <kbd>x + 2y + 1</kbd> would look like the following diagram. While it was written with two addition operators, the expression is parsed into a single function call to the <kbd>+</kbd> function, for which it takes three arguments—<kbd>x</kbd>, <kbd>2y</kbd>, and <kbd>1</kbd>. Because <kbd>2y</kbd> is itself an expression, it can be seen as a subtree of the main abstract syntax tree:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a8f1f88d-4ee8-498b-a969-4c8e4bf5330e.png" style="width:19.75em;height:13.92em;"/></p>
<p class="mce-root">The Julia compiler must first parse source code into an abstract syntax tree, and then it can perform additional transformations and analysis, such as expanding macros, type checking, type inference, and eventually translating the code into machine code. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Experimenting with the parser</h1>
                </header>
            
            <article>
                
<p><span>Because the abstract syntax tree is just a data structure, we can examine it directly within the Julia REPL environment. </span>Let's just start with a simple expression: <kbd>x + y</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8186f498-fee4-46b5-93c4-b870de13cd62.png" style="width:12.25em;height:2.42em;"/></p>
<p><span>In Julia, every expression is represented as an </span><kbd>Expr</kbd><span> object. We can create an </span><kbd>Expr</kbd><span> object by just parsing a string with the </span><kbd>Meta.parse</kbd><span> function.</span></p>
<p>Here, the expression object is displayed with a syntax that resembles the original source code so that it is easier to read. We can confirm that the object has the type of <kbd>Expr</kbd> as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2f61ebe7-8d7c-4ab5-8a0d-f27bb6e5e280.png" style="width:20.17em;height:2.75em;"/></p>
<p>In order to view the abstract syntax tree, we can use the <kbd>dump</kbd> function to print the structure:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cbfb4302-ee10-46ec-baaf-64cbdd3b0141.png" style="width:18.17em;height:8.33em;"/></p>
<p>In Julia, every expression is represented by a head node and an array of arguments.</p>
<p>In this case, the head node contains just a <kbd>call</kbd> symbol. The <kbd>args</kbd> array contains the <kbd>+</kbd> operator and two variables, <kbd>x</kbd> and <kbd>y</kbd>. Note that everything here is a symbol—that's OK because we are examining the source code itself, which is understandably just a tree of symbols.</p>
<p>Since we have had so much fun here, let's try a few other expressions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single-variable expressions</h1>
                </header>
            
            <article>
                
<p>One of the simplest expressions is just a reference to a variable. You<span> can try to parse a numeric or string literal and see what it returns:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1943fdfd-f8d9-4f34-9e8c-af4e356514f2.png" style="width:17.42em;height:3.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Function calls with keyword arguments</h1>
                </header>
            
            <article>
                
<p><span>Let's try something a little more complex. We will examine a function call that takes a single positional argument and two keyword arguments. Here, we use triple quotes around the code so that we can handle the double quotes inside it properly:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0e81cd68-ad62-44e1-a766-8823d216d42f.png" style="width:33.83em;height:17.58em;"/></p>
<p><span>Note that a function call has the <kbd>call</kbd> symbol as the head node of the expression. Also, the keyword arguments are represented as subexpressions, each with a head node of </span><kbd>kw</kbd><span> and a two-element array for the name and value of the argument.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nested functions</h1>
                </header>
            
            <article>
                
<p>We may wonder how Julia parses code when functions are nested. We can pick a simple example here that takes the sine of <kbd>x+1</kbd> and then takes the cosine of the result. The abstract syntax tree is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3bf61837-89ac-4f12-9b51-05f080dd5def.png" style="width:23.08em;height:17.17em;"/></p>
<p>Here, we can clearly see the tree structure. The outermost function, <kbd>cos</kbd>, contains a single argument, which is an expression node with a call to the <kbd>sin</kbd> function. This expression in turn contains a single argument, which is another expression node with a call to the <kbd>+</kbd> operator function with two arguments—the <kbd>x</kbd> variable and a value of <kbd>1</kbd>. Now, let's continue with our work on expressions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constructing expression objects manually</h1>
                </header>
            
            <article>
                
<p>As an expression is just a data structure, we can easily construct them programmatically. Understanding how to do this is essential for metaprogramming, which involves creating new code structures on the fly.</p>
<p>The <kbd>Expr</kbd> constructor has the following signature:</p>
<pre>Expr(head::Symbol, args...)</pre>
<p>The head node always carries a symbol. The arguments just contain whatever the head node expects—for example, the simple expression <kbd>x + y</kbd> can be created as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5f5bb0a3-13ab-4c7c-ba4e-233f519f08f2.png" style="width:17.50em;height:3.33em;"/></p>
<p>Of course, we can always create a nested expression if we want to:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0938942b-66a5-4fb1-a623-f01b023c2e55.png" style="width:26.75em;height:3.00em;"/></p>
<p>At this point, you may wonder whether there is an easier way to create expressions without having to construct <kbd>Expr</kbd> objects manually.  For sure, it can be done as shown below:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c2579b8b-162f-4294-8eab-9b4540a7ab02.png" style="width:14.17em;height:13.08em;"/></p>
<p>Basically, we can wrap any expression with <kbd>:(</kbd> on the left and <kbd>)</kbd> on the right. The code that sits inside will not be evaluated, but will instead be parsed into an expression object; however, this way of quoting only works with a single expression—if you try to do this with multiple expressions, an error will be displayed, as shown in the following code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f7d55f45-9cd4-4003-bc18-c9f59b614cf5.png" style="width:23.75em;height:3.42em;"/></p>
<p>It does not work because multiple expressions should be wrapped with <kbd>begin</kbd> and <kbd>end</kbd> keywords. So it would be fine if we entered the following code block:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0a4102ef-4edd-4e15-b44b-c2fd311d2446.png" style="width:11.67em;height:12.42em;"/></p>
<p>The result is a little interesting. As you can see, the code is now wrapped within a <kbd>quote/end</kbd> block rather than a <kbd>begin/end</kbd> block. It actually makes sense because a quoted expression is being displayed rather than the original source code. Remember, this is the abstract syntax tree rather than the original code.</p>
<p>It also turns out that <kbd>quote/end</kbd> can be used directly to create expressions:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b85ff5b5-02db-46bc-a44a-985c8dd178a5.png" style="width:10.58em;height:11.42em;"/></p>
<p><span><span>We have now learned how to parse source code into an expression object. Next, we will look into more complex expressions so that we are more familiar with the basic code structure of Julia programs.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Playing with more complex expressions</h1>
                </header>
            
            <article>
                
<p>As we said before, any valid Julia program can be represented as an abstract syntax tree. Now that we have the building blocks to create expression objects, let's examine a few more constructs and see what expression objects look like for more complex programs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Assignment</h1>
                </header>
            
            <article>
                
<p>We will see how it works for assignments first. Consider the following code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8c32beb4-b5b1-49e3-a440-ba7fc4608b27.png" style="width:16.67em;height:14.33em;"/></p>
<p>From the preceding code, we can see that the variable assignment has a head node of <kbd>=</kbd> and two arguments—the variable to be assigned (<kbd>x</kbd>, in this case) and another expression object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code blocks</h1>
                </header>
            
            <article>
                
<p>A code block is enclosed by the <kbd>begin</kbd> and <kbd>end</kbd> keywords. Let's examine what the abstract syntax tree looks like.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/925b6634-edb5-4819-a66a-af1bdd69944c.png" style="width:31.58em;height:26.25em;"/></p>
<p>The head node just contains a <kbd>block</kbd> symbol. When there are multiple lines in the block, the abstract syntax tree also includes line number nodes. In this example, there is a <kbd>LineNumberNode</kbd> with line 2 preceding the first call to <kbd>println</kbd>. Likewise, there is another <kbd>LineNumberNode</kbd> with line 3 preceding the second call to <kbd>println</kbd>. The <kbd>LineNumberNode</kbd> nodes do not do anything, but they are useful for stack traces and debugging.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Conditional</h1>
                </header>
            
            <article>
                
<p>Next up, we'll explore conditional constructs, such as <kbd>if-else-end</kbd>. Refer to the following code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3d2b3253-89b5-45d3-91bf-2e2346c730fd.png" style="width:23.25em;height:32.75em;"/></p>
<p>The head node contains the <kbd>if</kbd> symbol. There are three arguments—an expression for the condition, a block expression when the condition is satisfied, and another block expression when the condition is not satisfied.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loop</h1>
                </header>
            
            <article>
                
<p>We will now move on to looping constructs. Consider a simple <kbd>for</kbd> loop, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2130fa5b-520d-47a8-b2b9-7b1235351fc7.png" style="width:34.67em;height:34.25em;"/></p>
<p>The head node contains a <kbd>for</kbd> symbol. There are two arguments: the first one contains the expression about the loop and the second one contains a block expression. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Function definition</h1>
                </header>
            
            <article>
                
<p>Next, we will see the structure for a function definition. Consider the following code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/414fcd55-6739-42d1-9f8c-a73f24b18e03.png" style="width:27.17em;height:37.75em;"/></p>
<p>The head node contains a <kbd>function</kbd> symbol. Then, the first argument contains a <kbd>call</kbd> expression with the arguments. The second argument is just a block expression. </p>
<div class="packt_infobox">The call expression <span>may seem a little odd because we have seen a similar expression object when a function is being called. This is normal because we are currently working at the syntax level. The syntax for function definition is indeed quite similar to the function call itself.</span></div>
<p><span>By now, w</span><span>e have seen enough examples. There are obviously many more code constructs that we have not explored. You are encouraged to use the same technique to examine other code structures. Understanding how the abstract syntax tree is structured is essential to writing good metaprogramming code. Next, we will see how we can evaluate these expressions.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Evaluating expressions</h1>
                </header>
            
            <article>
                
<p>We have looked at creating expression objects in great detail. But how are they useful? Remember that an expression object is just an abstract syntax tree representation of a Julia program. At this point, we can ask the compiler to continue translating the expression into executable code and then run the program. </p>
<p>Expression objects can be evaluated by calling the <kbd>eval</kbd> function. Essentially, the Julia compiler will go through the rest of the compilation process and run the program. Now, let's start a fresh, new REPL and run the following code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/17f873d7-2181-40ed-8f15-3561552c254c.png" style="width:11.42em;height:2.75em;"/></p>
<p>Clearly, it's just a simple assignment. We can see that the <kbd>x</kbd> <span>variable</span><span> </span><span>is now defined in the current environment:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2f939154-52d6-4c29-9ac6-2aa74aa1b8ab.png" style="width:4.33em;height:2.42em;"/></p>
<p>Note that the evaluation of the expression actually happens in the global scope. We can prove this by running <kbd>eval</kbd> from within a function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9c9b4f79-5bb2-49fb-95b0-ce8203eca8ca.png" style="width:17.75em;height:10.75em;"/></p>
<p>This is not an unimportant observation! At first glance, we may have expected the <kbd>y</kbd> <span>variable</span><span> </span><span>to be assigned inside the</span> <kbd>foo</kbd> <span>function;</span><span> however, the variable assignment happened in the global scope instead, so the</span> <kbd>y </kbd><span>variable</span><span> </span><span>was defined in the current environment as a side-effect.</span></p>
<div class="packt_infobox">More precisely, the expression is evaluated in the current module. Since we are testing in the REPL, the evaluation was done in the current module, called <kbd>Main</kbd>. The expression is designed as such because <kbd>eval</kbd> is commonly used for code generation, which can be useful in defining variables or functions within the module.</div>
<p>Next, we will learn how to create expression objects more easily.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interpolating variables in expressions</h1>
                </header>
            
            <article>
                
<p>It is quite simple to construct expressions from a quote block. But what if we want to dynamically create expressions? This can be done using <em>interpolation</em>, which allows us to insert variable values into the expression object with an easy syntax. Interpolation in an expression is very similar to the way that variables can be interpolated in a string. The following screenshot shows an example:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a7ee7ac3-b5bb-4833-bb32-5c414bc69998.png" style="width:9.25em;height:6.00em;"/></p>
<p>As expected, the value of <kbd>2</kbd> is correctly substituted in the expression. Note that <kbd>splatting</kbd> is also supported, as shown below:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/75b2ee1c-6976-4c3b-adb1-22cb55363682.png" style="width:14.08em;height:15.75em;"/></p>
<p>We must make sure that the variable that includes the <kbd>splatting</kbd> operator is interpolated in this case. If we had forgotten to put the parentheses around <kbd>v...</kbd>, then we would have had a very different result:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9255e775-c7f4-4b94-87a4-984720944cd3.png" style="width:12.08em;height:8.92em;"/></p>
<p>Here, splatting does not actually occur during interpolation into the expression. Instead, the splatting operator now becomes part of the expression, so splatting will not occur until the expression is evaluated. </p>
<div class="packt_tip">The order of precedence in an expression such as <kbd>$v...</kbd> is somewhat unclear. Is the <kbd>v</kbd> variable <span>bound to the interpolation operation before or after the splatting operation? </span>In a situation like this, it is best to use parentheses around whatever we want to interpolate. As we want the interpolation to happen fully, the syntax should be <kbd>$(v...)</kbd>. In situations where splatting needs to happen at runtime, we could write <kbd>$(v)...</kbd> instead.</div>
<p>Interpolation is an important concept for writing macros. We will see more of its usage later in this chapter. Next, we will see how to handle construct expressions with symbol values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using QuoteNode for symbols</h1>
                </header>
            
            <article>
                
<p>Symbols are quite special when they appear in expressions. They may appear in the head node of an expression object—for example, the <kbd>=</kbd> symbol in a variable assignment expression. They may also appear in the arguments of an expression object, in which case they would represent a variable:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1c7ec2aa-3be8-4c3f-ac06-4e424e1c7886.png" style="width:13.00em;height:7.75em;"/></p>
<p>Since symbols are already used to represent variables, how would we assign an actual symbol to a variable? To figure out how this works, we can use the same trick that we have learned so far—using the <kbd>dump</kbd> function to examine the expression object for such a statement:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a6c583b4-4c64-4073-98fa-4fe8ceba0885.png" style="width:18.17em;height:9.92em;"/></p>
<p>As we can see, an actual symbol must be enclosed in a <kbd>QuoteNode</kbd> object. Now that we know what is needed, we should try to interpolate an actual symbol into an expression object. The way to achieve this is to create a <kbd>QuoteNode</kbd> object manually and use the interpolation technique as usual:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/275de7a3-11a7-409e-abc3-af1a49d9f12d.png" style="width:18.50em;height:7.00em;"/></p>
<p>A common mistake is when you forget to create <kbd>QuoteNode</kbd>. In this case, the expression object will misinterpret the symbol and treat it as a variable reference. Obviously, the result is very different, and it will not work properly:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0512ee43-2e07-4147-8a89-43eaec212d3f.png" style="width:12.33em;height:6.67em;"/></p>
<p>Not using <kbd>QuoteNode</kbd> would generate code that assigns the value of one variable to another. In this case, the variable <kbd>x</kbd> will be assigned with a value from variable <kbd>hello</kbd>.</p>
<p>Understanding how <kbd>QuoteNode</kbd> works is essential creating expressions on the fly. It is common for programmers to interpolate symbols into an existing expression. So next, we will look at how to work with nested expressions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interpolating in nested expressions</h1>
                </header>
            
            <article>
                
<p>It is possible to have a quoted expression that contains another quoted expression. This is not a very common practice, unless the programmer needs to write meta-metaprograms. Nonetheless, we should still learn about how to interpolate in such a situation.</p>
<p>First, let's recap what a single-level expression looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b444be5d-ede6-48ae-b0c6-4812746ec43a.png" style="width:15.08em;height:12.92em;"/></p>
<p>We can wrap the quoted expression with another quote block in order to see what the structure of a nested expression looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/66fd29be-2aae-47aa-b9cb-66c5b7922161.png" style="width:16.33em;height:10.83em;"/></p>
<p>Now, let's try to interpolate in such an expression:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/66f6f2ba-72a7-42cd-81cc-55044b3cb6c1.png" style="width:18.00em;height:18.58em;"/></p>
<p>As we can see, the <kbd>2</kbd> <span>value</span><span> </span><span>did not get into the expression. The expression structure is also entirely different from what we had expected. </span><span>The solution is to just interpolate the variable twice instead by using two</span> <kbd>$</kbd> <span>signs: </span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a5e4a9dc-2791-420c-add4-66a44d7b29cb.png" style="width:25.67em;height:3.50em;"/></p>
<p>In general, it is probably not much fun to interpolate more than one-level deep as the logic becomes difficult to work out. It can be useful, however, if you need to generate code for macros. I would definitely not suggest that you go more than two-levels deep and write meta-meta-metaprograms!</p>
<p>By now, you should be more familiar with, and comfortable working with, expressions. From the Julia REPL, it is quite easy to see how an expression is structured as represented as an <kbd>Expr</kbd> object. You should be able to construct new expressions and interpolate values inside; these are essential skills that will be required for metaprogramming.</p>
<p>In the next section, we will look into a powerful metaprogramming feature in Julia—macros.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing macros</h1>
                </header>
            
            <article>
                
<p>Now that we understand how source code is represented as abstract syntax trees, we can start doing more interesting things by writing macros. In this section, we will learn what macros are and how to work with them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What are macros?</h1>
                </header>
            
            <article>
                
<p>Macros<span> are functions that accept expressions, manipulate them, and return a new expression. This is best understood with a diagram:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f4271853-2e8b-4a47-bd13-28ecf8126b60.png" style="width:31.50em;height:15.92em;"/></p>
<p>As we know, expressions are just abstract syntax tree representations of source code. So the macro facility in Julia allows you to take any source code and generate new source code. The resulting expression is then executed as if the source code was written directly in place.</p>
<p>At this point, you may wonder why we cannot use regular functions to achieve the same thing. Why could we not write a function that takes expressions, generates a new expression, and then executes the resulting expression?</p>
<p>There are two main reasons:</p>
<ul>
<li>Macro expansion happens during compilation. This means that the macro is only executed once from where it is used—for example, when a macro is called from a function, the macro is executed at the time that the function is defined so that the function can be compiled.</li>
<li>The resulting expression from a macro can be executed within the current scope. At runtime, there is no other way to execute any dynamic code within the function itself because the function, by definition, is already compiled. So, the only way to evaluate any expression is to do so in the global scope.</li>
</ul>
<p>By the end of this chapter, you should have a better understanding of how macros work and how they differ from functions.</p>
<p>As we now understand what macros are, we will now continue our journey by writing our first macro.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing our first macro</h1>
                </header>
            
            <article>
                
<p>Macros are defined in a similar way to how functions are defined, except that the <kbd>macro</kbd> keyword is used instead of the <kbd>function</kbd> keyword.</p>
<p>We should also keep in mind that a macro must return expressions. Let's create our first macro. This macro returns an expression object that contains a <kbd>for</kbd> loop, as follows:</p>
<pre>macro hello()<br/>    return :(<br/>    for i in 1:3<br/>        println("hello world")<br/>    end<br/>    )<br/>end</pre>
<p>Invoking the macro is as easy as calling it with the <kbd>@</kbd> prefix. Refer to the following code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6b105cfd-4a31-4b85-b470-e9881e4bcb9f.png" style="width:9.58em;height:5.75em;"/></p>
<p>Unlike functions, macros may be called without using parentheses. So we can just do the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/43c8a997-9b9a-4fbc-90f8-d1ed60c47f33.png" style="width:31.58em;height:4.92em;"/></p>
<p><em>Fantastic!</em> We have now written our first macro. While it does not look very exciting, because the code being generated is just a static piece of code, we have learned how to define macros and run them.</p>
<p>Next, we will learn how to pass arguments to macros.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing literal arguments</h1>
                </header>
            
            <article>
                
<p>Just like functions, macros can also take arguments. In fact, taking an argument is the most common occurrence for a macro. The simplest type of argument is literals, such as numbers, symbols, and strings.</p>
<p>In order to utilize these arguments in the returned expression, we can use the interpolation technique that we learned in the last section. Consider the following code:</p>
<pre>macro hello(n)<br/>    return :(<br/>    for i in 1:$n<br/>        println("hello world")<br/>    end<br/>    )<br/>end</pre>
<p>The <kbd>hello</kbd> macro takes a single argument, <kbd>n</kbd>, which is interpolated into the expression when the macro is run. As before, we can just invoke the macro as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e76e0851-af2d-4280-8c53-ee71cb64a788.png" style="width:10.17em;height:4.25em;"/></p>
<p>As we learned earlier, parentheses are not required, so we can also call the macro<span> as follows</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/39aae576-f8b8-446e-ba2d-4a4729444b62.png" style="width:9.08em;height:4.17em;"/></p>
<p>You can try a similar exercise with string or symbol arguments. Passing literals is easy to understand because it works in the same way as functions. But there is indeed a subtle difference between macros and functions, which we will discuss in detail in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing expression arguments</h1>
                </header>
            
            <article>
                
<p>It is important to emphasize that macro arguments are passed as expressions rather than values. It may look confusing for beginners because macros are invoked similarly to functions, but the behavior is completely different. </p>
<p>Let's make sure that we fully understand what this means. When calling a function with a variable, the value of the variable is passed into the function. Consider the following sample code for a <kbd>showme</kbd> function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f84cffba-eb41-4aaa-a648-3f09ece404b1.png" style="width:22.08em;height:18.58em;"/></p>
<p>Now, let's create a <kbd>@showme</kbd> macro that does nothing but display the argument in the console. We can then compare the results with the preceding code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a7cf9700-6cee-4fda-8a7c-7b0964b53d18.png" style="width:17.50em;height:17.00em;"/></p>
<p>As we can see, the results from running a macro are totally different than those we get from calling a function. The function argument <kbd>x</kbd> really only sees an expression from where the macro was called. From the diagram at the beginning of this section, we can see that macros are supposed to take in expressions and return a single expression as a result. They do not know the value of the arguments as they work at the syntax level. </p>
<p>As we will see in the next section, expressions can even be manipulated when the macro is run. Let's go!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the macro expansion process</h1>
                </header>
            
            <article>
                
<p>By convention, every macro must return an expression. The process of taking one or more expressions and returning a new one is called <strong>macro expansion</strong>. Sometimes, it helps to see the expression being returned without actually running the code. We can use the <kbd>@macroexpand</kbd> macro for that purpose. Let's try to use it for the <kbd>@hello</kbd> macro that we defined earlier in this section:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/289780c8-b7d0-4570-924a-9099604360f9.png" style="width:20.33em;height:7.08em;"/></p>
<p>There are several things to note from this output:</p>
<ul>
<li>The <kbd>i</kbd> variable was renamed rather oddly: <kbd>#67#i</kbd>. This is done by the Julia compiler to ensure <em>hygiene</em>, which we will discuss later in this chapter. Macro hygiene is an important characteristic to keep in mind so that the code being generated does not conflict with other code.</li>
<li>A comment was inserted into the loop that contains source file and line number information. This is a useful part of the expression when a debugger is used.</li>
<li>The function call to <kbd>println</kbd> is bound to the one in the current environment, <kbd>Main</kbd>. This make sense because <kbd>println</kbd> is part of the <kbd>Core</kbd> package and is automatically brought into scope for every Julia program.</li>
</ul>
<p>So when does macro expansion happen? Let's go over that next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Timing of macro expansion</h1>
                </header>
            
            <article>
                
<p>In the REPL, any macro is expanded as soon as we invoke it. <span>Interestingly, when a function containing the macro is defined, the macro is expanded as part of the function definition process.</span></p>
<p>We can see this in action by developing a simple <kbd>@identity</kbd> macro that returns whatever expression is passed into it. Right before the expression is returned, we just <kbd>dump</kbd> the object to the screen. The code for the <kbd>@identity</kbd> macro is as follows:</p>
<pre>macro identity(ex)<br/>    dump(ex)<br/>    return ex<br/>end</pre>
<p>Since this macro returns the same expression that was passed, it should end up executing the original source code that follows the macro. </p>
<p>Now, let's define a function that uses the <kbd>@identity</kbd> macro:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ffe1dd38-680b-4965-a37f-c859e78a5b51.png" style="width:21.42em;height:14.25em;"/></p>
<p><span>Clearly, the</span> compiler has figured out <span>that the macro is being used in the definition of the <kbd>foo</kbd></span> <span>function a</span><span>nd, in order to compile the</span> <kbd>foo</kbd> <span>function, it must understand what the</span> <kbd>@identity</kbd> <span>macro does. So it expanded the macro and baked that into the function definition. During the macro expansion process, the expression was displayed.</span></p>
<p>If we use the <kbd>@code_lowered</kbd> macro against the <kbd>foo</kbd> function, we can see that the expanded code is now in the body of the <kbd>foo</kbd> function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7815efe2-61fe-478f-9a07-a9abfb5319a2.png" style="width:15.92em;height:7.25em;"/></p>
<div class="packt_tip">During development, the programmer may change the definitions of functions, macros, and so on frequently. Because macros are expanded when functions are defined, it is important to redefine the function again if any of the macros being used have been changed; otherwise, the function may continue to use the code generated from the prior macro definition.</div>
<p>The <kbd>@macroexpand</kbd> utility is an indispensable tool for developing macros, and in particular, is most useful for debugging purposes. </p>
<p>Next, we will try to be a little more creative by manipulating expressions in macros.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Manipulating expressions</h1>
                </header>
            
            <article>
                
<p>Macros are powerful because they allow expressions to be manipulated during the macro expansion process. This is a tremendously useful technique, especially for code generation and designing domain-specific languages. Let's go over some examples to get a taste of what is possible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example 1 – Making a new expression</h1>
                </header>
            
            <article>
                
<p>Let's start with a simple one. Suppose that we want to create a macro called <kbd>@squared</kbd> that takes an expression and just squares it. In other words, if we run <kbd>@squared(x)</kbd>, then it should be translated into <kbd>x * x</kbd>:</p>
<pre>macro squared(ex)<br/>    return :($(ex) * $(ex))<br/>end</pre>
<p>At first glance, it seems to work fine when we run it from the REPL:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0497020c-1f39-47af-a3da-366abf4482ef.png" style="width:11.08em;height:3.00em;"/></p>
<p>But this macro has a problem with the execution context. The best way to illustrate the problem is by defining a function that uses the macro. So let's define a <kbd>foo</kbd> function, as follows:</p>
<pre>function foo()<br/>    x = 2<br/>    return @squared x<br/>end</pre>
<p>Now, when we call the function, we get the following error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0481fc86-f878-46b4-867e-4aee1e845c32.png" style="width:20.67em;height:2.58em;"/></p>
<p>Why is that? It is because, <span>during the macro expansion, </span><span>the</span> <kbd>x</kbd><span> </span><span>symbol</span><span> </span><span>refers to the variable in the module rather than the local variable in the</span> <kbd>foo</kbd> <span>function. We can confirm this by using the</span> <kbd>@code_lowered</kbd> <span>macro:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/500c7a34-0f8b-4747-8811-56f00eed2e5e.png" style="width:15.92em;height:8.25em;"/></p>
<p>Obviously, our intention was to square the local <kbd>x</kbd> <span>variable</span><span> </span><span>rather than</span> <kbd>Main.x</kbd><span>. The easy fix to this problem is to use the</span> <kbd>esc</kbd> <span>function during interpolation in order to place the expression directly in the syntax tree without letting the compiler resolve it. The following is how it can be done:</span></p>
<pre>macro squared(ex)<br/>    return :($(esc(ex)) * $(esc(ex)))<br/>end</pre>
<p>Since the macro was expanded earlier, before <kbd>foo</kbd> was defined, we need to define the <kbd>foo</kbd> function once again, as follows, for this updated macro to take effect. Alternatively, you can start a new REPL and define the <kbd>@squared</kbd> macro and <kbd>foo</kbd> function again. Here we go:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6cb9a817-8915-4ea2-ba6b-2cb0e2158dc5.png" style="width:21.58em;height:10.50em;"/></p>
<p>The <kbd>foo</kbd> <span>function</span><span> </span><span>works correctly now. </span></p>
<p>From this example, we have learned how to create a new expression using the interpolation technique. We have also learned that the interpolated variable needs to be escaped using the <kbd>esc</kbd> function to avoid it being resolved by the compiler to the global scope.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example 2 - Tweaking the abstract syntax tree</h1>
                </header>
            
            <article>
                
<p>Let's say we want to design a macro called <kbd>@compose_twice</kbd> that takes a simple function call expression and calls the same function again with the result—for example, if we run <kbd>@compose_twice sin(x)</kbd>, then it should be translated to <kbd>sin(sin(x))</kbd>.</p>
<p>Before we write the macro, let's first get familiar with the abstract syntax tree of the expression:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/664d8b6d-80b2-459e-bbfe-9ae14e9ac4d2.png" style="width:15.17em;height:8.58em;"/></p>
<p>How does it look for <kbd>sin(sin(x))</kbd>? Refer to the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7e9871e0-6b20-4997-8674-ee2e84f80a5d.png" style="width:16.58em;height:12.67em;"/></p>
<p>No surprise here. The second argument of the top-level call is just another expression that looks like what we saw previously.</p>
<p>We can write the macro as follows:</p>
<pre>macro compose_twice(ex)<br/>    @assert ex.head == :call<br/>    @assert length(ex.args) == 2<br/>    me = copy(ex)<br/>    ex.args[2] = me<br/>    return ex<br/>end</pre>
<p>The first two <kbd>@assert</kbd> statements are used to ensure that the expression represents a function call that takes a single argument. As we want to replace the argument with a similar expression, we just make a copy of the current expression object and assign it to <kbd>ex.args[2]</kbd>. The macro then returns the resulting expression for evaluation.</p>
<p>We can verify that the macro is working correctly:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7ed701a3-07c2-4ca7-a172-b20b41a87a65.png" style="width:25.33em;height:3.17em;"/></p>
<p class="mce-root">As you can see, we can translate the source code by manipulating the abstract syntax tree directly rather than interpolating variables into a nice-looking expression.</p>
<p>By now, you can probably appreciate the power of metaprogramming. <span>Compared to using interpolation, manipulating an expression directly is not as easy to understand because the resulting expression is not represented in the code; however, the ability to manipulate expressions provides the ult</span>imate flexibility in translating source code.</p>
<p>Next up, we will go over an important feature of metaprogramming—macro hygiene.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding macro hygiene</h1>
                </header>
            
            <article>
                
<p>Macro hygiene refers to the ability to keep macro-generated code clean. It is referred to as hygiene because the generated code does not get polluted by other parts of the code. </p>
<p>Note that many other programming languages do not provide such a guarantee. The following is a C program that contains a macro called <kbd>SWAP</kbd>, which is used to exchange the value of two variables:</p>
<pre>#include &lt;stdio.h&gt;<br/><br/>#define SWAP(a,b) temp=a; a=b; b=temp;<br/><br/>int main(int argc, char *argv[])<br/>{<br/>    int a = 1;<br/>    int temp = 2;<br/><br/>    SWAP(a,temp);<br/>    printf("a=%d, temp=%d\n", a, temp);<br/>}</pre>
<p><span>However, running this C program yields an incorrect result:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8c89d315-9273-4b0a-b9a1-6a032a9c5cc6.png" style="width:7.83em;height:3.92em;"/></p>
<p><span>It did not swap the</span> <kbd>a</kbd><span> </span><span>and </span><kbd>temp</kbd><span> </span><span>variables </span><span>properly because the</span> <kbd>temp</kbd><span> </span><span>variable </span><span>is also used as a temporary variable in the body of the macro.</span></p>
<p><span><span>Let's go back to Julia. </span></span>Consider the following macro, which just runs an <kbd>ex</kbd> <span>expression </span><span>and repeats it </span><kbd>n</kbd> <span>times:</span></p>
<pre>macro ntimes(n, ex)<br/>    quote<br/>        times = $(esc(n))<br/>        for i in 1:times<br/>            $(esc(ex))<br/>        end<br/>    end<br/>end</pre>
<p>Since the <kbd>times</kbd> variable is used in the returned expression, what would happen if the same variable name is already used in the call site? Let's try this sample code, which defines a <kbd>times</kbd> variable before the macro call and prints the value of the same variable after the macro call:</p>
<pre>function foo()<br/>    times = 0<br/>    @ntimes 3 println("hello world")<br/>    println("times = ", times)<br/>end</pre>
<p>If the macro expander took it literally, then the <kbd>times</kbd> variable would be modified to <kbd>3</kbd> after the macro call; however, we can see it working properly in the following code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/69356a2f-70f7-4981-98df-dcc7d1f77cc5.png" style="width:7.17em;height:6.42em;"/></p>
<p>It works because the macro system is able to maintain hygiene by renaming the <kbd>times</kbd> variable to something different so that there is no conflict. Where is the magic? Well, let's take a look at the expanded code using <kbd>@macroexpand</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/07a64213-e13d-4060-aa22-8546322f2124.png" style="width:30.25em;height:12.67em;"/></p>
<p>Here, we can see that the <kbd>times</kbd> variable has turned into <kbd>#44#times</kbd>. The loop variable <kbd>i</kbd> has also turned into <kbd>#45#i</kbd>. <span>These variable names are dynamically generated by the compiler to ensure that macro-generated code does not conflict with other user-written code.</span></p>
<p>Macro hygiene is an essential feature for macros to function correctly. There is nothing that the programmer needs to do: Julia automatically provides the guarantee.</p>
<p>Next, we will look into a different kind of macro that powers nonstandard string literals. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing nonstandard string literals</h1>
                </header>
            
            <article>
                
<p>There is a special kind of macro for defining nonstandard string literals, which look like a literal string but instead a macro is called when it is referenced.</p>
<p>A good example would be Julia's regular expression literal—for example, <kbd>r"^hello"</kbd>. It is not a standard string literal because of the <kbd>r</kbd> prefix in front of the double quote. Let's first check the data type of such a literal. We can see that <span>a </span><kbd>Regex</kbd><span> object is created from the string:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/66d4c40a-9654-4c61-84c8-74f090383aad.png" style="width:14.33em;height:3.17em;"/></p>
<p class="mce-root">We can also create our own nonstandard string literals. Let's try to work through a fun example together here.</p>
<p class="mce-root">Suppose that, for development purposes, we want to conveniently create sample data frames with different types of columns. The syntax for doing so is a little bit tedious:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/91855e88-e2b9-40e7-8e6d-758a223a67c0.png" style="width:37.00em;height:15.50em;"/></p>
<p>Imagine that we occasionally need to create tens of columns with different data types. The code for creating such a data frame would be very long, and as a programmer, I would be extremely bored typing that all out. So we could design a string literal so that it contains the specification for constructing such a data frame—let's call it a <kbd>ndf</kbd> (numerical data frame) literal.</p>
<p>The specification on <kbd>ndf</kbd> just needs to encode the desired number of rows and column types. For instance, the literal <kbd>ndf"100000:f64,i16"</kbd> can be used to represent the preceding sample data frame, where 100,000 rows are needed, with two columns labeled as the <kbd>Float64</kbd> and <kbd>Int16</kbd> columns.</p>
<p>To implement this feature, we just define a macro called <kbd>@ndf_str</kbd>. The macro takes a string literal and creates the desired data frame accordingly. The following is one way to implement the macro:</p>
<pre>macro ndf_str(s)<br/>    nstr, spec = split(s, ":")<br/>    n = parse(Int, nstr) # number of rows<br/>    types = split(spec, ",") # column type specifications<br/>    <br/>    num_columns = length(types)<br/>    <br/>    mappings = Dict(<br/>    "f64"=&gt;Float64, "f32"=&gt;Float32,<br/>    "i64"=&gt;Int64, "i32"=&gt;Int32, "i16"=&gt;Int16, "i8"=&gt;Int8)<br/>    <br/>    column_types = [mappings[t] for t in types]<br/>    column_names = [Symbol("x$i") for i in 1:num_columns]<br/>    <br/>    DataFrame([column_names[i] =&gt; rand(column_types[i], n)<br/>        for i in 1:num_columns]...) <br/>end</pre>
<p>The first few lines parse the string and determine the number of rows (<kbd>n</kbd>), as well as the types of the columns (<kbd>types</kbd>). Then, a dictionary called <kbd>mappings</kbd> is created to map the shorthand to the corresponding numeric types. The column names and types are generated from the type and mapping data. Finally, it calls the <kbd>DataFrame</kbd> constructor and returns the result.</p>
<p>Now that we have the macro defined, we can easily create new data frames, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/26cacfc8-c5ab-431b-977a-b38b526a1447.png" style="width:28.33em;height:19.00em;"/></p>
<p>Nonstandard string literals can be quite useful in certain cases. We can see a string specification as a mini domain-specific language that is encoded in the string. As long as the string specification is well defined, it can make the code a lot shorter and more concise.</p>
<div class="packt_infobox">You may have noticed that the <kbd>ndf_str</kbd> macro returns a regular <kbd>DataFrame</kbd> object rather than an expression object, as it would normally do with macros. This is perfectly fine because the final <kbd>DataFrame</kbd> object will be returned as-is. You may think of an evaluation of a constant as just the constant itself. We can just return a value rather than an expression here because the returned value does not involve any variables from the call site or from the module.</div>
<p class="mce-root">A curious mind might ask - why can't we just create a regular function for this? We can certainly do that for this dummy example. However, using a string literal could improve performance in some cases.</p>
<p class="mce-root">For example, when we use the Regex string literal in a function, the <kbd>Regex</kbd> object is created at compile-time and so it is executed only once. If we use the <kbd>Regex</kbd> constructor instead, then the object would be created every single time the function is called.</p>
<p>We have now concluded the topic of macros. We learned how to create macros by taking expressions and generating a new expression. We used the <kbd>@macroexpand</kbd> macro to debug the macro expansion process. We also learned how to handle macro hygiene. Finally, we took a look at nonstandard string literals and created our own using a macro.</p>
<p>Next, we will look at another metaprogramming facility called generated functions, which can be used to solve a different kind of problem than what regular macros can handle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using generated functions</h1>
                </header>
            
            <article>
                
<p>So far, we have explained how to create macros that return expression objects. Since macros work at the syntax level, they can manipulate code only by examining how it <em>looks</em>. However, Julia is a dynamic system where data types are determined at runtime. For that reason, Julia provides the ability to create <strong>generated functions</strong>, which allow you to examine data types for a function call and return an expression, just like macros. When an expression is returned, it will be evaluated at the call site.</p>
<p>To understand why generated functions are needed, let's revisit how macros work. Let's say we have created a macro that doubles the value of its arguments. It would look like the following:</p>
<pre>macro doubled(ex)<br/>    return :( 2 * $(esc(ex)))<br/>end</pre>
<p>No matter what expression we pass into this macro, it would just blindly rewrite the code so it doubles the original expression. Suppose that one day, a super-duper piece of software is developed that lets us calculate twice<span> </span><span>the</span> amount of a floating-point number quickly. In this case, we may want the system to switch to that function for floating-point numbers only, instead of using the standard multiplication operator.</p>
<p>So our first attempt might be to try something as follows:</p>
<pre># This code does not work. Don't try it.<br/>macro doubled(ex)<br/>    if typeof(ex) isa AbstractFloat<br/>        return :( double_super_duper($(esc(ex))) )<br/>    else<br/>        return :( 2 * $(esc(ex)))<br/>    end<br/>end</pre>
<p>But unfortunately, it is impossible for macros to do this. Why? Again, macros only have access to the abstract syntax tree. This is at the earlier part of the compilation pipeline and there is no type information available. The <kbd>ex</kbd> <span>variable</span><span> </span><span>in the preceding code is merely an expression object. This problem can be solved with generated functions. Keep on reading!</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining generated functions</h1>
                </header>
            
            <article>
                
<p><strong>Generated functions</strong> are functions that are prefixed by <kbd>@generated</kbd> at the function definition. These functions can return expression objects, just like macros. For example, we can define the <kbd>doubled</kbd> function as follows:</p>
<pre>@generated function doubled(x)<br/>    return :( 2 * x )<br/>end</pre>
<p>Let's quickly run a test and make sure that it works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5743d747-3b23-4e65-beaa-ba7d94f060cf.png" style="width:9.92em;height:3.00em;"/></p>
<p>The code works beautifully, as expected.</p>
<p>So defining generated functions is quite similar to defining macros. In both cases, we can create an expression object and return it, and we can expect the expression to be evaluated properly.</p>
<p>We have not, however, exercised the full power of generated functions yet. Next, we will look at how data type information can be made available and how it can be used within generated functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Examining generated function arguments</h1>
                </header>
            
            <article>
                
<p>An important point to remember is that arguments of generated functions contain data types, not actual values. The following is a visual representation of how generated functions work:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/567af354-7dcc-46c4-991b-c74c16cc9f4c.png" style="width:36.08em;height:17.17em;"/></p>
<p>This is in sharp contrast to functions, which accept arguments as values. It is also different from macros, which accept arguments as expressions. Here, generated functions accept arguments as data types. It may seem a little strange, but let's do a simple experiment to confirm that this is indeed the case.</p>
<p>For this experiment, we will define the <kbd>doubled</kbd> function again by displaying the argument on screen before returning the expression.</p>
<pre>@generated function doubled(x)<br/>    @show x<br/>    return :( 2 * x )<br/>end</pre>
<p>Let's test the function again.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/65ba16c7-91c2-41d3-aac9-61f02d5be2ba.png" style="width:9.75em;height:7.50em;"/></p>
<p>As it is shown, the value of argument <kbd>x</kbd> is <kbd>Int64</kbd> rather than <kbd>2</kbd> during the execution of the generated function. Furthermore, when the function is called again, it no longer shows the value of <kbd>x</kbd>. This is because the function is now compiled after the first call.</p>
<p>Now, let's see what happens if we run it again with a different type:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/149b0d49-32bb-4144-8244-80e6b45e9b7e.png" style="width:11.08em;height:4.00em;"/></p>
<p>The compiler has kicked in again and compiled a new version based upon the type of <kbd>Float64</kbd>. So, technically speaking, we now have two versions of the <kbd>doubled</kbd> function for each type of argument.</p>
<div class="packt_infobox">You may have realized that the behavior of generated functions is similar to that of regular functions when it comes to specialization. The difference is that we have a chance to manipulate the abstract syntax tree right before the compilation happens.</div>
<p>With this new generated function, we can now take advantage of the hypothetical super-duper software by switching over to the faster <kbd>double_super_duper</kbd> function whenever the data type of the argument is a subtype of <kbd>AbstractFloat</kbd>, as shown in the following code:</p>
<pre>@generated function doubled(x)<br/>    if x &lt;: AbstractFloat<br/>        return :( double_super_duper(x) )<br/>    else<br/><span><span>      </span></span><span><span>  </span></span>return :( 2 * x )<br/>    end<br/> end</pre>
<p>Using generated functions, we can specialize the function depending on the type of the argument. When the type is <kbd>AbstractFloat</kbd>, the function will resort to the <kbd>double_super_duper(x)</kbd> rather than the <kbd>2 *x</kbd> expression.</p>
<div class="packt_tip">As mentioned in the official Julia language reference manual, care must be taken when developing generated functions. The exact limitations are beyond of the scope of this book. You are highly encouraged to refer to the manual if you need to write generated functions for your software.</div>
<p><span>Generated functions are a useful tool to deal with cases that macros are unable to handle. Specifically, during the macro expansion process, there is no information about the types of the argument</span>. Generated functions allow us to get a little closer to the heart of the compilation process. With the additional knowledge about argument types, we are more flexible when it comes to handling different situations.</p>
<p>As a metaprogramming tool, macros are used much more extensively than generated functions. Nevertheless, it is nice to know that both tools are available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how Julia parses expressions into an abstract syntax tree structure. We learned that expressions can be created and evaluated <span>programmatically. We also learned how to interpolate variables into quoted expressions.</span></p>
<p>Then, we jumped into the topic of macros, which are used to <span>dynamically </span><span>create new code. We learned that macro arguments are expressions rather than values, and learned how to create new expressions from macros. We had fun creating macros that manipulate the abstract syntax tree to deal with some interesting use cases.</span></p>
<p>Finally, we looked at generated functions, which can be used to generate code based on the type of the function arguments. We learned how generated functions can be useful for a hypothetical use case.</p>
<p>We have now concluded the introductory part of the book regarding the Julia programming language. In the next chapter, we will start looking at design patterns related to code reusability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the two ways we can use to quote expressions so that the code can be manipulated later?</li>
<li>In what environment does the <kbd>eval</kbd> function execute code?</li>
<li>How do you interpolate physical symbols into quoted expressions so that they are not misinterpreted as source code?</li>
<li>What is the naming convention for a macro that defines nonstandard string literals?</li>
</ol>
<ol start="5">
<li>When do you use the <kbd>esc</kbd> function?</li>
<li>How are generated functions different from macros?</li>
<li>How do you debug macros?</li>
</ol>


            </article>

            
        </section>
    </body></html>