- en: Anomaly Detection Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With k-means clustering models behind us, it is now time to dive into anomaly
    detection models. Anomaly detection is one of the newer additions to ML.NET, and
    specifically, time-series transforms. In this chapter, we will dive into anomaly
    detection and the various applications best suited to utilizing anomaly detection.
    In addition, we will build two new example applications: one anomaly detection
    application that determines whether the login attempt is abnormally demonstrating
    the randomized PCA trainer, and one that demonstrates time series in a network
    traffic anomaly detection application. Finally, we will explore how to evaluate
    an anomaly detection model with the properties that ML.NET exposes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down anomaly detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a time series application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an anomaly detection application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating an anomaly detection model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking down anomaly detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml), *Getting
    Started with Machine Learning and ML.NET,* anomaly detection, by definition, is
    an unsupervised learning algorithm. This means that the algorithm will train on
    data and look for data that does not fit the normal data. In this section, we
    will dive into use cases for anomaly detection and into the various trainers available
    for anomaly detection in ML.NET.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for anomaly detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anomaly detection, as you might have realized already, has numerous applications
    where data is available but it is unknown whether there is an anomaly in the data.
    Without needing to do manual spot-checking, anomaly detection algorithms train
    on this data and determine whether there are any anomalies. ML.NET provides various
    anomaly detection values to look at programmatically inside of your application.
    We will review these values later on in this chapter to better ensure that any
    detection is not a false positive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the potential applications best suited for anomaly detection include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sales forecasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stock market
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fraud detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anticipating the failure of a device due to various factors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cyber-security applications for remote connections and network traffic login
    history, such as the example application that we will dive into later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving into the randomized PCA trainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The randomized PCA trainer is the only traditional trainer for anomaly detection
    found in ML.NET at the time of writing. The randomized PCA trainer requires normalization
    of the values; however, caching is not necessary and no additional NuGet packages
    are required to utilize the trainer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to other algorithms, the input is a known vector size of the `Float` type.
    The output comprises two properties: `Score` and `PredictedLabel`. The `Score`
    value is of the `Float` type, non-negative, and unbounded. In contrast, the `PredictedLabel` property indicates
    a valid anomaly based on the threshold set; a value of true indicates an anomaly,
    while a value of false indicates otherwise. ML.NET''s default threshold is 0.5,
    which can be adjusted via the `ChangeModelThreshold` method. Effectively, values
    higher than the threshold return true, and false if they are lower.'
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, the algorithm uses eigenvectors to estimate the subspace containing
    the normal class and then computes the normalized difference between the actual
    feature vector and the projected feature vector in that subspace. Put simply,
    the algorithm finds edge cases if the computed error is not close to 0\. If it
    finds the error is close to 0, it is considered a normal data point (that is,
    a non-anomaly).
  prefs: []
  type: TYPE_NORMAL
- en: We will demonstrate this trainer in the second example application later on
    in this chapter, by detecting login anomalies.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to deep dive further into randomized PCA, the following paper
    is a great resource: [https://web.stanford.edu/group/mmds/slides2010/Martinsson.pdf](https://web.stanford.edu/group/mmds/slides2010/Martinsson.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Diving into time series transforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike other algorithms found in this book and ML.NET itself, time series support
    was added as a series of transforms to be applied to your training and test data.
    Time series, as mentioned previously, is also one of the newer additions to ML.NET,
    being added in 1.2.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ML.NET, times series transforms are grouped into the `TimeSeriesCatalog`
    class. There are six different methods inside this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DetectAnomalyBySrCnn`: Detects anomalies with the SRCNN algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DetectChangePointBySsa`: Detects anomalies with the **Singular Spectrum Analysis**
    (**SSA**) algorithm on change points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DetectIidChangePoint`: Detects changes to predict change points with an **independent
    identically distributed** (**i.i.d**) algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DetectIidSpike`: Detects changes with an i.i.d algorithm but predicts spikes
    instead of change points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DetectSpikeBySsa`: Detects spikes using the SSA algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ForecastBySsa`: Uses the SSA algorithm for a singular variable- (commonly
    referred to as univariate-) based time series forecasting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the application, you may want to look for spikes of data changes
    or points of change (on the upward or downward spiral). In this chapter's example
    on time series, we will be looking for spikes in network transfer over time utilizing
    `DetectSpikeBySsa`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on forecasting with SSA, a great resource can be found
    here: [http://arxiv.org/pdf/1206.6910.pdf](http://arxiv.org/pdf/1206.6910.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a time series application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the application we will be creating is a network traffic
    anomaly detector. Given a set of attributes relating to the network traffic amount
    (in bytes), the application will use that data to find anomalies in the amount
    of traffic for a given checkpoint. As with other applications, this is not meant
    to power the next ML network traffic anomaly detection product; however, it will
    show you how to use time series in ML.NET, specifically to detect spikes with
    SSA.
  prefs: []
  type: TYPE_NORMAL
- en: As with previous chapters, the completed project code, sample dataset, and project
    files can be downloaded here: [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter06-time-series](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter06-time-series).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the project architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building on the project architecture and code we created in previous chapters,
    the bulk of the changes are in the training of the model as time series requires
    a fairly significant paradigm shift from what we have reviewed in previous chapters.
    In addition to this, when using time series transforms, you will need to add the
    `Microsoft.ML.TimeSeries` NuGet package if you are creating a project from scratch.
    The example application available in the GitHub repository has this package already
    included.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you will find the Visual Studio Solution Explorer
    view of the project. The new additions to the solution are the `NetworkTrafficHistory`and `NetworkTrafficPrediction`files,
    which we will review later on in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7800d9bf-46b4-4f78-bcb1-582760156732.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `sampledata.csv` file contains eight rows of network traffic data. Feel
    free to adjust the data to fit your own observations or to adjust the trained
    model. Here is a snippet of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each of these rows contains the values for the properties in the newly created `NetworkTrafficHistory`class,
    which we will review later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, we have added the `testdata.csv` file, which contains
    additional data points to test the newly trained model against and evaluate. Here
    is a snippet of the data inside of `testdata.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Diving into the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this application, as noted in the previous section, we are building on top
    of the work completed in [Chapter 5](4c32e261-cec6-4113-9734-1e29c7c18f9a.xhtml), *Clustering
    Model*. For this deep dive, we are going to focus solely on the code that was
    changed for this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes that were changed or added are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NetworkTrafficHistory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NetworkTrafficPrediction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Predictor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Trainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Program`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NetworkTrafficHistory class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `NetworkTrafficHistory`class is the container class that contains the data
    to both predict and train our model. As described in previous chapters, the number
    in the `LoadColumn` decorator maps to the index in the CSV files. As noted earlier,
    anomaly detection in ML.NET requires the use of a single floating-point value;
    in this case, it is the `BytesTransferred` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The NetworkTrafficPrediction class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `NetworkTrafficPrediction`class contains the properties mapped to our prediction
    output. The `VectorType(3)` function holds the alert, score, and p-value. We will
    review these values later on in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Predictor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a couple of changes to make to this class in order to handle the
    network traffic prediction scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create our prediction engine with the `NetworkTrafficHistory`and `NetworkHistoryPrediction` types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we read the input file into an `IDataView` variable (note the override
    to use a comma as `separatorChar`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we take the newly created `IDataView` variable and get an enumerable
    based off of that data view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to run the prediction and then output the results of the model
    run:'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With `Transform` only returning the three-element vector, the original row data
    is output to give context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Trainer class
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `Trainer` class, several modifications need to be made to support
    the time series transform. In many ways, a simplification is required. The removal
    of the evaluation and testing data load is performed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first addition is of the four variables to send to the transform:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The training window size must be greater than twice the p-value history length
    due to a constraint in the ML.NET library at the time of writing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then build the `DataView` object from the CSV training file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then create SSA spike detection:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we fit the model on the training data and save the model:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Program class
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given that the training only requires the training data, some modifications
    to the `Program` class have to be performed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The help text needs to be updated to reflect the new usage:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In addition, the switch case statement needs to be updated to reflect the single
    argument passed for the prediction:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the application
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the application, the process we use is nearly identical to [Chapter
    3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml), *Regression Model*''s example
    application:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After preparing the data, we must train the model by passing in the newly created `sampledata.csv`
    file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the model with this file, simply pass in the `testdata.csv` filementioned
    earlier into the newly built application, and the predicted output will show the
    following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output includes the three data points: `HOST`, `TIMESTAMP`, and `TRANSFER`.
    The new additions are `ALERT`, `SCORE`, and `P-VALUE`. `ALERT` values of nonzero
    indicate an anomaly. `SCORE` is a numeric representation of the anomaly score;
    a higher value indicates a spike. `P-VALUE`, a value between 0 and 1, is the distance
    between the current point and the average point. A value closer or equal to 0
    is another indication of a spike. When evaluating your model and efficacy, using
    these three data points together you can be guaranteed a true spike, effectively
    reducing the potential false positive count.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Feel free to modify the values and explore how the prediction changes based
    on the dataset that the model was trained on. A few areas of experimentation from
    this point might be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adding more specific data points such as an IP address
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding diversification and more data points to the training and test data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an anomaly detection application
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the application we will be creating is a login anomaly
    detector. Given a set of attributes relating to the login, the application will
    use that data to find anomalies such as unusual login times. As with other applications,
    this is not meant to power the next ML login anomaly detection product; however,
    it will show you how to use anomaly detection in ML.NET.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As with previous chapters, the completed project code, sample dataset, and project
    files can be downloaded here: [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter06](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter06).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exploring the project architecture
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Building on the project architecture and code we created in previous chapters,
    the bulk of the changes in this example are in the training of the model.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the following screenshot, you will find the Visual Studio Solution Explorer
    view of the project. The new additions to the solution are the `LoginHistory `and `LoginPrediction` files,
    which we will review later on in this section:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/2264ca20-b60c-44c8-9b34-ede53f39ca3d.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The `sampledata.csv` file contains 10 rows of login data. Feel free to adjust
    the data to fit your own observations or to adjust the trained model. Here is
    a snippet of the data:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each of these rows contains the values for the properties in the newly created
    `LoginHistory` class, which we will review later on in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In addition to this, we added the `testdata.csv` file, which contains additional
    data points to test the newly trained model against and evaluate. Here is a snippet
    of the data inside of `testdata.csv`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Diving into the code
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: For this application, as noted in the previous section, we are building on top
    of the work completed in [Chapter 5](4c32e261-cec6-4113-9734-1e29c7c18f9a.xhtml),
    *Clustering Model*. For this deep dive, we are going to focus solely on the code
    that was changed for this application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Classes that were changed or added are as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Constants`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoginHistory`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoginPrediction`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Predictor`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Trainer`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Constants class
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Constants` class has been changed to save the model to `chapter6.mdl`.
    The following code block reflects these changes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The LoginHistory class
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `LoginHistory`class is the container class that contains the data to both
    predict and train our model. As described in previous chapters, the number in
    the `LoadColumn` decorator maps to the index in the CSV files. Each property maps
    to a value that will be sent into the model for anomaly detection:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The LoginPrediction class
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `LoginPrediction`class contains the properties mapped to our prediction
    output. The following `PredictedLabel` property will hold our prediction, while
    the `Label` and `Score` properties are used for evaluation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Predictor class
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a couple of changes to make to this class in order to handle the
    `Login` anomaly detection scenario:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we create our prediction engine with the `LoginHistory`and `LoginPrediction`
    types:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we read the input file into a string variable:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we run the prediction and then output the results of the model run:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Trainer class
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `Trainer` class, several modifications need to be made to support
    anomaly detection classification using the randomized PCA trainer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first change is the addition of a `GetDataView` helper method, which builds
    the `IDataView` data view from the columns previously defined in the `LoginHistory` class:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then build the training data view and the `RandomizedPcaTrainer.Options`
    object:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `Rank` property must be equal to or less than the features.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can then create the randomized PCA trainer, append it to the training data
    view, fit our model, and then save it:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we evaluate the model we just trained using the testing dataset:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we output all of the classification metrics. Each of these will be
    detailed in the next section:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the application
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the application, the process we use is nearly identical to [Chapter
    3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml), *Regression Model*''s example
    application with the addition of passing in the test dataset when training:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After extracting data, we must train the model by passing in the newly created `sampledata.csv` and `testdata.csv`
    files:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the model with this file, simply pass in a constructed JSON file (`input.json`,
    in this case) and the predicted output will show:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the expanded output of the model training to include two metric data points.
    We will go through what each one of these means at the end of this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Feel free to modify the values and explore how the prediction changes based
    on the dataset that the model was trained on. A few areas of experimentation from
    this point might include the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adding some additional properties to increase the prediction accuracy in a production
    scenario such as the hour of the day the login occurred
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding diversity to the training and test data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating a randomized PCA model
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in previous chapters, evaluating a model is a critical part of
    the overall model-building process. A poorly trained model will only provide inaccurate
    predictions. Fortunately, ML.NET provides many popular attributes to calculate
    model accuracy based on a test set at the time of training to give you an idea
    of how well your model will perform in a production environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In ML.NET, as noted in the example application, there are two properties that
    comprise the `AnomalyDetectionMetrics`class object. Let''s dive into the properties
    exposed in the `AnomalyDetectionMetrics`object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Area under the ROC curve
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection rate at false positive count
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next sections, we will break down how these values are calculated and
    ideal values to look for.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Area under the ROC curve
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The area under the ROC curve, as mentioned in [Chapter 3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml),
    *Regression Model*, is, as the name implies, the area under the **Receiver Operating
    Characteristic** (**ROC**) curve. One question that might come to mind is this:
    how is this relevant to evaluating an anomaly detection model?'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This computed area is equal to the chance that the algorithm, randomized PCA,
    in our case, scores a positive instance higher than a negative one, both chosen
    randomly to better evaluate the data. The number returned closer to 100% is the
    ideal value, while if it is closer to 0%, you will more than likely have significant
    false positives. You might remember our earlier example application getting 78%.
    This means that there was a 22% chance of a false positive; the following outlines
    some suggestions to improve the model and should reduce this number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following diagram visually reflects both a random guessing line and an
    arbitrary data curve. The area under the data curve in between the random guessing
    line is the area under the ROC curve data metric:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/ca963c34-e882-4652-bdae-ba762ee7d9d5.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Detection rate at false positive count
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The detection rate at false positive count property is the detection rate of
    *K* false positives. A false positive in an anomaly detection scenario would be
    to consider a data point an anomaly when, in fact, it was not. This rate is computed
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Detection Rate of K False Positives = X / Y*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, *X* is calculated to be the top test samples based on the scores previously
    described in the anomaly detection example (sorted in descending order). These
    are considered the top true positives (that is, more likely to be actual anomalies).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Y* is calculated to be the total number of anomalies in the test data regardless
    of the score value (not filtering to points that look suspicious or not). In theory,
    this number could be very high if the number of false positives is high in your
    training data. As you build production models with randomized PCA, ensure your
    data represents as close to production as possible to avoid overfitting or underfitting
    to anomalies.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this chapter, we discussed ML.NET's anomaly detection support
    via the randomized PCA algorithm. We also created and trained our first anomaly
    detection application using the randomized PCA algorithm to predict abnormal logins.
    In addition to this, we created a time series application, looking at network
    traffic and finding spikes in the amount of transferred data. Finally, we also
    looked at how to evaluate an anomaly detection model and the various properties
    that ML.NET exposes to achieve a proper evaluation of an anomaly detection model.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the next chapter, we will deep dive into matrix factorization with ML.NET to
    create a music preference predictor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
