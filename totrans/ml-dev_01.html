<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Introduction - Machine Learning and Statistical Science</h1>
                </header>
            
            <article>
                
<p>Machine learning has definitely been one of the most talked about fields in recent years, and for good reason. Every day new applications and models are discovered, and researchers around the world announce impressive advances in the quality of results on a daily basis.</p>
<p>Each day, many new practitioners decide to take courses and search for introductory materials so they can employ these newly available techniques that will improve their applications. But <span>in many cases, </span><span>the whole corpus of machine learning,</span> <span>as normally explained in the literature,</span><span> requires a good understanding of mathematical concepts as a prerequisite, thus imposing a high bar for programmers who typically have good algorithmic skills but are less familiar with higher mathematical concepts.</span></p>
<p>This first chapter will be a general introduction to the field, covering the main study areas of machine learning, and will offer an overview of the basic statistics, probability, and calculus, accompanied by source code examples in a way that allows you to experiment with the provided formulas and parameters.</p>
<p>In this first chapter, you will learn the following topics:</p>
<ul>
<li>What is machine learning?</li>
<li>Machine learning areas</li>
<li>Elements of statistics and probability</li>
<li>Elements of calculus</li>
</ul>
<p>The world around us provides huge amounts of data. At a basic level, we are continually acquiring and learning from text, image, sound, and other types of information surrounding us. The availability of data, then, is the first step in the process of acquiring the skills to perform a task.</p>
<p>A myriad of computing devices around the world collect and store an overwhelming amount of information that is image-, video-, and text-based. So, the raw material for learning is clearly abundant, and it's available in a format that a computer can deal with.</p>
<p>That's the starting point for the rise of the discipline discussed in this book: the study of techniques and methods allowing computers to learn from data without being explicitly programmed.</p>
<p>A more formal definition of machine learning, from <em>Tom Mitchell</em>, is as follows:</p>
<div class="packt_quote">"A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E."</div>
<p>This definition is complete, and reinstates the elements that play a role in every machine learning project: the task to perform, the successive experiments, and a clear and appropriate performance measure. In simpler words, we have a program that improves how it performs a task based on experience and guided by a certain criterion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Machine learning in the bigger picture</h1>
                </header>
            
            <article>
                
<p>Machine learning as a discipline is not an isolated field—it is framed inside a wider domain, <strong>Artificial Intelligence</strong> (<strong>AI</strong>). But as you can guess, machine learning didn't appear from the void. As a discipline it has its predecessors, and it has been evolving in stages of increasing complexity in the following four clearly differentiated steps:</p>
<ol>
<li>The first model of machine learning involved rule-based decisions and a simple level of data-based algorithms that includes in itself, and as a prerequisite, all the possible ramifications and decision rules, implying that all the possible options will be hardcoded into the model beforehand by an expert in the field. This structure was implemented in the majority of applications developed since the first programming languages appeared in 1950. The main data type and function being handled by this kind of algorithm is the Boolean<span><span>, as it exclusively dealt with yes or no decisions.</span></span></li>
</ol>
<p> </p>
<ol start="2">
<li>During the second developmental stage of statistical reasoning, we started to let the probabilistic characteristics of the data have a say, in addition to the previous choices set up in advance. This better reflects the fuzzy nature of real-world problems, where outliers are common and where it is more important to take into account the nondeterministic tendencies of the data than the rigid approach of fixed questions. This discipline adds to the mix of mathematical tools elements of <strong>Bayesian probability theory</strong>. Methods pertaining to this category include curve fitting (usually of linear or polynomial), which has the common property of working with numerical data.</li>
<li>The machine learning stage is the realm in which we are going to be working throughout this book, and it involves more complex tasks than the simplest Bayesian elements of the previous stage.<br/>
The most outstanding feature of machine learning algorithms is that they can generalize models from data but the models are capable of generating their own feature selectors, which aren't limited by a rigid target function, as they are generated and defined as the training process evolves. Another differentiator of this kind of model is that they can take a large variety of data types as input, such as speech, images, video, text, and other data susceptible to being represented as vectors.</li>
<li>AI is the last step in the scale of abstraction capabilities that, <span>in a way,</span> include all previous algorithm types, but with one key difference: AI algorithms are able to apply the learned knowledge to solve tasks that had never been considered during training. The types of data with which this algorithm works are even more generic than the types of data supported by machine learning, and they should be able, by definition, to transfer problem-solving capabilities from one data type to another, without a complete retraining of the model. In this way, we could develop an algorithm for object detection in black and white images and the model could abstract the knowledge to apply the model to color images.</li>
</ol>
<p>In the following diagram, we represent these four stages of development towards real AI applications:</p>
<div class="CDPAlignCenter CDPAlign"><img height="496" width="630" src="assets/0b800807-4849-42df-8074-74bb08da83a3.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of machine learning</h1>
                </header>
            
            <article>
                
<p>Let's try to dissect the different types of machine learning project, starting from the grade of previous knowledge from the point of view of the implementer. The project can be of the following types:</p>
<ul>
<li><strong>Supervised learning</strong>: In this type of learning, we are given a sample set of real data, accompanied by the result the model should give us after applying it. In statistical terms, we have the outcome of all the training set experiments.</li>
<li><strong>Unsupervised learning:</strong> This type of learning provides only the sample data from the problem domain, but the task of grouping similar data and applying a category has no previous information from which it can be inferred.</li>
<li><strong>Reinforcement learning:</strong> This type of learning doesn't have a labeled sample set and has a different number of participating elements, which include an agent, an environment, and learning an optimum policy or set of steps, maximizing a goal-oriented approach by using rewards or penalties (the result of each attempt).</li>
</ul>
<p style="padding-left: 60px">Take a look at the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="471" width="579" src="assets/b4e5dfbd-6f8a-470b-a6aa-753885eb15bf.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Main areas of Machine Learning</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Grades of supervision</h1>
                </header>
            
            <article>
                
<p>The learning process supports gradual steps in the realm of supervision: </p>
<ul>
<li>Unsupervised Learning doesn't have previous knowledge of the class or value of any sample, it should infer it automatically.</li>
<li>Semi-Supervised Learning, needs a seed of known samples, and the model infers the remaining samples class or value from that seed.</li>
<li>Supervised Learning: This approach normally includes a set of known samples, called training set, another set used to validate the model's generalization, and a third one, called test set, which is used after the training process to have an independent number of samples outside of the training set, and warranty  independence of testing.</li>
</ul>
<p>In the following diagram, depicts the mentioned approaches:</p>
<div class="CDPAlignCenter CDPAlign"><img height="171" width="601" src="assets/3605a99e-96d0-45ba-b54e-94b060b405c7.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Graphical depiction of the training techniques for Unsupervised, Semi-Supervised and Supervised Learning</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Supervised learning strategies - regression versus classification</h1>
                </header>
            
            <article>
                
<p>This type of learning has the following two main types of problem to solve:</p>
<ul>
<li><strong>Regression problem</strong>: This type of problem accepts samples from the problem domain and, after training the model, minimizes the error by comparing the output with the real answers, which allows the prediction of the right answer when given a new unknown sample</li>
<li><strong>Classification problem</strong>: This type of problem uses samples from the domain to assign a label or group to new unknown samples</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unsupervised problem solving–clustering</h1>
                </header>
            
            <article>
                
<p>The vast majority of unsupervised problem solving consist of grouping items by looking at similarities or the value of shared features of the observed items, because there is no certain information about the <em>a</em> <em>priori</em> classes. This type of technique is called clustering.</p>
<p>Outside of these main problem types, there is a mix of both, which is called semi-supervised problem solving, in which we can train a labeled set of elements and also use inference to assign information to unlabeled data during training time. To assign data to unknown entities, three main criteria are used—smoothness (points close to each other are of the same class), cluster (data tends to form clusters, a special case of smoothness), and manifold (data pertains to a manifold of much lower dimensionality than the original domain).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tools of the trade–programming language and libraries</h1>
                </header>
            
            <article>
                
<p>As this book is aimed at developers, we think that the approach of explaining the mathematical concepts using real code comes naturally.</p>
<p>When choosing the programming language for the code examples, the first approach was to use multiple technologies, including some cutting-edge libraries. After consulting the community, it was clear that a simple language would be preferable when explaining the concepts.</p>
<p>Among the options, the ideal candidate would be a language that is simple to understand, with real-world machine learning adoption, and that is also relevant.</p>
<p>The clearest candidate for this task was Python, which fulfils all these conditions, and especially in the last few  years has become the go-to language for machine learning, both for newcomers and professional practitioners.</p>
<p>In the following graph, we compare the previous star in the machine learning programming language field, R, and we can clearly conclude the huge, favorable tendency towards using Python. This means that the skills you acquire in this book will be relevant now and in the foreseeable future:</p>
<div class="CDPAlignCenter CDPAlign"><img height="337" width="881" class="alignnone size-full wp-image-887 image-border" src="assets/508009c9-5f18-4375-9acb-d3773b6406be.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Interest graph for R and Python in the Machine Learning realm.</div>
<p>In addition to Python code, we will have the help of a number of the most well-known numerical, statistical, and graphical libraries in the Python ecosystem, namely pandas, NumPy, and matplotlib. For the <strong>deep neural network</strong> examples, we will use the Keras library, with TensorFlow as the backend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Python language</h1>
                </header>
            
            <article>
                
<p>Python is a general-purpose scripting language, created by the Dutch programmer Guido Van Rossum in 1989. It possesses a very simple syntax with great extensibility, thanks to its numerous extension libraries, making it a very suitable language for prototyping and general coding. Because of its native C bindings, it can also be a candidate for production deployment.</p>
<p>The language is actually used in a variety of areas, ranging from web development to scientific computing, in addition to its use as a general scripting tool.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The NumPy library</h1>
                </header>
            
            <article>
                
<p>If we had to choose a definitive must-use library for use in this book, and a non-trivial mathematical application written in Python, it would have to be NumPy. This library will help us implement applications using statistics and linear algebra routines with the following components:</p>
<ul>
<li>A versatile and performant N-dimensional array object</li>
<li>Many mathematical functions that can be applied to these arrays in a seamless manner</li>
<li>Linear algebra primitives</li>
<li>Random number distributions and a powerful statistics package</li>
<li>Compatibility with all the major machine learning packages</li>
</ul>
<div class="packt_infobox">The NumPy library will be used extensively throughout this book, using many of its primitives to simplify the concept explanations with code.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The matplotlib library</h1>
                </header>
            
            <article>
                
<p>Data plotting is an integral part of data science and is normally the first step an analyst performs to get a sense of what's going on in the provided set of data.</p>
<p>For this reason, we need a very powerful library to be able to graph the input data, and also to represent the resulting output. In this book, we will use <span>Python's</span><span> </span><span>matplotlib library to describe concepts and the results from our models.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What's matplotlib?</h1>
                </header>
            
            <article>
                
<p>Matplotlib is an extensively used plotting library, especially designed for 2D graphs. From this library, we will focus on using the <kbd>pyplot</kbd> module, which is a part of the API of matplotlib and has MATLAB-like methods, with direct NumPy support. For those of you not familiar with MATLAB, it has been the default mathematical notebook environment for the scientific and engineering fields for decades.</p>
<p>The method <span>described</span><span> </span><span>will be used to illustrate a large proportion of the concepts involved, and in fact, the reader will be able to generate many of the examples in this book with just these two libraries, and using the provided code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pandas</h1>
                </header>
            
            <article>
                
<p><strong>Pandas</strong> <span>complements the previously mentioned libraries with a special structure, called <kbd>DataFrame</kbd>, and also adds many statistical and data mangling methods, such</span> as <span>I/O, for many different formats, such</span> as <span>slicing, subsetting, handling missing data, merging, and reshaping, among others.</span></p>
<p><span>The <kbd>DataFrame</kbd> object is one of the most useful features of the whole library, providing a special 2D data structure with columns that can be of different data types. Its structure is very similar to a database table, but immersed in a flexible programming runtime and ecosystem, such</span> as <span>SciPy. These data structures are also compatible with</span> NumPy matrices, so we can also apply high-performance operations to the data with minimal effort.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SciPy</h1>
                </header>
            
            <article>
                
<p><span><strong>SciPy</strong> is a stack of very useful scientific Python libraries, including</span> NumPy, pandas<span>,</span> matplotlib, a<span>nd others, but it also the core</span> library <span>of the ecosystem, with which</span> we <span>can also</span> perform <span>many additional fundamental mathematical operations, such as integration, optimization, interpolation, signal processing, linear algebra, statistics, and file I/O.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Jupyter notebook</h1>
                </header>
            
            <article>
                
<p><strong>Jupyter</strong> is a clear example of a successful Python-based project, and it's also one of the most powerful devices we will employ to explore and understand data through code.</p>
<p>Jupyter notebooks are documents consisting of intertwined cells of code, graphics, or formatted text, resulting in a very versatile and powerful research environment. All these elements are wrapped in a convenient web interface that interacts with the <strong>IPython</strong> interactive interpreter.</p>
<p>Once a Jupyter notebook is loaded, the whole environment and all the variables are in memory and can be changed and redefined, allowing research and experimentation, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="472" width="603" class=" image-border" src="assets/000a5a89-87d2-4089-858f-1acec71d359a.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Jupyter notebook</div>
<p>This tool will be an important part of this book's teaching process, because most of the Python examples will be provided in this format. In the last chapter of the book, you will find the full installation instructions.</p>
<div class="packt_tip">After installing, you can cd into the directory where your notebooks reside, and then call Jupyter by typing <kbd>jupyter notebook</kbd></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic mathematical concepts</h1>
                </header>
            
            <article>
                
<p>As we saw in the previous sections, this main target audience of the book is developers who want to understand machine learning algorithms. But in order to really grasp the motivations and reason behind them, it's necessary to review and build all the fundamental reasoning, which includes statistics, probability, and calculus.</p>
<p>We will first start with some of the fundamentals of statistics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Statistics - the basic pillar of modeling uncertainty</h1>
                </header>
            
            <article>
                
<p>Statistics can be defined as a discipline that uses data samples to extract and support conclusions about larger samples of data. Given that machine learning comprises a big part of the study of the properties of data and the assignment of values to data, we will use many statistical concepts to define and justify the different methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Descriptive statistics - main operations</h1>
                </header>
            
            <article>
                
<p>In the following sections, we will start defining the fundamental operations and measures of the discipline of statistics in order to be able to advance from the fundamental concepts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mean</h1>
                </header>
            
            <article>
                
<p>This is one of the most intuitive and most frequently used concepts in statistics. Given a set of numbers, the mean of that set is the sum of all the elements divided by the number of elements in the set.</p>
<p>The formula that represents the mean is as follows:</p>
<div style="padding-left: 180px"><img height="59" width="195" src="assets/2acf8cde-aeac-4554-b571-448bd799d28d.png"/></div>
<p>Although this is a very simple concept, we will write a Python code sample in which we will create a sample set, represent it as a line plot, and mark the mean of the whole set as a line, which should be at the weighted center of the samples. It will serve as an introduction to Python syntax, and also as a way of experimenting with Jupyter notebooks:</p>
<pre>    import matplotlib.pyplot as plt #Import the plot library <br/> <br/>    def mean(sampleset):  #Definition header for the mean function <br/>        total=0 <br/>        for element in sampleset: <br/>            total=total+element <br/>        return total/len(sampleset) <br/> <br/>    myset=[2.,10.,3.,6.,4.,6.,10.]  #We create the data set <br/>    mymean=mean(myset) #Call the mean funcion <br/>    plt.plot(myset)  #Plot the dataset <br/>    plt.plot([mymean] * 7)  #Plot a line of 7 points located on the mean </pre>
<p>This program will output a time series of the dataset elements, and will then draw a line at the mean height.</p>
<p>As the following graph shows, the mean is a succinct (one value) way of describing the tendency of a sample set:</p>
<div class="CDPAlignCenter CDPAlign"><img height="322" width="484" class=" image-border" src="assets/8d908460-8057-473d-a6b5-a311ad66e608.png"/></div>
<p>In this first example, we worked with a very homogeneous sample set, so the mean is very informative regarding its values. But let's try the same sample with a very dispersed sample set (you are encouraged to play with the values too):</p>
<div class="CDPAlignCenter CDPAlign"><img height="300" width="450" class=" image-border" src="assets/03c8e0c7-6e83-4148-91a1-950e3a2cf8ac.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variance</h1>
                </header>
            
            <article>
                
<p>As we saw in the first example, the mean isn't sufficient to describe non-homogeneous or very dispersed samples.</p>
<p>In order to add a unique value describing how dispersed the sample set's values are, we need to look at the concept of variance, which needs the mean of the sample set as a starting point, and then averages the distances of the samples from the provided mean. The greater the variance, the more scattered the sample set.</p>
<p>The canonical definition of variance is as follows:</p>
<div style="padding-left: 180px"><img height="61" width="188" src="assets/1539e143-9244-4fbc-8b57-d4cd167b3d52.jpg"/></div>
<p>Let's write the following sample code snippet to illustrate this concept, adopting the previously used libraries. For the sake of clarity, we are repeating the declaration of the <kbd>mean</kbd> function:</p>
<pre>    import math #This library is needed for the power operation <br/>    def mean(sampleset):  #Definition header for the mean function <br/>        total=0 <br/>        for element in sampleset: <br/>            total=total+element <br/>        return total/len(sampleset) <br/> <br/>    def variance(sampleset):  #Definition header for the mean function <br/>        total=0 <br/>        setmean=mean(sampleset) <br/>        for element in sampleset: <br/>            total=total+(math.pow(element-setmean,2)) <br/>        return total/len(sampleset) <br/> <br/>    myset1=[2.,10.,3.,6.,4.,6.,10.]  #We create the data set <br/>    myset2=[1.,-100.,15.,-100.,21.] <br/>    print "Variance of first set:" + str(variance(myset1)) <br/>    print "Variance of second set:" + str(variance(myset2)) <br/> </pre>
<p>The preceding code will generate the following output:</p>
<pre>    Variance of first set:8.69387755102<br/>    Variance of second set:3070.64</pre>
<p>As you can see, the variance of the second set was much higher, given the really dispersed values. The fact that we are computing the mean of the squared distance helps to really outline the differences, as it is a quadratic operation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Standard deviation</h1>
                </header>
            
            <article>
                
<p>Standard deviation is simply a means of regularizing the square nature of the mean square used in the variance, effectively linearizing this term. This measure can be useful for other, more complex operations.</p>
<p>Here is the official form of standard deviation:</p>
<div style="padding-left: 180px"><img height="63" width="178" src="assets/6c008034-4bb8-42ac-b591-761cca2cc4b6.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Probability and random variables</h1>
                </header>
            
            <article>
                
<p>We are now about to study the single most important discipline required for understanding all the concepts of this book.</p>
<p><strong>Probability</strong> is a mathematical discipline, and its main occupation is the study of random events. In a more practical definition, probability normally tries to quantify the level of certainty (or conversely, uncertainty) associated with an event, from a universe of possible occurrences.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Events</h1>
                </header>
            
            <article>
                
<p>In order to understand probabilities, we first need to define events. An event is, given an experiment in which we perform a determined action with different possible results, a subset of all the possible outcomes for that experiment.</p>
<p>Examples of events are a particular dice number appearing, and a product defect of particular type appearing on an assembly line.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Probability</h1>
                </header>
            
            <article>
                
<p>Following the previous definitions, probability is the likelihood of the occurrence of an event. Probability is quantified as a real number between <em>0</em> and <em>1</em>, and the assigned probability <em>P</em> increases towards <em>1</em> when the likelihood of the event occurring increases.</p>
<p>The mathematical expression for the probability of the occurrence of an event is <kbd>P(E)</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Random variables and distributions</h1>
                </header>
            
            <article>
                
<p>When assigning event probabilities, we could also try to cover the entire sample and assign one probability value to each of the possible outcomes for the sample domain.</p>
<p>This process does indeed have all the characteristics of a function, and thus we will have a random variable that will have a value for each one of the possible event outcomes. We will call this function a random function.</p>
<p>These variables can be of the following two types:</p>
<ul>
<li><strong>Discrete</strong>: If the number of outcomes is finite, or countably infinite</li>
<li><strong>Continuous</strong>: If the outcome set belongs to a continuous interval</li>
</ul>
<p>This probability function is also called <strong>probability distribution</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Useful probability distributions</h1>
                </header>
            
            <article>
                
<p>Between the multiple possible probability distributions, there are a number of functions that have been studied and analyzed for their special properties, or the popular problems they represent.</p>
<p>We will describe the most common ones that have a special effect on the development of machine learning.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bernoulli distributions</h1>
                </header>
            
            <article>
                
<p>Let's begin with a simple distribution: one that has a binary outcome, and is very much like tossing a (fair) coin.</p>
<p>This distribution represents a single event that takes the value <em>1</em> (let's call this <em>heads</em>) with a probability of <em>p</em>, and <em>0</em> (lets call this <em>tails</em>), with probability <em>1-p</em>.</p>
<p>In order to visualize this, let's generate a large number of events of a Bernoulli distribution using <kbd>np</kbd> and graph the tendency of this distribution, with the following only two possible outcomes:</p>
<pre class="CDPAlignCenter CDPAlign CDPAlignLeft">    plt.figure() <br/>    distro = np.random.binomial(1, .6, 10000)/0.5 <br/>    plt.hist(distro, 2 , normed=1) </pre>
<p class="mce-root CDPAlignLeft CDPAlign">The following graph shows the binomial distribution, through an histogram, showing the complementary nature of the outcomes' probabilities:</p>
<div class="CDPAlignCenter CDPAlign"><img height="296" width="444" class=" image-border" src="assets/90ea2658-e894-4b1f-9016-ad72cc77407b.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Binomial distribution</div>
<p>So, here we see the very clear tendency of the complementing probabilities of the possible outcomes. Now let's complement the model with a larger number of possible outcomes. When their number is greater than 2, we are talking about a <strong>multinomial distribution</strong>:</p>
<pre>    plt.figure()<br/>    distro = np.random.binomial(100, .6, 10000)/0.01 <br/>    plt.hist(distro, 100 , normed=1) <br/>    plt.show() </pre>
<p>Take a look at the following graph:</p>
<div class="CDPAlignCenter CDPAlign"><img height="294" width="440" class=" image-border" src="assets/7cc00694-f4b0-45f0-a2d8-6554080d226e.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Multinomial distribution with 100 possible outcomes</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uniform distribution</h1>
                </header>
            
            <article>
                
<p>This very common distribution is the first continuous distribution that we will see. As the name implies, it has a constant probability value for any interval of the domain.</p>
<p>In order to integrate to 1, <em>a</em> and <em>b</em> being the extreme of the function, this probability has the value of <em>1/(b-a)</em>.</p>
<p>Let's generate a plot with a sample uniform distribution using a very regular histogram, as generated by the following code:</p>
<pre>    plt.figure() <br/>    uniform_low=0.25 <br/>    uniform_high=0.8 <br/>                         <br/>    plt.hist(uniform, 50, normed=1) <br/>    plt.show() </pre>
<p class="mce-root"/>
<p>Take look at the following graph:</p>
<div class="CDPAlignCenter CDPAlign"><img height="289" width="434" class=" image-border" src="assets/755f4b86-a37b-4c05-a2e5-93f5ea2342ca.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Uniform distribution</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Normal distribution</h1>
                </header>
            
            <article>
                
<p>This very common continuous random function, also called a <strong>Gaussian</strong> <strong>function</strong>, can be defined with the simple metrics of the mean and the variance, although in a somewhat complex form.</p>
<p>This is the canonical form of the function:</p>
<div style="padding-left: 120px" class="mce-root"><img height="67" width="337" src="assets/42c42ced-bec7-4dea-a3dc-c6e1b45db226.png"/></div>
<p>Take a look at the following code snippet:</p>
<pre>    import matplotlib.pyplot as plt #Import the plot library <br/>    import numpy as np <br/>    mu=0. <br/>    sigma=2. <br/>    distro = np.random.normal(mu, sigma, 10000) <br/>    plt.hist(distro, 100, normed=True) <br/>    plt.show() </pre>
<p>The following graph shows the generated distribution's histogram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="303" width="454" class=" image-border" src="assets/2bf6938b-884e-466b-8614-8a4e8e50e1f3.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Normal distribution</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logistic distribution</h1>
                </header>
            
            <article>
                
<p>This distribution is similar to the normal distribution, but with the morphological difference of having a more elongated tail. The main importance of this distribution lies in its <strong>cumulative distribution function</strong> (<strong>CDF</strong>), which we will be using in the following chapters, and will certainly look familiar.</p>
<p>Let's first represent the base distribution by using the following code snippet:</p>
<pre>    import matplotlib.pyplot as plt #Import the plot library <br/>    import numpy as np <br/>    mu=0.5 <br/>    sigma=0.5 <br/>    distro2 = np.random.logistic(mu, sigma, 10000) <br/>    plt.hist(distro2, 50, normed=True) <br/>    distro = np.random.normal(mu, sigma, 10000) <br/>    plt.hist(distro, 50, normed=True) <br/>    plt.show() </pre>
<p>Take a look at the following graph:</p>
<div class="CDPAlignCenter CDPAlign"><img height="317" width="476" class=" image-border" src="assets/c2c191e4-ddfa-4cb1-97f0-0998f23f549b.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Logistic (red) vs Normal (blue) distribution</div>
<p>Then, as mentioned before, let's compute the CDF of the logistic distribution so that you will see a very familiar figure, the <strong>s</strong><strong>igmoid</strong> curve, which we will see again when we review neural network activation functions:</p>
<pre>    plt.figure() <br/>    logistic_cumulative = np.random.logistic(mu, sigma, 10000)/0.02 <br/>    plt.hist(logistic_cumulative, 50, normed=1, cumulative=True) <br/>    plt.show() </pre>
<p>Take a look at the following graph:</p>
<div class="CDPAlignCenter CDPAlign"><img height="271" width="407" class=" image-border" src="assets/1ec70b7c-685f-415f-8b2f-5c9d93534b79.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Inverse of the logistic distribution</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Statistical measures for probability functions</h1>
                </header>
            
            <article>
                
<p>In this section, we will see the most common statistical measures that can be applied to probabilities. The first measures are the mean and variance, which do not differ from the definitions we saw in the introduction to statistics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Skewness</h1>
                </header>
            
            <article>
                
<p>This measure represents the lateral deviation, or in general terms, the deviation from the center, or the symmetry (or lack thereof) of a probability distribution. In general, if skewness is negative, it implies a deviation to the right, and if it is positive, it implies a deviation to the left:</p>
<div style="padding-left: 180px"><img height="76" width="222" src="assets/3e8d2dbb-28e5-451c-988a-5b53640d8eb0.jpg"/></div>
<p>Take a look at the following diagram, which depicts the skewness statistical distribution:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="162" width="465" src="assets/6d684c1d-41fe-4475-a68e-60369d3965b7.jpg"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Depiction of the how the distribution shape influences Skewness.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kurtosis</h1>
                </header>
            
            <article>
                
<p><strong>Kurtosis</strong> gives us an idea of the central concentration of a distribution, defining how acute the central area is, or the reverse—how distributed the function's tail is.</p>
<p>The formula for kurtosis is as follows:</p>
<div style="padding-left: 180px"><img height="57" width="245" src="assets/1f87d984-ff69-4dea-8389-8830f0c69fee.png"/></div>
<p class="CDPAlignLeft CDPAlign">In the following diagram, we can clearly see how the new metrics that we are learning can be intuitively understood:</p>
<div class="CDPAlignCenter CDPAlign"><img height="162" width="467" src="assets/84c2ec98-3b71-4319-907f-03a7a2880f8a.jpg"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><span>Depiction of the how the distribution shape influences Kurtosis</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Differential calculus elements</h1>
                </header>
            
            <article>
                
<p>To cover the minimum basic knowledge of machine learning, especially the learning algorithms such as gradient descent, we will introduce you to the concepts involved in differential calculus.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preliminary knowledge</h1>
                </header>
            
            <article>
                
<p>Covering the calculus terminology necessary to get to gradient descent theory would take many chapters, so we will assume you have an understanding of the concepts of the properties of the most well-known continuous functions, such as <strong>linear</strong>, <strong>quadratic</strong>, <strong>logarithmic</strong>, and <strong>exponential</strong>, and the concept of <strong>limit</strong>.</p>
<p>For the sake of clarity, we will develop the concept of the functions of one variable, and then expand briefly to cover multivariate functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">In search of changes–derivatives</h1>
                </header>
            
            <article>
                
<p>We established the concept of functions in the previous section. With the exception of constant functions defined in the entire domain, all functions have some sort of value dynamics. That means that <em>f(x1)</em> is different than <em>f(x2)</em> for some determined values of <em>x</em>.</p>
<p>The purpose of differential calculus is to measure change. For this specific task, many mathematicians of the 17<span>th</span> century (Leibniz and Newton were the most prominent exponents) worked hard to find a simple model to measure and predict how a symbolically defined function changed over time.</p>
<p>This research guided the field to one wonderful concept—a symbolic result that, under certain conditions, tells you how much and in which direction a function changes at a certain point. This is the concept of a derivative.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sliding on the slope</h1>
                </header>
            
            <article>
                
<p>If we want to measure how a function changes over time, the first intuitive step would be to take the value of a function and then measure it at the subsequent point. Subtracting the second value from the first would give us an idea of how much the function changes over time:</p>
<pre>    import matplotlib.pyplot as plt <br/>    import numpy as np <br/>     %matplotlib inline <br/> <br/>    def quadratic(var): <br/>        return 2* pow(var,2) <br/>    x=np.arange(0,.5,.1) <br/>    plt.plot(x,quadratic(x)) <br/>    plt.plot([1,4], [quadratic(1), quadratic(4)],  linewidth=2.0) <br/>    plt.plot([1,4], [quadratic(1), quadratic(1)],  linewidth=3.0, <br/>    label="Change in x") <br/>    plt.plot([4,4], [quadratic(1), quadratic(4)],  linewidth=3.0, <br/>    label="Change in y") <br/>    plt.legend() <br/>    plt.plot (x, 10*x -8 ) <br/>    plt.plot() </pre>
<p>In the preceding code example, we first defined a sample quadratic equation (<kbd>2*x<sup>2</sup></kbd><em>)</em> and then defined the part of the domain in which we will work with the <kbd>arange</kbd> function (from <kbd>0</kbd> to <kbd>0.5</kbd>, in <kbd>0.1</kbd> steps).</p>
<p>Then, we define an interval for which we measure the change of <em>y</em> over <em>x</em>, and draw lines indicating this measurement, as shown in the following graph:</p>
<div class="CDPAlignCenter CDPAlign"><img height="240" width="353" class=" image-border" src="assets/7432239b-c655-45a9-815a-2c294b102e5f.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Initial depiction of a starting setup for implementing differentiation</div>
<p>In this case, we measure the function at <em>x=1</em> and <em>x=4</em>, and define the rate of change for this interval as follows:</p>
<div style="padding-left: 180px"><img height="51" width="179" src="assets/61be1ece-dea2-4591-b83d-236daf453cb7.png"/></div>
<p>Applying the formula, the result for the sample is <em>(36-0)/3= 12</em>.</p>
<p>This initial approach can serve as a way of approximately measuring this dynamic, but it's too dependent on the points at which we take the measurement, and it has to be taken at every interval we need.</p>
<p>To have a better idea of the dynamics of a function, we need to be able to define and measure the instantaneous change rate at every point in the function's domain.</p>
<p>This idea of instantaneous change brings to us the need to reduce the distance between the domain's <em>x</em> values, taken at a point where there are very short distances between them. We will formulate this approach with an initial value <em>x,</em> and the subsequent value, <em>x + Δx</em>:</p>
<div style="padding-left: 150px"><img height="57" width="260" src="assets/1d6ebb35-bc64-486f-a2b1-4db589e91d53.png"/></div>
<p>In the following code, we approximate the difference, reducing <em>Δx</em> progressively:</p>
<pre>    initial_delta = .1 <br/>    x1 = 1  <br/>    for power in range (1,6): <br/>        delta = pow (initial_delta, power) <br/>        derivative_aprox= (quadratic(x1+delta) - quadratic (x1) )/ <br/>        ((x1+delta) - x1 ) <br/>        print "del    ta: " + str(delta) + ", estimated derivative: " + <br/>        str(derivative_aprox)  </pre>
<p>In the preceding code, we first defined an initial delta, which brought an initial approximation. Then, we apply the difference function, with diminishing values of delta, thanks us to powering <kbd>0.1</kbd> with incremental powers. The results we get are as follows:</p>
<pre>    delta: 0.1, estimated derivative: 4.2 <br/>    delta: 0.01, estimated derivative: 4.02 <br/>    delta: 0.001, estimated derivative: 4.002 <br/>    delta: 0.0001, estimated derivative: 4.0002 <br/>    delta: 1e-05, estimated derivative: 4.00002 </pre>
<p>As the separation diminishes, it becomes clear that the change rate will hover around <kbd>4</kbd>. But when does this process stop? In fact, we could say that this process can be followed ad infinitum, at least in a numeric sense.</p>
<p>This is when the concept of limit intuitively appears. We will then define this process, of making Δ indefinitely smaller, and will call it the derivative of <em>f(x)</em> or <em>f'(x)</em>:</p>
<div style="padding-left: 120px"><img height="54" width="370" src="assets/c0827170-c744-4e24-b8ee-17285eaa90e8.png"/></div>
<p>This is the formal definition of the derivative.</p>
<p>But mathematicians didn't stop with these tedious calculations, making a large number of numerical operations (which were mostly done manually of the 17th century), and wanted to further simplify these operations.</p>
<p><em>What if we perform another step that can symbolically define the derivative of a function?</em></p>
<p>That would require building a function that gives us the derivative of the corresponding function, just by replacing the <kbd>x</kbd> variable value. That huge step was also reached in the 17th century, for different function families, starting with the parabolas <em>(y=x<sup>2</sup>+b)</em>, and following with more complex functions:</p>
<div class="CDPAlignCenter CDPAlign"><img height="366" width="532" src="assets/93726066-60a0-42c5-b785-d619a8c0c91e.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chain rule</h1>
                </header>
            
            <article>
                
<p>One very important result of the symbolic determination of a function's derivative is the chain rule. This formula, first mentioned in a paper by Leibniz in 1676, made it possible to solve the derivatives of composite functions in a very simple and elegant manner, simplifying the solution for very complex functions.</p>
<p>In order to define the chain rule, if we suppose a function <em>f</em>, which is defined as a function of another function <em>g</em>, <em>f(g(x))</em> of <em>F</em>, the derivative can be defined as follows:</p>
<div style="padding-left: 210px"><img height="59" width="148" src="assets/cd8487a6-80c2-4a93-a643-584234bbea8f.png"/></div>
<p>The formula of the chain rule allows us to differentiate formulas whose input values depend on another function. This is the same as searching the rate of change of a function that is linked to a previous one. The chain rule is one of the main theoretical concepts employed in the training phase of neural networks, because in those layered structures, the output of the first neuron layers will be the inputs of the following, giving, as a result, a composite function that, most of the time, is of more than one nesting level.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Partial derivatives</h1>
                </header>
            
            <article>
                
<p>Until now we've been working with univariate functions, but the type of function we will mostly work with from now on will be multivariate, as the dataset will contain much more than one column and each one of them will represent a different variable.</p>
<p>In many cases, we will need to know how the function changes in a relationship with only one dimension, which will involve looking at how one column of the dataset contributes to the total number of function changes.</p>
<p>The calculation of partial derivatives consists of applying the already known derivation rules to the multivariate function, considering the variables are not being derived as constant.</p>
<p>Take a look at the following power rule:</p>
<p class="CDPAlignCenter CDPAlign"><em>f(x,y) = 2x<sup>3</sup>y</em></p>
<p>When differentiating this function with respect to <em>x</em>, considering <em>y</em> a constant, we can rewrite it as <em>3 . 2 y x<sup>2</sup></em>, and applying the derivative to the variable <em>x</em> allows us to obtain the following derivative:</p>
<p class="CDPAlignCenter CDPAlign"><em>d/dx (f(x,y)) = 6y*x<sup>2</sup></em></p>
<p>Using these techniques, we can proceed with the more complex multivariate functions, which will be part of our feature set, normally consisting of much more than two variables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we worked through many different conceptual elements, including an overview of <span>some basic mathematical concepts</span>, which serve as a base for the machine learning concepts.</p>
<p>These concepts will be useful when we formally explain the mechanisms of the different modeling methods, and we encourage you to improve your understanding of them as much as possible, before and while reading the chapters, to better grasp how the algorithm works.</p>
<p>In the next chapter, we will have a quick overview of the the the complete workflow of a machine learning project, which will help us to understand the various elements involved, from data gathering to result evaluation.</p>
<p> </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>