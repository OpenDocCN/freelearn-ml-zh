- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing and Securing Access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have talked mostly about data, which is the basis of ML.
    But when it comes to security, there are other aspects we need to explore. Let
    us dive into identity and how we can manage access in Azure Machine Learning.
    As we embark on a journey through this chapter, we will first lay the groundwork
    by exploring the essence of the **principle of least privilege** (**PoLP**) and
    its importance. Although simple in theory, there are many things we need to consider
    before we start the implementation of Azure Machine Learning.
  prefs: []
  type: TYPE_NORMAL
- en: We will follow up by exploring all the identity features of Microsoft Entra.
    We will see authentication options available and how to work with permissions
    by implementing **role-based access control** (**RBAC**). We will see how to authenticate
    applications and services using managed identities and how to secure access using
    tools such as Key Vault. Finally, we will talk about how to automate the processes
    by using Conditional Access and **Privileged Identity Management** (**PIM**).
    The best practices in this chapter can be applied not only to Azure Machine Learning
    but to other services in Azure as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with the PoLP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating with Microsoft Entra ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing RBAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating with application identities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing access security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to apply access management
    effectively by implementing PoLP in Azure Machine Learning.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the PoLP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in [*Chapter 1*](B21076_01.xhtml#_idTextAnchor015) when we talked
    about the Zero Trust strategy, we learned about the PoLP, which states that users,
    devices, and applications should only be granted access to the minimum level of
    resources necessary to perform their job functions. Users are often given more
    access privileges to network resources and data, assuming they only access the
    resources required to perform their daily tasks. However, this tactic imposes
    a greater risk of unauthorized access. When users have access to resources they
    don’t need, attackers can take advantage of it. While providing just enough permissions
    to apps or users to complete their tasks sounds easy, the implementation can present
    some challenges. Creating overprivileged applications is never the intention,
    but usually the result of unplanned actions over time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Overprivileged applications** are software applications that have been granted
    more access rights, permissions, or privileges than they actually require to perform
    their intended tasks. An application is characterized as overprivileged if it
    includes unused as well as reducible permissions. Let us see some examples.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have an application that includes a user profile, where the user
    signs in and the application pulls all the information from the identity management
    system. The application’s usage has nothing to do with user profile updates and
    is just using the user’s profile information to get the manager or department
    information to complete other business tasks, so it does not include an **Edit
    profile** functionality. However, the application has the permissions needed to
    edit the profile information. This is an example of reducible permissions, where
    the application needs to read the data but not write in the system. Suppose that
    the same application also uses an API endpoint to get predictions from an ML model,
    and additionally has permissions to start or stop the Azure Machine Learning compute.
    This would be an example of unused permissions as the application has nothing
    to do with model training and the Azure Machine Learning compute.
  prefs: []
  type: TYPE_NORMAL
- en: It is tempting to include permissions to an application that will apply to future
    releases as we are often reluctant to modify deployed applications to avoid impacting
    their normal business operations. However, we must always consider the risks that
    accompany such decisions. Applying the PoLP is more of an iterative process than
    a rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us review some best practices before we dive into the implementations for
    Azure Machine Learning:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application inventory**: The first step is to keep an updated inventory of
    all applications in our organization. This includes both in-house developed applications
    and third-party applications and their required permissions. This can be part
    of our governance program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RBAC**: We can implement RBAC to define and assign roles that align with
    specific application functions. The best approach is to assign permissions based
    on the PoLP to ensure that applications only have the access they need and re-evaluate
    this access when appropriate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regular reviews**: We need to periodically review the permissions granted
    to applications and remove any unnecessary or unused permissions that could potentially
    be exploited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated tools**: It is always preferable to use automated tools to continuously
    analyze application permissions and identify overprivileged applications. These
    tools can provide insights into which permissions are actually being used and
    which can be revoked. For Azure, we can use Conditional Access policies and PIM
    as part of Microsoft Entra ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zero Trust architecture**: As mentioned in [*Chapter 1*](B21076_01.xhtml#_idTextAnchor015),
    applying a zero-trust architecture when possible, where applications are not automatically
    trusted based on their location or source, is always beneficial. We should always
    verify the identity and permissions of applications before granting access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous monitoring**: After any implementation, continuously monitor application
    behavior and access patterns. Detecting and investigating any unusual or unauthorized
    activities should be one of our priorities to identify any breaches as soon as
    possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Training and awareness**: We should never forget the human factor. Everyone
    from developers and IT staff to data scientists should be educated about the importance
    of preventing overprivileged applications. As part of our organization’s governance,
    we should provide guidelines for implementing secure access controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adhering to the PoLP is challenging as it requires a thorough understanding
    of user roles, responsibilities, and system interactions, and it is an iterative
    and continuous process. It can also become more complicated the more applications
    and systems we have. However, the security benefits it provides, by minimizing
    the potential impact of security breaches, make it an essential practice in any
    organization’s information security strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Let us explore how to implement the PoLP in Azure Machine Learning.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating with Microsoft Entra ID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Machine Learning uses **Microsoft Entra ID** (previously **Azure Active
    Directory** (**Azure AD**)) for authentication. Microsoft Entra ID is Microsoft’s
    cloud-based **identity and access management** (**IAM**) service. It’s designed
    to help organizations manage user identities and access to resources in the cloud
    and on-premises.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are logged in to the Azure portal, the same account is used to directly
    authenticate you to your Azure Machine Learning Studio session. So, anyone working
    on your ML project needs to be part of the Microsoft Entra ID workspace. That
    does not mean that only employees have access to the workspace. Microsoft Entra
    ID supports two types of users: members and guests. Members are users that are
    created within the Microsoft Entra ID tenant, while guests can be users that belong
    to other Microsoft Entra tenants or are personal accounts such as Outlook, Gmail,
    Hotmail, and so on. But as soon as you create or invite a user in your Microsoft
    Entra ID tenant, then you can assign them roles and treat them as part of your
    organization.'
  prefs: []
  type: TYPE_NORMAL
- en: Ways to authenticate using Microsoft Entra ID in Azure Machine Learning include
    interactive authentication directly with your account, the Azure CLI, service
    principals, and managed identities, which we will explore later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Entra ID is widely used across various industries and is an integral
    part of Microsoft’s cloud offerings, including Azure, Microsoft 365, and Dynamics
    365\. It’s a critical component for securing and managing access to cloud resources
    and ensuring that users have the appropriate level of access to applications and
    data while maintaining a high level of security.
  prefs: []
  type: TYPE_NORMAL
- en: Here is how we can use its security features to secure our Azure Machine Learning
    workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing RBAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RBAC is a built-in feature of Microsoft Entra ID that allows you to manage access
    to Azure resources using roles. This way, we can control who can perform specific
    actions on resources in Azure. This helps in maintaining a secure environment
    and ensures that users have only the permissions they need to perform their tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each role in RBAC is essentially a set of distinct permissions that operate
    in different scopes. We can assign a role to a management group, subscription,
    resource group, and resource. A role assignment at a higher scope is inherited
    by resources at a lower scope. For example, if we assign a role to a user at the
    subscription level, they will have those permissions across all resources within
    that subscription. Each role assignment in Azure has three distinct parts—the
    role, the scope, and the service principal, as we can see in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Role assignment](img/B21076_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Role assignment
  prefs: []
  type: TYPE_NORMAL
- en: The principle can be a user, a group of users, or a service principal such as
    an application or an Azure resource. We will explore service principals a little
    bit more later in the chapter when we talk about application identities and managed
    identities.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of roles: built-in and custom. Built-in roles are created
    by Azure, and we can assign them at any time. If they do not cover your needs,
    you can combine different roles to get the result you desire or create your own
    custom role to use with the service.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how we can assign or create RBAC roles specifically for Azure Machine
    Learning.
  prefs: []
  type: TYPE_NORMAL
- en: Working with built-in roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure offers over 400 built-in roles, such as **Virtual Machine Contributor**,
    **Storage Account Contributor**, and more. Each built-in role corresponds to specific
    scopes, actions, and services in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three roles that are a must-know and apply to all Azure services—the
    **Owner**, **Contributor**, and **Reader** roles. Here are their descriptions
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Core RBAC roles for Azure resources](img/B21076_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Core RBAC roles for Azure resources
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have Azure Machine Learning-specific roles that we need to be aware
    of. Here are descriptions of the most important roles we need to know when we
    are working with Azure Machine Learning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – RBAC roles for Azure Machine Learning](img/B21076_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – RBAC roles for Azure Machine Learning
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the roles have been built around specific employee roles and
    encompass certain tasks around data scientists or compute operators for ML. Of
    course, if you have a different structure in your organization, you can assign
    two roles to the same person and have them complete all the relevant tasks in
    Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Let us review how to work with role assignments.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a role assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As owners of the workspace, we can assign or remove roles to/from users and
    the workspace at any time using the Azure portal, the command-line tools, and
    even **Azure Resource Manager** (**ARM**) templates if we have complex assignments
    that we want to repeat. The process is simple. In every resource blade on the
    top left, we can see that there is an **Access control (****IAM)** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Azure Access control (IAM) menu](img/B21076_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Azure Access control (IAM) menu
  prefs: []
  type: TYPE_NORMAL
- en: From this blade, you can see existing role assignments and roles, and you can
    add or remove access to the resource. In this case, we have opened the **Subscription**
    blade, which means that any role assignments we change are going to be inherited
    by any resource groups and resources under this subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a role assignment, click the **Add** button on the top. Follow the three-step
    wizard to add your role assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to choose a role. For this example, I will choose **Reader**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Step 1: Choosing a role](img/B21076_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5 – Step 1: Choosing a role'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step is to choose members for the selected role. You can add multiple
    members by clicking the **Select** **members** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Step 2: Adding members](img/B21076_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6 – Step 2: Adding members'
  prefs: []
  type: TYPE_NORMAL
- en: That is it! The final step is to review and complete the assignment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want to use the command-line tools, here is an example in the CLI:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Role assignment documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'To view more options to assign roles using the Azure tools, follow the corresponding
    link to the tool of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: 'CLI: [https://learn.microsoft.com/en-us/azure/role-based-access-control/role-assignments-cli](https://learn.microsoft.com/en-us/azure/role-based-access-control/role-assignments-cli)'
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerShell: [https://learn.microsoft.com/en-us/azure/role-based-access-control/role-assignments-powershell](https://learn.microsoft.com/en-us/azure/role-based-access-control/role-assignments-powershell)'
  prefs: []
  type: TYPE_NORMAL
- en: 'REST API: [https://learn.microsoft.com/en-us/azure/role-based-access-control/role-assignments-rest](https://learn.microsoft.com/en-us/azure/role-based-access-control/role-assignments-rest)'
  prefs: []
  type: TYPE_NORMAL
- en: 'ARM templates: [https://learn.microsoft.com/en-us/azure/role-based-access-control/role-assignments-template](https://learn.microsoft.com/en-us/azure/role-based-access-control/role-assignments-template)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding role assignments is just one part of the story. Let us see how to review
    our existing assignments and remove them when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing and removing role assignments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The process to view and remove role assignments is just as simple. The first
    step is to visit the resource you want to check the role assignments for and open
    the **Access control (IAM)** menu. There, on the **Role assignments** tab, you
    can see existing role assignments, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Removing a role assignment](img/B21076_06_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Removing a role assignment
  prefs: []
  type: TYPE_NORMAL
- en: By clicking on the box on the left of the role assignment in the user list,
    the **Remove** button on the top is enabled. You can click **Remove** and **Confirm**
    to remove the assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with adding an assignment, you can use the command-line tools. Here is an
    example of removing an assignment using the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Role assignment documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'To view more options to remove role assignments using the Azure tools, follow
    this link: [https://learn.microsoft.com/en-us/azure/role-based-access-control/role-assignments-remove](https://learn.microsoft.com/en-us/azure/role-based-access-control/role-assignments-remove)'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in roles are not the only way to assign permissions. Let us review custom
    roles.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom role for Azure Machine Learning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The built-in roles are great, but sometimes they do not provide exactly what
    we need to properly restrict permissions of our users. In that case, we have the
    option of creating our own custom roles that have the exact permissions we need
    to complete the tasks necessary. A role is essentially a set of permissions. This
    set of permissions is described as a JSON file. You can find an example of the
    Contributor role in JSON format here: [https://learn.microsoft.com/en-us/azure/role-based-access-control/role-definitions-list](https://learn.microsoft.com/en-us/azure/role-based-access-control/role-definitions-list).'
  prefs: []
  type: TYPE_NORMAL
- en: Custom role overview
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about Azure custom role properties, see the information
    provided in this link: [https://learn.microsoft.com/en-us/azure/role-based-access-control/custom-roles](https://learn.microsoft.com/en-us/azure/role-based-access-control/custom-roles)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will not go into much detail on RBAC, but we will focus
    on how to create custom roles for the Azure Machine Learning service. If looking
    at that JSON file seems daunting, you do not have to worry. We can create our
    own custom role using the Azure portal. As done previously, we go onto the resource
    blade we want to assign a new role to and find the **Add** button. Click the Add
    button and then follow the **Add custom** **role** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Adding a custom role](img/B21076_06_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Adding a custom role
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom role wizard will pop up. The first step is to create a name for
    our role. In this case, I chose the name **AzureML Data Scientist Extended**,
    because my goal is to clone the existing role and simply add more permissions.
    You can, of course, start from scratch or from a saved JSON file. We then add
    a good description and we are ready to proceed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Filling in the basics](img/B21076_06_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Filling in the basics
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the **Permissions** tab, I see that this role has permissions in the
    workspace, but in the **Permission type** column is assigned with **NotAction**
    since we can see that *delete* and *write* actions in the workspace are prohibited.
    The **Action** section of the role describes what the role can do, and then **NotAction**
    describes what it cannot do. So, if I remove those permissions from **NotAction**,
    the role will be able to create and delete workspaces, which is what I want my
    data scientists to be able to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Working with permissions](img/B21076_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Working with permissions
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the result with the complete permissions list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Final permissions](img/B21076_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Final permissions
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, though, you might ask: What if I want to add permissions?
    Where do I find them? In the preceding screenshot, we can see the **+ Add permissions**
    button. From here, the process of adding permissions is very intuitive. When you
    want to add permissions, you do not need to scroll through an endless list or
    have the documentation at hand every time. You can simply filter to the service
    you want and see the relevant permissions. For Azure Machine Learning, we are
    interested in the **Machine Learning Services Resource Provider** or **Microsoft
    Machine Learning Web Services Management** permissions, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Adding permissions](img/B21076_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Adding permissions
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking on the relevant category, we can see a list of permissions together
    with their description, as we can see in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Viewing Azure Machine Learning permissions](img/B21076_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Viewing Azure Machine Learning permissions
  prefs: []
  type: TYPE_NORMAL
- en: This makes it very quick to create a custom role. You just need to ensure that
    you have included all the permissions needed and then you can come back to the
    **Permissions** page and review the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to set the assignable scope. You can change the **Assignable
    scopes** option to set the scope of this custom role at the subscription level,
    the resource group level, or a specific workspace level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21076_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Deciding on the scope
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can review and download the generated JSON or proceed to the final
    step to create the new custom role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Reviewing and creating/downloading](img/B21076_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Reviewing and creating/downloading
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have created the custom role, you can assign it just as with the
    built-in roles. You will find it on the **Roles** list in the **Access control
    (IAM)** menu with the **CustomRole** type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Finding your custom role](img/B21076_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – Finding your custom role
  prefs: []
  type: TYPE_NORMAL
- en: Azure RBAC
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn more about Azure RBAC here: [https://learn.microsoft.com/en-us/azure/role-based-access-control/overview](https://learn.microsoft.com/en-us/azure/role-based-access-control/overview)'
  prefs: []
  type: TYPE_NORMAL
- en: Azure RBAC is a crucial component for securing Azure resources and ensuring
    that only authorized users and applications have access. It plays a vital role
    in maintaining a secure, compliant, and well-managed Azure environment. Combining
    it with Azure Policy, Azure management groups, and Azure Blueprints, we have all
    the components needed for a complete governance framework.
  prefs: []
  type: TYPE_NORMAL
- en: RBAC – best practices
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some RBAC best practices to follow when assigning roles:'
  prefs: []
  type: TYPE_NORMAL
- en: Only grant the exact access users need
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrict the number of subscription owners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Microsoft Entra ID PIM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign roles to groups, not individual users, so that permissions are inherited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign roles using the unique role ID instead of the role name, in case the
    role is renamed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using wildcards when working with custom roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RBAC is not only about the users. Microsoft Entra ID is also used to authenticate
    users and applications. Let us see how we can work with those identities in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating with application identities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application identities are a fundamental concept in Microsoft Entra ID IAM.
    They represent the security context of an application or service when interacting
    with Azure resources. Typically, the underlying object is the service principal.
    A service principal is like a user identity but is used by applications, services,
    or scripts to authenticate and access Azure resources securely. The process of
    creating a service principal depends on what it is we want to use to authenticate,
    and mostly, we can recognize two types—application identities and managed identities
    used by Azure services.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to authentication and authorization in the application or managed
    identity, the process is the same. If it exists in Microsoft Entra ID, it can
    be assigned RBAC, as with any user in the system. Service principals have life
    cycles, just as with user identities. They can be created, updated, and deleted.
    For standalone Azure AD applications, service principals can use client secrets/passwords
    or certificates for authentication. Client secrets should be stored securely,
    while certificates provide an added layer of security. Microsoft Entra ID applications
    can be configured as single tenant (only accessible in one Microsoft Entra ID
    tenant) or multi-tenant (accessible by users and applications from multiple Microsoft
    Entra ID tenants). Multi-tenant apps often require additional configuration to
    handle identity federation.
  prefs: []
  type: TYPE_NORMAL
- en: Let us review how we can create and work with service principals next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service principal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to authenticate when working with applications or scripts that train
    and test a model, for example, you can use service principal authentication. To
    achieve this, we need to create a service principal in the Microsoft Entra ID
    workspace. If you are creating a service principal, you need to create an application
    registration.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see both ways of achieving this.
  prefs: []
  type: TYPE_NORMAL
- en: Using the CLI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Depending on where you are running the command, you might need to authenticate
    your Azure subscription. Run the commands through Cloud Shell so that there is
    no need. The command to create a service principal is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will include several values that we must protect as they serve as
    credentials, but we must ensure to save them so that we can use them in our code
    to retrieve an authentication token. These are `clientId`, `clientSecret`, and
    `tenantId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Service principal creation result](img/B21076_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – Service principal creation result
  prefs: []
  type: TYPE_NORMAL
- en: 'You can retrieve more information about the service principal using the portal
    or the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have created a service principal, we can use it in our code and
    assign more roles if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Registering an application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The CLI is not the only way to create a service principal. Another way is to
    use the portal. Open the Microsoft Entra ID workspace and find the **App registrations**
    menu. In the following screenshot, you can see a list of existing service principals,
    including the service principal we created in the previous section using the CLI.
    You can find the necessary IDs and information using the portal from here as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – App registrations](img/B21076_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – App registrations
  prefs: []
  type: TYPE_NORMAL
- en: 'To proceed from here, click the **New registration** button. Fill in the details,
    giving the application a name and indicating what kinds of accounts can use this.
    For this example, we will keep the defaults and click **Register**, as we can
    see in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Creating a new registration](img/B21076_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – Creating a new registration
  prefs: []
  type: TYPE_NORMAL
- en: 'Your registration is complete. As soon as we click **Register**, the application
    registration page will open, and we can configure multiple options, as seen in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20 – Creating a new registration](img/B21076_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – Creating a new registration
  prefs: []
  type: TYPE_NORMAL
- en: By opening up an app registration, you can configure options such as client
    certificates and secrets, as well as roles and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: But what about services? How does the workspace authenticate a **virtual machine**
    (**VM**) that wants to connect to the workspace? This is where managed identities
    come in. Let us see how managed identities work and how we can use everything
    we have seen so far to authenticate in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Working with managed identities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Managed identities in Azure are a way to securely authenticate and authorize
    applications and services within the Azure ecosystem. They are a fundamental part
    of Azure’s IAM capabilities and are used to authorize themselves when interacting
    with other Azure services and resources. This eliminates the need to store sensitive
    credentials or secrets in code or configuration files, making the application
    more secure. Managed identities can be used with a wide range of Azure services,
    including Azure Virtual Machines, Azure Storage accounts, Azure Key Vault, Azure
    Machine Learning, and more. They can be assigned specific roles and permissions
    in Azure RBAC. This means you can control which actions and resources the identity
    can access within your Azure environment. We can easily use managed identities
    in our applications or scripts by leveraging the Azure Machine Learning libraries
    and SDKs available, as we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Each Azure resource that supports managed identities has a specific way of enabling
    and using them. There are two types of managed identities. Let us review the differences
    between the two.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling a system-assigned managed identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This type of identity is created and managed by Azure for a specific Azure resource,
    such as a VM or an Azure function. It’s tightly bound to the life cycle of the
    resource it’s associated with, meaning when the resource is deleted, the managed
    identity is deleted along with it and cannot be associated with multiple resources.
    To work with system-assigned managed identities, you simply enable them on your
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable a system-assigned managed identity, we simply need to find the **Identity**
    menu, as shown in the following screenshot, in the resource blade of our choice,
    set the **Status** toggle to **On**, and click on **Save**. For this example,
    I have chosen a VM, but it is supported in multiple Azure resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Opening the Identity menu](img/B21076_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – Opening the Identity menu
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as we have enabled the system-assigned managed identity, we can use
    RBAC and assign roles or disable it by setting the **Status** toggle to **Off**.
    You can see the enabled system-assigned managed identity in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22 – System-assigned managed identity enabled](img/B21076_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.22 – System-assigned managed identity enabled
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user-assigned managed identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This type of identity is created and managed as a standalone Azure resource.
    You can then associate it with one or more Azure resources, allowing multiple
    resources to use the same identity. This is very useful when, for example, the
    life cycle of the managed identity needs to be independent of the resource life
    cycle or multiple resources need to share the same permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a managed identity is a two-step process. First, we need to create
    a managed identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, open the **Managed Identities** menu from the search box on the
    top and click on **Create**. Fill in some basic details, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – Creating a user-assigned managed identity](img/B21076_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.23 – Creating a user-assigned managed identity
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as the identity is created, we can associate it with many resources.
    As previously, we will find the **Identity** menu in the resource blade, but this
    time we will switch to the **User assigned** tab. Then, we can click on the **Add**
    button and filter our identities, and as soon as we find the one we created previously,
    we can associate it with the resource. You can see the portal for these steps
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24 – Associating the user-assigned managed identity](img/B21076_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.24 – Associating the user-assigned managed identity
  prefs: []
  type: TYPE_NORMAL
- en: Managed identities can also be created or enabled using other Azure tools such
    as the CLI, PowerShell, or the REST API. Then, they can be used from scripts or
    other Azure services we want to connect to. We can enable, disable, or disassociate
    them from our resources at any time.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, Microsoft Entra ID managed identities are a way to improve the security
    and management of authentication and authorization for Azure resources by eliminating
    the need for storing credentials and providing seamless integration with Azure
    services. They help developers and administrators ensure the security and compliance
    of their Azure workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Here is how we can set up authentication using the different identities available.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can simplify the authentication process by using the `DefaultAzureCredential`
    class from the Azure Identity package for Python. This class automatically chooses
    the appropriate authentication method (such as Managed Identity, Service Principal,
    or interactive login) based on the environment it’s running in. Here’s how we
    can use it for both managed identity and service principal scenarios
  prefs: []
  type: TYPE_NORMAL
- en: When connecting with a service principal, we need to provide three environment
    variables and use the values when authenticating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the variables—they can all be found in the object returned when we
    created the service principal:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AZURE_CLIENT_ID` : The ID of the client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AZURE_TENANT_ID`: The Microsoft Entra ID tenant ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AZURE_CLIENT_SECRET`: The credential secret'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To set these variables, you can use the `python-dotenv` package.
  prefs: []
  type: TYPE_NORMAL
- en: Identity libraries
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out more about the libraries, see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/python/api/overview/azure/identity-readme?view=azure-python](https://learn.microsoft.com/en-us/python/api/overview/azure/identity-readme?view=azure-python)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pypi.org/project/python-dotenv/](https://pypi.org/project/python-dotenv/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are using a managed identity, the class will automatically detect the
    credentials, and there is no need for environment variables. Here is a code sample
    for both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After this code, you can write your desired code to work with Azure Machine
    Learning and train your models.
  prefs: []
  type: TYPE_NORMAL
- en: Working with application identities helps us greatly ensure that we have consistency
    across roles and secure our ML assets. Now that we have reviewed our authentication
    and role management options, let us review some other services that complement
    this functionality and help us secure our workloads further.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing access security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a better idea of how to leverage Microsoft Entra ID for authentication
    and role management, we can see some other services that we can use to complement
    and further secure our users’ identities.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Conditional Access** in Microsoft Entra ID is a powerful feature that allows
    organizations to set specific conditions and policies for granting or denying
    access to their cloud-based resources. With **Conditional Access**, you can create
    rules and policies that consider a range of factors before allowing or blocking
    access, enhancing security and compliance.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conditional Access** policies are rules that you define to control access
    to your protected resources. These policies are based on conditions and can be
    tailored to specific users, groups, applications, IP location information, user
    or sign risk detection, and devices. The action based on those signals is either
    **Block/Allow**. You can combine multiple conditions based on different scenarios
    that apply to your organization and users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some examples of policies that are used commonly:'
  prefs: []
  type: TYPE_NORMAL
- en: Requiring for **multi-factor authentication** (**MFA**) to be enabled for users
    with highly privileged roles or from unrecognized locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking users that are flagged by the system as high risk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing or blocking access from specific IPs or countries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requiring a password change to allow access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the **Overview** blade of **Conditional Access** where you can manage
    policies, locations, networking, and other features:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.25 – Conditional Access Overview blade](img/B21076_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.25 – Conditional Access Overview blade
  prefs: []
  type: TYPE_NORMAL
- en: '**Conditional Access** in Microsoft Entra ID is a dynamic and flexible tool
    that helps organizations strike a balance between security and user productivity.
    By setting up policies that consider different factors, we can enforce access
    controls that adapt to the changing security landscape and the needs of your organization.'
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only tool we can use to enhance security. Let us see how we
    can use PIM together with RBAC.
  prefs: []
  type: TYPE_NORMAL
- en: PIM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft Entra ID PIM is an Azure service that helps organizations manage,
    control, and monitor access within their Azure AD and other Microsoft Online services.
    It focuses on privileged accounts, which have access to critical resources and
    data. PIM provides features and capabilities to help organizations protect these
    privileged accounts and mitigate security risks.
  prefs: []
  type: TYPE_NORMAL
- en: PIM can be used in conjunction with RBAC to enhance the security and management
    of privileged accounts and access to Azure resources. When used together, PIM
    and RBAC provide a comprehensive approach to managing access to Azure resources,
    especially those that require elevated privileges. We can enable **just-in-time**
    (**JIT**) and time-bound access for users assigned to specific RBAC roles. For
    example, if a user needs **Contributor** access to a resource group, Azure PIM
    allows them to activate this role only when necessary and for a defined duration.
    When a user needs to activate an RBAC role, they initiate a request through the
    Azure PIM interface by providing a valid justification. This request goes through
    an approval process, ensuring that activation is authorized by an appropriate
    administrator or role owner. The user specifies the duration, and access is automatically
    revoked when the specified time period expires, reducing the risk of prolonged
    elevated access.
  prefs: []
  type: TYPE_NORMAL
- en: Azure PIM logs all activations and deactivations of RBAC roles, providing audit
    trails for compliance and security purposes. Organizations can regularly review
    and certify the continued need for privileged access through access reviews. This
    process helps ensure that users who have been assigned RBAC roles still require
    them, and that access remains aligned with business needs.
  prefs: []
  type: TYPE_NORMAL
- en: By combining Azure PIM and RBAC, organizations can strengthen their IAM strategy
    for Azure resources. This approach minimizes risks associated with persistent,
    overprivileged accounts, and helps organizations maintain control, visibility,
    and compliance while managing access to critical Azure services and data.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Key Vault
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Azure Key Vault is a cloud service provided by Microsoft Azure that helps you
    securely manage keys, secrets, certificates, and other sensitive information used
    by your applications and services. It is designed to provide a centralized and
    secure location for storing and managing cryptographic keys and other secrets,
    making it easier to adhere to security best practices and compliance requirements.
    Here is some information about its features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key management**: Azure Key Vault allows us to generate, import, and manage
    cryptographic keys used for encryption, decryption, and authentication. It supports
    various key types, including **Rivest–Shamir–Adleman** (**RSA**), **Advanced Encryption
    Standard** (**AES**), and elliptic curve keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secrets management**: We can use Azure Key Vault to store and manage secrets,
    such as connection strings, API keys, and passwords. These secrets are stored
    securely and can be accessed programmatically by your applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certificate management**: Key Vault enables the management of X.509 certificates
    and automates tasks such as certificate renewal. It also supports integration
    with Azure services such as Azure Application Gateway and **Azure Kubernetes Service**
    (**AKS**) for SSL/TLS certificate management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To retrieve keys or secrets, instead of hardcoding the secrets, we authenticate
    to Key Vault to retrieve them. This adds another layer of security, and we can
    revoke access easily at any time and have additional security options such as
    key versioning, logging, backup, purge protection, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Best practice
  prefs: []
  type: TYPE_NORMAL
- en: Combine the Azure Key Vault service with managed identities for maximum security.
  prefs: []
  type: TYPE_NORMAL
- en: For Azure Machine Learning, we can combine the Azure Key Vault service with
    managed identities to retrieve secrets in our scripts. All we need is the Azure
    Key Vault Secrets client library for Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started, we need to make sure we have the following prerequisites
    along with our workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: An Azure Key Vault resource with the secret value we want to retrieve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A compute cluster with a managed identity enabled and assigned with the proper
    RBAC roles or access policies in Azure Key Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `azure-keyvault-secrets` and `azure-identity` packages installed in our
    Azure Machine Learning environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have all the prerequisites completed, you can retrieve the secret using
    the following code sample. Just ensure you replace the key vault name with yours
    and the secret name with yours:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Conditional Access** and PIM are both Microsoft Entra ID features that, when
    enabled, provide additional security to our identities and keep our user credentials
    secure and in accordance with the PoLP. Azure Key Vault is a critical component
    in building secure and compliant applications in the Azure cloud environment,
    especially when you combine it with managed identities. These features might be
    optional, but they need to be considered when working to secure our ML projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on all aspects of identity and adhering to the PoLP.
    Although simple in theory, the PoLP is an iterative and continuous process that
    we need to monitor in order to prevent overprivileged applications. Since Microsoft
    Entra ID is the identity management tool for Azure and, by extension, Azure Machine
    Learning, implementing its core features such as RBAC and learning to work with
    application identities will help us ensure that the credentials of our users and
    applications will not be compromised easily. Additionally, implementing features
    such as **Conditional Access** and PIM can provide an additional level of security
    to our identities. But these credentials are not the only ones that matter. In
    our scripts, we might be using different connection strings or secrets. We can
    use the Key Vault service together with managed identities where it is possible
    to manage them centrally and ensure that our secrets are safe.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore everything to do with our workspace security
    and the underlying infrastructure. We will learn how to secure our compute and
    endpoints and take advantage of any existing Azure infrastructure such as networks
    for added security.
  prefs: []
  type: TYPE_NORMAL
