- en: Chapter 10. Big Data and IoT
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 大数据和物联网
- en: Up to this point, this book has followed a pattern of extracting data, cleaning
    and shaping the data, and then building machine learning models. A common element
    in all of the examples is that when we've extracted data, we have brought it from
    the server (or other external sources) locally to our machine. This means our
    analysis is confined to whatever data fits in the memory on our local machines.
    While this is good for small- and medium-sized datasets, there are plenty of datasets
    and questions that do not fit in RAM. The last couple of years have seen the rise
    of big data, where we can ask questions of datasets that are too large, unstructured,
    or fast-moving to be analyzed using our conventional machine learning techniques.
    One domain that fits well with big data is the proliferation of small, inexpensive
    devices that can send a vast quantity of data to a server for analysis. These
    **Internet of Things** (**IoT**) devices have the potential to reshape the world
    around us in ways that typical computers and smartphones cannot. In this chapter,
    let's run though a potential big data and the Internet of Things scenario at AdventureWorks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这本书遵循了一种提取数据、清洗和塑形数据，然后构建机器学习模型的模式。所有示例的共同点是，当我们提取数据时，我们已经将它从服务器（或其他外部来源）本地带到我们的机器上。这意味着我们的分析仅限于适合我们本地机器内存中的数据。虽然这对于小型和中型数据集来说很好，但还有很多数据集和问题不适合RAM。在过去的几年里，大数据的兴起，我们可以对太大、无结构或快速移动的数据集提出问题，这些数据集无法使用我们传统的机器学习技术进行分析。与大数据很好地匹配的一个领域是小型、低成本设备的大量涌现，这些设备可以将大量数据发送到服务器进行分析。这些**物联网**（**IoT**）设备有可能以典型计算机和智能手机无法实现的方式重塑我们周围的世界。在本章中，让我们在AdventureWorks中运行一个潜在的大数据和物联网场景。
- en: AdventureWorks and the Internet of Bikes
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AdventureWorks和物联网
- en: 'One day you are sitting in your office, your boss comes in and says, "Since
    you did such a great job on helping reduce our scrap rate, we would like you to
    work on a proof of concept with our research and development department. Last
    month, the management team went to a conference about the Internet of Things and
    we think we have an interesting use case: the **Internet of Bikes** (**IoB**).
    We are going to put sensors on a bike model that can read certain diagnostic information
    about the bike and its riding patterns. We think that a certain segment of our
    customers would love to have a "smart bike".'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有一天，你坐在办公室里，你的老板走进来说：“自从你在帮助我们降低废品率方面做得如此出色，我们希望你能和我们的研发部门一起工作，做一个概念验证。上个月，管理团队参加了一个关于物联网的会议，我们认为有一个有趣的应用案例：**物联网自行车**（**IoB**）。我们打算在一种可以读取自行车及其骑行模式某些诊断信息的自行车型号上安装传感器。我们认为我们的一部分客户会非常喜欢“智能自行车”。
- en: 'You head over to the research and development area, where they have tricked
    out a bike like this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你前往研发区域，他们已经将一辆自行车改装成这样：
- en: Tire pressure sensors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮胎压力传感器
- en: Speedometer sensor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度表传感器
- en: Gear sensor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度传感器
- en: A Raspberry Pi 2 mounted under the seat
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装在座椅下的Raspberry Pi 2
- en: A wireless Ethernet shield attached to the PI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到PI的无线以太网盾
- en: A GPS shield attached to the PI![AdventureWorks and the Internet of Bikes](img/00155.jpeg)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到PI的GPS盾![AdventureWorks和物联网](img/00155.jpeg)
- en: The head of the R&D department tells you, "We are trying to find cost-effective
    wireless sensors. Until then, we are stringing wires through the frame's tube
    to the PI. We initially thought of using the bike rider's phone as the CPU, but
    we went with the PI because it is less bulky and weighs much less than a phone—bike
    riders are very concerned about weight. The PI gets its power from a rechargeable
    battery and when the bike gets docked at home to recharge, all of its on-board
    data is uploaded to our servers at that time. We want to transmit data from the
    PI to our servers only at the bike's home for security reasons and so the riders
    are not hit with data plan limitations by using cell networks."
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 研发部门的负责人告诉你：“我们正在寻找成本效益高的无线传感器。在此之前，我们正在通过车架的管子将电线连接到PI。我们最初考虑使用骑行者的手机作为CPU，但最终选择了PI，因为它体积更小，重量也比手机轻得多——骑行者非常关心重量问题。PI从可充电电池中获取电力，当自行车在家充电时，所有车载数据都会在那个时间上传到我们的服务器。出于安全原因，我们只想在自行车在家时从PI向服务器传输数据，这样骑行者就不会因为使用蜂窝网络而受到数据计划限制。”
- en: The head of R&D continues, "We envision a dashboard for people to keep track
    of their cycling route, their biking habits, and whatnot. Where you come in is
    on the machine learning piece. We need a way of analyzing these huge amounts of
    data we are going to collect to provide an enhanced customer experience when they
    are riding this bike."
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 研发部门负责人继续说：“我们设想了一个仪表板，让人们可以跟踪他们的骑行路线、骑行习惯等等。您的角色在于机器学习部分。我们需要一种方法来分析我们将要收集的大量数据，以便在骑行时为用户提供增强的客户体验。”
- en: Data considerations
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据考虑因素
- en: You look at the data (called telemetry) coming from the bike as two different
    problems. Problem one is getting the data to the server from individual bikes
    and problem two is having the data in a format that allows for machine learning
    on a large scale. You decide to solve both those problems by using the Microsoft
    Azure IoT suite to stream the data from the bikes into the current Northwind SQL
    Azure database. You add a table called `telemetry` and add a foreign key to `PurchaseOrderHeader`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您将来自自行车的数据（称为遥测数据）视为两个不同的问题。问题一是将数据从单个自行车传输到服务器，问题二是拥有一种格式，允许在大规模上进行机器学习。您决定通过使用Microsoft
    Azure IoT套件将自行车的数据流式传输到当前的Northwind SQL Azure数据库来解决这两个问题。您添加了一个名为`telemetry`的表，并将外键添加到`PurchaseOrderHeader`。
- en: You then populate the table with some data from riders in the AdventureWorks
    Early Adopter program. Although there is not much data in the table to start,
    it is expected to grow rapidly. The level of atomacy of the table is a single
    reading that occurs about every second. That means for a 30-minute bike ride,
    we capture 1,800 rows of data. Since we have about 200 bike riders in our early
    adopter program, we will generate about 360,000 rows of data every time they take
    a ride. This one ride generates about as much data as the current AdventureWorks
    database maintains for the entire company. After one month of data where these
    bikers go out about every other day, we will have 5.4 million rows of data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您接下来将一些来自AdventureWorks早期采用者计划中的骑行者的数据填充到表格中。虽然表格开始时数据不多，但预计会迅速增长。表格的原子级别是每秒大约发生一次的单次读取。这意味着对于30分钟的骑行，我们捕获了1,800行数据。由于我们早期采用者计划中有大约200名骑行者，每次他们骑行时，我们将生成大约360,000行数据。一次骑行生成的数据量几乎与当前AdventureWorks数据库为公司维护的全部数据量相当。在一个月的时间里，这些骑行者每隔一天就出去骑行，我们将拥有5,400,000行数据。
- en: One of the data elements that we are capturing is latitude and longitude. Fortunately,
    all of our bike riders live in Enderlin, North Dakota, and all travel on the straightest
    road in the United States, Highway 46 ([https://en.wikipedia.org/wiki/North_Dakota_Highway_46_(54st_SE)](https://en.wikipedia.org/wiki/North_Dakota_Highway_46_(54st_SE))).
    This means our longitude does not change. Also, we are capturing feet per second
    as a speed gauge so we can easily compare how riders perform against each other.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在捕获的数据元素之一是纬度和经度。幸运的是，我们所有的骑行者都住在北达科他州的Enderlin，并且都在美国最直的公路上骑行，即46号公路([https://en.wikipedia.org/wiki/North_Dakota_Highway_46_(54st_SE)](https://en.wikipedia.org/wiki/North_Dakota_Highway_46_(54st_SE))).
    这意味着我们的经度不会改变。此外，我们正在以英尺每秒作为速度计来捕获速度，这样我们可以轻松地比较骑行者之间的表现。
- en: With the data in place, let's take a look at how to analyze data at scale.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数据就绪后，让我们看看如何进行大规模数据分析。
- en: MapReduce
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MapReduce
- en: 'Open Visual Studio and create a new Visual F# Windows Library called `AdventureWorks.IOB`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Visual Studio并创建一个新的Visual F# Windows库，命名为`AdventureWorks.IOB`：
- en: '![MapReduce](img/00156.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![MapReduce](img/00156.jpeg)'
- en: 'Go into the NuGet Package Manager Console and enter this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 进入NuGet包管理器控制台并输入以下内容：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, rename `script1.fsx` to `MapReduce.fsx`. Now, enter in the same code
    from [Chapter 5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "Chapter 5. Time Out – Obtaining Data"), *Time Out – Obtaining Data*, that created
    a k-NN:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`script1.fsx`重命名为`MapReduce.fsx`。现在，输入来自[第5章](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "第5章。时间到 – 获取数据")的相同代码，*时间到 – 获取数据*，该代码创建了一个k-NN：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Sending this to the FSI gives us the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到FSI，我们得到以下结果：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice this line:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这一行：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We called `knn.Compute` to do a calculation on a single input after the k-NN
    model was created.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`knn.Compute`在创建k-NN模型后对单个输入进行计算。
- en: This works well enough or a single calculation, but what if we want to do thousands
    of calculations? For example, let's call `knn.Compute()` on 250,000 random samples.
    After we finish all 250,000 calculations, let's add up the results and then divide
    that total by the number of observations and see if the dataset is biased towards
    a particular category.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个计算来说，这已经足够好了，但如果我们要进行数千次计算呢？例如，让我们在250,000个随机样本上调用`knn.Compute()`。完成所有250,000次计算后，让我们将结果相加，然后将总数除以观察次数，看看数据集是否偏向特定类别。
- en: 'First, let''s create a function that will create a random input:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个函数来创建随机输入：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Sending this to the FSI gives us the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到FSI将给我们以下结果：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, let''s create an array of 250,000 items and populate it with the random
    values:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个包含250,000个项目的数组并用随机值填充它：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Sending this to the REPL gives us the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL将给我们以下结果：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With our data ready, let''s do our calculation. I added a timer to give us
    an idea of the performance hit for running 250,000 records:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 数据准备就绪后，让我们进行计算。我添加了一个计时器，以给我们一个运行250,000条记录的性能影响的印象：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Sending this to the FSI will give us the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到FSI将给我们以下结果：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The interesting piece of code is this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的代码片段如下：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that we are mapping and reducing. Mapping is old hat to you by now,
    but you might not be familiar with reducing. Reduce is a high-ordered function
    that takes in two parameters: an accumulator and a value. Both parameters are
    of the same type (in this case, `int`). What reduce is doing is going through
    each of the items of the array and applying a function. It then takes the results
    of that calculation and adds it to the accumulator. In this case, the accumulator
    `acc` is added to the value from the `array (i)`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在进行映射和归约。映射对你来说已经是老生常谈了，但你可能对归约不太熟悉。归约是一个高阶函数，它接受两个参数：一个累加器和一个值。这两个参数是同一类型（在这种情况下，`int`）。归约所做的是遍历数组中的每个项目并应用一个函数。然后，它将计算结果添加到累加器中。在这种情况下，累加器`acc`被添加到`array
    (i)`的值中。
- en: 'Visually, this looks like the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，它看起来如下：
- en: '![MapReduce](img/00157.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![MapReduce](img/00157.jpeg)'
- en: You might have heard the expression map/reduce used in the context of big data.
    That's because some of the pioneers in big data analytics such as Google and Yahoo
    created Hadoop based on the concept of map/reduce. Hadoop is a platform for big
    data, including a filesystem (HDFS), query languages (Hive and PIG), and machine
    learning (Mahdut). Typically, when you hear people talking about Hadoop and map/reduce,
    they are talking about a specialized implementation using key/value pairs. Also,
    usually the *map* part of map/reduce is distributed across thousands of commodity
    machines. The *reduce* can be distributed depending on the nature of the function
    that is passed to reduce. If the function does a `groupBy` or some other calculation
    on a section of the entire dataset, it can be distributed. In this chapter, we
    are going to distribute map and are not going to distribute reduce.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过在大数据背景下使用的map/reduce表达式。这是因为大数据分析的一些先驱，如Google和Yahoo，基于map/reduce的概念创建了Hadoop。Hadoop是一个大数据平台，包括文件系统（HDFS）、查询语言（Hive和PIG）和机器学习（Mahdut）。通常，当人们谈论Hadoop和map/reduce时，他们是在谈论一个使用键/值对的特殊实现。此外，map/reduce的*map*部分通常分布在一千台通用机器上。*reduce*可以根据传递给reduce的函数的性质进行分布。如果函数在数据集的某个部分上执行`groupBy`或其他计算，它就可以进行分布。在本章中，我们将分布map，但不会分布reduce。
- en: 'To illustrate why map/reduce is popular for big data, let''s distribute the
    mapping across all of the cores on my machine. This can simulate the way Hadoop
    distributes processing across thousands of networked computers. Go into Visual
    Studio and open the NuGet Package Manager and enter this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明为什么map/reduce在大数据中很受欢迎，让我们将映射分布到我的机器上的所有核心。这可以模拟Hadoop如何在成千上万的联网计算机之间分配处理。进入Visual
    Studio并打开NuGet包管理器，输入以下内容：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, go into `MapReduce.fsx` and enter this at the bottom:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进入`MapReduce.fsx`并在底部输入以下内容：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Sending this to the FSI gives us the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到FSI将给我们以下结果：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that the code is identical to the preceding code except that we are now
    implementing `PSeq` for the mapping function, so we are distributing it across
    all of my cores. You can see that the time dropped significantly by implementing
    parallelism to the mapping function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码与前面的代码相同，只是我们现在正在实现映射函数的`PSeq`，因此我们将其分布到所有核心上。你可以看到，通过实现映射函数的并行性，时间显著下降。
- en: 'If you are thinking we have an answer for our big data scenario, you are incorrect.
    Look what happens when we try and do 5.4 million records:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为我们针对大数据场景有解决方案，那么您是错误的。看看当我们尝试处理540万条记录时会发生什么：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can't analyze the data only with my machine. To do map/reduce and distribute
    the mapping across many machines, we could implement Hadoop or its faster cousin,
    Spark, but then we would have to leave Visual Studio and .NET, and journey into
    the JVM. Also, we would have to learn Java/Python/Scala and be unable to easily
    integrate with our existing .NET applications. As an alternative, we could use
    the Azure implementation called HDInsight, but then we are locked-in to a specific
    cloud vendor. Instead, let's use `MBrace` to handle our distributed computations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能仅用我的机器来分析数据。为了进行映射/归约并将映射分布到多台机器上，我们可以实现Hadoop或其更快的兄弟产品Spark，但那样我们就必须离开Visual
    Studio和.NET，并进入JVM的世界。此外，我们还需要学习Java/Python/Scala，并且无法轻松地与现有的.NET应用程序集成。作为替代方案，我们可以使用Azure的HDInsight实现，但那样我们就被锁定在特定的云供应商上了。相反，让我们使用`MBrace`来处理我们的分布式计算。
- en: MBrace
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MBrace
- en: MBrace is an open source project for scalable data scripting using F# or C#.
    You can find the website at [http://mbrace.io/](http://mbrace.io/). MBrace supports
    a local simulation of distributed computing and actual implementation on Azure
    and, coming soon, AWS. For this chapter, we are going to stick with the local
    simulation so you don't have to get an Azure or AWS subscription to work through
    the samples.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: MBrace是一个开源项目，用于使用F#或C#进行可扩展的数据脚本。您可以在[http://mbrace.io/](http://mbrace.io/)找到网站。MBrace支持在本地模拟分布式计算以及在Azure和即将推出的AWS上的实际实现。对于本章，我们将坚持使用本地模拟，这样您就不需要Azure或AWS订阅来运行示例。
- en: 'Go back to Visual Studio, open the NuGet Package Manager, and enter this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Visual Studio，打开NuGet包管理器，并输入以下内容：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once all of the packages install, go into `MapReduce.fsx` and add this at the
    bottom (note that the version number might be different for you):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有包安装完成，进入`MapReduce.fsx`并在底部添加以下内容（注意，版本号可能因您而异）：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Sending this to the REPL gives us the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL后，我们得到了以下结果：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'But also notice what is happening outside of Visual Studio on your machine.
    You probably got this dialog:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但也要注意在您的机器上Visual Studio之外发生的事情。您可能得到了这个对话框：
- en: '![MBrace](img/00158.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![MBrace](img/00158.jpeg)'
- en: If so, click on **Allow access**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，请点击**允许访问**。
- en: 'Next, four dialog boxes popped up, representing the four machines that you
    initialized on this line:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，出现了四个对话框，代表您在这行初始化的四个机器：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![MBrace](img/00159.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![MBrace](img/00159.jpeg)'
- en: 'If you cycle through the dialog boxes, you will notice that one of them looks
    like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在对话框之间切换，您会注意到其中一个看起来像这样：
- en: '![MBrace](img/00160.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![MBrace](img/00160.jpeg)'
- en: 'Consider executing the following line:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑执行以下行：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: MBrace sends the job to one of the four consoles. When working with MBrace,
    everything inside of the curly braces `{}` is executed. In this case, it is 5
    + 10, but soon enough it will contain much more complicated calculations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: MBrace将作业发送到四个控制台中的一个。当使用MBrace时，花括号`{}`内的所有内容都会被执行。在这种情况下，它是5 + 10，但很快它将包含更复杂的计算。
- en: 'Go back into `MapReduce.fsx` and add this script at the bottom:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`MapReduce.fsx`并在底部添加以下脚本：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you send this to the REPL, nothing much will happen for quite a while.
    If you look at the four console windows, you will see that they are working hard
    calculating `knn.map` on each of those 250,000 values:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将此发送到REPL时，一段时间内不会有太多的事情发生。如果您查看四个控制台窗口，您会看到它们正在努力计算`knn.map`，针对那些250,000个值中的每一个：
- en: '![MBrace](img/00161.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![MBrace](img/00161.jpeg)'
- en: Since this is on our local machine and there is overhead passing data to the
    different processes, it is much slower than running the in-memory map/reduce that
    we have seen earlier in the chapter. However, out in the real world when we have
    more data than any one machine can handle and we can spin up several machines
    on Azure or AWS, MBrace really shines. You will also notice that we did nothing
    to install Accord.NET on those four other machines. Vagabond, part of the MBrace
    NuGet package, handles installing missing assemblies for us. This is a brand of
    awesome that should never be on sale. Instead of worrying about standing up and
    configuring machines, we can let MBrace handle all of that for us.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是在本地机器上，并且向不同进程传递数据存在开销，所以它的速度比我们在本章前面看到的内存中的map/reduce要慢得多。然而，在现实世界中，当我们拥有的数据比任何一台机器都能处理的多，并且我们可以在Azure或AWS上启动多台机器时，MBrace真的非常出色。你也会注意到，我们没有在那些其他四台机器上安装Accord.NET。Vagabond是MBrace
    NuGet包的一部分，它为我们处理安装缺失的程序集。这是一种永远不会打折的酷炫品牌。我们不必担心搭建和配置机器，我们可以让MBrace为我们处理所有这些。
- en: 'There is one last bit of syntax we want to use. Go back into `MapReduce.fsx`
    and add this at the bottom:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想使用一种最后的语法。回到`MapReduce.fsx`，在底部添加以下内容：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Sending it to the REPL has the same effect as the first MBrace example. Consider
    the following line:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将它发送到REPL的效果与第一个MBrace示例相同。考虑以下行：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This line replaces these lines from the first MBrace example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这行替换了第一个MBrace示例中的这些行：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is the syntax we will be using for the AdventureWorks implementation. If
    you want to dig into MBrace further, download the starter pack found on GitHub
    at [https://github.com/mbraceproject/MBrace.StarterKit/blo](https://github.com/mbraceproject/MBrace.StarterKit).
    With our intro to MapReduce and MBrace out of the way, let's see what we can do
    with AdventureWorks data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用于AdventureWorks实现的语法。如果你想深入了解MBrace，请下载GitHub上找到的入门包[https://github.com/mbraceproject/MBrace.StarterKit/blo](https://github.com/mbraceproject/MBrace.StarterKit)。随着我们对MapReduce和MBrace的介绍完成，让我们看看我们能用AdventureWorks数据做什么。
- en: Distributed logistic regression
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式逻辑回归
- en: 'In the Visual Studio **Solution Explorer**, add a new F# script file called
    `AdventureWorksLR`. Go back into Visual Studio, open up the NuGet Package Manager,
    and enter this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio **解决方案资源管理器**中，添加一个名为`AdventureWorksLR`的新F#脚本文件。回到Visual Studio，打开NuGet包管理器，输入以下内容：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In that script, add the following code (your version number might be different):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个脚本中添加以下代码（你的版本号可能不同）：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Sending this to the FSI gives us the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到FSI，我们得到以下结果：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There is no new code here. We are creating a `telemetry` type that contains
    all of the useful data that we are capturing from the IoT bikes. We then create
    an array of telemetries from all of the data in the database. If you were wondering,
    there are 360,000 records in the `telemetry` table.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有新的代码。我们正在创建一个包含我们从物联网自行车中捕获的所有有用数据的`telemetry`类型。然后我们创建一个来自数据库中所有数据的遥测数组。如果你想知道，`telemetry`表中共有360,000条记录。
- en: 'Go back to the script and enter this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 回到脚本，输入以下内容：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Sending this to the FSI gives us the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到FSI，我们得到以下结果：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This chunk of code creates a multiple linear regression to predict bike speeds
    based on the level of the rider and the gear they are using. Instead of looking
    at the r2, let''s do a sniff test. Go back to the script and add this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个多元线性回归，用于根据骑行者的级别和他们使用的档位来预测自行车速度。不要看r2，让我们做一个嗅探测试。回到脚本，添加以下内容：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Sending this to the REPL, gives us the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，我们得到以下结果：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this script, `possible` is a jagged array of all the possible combination
    of gears (values 0 to 4) and biker level (values 0 to 2). We then populate this
    matrix with the results of the `Compute()` method. When you take this data and
    put it in a more user-friendly way, you can see that there is a relationship—the
    elite cyclists go faster in all gears than the beginners and it looks like the
    beginners don''t use the lowest gear at all:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，`possible`是一个所有可能的档位（值0到4）和骑行者级别（值0到2）组合的交错数组。然后我们用`Compute()`方法的结果填充这个矩阵。当你将数据以更用户友好的方式呈现时，你可以看到存在一种关系——精英骑行者在所有档位上比初学者骑得快，而且看起来初学者根本不用最低档：
- en: '![Distributed logistic regression](img/00162.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![分布式逻辑回归](img/00162.jpeg)'
- en: 'With this model created, we can then run classifiers on the data and get expected
    speeds for a given gear and biker level. Go into the script file and enter this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了这个模型之后，我们就可以在数据上运行分类器，并得到给定档位和骑行者级别的预期速度。进入脚本文件，输入以下内容：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you send this to the REPL, you will see that the console windows pop up
    and start doing work. After a couple of minutes, you will get this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将此代码发送到REPL时，你会看到控制台窗口弹出并开始工作。几分钟之后，你会得到这个结果：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You might be wondering if there is a way to distribute the creation of the model
    (the `target.Regress(trainInputs, trainOutputs)` line). The short answer is no,
    you cannot be using the frameworks that we are using to do that. However, some
    models might lend themselves to distribution and then re-aggregation, but you
    would have to extend what is offered in numl and Accord.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道是否有方法可以分发模型的创建（即`target.Regress(trainInputs, trainOutputs)`这一行）。简短的回答是，你不能使用我们正在使用的框架来做这件事。然而，一些模型可能适合分布式和重新聚合，但你必须扩展numl和Accord提供的内容。
- en: The IoT
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物联网
- en: But before we leave machine learning and IoT, let's get crazy. The PI is not
    just an input device—heck, it is more powerful than the laptop you bought five
    years ago. Let's make our Raspberry PI-enabled bike the ultimate power in the
    tri-state area.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们离开机器学习和物联网之前，让我们疯狂一下。PI不仅仅是一个输入设备——天哪，它比五年前你买的笔记本电脑还要强大。让我们让我们的树莓派自行车成为三州地区的终极力量。
- en: PCL linear regression
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PCL线性回归
- en: 'Go into Visual Studio and add a new Visual F# Windows Portable Library (.NET
    4.5) called `AdventureWorks.IOB.PCL`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 进入Visual Studio，添加一个新的Visual F# Windows Portable Library (.NET 4.5)名为`AdventureWorks.IOB.PCL`：
- en: '![PCL linear regression](img/00163.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![PCL线性回归](img/00163.jpeg)'
- en: 'Once the project is created, go into the NuGet Package Manager Console and
    enter this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建完成后，进入NuGet包管理器控制台，输入以下内容：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Make sure that the default project is pointed to `AdventureWorks.IOB.PCL`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 确保默认项目指向`AdventureWorks.IOB.PCL`：
- en: '![PCL linear regression](img/00164.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![PCL线性回归](img/00164.jpeg)'
- en: One of the issues when dealing with PCLs is that since they are a slimmed-down
    version of the .NET Framework, they have no data access support. This means we
    can't use our friendly neighborhood type provider to get the telemetry data to
    train our models. Instead, we will need to get our data from a different project
    and push that data into the PCL for it to train the model. Another "gotcha" is
    that the script file created in the PCL project is evaluated inside the FSI, which
    is a full-on .NET Framework. This means you can't assume that all of the code
    you write inside the `.fsx` file can be copied and pasted into the `.fs` file.
    Since we are building on code we already wrote, we won't be using the script file
    for this section. I know…take a deep breath…functional programming without an
    REPL.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 处理PCL时遇到的一个问题是，由于它们是.NET Framework的精简版，因此没有数据访问支持。这意味着我们无法使用我们熟悉的环境类型提供者来获取遥测数据以训练我们的模型。相反，我们需要从不同的项目获取数据，并将这些数据推送到PCL中以便训练模型。另一个“陷阱”是，在PCL项目中创建的脚本文件在FSI中评估，而FSI是一个完整的.NET
    Framework。这意味着你不能假设你写在`.fsx`文件中的所有代码都可以复制粘贴到`.fs`文件中。由于我们是在已有的代码基础上构建的，所以我们将不会在这个部分使用脚本文件。我知道……深呼吸……没有REPL的功能性编程。
- en: Go into the PCL project and delete the `Script.fsx` file and rename `PortableLibrary1.fs`
    to `SpeedModel.fs`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 进入PCL项目，删除`Script.fsx`文件，并将`PortableLibrary1.fs`重命名为`SpeedModel.fs`。
- en: 'Inside the `SpeedModel.fs` file, replace all of the existing code with this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SpeedModel.fs`文件中，将所有现有代码替换为以下内容：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This code creates two .NET classes. The `Telemetry` class is equivalent to
    a read-only DTO/POCO that you would see in C# or VB.NET. The `SpeedModel` class
    is a bit more involved. The class has one property and two methods:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了两个.NET类。`Telemetry`类相当于在C#或VB.NET中看到的只读DTO/POCO。`SpeedModel`类则更为复杂。该类有一个属性和两个方法：
- en: '`CurrentModel` is a property that allows the linear regression model to be
    set. Note that the model is an internal variable that is mutable.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrentModel`是一个属性，允许设置线性回归模型。请注意，模型是一个内部变量，是可变的。'
- en: '`Train` is a method where an array of telemetries is passed and the linear
    regression model will be updated. The implementation of `Train()` can be copied
    and pasted from the script file that you worked on previously.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Train`是一个方法，其中传递一个遥测数组，线性回归模型将被更新。`Train()`的实现可以从之前工作的脚本文件中复制粘贴。'
- en: '`Classify` is a method where a single telemetry is passed and the linear regression
    computes the score. The implementation of `Classify()` can be copied and pasted
    from the script file that you worked on previously.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Classify`是一个方法，其中传递一个单个遥测，线性回归计算分数。`Classify()`的实现可以从之前工作的脚本文件中复制粘贴。'
- en: You can check to see if everything is OK by compiling the project.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编译项目来检查一切是否正常。
- en: Service layer
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务层
- en: 'With our PCL ready, let''s build a service layer to deploy the model to devices
    in the field:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的PCL准备好了，让我们构建一个服务层来部署模型到现场设备：
- en: Go into Visual Studio and add a new Visual C# Web **ASP.NET Web Application**:![Service
    layer](img/00165.jpeg)![Service layer](img/00166.jpeg)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入Visual Studio，添加一个新的Visual C# Web **ASP.NET Web应用程序**：![服务层](img/00165.jpeg)![服务层](img/00166.jpeg)
- en: Add a reference:![Service layer](img/00167.jpeg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个引用：![服务层](img/00167.jpeg)
- en: Next, go into the NuGet Package Manager Console and add a reference to `Accord.Statistics`.
    Make sure the **Default project** is pointing to `AdventureWorks.IOB.Services`:![Service
    layer](img/00168.jpeg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入NuGet包管理器控制台，添加对`Accord.Statistics`的引用。确保**默认项目**指向`AdventureWorks.IOB.Services`：![服务层](img/00168.jpeg)
- en: 'Next, go into the `Web.Config` file and add a connection string entry:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入`Web.Config`文件并添加一个连接字符串条目：
- en: '[PRE35]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Head over to the `Global.asax.cs` file and replace the entire contents with
    the following:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Global.asax.cs`文件，并用以下内容替换整个内容：
- en: '[PRE36]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can compile the project now. This code is much like [Chapter 3](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 3. More AdventureWorks Regression"), *More AdventureWorks Regression*,
    in that we create a timer that fires every 5 minutes. Also, we use a lock to prevent
    the model being read in an illegal state. When the timer fires, the model is recreated,
    based on the data from the database. Notice that this is where the C# application
    is responsible for getting the data that is passed into the `SpeedModel` class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以编译这个项目了。这段代码与[第3章](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "第3章。更多AdventureWorks回归")，*更多AdventureWorks回归*非常相似，我们创建了一个每5分钟触发一次的计时器。此外，我们使用锁来防止模型在非法状态下被读取。当计时器触发时，模型将根据数据库中的数据重新创建。请注意，这是C#应用程序负责获取传递给`SpeedModel`类的数据的部分。
- en: 'Head over to the `Controllers` and rename `ValuesController` to `SpeedModelController`.
    Go into the file and replace all of the code with this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`Controllers`并将`ValuesController`重命名为`SpeedModelController`。进入文件并将所有代码替换为以下内容：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you compile the project and run the website, when you navigate to the controller,
    you will get this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译了项目并运行了网站，当你导航到控制器时，你会得到以下内容：
- en: '![Service layer](img/00169.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![服务层](img/00169.jpeg)'
- en: We now have a way of creating a model based on all the data in the database
    that we can share to individual clients.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一种方法可以根据数据库中的所有数据创建模型，我们可以将其共享给单个客户端。
- en: Universal Windows app and Raspberry Pi 2
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用Windows应用程序和Raspberry Pi 2
- en: 'This universal app has a couple of moving parts:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通用应用程序有几个组成部分：
- en: 'When the app is connected to its home network, it will:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序连接到其家庭网络时，它将：
- en: Upload all of the telemetry that is collected to Azure's IoT Suite
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将收集的所有遥测数据上传到Azure的IoT Suite
- en: Download the most recent global model that was created based on all the riders
    in the AdventureWorks database from our service layer
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从我们的服务层下载基于AdventureWorks数据库中所有骑手创建的最新全局模型
- en: When the app is running, it will collect telemetry data from the sensors hooked
    up to the bike. After a certain point, it will start generating its own local
    model and compare it to the global AdventureWorks model. If the local model begins
    diverging from the expected speed of the global model, it will instruct the biker
    to shift. The app will keep the telemetry data on local storage until it is connected
    to the network, then it will upload the data.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序运行时，它将从连接到自行车的传感器收集遥测数据。在某个时刻之后，它将开始生成自己的本地模型，并将其与全局AdventureWorks模型进行比较。如果本地模型开始偏离全局模型的预期速度，它将指示骑手换挡。应用程序将保留遥测数据在本地存储中，直到它连接到网络，然后上传数据。
- en: 'Let''s code this up:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来编写这段代码：
- en: Go into the **Solution Explorer** and add a new Visual C# Windows Universal
    Blank App named `AdventureWorks.IOB.RP2`:![Universal Windows app and Raspberry
    Pi 2](img/00170.jpeg)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**解决方案资源管理器**，添加一个新的Visual C# Windows通用空白应用程序，命名为`AdventureWorks.IOB.RP2`：![通用Windows应用程序和Raspberry
    Pi 2](img/00170.jpeg)
- en: Once the project is created, go to its **References** section and select **Add
    Reference**:![Universal Windows app and Raspberry Pi 2](img/00171.jpeg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目创建后，转到其**引用**部分并选择**添加引用**：![通用Windows应用程序和Raspberry Pi 2](img/00171.jpeg)
- en: The Add Reference... option
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加引用...选项
- en: Then navigate to **Projects** | **Solution** and select the location of your
    PCL project:![Universal Windows app and Raspberry Pi 2](img/00172.jpeg)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后导航到**项目** | **解决方案**并选择你的PCL项目的位置：![通用Windows应用程序和Raspberry Pi 2](img/00172.jpeg)
- en: Now navigate to **Universal Windows** | **Extensions** | **Windows IoT Extensions
    for the UWP**:![Universal Windows app and Raspberry Pi 2](img/00173.jpeg)
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在导航到**通用Windows** | **扩展** | **Windows IoT扩展用于UWP**：![通用Windows应用程序和树莓派2](img/00173.jpeg)
- en: 'Next, go into the NuGet Package Manager Console and enter this:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入NuGet包管理器控制台，输入以下内容：
- en: '[PRE38]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Make sure that the **Default project** is pointing to `AdventureWorks.IOB.RP2`:![Universal
    Windows app and Raspberry Pi 2](img/00174.jpeg)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保默认项目指向`AdventureWorks.IOB.RP2`：![通用Windows应用程序和树莓派2](img/00174.jpeg)
- en: Build the project to make sure all is well.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建项目以确保一切正常。
- en: Next, go to the **Solution Explorer** and add a new folder called `Sensors`:![Universal
    Windows app and Raspberry Pi 2](img/00175.jpeg)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到**解决方案资源管理器**，添加一个名为`Sensors`的新文件夹：![通用Windows应用程序和树莓派2](img/00175.jpeg)
- en: Adding new folder
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加新文件夹
- en: Navigate to the `Sensors` folder:![Universal Windows app and Raspberry Pi 2](img/00176.jpeg)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`Sensors`文件夹：![通用Windows应用程序和树莓派2](img/00176.jpeg)
- en: Add a new class called `TelemetryEventArgs.cs`:![Universal Windows app and Raspberry
    Pi 2](img/00177.jpeg)
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`TelemetryEventArgs.cs`的新类：![通用Windows应用程序和树莓派2](img/00177.jpeg)
- en: Adding a new class
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加一个新类
- en: 'In `TelemetryEventArgs.cs`, replace the existing code with the following:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TelemetryEventArgs.cs`中，用以下代码替换现有代码：
- en: '[PRE39]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the sensors folder, add a new interface called `IBikeController`. After
    it is created, replace all of the code with the following:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在传感器文件夹中，添加一个名为`IBikeController`的新接口。创建后，用以下代码替换所有代码：
- en: '[PRE40]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This interface will be used by the main app to, well, interface with the Raspberry
    Pi. The Pi communicates back to the main app via an event called `TelemetryCreated`.
    The reason that we used an interface (versus talking directly to the PI) is that
    we want to borrow a bit from the SOLID principles and have several implementations
    for our app: an in-memory bike controller that we can use to make sure everything
    is hooked up correctly and a Raspberry Pi bike controller that actually talks
    to the hardware that we currently have available. Also, there are so many sensors
    available on the market, we need a way of adding in new sensors without changing
    the existing code.'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此接口将由主应用程序用于，嗯，与树莓派进行接口交互。Pi通过一个名为`TelemetryCreated`的事件将信息传回主应用程序。我们之所以使用接口（而不是直接与PI交谈），是因为我们想要借鉴SOLID原则，并为我们的应用程序提供几个实现：一个内存中的自行车控制器，我们可以用它来确保一切连接正确，以及一个实际的树莓派自行车控制器，它实际上与我们现在可用的硬件进行通信。此外，市场上有很多传感器，我们需要一种方法在不更改现有代码的情况下添加新传感器。
- en: 'Go into the `Sensors` folder and add a new class called `InMemoryBikeController`.
    Replace the existing code with this:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`Sensors`文件夹，添加一个名为`InMemoryBikeController`的新类。用以下代码替换现有代码：
- en: '[PRE41]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This code simulates an actual Raspberry Pi. Every second, it fires an event
    with some hardcoded telemetry data. It also has a method stub for the `SwitchGears`
    that does nothing.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码模拟了一个实际的树莓派。每秒，它触发一个带有一些硬编码遥测数据的事件。它还有一个`SwitchGears`的方法占位符，什么都不做。
- en: 'Make sure everything compiles and jumps over to the `MainPage.xaml` file and
    replace all of the contents with this:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保一切编译正常，跳转到`MainPage.xaml`文件，并用以下内容替换所有内容：
- en: '[PRE42]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This creates a status box that you can use for debugging. When you deploy this
    app to the Raspberry Pi, this is unnecessary because there is no graphical user
    interface.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这创建了一个状态框，你可以用它进行调试。当你将此应用程序部署到树莓派时，这就不必要了，因为没有图形用户界面。
- en: 'Next, go into the `MainPage.xaml.cs` file and replace everything with this:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入`MainPage.xaml.cs`文件，并用以下内容替换所有内容：
- en: '[PRE43]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is where the heavy lifting occurs. When the app starts, it begins a timer
    that fires every second (`_timer_Tick`). If there are over 5 minutes' worth of
    data in the local collection, it generates a `SpeedModel`. It then compares this
    speed model to the global one and if the global output is less than the local
    one, it signals the biker via the `.SwitchGear()`. The actual implementation is
    up to the controller. As you will see in a minute, the Raspberry Pi controller
    turns on an LED that the biker can see. In other examples, we could hook the Pi
    up to the bike's shifting assembly and shift the gears for the biker—an automatic
    transmission for the bike, as it were.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是重头戏所在。当应用程序启动时，它开始一个每秒触发一次的计时器（`_timer_Tick`）。如果本地集合中有超过5分钟的数据，它将生成一个`SpeedModel`。然后，它将这个速度模型与全局模型进行比较，如果全局输出小于本地输出，它将通过`.SwitchGear()`向骑手发出信号。实际实现取决于控制器。正如你将在一分钟内看到的那样，树莓派控制器会打开一个骑手可以看到的LED灯。在其他示例中，我们可以将Pi连接到自行车的变速机构，为骑手换挡——就像自行车的自动变速器一样。
- en: Next, go into the **Solution Explorer** and right-click on **Properties** and
    change the startup project to **Multiple startup projects** with the `Services`
    and `RP2` projects changed to **Start**. The `Services` project has to be listed
    before the `RP2` one:![Universal Windows app and Raspberry Pi 2](img/00178.jpeg)
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入**解决方案资源管理器**，右键点击**属性**，将启动项目更改为**多个启动项目**，并将`Services`和`RP2`项目更改为**启动**。`Services`项目必须列在`RP2`项目之前：![通用Windows应用和树莓派2](img/00178.jpeg)
- en: One last thing you need to do before we run this is to deploy the Universal
    Windows application. If you ask me why you need to deploy it first, I will tell
    you, "Because Microsoft said so." Go into the **Solution Explorer** and right-click
    on the `Rp2` project and select **Deploy**:![Universal Windows app and Raspberry
    Pi 2](img/00179.jpeg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们运行此应用之前，你需要做的最后一件事是部署通用Windows应用。如果你问我为什么需要先部署它，我会告诉你，“因为微软说了。”进入**解决方案资源管理器**，右键点击`Rp2`项目，并选择**部署**：![通用Windows应用和树莓派2](img/00179.jpeg)
- en: The Deploy option
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 部署选项
- en: Now you can run the app and both, the browser will pop up for the service layer
    and the universal Windows app will start:![Universal Windows app and Raspberry
    Pi 2](img/00180.jpeg)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以运行应用，浏览器将弹出服务层，通用Windows应用将启动：![通用Windows应用和树莓派2](img/00180.jpeg)
- en: Notice nothing much is happening—at least on the screen. That is pretty typical
    of IoT projects; the action is on the device and connected peripherals. If the
    device fired the `NetworkStatus_Changed` event, the device would get the most
    recent global model and upload the global model. You can simulate this by placing
    `GetGlobalModelinMainPage()` and then write it to the status box if you are the
    type of person who wants to see something on the screen.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意屏幕上没有发生太多事情。这在物联网项目中很典型；动作发生在设备和连接的外围设备上。如果设备触发了`NetworkStatus_Changed`事件，设备将获取最新的全局模型并上传全局模型。如果你是那种想在屏幕上看到东西的人，你可以通过放置`GetGlobalModelinMainPage()`并写入状态框来模拟此操作。
- en: 'Let''s build out the Raspberry Pi implementation of the `BikeController`. Since
    this is a book on machine learning and not on IoT, I will not be covering the
    details of setting up a Raspberry Pi and doing all of the wiring and coding. As
    a frame of reference, I used the example found at [http://ms-iot.github.io/content/en-US/win10/samples/Potentiometer.htm](http://ms-iot.github.io/content/en-US/win10/samples/Potentiometer.htm).
    Basically, each of the sensors would be considered an analog input device (such
    as a potentiometer) that converts its signal to a digital signal. For each of
    the inputs, a `SpiConnection` was created like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建`BikeController`的树莓派实现。由于这是一本关于机器学习的书，而不是关于物联网的书，因此我不会涵盖设置树莓派和进行所有布线和编码的细节。作为一个参考框架，我使用了在[http://ms-iot.github.io/content/en-US/win10/samples/Potentiometer.htm](http://ms-iot.github.io/content/en-US/win10/samples/Potentiometer.htm)找到的示例。基本上，每个传感器都会被视为一个模拟输入设备（如电位计），它将信号转换为数字信号。对于每个输入，创建了一个`SpiConnection`，如下所示：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And every second, each device''s buffer was read:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒，读取每个设备的缓冲区：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The readings were aggregated into telemetry data and the event was raised:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 读取被汇总到遥测数据中，并引发事件：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Meanwhile, a different timer was running and shutting off the LED every two
    seconds. The LED was set when the `SwitchGear` method was called:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，另一个计时器正在运行，每两秒关闭一次LED。当调用`SwitchGear`方法时，LED被设置：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: So the controller app can turn the LED on, and then the Pi turns it off after
    two seconds. You can see the final result in the code sample that accompanies
    the book.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，控制器应用可以打开LED，然后树莓派在两秒后关闭它。你可以在书中附带的代码示例中看到最终结果。
- en: Next steps
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署选项
- en: 'I glossed over some important IoT issues that would need to be addressed to
    make this bike app fully functional:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步
- en: There are hundreds of input devices that I could have used. You will have to
    write a specific implementation for the devices that you are interested in. Thank
    goodness we have an interface!
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我省略了一些重要的物联网问题，这些问题需要解决才能使这个自行车应用完全功能化：
- en: How to deploy this app to a Raspberry Pi is beyond the scope of this book. You
    can learn more about this at [https://dev.windows.com/en-US/iot](https://dev.windows.com/en-US/iot).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将此应用部署到树莓派超出了本书的范围。你可以在[https://dev.windows.com/en-US/iot](https://dev.windows.com/en-US/iot)了解更多信息。
- en: Telemetry to local storage is beyond the scope of this book. This is a universal
    Windows app issue that can be researched at [https://msdn.microsoft.com/en-us/library/windows/apps/dn894631.aspx](https://msdn.microsoft.com/en-us/library/windows/apps/dn894631.aspx).
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将遥测数据存储到本地超出了本书的范围。这是一个通用的Windows应用程序问题，您可以在[https://msdn.microsoft.com/en-us/library/windows/apps/dn894631.aspx](https://msdn.microsoft.com/en-us/library/windows/apps/dn894631.aspx)进行查询。
- en: Uploading the data to the Azure IoT suite is beyond the scope of this book.
    You can find more information on that at [https://www.microsoft.com/en-us/server-cloud/internet-of-things/azure-iot-suite.aspx](https://www.microsoft.com/en-us/server-cloud/internet-of-things/azure-iot-suite.aspx).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据上传到Azure IoT套件超出了本书的范围。您可以在[https://www.microsoft.com/en-us/server-cloud/internet-of-things/azure-iot-suite.aspx](https://www.microsoft.com/en-us/server-cloud/internet-of-things/azure-iot-suite.aspx)找到更多相关信息。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a fairly ambitious chapter. We looked at some of the challenges of
    big data and how to use MBrace to help us with distributed machine learning. We
    then created a sample IoT project to show an example of how big data is generated
    and how we can deploy ML models to devices. The IoT app used two ML models to
    give optimal results. We then looked (briefly) at how we can use the power of
    .NET to build multiple input devices so that we can extend across the variety
    of hardware that is, and will be, available for IoT.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章相当雄心勃勃的内容。我们探讨了大数据的一些挑战以及如何使用MBrace帮助我们进行分布式机器学习。然后我们创建了一个示例物联网项目，以展示大数据是如何生成的，以及我们如何部署机器学习模型到设备上。该物联网应用使用了两个机器学习模型以获得最佳结果。然后我们简要地探讨了如何利用.NET的力量构建多个输入设备，以便我们可以扩展到目前和未来可用的各种物联网硬件。
