- en: Chapter 10. Big Data and IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, this book has followed a pattern of extracting data, cleaning
    and shaping the data, and then building machine learning models. A common element
    in all of the examples is that when we've extracted data, we have brought it from
    the server (or other external sources) locally to our machine. This means our
    analysis is confined to whatever data fits in the memory on our local machines.
    While this is good for small- and medium-sized datasets, there are plenty of datasets
    and questions that do not fit in RAM. The last couple of years have seen the rise
    of big data, where we can ask questions of datasets that are too large, unstructured,
    or fast-moving to be analyzed using our conventional machine learning techniques.
    One domain that fits well with big data is the proliferation of small, inexpensive
    devices that can send a vast quantity of data to a server for analysis. These
    **Internet of Things** (**IoT**) devices have the potential to reshape the world
    around us in ways that typical computers and smartphones cannot. In this chapter,
    let's run though a potential big data and the Internet of Things scenario at AdventureWorks.
  prefs: []
  type: TYPE_NORMAL
- en: AdventureWorks and the Internet of Bikes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One day you are sitting in your office, your boss comes in and says, "Since
    you did such a great job on helping reduce our scrap rate, we would like you to
    work on a proof of concept with our research and development department. Last
    month, the management team went to a conference about the Internet of Things and
    we think we have an interesting use case: the **Internet of Bikes** (**IoB**).
    We are going to put sensors on a bike model that can read certain diagnostic information
    about the bike and its riding patterns. We think that a certain segment of our
    customers would love to have a "smart bike".'
  prefs: []
  type: TYPE_NORMAL
- en: 'You head over to the research and development area, where they have tricked
    out a bike like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Tire pressure sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speedometer sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gear sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Raspberry Pi 2 mounted under the seat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A wireless Ethernet shield attached to the PI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GPS shield attached to the PI![AdventureWorks and the Internet of Bikes](img/00155.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The head of the R&D department tells you, "We are trying to find cost-effective
    wireless sensors. Until then, we are stringing wires through the frame's tube
    to the PI. We initially thought of using the bike rider's phone as the CPU, but
    we went with the PI because it is less bulky and weighs much less than a phone—bike
    riders are very concerned about weight. The PI gets its power from a rechargeable
    battery and when the bike gets docked at home to recharge, all of its on-board
    data is uploaded to our servers at that time. We want to transmit data from the
    PI to our servers only at the bike's home for security reasons and so the riders
    are not hit with data plan limitations by using cell networks."
  prefs: []
  type: TYPE_NORMAL
- en: The head of R&D continues, "We envision a dashboard for people to keep track
    of their cycling route, their biking habits, and whatnot. Where you come in is
    on the machine learning piece. We need a way of analyzing these huge amounts of
    data we are going to collect to provide an enhanced customer experience when they
    are riding this bike."
  prefs: []
  type: TYPE_NORMAL
- en: Data considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You look at the data (called telemetry) coming from the bike as two different
    problems. Problem one is getting the data to the server from individual bikes
    and problem two is having the data in a format that allows for machine learning
    on a large scale. You decide to solve both those problems by using the Microsoft
    Azure IoT suite to stream the data from the bikes into the current Northwind SQL
    Azure database. You add a table called `telemetry` and add a foreign key to `PurchaseOrderHeader`.
  prefs: []
  type: TYPE_NORMAL
- en: You then populate the table with some data from riders in the AdventureWorks
    Early Adopter program. Although there is not much data in the table to start,
    it is expected to grow rapidly. The level of atomacy of the table is a single
    reading that occurs about every second. That means for a 30-minute bike ride,
    we capture 1,800 rows of data. Since we have about 200 bike riders in our early
    adopter program, we will generate about 360,000 rows of data every time they take
    a ride. This one ride generates about as much data as the current AdventureWorks
    database maintains for the entire company. After one month of data where these
    bikers go out about every other day, we will have 5.4 million rows of data.
  prefs: []
  type: TYPE_NORMAL
- en: One of the data elements that we are capturing is latitude and longitude. Fortunately,
    all of our bike riders live in Enderlin, North Dakota, and all travel on the straightest
    road in the United States, Highway 46 ([https://en.wikipedia.org/wiki/North_Dakota_Highway_46_(54st_SE)](https://en.wikipedia.org/wiki/North_Dakota_Highway_46_(54st_SE))).
    This means our longitude does not change. Also, we are capturing feet per second
    as a speed gauge so we can easily compare how riders perform against each other.
  prefs: []
  type: TYPE_NORMAL
- en: With the data in place, let's take a look at how to analyze data at scale.
  prefs: []
  type: TYPE_NORMAL
- en: MapReduce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open Visual Studio and create a new Visual F# Windows Library called `AdventureWorks.IOB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MapReduce](img/00156.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go into the NuGet Package Manager Console and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, rename `script1.fsx` to `MapReduce.fsx`. Now, enter in the same code
    from [Chapter 5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "Chapter 5. Time Out – Obtaining Data"), *Time Out – Obtaining Data*, that created
    a k-NN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the FSI gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We called `knn.Compute` to do a calculation on a single input after the k-NN
    model was created.
  prefs: []
  type: TYPE_NORMAL
- en: This works well enough or a single calculation, but what if we want to do thousands
    of calculations? For example, let's call `knn.Compute()` on 250,000 random samples.
    After we finish all 250,000 calculations, let's add up the results and then divide
    that total by the number of observations and see if the dataset is biased towards
    a particular category.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a function that will create a random input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the FSI gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create an array of 250,000 items and populate it with the random
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With our data ready, let''s do our calculation. I added a timer to give us
    an idea of the performance hit for running 250,000 records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the FSI will give us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting piece of code is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are mapping and reducing. Mapping is old hat to you by now,
    but you might not be familiar with reducing. Reduce is a high-ordered function
    that takes in two parameters: an accumulator and a value. Both parameters are
    of the same type (in this case, `int`). What reduce is doing is going through
    each of the items of the array and applying a function. It then takes the results
    of that calculation and adds it to the accumulator. In this case, the accumulator
    `acc` is added to the value from the `array (i)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visually, this looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MapReduce](img/00157.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You might have heard the expression map/reduce used in the context of big data.
    That's because some of the pioneers in big data analytics such as Google and Yahoo
    created Hadoop based on the concept of map/reduce. Hadoop is a platform for big
    data, including a filesystem (HDFS), query languages (Hive and PIG), and machine
    learning (Mahdut). Typically, when you hear people talking about Hadoop and map/reduce,
    they are talking about a specialized implementation using key/value pairs. Also,
    usually the *map* part of map/reduce is distributed across thousands of commodity
    machines. The *reduce* can be distributed depending on the nature of the function
    that is passed to reduce. If the function does a `groupBy` or some other calculation
    on a section of the entire dataset, it can be distributed. In this chapter, we
    are going to distribute map and are not going to distribute reduce.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate why map/reduce is popular for big data, let''s distribute the
    mapping across all of the cores on my machine. This can simulate the way Hadoop
    distributes processing across thousands of networked computers. Go into Visual
    Studio and open the NuGet Package Manager and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, go into `MapReduce.fsx` and enter this at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the FSI gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the code is identical to the preceding code except that we are now
    implementing `PSeq` for the mapping function, so we are distributing it across
    all of my cores. You can see that the time dropped significantly by implementing
    parallelism to the mapping function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are thinking we have an answer for our big data scenario, you are incorrect.
    Look what happens when we try and do 5.4 million records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can't analyze the data only with my machine. To do map/reduce and distribute
    the mapping across many machines, we could implement Hadoop or its faster cousin,
    Spark, but then we would have to leave Visual Studio and .NET, and journey into
    the JVM. Also, we would have to learn Java/Python/Scala and be unable to easily
    integrate with our existing .NET applications. As an alternative, we could use
    the Azure implementation called HDInsight, but then we are locked-in to a specific
    cloud vendor. Instead, let's use `MBrace` to handle our distributed computations.
  prefs: []
  type: TYPE_NORMAL
- en: MBrace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MBrace is an open source project for scalable data scripting using F# or C#.
    You can find the website at [http://mbrace.io/](http://mbrace.io/). MBrace supports
    a local simulation of distributed computing and actual implementation on Azure
    and, coming soon, AWS. For this chapter, we are going to stick with the local
    simulation so you don't have to get an Azure or AWS subscription to work through
    the samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to Visual Studio, open the NuGet Package Manager, and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all of the packages install, go into `MapReduce.fsx` and add this at the
    bottom (note that the version number might be different for you):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'But also notice what is happening outside of Visual Studio on your machine.
    You probably got this dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MBrace](img/00158.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If so, click on **Allow access**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, four dialog boxes popped up, representing the four machines that you
    initialized on this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![MBrace](img/00159.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you cycle through the dialog boxes, you will notice that one of them looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MBrace](img/00160.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Consider executing the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: MBrace sends the job to one of the four consoles. When working with MBrace,
    everything inside of the curly braces `{}` is executed. In this case, it is 5
    + 10, but soon enough it will contain much more complicated calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back into `MapReduce.fsx` and add this script at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When you send this to the REPL, nothing much will happen for quite a while.
    If you look at the four console windows, you will see that they are working hard
    calculating `knn.map` on each of those 250,000 values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MBrace](img/00161.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Since this is on our local machine and there is overhead passing data to the
    different processes, it is much slower than running the in-memory map/reduce that
    we have seen earlier in the chapter. However, out in the real world when we have
    more data than any one machine can handle and we can spin up several machines
    on Azure or AWS, MBrace really shines. You will also notice that we did nothing
    to install Accord.NET on those four other machines. Vagabond, part of the MBrace
    NuGet package, handles installing missing assemblies for us. This is a brand of
    awesome that should never be on sale. Instead of worrying about standing up and
    configuring machines, we can let MBrace handle all of that for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last bit of syntax we want to use. Go back into `MapReduce.fsx`
    and add this at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending it to the REPL has the same effect as the first MBrace example. Consider
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This line replaces these lines from the first MBrace example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is the syntax we will be using for the AdventureWorks implementation. If
    you want to dig into MBrace further, download the starter pack found on GitHub
    at [https://github.com/mbraceproject/MBrace.StarterKit/blo](https://github.com/mbraceproject/MBrace.StarterKit).
    With our intro to MapReduce and MBrace out of the way, let's see what we can do
    with AdventureWorks data.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed logistic regression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Visual Studio **Solution Explorer**, add a new F# script file called
    `AdventureWorksLR`. Go back into Visual Studio, open up the NuGet Package Manager,
    and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In that script, add the following code (your version number might be different):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the FSI gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There is no new code here. We are creating a `telemetry` type that contains
    all of the useful data that we are capturing from the IoT bikes. We then create
    an array of telemetries from all of the data in the database. If you were wondering,
    there are 360,000 records in the `telemetry` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the script and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the FSI gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This chunk of code creates a multiple linear regression to predict bike speeds
    based on the level of the rider and the gear they are using. Instead of looking
    at the r2, let''s do a sniff test. Go back to the script and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL, gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this script, `possible` is a jagged array of all the possible combination
    of gears (values 0 to 4) and biker level (values 0 to 2). We then populate this
    matrix with the results of the `Compute()` method. When you take this data and
    put it in a more user-friendly way, you can see that there is a relationship—the
    elite cyclists go faster in all gears than the beginners and it looks like the
    beginners don''t use the lowest gear at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Distributed logistic regression](img/00162.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'With this model created, we can then run classifiers on the data and get expected
    speeds for a given gear and biker level. Go into the script file and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When you send this to the REPL, you will see that the console windows pop up
    and start doing work. After a couple of minutes, you will get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering if there is a way to distribute the creation of the model
    (the `target.Regress(trainInputs, trainOutputs)` line). The short answer is no,
    you cannot be using the frameworks that we are using to do that. However, some
    models might lend themselves to distribution and then re-aggregation, but you
    would have to extend what is offered in numl and Accord.
  prefs: []
  type: TYPE_NORMAL
- en: The IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But before we leave machine learning and IoT, let's get crazy. The PI is not
    just an input device—heck, it is more powerful than the laptop you bought five
    years ago. Let's make our Raspberry PI-enabled bike the ultimate power in the
    tri-state area.
  prefs: []
  type: TYPE_NORMAL
- en: PCL linear regression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go into Visual Studio and add a new Visual F# Windows Portable Library (.NET
    4.5) called `AdventureWorks.IOB.PCL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PCL linear regression](img/00163.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the project is created, go into the NuGet Package Manager Console and
    enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that the default project is pointed to `AdventureWorks.IOB.PCL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PCL linear regression](img/00164.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: One of the issues when dealing with PCLs is that since they are a slimmed-down
    version of the .NET Framework, they have no data access support. This means we
    can't use our friendly neighborhood type provider to get the telemetry data to
    train our models. Instead, we will need to get our data from a different project
    and push that data into the PCL for it to train the model. Another "gotcha" is
    that the script file created in the PCL project is evaluated inside the FSI, which
    is a full-on .NET Framework. This means you can't assume that all of the code
    you write inside the `.fsx` file can be copied and pasted into the `.fs` file.
    Since we are building on code we already wrote, we won't be using the script file
    for this section. I know…take a deep breath…functional programming without an
    REPL.
  prefs: []
  type: TYPE_NORMAL
- en: Go into the PCL project and delete the `Script.fsx` file and rename `PortableLibrary1.fs`
    to `SpeedModel.fs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `SpeedModel.fs` file, replace all of the existing code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates two .NET classes. The `Telemetry` class is equivalent to
    a read-only DTO/POCO that you would see in C# or VB.NET. The `SpeedModel` class
    is a bit more involved. The class has one property and two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CurrentModel` is a property that allows the linear regression model to be
    set. Note that the model is an internal variable that is mutable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Train` is a method where an array of telemetries is passed and the linear
    regression model will be updated. The implementation of `Train()` can be copied
    and pasted from the script file that you worked on previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Classify` is a method where a single telemetry is passed and the linear regression
    computes the score. The implementation of `Classify()` can be copied and pasted
    from the script file that you worked on previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can check to see if everything is OK by compiling the project.
  prefs: []
  type: TYPE_NORMAL
- en: Service layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our PCL ready, let''s build a service layer to deploy the model to devices
    in the field:'
  prefs: []
  type: TYPE_NORMAL
- en: Go into Visual Studio and add a new Visual C# Web **ASP.NET Web Application**:![Service
    layer](img/00165.jpeg)![Service layer](img/00166.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference:![Service layer](img/00167.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go into the NuGet Package Manager Console and add a reference to `Accord.Statistics`.
    Make sure the **Default project** is pointing to `AdventureWorks.IOB.Services`:![Service
    layer](img/00168.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, go into the `Web.Config` file and add a connection string entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Head over to the `Global.asax.cs` file and replace the entire contents with
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can compile the project now. This code is much like [Chapter 3](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 3. More AdventureWorks Regression"), *More AdventureWorks Regression*,
    in that we create a timer that fires every 5 minutes. Also, we use a lock to prevent
    the model being read in an illegal state. When the timer fires, the model is recreated,
    based on the data from the database. Notice that this is where the C# application
    is responsible for getting the data that is passed into the `SpeedModel` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head over to the `Controllers` and rename `ValuesController` to `SpeedModelController`.
    Go into the file and replace all of the code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compile the project and run the website, when you navigate to the controller,
    you will get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Service layer](img/00169.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We now have a way of creating a model based on all the data in the database
    that we can share to individual clients.
  prefs: []
  type: TYPE_NORMAL
- en: Universal Windows app and Raspberry Pi 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This universal app has a couple of moving parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the app is connected to its home network, it will:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload all of the telemetry that is collected to Azure's IoT Suite
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the most recent global model that was created based on all the riders
    in the AdventureWorks database from our service layer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the app is running, it will collect telemetry data from the sensors hooked
    up to the bike. After a certain point, it will start generating its own local
    model and compare it to the global AdventureWorks model. If the local model begins
    diverging from the expected speed of the global model, it will instruct the biker
    to shift. The app will keep the telemetry data on local storage until it is connected
    to the network, then it will upload the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s code this up:'
  prefs: []
  type: TYPE_NORMAL
- en: Go into the **Solution Explorer** and add a new Visual C# Windows Universal
    Blank App named `AdventureWorks.IOB.RP2`:![Universal Windows app and Raspberry
    Pi 2](img/00170.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project is created, go to its **References** section and select **Add
    Reference**:![Universal Windows app and Raspberry Pi 2](img/00171.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Add Reference... option
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then navigate to **Projects** | **Solution** and select the location of your
    PCL project:![Universal Windows app and Raspberry Pi 2](img/00172.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now navigate to **Universal Windows** | **Extensions** | **Windows IoT Extensions
    for the UWP**:![Universal Windows app and Raspberry Pi 2](img/00173.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, go into the NuGet Package Manager Console and enter this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure that the **Default project** is pointing to `AdventureWorks.IOB.RP2`:![Universal
    Windows app and Raspberry Pi 2](img/00174.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the project to make sure all is well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, go to the **Solution Explorer** and add a new folder called `Sensors`:![Universal
    Windows app and Raspberry Pi 2](img/00175.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding new folder
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to the `Sensors` folder:![Universal Windows app and Raspberry Pi 2](img/00176.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class called `TelemetryEventArgs.cs`:![Universal Windows app and Raspberry
    Pi 2](img/00177.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a new class
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `TelemetryEventArgs.cs`, replace the existing code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the sensors folder, add a new interface called `IBikeController`. After
    it is created, replace all of the code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This interface will be used by the main app to, well, interface with the Raspberry
    Pi. The Pi communicates back to the main app via an event called `TelemetryCreated`.
    The reason that we used an interface (versus talking directly to the PI) is that
    we want to borrow a bit from the SOLID principles and have several implementations
    for our app: an in-memory bike controller that we can use to make sure everything
    is hooked up correctly and a Raspberry Pi bike controller that actually talks
    to the hardware that we currently have available. Also, there are so many sensors
    available on the market, we need a way of adding in new sensors without changing
    the existing code.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go into the `Sensors` folder and add a new class called `InMemoryBikeController`.
    Replace the existing code with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code simulates an actual Raspberry Pi. Every second, it fires an event
    with some hardcoded telemetry data. It also has a method stub for the `SwitchGears`
    that does nothing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Make sure everything compiles and jumps over to the `MainPage.xaml` file and
    replace all of the contents with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a status box that you can use for debugging. When you deploy this
    app to the Raspberry Pi, this is unnecessary because there is no graphical user
    interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, go into the `MainPage.xaml.cs` file and replace everything with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is where the heavy lifting occurs. When the app starts, it begins a timer
    that fires every second (`_timer_Tick`). If there are over 5 minutes' worth of
    data in the local collection, it generates a `SpeedModel`. It then compares this
    speed model to the global one and if the global output is less than the local
    one, it signals the biker via the `.SwitchGear()`. The actual implementation is
    up to the controller. As you will see in a minute, the Raspberry Pi controller
    turns on an LED that the biker can see. In other examples, we could hook the Pi
    up to the bike's shifting assembly and shift the gears for the biker—an automatic
    transmission for the bike, as it were.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, go into the **Solution Explorer** and right-click on **Properties** and
    change the startup project to **Multiple startup projects** with the `Services`
    and `RP2` projects changed to **Start**. The `Services` project has to be listed
    before the `RP2` one:![Universal Windows app and Raspberry Pi 2](img/00178.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One last thing you need to do before we run this is to deploy the Universal
    Windows application. If you ask me why you need to deploy it first, I will tell
    you, "Because Microsoft said so." Go into the **Solution Explorer** and right-click
    on the `Rp2` project and select **Deploy**:![Universal Windows app and Raspberry
    Pi 2](img/00179.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Deploy option
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now you can run the app and both, the browser will pop up for the service layer
    and the universal Windows app will start:![Universal Windows app and Raspberry
    Pi 2](img/00180.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice nothing much is happening—at least on the screen. That is pretty typical
    of IoT projects; the action is on the device and connected peripherals. If the
    device fired the `NetworkStatus_Changed` event, the device would get the most
    recent global model and upload the global model. You can simulate this by placing
    `GetGlobalModelinMainPage()` and then write it to the status box if you are the
    type of person who wants to see something on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build out the Raspberry Pi implementation of the `BikeController`. Since
    this is a book on machine learning and not on IoT, I will not be covering the
    details of setting up a Raspberry Pi and doing all of the wiring and coding. As
    a frame of reference, I used the example found at [http://ms-iot.github.io/content/en-US/win10/samples/Potentiometer.htm](http://ms-iot.github.io/content/en-US/win10/samples/Potentiometer.htm).
    Basically, each of the sensors would be considered an analog input device (such
    as a potentiometer) that converts its signal to a digital signal. For each of
    the inputs, a `SpiConnection` was created like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And every second, each device''s buffer was read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The readings were aggregated into telemetry data and the event was raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Meanwhile, a different timer was running and shutting off the LED every two
    seconds. The LED was set when the `SwitchGear` method was called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: So the controller app can turn the LED on, and then the Pi turns it off after
    two seconds. You can see the final result in the code sample that accompanies
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I glossed over some important IoT issues that would need to be addressed to
    make this bike app fully functional:'
  prefs: []
  type: TYPE_NORMAL
- en: There are hundreds of input devices that I could have used. You will have to
    write a specific implementation for the devices that you are interested in. Thank
    goodness we have an interface!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to deploy this app to a Raspberry Pi is beyond the scope of this book. You
    can learn more about this at [https://dev.windows.com/en-US/iot](https://dev.windows.com/en-US/iot).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Telemetry to local storage is beyond the scope of this book. This is a universal
    Windows app issue that can be researched at [https://msdn.microsoft.com/en-us/library/windows/apps/dn894631.aspx](https://msdn.microsoft.com/en-us/library/windows/apps/dn894631.aspx).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading the data to the Azure IoT suite is beyond the scope of this book.
    You can find more information on that at [https://www.microsoft.com/en-us/server-cloud/internet-of-things/azure-iot-suite.aspx](https://www.microsoft.com/en-us/server-cloud/internet-of-things/azure-iot-suite.aspx).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a fairly ambitious chapter. We looked at some of the challenges of
    big data and how to use MBrace to help us with distributed machine learning. We
    then created a sample IoT project to show an example of how big data is generated
    and how we can deploy ML models to devices. The IoT app used two ML models to
    give optimal results. We then looked (briefly) at how we can use the power of
    .NET to build multiple input devices so that we can extend across the variety
    of hardware that is, and will be, available for IoT.
  prefs: []
  type: TYPE_NORMAL
