- en: Clustering Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚类模型
- en: With classification models behind us, it is now time to dive into clustering
    models. Currently, in ML.NET there is only one cluster algorithm, k-means. In
    this chapter, we will dive into k-means clustering as well as the various applications
    best suited to utilizing a clustering algorithm. In addition, we will build a
    new ML.NET clustering application that determines the type of a file simply by
    looking at the content. Finally, we will explore how to evaluate a k-means clustering
    model with the properties that ML.NET exposes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在分类模型之后，现在是时候深入探讨聚类模型了。目前，在ML.NET中只有一个聚类算法，即k-means。在本章中，我们将深入探讨k-means聚类以及最适合使用聚类算法的各种应用。此外，我们将构建一个新的ML.NET聚类应用程序，该程序仅通过查看内容就能确定文件的类型。最后，我们将探讨如何使用ML.NET公开的属性来评估k-means聚类模型。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Breaking down the k-means algorithm
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析k-means算法
- en: Creating the clustering application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建聚类应用程序
- en: Evaluating a k-means model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估k-means模型
- en: Breaking down the k-means algorithm
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析k-means算法
- en: As mentioned in [Chapter 1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml), *Getting
    Started with Machine Learning and ML.NET,* k-means clustering, by definition,
    is an unsupervised learning algorithm. This means that data is grouped into clusters
    based on the data provided to the model for training. In this section, we will
    dive into a number of use cases for clustering and the k-means trainer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml)中所述，“使用ML.NET开始机器学习之旅”，根据定义，k-means聚类是一种无监督学习算法。这意味着数据根据提供给模型进行训练的数据被分组到各个簇中。在本节中，我们将深入探讨聚类的多种用例以及k-means训练器。
- en: Use cases for clustering
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚类的用例
- en: Clustering, as you may be beginning to realize, has numerous applications where
    the output categorizes similar outputs into groups of similar data points.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能开始意识到的，聚类有众多应用，其输出将相似输出分类为相似数据点的组。
- en: 'Some of its potential applications include the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它的一些潜在应用包括以下内容：
- en: Natural disaster tracking such as earthquakes or hurricanes and creating clusters
    of high-danger zones
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪自然灾害，如地震或飓风，并创建高风险区域的簇
- en: Book or document grouping based on the authors, subject matter, and sources
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据作者、主题和来源对书籍或文档进行分组
- en: Grouping customer data into targeted marketing predictions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将客户数据分组以进行目标市场营销预测
- en: Search result grouping of similar results that other users found useful
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索结果分组，将其他用户认为有用的相似结果分组在一起
- en: In addition, it has numerous other applications such as predicting malware families
    or medical purposes for cancer research.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还有许多其他应用，如预测恶意软件家族或癌症研究的医疗用途。
- en: Diving into the k-means trainer
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解k-means训练器
- en: The k-means trainer used in ML.NET is based on the Yinyang method as opposed
    to a classic k-means implementation. Like some of the trainers we have looked
    at in previous chapters, all of the input must be of the Float type. In addition,
    all input must be normalized into a single feature vector. Fortunately, the k-means
    trainer is included in the main ML.NET NuGet package; therefore, no additional
    dependencies are required.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ML.NET中使用的k-means训练器是基于阴阳方法，而不是经典的k-means实现。像我们在前几章中查看的一些训练器一样，所有输入都必须是Float类型。此外，所有输入都必须归一化到一个单一的特征向量中。幸运的是，k-means训练器包含在主要的ML.NET
    NuGet包中；因此，不需要额外的依赖项。
- en: To learn more about the Yinyang implementation, Microsoft Research published
    a white paper here: [https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/ding15.pdf](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/ding15.pdf).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于阴阳实现的信息，微软研究院在此发布了白皮书：[https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/ding15.pdf](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/ding15.pdf)。
- en: 'Take a look at the following diagram, showing three clusters and a data point:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图表，展示了三个簇和一个数据点：
- en: '![](img/b7759f97-a307-4176-a449-ad7e854ac847.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b7759f97-a307-4176-a449-ad7e854ac847.png)'
- en: In clustering, each of these clusters represents a grouping of similar data
    points. With k-means clustering (and other clustering algorithms), the distances
    between the data point and each of the clusters are the measures of which cluster
    the model will return. For k-means clustering specifically, it uses the center
    point of each of these clusters (also called a centroid) and then calculates the
    distance to the data point. The smallest of these values is the predicted cluster.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在聚类中，每个这些簇代表了一组相似数据点的分组。对于 k-means 聚类（以及其他聚类算法），数据点与每个簇之间的距离是模型将返回哪个簇的度量。对于
    k-means 聚类特别来说，它使用每个簇的中心点（也称为质心）并计算到数据点的距离。这些值中最小的是预测的簇。
- en: For the k-means trainer, it can be initialized in one of three ways. One way
    is to utilize a randomized initialization—as you have probably guessed, this can
    lead to randomized prediction results. Another way is to utilize k-means++, which
    strives to produce O(log K) predictions. Lastly, k-means||, the default method
    in ML.NET, uses a parallel method to reduce the number of passes required to initialize.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 k-means 训练器，它可以以三种方式之一进行初始化。一种方式是使用随机初始化——正如你可能猜到的，这可能导致随机的预测结果。另一种方式是使用
    k-means++，它力求产生 O(log K) 的预测。最后，ML.NET 的默认方法 k-means|| 使用并行方法来减少初始化所需的遍历次数。
- en: For more information on k-means||, you can refer to a paper published by Stanford,
    which explains it in detail: [https://theory.stanford.edu/~sergei/papers/vldb12-kmpar.pdf](https://theory.stanford.edu/~sergei/papers/vldb12-kmpar.pdf).
    [](https://theory.stanford.edu/~sergei/papers/vldb12-kmpar.pdf)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 k-means|| 的更多信息，你可以参考斯坦福大学发表的一篇论文，其中对其进行了详细解释：[https://theory.stanford.edu/~sergei/papers/vldb12-kmpar.pdf](https://theory.stanford.edu/~sergei/papers/vldb12-kmpar.pdf)。
- en: 'For more information on k-means++, you can refer to a paper published by Stanford in
    2006, explaining it in detail: [http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf](http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 k-means++ 的更多信息，你可以参考斯坦福大学在 2006 年发表的一篇论文，其中对其进行了详细解释：[http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf](http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf)。
- en: We will demonstrate this trainer in the example application in the next section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中演示这个训练器。
- en: Creating the clustering application
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建聚类应用程序
- en: As mentioned earlier, the application we will be creating is a file type classifier.
    Given a set of attributes statically extracted from a file, the prediction will
    return if it is a document, an executable, or a script. For those of you who have
    used the Linux `file` command, this is a simplified version but based on machine
    learning. The attributes included in this example aren't the definitive list of
    attributes, nor should they be used as-is in a production environment; however,
    you could use this as a starting point for creating a true ML-based replacement
    for the Linux `file` command.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将创建的应用程序是一个文件类型分类器。给定从文件中静态提取的一组属性，预测将返回它是一个文档、可执行文件还是脚本。对于那些使用过 Linux
    `file` 命令的人来说，这是一个简化的版本，但基于机器学习。本例中包含的属性不是属性的确切列表，也不应在生产环境中直接使用；然而，你可以将其用作创建基于机器学习的
    Linux `file` 命令替代品的起点。
- en: As with previous chapters, the completed project code, sample dataset, and project
    files can be downloaded here: [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter05](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter05).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的章节一样，完整的项目代码、样本数据集和项目文件可以在此处下载：[https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter05](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter05)。
- en: Exploring the project architecture
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索项目架构
- en: Building on the project architecture and code we created in previous chapters,
    the major change architecturally is in the feature extraction being done on both
    the training and test sets.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面章节中创建的项目架构和代码的基础上，主要的架构变化是在训练集和测试集上进行的特征提取。
- en: 'Here, you will find the Visual Studio Solution Explorer view of the project.
    The new additions to the solution are the `FileTypes`, `FileData`, and `FilePrediction`
    files that we will review later on in this section:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以找到项目的 Visual Studio Solution Explorer 视图。解决方案中的新增文件是 `FileTypes`、`FileData`
    和 `FilePrediction` 文件，我们将在本节稍后进行回顾：
- en: '![](img/7b2bdf6a-0c57-43f5-bd7b-22b0dba1c1c3.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b2bdf6a-0c57-43f5-bd7b-22b0dba1c1c3.png)'
- en: 'The `sampledata.csv` file contains 80 rows of random files I had on my system,
    comprising 30 Windows executables, 20 PowerShell scripts, and 20 Word documents.
    Feel free to adjust the data to fit your own observations or to adjust the trained
    model. Here is a snippet of the data:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampledata.csv` 文件包含了我系统上的 80 行随机文件，包括 30 个 Windows 可执行文件，20 个 PowerShell
    脚本和 20 个 Word 文档。请随意调整数据以适应您的观察或调整训练好的模型。以下是数据的一个片段：'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each of these rows contains the value for the properties in the newly created
    `FileData` class that we will review later on in this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都包含新创建的 `FileData` 类中属性的值，我们将在本章稍后进行回顾。
- en: 'In addition to this, we added the `testdata.csv` file, which contains additional
    data points to test the newly trained model against and evaluate. The breakdown
    was even with 10 Windows executables, 10 PowerShell scripts, and 10 Word documents.
    Here is a snippet of the data inside `testdata.csv`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还添加了 `testdata.csv` 文件，其中包含额外的数据点，用于测试新训练的模型并评估。分布是均匀的，包括 10 个 Windows
    可执行文件，10 个 PowerShell 脚本和 10 个 Word 文档。以下是 `testdata.csv` 内部数据的一个片段：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Diving into the code
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入代码
- en: For this application, as noted in the previous section, we are building on top
    of the work completed in [Chapter 4](da0d1d99-ad37-498b-8670-f8cee6ad49bc.xhtml),
    *Classification Model*. For this deep dive, we are going to focus solely on the
    code that was changed for this application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，对于这个应用，我们正在构建在 [第 4 章](da0d1d99-ad37-498b-8670-f8cee6ad49bc.xhtml) 完成的作品之上，即
    *分类模型*。对于这次深入探讨，我们将专注于为这个应用更改的代码。
- en: 'Classes that were changed or added are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 被更改或添加的类如下：
- en: '`Constants`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Constants`'
- en: '`` `BaseML` ``'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `BaseML` ``'
- en: '`FileTypes`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileTypes`'
- en: '`FileData`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileData`'
- en: '`FileTypePrediction`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileTypePrediction`'
- en: '`FeatureExtractor`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FeatureExtractor`'
- en: '`Predictor`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Predictor`'
- en: '`Trainer`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trainer`'
- en: '`Program`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Program`'
- en: The Constants class
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Constants` 类'
- en: 'The `Constants` class has been changed to save the model to `chapter5.mdl`,
    in addition to supporting a feature-extracted `testdata.csv` variable. The following
    code block reflects these changes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Constants` 类已被更改，以将模型保存到 `chapter5.mdl`，同时支持提取特征的 `testdata.csv` 变量。以下代码块反映了这些更改：'
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The BaseML class
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`BaseML` 类'
- en: 'The sole change in the `BaseML` class is the addition of the `FEATURES` variable.
    By using a variable here, we can remove the use of a magic string in our `Trainer`
    class (we will discuss this later in this section):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BaseML` 类中唯一的更改是添加了 `FEATURES` 变量。通过在这里使用变量，我们可以移除在 `Trainer` 类中使用魔法字符串的需求（我们将在本节稍后讨论这一点）：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The FileTypes enumeration
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`FileTypes` 枚举'
- en: 'The `FileTypes` enumeration contains a strongly typed method for mapping our
    classifications and a numeric value. As we discovered in our previous examples,
    utilizing an enumeration as opposed to magic or constant values provides better
    flexibility, as shown here and throughout the remaining classes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileTypes` 枚举包含一个强类型方法，用于映射我们的分类和数值。正如我们在先前的示例中所发现的那样，使用枚举而不是魔法或常量值提供了更好的灵活性，正如这里和剩余类中所示：'
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The FileData class
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`FileData` 类'
- en: 'The `FileData`class is the container class that contains the data to both predict
    and train our model:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileData` 类是包含用于预测和训练我们的模型的数据的容器类：'
- en: 'First, we add constant values for `True` and `False` since k-means requires
    floating-point values:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加了 `True` 和 `False` 的常量值，因为 k-means 需要浮点数值：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we create a constructor that supports both our prediction and training.
    We optionally pass in the filename for the training to provide a label, in this
    case, `ps1`, `exe`, and `doc` for scripts, executables, and documents, respectively.
    We also call helper methods to determine whether the file is binary, or whether
    it starts with MZ or PK:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个构造函数，它支持我们的预测和训练。我们可以选择性地传递训练的文件名以提供标签，在这种情况下，对于脚本、可执行文件和文档，分别是 `ps1`、`exe`
    和 `doc`。我们还调用辅助方法来确定文件是否为二进制文件，或者它是否以 MZ 或 PK 开头：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: MZ and PK are considered to be magic numbers of Windows executables and modern
    Microsoft Office files. Magic numbers are unique byte strings that are found at
    the beginning of every file. In this case, both are simply two bytes. When performing
    analysis on files, making quick determinations is crucial for performance. For
    the keen reader, PK is also the magic number for ZIP. Modern Microsoft Office
    documents are actually ZIP archives. For the sake of simplicity in this example,
    PK is used as opposed to performing an additional level of detection.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: MZ和PK被认为是Windows可执行文件和现代Microsoft Office文件的魔法数字。魔法数字是位于每个文件开头的唯一字节字符串。在这种情况下，两者都是两个字节。在分析文件时，快速确定对于性能至关重要。对于细心的读者，PK也是ZIP的魔法数字。现代Microsoft
    Office文档实际上是ZIP存档。为了简化本例，我们使用PK而不是执行额外的检测级别。
- en: 'Next, we also add an additional constructor to support the hard truth setting
    of values. We will deep dive into the purpose of this addition later on in this
    section:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们还添加了一个额外的构造函数来支持值的硬真设置。我们将在本节稍后深入了解此添加的目的：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we implement our two helper methods. The first, `HasBinaryContent`, as
    the name implies, takes the raw binary data and searches for non-text characters
    to ensure it is a binary file. Secondly, we define `HasHeaderBytes`; this method
    takes an array of bytes, converts it into a `UTF8` string, and then checks to
    see whether the string matches the string passed in:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们实现我们的两个辅助方法。第一个，`HasBinaryContent`，正如其名所示，接受原始二进制数据并搜索非文本字符以确保它是一个二进制文件。其次，我们定义`HasHeaderBytes`；此方法接受一个字节数组，将其转换为`UTF8`字符串，然后检查该字符串是否与传入的字符串匹配：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we add the properties used for prediction, training, and testing:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加用于预测、训练和测试的属性：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lastly, we override the `ToString` method to be used with the feature extraction:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们重写`ToString`方法以用于特征提取：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The FileTypePrediction class
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`FileTypePrediction`类'
- en: 'The `FileTypePrediction`class contains the properties mapped to our prediction
    output. In k-means clustering, the `PredictedClusterId` property stores the closest
    cluster found. In addition to this, the `Distances` array contains the distances
    from the data point to each of the clusters:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileTypePrediction`类包含映射到我们的预测输出的属性。在k-means聚类中，`PredictedClusterId`属性存储找到的最近簇。此外，`Distances`数组包含数据点到每个簇的距离：'
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The FeatureExtractor class
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`FeatureExtractor`类'
- en: 'The `FeatureExtractor` class that we utilized in the logistic regression example
    from [Chapter 3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml), *Regression Model*,
    has been adapted to support both test and training data extraction:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml)的“回归模型”示例中使用的`FeatureExtractor`类已被调整以支持测试和训练数据提取：
- en: 'First, we generalize the extraction to take the folder path and the output
    file. As noted earlier, we also pass in the filename, providing the `Labeling`
    to occur cleanly inside the `FileData` class:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将提取泛化到接受文件夹路径和输出文件。如前所述，我们还传递了文件名，以确保`Labeling`在`FileData`类内部干净地发生：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lastly, we take the two parameters from the command line (called from the `Program`
    class) and simply call the preceding method a second time:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们从命令行中获取两个参数（由`Program`类调用）并简单地再次调用前面的方法：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Predictor class
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Predictor`类'
- en: 'There are a couple of changes in this class to handle the file type prediction
    scenario:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类中有一两个更改来处理文件类型预测场景：
- en: 'First, we add a helper method, `GetClusterToMap`, which maps known values to
    the prediction clusters. Note the use of `Enum.GetValues` here; as you add more
    file types, this method does not need to be modified:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加一个辅助方法`GetClusterToMap`，它将已知值映射到预测簇。注意这里使用`Enum.GetValues`；随着你添加更多文件类型，此方法不需要修改：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we pass in the `FileData` and `FileTypePrediction` types into the `CreatePredictionEngine`
    method to create our prediction engine. Then, we read the file in as a binary
    file and pass these bytes into the constructor of `FileData` prior to running
    the prediction and mapping initialization:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将`FileData`和`FileTypePrediction`类型传递给`CreatePredictionEngine`方法以创建我们的预测引擎。然后，我们将文件作为二进制文件读取，并在运行预测和映射初始化之前将这些字节传递给`FileData`构造函数：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, we need to adjust the output to match the output that a k-means prediction
    returns, including the Euclidean distances:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要调整输出以匹配k-means预测返回的输出，包括欧几里得距离：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Trainer class
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Trainer`类'
- en: 'Inside the `Trainer` class, several modifications need to be made to support
    k-means classification:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Trainer`类内部，需要进行一些修改以支持k-means分类：
- en: 'The first change is the addition of a `GetDataView` helper method, which builds
    the `IDataView` object from the columns previously defined in the `FileData` class:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个变化是添加了一个`GetDataView`辅助方法，它从`FileData`类中先前定义的列构建`IDataView`对象：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then build the data process pipeline, transforming the columns into a single
    `Features` column:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来构建数据处理管道，将列转换为一个单独的`Features`列：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can then create the k-means trainer with a cluster size of 3 and create
    the model:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个具有3个聚类的k-means训练器并创建模型：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The default value for the number of clusters is 5\. An interesting experiment
    to run based either on this dataset or one modified by you is to see how the prediction
    results change by adjusting this value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类数量的默认值为5。一个有趣的实验是基于这个数据集或您修改后的数据集，看看通过调整这个值预测结果如何变化。
- en: 'Now we evaluate the model we just trained using the testing dataset:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用测试数据集评估我们刚刚训练的模型：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we output all of the classification metrics, each of which we will
    detail in the next section:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们输出所有分类度量，我们将在下一节中详细介绍每个度量。
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Program class
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Program`类'
- en: 'The `Program` class, as mentioned in previous chapters, is the main entry point
    for our application. The only change in the `Program` class is the help text to
    indicate usage for the extract to accept the test folder path for extraction:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，`Program`类是我们应用程序的主要入口点。`Program`类中唯一的变化是帮助文本，用于指示如何使用`extract`方法接受提取测试文件夹路径：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we modify the `switch`/`case` statement to support the additional
    parameter to the `extract` method to support both the training and test datasets:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们修改`switch`/`case`语句以支持`extract`方法的附加参数，以支持训练和测试数据集：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Running the application
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'To run the application, the process is nearly identical to [Chapter 3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml), *Regression
    Model*''s example application with the addition of passing in the test dataset
    when training:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行应用程序，过程几乎与[第3章](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml)中*回归模型*的示例应用程序相同，只是在训练时传递测试数据集：
- en: 'To run the training on the command line as we did in previous chapters, simply
    pass in the following command (assuming you have added two sets of files; one
    each for your training and test sets):'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在命令行上运行训练，就像我们在前几章中所做的那样，只需传递以下命令（假设您已添加两组文件；一组用于您的训练集，另一组用于测试集）：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Included in the code repository are two pre-feature extracted files (`sampledata.csv`
    and t`estdata.csv`) to allow you to train a model without performing your own
    feature extraction.  If you would like to perform your own feature extraction,
    create a `TestData` and `TrainingData` folder.  Populate these folders with a
    sampling of **PowerShell **(**PS1**), **Windows Executables** (**EXE**) and **Microsoft
    Word documents** (**DOCX**).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库中包含两个预特征提取文件（`sampledata.csv`和`t`estdata.csv`），以便您可以在不执行自己的特征提取的情况下训练模型。如果您想执行自己的特征提取，创建一个`TestData`和`TrainingData`文件夹。在这些文件夹中填充**PowerShell**（**PS1**）、**Windows可执行文件**（**EXE**）和**Microsoft
    Word文档**（**DOCX**）的样本。
- en: 'After extracting the data, we must then train the model by passing in the newly
    created `sampledata.csv` and `testdata.csv` files:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提取数据后，我们必须通过传递新创建的`sampledata.csv`和`testdata.csv`文件来训练模型：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To run the model with this file, simply pass in the filename to the built application
    (in this case, the compiled `chapter05.exe` is used) and the predicted output
    will show:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用此文件运行模型，只需将文件名传递给构建的应用程序（在这种情况下，使用编译的`chapter05.exe`）即可，预测输出将显示：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note the expanded output to include several metric data points—we will go through
    what each one of these means at the end of this chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出已扩展以包括几个度量数据点——我们将在本章末尾详细介绍每个数据点的含义。
- en: 'Feel free to modify the values and see how the prediction changes based on
    the dataset that the model was trained on. A few areas of experimentation from
    this point could include the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 随意修改值，并查看基于模型训练数据集的预测如何变化。从这个点开始的一些实验领域可能包括以下内容：
- en: Adding some additional features to increase the prediction accuracy
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一些额外的功能以提高预测准确性
- en: Adding additional file types to the clusters such as video or audio
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向聚类中添加额外的文件类型，如视频或音频
- en: Adding a new range of files to generate new sample and test data
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的文件范围以生成新的样本和测试数据
- en: Evaluating a k-means model
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估k-means模型
- en: As discussed in previous chapters, evaluating a model is a critical part of
    the overall model-building process. A poorly trained model will only provide inaccurate
    predictions. Fortunately, ML.NET provides many popular attributes to calculate
    model accuracy based on a test set at the time of training to give you an idea
    of how well your model will perform in a production environment.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，评估模型是整个模型构建过程中的关键部分。一个训练不当的模型只会提供不准确的预测。幸运的是，ML.NET提供了许多流行的属性，可以根据训练时的测试集计算模型精度，从而让你了解你的模型在生产环境中将如何表现。
- en: 'In ML.NET, as noted in the example application, there are three properties
    that comprise the `ClusteringMetrics` class object. Let''s dive into the properties
    exposed in the `ClusteringMetrics` object:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在ML.NET中，正如示例应用程序中提到的，有三个属性构成了`ClusteringMetrics`类对象。让我们深入了解`ClusteringMetrics`对象公开的属性：
- en: Average distance
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均距离
- en: The Davies-Bouldin index
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Davies-Bouldin指数
- en: Normalized mutual information
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化互信息
- en: In the next sections, we will break down how these values are calculated and
    the ideal values to look for.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将分解这些值的计算方法以及理想值。
- en: Average distance
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平均距离
- en: Also referred to as the **average score** is the distance from the center of
    a cluster to the test data. The value, of type double, will decrease as the number
    of clusters increases, effectively creating clusters for the edge cases. In addition
    to this, a value of 0, such as the one found in our example, is possible when
    your features create distinct clusters. This means that, if you find yourself
    seeing poor prediction performance, you should increase the number of clusters.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 也被称为**平均得分**的是簇中心到测试数据的距离。该值，类型为double，随着簇数量的增加而减小，有效地为边缘情况创建簇。此外，当你的特征创建出独特的簇时，可能存在一个值为0的情况，就像我们在示例中看到的那样。这意味着，如果你发现自己看到较差的预测性能，你应该增加簇的数量。
- en: The Davies-Bouldin Index
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Davies-Bouldin指数
- en: The Davies-Bouldin Index is another measure for the quality of the clustering.
    Specifically, the Davies-Bouldin Index measures the scatter of cluster separation
    with values ranging from 0 to 1 (of type double), with a value of 0 being ideal
    (as was the case of our example).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Davies-Bouldin指数是衡量聚类质量的另一个指标。具体来说，Davies-Bouldin指数衡量簇分离的散布，值范围从0到1（类型为double），值为0是理想的（正如我们的示例所示）。
- en: For more details on the Davies-Bouldin Index, specifically the math behind the
    algorithm, a good resource can be found here: [https://en.wikipedia.org/wiki/Davies%E2%80%93Bouldin_index](https://en.wikipedia.org/wiki/Davies%E2%80%93Bouldin_index).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Davies-Bouldin指数的更多细节，特别是算法背后的数学，可以在以下资源中找到：[https://en.wikipedia.org/wiki/Davies%E2%80%93Bouldin_index](https://en.wikipedia.org/wiki/Davies%E2%80%93Bouldin_index)。
- en: Normalized mutual information
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准化互信息
- en: The normalized mutual information metric is used to measure the mutual dependence
    of the feature variables.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化互信息度量用于衡量特征变量的相互依赖性。
- en: The range of values is from 0 to 1 (the type is of double)—closer to or equal
    to 1 is ideal, akin to the model we trained earlier in this chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 值的范围是从0到1（类型为double），越接近或等于1越理想，类似于本章早期训练的模型。
- en: For more details on normalized mutual information along with the math behind
    the algorithm, please read [http://en.wikipedia.org/wiki/Mutual_information#Normalized_variants](http://en.wikipedia.org/wiki/Mutual_information#Normalized_variants).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 关于标准化互信息的更多细节以及算法背后的数学，请阅读[http://en.wikipedia.org/wiki/Mutual_information#Normalized_variants](http://en.wikipedia.org/wiki/Mutual_information#Normalized_variants)。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Over the course of this chapter, we dove into ML.NET's clustering support via
    the k-means clustering algorithm. We have also created and trained our first clustering
    application using k-means to predict what file type a file is. Lastly, we dove
    into how to evaluate a k-means clustering model and the various properties that
    ML.NET exposes to achieve a proper evaluation of a k-means clustering model.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们深入探讨了ML.NET通过k-means聚类算法提供的聚类支持。我们还创建并训练了我们的第一个聚类应用程序，使用k-means来预测文件类型。最后，我们探讨了如何评估k-means聚类模型以及ML.NET公开的各种属性，以实现k-means聚类模型的正确评估。
- en: In the next chapter, we will deep dive into anomaly detection algorithms with
    ML.NET by creating a login anomaly predictor.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过创建登录异常预测器来深入探讨ML.NET中的异常检测算法。
