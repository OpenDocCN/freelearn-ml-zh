<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Reinforcement Learning"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Reinforcement Learning</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Markov chains - the stocks regime switching model</li><li class="listitem" style="list-style-type: disc">Markov chains - the multi-channel attribution model</li><li class="listitem" style="list-style-type: disc">Markov chains - the car rental agency service</li><li class="listitem" style="list-style-type: disc">Continuous Markov chains - vehicle service at the gas station</li><li class="listitem" style="list-style-type: disc">Monte Carlo simulations - calibrated hull and white short-rates</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec40"/>Introduction</h1></div></div></div><p>
<span class="strong"><strong>The Markov chain</strong></span>: A sequence  of trials of an experiment is a Markov chain if the outcome of each experiment is one of the set of discrete states, and the outcome of the experiment is dependent only on the present state and not of any of the past states. The probability of changing from one state to another state is represented as<span class="inlinemediaobject"><img src="graphics/image_08_001.jpg" alt="Introduction"/></span>. It is called a transition probability. The transition probability matrix is an n × n matrix such that each element of the matrix is non-negative and each row of the matrix sums to one.</p><p>
<span class="strong"><strong>Continuous time Markov chains</strong></span>: Continuous-time Markov chains can be labeled as transition systems augmented with rates that have discrete states. The states have continuous time-steps and the delays are exponentially distributed. Continuous-time Markov chains are suited to model reliability models, control systems, biological pathways, chemical reactions, and so on.</p><p>
<span class="strong"><strong>Monte Carlo simulations</strong></span>: Monte Carlo simulation  is a stochastic simulation of system behavior. The simulation uses sampling experiments to be performed on the model and then conducts numerical experiments using the computer to obtain a statistical understanding of the system behavior. Monte Carlo simulations are used to construct theories for observed behavior of complicated systems, predict future behavior of a system, and study effects on final results based upon input and parameter changes within a system. The stochastic simulation is a way of experimenting with a system to find ways to improve or better understand the system behavior. It uses random numbers that are uniformly distributed over the interval [0, 1]. These uniformly distributed random numbers are used for the generation of stochastic variables from various probability distributions. Sampling experiments are then generated, which are associated with the modeling of system behavior.</p></div></div>
<div class="section" title="Markov chains - the stocks regime switching model"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec41"/>Markov chains - the stocks regime switching model</h1></div></div></div><p>In the last few decades, a lot of studies have been conducted on the analysis and forecasting of volatility. Volatility is the degree of variation of a trading price series over time as measured by the standard deviation of returns. Models of stock returns assume that the returns follow a geometric Brownian motion. This implies that over any discrete time interval, the return on stocks is log normally distributed and that returns in non-overlapping intervals are independent. Studies have found that this model fails to capture extreme price movements and stochastic variability in the volatility parameter. Stochastic volatility takes discrete values, switching between these values randomly. This is the basis of the <span class="strong"><strong>regime-switching lognormal process</strong></span> (<span class="strong"><strong>RSLN</strong></span>).</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec49"/>Getting ready</h2></div></div></div><p>In order to perform the Markov chains regime switching model we shall be using data collected from the Stock's dataset.</p><div class="section" title="Step 1 - collecting and describing the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec125"/>Step 1 - collecting and describing the data</h3></div></div></div><p>The dataset called <code class="literal">StocksRegimeSwitching.csv</code> shall be used. This dataset is available in csv format and called <code class="literal">StocksRegimeSwitching.csv</code>. The dataset is in the standard format. There are 66 rows of data. There are seven variables. The numeric variables are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LRY</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">LRV</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">INT</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">LRC</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">LVS</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">LGS</code></li></ul></div><p>The non-numeric variable is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">DATE</code></li></ul></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec50"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - exploring the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec126"/>Step 2 - exploring the data</h3></div></div></div><p>The first step is to load the following packages:</p><pre class="programlisting">
<span class="strong"><strong>    &gt;install.packages("MSwM")</strong></span>
<span class="strong"><strong>    &gt;library(MSwM)</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Version info: Code for this page was tested in R version 3.2.2 (2015-08-14).</p></div></div><p>Let's explore the data and understand the relationships between the variables. We'll begin by importing the CSV data file called <code class="literal">StocksRegimeSwitching.csv</code>. We will be saving the data to the <code class="literal">MarkovSwitchData</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; MarkovSwitchData &lt;- read.csv("d:/StocksRegimeSwitching.csv", header = TRUE)</strong></span>
</pre><p>Attaching the dataset. The <code class="literal">attach()</code> function attaches the dataset to the search path. The dataset is searched when evaluating the variables. <code class="literal">MarkovSwitchData</code> is passed as a parameter:</p><pre class="programlisting">
<span class="strong"><strong>&gt; attach(MarkovSwitchData)</strong></span>
</pre><p>Printing the <code class="literal">MarkovSwitchData</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">MarkovSwitchData</code> data frame. The <code class="literal">MarkovSwitchData</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(MarkovSwitchData)</strong></span>
</pre><p>The results are as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_002.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>Exploring the dimension of the <code class="literal">MarkovSwitchData</code> data frame. The <code class="literal">dim()</code>function returns the dimension of the <code class="literal">MarkovSwitchData</code> frame. The <code class="literal">MarkovSwitchData</code> data frame is passed as an input parameter. The result clearly states that there are 66 rows of data and seven single columns:</p><pre class="programlisting">
<span class="strong"><strong>&gt; dim(MarkovSwitchData)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_003.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>Printing the summary of the <code class="literal">MarkovSwitchData</code> data frame. The <code class="literal">summary()</code> function is a multipurpose function. The <code class="literal">summary()</code> function is a generic function that provides a summary of the data related to the individual object or data frame. The <code class="literal">MarkovSwitchData</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(MarkovSwitchData)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_004.jpg" alt="Step 2 - exploring the data"/></div><p>
</p></div><div class="section" title="Step 3 - preparing the regression model"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec127"/>Step 3 - preparing the regression model</h3></div></div></div><p>A regression model will be prepared on the dataset. Regression analysis is used when two or more variables are thought to be systematically connected by a linear relationship. Regression models are used to predict one variable from another variable. They provide a prediction about the past, present, and future events, based on information.</p><p>Defining the dependent variable. The <code class="literal">cbind()</code> function is used to define the dependent variable. The function takes in the <code class="literal">LVS</code> data frame. The resulting data frame is stored in the <code class="literal">yLogValueStocks</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; yLogValueStocks &lt;- cbind(LVS)</strong></span>
</pre><p>Printing the <code class="literal">yLogValueStocks</code> frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">yLogValueStocks</code> frame. The <code class="literal">yLogValueStocks</code> frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(yLogValueStocks)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_005.jpg" alt="Step 3 - preparing the regression model"/></div><p>
</p><p>The <code class="literal">cbind ()</code> function takes in the <code class="literal">LGS</code> data frame. The resulting data frame is stored in the <code class="literal">yLogGrowthStocks</code> data frame.</p><p>Printing the <code class="literal">yLogGrowthStocks</code> frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">yLogGrowthStocks</code> data frame. The <code class="literal">yLogGrowthStocks</code> frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(yLogGrowthStocks)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_006.jpg" alt="Step 3 - preparing the regression model"/></div><p>
</p><p>Defining the independent variable The <code class="literal">cbind()</code> function is used to define the dependent variable. The function takes in the <code class="literal">LRY</code>, <code class="literal">LRC</code>, <code class="literal">INT</code>, <code class="literal">LRV</code> data frames. The resulting data frame is stored in the <code class="literal">x</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; x &lt;- cbind(LRY, LRC, INT, LRV)</strong></span>
</pre><p>Creating an <span class="strong"><strong>ordinary least square</strong></span> (<span class="strong"><strong>OLS</strong></span>) regression equation. The <code class="literal">lm()</code> function is used to fit linear models. The model to be fitted is represented symbolically by <code class="literal">yLogValueStocks~x</code>. The result is then stored in the <code class="literal">olsLogValueStocks</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; olsLogValueStocks &lt;- lm(yLogValueStocks~x)</strong></span>
</pre><p>Printing the summary of the <code class="literal">olsLogValueStocks</code> data frame. The <code class="literal">summary()</code> function is used to provide a summary of the data related to the individual object or data frame. The <code class="literal">olsLogValueStocks</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(olsLogValueStocks)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_007.jpg" alt="Step 3 - preparing the regression model"/></div><p>
</p><p>Creating an ordinary least square regression equation. The model to be fitted is represented symbolically by <code class="literal">yLogGrowthStocks~x</code>. The result is then stored in the <code class="literal">olsLogGrowthStocks</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; olsLogGrowthStocks &lt;- lm(yLogGrowthStocks~x)</strong></span>
</pre><p>Printing the summary of the <code class="literal">olsLogGrowthStocks</code> data frame. The <code class="literal">olsLogGrowthStocks</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(olsLogGrowthStocks)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_008.jpg" alt="Step 3 - preparing the regression model"/></div><p>
</p></div><div class="section" title="Step 4 - preparing the Markov-switching model"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec128"/>Step 4 - preparing the Markov-switching model</h3></div></div></div><p>The Markov switching model involves multiple equations that can characterize the time series behaviors in different regimes. The model is able to capture complex dynamic patterns by switching between structures. The current value of the state variable depends on the immediate past value, which is controlled by the Markovian property.</p><p>Creating a Markov switching model for the value of stocks. The <code class="literal">msmFit()</code> function implements a Markov switching models using the EM algorithm, as follows. <code class="literal">olsLogValueStocks</code> is of the object class of the <code class="literal">lm</code> type. <code class="literal">k = 2</code> represents the estimated number of regimes. The result is stored in the <code class="literal">MarkovSwtchLogValueStocks</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; MarkovSwtchLogValueStocks &lt;- msmFit(olsLogValueStocks, k = 2, sw = rep(TRUE, 6))</strong></span>
</pre><p>Printing the summary of the <code class="literal">MarkovSwtchLogValueStocks</code> data frame as follows. The <code class="literal">MarkovSwtchLogValueStocks</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(MarkovSwtchLogValueStocks)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_009.jpg" alt="Step 4 - preparing the Markov-switching model"/></div><p>
</p><p>
<span class="strong"><strong>
</strong></span>
</p><div class="mediaobject"><img src="graphics/image_08_010.jpg" alt="Step 4 - preparing the Markov-switching model"/></div><p>
</p><p>Creating a Markov switching model for growth stocks. The <code class="literal">msmFit()</code> function implements the Markov switching model using the EM algorithm. <code class="literal">olsLogGrowthStocks</code> is of the object class of the <code class="literal">lm</code> type. <code class="literal">k = 2</code> represents the estimated number of regimes. The result is stored in the <code class="literal">MarkoSwtchLogGrowthStocks</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; MarkoSwtchLogGrowthStocks&lt;- msmFit(olsLogGrowthStocks, k = 2, sw = rep(TRUE, 6))</strong></span>
</pre><p>Printing the summary of the <code class="literal">MarkoSwtchLogGrowthStocksdata</code> frame. The <code class="literal">MarkoSwtchLogGrowthStocks</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(MarkoSwtchLogGrowthStocks)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_011.jpg" alt="Step 4 - preparing the Markov-switching model"/></div><p>
</p><p>
<span class="strong"><strong>
</strong></span>
</p><div class="mediaobject"><img src="graphics/image_08_012.jpg" alt="Step 4 - preparing the Markov-switching model"/></div><p>
</p></div><div class="section" title="Step 5 - plotting the regime probabilities"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec129"/>Step 5 - plotting the regime probabilities</h3></div></div></div><p>Next we shall be plotting the regime probabilities that have been calculated.</p><p>Plotting the regime probabilities for the value of stocks. The <code class="literal">par()</code> function is used to query the graphical parameters as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; par(mar=c(3,3,3,3))</strong></span>
</pre><p>The <code class="literal">plotProb()</code> function creates each plot for each regime. The plot contains smoothed and filtered probabilities. <code class="literal">MarkovSwtchLogValueStocks</code> is passed as an object of type <code class="literal">MSM.lm</code>. The <code class="literal">which = 1</code> value represents the subset of the plots that is required. Use the following command:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plotProb(MarkovSwtchLogValueStocks, which=1)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_013.jpg" alt="Step 5 - plotting the regime probabilities"/></div><p>
</p><p>The <code class="literal">plotProb()</code> function creates each plot for each regime. The plot contains smoothed and filtered probabilities. <code class="literal">MarkovSwtchLogValueStocks</code> is passed as an object of the <code class="literal">MSM.lm </code>type. The <code class="literal">which = 2</code> value represents the plot of the regime with the response variable against the smoothed probabilities. Use the following command:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plotProb(MarkovSwtchLogValueStocks, which=2)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_014.jpg" alt="Step 5 - plotting the regime probabilities"/></div><p>
</p><p>The <code class="literal">plotProb()</code> function creates each plot for each regime. <code class="literal">MarkoSwtchLogGrowthStocks</code> is passed as an object of the <code class="literal">MSM.lm</code> type. The <code class="literal">which = 1</code> value represents the subset of the plots that is required:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plotProb(MarkoSwtchLogGrowthStocks, which=1)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_015.jpg" alt="Step 5 - plotting the regime probabilities"/></div><p>
</p><p>The <code class="literal">plotProb()</code> function creates each plot for each regime. <code class="literal">MarkoSwtchLogGrowthStocks</code> is passed as an object of  the <code class="literal">MSM.lm</code> type. The <code class="literal">which = 2</code> value represents the plot of the regime with the response variable against the smoothed probabilities. Use the following command:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plotProb(MarkoSwtchLogGrowthStocks, which=2)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_016.jpg" alt="Step 5 - plotting the regime probabilities"/></div><p>
</p></div><div class="section" title="Step 6 - testing the Markov switching model"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec130"/>Step 6 - testing the Markov switching model</h3></div></div></div><p>Next we shall run a set of diagnostic tests on the Markov switching model.</p><p>Ploting the regime probabilities for the value of stocks. The <code class="literal">par()</code> function is used to query graphical parameters:</p><pre class="programlisting">
<span class="strong"><strong>&gt; par(mar=c(3,3,3,3))</strong></span>
</pre><p>Creating the plots for the residual analysis. The <code class="literal">plotDiag()</code> function plots the residuals against the fitted values. <code class="literal">MarkovSwtchLogValueStocks</code> is passed as an object of the <code class="literal">MSM.lm</code> type. The <code class="literal">which = 1</code> value represents the subset of the plots is that required. The <code class="literal">which=1</code> value represents the plot of residuals against fitted values:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plotDiag(MarkovSwtchLogValueStocks, regime=1, which=1)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_017.jpg" alt="Step 6 - testing the Markov switching model"/></div><p>
</p><p>The <code class="literal">plotDiag()</code> function plots the residuals against the fitted values. <code class="literal">MarkovSwtchLogValueStocks</code> is passed as an object of the <code class="literal">MSM.lm</code> type. <code class="literal">which = 2</code> represents the subset of the plots that is required. <code class="literal">which=2</code> represents the Normal Q-Q plot:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plotDiag(MarkovSwtchLogValueStocks, regime=1, which=2)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_018.jpg" alt="Step 6 - testing the Markov switching model"/></div><p>
</p><p>The <code class="literal">plotDiag()</code> function plots the residuals against the fitted values. <code class="literal">MarkoSwtchLogGrowthStocks</code> is passed as an object of the <code class="literal">MSM.lm</code> type. <code class="literal">which = 3</code> represents the subset of the plots that is required. <code class="literal">which=3</code> represents the ACF/PACF of residuals and the ACF/PACF of square residuals:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plotDiag(MarkoSwtchLogGrowthStocks, regime=1, which=3)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_019.jpg" alt="Step 6 - testing the Markov switching model"/></div><p>
</p><p>The <code class="literal">plotDiag()</code> function plots the residuals against the fitted values. <code class="literal">MarkoSwtchLogGrowthStocks</code> is passed as an object of the <code class="literal">MSM.lm</code> type. <code class="literal">which = 1</code> represents the subset of the plots that is required. <code class="literal">which = 1</code> represents the plot of residuals against fitted values:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plotDiag(MarkoSwtchLogGrowthStocks, regime=1, which=1)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_020.jpg" alt="Step 6 - testing the Markov switching model"/></div><p>
</p><p>The <code class="literal">plotDiag()</code> function plots the residuals against the fitted values. <code class="literal">MarkoSwtchLogGrowthStocks</code> is passed as an object of the <code class="literal">MSM.lm</code> type. <code class="literal">which = 2</code> represents the subset of the plots that is required. <code class="literal">which=2</code> represents the Normal Q-Q plot:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plotDiag(MarkoSwtchLogGrowthStocks, regime=1, which=2)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_021.jpg" alt="Step 6 - testing the Markov switching model"/></div><p>
</p><p>The <code class="literal">plotDiag()</code> function plots the residuals against the fitted values. <code class="literal">MarkoSwtchLogGrowthStocks</code> is passed as an object of the <code class="literal">MSM.lm</code> type. <code class="literal">which = 3</code> represents the subset of the plots that is required. <code class="literal">which=3</code> represents the ACF/PACF of residuals and the ACF/PACF of square residuals:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plotDiag(MarkoSwtchLogGrowthStocks, regime=1, which=3)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_022.jpg" alt="Step 6 - testing the Markov switching model"/></div><p>
</p></div></div></div>
<div class="section" title="Markov chains - the multi-channel attribution model"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec42"/>Markov chains - the multi-channel attribution model</h1></div></div></div><p>A customer's journey undergoes a path of different channels before a purchase on an e-commerce website. Multi-channel attribution assigns a value to each step in the journey. The question is how one can identify the value in the actions people take on your website that lead to a conversion. Commonly, businesses use "last click" attribution, which means assigning all the conversion value to the last step in the journey or "first click" attribution. The first step in developing multi-channel attribution analytics is to understand the customer's journey - from awareness through purchase to after-purchase support. The ultimate goal is to develop loyal customers who spend a significant money on purchases, recommend the brand to others, and it potentially becomes a brand.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec51"/>Getting ready</h2></div></div></div><p>In order to perform a Markov chains multi-channel attribution model we shall be simulating customer journeys containing three unique channels.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec52"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 1 - preparing the dataset"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec131"/>Step 1 - preparing the dataset</h3></div></div></div><p>First load the following packages:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; install.packages("dplyr")</strong></span>
<span class="strong"><strong>    &gt; install.packages("reshape2")</strong></span>
<span class="strong"><strong>    &gt; install.packages("ggplot2")</strong></span>
<span class="strong"><strong>    &gt; install.packages("ChannelAttribution")</strong></span>
<span class="strong"><strong>    &gt; install.packages("markovchain")</strong></span>
<span class="strong"><strong>    &gt; library(dplyr)</strong></span>
<span class="strong"><strong>    &gt; library(reshape2)</strong></span>
<span class="strong"><strong>    &gt; library(ggplot2)</strong></span>
<span class="strong"><strong>    &gt; library(ChannelAttribution)</strong></span>
<span class="strong"><strong>    &gt; library(markovchain)</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Version info: Code for this page was tested in R version 3.2.2 (2015-08-14).</p></div></div><p>Creating the data sample: The <code class="literal">c()</code> function combines arguments to form a vector. All the arguments passed to the function are combined to form a common type that is the type of the returned value. The <code class="literal">data.frame()</code> function creates a tightly coupled data frame that is the collection of variables that share many of the properties of matrices and of lists. We will be saving the data to the <code class="literal">datafrm1</code> data frame as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrm1 &lt;- data.frame(path = c('c1 &gt; c2 &gt; c3', 'c1', 'c2 &gt; c3'), conv = c(1, 0, 0), conv_null = c(0, 1, 1))</strong></span>
</pre><p>Print the <code class="literal">datafrm1</code> data frame as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrm1</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_023.jpg" alt="Step 1 - preparing the dataset"/></div><p>
</p></div><div class="section" title="Step 2 - preparing the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec132"/>Step 2 - preparing the model</h3></div></div></div><p>Preparing the Markov model. The <code class="literal">markov_model()</code> function estimates the k-order Markov model from customer journey data. <code class="literal">datafrm1</code> is the data frame that contains the customer journeys as defined. The <code class="literal">var_path</code> variable has the names of the columns that contain the journey path. The <code class="literal">var_conv</code> variable represents the name of the columns containing total conversions. The <code class="literal">var_null</code> variable represents the columns containing total paths that do not lead to conversions. <code class="literal">out_more = TRUE</code> returns the transition probabilities between channels and removal effects.</p><p>The result of the estimated k-order Markov model is stored in the <code class="literal">model1</code> data frame as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; model1 &lt;- markov_model(datafrm1, var_path = 'path', var_conv = 'conv', var_null = 'conv_null', out_more = TRUE)</strong></span>
</pre><p>Printing the <code class="literal">model1</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; model1</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_024.jpg" alt="Step 2 - preparing the model"/></div><p>
</p><p>Extract the result attribution from the <code class="literal">model1data</code> frame as follows. The result is then stored in the <code class="literal">datafrmresult1</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafr{BS}l1$result</strong></span>
</pre><p>Extracting the <code class="literal">transition_matrix</code> attribution from the <code class="literal">model1data</code> frame as follows. The result is then stored in the <code class="literal">datafrmtransmatrix1</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmtransmatrix1 &lt;- model1$transition_matrix</strong></span>
</pre><p>Reshaping the data frame. The result of the reshaped data frame is stored in <code class="literal">datafrmtransmatrix</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmtransmatrix &lt;- dcast(datafrmtransmatrix1, channel_from ~ channel_to, value.var = 'transition_probability')</strong></span>
</pre><p>Printing the <code class="literal">datafrmtransmatrix</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmtransmatrix</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_025.jpg" alt="Step 2 - preparing the model"/></div><p>
</p></div><div class="section" title="Step 3 - plotting the Markov graph"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec133"/>Step 3 - plotting the Markov graph</h3></div></div></div><p>Extracting the <code class="literal">transition_matrix</code> attribution from the <code class="literal">model1</code> data frame. The result is then stored in the <code class="literal">datafrmtransmatrix</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmtransmatrix &lt;- model1$transition_matrix</strong></span>
</pre><p>Print the <code class="literal">datafrmtransmatrix</code> data frame as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmtransmatrix</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_026.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>
</p><p>Creating the <code class="literal">datafrmdummy</code> data sample. The <code class="literal">c()</code> function combines arguments to form a vector. All the arguments passed to the function are combined to form a common type that is the type of the returned value. The <code class="literal">data.frame()</code> function creates a tightly coupled data frame that is the collection of variables that share many of the properties of matrices and of lists. We will be saving the data to the <code class="literal">datafrmdummy</code> data frame as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmdummy &lt;- data.frame(channel_from = c('(start)', '(conversion)', '(null)'), channel_to = c('(start)', '(conversion)', '(null)'), transition_probability = c(0, 1, 1))</strong></span>
</pre><p>Printing the <code class="literal">datafrmtransmatrix</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmtransmatrix</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_027.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>
</p><p>Combining the columns as follows<span class="emphasis"><em>. </em></span>
<code class="literal">rbind()</code> takes a sequence of data frames and combines them. <code class="literal">datafrmtransmatrix</code> and <code class="literal">df_dummy</code> are passed as input parameters. The result is then the <code class="literal">datafrmtransmatrix</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmtransmatrix &lt;- rbind(datafrmtransmatrix, datafrmdummy)</strong></span>
</pre><p>Printing the <code class="literal">datafrmtransmatrix</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmtransmatrix</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_028.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>
</p><p>Order the channels as follows. <code class="literal">factor()</code> as a function is used to encode a vector as a factor. <code class="literal">datafrmtransmatrix$channel_from</code> is passed as a vector of data. <code class="literal">levels = c('(start)', '(conversion)', '(null)', 'c1', 'c2', 'c3')</code> represents an optional vector of the values:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmtransmatrix$channel_from &lt;- factor(datafrmtransmatrix$channel_from, levels = c('(start)', '(conversion)', '(null)', 'c1', 'c2', 'c3'))</strong></span>
</pre><p>Printing the <code class="literal">datafrmtransmatrix$channel_from</code> data frame as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmtransmatrix$channel_from</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_029.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>
</p><p>Ordering the channels as follows. <code class="literal">datafrmtransmatrix$channel_to</code> is passed as a vector of data:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmtransmatrix$channel_to &lt;- factor(datafrmtransmatrix$channel_to, levels = c('(start)', '(conversion)', '(null)', 'c1', 'c2', 'c3'))</strong></span>
</pre><p>Print <code class="literal">datafrmtransmatrix$channel_to</code> the data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmtransmatrix$channel_to</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_030.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>
</p><p>Reshaping the data frame. The result of the reshaped data frame is stored in <code class="literal">datafrmtransmatrix</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmtransmatrix &lt;- dcast(datafrmtransmatrix, channel_from ~ channel_to, value.var = 'transition_probability')</strong></span>
</pre><p>Printing the <code class="literal">datafrmtransmatrix</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmtransmatrix</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_031.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>
</p><p>Creating the Markov chain object. <code class="literal">matrix()</code> as a function creates a matrix from a given set of values:</p><pre class="programlisting">
<span class="strong"><strong>&gt; transitionmatrix &lt;- matrix(data = as.matrix(datafrmtransmatrix[, -1]), nrow = nrow(datafrmtransmatrix[, -1]), ncol = ncol(datafrmtransmatrix[, -1]), dimnames = list</strong></span>
<span class="strong"><strong>(c(as.character(datafrmtransmatrix[, 1])), c(colnames(datafrmtransmatrix[, -1]))))</strong></span>
</pre><p>Printing the <code class="literal">transitionmatrix</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; transitionmatrix</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_032.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>&gt; transitionmatrix[is.na(transitionmatrix)] &lt;- 0</strong></span>
</pre><p>Creating a Markov chain object. The <code class="literal">transitionMatrix</code> will be a transition matrix, that is, all entries will be probabilities and either all rows or all columns will sum up to one:</p><pre class="programlisting">
<span class="strong"><strong>&gt; transitionmatrix1 &lt;- new("markovchain", transitionMatrix = transitionmatrix)</strong></span>
</pre><p>Printing the <code class="literal">transitionmatrix1</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; transitionmatrix1</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_033.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>
</p><p>Plotting the graph:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot(transitionmatrix1, edge.arrow.size = 0.5, main = "Markov Graph Transition Matrix - transitionmatrix1")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_034.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>
</p></div><div class="section" title="Step 4 - simulating the dataset of customer journeys"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec134"/>Step 4 - simulating the dataset of customer journeys</h3></div></div></div><p>The <code class="literal">data.frame()</code> function creates a tightly coupled data frame that is the collection of variables that share many of the properties of matrices and of lists. We will be saving the data to the <code class="literal">datafrm2</code> data frame as follows:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; set.seed(354)</strong></span>
<span class="strong"><strong>    &gt; datafrm2 &lt;- data.frame(client_id = sample(c(1:1000), 5000, replace = TRUE), date = sample(c(1:32), 5000, replace = TRUE), channel = sample(c(0:9), 5000, replace = TRUE, prob = c(0.1, 0.15, 0.05, 0.07, 0.11, 0.07, 0.13, 0.1, 0.06, 0.16)))</strong></span>
</pre><p>Printing the <code class="literal">datafrm2</code> frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">datafrm2</code> frame. The <code class="literal">datafrm2</code> frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(datafrm2)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_035.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>
</p><p>Converting the character objects to date objects. <code class="literal">datafrm2$date</code> represents the object to be converted. <code class="literal">origin = "2016-01-01"</code> represents the <code class="literal">Date</code> object:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrm2$date &lt;- as.Date(datafrm2$date, origin = "2016-01-01")</strong></span>
</pre><p>Concatenating the vectors after converting to characters. Add the <code class="literal">channel_</code> object to the channel. <code class="literal">datafrm2$channel</code> represents the data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrm2$channel &lt;- paste0('channel_', datafrm2$channel)</strong></span>
</pre><p>Printing the <code class="literal">datafrm2</code> frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">datafrm2</code> frame. The <code class="literal">datafrm2</code> frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(datafrm2)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_036.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>
</p><p>Aggregating the channels to the paths for each customer:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrm2 &lt;- datafrm2 %&gt;% group_by(client_id) %&gt;% summarise(path = paste(channel, collapse = ' &gt; '), conv = 1, conv_null = 0) %&gt;% ungroup()</strong></span>
</pre><p>Printing the <code class="literal">datafrm2</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrm2</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_037.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>
</p><p>Preparing the Markov models. The <code class="literal">markov_model()</code> function estimates the k-order Markov model from customer journey data. <code class="literal">datafrm2</code> is the data frame that contains the customer journeys as defined. <code class="literal">var_path</code> has the names of the columns that contain the journey path. <code class="literal">var_conv</code> represents the name of the columns containing total conversions. <code class="literal">var_null</code> represents the columns containing total paths that do not lead to conversions. <code class="literal">out_more = TRUE</code> returns the transition probabilities between channels and removal effects.</p><p>The result of the estimated k-order Markov model is stored in the <code class="literal">model2</code> data frame as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; model2 &lt;- markov_model(datafrm2, var_path = 'path', var_conv = 'conv', var_null = 'conv_null', out_more = TRUE)</strong></span>
</pre><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmheuristic &lt;- datafrm2 %&gt;% mutate(channel_name_ft = sub('&gt;.*', '', path), channel_name_ft = sub(' ', '', channel_name_ft), channel_name_lt = sub('.*&gt;', '', path), channel_name_lt = sub(' ', '', channel_name_lt))</strong></span>
</pre><p>Printing the <code class="literal">datafrmheuristic</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmheuristic</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_038.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmfirsttouch &lt;- datafrmheuristic %&gt;% group_by(channel_name_ft) %&gt;% summarise(first_touch_conversions = sum(conv)) %&gt;% ungroup()</strong></span>
</pre><p>Printing the <code class="literal">datafrmfirsttouch</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmfirsttouch</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_039.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmlasttouch &lt;- datafrmheuristic %&gt;% group_by(channel_name_lt) %&gt;% summarise(last_touch_conversions = sum(conv)) %&gt;% ungroup()</strong></span>
</pre><p>Printing the <code class="literal">datafrmfirsttouch</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; datafrmfirsttouch</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_040.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>
</p><p>Merging the two data frames by common columns. The result is stored in the <code class="literal">heuristicmodel2</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; heuristicmodel2 &lt;- merge(datafrmfirsttouch, datafrmlasttouch, by.x = 'channel_name_ft', by.y = 'channel_name_lt')</strong></span>
</pre><p>Printing the <code class="literal">heuristicmodel2</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; heuristicmodel2</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_041.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>
</p><p>Merging all the models:</p><pre class="programlisting">
<span class="strong"><strong>&gt; allmodels &lt;- merge(heuristicmodel2, model2$result, by.x = 'channel_name_ft', by.y = 'channel_name')</strong></span>
</pre><p>Printing the <code class="literal">allmodels</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; allmodels</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_042.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>
</p></div><div class="section" title="Step 5 - preparing a transition matrix heat map for real data"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec135"/>Step 5 - preparing a transition matrix heat map for real data</h3></div></div></div><p>Plotting the heatmap.</p><pre class="programlisting">
<span class="strong"><strong>    &gt; colnames(allmodels)[c(1, 4)] &lt;- c('channel_name', 'attrib_model_conversions')</strong></span>
<span class="strong"><strong>    &gt; datafrmplottransition &lt;- model2$transition_matrix</strong></span>
<span class="strong"><strong>    &gt; cols &lt;- c("#e7f0fa", "#c9e2f6", "#95cbee", "#0099dc", "#4ab04a", "#ffd73e", "#eec73a", "#e29421", "#e29421", "#f05336", "#ce472e")</strong></span>
</pre><p>Return the maximum value of all the arguments present in the <code class="literal">datafrmplottransition$transition_probability</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; t &lt;- max(datafrmplottransition$transition_probability)</strong></span>
</pre><p>Printing the value of <code class="literal">t</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; t</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_043.jpg" alt="Step 5 - preparing a transition matrix heat map for real data"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>&gt; ggplot(datafrmplottransition, aes(y = channel_from, x = channel_to, fill = transition_probability)) + theme_minimal() + geom_tile(colour = "white", width = .9, height = .9) + scale_fill_gradientn(colours = cols, limits = c(0, t), breaks = seq(0, t, by = t/4), labels = c("0", round(t/4*1, 2), round(t/4*2, 2), round(t/4*3, 2), round(t/4*4, 2)), guide = guide_colourbar(ticks = T, nbin = 50, barheight = .5, label = T, barwidth = 10)) + geom_text(aes(label = round(transition_probability, 2)), fontface = "bold", size = 4) + theme(legend.position = 'bottom', legend.direction = "horizontal", panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.title = element_text(size = 20, face = "bold", vjust = 2, color = 'black', lineheight = 0.8), axis.title.x = element_text(size = 24, face = "bold"), axis.title.y = element_text(size = 24, face = "bold"), axis.text.y = element_text(size = 8, face = "bold", color = 'black'), axis.text.x = element_text(size = 8, angle = 90, hjust = 0.5, vjust = 0.5, face = "plain")) + ggtitle("Heatmap - Transition Matrix ")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_044.jpg" alt="Step 5 - preparing a transition matrix heat map for real data"/></div><p>
</p></div></div></div>
<div class="section" title="Markov chains - the car rental agency service"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec43"/>Markov chains - the car rental agency service</h1></div></div></div><p>Suppose a car rental agency has three locations in Ottawa: A downtown location (labeled A), A East End location (labeled B), and a West End location (labeled C). The agency has a group of delivery drivers to serve all three locations. The agency's statistician has determined the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Of the calls to the <code class="literal">Downtown</code> location, 30% are delivered in the Downtown area, 30% are delivered in the <code class="literal">East</code> end, and 40% are delivered in the <code class="literal">West</code> end</li><li class="listitem" style="list-style-type: disc">Of the calls to the <code class="literal">East</code> end location, 40% are delivered in the downtown area, 40% are delivered in the <code class="literal">East</code> end, and 20% are delivered in the <code class="literal">West</code> end</li><li class="listitem" style="list-style-type: disc">Of the calls to the <code class="literal">West</code> end location, 50% are delivered in the Downtown area, 30% are delivered in the <code class="literal">East</code> end, and 20% are delivered in the <code class="literal">West</code> end</li></ul></div><p>After making a delivery, a driver goes to the nearest location to make the next delivery. This way, the location of a specific driver is determined only by their previous location.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec53"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 1 - preparing the dataset"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec136"/>Step 1 - preparing the dataset</h3></div></div></div><p>Load the following packages:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; install.packages("markovchain")</strong></span>
<span class="strong"><strong>    &gt; library(markovchain)</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>Version info: Code for this page was tested in R version 3.2.2 (2015-08-14).</p></div></div><p>Creating the data sample. The <code class="literal">c()</code> function combines arguments to form a vector. All the arguments passed to the function are combined to form a common type that is the type of the returned value. We will be saving the data to the <code class="literal">RentalStates</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; RentalStates &lt;- c("Downtown", "East", "West")</strong></span>
</pre><p>Printing the value of <code class="literal">RentalStates</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; RentalStates</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_045.jpg" alt="Step 1 - preparing the dataset"/></div><p>
</p><p>Creating the matrix. The <code class="literal">matrix()</code> function creates a matrix from the given set of values. The <code class="literal">byrow = T</code> matrix is filled by rows. <code class="literal">nrow = 3</code> represents the desired number of rows. The <code class="literal">c()</code> function combines arguments to form a vector. All the arguments passed to the function are combined to form a common type that is the type of the returned value:</p><pre class="programlisting">
<span class="strong"><strong>&gt; RentalTransitionMatrix &lt;- matrix(c(0.3, 0.3, 0.4, </strong></span>
<span class="strong"><strong>                                     0.4, 0.4, 0.2, </strong></span>
<span class="strong"><strong>                                     0.5, 0.3, 0.2),</strong></span>
<span class="strong"><strong>  byrow = T, nrow = 3, dimnames = list(RentalStates, RentalStates))</strong></span>
</pre><p>Printing the value of <code class="literal">RentalTransitionMatrix</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; RentalTransitionMatrix</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_046.jpg" alt="Step 1 - preparing the dataset"/></div><p>
</p></div><div class="section" title="Step 2 - preparing the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec137"/>Step 2 - preparing the model</h3></div></div></div><p>Creating a Markov chain object. The <code class="literal">new()</code> function creates object of the type <code class="literal">markovchain</code>. States represents the <code class="literal">RentalStates</code> as defined previously. <code class="literal">byrow = T matrix</code> is filled by rows. The result is then stored in the data frame <code class="literal">mcRental</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; mcRental &lt;- new("markovchain", states = RentalStates, byrow = T, transitionMatrix = RentalTransitionMatrix, name = "Rental Cars")</strong></span>
</pre><p>Printing the <code class="literal">mcRental</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; mcRental</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_047.jpg" alt="Step 2 - preparing the model"/></div><p>
</p><p>Accessing the transition matrix by calling the <code class="literal">mcRental</code> object as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; mcRental[2]</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_048.jpg" alt="Step 2 - preparing the model"/></div><p>
</p><p>Ploting the <code class="literal">mcRental</code> object. <code class="literal">plot()</code> is a generic function to plot R objects:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot(mcRental)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_049.jpg" alt="Step 2 - preparing the model"/></div><p>
</p><p>Calculating the transition probability. <code class="literal">transitionProbability</code>
<code class="literal">()</code> provides direct access to transition probabilities.</p><pre class="programlisting">
<span class="strong"><strong>&gt; transitionProbability(mcRental, "East", "West")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_050.jpg" alt="Step 2 - preparing the model"/></div><p>
</p></div><div class="section" title="Step 3 - improving the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec138"/>Step 3 - improving the model</h3></div></div></div><p>Calculating the probability of being in Downtown in two trips; Downtown to Downtown:</p><pre class="programlisting">
<span class="strong"><strong>&gt; x &lt;- 0.3 * 0.3</strong></span>
</pre><p>Calculating the probability of going Downtown from the East location; East to Downtown:</p><pre class="programlisting">
<span class="strong"><strong>&gt; y &lt;- 0.3 * 0.4</strong></span>
</pre><p>Calculating the probability of going Downtown from the West location; West to Downtown:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; z &lt;- 0.4 * 0.5</strong></span>
<span class="strong"><strong>    &gt; x + y + z</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_051.jpg" alt="Step 3 - improving the model"/></div><p>
</p><p>Squaring the <code class="literal">mcRental</code> matrix to calculate the probability, we will be downtown in two trips:</p><pre class="programlisting">
<span class="strong"><strong>&gt; mcRental ^ 2</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_052.jpg" alt="Step 3 - improving the model"/></div><p>
</p><p>Checking the probability that we will be downtown in 20 trips using the <code class="literal">mcRental</code> matrix probability calculation as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; mcRental ^ 20</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_053.jpg" alt="Step 3 - improving the model"/></div><p>
</p><p>Checking the probability that we will be downtown in three trips using the <code class="literal">mcRental</code> matrix probability calculation as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; mcRental ^ 30</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_054.jpg" alt="Step 3 - improving the model"/></div><p>
</p><p>This method returns the stationary vector in matrix form of a markovchain object:</p><pre class="programlisting">
<span class="strong"><strong>&gt; 70 * steadyStates(mcRental)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_055.jpg" alt="Step 3 - improving the model"/></div><p>
</p><p>Printing the summary of <code class="literal">mcRental</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(mcRental)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_056.jpg" alt="Step 3 - improving the model"/></div><p>
</p><p>Extracting the conditional distribution of the subsequent state, given the current state. <code class="literal">mcRental</code> is the markov chain object that is passed while <code class="literal">"Downtown"</code> is the next state:</p><pre class="programlisting">
<span class="strong"><strong>&gt; conditionalDistribution(mcRental, "Downtown")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_057.jpg" alt="Step 3 - improving the model"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>&gt; conditionalDistribution(mcRental, "West")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_058.jpg" alt="Step 3 - improving the model"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>&gt; conditionalDistribution(mcRental, "East")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_059.jpg" alt="Step 3 - improving the model"/></div><p>
</p></div></div></div>
<div class="section" title="Continuous Markov chains - vehicle service at a gas station"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Continuous Markov chains - vehicle service at a gas station</h1></div></div></div><p>A gas station has a single pump. There is no space for vehicles to wait. If a vehicle arrives at the pump and there is no place the vehicle leaves without filling at the pump. Vehicles arrive at the gas station following a Poisson process with a rate of 3/20 vehicles per minute. Of the vehicles arriving at the pump, 75% are cars and 25% are motorcycles. The refueling time can be modeled with an exponential random variable with a mean of eight minutes for cars and three minutes for motorcycles.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec54"/>Getting ready</h2></div></div></div><p>In order to perform continuous Markov chains for vehicle service at a gas station we shall be simulating data.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec55"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 1 - preparing the dataset"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec139"/>Step 1 - preparing the dataset</h3></div></div></div><p>Load the following packages:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; install.packages("simmer")</strong></span>
<span class="strong"><strong>    &gt; install.packages("ggplot2")</strong></span>
<span class="strong"><strong>    &gt; library(simmer)</strong></span>
<span class="strong"><strong>    &gt; library(ggplot2)</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>Version info: Code for this page was tested in R version 3.2.2 (2015-08-14)</p></div></div><p>Initializing the vehicle arrival rate:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ArrivalRate &lt;- 3/20</strong></span>
</pre><p>Printing the <code class="literal">ArrivalRate</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ArrivalRate</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_060.jpg" alt="Step 1 - preparing the dataset"/></div><p>
</p><p>Initializing the service rate of the vehicles and create the data sample. The <code class="literal">c()</code> function combines arguments to form a vector. All the arguments passed to the function are combined to form a common type that is the type of the returned value. We will be saving the data to the <code class="literal">ServiceRate</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ServiceRate &lt;- c(1/8, 1/3)</strong></span>
</pre><p>Printing the <code class="literal">ServiceRate</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ServiceRate</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_061.jpg" alt="Step 1 - preparing the dataset"/></div><p>
</p><p>Initializing the probability of the arrival of the car:</p><pre class="programlisting">
<span class="strong"><strong>&gt; p &lt;- 0.75</strong></span>
</pre><p>Creating a transition matrix. <code class="literal">matrix()</code> as a function creates a matrix from a given set of values. The result is stored in the <code class="literal">TransitionMatrix</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; TransitionMatrix &lt;- matrix(c(1,   ServiceRate[1],     0,</strong></span>
<span class="strong"><strong>    1,   -ArrivalRate,       (1-p)*ArrivalRate,</strong></span>
<span class="strong"><strong>    1,   ServiceRate[2],     -ServiceRate[2]), byrow=T, ncol=3)</strong></span>
</pre><p>Printing the <code class="literal">TransitionMatrix</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; TransitionMatrix</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_062.jpg" alt="Step 1 - preparing the dataset"/></div><p>
</p><p>Initializing the vector:</p><pre class="programlisting">
<span class="strong"><strong>&gt; B &lt;- c(1, 0, 0)</strong></span>
</pre></div><div class="section" title="Step 2 - computing the theoretical resolution"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec140"/>Step 2 - computing the theoretical resolution</h3></div></div></div><p>Solving the linear system of equations. <code class="literal">solve()</code> is used to compute the linear equation. <code class="literal">t(A)</code> represents the transition matrix while <code class="literal">B</code> is the vector. The result is then stored in <code class="literal">P</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; P &lt;- solve(t(A), B)</strong></span>
</pre><p>Printing the <code class="literal">P</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; P</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_063.jpg" alt="Step 2 - computing the theoretical resolution"/></div><p>
</p><p>Computing the theoretical resolution. <code class="literal">sum()</code> computes the sum. The result is then stored in <code class="literal">Resolution</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; Resolution &lt;- sum(P * c(1, 0, 1)) </strong></span>
</pre><p>Printing the <code class="literal">Resolution</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; Resolution</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_064.jpg" alt="Step 2 - computing the theoretical resolution"/></div><p>
</p></div><div class="section" title="Step 3 - verifying the convergence of a theoretical solution"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec141"/>Step 3 - verifying the convergence of a theoretical solution</h3></div></div></div><p>Simulating the system and verify that it converges to a theoretical solution:</p><pre class="programlisting">
<span class="strong"><strong>&gt; set.seed(1234)</strong></span>
</pre><p>Defining the <code class="literal">option.1</code> function. A <code class="literal">create_trajectory()</code> function creates the trajectory object of car and motorcycle types. These objects comprise a chain of activities that is to be attached to a generator object. Activities for seizing the pump object by name are carried out. <code class="literal">amount=1</code> means the number of objects that require to be seized. The <code class="literal">timeout()</code> function inserts the delays based on the user definition. The <code class="literal">timeout()</code> function also takes in the <code class="literal">rexp()</code> function that randomly generates the exponential distribution with a rate defined as <code class="literal">ServiceRate[1] = 1/8</code> for the <code class="literal">car</code> object and <code class="literal">ServiceRate[1] = 1/3</code> for the <code class="literal">motorcycle</code> object.</p><p>Then a simulator object is created as follows. The method initializes a simulation environment. The <code class="literal">car</code> and <code class="literal">motorcycle</code> objects are created with the exponential distribution with the rate defined as <code class="literal">p*ArrivalRate</code> where <code class="literal">ArrivalRate = 0.15</code>. Then a new generator of arrivals in a simulation environment is created:</p><pre class="programlisting">
<span class="strong"><strong>&gt; option.1 &lt;- function(t) {</strong></span>
<span class="strong"><strong>      car &lt;- create_trajectory() %&gt;%</strong></span>
<span class="strong"><strong>          seize("pump", amount=1) %&gt;%</strong></span>
<span class="strong"><strong>          timeout(function() rexp(1, ServiceRate[1])) %&gt;%</strong></span>
<span class="strong"><strong>          release("pump", amount=1)</strong></span>
</pre><pre class="programlisting">
<span class="strong"><strong>      motorcycle &lt;- create_trajectory() %&gt;%</strong></span>
<span class="strong"><strong>          seize("pump", amount=1) %&gt;%</strong></span>
<span class="strong"><strong>          timeout(function() rexp(1, ServiceRate[2])) %&gt;%</strong></span>
<span class="strong"><strong>          release("pump", amount=1)</strong></span>
</pre><pre class="programlisting">
<span class="strong"><strong>      simmer() %&gt;%</strong></span>
<span class="strong"><strong>          add_resource("pump", capacity=1, queue_size=0) %&gt;%</strong></span>
<span class="strong"><strong>          add_generator("car", car, function() rexp(1, p*ArrivalRate)) %&gt;%</strong></span>
<span class="strong"><strong>          add_generator("motorcycle", motorcycle, function() rexp(1, (1-p)*ArrivalRate)) %&gt;%</strong></span>
<span class="strong"><strong>          run(until=t)</strong></span>
<span class="strong"><strong>  }</strong></span>
</pre><p>Defining the <code class="literal">option.2</code> function. Define a single generator for all kinds of vehicles and a single trajectory. In order to distinguish between cars and motorcycles, define a branch after seizing the resource to select the proper service time.</p><p>A <code class="literal">create_trajectory()</code> function creates the trajectory object of the <code class="literal">vehicle</code> type. This object comprises a chain of activities that is to be attached to a generator object. Activities for seizing the pump object by name are carried out. <code class="literal">amount=1</code> means the number of objects that are required to be seized. The <code class="literal">create_trajectory()</code> function then calls the <code class="literal">timeout()</code> function that inserts the delays based on the user definition. The <code class="literal">timeout()</code> function, also takes in the <code class="literal">rexp()</code> function which randomly generates the exponential distribution with the rate defined as <code class="literal">ServiceRate[1] = 1/8</code> for a car object and <code class="literal">ServiceRate[1] = 1/3</code> for a <code class="literal">motorcycle</code> object.</p><p>Then a simulator object is created as follows. The method initializes a simulation environment. The <code class="literal">car</code> and <code class="literal">motorcycle</code> objects are created with the exponential distribution with the rate defined as <code class="literal">p*ArrivalRate. ArrivalRate = 0.15</code>. The <code class="literal">run()</code> function then continues to run until the user-defined time out, as mentioned in <code class="literal">until=t</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; option.2 &lt;- function(t) {</strong></span>
<span class="strong"><strong>      vehicle &lt;- create_trajectory() %&gt;%</strong></span>
<span class="strong"><strong>          seize("pump", amount=1) %&gt;%</strong></span>
<span class="strong"><strong>          branch(function() sample(c(1, 2), 1, prob=c(p, 1-p)), merge=c(T, T),</strong></span>
<span class="strong"><strong>                 create_trajectory("car") %&gt;%</strong></span>
<span class="strong"><strong>                     timeout(function() rexp(1, ServiceRate[1])),</strong></span>
<span class="strong"><strong>                 create_trajectory("motorcycle") %&gt;%</strong></span>
<span class="strong"><strong>                     timeout(function() rexp(1, ServiceRate[2]))) %&gt;%</strong></span>
<span class="strong"><strong>          release("pump", amount=1)</strong></span>
<span class="strong"><strong>      simmer() %&gt;%</strong></span>
<span class="strong"><strong>          add_resource("pump", capacity=1, queue_size=0) %&gt;%</strong></span>
<span class="strong"><strong>          add_generator("vehicle", vehicle, function() rexp(1, ArrivalRate)) %&gt;%</strong></span>
<span class="strong"><strong>          run(until=t)</strong></span>
<span class="strong"><strong>  }</strong></span>
</pre><p>Defining the <code class="literal">option.3</code> function. <code class="literal">option.2</code> adds an unnecessary overhead. An additional call is made to select the branch, and therefore performance decreases. Select the service time directly inside the <code class="literal">timeout()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; option.3 &lt;- function(t) {</strong></span>
<span class="strong"><strong>       vehicle &lt;- create_trajectory() %&gt;%</strong></span>
<span class="strong"><strong>       seize("pump", amount=1) %&gt;%</strong></span>
<span class="strong"><strong>       timeout(function() {</strong></span>
<span class="strong"><strong>          if (runif(1) &lt; p) rexp(1, ServiceRate[1]) </strong></span>
<span class="strong"><strong>          else rexp(1, ServiceRate[2]) </strong></span>
<span class="strong"><strong>       }) %&gt;%</strong></span>
<span class="strong"><strong>    release("pump", amount=1)</strong></span>
<span class="strong"><strong>    simmer() %&gt;%</strong></span>
<span class="strong"><strong>    add_resource("pump", capacity=1, queue_size=0) %&gt;%</strong></span>
<span class="strong"><strong>    add_generator("vehicle", vehicle, function() rexp(1, ArrivalRate)) %&gt;%</strong></span>
<span class="strong"><strong>    run(until=t)</strong></span>
<span class="strong"><strong>    }</strong></span>
</pre><p>Call the options created as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; gas.station &lt;- option.3(5000)</strong></span>
</pre></div><div class="section" title="Step 4 - plotting the results"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec142"/>Step 4 - plotting the results</h3></div></div></div><p>Plotting the results. <code class="literal">plot_resource_usage()</code> is used to plot the usage of a resource over the simulation time frame. <code class="literal">gas.station</code> represents a single simmer environment. <code class="literal">"pump"</code> represents the name of the resource. <code class="literal">items="system"</code> refers to the components of the resource to be plotted. The result is then stored in an object of <code class="literal">ggplot2</code> type graph:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; graph &lt;- plot_resource_usage(gas.station, "pump", items="system")</strong></span>
<span class="strong"><strong>    &gt; graph + geom_hline(yintercept = Resolution)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_065.jpg" alt="Step 4 - plotting the results"/></div><p>
</p></div></div></div>
<div class="section" title="Monte Carlo simulations - calibrated Hull and White short-rates"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Monte Carlo simulations - calibrated Hull and White short-rates</h1></div></div></div><p>Monte Carlo simulation is a stochastic simulation of system behavior. The simulation uses sampling experiments to be performed on the model and it then conducts numerical experiments using the computer to obtain a statistical understanding of the system behavior.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec56"/>Getting ready</h2></div></div></div><p>In order to perform Monte Carlo simulations for calibrated hull and white short-rates, data is taken from sample code that has been shipped with <code class="literal">QuantLib</code> 0.3.10, market data used to construct the term structure of interest rates and swaption volatility matrix with corresponding maturities and tenors.</p><div class="section" title="Step 1 - installing the packages and libraries"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec143"/>Step 1 - installing the packages and libraries</h3></div></div></div><p>Load the following packages:</p><pre class="programlisting">
<span class="strong"><strong>    &gt;install.packages("RQuantLib", type="binary")</strong></span>
<span class="strong"><strong>    &gt;install.packages("ESGtoolkit")</strong></span>
<span class="strong"><strong>    &gt;library(RQuantLib)</strong></span>
<span class="strong"><strong>    &gt;library(ESGtoolkit)</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Version info: Code for this page was tested in R version 3.2.2 (2015-08-14)</p></div></div><p>In order to make part of the <code class="literal">Quantlib</code> package accessible to the R environment <code class="literal">RQuantLib</code> is used. The <code class="literal">Quantlib</code> package provides a comprehensive software framework for quantitative finance. The goal of the <code class="literal">RQuantLib</code> is to provide source libraries for modeling, trading, sources, either local or remote sources. GSPC is assets.</p><p>
<code class="literal">type="binary"</code> indicates the type of package to be downloaded and installed. This means that the nature of the package to be installed is not a source package.</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec57"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - initializing the data and variables"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec144"/>Step 2 - initializing the data and variables</h3></div></div></div><p>Initializing the variables:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; freq &lt;- "monthly"</strong></span>
<span class="strong"><strong>    &gt; delta_t &lt;- 1/12</strong></span>
</pre><p>Printing the value of <code class="literal">delta_t</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; delta_t</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_066.jpg" alt="Step 2 - initializing the data and variables"/></div><p>
</p><p>Initializing the variables from the sample code integrated with <code class="literal">QuantLib</code> 0.3.10. A list specifying the <code class="literal">tradeDate</code> (month/day/year), <code class="literal">settleDate</code>, forward rate time span <code class="literal">dt</code>, and two curve construction options: <code class="literal">interpWhat</code> (with possible values discount, forward, and zero) and <code class="literal">interpHow</code> (with possible values linear, loglinear, and spline). spline here means cubic spline interpolation of the <code class="literal">interpWhat</code> value.</p><p>The result is then stored in the <code class="literal">params</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; params &lt;- list(tradeDate=as.Date('2002-2-15'),</strong></span>
<span class="strong"><strong>                 settleDate=as.Date('2002-2-19'),</strong></span>
<span class="strong"><strong>                 payFixed=TRUE,</strong></span>
<span class="strong"><strong>                 dt=delta_t,</strong></span>
<span class="strong"><strong>                 strike=.06,</strong></span>
<span class="strong"><strong>                 method="HWAnalytic",</strong></span>
<span class="strong"><strong>                 interpWhat="zero",</strong></span>
<span class="strong"><strong>                 interpHow= "spline")</strong></span>
</pre><p>Initializing the market data. The term structure is constructed for interest rates, deposits, and swaps. The result is then stored in <code class="literal">TermQuotes</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; TermQuotes  &lt;- list(d1w =0.0382, # 1-week deposit rate</strong></span>
<span class="strong"><strong>                      d1m =0.0372,# 1-month deposit rate</strong></span>
<span class="strong"><strong>                      d3m = 0.0363,# 3-month deposit rate</strong></span>
<span class="strong"><strong>                      d6m = 0.0353,# 6-month deposit rate</strong></span>
<span class="strong"><strong>                      d9m = 0.0348,# 9-month deposit rate</strong></span>
<span class="strong"><strong>                      d1y = 0.0345,# 1-year deposit rate</strong></span>
<span class="strong"><strong>                      s2y = 0.037125,# 2-year swap rate</strong></span>
<span class="strong"><strong>                      s3y =0.0398,# 3-year swap rate</strong></span>
<span class="strong"><strong>                      s5y =0.0443,# 5-year swap rate</strong></span>
<span class="strong"><strong>                      s10y =0.05165,# 10-year swap rate</strong></span>
<span class="strong"><strong>                      s15y =0.055175)# 15-year swap rate</strong></span>
</pre><p>Initializing the <code class="literal">Swaptionmaturities</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; SwaptionMaturities &lt;- c(1,2,3,4,5)</strong></span>
</pre><p>Printing the value of <code class="literal">SwaptionMaturities</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; SwaptionMaturities</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_067.jpg" alt="Step 2 - initializing the data and variables"/></div><p>
</p><p>Initializing the swap tenors:</p><pre class="programlisting">
<span class="strong"><strong>&gt; SwapTenors &lt;- c(1,2,3,4,5)</strong></span>
</pre><p>Printing the value of <code class="literal">SwapTenors</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; SwapTenors</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_068.jpg" alt="Step 2 - initializing the data and variables"/></div><p>
</p><p>Initializing the volatility matrix. The <code class="literal">matrix()</code> function creates a matrix from the given set of values. <code class="literal">ncol=5</code> denotes the number of desired of columns. <code class="literal">byrow=TRUE</code> means the matrix is filled by rows. The result is then stored in <code class="literal">VolatilityMatrix</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; VolatilityMatrix &lt;- matrix(</strong></span>
<span class="strong"><strong>      c(0.1490, 0.1340, 0.1228, 0.1189, 0.1148,</strong></span>
<span class="strong"><strong>        0.1290, 0.1201, 0.1146, 0.1108, 0.1040,</strong></span>
<span class="strong"><strong>        0.1149, 0.1112, 0.1070, 0.1010, 0.0957,</strong></span>
<span class="strong"><strong>        0.1047, 0.1021, 0.0980, 0.0951, 0.1270,</strong></span>
<span class="strong"><strong>        0.1000, 0.0950, 0.0900, 0.1230, 0.1160),</strong></span>
<span class="strong"><strong>      ncol=5, byrow=TRUE)</strong></span>
</pre></div><div class="section" title="Step 3 - pricing the Bermudan swaptions"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec145"/>Step 3 - pricing the Bermudan swaptions</h3></div></div></div><p>Price the Bermudan swaption as follows. <code class="literal">BermudanSwaption</code> is part of the <code class="literal">Quantlib</code> package. This is accessible to the R environment using <code class="literal">RQuantLib</code>. <code class="literal">BermudanSwaption</code> prices a Bermudan swaption with specified strike and maturity (in years), after calibrating the selected short-rate model to an input swaption volatility matrix. Swaption maturities and swap tenors are in years. It is assumed that the Bermudan swaption is exercisable on each reset date of the underlying swaps. Passing <code class="literal">params</code>, <code class="literal">TermQuotes</code>, <code class="literal">SwaptionMaturities</code>, <code class="literal">SwapTenors</code>, and <code class="literal">VolatilityMatrix</code> as inputs is used to compute Bermudan swaption. The result is stored in <code class="literal">BermudanSwaption</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; BermudanSwaption &lt;- RQuantLib::BermudanSwaption(params, TermQuotes, SwaptionMaturities, SwapTenors, VolatilityMatrix)</strong></span>
</pre><p>The <code class="literal">BermudanSwaption</code> valuation is displayed. The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_069.jpg" alt="Step 3 - pricing the Bermudan swaptions"/></div><p>
</p><p>Printing the summary of <code class="literal">BermudanSwaption</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(BermudanSwaption)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_070.jpg" alt="Step 3 - pricing the Bermudan swaptions"/></div><p>
</p><p>Printing the valuations of <code class="literal">BermudanSwaption</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; BermudanSwaption</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_071.jpg" alt="Step 3 - pricing the Bermudan swaptions"/></div><p>
</p></div><div class="section" title="Step 4 - constructing the spot term structure of interest rates"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec146"/>Step 4 - constructing the spot term structure of interest rates</h3></div></div></div><p>Initializing the vector of times at which to return the discount factors, forward rates, and zero rates. Times are specified such that the largest time plus <code class="literal">delta_t</code> does not exceed the longest maturity of the instruments used for calibration (no extrapolation):</p><pre class="programlisting">
<span class="strong"><strong>&gt; times &lt;- seq(from = delta_t, to = 5, by = delta_t)</strong></span>
</pre><p>
<code class="literal">DiscountCurve</code> constructs the spot term structure of interest rates based on input market data including the settlement date, deposit rates, and swap rates. It returns the corresponding discount factors, zero rates, and forward rates for a vector of times that is specified as input. params represents a list that specifies the <code class="literal">tradeDate</code> (month/day/year), <code class="literal">settleDate</code>, forward rate time span, and two curve construction options: <code class="literal">interpWhat</code> (with possible values discount, forward, and zero) and <code class="literal">interpHow</code> (with possible values <code class="literal">linear</code>, <code class="literal">loglinear</code>, and <code class="literal">spline</code>). spline here means cubic spline interpolation of the <code class="literal">interpWhat</code> value. <code class="literal">TermQuotes</code> represents market quotes to construct the spot term structure of interest rates. Use the following command:</p><pre class="programlisting">
<span class="strong"><strong>&gt; DiscountCurve &lt;- RQuantLib::DiscountCurve(params, TermQuotes, times)</strong></span>
</pre><p>Exploring the internal structure of the <code class="literal">DiscountCurve</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">DiscountCurve</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>&gt; str(DiscountCurve)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_072.jpg" alt="Step 4 - constructing the spot term structure of interest rates"/></div><p>
</p><p>Finding the maturity time at which to return the discount factors, forward rates, and zero rates:</p><pre class="programlisting">
<span class="strong"><strong>&gt; maturities &lt;- DiscountCurve$times</strong></span>
</pre><p>Printing the value of maturities:</p><pre class="programlisting">
<span class="strong"><strong>&gt; maturities</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_073.jpg" alt="Step 4 - constructing the spot term structure of interest rates"/></div><p>
</p><p>Finding zero coupon rates:</p><pre class="programlisting">
<span class="strong"><strong>&gt; MarketZeroRates &lt;- DiscountCurve$zerorates</strong></span>
</pre><p>Printing the value of zero coupon rates:</p><pre class="programlisting">
<span class="strong"><strong>&gt; MarketZeroRates</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_074.jpg" alt="Step 4 - constructing the spot term structure of interest rates"/></div><p>
</p><p>Finding discount factors:</p><pre class="programlisting">
<span class="strong"><strong>&gt; MarketPrices &lt;- DiscountCurve$discounts</strong></span>
</pre><p>Printing the discount factors:</p><pre class="programlisting">
<span class="strong"><strong>&gt; MarketPrices</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_075.jpg" alt="Step 4 - constructing the spot term structure of interest rates"/></div><p>
</p></div><div class="section" title="Step 5 - simulating Hull-White short-rates"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec147"/>Step 5 - simulating Hull-White short-rates</h3></div></div></div><p>Setting the time horizons:</p><pre class="programlisting">
<span class="strong"><strong>&gt; horizon &lt;- 5</strong></span>
</pre><p>Setting the number of simulations:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; NoSimulations &lt;- 10000</strong></span>
<span class="strong"><strong>    &gt; a &lt;- BermudanSwaption$a</strong></span>
</pre><p>Printing the value of <code class="literal">a</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; a</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_076.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>&gt; sigma &lt;- BermudanSwaption$sigma</strong></span>
</pre><p>Printing the value of <code class="literal">sigma</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; sigma</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_077.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><p>Simulating Gaussian shocks. <code class="literal">simshocks()</code> create a simulated version of correlated or dependent Gaussian shocks for risk factors. <code class="literal">n = NoSimulations</code> denotes number of simulations. <code class="literal">horizon = 5</code> means the time horizons. <code class="literal">frequency = monthly</code>. The result is then stored in the <code class="literal">GaussianShocks</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; GaussianShocks &lt;- ESGtoolkit::simshocks(n = NoSimulations, horizon = horizon, frequency = freq)</strong></span>
</pre><p>
<code class="literal">simdiff()</code> makes simulations of diffusion processes. <code class="literal">n = NoSimulations</code> represents the number of independent observations. <code class="literal">frequency = freq</code> is monthly. <code class="literal">model = "OU"</code> stands for the Ornstein-Uhlenbeck method. <code class="literal">x0 = 0</code> is the starting value of the process. <code class="literal">eps = GaussianShocks</code> represents Gaussian shocks:</p><pre class="programlisting">
<span class="strong"><strong>&gt; x &lt;- ESGtoolkit::simdiff(n = NoSimulations, horizon = horizon, frequency = freq, model = "OU", x0 = 0, theta1 = 0, theta2 = a, theta3 = sigma, eps = GaussianShocks)</strong></span>
</pre><p>Calculating the forward rates. <code class="literal">ts()</code> creates time series objects. <code class="literal">replicate(nb.sims, DiscountCurve$forwards)</code> creates a vector of time-series values. <code class="literal">start = start(x)</code> represents the time of the first observation. <code class="literal">deltat = deltat(x)</code> represents the fraction of the sampling period between successive observations. The result is then stored in the <code class="literal">ForwardRates</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ForwardRates &lt;- ts(replicate(nb.sims, DiscountCurve$forwards), start = start(x), deltat = deltat(x))</strong></span>
</pre><p>Generating regular sequences. <code class="literal">from = 0</code>, <code class="literal">to = horizon</code> denotes the starting and end values of sequences. <code class="literal">by = delta_t</code> denotes the increments in sequence:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; t.out &lt;- seq(from = 0, to = horizon, by = delta_t)</strong></span>
<span class="strong"><strong>    &gt; param.alpha &lt;- ts(replicate(NoSimulations, 0.5*(sigma^2)*(1 - exp(-a*t.out))^2/(a^2)), start = start(x), deltat = deltat(x))</strong></span>
<span class="strong"><strong>    &gt; alpha &lt;- ForwardRates + param.alpha</strong></span>
</pre><p>Generating the short-term rates:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ShortRates &lt;- x + alpha</strong></span>
</pre><p>Calculating stochastic discount values. <code class="literal">r = ShortRates</code> denotes the short term rates, <code class="literal">X = 1</code> denotes the asset's price:</p><pre class="programlisting">
<span class="strong"><strong>&gt; StochasticDiscount &lt;- ESGtoolkit::esgdiscountfactor(r = ShortRates, X = 1)</strong></span>
</pre><p>Calculating the mean of stochastic discount values:</p><pre class="programlisting">
<span class="strong"><strong>&gt; MonteCarloPrices &lt;- rowMeans(StochasticDiscount)</strong></span>
</pre><p>Printing the values of <code class="literal">MonteCarloPrices</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; MonteCarloPrices</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_078.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><p>Calculating the zero rates of stochastic discount values:</p><pre class="programlisting">
<span class="strong"><strong>&gt; MonteCarloZeroRates &lt;- -log(MonteCarloPrices)/maturities</strong></span>
</pre><p>Printing the values of <code class="literal">MonteCarloZeroRates</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; MonteCarloZeroRates</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_079.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><p>Performing the student t test on the difference between stochastic discount terms and market prices. <code class="literal">t.test(x)</code> performs the t test. <code class="literal">conf.int</code> means confidence interval for the mean appropriate:
</p><pre class="programlisting">
<span class="strong"><strong>&gt; ConfidenceInterval &lt;- t(apply((StochasticDiscount - MarketPrices)[-1, ], 1, function(x) t.test(x)$conf.int))</strong></span>
</pre><p>The <code class="literal">head()</code> function returns the first part of the <code class="literal">ConfidenceInterval</code> frame. The <code class="literal">ConfidenceInterval</code> frame is passed as an input parameter as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(ConfidenceInterval)</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_080.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><p>Set the graphical parameters as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; par(mfrow = c(2, 2))</strong></span>
</pre><p>
<code class="literal">esgplotbands()</code> plots color bands confidence intervals as follows. <code class="literal">ShortRates</code> represents the confidence interval:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ESGtoolkit::esgplotbands(ShortRates, xlab = "maturities", ylab = "short-rate quantiles", main = "Short Rate Quantiles")</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_081.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><p>Plotting the <span class="strong"><strong>Monte Carlo v/s Market n Zero Rates</strong></span> as follows. maturities, <code class="literal">MonteCarloZeroRates</code> represents the time series:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot(maturities, MonteCarloZeroRates, type='l', col = 'blue', lwd = 1, main = "Monte Carlo v/s Market n Zero Rates")</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_082.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><p>Adding a sequence of points at the specified coordinates of the plot between maturities, <code class="literal">MonteCarloZeroRates</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; points(maturities, MonteCarloZeroRates, col = 'red')</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_083.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><p>Plotting the Monte Carlo v/s Market Prices as follows. maturities, <code class="literal">MonteCarloPrices</code> represents the time series:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot(maturities, MonteCarloPrices, type='l', col = 'blue', lwd = 1, main = "Monte Carlo v/s Market Prices")</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_084.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><p>Adding a sequence of points at the specified coordinates of the plot between maturities, <code class="literal">MonteCarloPrices</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; points(maturities, MonteCarloPrices, col = 'red')</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_085.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>&gt; matplot(maturities[-1], conf.int, type = 'l', main = "Confidence Interval for the price difference")</strong></span>
</pre></div></div></div></body></html>