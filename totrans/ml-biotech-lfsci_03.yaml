- en: 'Chapter 2: Introducing Python and the Command Line'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：介绍 Python 和命令行
- en: 'When walking into a coffee shop, you will almost immediately notice three types
    of people: those socializing with others, those working on projects, and those
    who code. Coders can easily be spotted by the black background and white letters
    on their computer screens – this is known as the **command line**. To many, the
    command line can look fierce and intimidating, but to others, it is a way of life.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你走进一家咖啡馆时，你几乎会立刻注意到三种类型的人：那些与他人社交的人，那些在项目上工作的人，以及那些编码的人。编码者可以通过他们电脑屏幕上的黑色背景和白色字母轻松辨认出来——这被称为**命令行**。对于许多人来说，命令行可能看起来凶猛且令人畏惧，但对于其他人来说，这是一种生活方式。
- en: One of the most essential parts of conducting any type of data science project
    is the ability to effectively navigate directories and execute commands via the
    Terminal command line. The command line allows users to find files, install libraries,
    locate packages, access data, and execute commands in an efficient and concise
    way. This chapter is by no means a comprehensive overview of all the capabilities
    the command line has, but it does cover a general list of essential commands every
    data scientist should know.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 进行任何类型的数据科学项目的一个重要部分是能够有效地通过终端命令行导航目录和执行命令。命令行允许用户以高效和简洁的方式查找文件、安装库、定位包、访问数据以及执行命令。本章绝对不是命令行所有功能的全面概述，但它确实涵盖了一个数据科学家应该知道的必要命令列表。
- en: 'In this chapter, we''ll cover the following specific topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下具体主题：
- en: Introducing the command line
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍命令行
- en: Discovering the **Python** language
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 **Python** 语言
- en: Tutorial – getting started in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指南 – Python 入门
- en: Tutorial – working with Rdkit and BioPython
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指南 – 使用 Rdkit 和 BioPython
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will use the `Applications` folder (**macOS**), or **Command
    Prompt**, which can be found in the Start menu (**Windows** **PC**). Although
    the two are equivalent in functionality, the syntax behind some of the commands
    will differ. If you are using a PC, you are encouraged to download **Git for Windows**
    ([https://git-scm.com/download/win](https://git-scm.com/download/win)), which
    will allow you to follow along using the **Bash** command line. As we begin to
    edit files in the command line, we will need an editor called **Vim**. Most Mac
    users will have Vim preinstalled on their systems. PC users are encouraged to
    download Vim from their website ([https://www.vim.org/download.php](https://www.vim.org/download.php)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用**macOS**的**应用程序**文件夹，或者在**Windows** **PC**的启动菜单中找到的**命令提示符**。尽管这两个在功能上等效，但某些命令背后的语法会有所不同。如果你使用的是PC，我们鼓励你从其网站下载**Git
    for Windows** ([https://git-scm.com/download/win](https://git-scm.com/download/win))，这将允许你使用**Bash**命令行来跟随。当我们开始在命令行中编辑文件时，我们需要一个名为**Vim**的编辑器。大多数Mac用户将预装Vim。我们鼓励PC用户从其网站([https://www.vim.org/download.php](https://www.vim.org/download.php))下载Vim。
- en: In addition, we will be exploring Python using the **Anaconda** distribution.
    We will go over getting this downloaded on your system soon. The process of installing
    Anaconda is nearly identical for both Mac and PC users, and the execution of Python
    code is nearly identical as well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将使用**Anaconda**发行版来探索Python。我们将在不久的将来介绍如何在你的系统上下载它。安装Anaconda的过程对于Mac和PC用户几乎相同，Python代码的执行也几乎相同。
- en: Throughout this book, the code you see will also be available for you on **GitHub**.
    We can think of GitHub as a space where code can live, allowing us to maintain
    versioning, make edits, and share our work with others. As you follow along in
    this chapter, you are encouraged to refer to the associated GitHub repository,
    which can be found at [https://github.com/PacktPublishing/Machine-Learning-in-Biotechnology-and-Life-Sciences](https://github.com/PacktPublishing/Machine-Learning-in-Biotechnology-and-Life-Sciences).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，你看到的代码也将可在**GitHub**上找到。我们可以将GitHub视为代码可以生存的空间，使我们能够维护版本控制、进行编辑，并与他人分享我们的工作。随着你跟随本章的内容，我们鼓励你参考相关的GitHub仓库，该仓库可在[https://github.com/PacktPublishing/Machine-Learning-in-Biotechnology-and-Life-Sciences](https://github.com/PacktPublishing/Machine-Learning-in-Biotechnology-and-Life-Sciences)找到。
- en: Introducing the command line
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍命令行
- en: The command line is available for **Mac**, **PC**, and **Linux**. While the
    following examples were executed on a Mac, very similar functionality is also
    applicable on a PC, but with a slightly different syntax.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行在**Mac**、**PC**和**Linux**上都是可用的。虽然以下示例是在Mac上执行的，但非常类似的功能也适用于PC，但语法略有不同。
- en: You can begin the process by opening the command line (known as `@` symbol.
    Let's look at some basic commands.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打开命令行（称为 `@` 符号）开始此过程。让我们看看一些基本命令。
- en: 'In order to identify the path of your current (working) directory, you can
    use the `pwd` command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别您当前（工作）目录的路径，您可以使用 `pwd` 命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will return the exact directory that you are currently in. In the case
    of my system, the returned path was as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回您当前所在的精确目录。在我的系统中，返回的路径如下：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In order to identify the contents within this particular directory, you can
    use the `ls` command, which will return a list of directories and files:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别此特定目录内的内容，您可以使用 `ls` 命令，它将返回目录和文件的列表：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can make a new directory within the command line by using the `mkdir` command,
    followed by the name of the directory you wish to create. For example, you can
    create the `machine-learning-practice` directory using the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在命令行中使用 `mkdir` 命令（后跟您希望创建的目录名称）在命令行内创建新目录。例如，您可以使用以下命令创建 `machine-learning-practice`
    目录：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you once again list the contents within this directory using the `ls` command,
    the new directory will appear in that list. You can navigate to that directory
    using the `cd` (that is, *change directory*) command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次使用 `ls` 命令列出此目录的内容，新目录将出现在该列表中。您可以使用 `cd`（即 *change directory*）命令导航到该目录：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can once again use the `pwd` command to check your new path:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以再次使用 `pwd` 命令来检查您的新路径：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In order to return to the previous directory, you can use the `cd` command,
    followed by a blank space and two periods ( `..`):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了返回上一个目录，您可以使用 `cd` 命令，后跟一个空格和两个点（`..`）：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Important note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is worth mentioning that depending on the command line you are using, the
    directory names can be case-sensitive. For example, entering `Downloads` instead
    of `downloads` can be interpreted as a different location, so this may return
    an error. Maintaining consistency in how you name files and directories will be
    key to your success in using the command line.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，根据您使用的命令行，目录名称可能区分大小写。例如，输入 `Downloads` 而不是 `downloads` 可能会被解释为不同的位置，因此这可能会返回错误。在命名文件和目录时保持一致性将是您在命令行中成功的关键。
- en: Creating and running Python scripts
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和运行 Python 脚本
- en: 'Now that you''ve learned a few of the basics, let''s go ahead and create our
    first Python application using the command line. We can create and edit a new
    file using `vim` command, followed by the name of the file you wish to create
    and edit:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学到了一些基础知识，让我们继续使用命令行创建我们的第一个 Python 应用程序。我们可以使用 `vim` 命令（后跟您希望创建和编辑的文件名称）创建和编辑新文件：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will open up an empty file within the Vim editor of your command line
    where you can write or paste your code. By default, you will begin in the *view*
    mode. You can change to the *edit* mode by pressing the *I* key on your keyboard.
    You will notice that the status at the bottom of the Vim window has changed to
    **- - INSERT - -**, which means you can now add code to this file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的命令行 Vim 编辑器中打开一个空文件，您可以在其中编写或粘贴代码。默认情况下，您将处于 *view* 模式。您可以通过按键盘上的 *I* 键切换到
    *edit* 模式。您会注意到 Vim 窗口底部的状态已更改为 **- - INSERT - -**，这意味着您现在可以向此文件添加代码：
- en: '![Figure 2.1 – The Vim window ](img/B17761_02_001.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – Vim 窗口](img/B17761_02_001.jpg)'
- en: Figure 2.1 – The Vim window
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – Vim 窗口
- en: 'Type (or copy and paste) the following few lines of Python code into the file,
    and then click the *Esc* key. You will notice that the status is no longer `:wq`
    and press *Enter*. The *w* key will write the file and the *q* key will quit the
    editor. For more details on other Vim commands, see the Vim website at [https://www.vim.org/](https://www.vim.org/):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下几行 Python 代码（或复制并粘贴）输入到文件中，然后按 *Esc* 键。您会注意到状态不再是 `:wq` 并按 *Enter*。*w* 键将写入文件，而
    *q* 键将退出编辑器。有关其他 Vim 命令的更多详细信息，请参阅 Vim 网站 [https://www.vim.org/](https://www.vim.org/)：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With that, you have now written your first Python script. We can go ahead and
    execute this script using the Python interpreter you installed earlier. Before
    we do so, let's talk about what the script will do. Starting on the first line,
    we will import a library known as `datetime`, which will allow us to determine
    the current date and time of our system. Next, we assign the `datetime` object
    to a variable we will call `now`. We will discuss objects and variables in the
    following section, but for the time being, think of them as variables that can
    be filled with values such as dates or numbers. Finally, we will print a phrase
    that says `Hello Biotech World!`, followed by a statement of the current time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你已经编写了你的第一个Python脚本。我们可以继续使用你之前安装的Python解释器来执行这个脚本。在我们这样做之前，让我们谈谈这个脚本将做什么。从第一行开始，我们将导入一个名为`datetime`的库，这将允许我们确定系统的当前日期和时间。接下来，我们将`datetime`对象分配给一个我们将称之为`now`的变量。我们将在下一节讨论对象和变量，但在此期间，可以将它们视为可以填充值（如日期或数字）的变量。最后，我们将打印一个短语“Hello
    Biotech World!”，然后是当前时间的声明。
- en: 'Let''s give this a try:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Upon executing this file, the following results will appear on your screen:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此文件后，以下结果将出现在你的屏幕上：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we used a library called `datetime`, which was installed by
    default when you installed the Anaconda distribution. There were many others that
    were also installed, and many more that were not. As we progress through these
    projects, we will be using many of these other libraries that we can install using
    `pip`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个名为`datetime`的库，这个库是在你安装Anaconda发行版时默认安装的。还安装了许多其他库，但没有安装的更多。随着我们通过这些项目，我们将使用许多这些其他库，我们可以使用`pip`来安装。
- en: 'The previous example worked without any errors. However, this is seldom the
    case when it comes to programming. There will be instances in which a missing
    period or unclosed bracket will lead to an error. In other situations, programs
    will run indefinitely – perhaps in the background without your knowledge. Closing
    the Terminal command line generally halts running applications. However, there
    will be times in which closing a command-line window is not an option. To identify
    processes running in the background, you can use the `ps` (that is, `process`)
    command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子运行没有任何错误。然而，在编程中这种情况很少见。有时候，一个遗漏的句号或未关闭的括号会导致错误。在其他情况下，程序可能会无限期地运行——可能是在你不知情的情况下在后台运行。通常关闭终端命令行会停止正在运行的应用程序。然而，有时关闭命令行窗口并不是一个选择。要识别后台运行的过程，你可以使用`ps`（即`process`）命令：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will display a list of all running processes. The first column, `UID`,
    is the user ID, followed by the `PID` (process ID) column. A few columns further
    to the right you can see the specific names of the files (if any) that are currently
    active and running. You can narrow down the list using the `grep` command to find
    all those relating to Python:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示所有正在运行的过程列表。第一列是`UID`（用户ID），接着是`PID`（进程ID）列。再往右几列，你可以看到当前活跃和正在运行的特定文件名（如果有）。你可以使用`grep`命令来缩小列表，以找到所有与Python相关的：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If a Python script (for example, `someScript.py`) is running continuously in
    the background, you can easily determine the process ID by using the `grep` command,
    and this means you can subsequently kill the process with the `pkill` command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个Python脚本（例如，`someScript.py`）在后台持续运行，你可以很容易地使用`grep`命令确定进程ID，这意味着你可以随后使用`pkill`命令来结束该进程：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will terminate the script and free up your computer's memory for other
    tasks.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将终止脚本并释放你的计算机内存以供其他任务使用。
- en: Installing packages with pip
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pip安装包
- en: 'One of the best resources available to manage Python libraries is the `sklearn`),
    which we can install using the `pip install` command directly in the Terminal
    command line:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 管理Python库的最佳资源之一是`sklearn`，我们可以直接在终端命令行使用`pip install`命令来安装它：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The package manager will then print some feedback messages alerting you to the
    status of the installation. In some cases, the installation will be successful,
    and in others, it may not be. The feedback you receive here will be helpful in
    determining what next steps, if any, need to be taken.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包管理器将打印一些反馈消息，提醒你安装的状态。在某些情况下，安装将成功，在其他情况下，可能不会。你在这里收到的反馈将有助于确定是否需要采取下一步行动。
- en: There will be instances in which one library will require another to function
    – this is known as a `pip` will automatically handle dependencies for you, but
    this will not always be the case.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将会有一些情况，其中一个库需要另一个库才能运行——这被称为`pip`将自动为你处理依赖关系，但这并不总是如此。
- en: 'To identify the dependencies of a library, you can use the `pip show` command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别库的依赖关系，你可以使用`pip show`命令：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The command line will then print the name, version, URL, and many other properties
    associated with the given library. In some instances, the version shown will be
    outdated or simply not the version you need. You can either use the `pip install`
    command again to update the library to a more recent version, or you can select
    a specific version by specifying it after the library name:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行将随后打印出与给定库相关的名称、版本、URL以及许多其他属性。在某些情况下，显示的版本可能是过时的，或者根本不是你需要的版本。你可以再次使用`pip
    install`命令来更新库到较新版本，或者通过在库名称后指定来选择特定版本：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As the number of packages you install begins to grow, remembering the names
    and associated versions will become increasingly difficult. In order to generate
    a list of packages in a given environment, you can use the `pip freeze` command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你安装的包的数量开始增长，记住它们的名称和相关版本将变得越来越困难。为了生成给定环境中的包列表，你可以使用`pip freeze`命令：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This command will *freeze* a list of libraries and their associated versions
    and then write them to a file called `requirements.txt`. This practice is common
    within teams when migrating code from one computer to another.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将**冻结**一系列库及其相关版本，并将它们写入一个名为`requirements.txt`的文件。当将代码从一个计算机迁移到另一个计算机时，这种做法在团队中很常见。
- en: When things don't work…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当事情不按预期进行时…
- en: Often, code will fail, commands will malfunction, and issues will arise for
    which a solution will not be immediately found. Do not let these instances discourage
    you. As you begin to explore the command line, Python, and most other code-based
    endeavors, you will likely run into errors and problems that you will not be able
    to solve. However, it is likely that others have already solved your problem.
    One of the best resources available for searching and diagnosing code-related
    issues is **Stack Overflow** – a major collaboration and knowledge-sharing platform
    for individuals and companies to ask questions and find solutions for problems
    relating to all types of code. It is highly encouraged that you take advantage
    of this wonderful resource.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，代码会失败，命令会出错，会出现一些问题，而解决方案可能不会立即找到。不要让这些情况让你气馁。当你开始探索命令行、Python以及大多数其他基于代码的尝试时，你可能会遇到一些你无法解决的错误和问题。然而，很可能其他人已经解决了你的问题。用于搜索和诊断代码相关问题的最佳资源之一是**Stack
    Overflow**——一个主要面向个人和公司，用于提问和寻找所有类型代码相关问题的解决方案的协作和知识共享平台。强烈建议你利用这个美好的资源。
- en: Now that we've had a good look at the command line and its endless capabilities,
    let's begin to explore Python in more detail.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对命令行及其无限的能力有了很好的了解，让我们开始更详细地探索Python。
- en: Discovering the Python language
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Python语言
- en: 'There are many different computer languages that exist in the world today.
    **Python**, **R**, **SQL**, **Java**, **JavaScript**, **C++**, **C**, and **C#**
    are just a few examples. Although each of these languages is different when it
    comes to their syntax and application, they can be divided into two general categories:
    *low-level* and *high-level* languages. **Low-level** languages – such as C and
    C++ – are computer languages operating at the machine level. They concern themselves
    with very specific tasks, such as the movement of bits from one location to another.
    On the other hand, **high-level** languages – such as R and Python – concern themselves
    with more abstract processes such as squaring numbers in a list. They completely
    disregard what is happening at the machine level.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上存在许多不同的计算机语言。**Python**、**R**、**SQL**、**Java**、**JavaScript**、**C++**、**C**和**C#**只是其中的一些例子。尽管这些语言在语法和应用方面各不相同，但它们可以被分为两大类：*低级*和*高级*语言。*低级*语言——如C和C++——是在机器级别运行的计算机语言。它们关注非常具体的事情，例如将位从一个位置移动到另一个位置。另一方面，*高级*语言——如R和Python——关注更抽象的过程，例如对一个列表中的数字进行平方。它们完全不考虑机器级别发生的事情。
- en: 'Before we discuss Python in more detail, let''s talk about the idea of compiling
    programs. Most programs – such as programs written in C++ and Java – require what
    is known as a **compiler**. Think of a compiler as a piece of software that converts
    human-readable code into machine-readable code immediately before the program
    is started or executed. While compilers are required for most languages, they
    are not required for languages such as Python. Python requires what is known as
    an **interpreter**, which is inherently similar to a compiler in structure, but
    it executes commands immediately instead of translating them to machine-readable
    code. With that in mind, we will define Python as a *high-level*, *general-purpose*,
    and *interpreted* programming language. Python is commonly used for statistical
    work, machine learning applications, and even game and website development. Since
    Python is an interpreted language, it can either be used within an IDE or directly
    within the Terminal command line:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地讨论Python之前，让我们先谈谈编译程序的概念。大多数程序——例如用C++和Java编写的程序——都需要一种称为**编译器**的东西。将编译器想象成一种软件，它在程序启动或执行之前立即将人类可读的代码转换为机器可读的代码。虽然大多数语言都需要编译器，但像Python这样的语言则不需要。Python需要一种称为**解释器**的东西，它在结构上本质上与编译器相似，但它会立即执行命令而不是将它们转换为机器可读的代码。考虑到这一点，我们将Python定义为一种*高级*、*通用*和*解释型*编程语言。Python常用于统计分析、机器学习应用，甚至游戏和网站开发。由于Python是一种解释型语言，它可以在IDE中使用，也可以直接在终端命令行中使用：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, we'll talk about IDEs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论集成开发环境（IDEs）。
- en: Selecting an IDE
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择IDE
- en: Python code can be prepared in several different ways. For instance, we could
    prepare it through the Terminal command line using the Vim text editor, as demonstrated
    in the previous section. While this method works quite well, you will commonly
    encounter redundancy when it comes to structuring files, organizing directories,
    and executing code. Alternatively, most data scientists default to more graphical
    editors known as **Integrated Development Environments** (**IDEs**). There are
    numerous IDEs that are free and available to download, such as **Spyder**, **PyCharm**,
    **Visual Studio**, or **Jupyter Lab**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码可以通过几种不同的方式准备。例如，我们可以通过在终端命令行中使用Vim文本编辑器来准备它，如前一小节所示。虽然这种方法相当有效，但在结构化文件、组织目录和执行代码时，您通常会遇到冗余。或者，大多数数据科学家默认使用更图形化的编辑器，称为**集成开发环境**（**IDEs**）。有许多免费且可下载的IDE，例如**Spyder**、**PyCharm**、**Visual
    Studio**或**Jupyter Lab**。
- en: 'Each IDE has its respective advantages and disadvantages, and those are highly
    dependent on the use cases and workstreams of the user. Most new data scientists
    generally default to **Jupyter Notebook** and/or **Jupyter Lab** when getting
    started. For the purposes of this book, all code will be prepared and shared using
    Jupyter Notebook. Assuming the installation instructions for Anaconda were properly
    followed in the previous chapter, Jupyter Notebook should already be installed
    on your local machine. You can start the application by opening **Anaconda Navigator**
    and selecting **Jupyter Notebook**:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个IDE都有其各自的优缺点，这些优缺点高度依赖于用户的用例和工作流程。大多数新数据科学家在开始时通常默认使用**Jupyter Notebook**和/或**Jupyter
    Lab**。为了本书的目的，所有代码都将使用Jupyter Notebook准备和共享。假设在上一章中正确遵循了Anaconda的安装说明，Jupyter
    Notebook应该已经安装在本地的计算机上。您可以通过打开**Anaconda Navigator**并选择**Jupyter Notebook**来启动应用程序：
- en: '![Figure 2.2 – The Anaconda Navigator window ](img/B17761_02_002.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – Anaconda Navigator窗口](img/B17761_02_002.png)'
- en: Figure 2.2 – The Anaconda Navigator window
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – Anaconda Navigator窗口
- en: 'Alternatively, you can also start the Jupyter Notebook application using the
    Terminal command line by typing in the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以通过在终端命令行中输入以下命令来启动Jupyter Notebook应用程序：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Upon hitting enter, the same Jupyter Notebook application we saw previously
    should appear on your screen. This is simply a faster method of opening Jupyter
    Notebook.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按下回车键后，之前看到的相同的Jupyter Notebook应用程序应该会出现在您的屏幕上。这仅仅是一种打开Jupyter Notebook的更快方法。
- en: Data types
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'There are many different types of data that Python is capable of handling.
    These can generally be divided into two main categories: **primitives** and **collections**,
    as illustrated in the following diagram:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Python能够处理许多不同类型的数据。这些通常可以分为两大类：**原始数据类型**和**集合**，如下面的图所示：
- en: '![Figure 2.3 – A diagram showing Python datatypes ](img/B17761_02_003.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 显示Python数据类型的图](img/B17761_02_003.jpg)'
- en: Figure 2.3 – A diagram showing Python data types
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 显示Python数据类型的图表
- en: 'The first data type category is primitive values. As the name implies, these
    data types are the most basic building blocks in Python. A few examples of these
    include the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种数据类型类别是原始值。正如其名所示，这些数据类型是Python中最基本的构建块。以下是一些例子：
- en: '![Figure 2.4 – A table of primitive data types ](img/B17761_02_004.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 原始数据类型的表格](img/B17761_02_004.jpg)'
- en: Figure 2.4 – A table of primitive data types
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 原始数据类型的表格
- en: 'The second data type category is collections. Collections are made up of one
    or more primitive values put together. Each type of collection has specific properties
    associated with it, yielding distinct advantages and disadvantages in certain
    conditions. A few examples of these include the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种数据类型类别是集合。集合是由一个或多个原始值组合而成的。每种集合类型都有与之相关的特定属性，在某些条件下产生不同的优势和劣势。以下是一些例子：
- en: '![Figure 2.5 – A table showing different kinds of data type collections ](img/B17761_02_005.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 显示不同数据类型集合的表格](img/B17761_02_005.jpg)'
- en: Figure 2.5 – A table showing different kinds of data type collections
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 显示不同数据类型集合的表格
- en: 'As scientists, we are naturally inclined to organize information as best we
    can. We previously classified data types based on their primitive and collective
    nature. However, we can also classify data types based on a concept known as **mutability**.
    Mutability can also be thought of as *delete-ability*. Variables, such as those
    representing a list, hold an instance of that type. When the object is created
    or instantiated, it is assigned a unique ID. Normally, the type of this object
    cannot be changed after it is defined at runtime, however, it can be changed if
    it is considered *mutable*. Objects such as integers, floats, and Booleans are
    considered *immutable* and therefore cannot be changed after being created. On
    the other hand, objects such as lists, dictionaries, and sets are mutable objects
    and can be changed. Therefore, they are considered mutable, as you can see from
    *Figure 2.6*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为科学家，我们自然会倾向于尽可能好地组织信息。我们之前根据它们的原始和集合性质对数据类型进行了分类。然而，我们也可以根据一个称为**可变性**的概念来分类数据类型。可变性也可以被理解为*可删除性*。变量，例如表示列表的变量，持有该类型的一个实例。当对象被创建或实例化时，它会被分配一个唯一的ID。通常，在运行时定义后，该对象的类型不能更改，但是，如果它被认为是*可变的*，则可以更改。整数、浮点数和布尔值等对象被认为是*不可变的*，因此创建后不能更改。另一方面，列表、字典和集合等对象是可变对象，可以更改。因此，它们被认为是可变的，正如您可以从*图2.6*中看到的那样：
- en: '![Figure 2.6 – Python data types according to their mutability ](img/B17761_02_006.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 根据可变性分类的Python数据类型](img/B17761_02_006.jpg)'
- en: Figure 2.6 – Python data types according to their mutability
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 根据可变性分类的Python数据类型
- en: Now that we have taken a look at some of the basics, let's explore some of the
    more exciting areas of the Python language.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些基础知识，让我们探索Python语言的一些更令人兴奋的领域。
- en: Tutorial – getting started in Python
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 教程 – Python入门
- en: Python is an extensive language, and any attempt to summarize its capabilities
    in under 10 pages would be limited. While this book is not intended to be used
    as a comprehensive guide to Python, we will talk through a number of the *must-know*
    commands and capabilities that every data scientist should be aware of. We will
    see the vast majority of these commands come up in the tutorials to come.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种广泛的语言，任何试图在10页以下总结其功能的尝试都会有限制。虽然这本书的目的不是作为Python的全面指南，但我们将讨论许多数据科学家应该了解的*必知*命令和能力。我们将看到这些命令中的大多数将在接下来的教程中出现。
- en: Creating variables
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建变量
- en: 'One of the core concepts in Python is the idea of variables. `+`) or subtraction
    (`-`) can be combined with variables to create `5` will be assigned to the `x`
    variable, and then, a value of `10` will be assigned to the `y` variable. The
    two variables (`x` and `y`), which are now representing numerical values, are
    considered `z`, can be created to represent the sum of `x` and `y`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Python的一个核心概念是变量的概念。`+`)或减法(`-`)可以与变量结合使用来创建`5`将被分配给`x`变量，然后，`10`的值将被分配给`y`变量。现在代表数值的两个变量（`x`和`y`），可以创建一个名为`z`的变量来表示`x`和`y`的和：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Variables can take on many data types. In addition to the integer values shown
    in the preceding code, variables can be assigned strings, floats, or even Booleans:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以采用许多数据类型。除了前面代码中显示的整数值之外，变量还可以被分配字符串、浮点数，甚至是布尔值：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The specific data type of a variable can be determined using the `type()` function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`type()`函数确定变量的具体数据类型：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Data types do not need to be explicitly declared in Python (unlike other languages
    such as C++ or Java). In fact, Python also allows variables to be **cast** into
    other types. For example, we can cast an integer into a string:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，数据类型不需要显式声明（与C++或Java等语言不同）。实际上，Python还允许变量被**转换**为其他类型。例如，我们可以将一个整数转换为字符串：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can see from what was returned that the data is now of the string type!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从返回的结果中看到，数据现在已经是字符串类型了！
- en: Importing installed libraries
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入已安装的库
- en: 'After a library has been installed, you can import the library into your Python
    script or Jupyter Notebook using the `import` function. You can import the library
    as a whole in the following way:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完库后，你可以使用`import`函数将库导入到你的Python脚本或Jupyter Notebook中。你可以以下面的方式整体导入库：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Alternatively, we can explicitly import all classes from the library:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以显式地从库中导入所有类：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The best way to import any library is to only import the classes that you plan
    to use. We can think of `statistics` library:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 导入任何库的最佳方式是只导入你计划使用的类。我们可以以`statistics`库为例：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Installing and importing libraries will become second nature to you as you venture
    further into the data science field. The following table shows some of the most
    common and most useful libraries any new data scientist should know. Although
    not all of these will be covered within the scope of this book, they are useful
    to know.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你进一步进入数据科学领域，安装和导入库将变得习以为常。下表展示了任何新数据科学家都应该了解的一些最常见且最有用的库。尽管并非所有这些库都会在本书的范围内被涵盖，但了解它们是有用的。
- en: '![Figure 2.7 – A table showing some of the most common Python libraries ](img/B17761_02_007.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 一个显示一些最常见Python库的表格](img/B17761_02_007.jpg)'
- en: Figure 2.7 – A table showing some of the most common Python libraries
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 一个显示一些最常见Python库的表格
- en: The libraries included in the previous table are some of the most common ones
    you will face as you begin your journey in the data science space. In the following
    section, we will focus on the `math` library to run a few calculations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上表中包含的库是在你开始数据科学之旅时可能会遇到的一些最常见的库。在下一节中，我们将重点关注`math`库来进行一些计算。
- en: General calculations
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般计算
- en: 'Within the Python language, we can create variables and assign them specific
    values, as we previously observed. Following this, we can use the values within
    these variables to form expressions and conduct mathematical calculations. For
    example, take the *Arrhenius equation*, commonly used for forecasting molecular
    stability and calculating the temperature dependence of reaction rates. This equation
    is commonly used in R&D for two main purposes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python语言中，我们可以创建变量并赋予它们特定的值，正如我们之前观察到的。随后，我们可以使用这些变量中的值来形成表达式并进行数学计算。例如，考虑常用的*阿伦尼乌斯方程*，它常用于预测分子稳定性和计算反应速率的温度依赖性。这个方程在研发中主要用于两个目的：
- en: Optimizing reaction conditions to maximize yields within a synthetic manufacturing
    process
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化合成制造过程中的反应条件以最大化产量
- en: Predicting the long-term stability of tablets and pills given changes in temperature
    and humidity
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据温度和湿度的变化预测片剂和药丸的长期稳定性
- en: 'The equation can be expressed as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该方程可以表示如下：
- en: '![](img/011.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/011.jpg)'
- en: 'In this case, *k* is the rate constant, *A* is the frequency factor, *EA* is
    the activation energy, *R* is the ideal gas constant, and *T* is the temperature
    in **Kelvin** (**K**). We can use this equation to calculate how a change in temperature
    would affect the rate constant. Let''s assume that the current need is to predict
    what would happen if the temperature changed from 293 K to 303 K. First, we would
    need to define some variables:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*k* 是速率常数，*A* 是频率因子，*EA* 是活化能，*R* 是理想气体常数，*T* 是温度（**开尔文**，**K**）。我们可以使用这个方程来计算温度变化如何影响速率常数。假设当前的需求是预测如果温度从293
    K变化到303 K会发生什么。首先，我们需要定义一些变量：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now reassign the temperature variable another value and recalculate:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重新分配温度变量的另一个值并重新计算：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In conclusion, this shows that a simple change in temperature nearly doubles
    the faction!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这表明温度的简单变化几乎将分数翻倍！
- en: Lists and dictionaries
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表和字典
- en: '**Lists** and **dictionaries** are two of the most common and fundamental data
    types in Python. Lists are simply ordered collections of elements (similar to
    arrays) and can hold elements of the same type, or of different types:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表**和**字典**是Python中最常见和最基本的数据类型。列表只是元素的有序集合（类似于数组），可以包含相同类型或不同类型的元素：'
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The length of any given list can be captured using the `len()` function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`len()`函数捕获任何给定列表的长度：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'List elements can be retrieved using their index location. Remember that all
    indexes in Python begin at `0`, therefore, the first element of this list would
    be at the `0` index:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用索引位置检索列表元素。记住，Python中的所有索引都是从`0`开始的，因此，这个列表的第一个元素位于`0`索引处：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Unlike their primitive counterparts, lists are mutable, as they can be altered
    after their creation. We can add another element to a list using the `append()`
    function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与它们的原始对应物不同，列表是可变的，因为它们在创建后可以被修改。我们可以使用`append()`函数向列表中添加另一个元素：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Dictionaries, on the other hand, are often used for their association of **keys**
    and **values**. Given a dictionary, you can specify the name of a *key* along
    with its corresponding *value*. For example, a chemical inventory list containing
    chemical names and their expiration dates would not work well within a standard
    Python list. The chemical names and their dates cannot be *associated* together
    very easily in this formation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，字典通常用于它们的**键**和**值**的关联。给定一个字典，你可以指定一个*键*的名称及其相应的*值*。例如，一个包含化学名称和它们的有效期的化学清单在标准的Python列表中工作得并不好。化学名称和它们的日期在这个格式中很难*关联*在一起。
- en: 'However, a dictionary would be a perfect way to make this association:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用字典来建立这种关联是完美的：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This dictionary now represents the elements of a single *chemical*, in the
    sense that there is a key assigned to it for a name, and another for an expiration
    date. You can retrieve a specific value within a dictionary by specifying the
    key:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这本词典现在代表了一个单一的*化学元素*，在这个意义上，有一个键分配给它作为名称，另一个键分配给它作为有效期。你可以通过指定键来检索字典中的特定值：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To construct a full inventory of chemicals, you would need to create multiple
    dictionaries, one for each chemical, and add them all to a single list. This format
    is known as **JSON**, which we will explore in more detail later in this chapter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个完整的化学清单，你需要为每个化学物质创建多个字典，并将它们全部添加到一个列表中。这种格式被称为**JSON**，我们将在本章的后面更详细地探讨。
- en: Arrays
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: '**Arrays** in Python are analogous to lists in the sense that they can contain
    elements of different types, they can have multiple duplicates, and they can be
    changed and mutated over time. Arrays can be easily extended, appended, cleared,
    copied, counted, indexed, reversed, or sorted using simple functions. Take the
    following as an example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的**数组**与列表类似，因为它们可以包含不同类型的元素，可以有多个重复项，并且可以随时间改变和变异。数组可以通过简单的函数轻松扩展、追加、清除、复制、计数、索引、反转或排序。以下是一个例子：
- en: 'Let''s go ahead and create an array using `numpy`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续使用`numpy`创建一个数组：
- en: '[PRE35]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can add another element to the end of the list using the `append()` function:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用`append()`函数向列表末尾添加另一个元素：
- en: '[PRE36]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The length of the array can be determined using the `len()` function:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`len()`函数确定数组的长度：
- en: '[PRE37]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The array can also be sliced using brackets and assigned to new variables.
    For example, the following code takes the first five elements of the list:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组也可以使用方括号进行切片，并分配给新的变量。例如，以下代码取列表的前五个元素：
- en: '[PRE38]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now that we have mastered some of the basics when it comes to Python, let's
    dive into the more complex topic of *functions*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了Python的一些基础知识，让我们深入探讨更复杂的话题——*函数*。
- en: Creating functions
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建函数
- en: 'A **function** in Python is a way to organize code and isolate processes, allowing
    you to define an explicit input and an explicit output. Take, for example, a function
    that squares numbers:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的**函数**是一种组织代码和隔离过程的方式，允许你定义明确的输入和明确的输出。以一个平方数字的函数为例：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Functions are *first class* in the sense that they can be assigned to variables
    or subsequently passed to other functions:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是*一等*的，因为它们可以被分配给变量或随后传递给其他函数：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Depending on their purpose, functions can have multiple inputs and outputs.
    It is generally accepted that a function should serve one specific purpose and
    nothing more.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们的目的，函数可以有多个输入和输出。通常认为一个函数应该只服务于一个特定的目的，而不再多。
- en: Iteration and loops
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代和循环
- en: 'There will be many instances where a task must be conducted in a repetitive
    or iterative manner. In the previous example, a single value was squared, however,
    what if there were 10 values that needed to be squared? You could either manually
    run this function over and over, or you could iterate it with a `for` loops and
    `while` loops. A `for` loop is generally used when the number of iterations is
    known. On the other hand, a `while` loop is generally used when a loop needs to
    be broken based on a given condition. Let''s take a look at an example of a `for`
    loop:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将会有许多任务必须以重复或迭代的方式进行。在先前的例子中，一个值被平方了，但是如果有10个值需要被平方怎么办？你可以手动重复运行这个函数，或者使用`for`循环和`while`循环来迭代。`for`循环通常用于已知迭代次数的情况。另一方面，`while`循环通常用于需要根据给定条件中断循环的情况。让我们来看一个`for`循环的例子：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, a list of values is defined. An empty list – where the squared values
    will be written to – is then created. We then iterate over the list, square the
    value, append (add) it to the new list, and then print the value. Although `for`
    loops are great for iterating, they can be incredibly slow in some cases when
    handling larger datasets.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个值列表。然后创建一个空列表——平方值将被写入其中。我们然后遍历这个列表，平方值，将其追加（添加）到新列表中，然后打印值。虽然`for`循环在迭代方面很棒，但在处理大型数据集的情况下，它们在某些情况下可能会非常慢。
- en: 'However, `while` loops can also be used for various types of iterations, specifically
    when the iteration is to cease when a condition is met. Let''s take a look at
    an example of a `while` loop:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`while`循环也可以用于各种类型的迭代，特别是在迭代需要在满足条件时停止时。让我们来看一个`while`循环的例子：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now that we have gained a stronger understanding of loops and how they can be
    used, let's explore a more advanced form of iteration known as *list comprehension*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对循环及其使用有了更深入的了解，让我们探索一种更高级的迭代形式，称为*列表推导*。
- en: List comprehension
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表推导
- en: 'Like `for` loops, **list comprehension** allows the iteration of a process
    using a powerful single line of code. We can replicate the previous example of
    squaring values using this single line:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与`for`循环一样，**列表推导**允许使用一行强大的代码来迭代一个过程。我们可以使用这行代码来复制之前平方值的例子：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'There are three main reasons why you should use list comprehension:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个主要的原因说明你应该使用列表推导：
- en: It can reduce several lines of code down to a single line, making your code
    much neater.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以将几行代码缩减为单行，使你的代码更加整洁。
- en: It can be significantly faster than its `for` loop counterparts.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能比其`for`循环版本快得多。
- en: It is an excellent interview question about writing efficient code. Hint hint.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个关于编写高效代码的极好面试问题。提示提示。
- en: DataFrames
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DataFrames
- en: '`pandas` library are arguably among the most common objects within the Python
    data science space. DataFrames are analogous to structured tables (think of an
    `DataFrame` object can be constructed as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`库可以说是Python数据科学空间中最常见的对象之一。DataFrames类似于结构化表格（例如，可以将`DataFrame`对象构建如下：'
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will give the following output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '![Figure 2.8 – A table showing the results of the DataFrame object ](img/B17761_02_008.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 显示DataFrame对象结果的表格](img/B17761_02_008.jpg)'
- en: Figure 2.8 – A table showing the results of the DataFrame object
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 显示DataFrame对象结果的表格
- en: 'Almost every parameter within a `DataFrame` object can be changed and altered
    to fit the data within it. For example, the columns can be relabeled with full
    words:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DataFrame`对象内部几乎每一个参数都可以被改变和调整以适应其中的数据。例如，列可以被重新标记为全词：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'New columns can be created representing an output of a mathematical function.
    For example, a column representing the squared values of `ColumnC` can be prepared:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建新的列来表示数学函数的输出。例如，可以准备一个表示`ColumnC`平方值的列：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output of this is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出的结果如下：
- en: '![Figure 2.9 – A table showing the results of the DataFrame object ](img/B17761_02_009.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 显示DataFrame对象结果的表格](img/B17761_02_009.jpg)'
- en: Figure 2.9 – A table showing the results of the DataFrame object
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 显示DataFrame对象结果的表格
- en: 'Alternatively, DataFrames can be prepared using a pre-existing CSV file from
    your local machine. This can be accomplished using the `read_csv()` function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用您本地机器上的现有CSV文件来准备DataFrames。这可以通过使用`read_csv()`函数来完成：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Instead of importing the entire dataset, a specific set of columns can be selected:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是导入整个数据集，可以选择特定的列集：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output of this is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出的结果如下：
- en: '![Figure 2.10 – A table showing the results of the DataFrame object ](img/B17761_02_010.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.10 – 展示 DataFrame 对象结果的表格](img/B17761_02_010.jpg)'
- en: Figure 2.10 – A table showing the results of the DataFrame object
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.10 – 展示 DataFrame 对象结果的表格
- en: 'Alternatively, the `tail()` function can also be used to view the last few
    rows of data:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也可以使用 `tail()` 函数来查看数据的最后几行：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: DataFrames are some of the most common forms of data handling and presentation
    within Python, as they resemble standard 2D tables that most people are familiar
    with. A more efficient alternative for handling larger quantities of data is to
    use `PySpark` library.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrames 是 Python 中最常见的数据处理和展示形式之一，因为它们类似于大多数人熟悉的标准的 2D 表格。处理大量数据的一个更有效的方法是使用
    `PySpark` 库。
- en: Now that we are able to manage and process data locally on our machines, let's
    take a look at how we could retrieve data from external sources using *API requests*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够在我们的机器上本地管理和处理数据，让我们看看如何使用 *API 请求* 从外部源检索数据。
- en: API requests and JSON
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 请求和 JSON
- en: 'In some instances, data will not be available locally on your computer and
    you will need to retrieve it from a remote location. One of the most common ways
    to send and receive data is in the form of an **application programming interface**
    (**API**). The main idea behind an API is to use HTTP requests to obtain data,
    commonly communicated in the **JSON** format. Let''s take a look at an example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，数据可能不会存储在您的计算机本地，您需要从远程位置检索它。发送和接收数据最常见的方式之一是以 **应用程序编程接口**（**API**）的形式。API
    的主要思想是使用 HTTP 请求来获取数据，通常以 **JSON** 格式进行通信。让我们来看一个例子：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Think of a JSON as a list of dictionaries in which each dictionary is an element.
    We can select specific elements in the list based on their index locations. In
    Python, we begin the count at `0`, therefore, the first item in our list of dictionaries
    will have the index location of `0`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JSON 视为一个字典列表，其中每个字典是一个元素。我们可以根据它们的索引位置选择列表中的特定元素。在 Python 中，我们从 `0` 开始计数，因此，我们字典列表中的第一个元素将具有索引位置
    `0`：
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This gives us the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下结果：
- en: '![Figure 2.11 – A sample of the results obtained from an HTTP request ](img/B17761_02_011.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.11 – 来自 HTTP 请求的结果样本](img/B17761_02_011.jpg)'
- en: Figure 2.11 – A sample of the results obtained from an HTTP request
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.11 – 来自 HTTP 请求的结果样本
- en: 'The *values* within the dictionary can be accessed using their corresponding
    *keys*:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用相应的 *键* 访问字典中的 *值*：
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In a similar way to CSV files, JSON files can also be imported into DataFrames
    using the `read_json()` function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CSV 文件类似，JSON 文件也可以使用 `read_json()` 函数导入到 DataFrame 中。
- en: Parsing PDFs
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析 PDF
- en: 'Unlike the many structured forms of data we have imported into Python, such
    as CSV and JSON files, you will often encounter data in its unstructured form
    – for example, text files or PDFs. For most applications that use `tika` – one
    of the most popular in the open source community. We can begin by installing the
    library using `pip`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们导入 Python 的许多结构化数据形式不同，例如 CSV 和 JSON 文件，您通常会遇到非结构化的数据形式——例如，文本文件或 PDF 文件。对于大多数使用
    `tika` 的应用程序——开源社区中最受欢迎的一个——我们可以通过使用 `pip` 安装库来开始：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can then go ahead and read the specific PDF file of interest:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以继续读取感兴趣的特定 PDF 文件：
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The data within `raw['content']` will be the text of the PDF file parsed by
    the `tika` library. This data is now ready to be used and preprocessed in a subsequent
    NLP application.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`raw[''content'']` 中的数据将是 `tika` 库解析的 PDF 文件文本。这些数据现在可以用于后续的自然语言处理（NLP）应用程序中的预处理和使用。'
- en: Pickling files
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pickling 文件
- en: 'The vast majority of the documents we have handled so far are files that are
    commonly saved locally to your computer – for example, PDFs, CSVs, and JSON files.
    So, how do we save a Python object? If you have an important list of items you
    wish to save – perhaps the chemicals from our previous example – you will need
    a way to save those files locally to use at a later time. For this, most data
    scientists use `pickle`. The `pickle` library allows you to save and store Python
    objects for use at a later time in the form of `.pkl` files. These files can later
    be imported back to Python and used for new tasks. This is a process known as
    *serializing* and *deserializing* objects in Python. Let''s take a look at an
    example of using a `.pkl` file. We start by importing the `pickle` library and
    then creating a list of items:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止处理的大多数文档都是通常保存在您计算机上的文件，例如PDF、CSV和JSON文件。那么，我们如何保存Python对象呢？如果您有一个重要的项目列表需要保存，比如我们之前的例子中的化学品，您需要一种方法将这些文件本地保存以便以后使用。为此，大多数数据科学家使用`pickle`。`pickle`库允许您将Python对象保存和存储为`.pkl`文件，以便以后在Python中使用。这些文件可以稍后导入到Python中，用于新任务。这是一个在Python中序列化和反序列化对象的过程。让我们看看使用`.pkl`文件的一个例子。我们首先导入`pickle`库，然后创建一个项目列表：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In order to save the list as a `.pkl` file, we will need to specify a location
    for the file to be saved in. Note that we will be using the `wb` mode (that is,
    the *write binary* mode). We will then use the `dump()` function to save the contents:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将列表保存为`.pkl`文件，我们需要指定文件保存的位置。请注意，我们将使用`wb`模式（即*写二进制*模式）。然后我们将使用`dump()`函数来保存内容：
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Whether the file was saved locally or shared with a colleague, it can subsequently
    be loaded back into Python using the `load()` command in a similar manner:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 不论文件是本地保存还是与同事共享，都可以使用类似的方式通过Python中的`load()`命令将其重新加载：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Notice that in the preceding example, we switched between two arguments – `wb`
    (write binary) and `rb` (read binary) – depending on the task. These are two modes
    that can be selected to load and save files. There are a number of other options
    that can be used. The main distinction that should be noted here is the use of
    *binary* formats. On Windows, opening the files in binary mode will address end-of-line
    characters in text files mostly seen in `ASCII` files. The following table provides
    an overview of some of the most common modes:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的例子中，我们根据任务在两个参数之间切换 – `wb`（写二进制）和`rb`（读二进制） – 这些是可以选择的两种加载和保存文件的模式。还有许多其他选项可以使用。这里应该注意的主要区别是*二进制*格式的使用。在Windows上，以二进制模式打开文件将解决文本文件中的换行符，这在`ASCII`文件中很常见。以下表格概述了一些最常见的模式：
- en: '![ Figure 2.12 – A table showing the most common read/write modes ](img/B17761_02_012.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 一个显示最常见的读写模式的表格](img/B17761_02_012.jpg)'
- en: Figure 2.12 – A table showing the most common read/write modes
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 一个显示最常见的读写模式的表格
- en: Now that we have gained a basic understanding of APIs and the operations we
    can perform on data, let's take a look at the use of **object-oriented programming**
    (**OOP**) as it relates to Python.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对API和我们可以对数据进行操作有了基本的理解，让我们看看**面向对象编程（OOP**）在Python中的应用。
- en: Object-oriented programming
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Similar to many other languages – such as C++, Java, and C# – the concept of
    OOP can also be used in Python. In OOP, the main aim is to use **classes** to
    organize and **encapsulate** data objects and their associated functions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他语言（如C++、Java和C#）类似，面向对象的概念也可以在Python中使用。在面向对象编程中，主要目的是使用**类**来组织和封装数据对象及其相关函数。
- en: 'Let''s explore an example of OOP in the context of chemical inventory management.
    Most modern biotechnology companies have extensive inventory systems that monitor
    their stock of in-house chemicals. Inventory systems allow companies to ensure
    that supplies do not run out and expiration dates are adequately monitored, along
    with many other tasks. Now, we will use our current knowledge of Python alongside
    the concept of OOP to construct an inventory management system:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨一个在化学库存管理背景下的面向对象编程（OOP）的例子。大多数现代生物技术公司都有广泛的库存系统，用于监控他们内部的化学品库存。库存系统允许公司确保供应不会耗尽，并且到期日期得到充分监控，以及许多其他任务。现在，我们将利用我们对Python的了解以及面向对象的概念来构建一个库存管理系统：
- en: 'We begin by importing two libraries we will need to manage our dates:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入我们将需要来管理我们日期的两个库：
- en: '[PRE58]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, we define a name for the class using the following syntax:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下语法为类定义一个名称：
- en: '[PRE59]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We then construct a portion of code known as the constructor:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们构建了一个称为构造函数的代码片段：
- en: '[PRE60]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The purpose of the `__init__` function to initialize or create this object,
    and we use `self` to refer to that specific instance of a class. For example,
    if we created two chemical objects, `self.name` could be `acetonitrile` for one
    object and `methanol` for another.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`__init__` 函数的目的是初始化或创建此对象，我们使用 `self` 来引用该特定类的实例。例如，如果我们创建了两个化学对象，`self.name`
    对于一个对象可能是 `acetonitrile`，而对于另一个对象则是 `methanol`。'
- en: 'Next, we can define a few functions that are relevant to our class. These functions
    are class-specific and are *tied* to the class in such a way that they can only
    be accessed through it. We call these functions `self` as an argument to tie the
    function to the specific instance of interest. In the following example, we will
    create an `isExpired()` function that will read the expiration date of the chemical
    and return a `True` value if expired. We begin by determining today''s date, and
    then retrieve the object''s date using the `self.exp_date` argument. We then return
    a Boolean value that is the product of a comparison between the two dates:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以定义一些与我们的类相关的函数。这些函数是类特定的，并且以某种方式与类相关联，使得它们只能通过它来访问。我们将这些函数称为 `self`
    作为参数，以将函数绑定到感兴趣的特定实例。在以下示例中，我们将创建一个 `isExpired()` 函数，该函数将读取化学品的过期日期，并在过期时返回 `True`
    值。我们首先确定今天的日期，然后使用 `self.exp_date` 参数检索对象的日期。然后，我们返回一个布尔值，它是两个日期比较的结果的乘积：
- en: '[PRE61]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can test this out by creating a new object using the `Chemical` class:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `Chemical` 类创建一个新的对象来测试这一点：
- en: '[PRE62]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'With that, we have constructed a chemical object we call `chem1`. We can retrieve
    the fields or attributes of `chem1` by specifying the name of the field:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这些，我们已经构建了一个我们称之为 `chem1` 的化学对象。我们可以通过指定字段的名称来检索 `chem1` 的字段或属性：
- en: '[PRE63]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can use our function by specifying in a similar manner:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过类似的方式指定来使用我们的函数：
- en: '[PRE64]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can create many instances of our class, with each instance containing a
    different date:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建我们类的多个实例，每个实例包含不同的日期：
- en: '[PRE65]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Each of these objects will return their respective values when followed by either
    their fields or functions.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个这些对象在跟随它们的字段或函数时都会返回各自的值。
- en: 'We can also create functions to summarize the data within a particular instance
    of an object:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以创建函数来总结对象特定实例中的数据：
- en: '[PRE66]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We can then call the `summarizer()` function on any of the chemical objects
    we have created in order to retrieve a human-readable summary of its status:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以调用任何我们创建的化学对象的 `summarizer()` 函数，以检索其状态的易读摘要：
- en: '[PRE67]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The functions we have written so far have not taken any additional arguments
    and have simply retrieved data for us. Chemical inventory systems often need to
    be updated to reflect items that have expired or been consumed, thereby altering
    the count. Functions can also be used to change or alter the data within an object:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们迄今为止编写的函数没有接受任何额外的参数，只是为我们检索数据。化学库存系统通常需要更新以反映已过期或被消耗的项目，从而改变计数。函数也可以用来更改或修改对象内的数据：
- en: '[PRE68]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can simply add `value` as an argument to set that instance''s count (represented
    by `self.count`) to the corresponding value. We can test this using one of our
    objects:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以简单地添加 `value` 作为参数来设置该实例的计数（由 `self.count` 表示）为相应的值。我们可以通过我们的一个对象来测试这一点：
- en: '[PRE69]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: There are many other uses, applications, and patterns for OOP that go above
    and beyond the example we have just seen. For example, inventory systems would
    not only need to maintain their inventories, but they would also need to manage
    the expiry dates of each item, record sales details, and have methods and functions
    to compile and report these metrics. If you are interested in the development
    of classes within Python, please visit the official Python documentation to learn
    more ([https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html)).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: OOP（面向对象编程）有许多其他用途、应用和模式，这些模式超出了我们刚刚看到的示例。例如，库存系统不仅需要维护其库存，还需要管理每个项目的过期日期，记录销售详情，并具有编译和报告这些指标的方法和函数。如果您对Python中类的开发感兴趣，请访问官方Python文档以了解更多信息（[https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html)）。
- en: Tutorial – working with Rdkit and BioPython
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 教程 – 使用Rdkit和BioPython
- en: 'In the previous tutorial, we saw various examples of how Python can be used
    to calculate properties, organize data, parse files, and much more. In addition
    to the libraries we have worked with thus far, there are two others in particular
    we need to pay close attention to when operating in the fields of Biotechnology
    and Life Sciences: **Rdkit**, and **BioPython**. In the following sections, we
    will look at a few examples of the many capabilities available in these packages.
    With this in mind, let us go ahead and get started!'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的教程中，我们看到了如何使用Python来计算属性、组织数据、解析文件以及更多示例。除了我们迄今为止使用的库之外，在生物技术和生命科学领域操作时，我们还需要特别注意两个库：**Rdkit**和**BioPython**。在接下来的章节中，我们将探讨这些包中许多可用功能的几个示例。考虑到这一点，让我们开始吧！
- en: Working with Small Molecules and Rdkit
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与小分子和Rdkit一起工作
- en: 'One of the most common packages data scientists use when handling data relating
    to small molecules is known as `rdkit` package includes many different tools and
    capabilities to the point that we would need a completely second book to cover
    in total. Highlighted below are five of the most common applications this package
    is generally known for, as seen in *Figure 2.13*:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家在处理小分子相关数据时最常用的包之一是名为`rdkit`的包，它包含了许多不同的工具和能力，以至于我们需要另一本完全不同的书来全面覆盖。以下列出了该包通常被认为是五个最常见的应用，如*图2.13*所示：
- en: '![Figure 2.13 – Some of the main functionality in the rdkit package ](img/B17761_02_013.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13 – rdkit包中的主要功能](img/B17761_02_013.jpg)'
- en: Figure 2.13 – Some of the main functionality in the rdkit package
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – rdkit包中的主要功能
- en: Let us go ahead and example a few of these capabilities in order to introduce
    ourselves to the `rdkit` package.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举例说明这些功能，以便我们熟悉`rdkit`包。
- en: Working with SMILES Representations
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与SMILES表示一起工作
- en: Similar to some of the packages we have seen already, `rdkit` is organized by
    classes. Let us now take advantage of the `Chem` class to load a `SMILES` representation
    in a few simple steps.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的某些包类似，`rdkit`是按类组织的。现在让我们利用`Chem`类通过几个简单的步骤加载`SMILES`表示。
- en: 'We will start off by importing the `Chem` class:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先导入`Chem`类：
- en: '[PRE70]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'One of the easiest and most common ways to transfer 2D molecular structures
    from one Python script to another is by using a `SMILES` representation. For example,
    we can describe a `SMILES` representation as seen here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 将2D分子结构从一个Python脚本传输到另一个最简单和最常见的方法是使用`SMILES`表示。例如，我们可以将`SMILES`表示描述如下：
- en: '[PRE71]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can use the `MolFromSmiles` function within the `Chem` class to load our
    `SMILES` representation into `rdkit`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Chem`类中的`MolFromSmiles`函数将我们的`SMILES`表示加载到`rdkit`中：
- en: '[PRE72]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Upon printing the molecule variable we assigned above, a figure of the molecule
    will be returned as shown in *Figure 2.14*:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印我们分配的分子变量时，将返回如图2.14所示的分子图示：
- en: '![Figure 2.14 – A 2D representation of the QAC using rdkit ](img/B17761_02_014.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14 – 使用rdkit的QAC的2D表示](img/B17761_02_014.jpg)'
- en: Figure 2.14 – A 2D representation of the QAC using rdkit
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – 使用rdkit的QAC的2D表示
- en: Notice that we did not need any additional packages to print this figure as
    `rdkit` is quire comprehensive and has everything you need to run these visualizations.
    In the following section, we will see another example of `rdkit` as it comes to
    similarity calculations.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要任何额外的包来打印这个图，因为`rdkit`非常全面，包含了运行这些可视化所需的一切。在下一节中，我们将看到`rdkit`在相似性计算方面的另一个示例。
- en: 'With the structure now loaded, there are many different applications and calculations
    one can do. One of the most common methods to do here is searching for substructures
    within the molecule. We can accomplish this by using the `MolFromSmarts` function
    within `rdkit`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 结构现在已加载，可以进行许多不同的应用和计算。在这里最常见的方法之一是在分子内搜索子结构。我们可以通过使用`rdkit`中的`MolFromSmarts`函数来完成这项任务：
- en: '[PRE73]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Upon executing this, we yield the following figure showing the substructure
    of interest:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作后，我们将得到以下图示，显示了感兴趣的子结构：
- en: '![Figure 2.15 – A 2D substructure of interest ](img/B17761_02_015.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15 – 一个感兴趣的2D子结构](img/B17761_02_015.jpg)'
- en: Figure 2.15 – A 2D substructure of interest
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 – 一个感兴趣的2D子结构
- en: 'With the main molecule of interest and the pattern now both loaded, we can
    use the `HasSubstructMatch` function to determine if the substructure exists:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载了主要分子和模式之后，我们可以使用`HasSubstructMatch`函数来确定子结构是否存在：
- en: '[PRE74]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Upon executing this code, the value of `True` will be returned indicating that
    the structure does exist. On the other hand, if another substructure such as a
    phenol were to be run, the value would return as `False`, since that substructure
    does not exist in the main molecule.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码后，将返回 `True` 的值，表示该结构确实存在。另一方面，如果运行另一个子结构，例如苯酚，返回的值将是 `False`，因为该子结构不存在于主分子中。
- en: 'In addition, similarity calculations can be run using the `DataStructs` class
    within `rdkit`. We can being by importing the class, and entering two molecules
    of interest:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以使用 `rdkit` 中的 `DataStructs` 类来运行相似度计算。我们可以从导入该类并输入两个感兴趣的分子开始：
- en: '[PRE75]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: If we compared the two molecules visually using the `MolFromSmiles` method we
    saw previously, we can see that there exists a minor difference between the two
    structures, being the double bonds in the hydrophobic tails in one of the molecules.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用之前提到的 `MolFromSmiles` 方法从视觉上比较这两个分子，我们可以看到两个结构之间存在细微的差异，即其中一个分子的疏水性尾部存在双键。
- en: 'Next, we can use the `RDKFingerprint` function to calculate the fingerprints:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用 `RDKFingerprint` 函数来计算指纹：
- en: '[PRE76]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, we can use `CosineSimilarity` metric to calculate how different the
    two structures are:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `CosineSimilarity` 指标来计算两个结构之间的差异：
- en: '[PRE77]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This calculation will yield a value of approximately 99.14%, indicating that
    the structures are mostly the same with the exception of a minor difference.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此计算将产生大约 99.14% 的值，表明结构基本上是相同的，除了存在一个细微的差异。
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Python is a powerful language that will serve you well, regardless of your area
    of expertise. In this chapter, we discussed some of the most important concepts
    when working with the command line, such as creating directories, installing packages,
    and creating and editing Python scripts. We also discussed the Python programming
    language quite extensively. We reviewed some of the most commonly used IDEs, general
    data types, and calculations. We also reviewed some of the more complex data types
    such as lists, DataFrames, and JSON files. We also looked over the basics of APIs
    and making HTTP requests, and we introduced OOP with regard to Python classes.
    All of the examples we explored in this chapter relate to applications commonly
    discussed within the field of data science, so having a strong understanding of
    them will be very beneficial.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种强大的语言，无论您的专业领域如何，它都会为您服务得很好。在本章中，我们讨论了与命令行工作相关的一些重要概念，例如创建目录、安装包、创建和编辑
    Python 脚本。我们还广泛地讨论了 Python 编程语言。我们回顾了一些最常用的 IDE、通用数据类型和计算。我们还回顾了一些更复杂的数据类型，如列表、DataFrames
    和 JSON 文件。我们还了解了 API 的基础知识以及如何进行 HTTP 请求，并介绍了与 Python 类相关的 OOP。本章中我们探讨的所有示例都与数据科学领域内常见应用相关，因此对这些概念有深入理解将非常有益。
- en: Although this chapter was designed to introduce you to some of the most important
    concepts in data science (such as variables, lists, JSON files, and dictionaries),
    we were not able to cover them all. There are many other topics, such as tuples,
    sets, counters, sorting, regular expressions, and many facets of OOP that we have
    not discussed. The documentation for Python – both in print and online – is extensive
    and mostly free. I would urge you to take advantage of these resources and learn
    as much as you can from them.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章旨在向您介绍数据科学中的一些重要概念（如变量、列表、JSON 文件和字典），但我们并没有涵盖所有内容。还有许多其他主题，例如元组、集合、计数器、排序、正则表达式以及
    OOP 的许多方面，我们尚未讨论。Python 的文档——无论是印刷版还是在线版——都非常广泛，而且大部分是免费的。我敦促您利用这些资源，尽可能多地从中学习。
- en: Within this chapter, we discussed many ways to handle small amounts of data
    when it comes to slicing it around and running basic calculations. At the enterprise
    level, data generally comes in significantly larger quantities, and therefore,
    we'll need the right tool to tackle it. That tool is **Structured Query Language**
    (**SQL**), and we will get acquainted with this in the next chapter.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了许多处理少量数据的方法，包括切片和运行基本计算。在企业层面，数据通常以显著更大的数量出现，因此，我们需要合适的工具来处理它。这个工具就是**结构化查询语言**（**SQL**），我们将在下一章中了解它。
