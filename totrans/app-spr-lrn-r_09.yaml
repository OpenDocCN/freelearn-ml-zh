- en: '*Chapter 9:*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章：*'
- en: Capstone Project - Based on Research Papers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于研究论文的毕业设计
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Apply end-to-end machine learning workflow on a problem using mlr and OpenML,
    which involves identifying research articles.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用mlr和OpenML在问题上应用端到端的机器学习工作流程，这包括识别研究文章。
- en: Train machine learning model and, subsequently, predict and evaluate using the
    model on a test dataset.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练机器学习模型，并随后在测试数据集上使用该模型进行预测和评估。
- en: Perform resampling on the dataset.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数据集进行重采样。
- en: Design experiments for building various models.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计用于构建各种模型的实验。
- en: Build benchmarks for choosing the best model.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为选择最佳模型建立基准。
- en: In this chapter, we will take up the latest research paper based on a real-world
    problem and will reproduce the result.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于一个现实世界问题选取最新的研究论文，并重现其结果。
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: In this final chapter, we will focus on working on a research-based capstone
    project. The ideas from all the previous chapters such as designing the problem
    using the SCQ framework, identifying the source of data, preprocessing the dataset,
    training a machine learning model, evaluating a model, applying resampling techniques,
    and many other concepts will be used. Additionally, this chapter will also focus
    on benchmarking models, designing experiments in machine learning, collaborating
    in open source platforms, and making a research work reproducible for the benefits
    of the larger community.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将专注于一个基于研究的项目。所有前几章中的想法，例如使用SCQ框架设计问题、识别数据来源、预处理数据集、训练机器学习模型、评估模型、应用重采样技术以及许多其他概念都将被使用。此外，本章还将关注基准测试模型、设计机器学习实验、在开源平台上协作以及使研究工作可重复，以造福更大的社区。
- en: The abundance of online resources, computation power, and out-of-the-box toolkit
    solutions has made the entry barrier in becoming a machine learning professional
    minimum. Today, we have plenty of quickstart algorithms provided as a function
    in a package in programming languages such as R and Python, or even as a drag
    and drop in platforms such as Google Cloud AutoML or Microsoft Azure Machine Learning
    Studio. However, what is often missing in many such quick start Hello World models
    is the keen focus on problem solving and the ability to go beyond the available
    tools.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在线资源的丰富、计算能力的提升以及现成的工具包解决方案的广泛应用，使得成为机器学习专业人员的门槛降至最低。如今，我们有很多快速入门算法，它们作为R和Python等编程语言中的函数提供，甚至在Google
    Cloud AutoML或Microsoft Azure Machine Learning Studio等平台上的拖放操作中提供。然而，在许多这样的快速入门Hello
    World模型中，通常缺少的是对问题解决的敏锐关注以及超越现有工具的能力。
- en: Apart from the extravagant toolkits, there exists a world of research-oriented
    work produced by many leading practitioners from academia and industry. The importance
    of such research work is immense when it comes to producing breakthrough and high-quality
    outcomes. However, the accessibility of such research work is limited and hence
    prevents the widespread adoption among machine learning practitioners. Another
    reason why one does not pursue research-based work is because of the lack of reproducibility
    (mostly because of code not being available in public domain, unclear research
    finding, or poor quality of the research work) and jargon-filled theory (many
    written in mathematical language) found in research articles or papers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了豪华的工具集之外，还存在着由许多学术界和工业界的领先实践者产生的以研究为导向的工作世界。当涉及到产生突破和高品质成果时，这种研究工作的重要性是巨大的。然而，这种研究工作的可访问性有限，因此阻碍了机器学习实践者中的广泛应用。不追求基于研究的工作的另一个原因是由于缺乏可重复性（大多是因为代码未在公共领域提供，研究发现不明确，或研究工作质量差）以及在研究文章或论文中发现的充满术语的理论（许多是用数学语言编写的）。
- en: This chapter is dedicated to such research work, which often goes unnoticed
    by many learners who endeavor into machine learning but limit themselves to using
    only specific tools and packages advocated in blogs or online books. We will focus
    on two significant research works, which, fortunately, also found a place in R
    packages. The next section will introduce the work and set the flow of the rest
    of this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于此类研究工作，这些工作往往被许多努力进入机器学习但仅限于使用博客或在线书籍中提倡的特定工具和包的许多学习者忽视。我们将关注两个重要的研究工作，幸运的是，它们也找到了在R包中的位置。下一节将介绍这项工作，并设定本章其余部分的流程。
- en: Exploring Research Work
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索研究工作
- en: In this chapter, we will explore the two most significant research works that
    eventually also became an open source offering. The emphasis in this chapter is
    given onto a top-down approach, where we will start from the origin of excellent
    research work and see how it became a mainstream toolkit for everyone to use.
    While emphasizing on research work, we would like to highlight that a lot of research
    work does not find its place in the standard toolkit available in the market,
    but some gems could be found if one works slightly harder.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨两项最终也成为开源项目的最显著研究成果。本章的重点在于自上而下的方法，我们将从优秀研究成果的起源开始，看看它是如何成为每个人都可以使用的主流工具包的。在强调研究成果的同时，我们还想强调，许多研究成果在市场上可用的标准工具包中找不到位置，但如果稍微努力一些，就能发现一些珍宝。
- en: We recommend following the fantastic effort put by the creators of https://paperswithcode.com.
    The **Papers With Code** team has created a free and open resource platform with
    machine learning papers, code, and evaluation tables with the help from the community
    and powered by automation. They have already automated the linking of code to
    papers, and they are now working on automating the extraction of evaluation metrics
    from papers. The work is commendable because it will bring the best research work
    to stand out amid the noise and abundance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐参考 https://paperswithcode.com 创作者所付出的出色努力。**Papers With Code** 团队借助社区的帮助和自动化的力量，创建了一个免费且开放的资源平台，包含机器学习论文、代码和评估表格。他们已经自动化了代码与论文的链接，现在正在努力自动化从论文中提取评估指标。这项工作值得称赞，因为它将把最佳研究成果从噪音和繁杂中凸显出来。
- en: 'The following table will highlight five cases of research work, which we found
    through the Papers With Code website. Throughout this book, you would have seen
    a lot of R code using various packages for each stage of the machine learning
    workflow. The work done by the researchers of mlr and OpenML is now packaged in
    R, and in particular, OpenML is a complete platform. We will learn how to leverage
    the mlr and OpenML platforms to produce the best machine learning model, beyond
    just the quickstart **Hello World** examples. For reference, review the following
    table:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下表将突出五个研究成果案例，这些案例是通过 Papers With Code 网站找到的。在整个书中，你已经看到了很多用于机器学习工作流程各个阶段的 R
    代码和不同包。mlr 和 OpenML 研究人员的工作现在已打包在 R 中，特别是 OpenML 是一个完整的平台。我们将学习如何利用 mlr 和 OpenML
    平台来制作最佳的机器学习模型，而不仅仅是快速入门的 **Hello World** 示例。为了参考，请查看以下表格：
- en: '![Figure 9.1: Research papers used in this lesson for demonstration (Part 1)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.1：本课程演示中使用的论文（第一部分）]'
- en: '](img/C12624_09_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C12624_09_01.jpg)'
- en: 'Figure 9.1: Research papers used in this chapter for demonstration (Part 1)'
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9.1：本章演示中使用的论文（第一部分）
- en: '![Figure 9.2: Research papers used in this lesson for demonstration (Part 2)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.2：本课程演示中使用的论文（第二部分）]'
- en: '](img/C12624_09_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C12624_09_02.jpg)'
- en: 'Figure 9.2: Research papers used in this chapter for demonstration (Part 2)'
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9.2：本章演示中使用的论文（第二部分）
- en: The mlr Package
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mlr 包
- en: Now, we shall go into learning how the mlr package offers a complete framework
    to work with many machine learning models and problem. Often, in many ML projects,
    one has to manage an overwhelming amount of detailing around numerous experiments
    (also called **trial-and-error iterations**). Each experiment consists of many
    pieces of training using different machine learning algorithms, performance measures,
    hyperparameters, resampling techniques and predictions. Unless we do not systematically
    analyze the information obtained in each experiment, we will not be able to come
    out with the best combination of parameter values.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习 mlr 包如何提供一个完整的框架来处理许多机器学习模型和问题。在许多机器学习项目中，人们往往需要管理大量围绕众多实验的细节（也称为**试错迭代**）。每个实验都包含使用不同机器学习算法、性能指标、超参数、重采样技术和预测的大量训练。除非我们系统地分析每个实验中获得的信息，否则我们无法得出最佳参数值组合。
- en: 'Another advantage of using the mlr package comes from its rich collection of
    machine learning algorithms from various packages. We do not have to install multiple
    packages for different implementation of the machine learning algorithm anymore.
    Instead, mlr offers everything in one place. To understand this better, refer
    to the following table:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用mlr包的另一个优点来自于其丰富的机器学习算法集合，来自各种包。我们不再需要为机器学习算法的不同实现安装多个包。相反，mlr在一个地方提供了一切。为了更好地理解这一点，请参考以下表格：
- en: '![Figure 9.3: The mlr Package (Part 1)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：mlr包（第一部分）
- en: '](img/C12624_09_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C12624_09_03.jpg)'
- en: 'Figure 9.3: The mlr Package (Part 1)'
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.3：mlr包（第一部分）
- en: '**Multilabel Classification Algorithms**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**多标签分类算法**'
- en: The following models are available in the mlr package for multilabel classification,
    where one observation could be assigned to more than one class. These models are
    useful in solving many useful problems, such as, in Netflix, you will see that
    each movie could be tagged as Action, Adventure and Fantasy. Alternatively, in
    YouTube, where millions of videos are posted every day, an automatic algorithm
    could tag the videos into multiple class and hence help in content filtering and
    better search.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: mlr包中提供了以下多标签分类模型，其中单个观测值可以分配给多个类别。这些模型在解决许多有用的问题中很有用，例如，在Netflix上，你会看到每部电影都可以被标记为动作、冒险和奇幻。或者，在YouTube上，每天都有数百万个视频被发布，一个自动算法可以将视频标记为多个类别，从而帮助内容过滤和更好的搜索。
- en: 'We will use these algorithms along with the classifiers defined in the previous
    table:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些算法以及前表中定义的分类器：
- en: '![Figure 9.4: Multilabel classification with the mlr package'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4：使用mlr包进行多标签分类]'
- en: '](img/C12624_09_04.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C12624_09_04.jpg)'
- en: 'Figure 9.4: Multilabel classification with the mlr package'
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.4：使用mlr包进行多标签分类
- en: OpenML Package
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenML包
- en: OpenML, a collaboration platform through which researchers from academia and
    industry can automatically share, organize, and deliberate machine learning experiments,
    data, algorithms, and flows. The platform brings efficient collaboration and results
    in reproducibility.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: OpenML，一个学术和工业研究人员可以通过它自动共享、组织和审议机器学习实验、数据、算法和流程的合作平台。该平台带来了高效的协作，并实现了可重复性。
- en: The OpenML package in R comes with various features that allow users to search,
    upload, and download the datasets and perform Machine Learning related operations.
    A user can upload the output of ML experiments, share them with other users, and
    download the output results. This enhances the reproducibility of work, speeds
    up the research work, and brings people from different domains together.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: R中的OpenML包包含各种功能，允许用户搜索、上传和下载数据集，并执行与机器学习相关的操作。用户可以上传机器学习实验的输出，与其他用户分享，并下载输出结果。这增强了工作的可重复性，加快了研究工作，并将来自不同领域的人们聚集在一起。
- en: Problem Design from the Research Paper
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 研究论文中的问题设计
- en: 'In this chapter, we will understand, analyze, and reproduce the results from
    the *Learning multi-label scene classification* paper. We will effectively use
    the mlr and OpenML packages to reproduce the result. Before that, let’s write
    the **Situation-Complication-Question** from the paper using the **SCQ framework**:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将理解、分析和重现《学习多标签场景分类》论文的结果。我们将有效地使用mlr和OpenML包来重现结果。在此之前，让我们使用**SCQ框架**来编写论文中的**情况-复杂性-问题**：
- en: '![Figure 9.5: SCQ from the paper Learning multi-label scene classification'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5：来自论文《学习多标签场景分类》的SCQ]'
- en: '](img/C12624_09_05.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C12624_09_05.jpg)'
- en: 'Figure 9.5: SCQ from the paper Learning multi-label scene classification'
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.5：来自论文《学习多标签场景分类》的SCQ
- en: Features in Scene Dataset
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景数据集功能
- en: 'The paper uses the `scene` dataset for semantic scene classification task.
    The dataset is a collection of images of natural scenes, where a natural scene
    may contain multiple objects, such that multiple class labels can describe the
    scene. For example, a field scene with a mountain in the background. From the
    paper, we have taken the first figure, which shows two images that are multilabel
    images depicting two different scenes in a single image. *Figure 9.6* is a beach
    and urban scene, whereas *Figure 9.7* shows mountains:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 论文使用了`scene`数据集进行语义场景分类任务。该数据集是自然场景图像的集合，其中自然场景可能包含多个对象，因此多个类别标签可以描述场景。例如，背景有山的田野场景。从论文中，我们选取了第一张图，它显示了两个图像，这两个图像是多标签图像，描述了单个图像中的两个不同场景。*图9.6*是海滩和城市场景，而*图9.7*展示了山脉：
- en: '![Figure 9.6: A beach and urban scene.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6：海滩和城市场景。'
- en: '](img/C12624_09_06.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C12624_09_06.jpg]'
- en: 'Figure 9.6: A beach and urban scene.'
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.6：海滩和城市场景。
- en: '![Figure 9.7: A mountains scene.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7：山脉场景。'
- en: '](img/C12624_09_07.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C12624_09_07.jpg]'
- en: 'Figure 9.7: A mountains scene.'
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.7：山脉场景。
- en: 'From the given images, we could use the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从给定的图像中，我们可以使用以下内容：
- en: '**Color information**: This information is useful when differentiating between
    certain types of outdoor scenes.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色信息**：当区分某些类型的户外场景时，这种信息很有用。'
- en: '**Spatial information**: This information is useful in various cases. For example,
    light, warm colors at the top of the image may correspond to sunrise.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空间信息**：这种信息在许多情况下都很有用。例如，图像顶部的光、暖色调可能对应日出。'
- en: The paper uses *CIE L*U*V**, such as space, denoted as Luv. Luv space proposes
    the anticipated perceptual uniformity. After adaptation (a mathematical transformation
    from the XYZ space to the *L*U*V* space) to Luv spaces, the image is divided into
    49 blocks using a 7 x 7 grid. Then, the authors calculate the first and second
    moment (mean and variance) of each band (RGB), which corresponds to a low-resolution
    image and to computationally low-cost quality features, respectively. In total,
    we obtain *49 x 2 x 3 = 294* features vector per image.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 论文使用*CIE L*U*V*，如空间，表示为Luv。Luv空间提出了预期的感知均匀性。在将XYZ空间适应到Luv空间（一种从XYZ空间到*L*U*V*空间的数学转换）之后，图像被一个7
    x 7网格分成49个块。然后，作者计算每个波段（RGB）的第一和第二矩（均值和方差），这分别对应于低分辨率图像和计算成本较低的质量特征。总共，我们为每张图像获得*49
    x 2 x 3 = 294*个特征向量。
- en: The remaining six columns in the dataset correspond to the six labels represented
    in a true/false encoded value. If an image belongs to two classes, the respective
    column will have true value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集中的剩余六列对应于用真/假编码值表示的六个标签。如果一个图像属于两个类别，相应的列将具有真值。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In colorimetry, the CIE 1976 L*, u*, v* color space, was adopted by the **International
    Commission on Illumination** (**CIE**) in 1976, as a simple-to-compute transformation
    of the 1931 CIE XYZ color space, but which attempted perceptual uniformity, which
    is the difference or distance between two colors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在比色法中，国际照明委员会（**CIE**）于1976年采用了CIE 1976 L*、u*、v*颜色空间，作为1931 CIE XYZ颜色空间的一个简单计算转换，但试图实现感知均匀性，即两种颜色之间的差异或距离。
- en: Implementing Multilabel Classifier Using the mlr and OpenML Packages
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用mlr和OpenML包实现多标签分类器
- en: We will now see how to train a multilabel classifier using the mlr and OpenML
    packages. First, we will download the scene dataset from OpenML.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将了解如何使用mlr和OpenML包训练多标签分类器。首先，我们将从OpenML下载场景数据集。
- en: 'Exercise 102: Downloading the Scene Dataset from OpenML'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习102：从OpenML下载场景数据集
- en: In this exercise, we will download the scene dataset and set it up for further
    analysis.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将下载场景数据集并为其进一步分析做准备。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 完成练习的以下步骤：
- en: 'In order to download the scene dataset through OpenML API, first create an
    account in the OpenML website at [https://www.openml.org/register](https://www.openml.org/register).
    The registration process involves verifying your email address, post which you
    will get the access to the API keys.![Figure 9.8: The OpenML registration page.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了通过OpenML API下载场景数据集，首先在[https://www.openml.org/register](https://www.openml.org/register)网站上创建一个账户。注册过程涉及验证您的电子邮件地址，之后您将获得访问API密钥的权限。![图9.8：OpenML注册页面。
- en: '](img/C12624_09_08.jpg)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C12624_09_08.jpg]'
- en: 'Figure 9.8: The OpenML registration page.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.8：OpenML注册页面。
- en: After logging in to your account, navigate to your account and select the API
    AUTHENTICATION option.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录您的账户后，转到您的账户并选择API认证选项。
- en: On the API Authentication page, select and copy-paste the API key from the API
    key section. The authors of the Multilabel Classification with R Package mlr paper
    uploaded a bunch of datasets with a 2016_multilabel_r_benchmark_paper tag, which
    we can now download from OpenML and start reproducing their results. We will specifically
    use the scene dataset (with ID 40595).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在API认证页面，从API密钥部分选择并复制粘贴API密钥。Multilabel Classification with R Package mlr论文的作者上传了一组带有2016_multilabel_r_benchmark_paper标签的数据集，我们现在可以从OpenML下载并开始重现他们的结果。我们将特别使用场景数据集（ID为40595）。
- en: Open RStudio and install all the required packages before proceeding.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，打开RStudio并安装所有必需的包。
- en: 'Import the required packages and libraries:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的包和库：
- en: '[PRE0]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use the API key from the OpenML and register the API key using the following
    command:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用来自OpenML的API密钥，并使用以下命令注册API密钥：
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output is as follows:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE2]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use the following command to download the dataset from the source:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从源下载数据集：
- en: '[PRE3]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we will use the ID 40595 to get the scene dataset:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用ID 40595获取场景数据集：
- en: '[PRE5]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Ensure that you install the farff package before proceeding with the previous
    two commands.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在执行前两个命令之前，请确保您已安装farff包。
- en: 'Create the DataFrame using the following command:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建DataFrame：
- en: '[PRE6]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 9.9: Environment setting of the scene.task variable.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9：场景.task变量的环境设置](img/C12624_09_09.jpg)'
- en: '](img/C12624_09_09.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9：场景.task变量的环境设置](img/C12624_09_09.jpg)'
- en: 'Figure 9.9: Environment setting of the scene.task variable.'
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.9：场景.task变量的环境设置
- en: In this exercise, we registered an account in OpenML and obtained an API key.
    Using the API key, we were able to download the scene dataset, which has a 2016_multilabel_r_benchmark_paper
    tag in OpenML. Finally, we converted the dataset into data frame. OpenML provides
    many such features to collaborate. One can share their code, experiments, and
    flow with a larger community by assigning a tag.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们在OpenML上注册了一个账户并获取了一个API密钥。使用该API密钥，我们能够下载具有OpenML中2016_multilabel_r_benchmark_paper标签的场景数据集。最后，我们将数据集转换为数据框。OpenML提供了许多这样的功能以促进协作。通过分配标签，人们可以与更大的社区分享他们的代码、实验和流程。
- en: Constructing a Learner
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建学习器
- en: A **learner** is a machine learning algorithm implementation in the mlr package.
    As highlighted in the previous section on the mlr package, there is a rich collection
    of such learner functions in mlr.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习器**是mlr包中机器学习算法的实现。如前文所述的mlr包部分所强调，mlr中有一个丰富的学习器函数集合。'
- en: 'For our scene classification problem, the mlr package offers building a multilabel
    classification model in two possible ways:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的场景分类问题，mlr包提供了两种可能的方式来构建多标签分类模型：
- en: '**Adaptation method**: In this, we adapt an explicit algorithm on the entire
    problem.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应方法**：在这种情况下，我们在整个问题上适应一个显式算法。'
- en: '**Transformation method**: We transform the problem into a simple binary classification
    problem and then apply the available algorithm for the binary classification.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换方法**：我们将问题转换为一个简单的二元分类问题，然后应用可用的二元分类算法。'
- en: Adaptation Methods
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适应方法
- en: The mlr package in R offers two algorithm adaption methods. First, the multivariate
    random forest algorithm that comes from the `randomForestSRC` package, and second,
    the random ferns multilabel algorithm built in the `rFerns` package.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: R中的mlr包提供了两种算法适应方法。首先，来自`randomForestSRC`包的多变量随机森林算法，其次，内置在`rFerns`包中的随机森林多标签算法。
- en: 'The `makeLearner()` function in mlr creates the model object for the `rFerns`
    and `randomForestSRC` algorithms, as shown in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: mlr中的`makeLearner()`函数创建了`rFerns`和`randomForestSRC`算法的模型对象，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows, which shows the information such as name and predict-type
    about the multilable.rFerns model:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下，显示了关于多标签.rFerns模型的信息，如名称和预测类型：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Ensure that you install the *rFerns* and *randomForestSRC* packages before proceeding
    with the previous two commands.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行前两个命令之前，请确保您已安装*rFerns*和*randomForestSRC*包。
- en: Transformation Methods
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换方法
- en: The second method for constructing a learner is to use the `makeLearner()` function,
    and then any one of the five wrapper functions (described in the following section)
    could be utilized for problem transformation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 构建学习器的第二种方法是使用`makeLearner()`函数，然后可以使用以下章节中描述的五个包装函数中的任何一个来进行问题转换。
- en: Binary Relevance Method
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二元相关方法
- en: In multilabel classification problems, each label could be transformed as a
    binary classification problem. In the process, any one observation could have
    multiple labels assigned to it. In the mlr package, the `makeMultilabelBinaryRelevanceWrapper()`
    method converts the binary learner method to a wrapped Binary Relevance multilabel
    learner.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在多标签分类问题中，每个标签都可以被转换为一个二元分类问题。在这个过程中，任何一个观测值都可能被分配多个标签。在mlr包中，`makeMultilabelBinaryRelevanceWrapper()`方法将二元学习器方法转换为包装的二元相关多标签学习器。
- en: Classifier Chains Method
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分类链方法
- en: The classifier chain wrapper method implements a multilabel model, where the
    binary classifiers are arranged into a chain. Each model comes out with a prediction
    in the order specified by the chain. The model uses all the features in the given
    dataset, along with all the predictions of the model that are before in the chain.
    The `makeMultilabelClassifierChainsWrapper()` method in mlr is used to create
    the classifier chain wrappers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 分类链包装器方法实现了一个多标签模型，其中二元分类器被排列成链。每个模型按照链中指定的顺序输出预测。该模型使用给定数据集中的所有特征，以及链中之前模型的全部预测。mlr中的`makeMultilabelClassifierChainsWrapper()`方法用于创建分类链包装器。
- en: Nested Stacking
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套堆叠
- en: Like classifier chain, however, the class (or label) of the observation are
    not the actual class but are based on estimations of the class obtained by the
    trained model (learner) from the previous model in the chain. The `makeMultilabelNestedStackingWrapper()`
    method in the mlr package is used to create the nested stacking wrappers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与分类链类似，观察到的类别（或标签）不是实际类别，而是基于从链中前一个模型（学习器）获得的类别估计。mlr包中的`makeMultilabelNestedStackingWrapper()`方法用于创建嵌套堆叠包装器。
- en: Dependent Binary Relevance Method
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖二分类相关性方法
- en: The `makeMultilabelDBRWrapper` method in the mlr package is used to create the
    dependent Binary Relevance wrappers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: mlr包中的`makeMultilabelDBRWrapper`方法用于创建依赖二分类相关性包装器。
- en: Stacking
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆叠
- en: Like the dependent Binary Relevance method, however, in the training phase,
    the labels used as input for each label are obtained by the Binary Relevance method
    instead of using the actual labels. The `makeMultilabelStackingWrapper` method
    in the mlr package is used to create the stacking wrappers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与依赖二分类相关性方法类似，在训练阶段，用作每个标签输入的标签是通过二分类方法获得的，而不是使用实际标签。mlr包中的`makeMultilabelStackingWrapper`方法用于创建堆叠包装器。
- en: In the following exercise, we will see how to generate decision tree model using
    the `classif.rpart` method.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将看到如何使用`classif.rpart`方法生成决策树模型。
- en: 'Exercise 103: Generating Decision Tree Model Using the classif.rpart Method'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习103：使用classif.rpart方法生成决策树模型
- en: In this exercise, we will generate the decision tree model using the `classif.rpart`
    method and then transform it using *Binary Relevance* and nested *Stacking* wrappers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`classif.rpart`方法生成决策树模型，然后使用*二分类*和嵌套*堆叠*包装器进行转换。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'First, use the `makeLearner` method to create the object for `classif.rpart`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用`makeLearner`方法创建`classif.rpart`的对象：
- en: '[PRE9]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, create the stacking wrappers using the `makeMultilabelBinaryRelevanceWrapper`
    method:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`makeMultilabelBinaryRelevanceWrapper`方法创建堆叠包装器：
- en: '[PRE10]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, print the model:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打印模型：
- en: '[PRE11]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE12]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Print the stacking wrappers, as illustrated here:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印堆叠包装器，如图所示：
- en: '[PRE13]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of the previous command is as follows, which shows the information
    such as the type of model, properties available as part of the model output, and
    the predict-type:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下命令的输出如下，显示了模型类型、作为模型输出一部分的属性以及预测类型：
- en: '[PRE14]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Train the Model
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 训练模型
- en: We can train a model as usual with a multilabel learner and a multilabel task
    as input; use the `multilabel.lrn1` object.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多标签学习者和多标签任务作为输入，像通常一样训练模型；使用`multilabel.lrn1`对象。
- en: 'Exercise 104: Train the Model'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习104：训练模型
- en: In this exercise, we will first randomly split the data into train and test
    datasets and then train the model using the `tain()` function from mlr package
    and the `multilabel.lrn1` object defined in the previous section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们首先将数据随机分为训练集和测试集，然后使用mlr包中的`train()`函数和前一小节中定义的`multilabel.lrn1`对象来训练模型。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'Use the following command to train, predict, and evaluate the dataset:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令进行训练、预测和评估数据集：
- en: '[PRE15]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create the `test_index variable` using the following command:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建`test_index变量`：
- en: '[PRE16]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use the `train` function, which takes model object `multilabel.lrn1` (`scene.task`
    with only randomly selected `train_index` to train the model:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`train`函数，该函数接受模型对象`multilabel.lrn1`（仅包含随机选择的`train_index`的`scene.task`）来训练模型：
- en: '[PRE17]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE18]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `scene_classi_mod` model using the `1684` randomly chosen observations from
    `scene` dataset is trained using the `rpart` package in R, which is an implementation
    of the **Classification and Regression Tree** (**CART**) algorithm in machine
    learning wrapped with the Binary Relevance method for multilabel classification.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用R中的`rpart`包训练的`scene_classi_mod`模型，使用了从`scene`数据集中随机选择的`1684`个观测值，它是机器学习中**分类和回归树**（**CART**）算法的实现，并包装了二值相关方法进行多标签分类。
- en: Predicting the Output
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预测输出
- en: 'Prediction can be done as usual in mlr with the `predict` function. The input
    arguments are trained models; the scene.task dataset is assigned to the `task`
    and `test_index` arguments, which correspond to the `test` dataset is assigned
    to the `subset` argument:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在mlr中，可以使用`predict`函数进行预测。输入参数是训练模型；将`scene.task`数据集分配给`task`和`test_index`参数，它们对应于分配给`subset`参数的测试数据集：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Performance of the Model
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型性能
- en: 'In order assess the performance of the prediction, the mlr package offers the
    `performance()` function, which takes as an input the prediction of the model
    along with all the measures we would like to compute. All available measures for
    multilabel classification can be listed by `listMeasures()`. As per the paper,
    we use measures such as `hamloss`, `f1`, `subset01`, `acc`, `tpr`, and `ppv` on
    our predictions:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估预测的性能，mlr包提供了`performance()`函数，该函数接受模型的预测作为输入，以及我们想要计算的所有度量。所有可用的多标签分类度量可以通过`listMeasures()`列出。根据论文，我们在预测上使用了`hamloss`、`f1`、`subset01`、`acc`、`tpr`和`ppv`等度量：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of the previous command is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上一条命令的输出如下：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following command will list down all the measures available for multilabel
    classification problem:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将列出所有可用的多标签分类问题度量：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Resampling the Data
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据重采样
- en: 'For evaluating the complete performance of the learning algorithm, we can do
    some resampling. To define a resampling strategy, either use `makeResampleDesc()`
    or `makeResampleInstance()`. After that, run the `resample()` function. Use the
    following default measure to calculate the hamming loss:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估学习算法的完整性能，我们可以进行一些重采样。为了定义重采样策略，可以使用`makeResampleDesc()`或`makeResampleInstance()`。之后，运行`resample()`函数。使用以下默认度量来计算汉明损失：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Binary Performance for Each Label
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个标签的二进制性能
- en: 'We can calculate a binary performance measure, for example, the accuracy, or
    the `auc` for each label, the `getMultilabelBinaryPerformances()` function is
    useful. We can apply this function to any multilabel prediction, for example,
    also on the resampled multilabel prediction. For calculating `auc`, we need predicted
    probabilities:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算每个标签的二进制性能度量，例如准确度或`auc`，`getMultilabelBinaryPerformances()`函数很有用。我们可以将此函数应用于任何多标签预测，例如，也可以应用于重采样的多标签预测。为了计算`auc`，我们需要预测概率：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Benchmarking Model
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基准测试模型
- en: In a benchmark experiment, different learning methods are applied to one or
    more than a few datasets with the purpose of comparing and ranking the algorithms
    concerning one or more performance measures. The `mlr()` method offers a very
    robust framework to conduct such experiments and helps in keeping track of all
    the results of the experiment to compare.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在基准实验中，不同的学习方法被应用于一个或多个数据集，目的是比较和排名算法，根据一个或多个性能度量。`mlr()`方法提供了一个非常稳健的框架来执行此类实验，并有助于跟踪实验的所有结果以进行比较。
- en: Conducting Benchmark Experiments
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进行基准实验
- en: In our first experiment, we use the multilabel `randomForestSRC` and `rFerns`
    learners of the `mlr()` package and various measures to get our first benchmark.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个实验中，我们使用`mlr()`包中的多标签`randomForestSRC`和`rFerns`学习者和各种度量来获得我们的第一个基准。
- en: In the following exercise, we will explore how to conduct a benchmarking on
    various learners.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将探索如何对各种学习器进行基准测试。
- en: 'Exercise 105: Exploring How to Conduct a Benchmarking on Various Learners'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习105：探索如何在各种学习器上进行基准测试
- en: In this exercise, we will see how to conduct a benchmarking on various learners
    we created so far and compare the results to select the best learner (model) for
    the multilabel scene classification problem. This helps us organize all the results
    in a structured format to select the best performing model.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到如何对迄今为止创建的各种学习者进行基准测试，并将结果进行比较，以选择多标签场景分类问题的最佳学习者（模型）。这有助于我们将所有结果组织成结构化格式，以选择表现最佳的模式。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'First, list all learners using the following command:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令列出所有学习者：
- en: '[PRE28]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Conduct the benchmark experiment:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行基准实验：
- en: '[PRE29]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE30]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, execute the `bmr` object:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行`bmr`对象：
- en: '[PRE31]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Iterations of the model train will look something like the following for each
    learner:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模型的训练迭代将类似于以下每个学习者：
- en: '[PRE32]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following table demonstrates the mean of various measures on the test data:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下表展示了测试数据上各种度量的平均值：
- en: '![Figure 9.10: Mean of various measures on the test data.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.10：测试数据上各种度量的平均值。'
- en: '](img/C12624_09_10.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C12624_09_10.jpg)'
- en: 'Figure 9.10: Mean of various measures on the test data.'
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.10：测试数据上各种度量的平均值。
- en: This table shows that the `randomForestSRC` model does a slightly better job
    than `rFerns` on all the measures, primarily in the **hamloss mean measure**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此表显示，`randomForestSRC`模型在所有度量上比`rFerns`做得稍好，主要在**hamloss平均值度量**上。
- en: Accessing Benchmark Results
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问基准结果
- en: The `mlr()` method provides many `getBMR` functions to extract useful information
    such as performance, predictions, leaners, and many more from the benchmark experiment
    object.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`mlr()`方法提供了许多`getBMR`函数，可以从基准实验对象中提取有用的信息，如性能、预测、学习者等。'
- en: Learner Performances
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习者表现
- en: The `getBMRPerformances` function gives all values of all the measures defined
    in the benchmark in each iteration of the training. The following table lists
    the values for each measure using the `randomForestSRC` and `rFerns` learners.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBMRPerformances`函数给出了训练过程中每个迭代中基准中定义的所有度量的所有值。下表列出了使用`randomForestSRC`和`rFerns`学习者每个度量的值。'
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![Figure 9.11: Learner performances randomForestSRC'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.11：学习者的randomForestSRC表现'
- en: '](img/C12624_09_11.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C12624_09_11.jpg)'
- en: 'Figure 9.11: Learner performances randomForestSRC'
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.11：学习者的randomForestSRC表现
- en: '![Figure 9.12: Learner performances rFerns'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.12：学习者的rFerns表现'
- en: '](img/C12624_09_12.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C12624_09_12.jpg)'
- en: 'Figure 9.12: Learner performances rFerns'
  id: totrans-202
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.12：学习者的rFerns表现
- en: Predictions
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预测
- en: We could also get the predictions on the test dataset using the `getBMRPredictions`
    function. The two tables in this section show the actual and the predicted labels
    of a few images represented by the ID column. Observe that the predictions are
    not perfect, just as we would expect from the relatively low overall accuracy.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`getBMRPredictions`函数在测试数据集上获取预测。本节中的两个表格显示了ID列表示的几个图像的实际和预测标签。观察发现，预测并不完美，正如我们预期的那样，整体准确率相对较低。
- en: '**Predictions using randomForestSRC**:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用randomForestSRC进行预测**：'
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![Figure 9.13: The actual labels.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13：实际标签。'
- en: '](img/C12624_09_13.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C12624_09_13.jpg)'
- en: 'Figure 9.13: The actual labels.'
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.13：实际标签。
- en: '![Figure 9.14: The predicted labels.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14：预测标签。'
- en: '](img/C12624_09_14.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C12624_09_14.jpg)'
- en: 'Figure 9.14: The predicted labels.'
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.14：预测标签。
- en: Learners and measures
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习者和度量
- en: 'The `getBMRLearners` function gives details about the learners used in the
    benchmark. Information such as hyperparameter and predict-type could be obtained
    using this function. Similarly, the `getBMRMeasures` function provides details
    such as best about the performance measures. The following table shows the details
    about the measures we used in our benchmark experiment:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBMRLearners`函数提供了关于基准中使用的学习者的详细信息。可以使用此函数获取有关超参数和预测类型等信息。同样，`getBMRMeasures`函数提供了有关性能度量的详细信息。下表显示了我们在基准实验中使用的度量的详细信息：'
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the `getBMRMeasures(bmr)` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`getBMRMeasures(bmr)`函数：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Figure 9.15: Learners and measures (part 1).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15：学习者和度量（第一部分）。'
- en: '](img/C12624_09_15.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C12624_09_15.jpg)'
- en: 'Figure 9.15: Learners and measures (part 1).'
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.15：学习者和度量（第一部分）。
- en: 'Figures 15 and 16 summarize the result of the `getBMRMeasures(bmr)` command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图15和16总结了`getBMRMeasures(bmr)`命令的结果：
- en: '![Figure 9.16: Learners and measures (part 2).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.16：学习者和度量（第二部分）。'
- en: '](img/C12624_09_16.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C12624_09_16.jpg)'
- en: 'Figure 9.16: Learners and measures (part 2).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16：学习者和度量（第二部分）。
- en: Merging Benchmark Results
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 合并基准结果
- en: Often, we run multiple experiments and would like to see all the benchmarks
    coming from the experiments into one consolidated list of values to compare the
    results. The `mergeBenchmarkResults` function helps in combining the results.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会运行多个实验，并希望将所有实验的基准结果汇总到一个列表中，以便比较结果。`mergeBenchmarkResults` 函数有助于合并结果。
- en: 'Here’s the benchmark:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是基准：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![Figure 9.17: Merging benchmark results.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.17：合并基准结果。](img/C12624_09_17.jpg)'
- en: '](img/C12624_09_17.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C12624_09_17.jpg](img/C12624_09_17.jpg)'
- en: 'Figure 9.17: Merging benchmark results.'
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9.17：合并基准结果。
- en: Clearly, using `classif.randomForest` with the classifier chain wrapper produces
    the highest accuracy and performs well in all the other measures as well.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用 `classif.randomForest` 与分类器链包装器产生最高的准确率，并在其他所有指标上也表现良好。
- en: 'Activity 14: Getting the Binary Performance Step with classif.C50 Learner Instead
    of classif.rpart'
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动十四：使用 classif.C50 学习者而不是 classif.rpart 获取二进制性能步骤
- en: In this activity, we will revisit the entire process flow of building a model,
    in which we will use the `makeLearner` function to specify the `rpart` model,
    replacing `C50`. Specifically, we will rerun the entire machine learning flow,
    starting from the problem transformation step to getting the binary performance
    step with the classif.C50 learner instead of `classif.rpart`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将回顾构建模型的整个流程，我们将使用 `makeLearner` 函数指定 `rpart` 模型，替换 `C50`。具体来说，我们将重新运行整个机器学习流程，从问题转换步骤到使用
    classif.C50 学习者而不是 `classif.rpart` 的二进制性能步骤。
- en: 'Perform the following steps to complete the activity:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成活动：
- en: Define the algorithm adaptation methods.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义算法自适应方法。
- en: Use the problem transformation method, and change the `classif.rpart` learner
    to `classif.C50`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用问题转换方法，并将 `classif.rpart` 学习者更改为 `classif.C50`。
- en: Note
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You need to install the `C50` package for this code to work.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使此代码正常工作，你需要安装 `C50` 包。
- en: Print the learner details.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印学习者的详细信息。
- en: Print the multilabel learner details.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印多标签学习者的详细信息。
- en: Train the model using the same dataset with training dataset.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用训练数据集训练模型。
- en: Print the model details.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印模型详细信息。
- en: Predict the output using the C50 model we created earlier on the test dataset.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们之前创建的 C50 模型在测试数据集上预测输出。
- en: Print the performance measures.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印性能指标。
- en: Print the performance measures for the `listMeasures` variable.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印 `listMeasures` 变量的性能指标。
- en: Run the resampling with the cross validation method.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用交叉验证方法进行重采样。
- en: Print the binary performance.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印二进制性能。
- en: 'Once you complete the activity, you should see the following output:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成活动，你应该看到以下输出：
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 466.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第 466 页找到。
- en: Working with OpenML Upload Functions
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 OpenML 上传函数工作
- en: 'In order to improve collaboration and version control the experiments, we can
    upload the flows we create into OpenML using the `uploadOMLFlow` function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高实验的协作和版本控制，我们可以使用 `uploadOMLFlow` 函数将我们创建的流程上传到 OpenML：
- en: '[PRE40]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output is as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE41]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We encourage students to explore the OpenML platform to find many more such
    functionalities, as the platform helps researchers all around the world to collaborate
    and share their work, making good work spread fast and help build the best model
    with the collective wisdom of researchers.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励学生探索 OpenML 平台，以找到更多此类功能，因为这个平台帮助全球的研究人员协作和分享他们的工作，使优秀的工作快速传播，并帮助利用研究人员的集体智慧构建最佳模型。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used the mlr and OpenML packages from R to build an entire
    machine learning workflow for solving a multilabel semantic scene classification
    problem. The mlr package offered a rich collection of machine learning algorithms
    and evaluation measures that helped us in quick implementation and facilitated
    a faster experimentation process to get the best model for the problem. The package
    also offered many wrapper functions to handle the multilabel problem. Building
    real-world machine learning models using a robust framework such as the one in
    mlr helps in speeding the implementation and provides a structure to the complete
    project. Further, using OpenML, we could reproduce a research work using the already
    available dataset and code, and then modify it according to our need. Such a platform
    offers the ability to collaborate at scale with researchers all over the world.
    At the end, we could also upload our own machine learning flows with others for
    them to pick it up from where we left.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了R语言的mlr和OpenML包来构建一个完整的机器学习工作流程，用于解决多标签语义场景分类问题。mlr包提供了一系列丰富的机器学习算法和评估度量，这有助于我们快速实施，并加速了实验过程，以便为问题找到最佳模型。该包还提供了许多包装函数来处理多标签问题。使用像mlr这样的强大框架构建现实世界的机器学习模型有助于加快实施速度，并为整个项目提供结构。此外，使用OpenML，我们可以使用现有的数据集和代码重现研究工作，并根据我们的需求进行修改。这样的平台能够与世界各地的研究人员进行大规模合作。最后，我们还可以上传自己的机器学习流程供他人使用，以便他们从我们停止的地方继续。
- en: In this book, our focus was to teach supervised learning in R programming language.
    Supervised learning is a class of algorithms where we are provided with labeled
    observation of data. Exploratory Data Analysis (EDA) methods help in understanding
    the dataset well, and the SCQ framework is used to design the problem precisely.
    The features are chosen on the basis of the problem design and an appropriate
    supervised learning model is selected after many rounds of experiments and evaluation.
    We then learned how to deploy machine learning models in production environment,
    which could be used by an application team in a business. Also, in cases where
    the dataset has hundreds of features, we used feature reduction and selection
    techniques.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们的重点是教授使用R编程语言进行监督学习。监督学习是一类算法，其中我们提供了数据的有标签观测。探索性数据分析（EDA）方法有助于深入了解数据集，而SCQ框架用于精确设计问题。特征的选择基于问题设计，并在多次实验和评估后选择合适的监督学习模型。然后我们学习了如何在生产环境中部署机器学习模型，这些模型可以被业务中的应用团队使用。此外，在数据集有数百个特征的情况下，我们使用了特征降维和选择技术。
- en: We would like to emphasize that in any machine learning project, beyond a certain
    point (could be defined such as 3 months of effort from the start of project or
    100 trial runs with different combinations), we should stop and ask whether or
    not what we have done so far could be deployed in a production environment. If
    the answer is yes, deploy it and keep monitoring the response for any abnormality
    and improvements. If it’s a no, go back to the drawing boards and start over (obviously
    if such a luxury is given). Machine learning in stages such as hyperparameter
    fine-tuning and model selection is an art. A lot of trial-and-error experiments
    are required to come out with the best model.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想强调的是，在任何机器学习项目中，超过一定阶段（可能是从项目开始算起3个月的努力或100次不同组合的尝试），我们应该停下来思考我们到目前为止所做的工作是否可以部署到生产环境中。如果答案是肯定的，那么部署它并持续监控任何异常和改进。如果答案是否定的，那么就回到起点重新开始（显然，如果这种奢侈是允许的）。在超参数微调和模型选择等阶段进行机器学习是一种艺术。需要大量的试错实验才能得出最佳模型。
