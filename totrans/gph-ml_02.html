<html><head></head><body>
		<div id="_idContainer103">
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Chapter 1: Getting Started with Graphs</h1>
			<p>Graphs<a id="_idIndexMarker000"/> are mathematical structures that are used for describing relations between entities and are used almost everywhere. For example, social networks are graphs, where users are connected depending on whether one user "<em class="italic">follows</em>" the updates of another user. They can be used for representing maps, where cities are linked through streets. Graphs can describe biological structures, web pages, and even the progression of neurodegenerative diseases.</p>
			<p><strong class="bold">Graph theory</strong>, the <a id="_idIndexMarker001"/>study of graphs, has received major interest for years, leading people to develop algorithms, identify properties, and define mathematical models to better understand complex behaviors.</p>
			<p>This chapter will review some of the concepts behind graph-structured data. Theoretical notions will be presented, together with examples to help you understand some of the more general concepts and put them into practice. In this chapter, we will introduce and use some of the most widely used libraries for the creation, manipulation, and study of the structure dynamics and functions of complex networks, specifically looking at the Python <strong class="source-inline">networkx</strong> library<a id="_idTextAnchor015"/>.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Introduction to graphs with <strong class="source-inline">networkx</strong></li>
				<li>Plotting graphs</li>
				<li>Graph properties</li>
				<li>Benchmarks and repositories</li>
				<li>Dealing with large graphs</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>We will be using Jupyter Notebooks with <em class="italic">Python 3.8</em> for all of our exercises. In the following code snippet, we show a list of Python libraries that will be installed for this chapter using <strong class="source-inline">pip</strong> (for example, run <strong class="source-inline">pip install networkx==2.5</strong> on the command line, and so on):</p>
			<p class="source-code">Jupyter==1.0.0</p>
			<p class="source-code">networkx==2.5</p>
			<p class="source-code">snap-stanford==5.0.0</p>
			<p class="source-code">matplotlib==3.2.2</p>
			<p class="source-code">pandas==1.1.3</p>
			<p class="source-code">scipy==1.6.2</p>
			<p>In this book, the following Python commands will be referred to:</p>
			<ul>
				<li><strong class="source-inline">import networkx as nx</strong></li>
				<li><strong class="source-inline">import pandas as pd</strong></li>
				<li><strong class="source-inline">import numpy as np</strong></li>
			</ul>
			<p>For more complex data visualization tasks, Gephi (<a href="https://gephi.org/">https://gephi.org/</a>) is also required. The installation manual is available here: <a href="https://gephi.org/users/install/">https://gephi.org/users/install/</a>. All code files relevant to this chapter are available at <a href="https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter01">https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter01</a>.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Introduction to graphs with networkx</h1>
			<p>In this section, we will give a<a id="_idIndexMarker002"/> general introduction to graph theory. Moreover, in order to merge theoretical concepts with their practical implementation, we will enrich our <a id="_idIndexMarker003"/>explanation with code snippets in Python, using <strong class="source-inline">networkx</strong>. </p>
			<p>A <strong class="bold">simple undirected graph</strong> (or simply, a graph) <em class="italic">G</em> is defined as a couple <em class="italic">G=(V,E) </em>, where <em class="italic">V={</em><img src="image/Formula_01_001.png" alt=""/><em class="italic">, .., </em><img src="image/Formula_01_002.png" alt=""/><em class="italic">}</em> is a set of <a id="_idIndexMarker004"/>nodes (also<a id="_idIndexMarker005"/> called <strong class="bold">vertices</strong>) and <em class="italic">E={{</em><img src="image/Formula_01_003.png" alt=""/><em class="italic">,</em><img src="image/Formula_01_004.png" alt=""/><em class="italic"> .., {</em><img src="image/Formula_01_005.png" alt=""/><em class="italic">,</em><img src="image/Formula_01_006.png" alt=""/><em class="italic">}}</em> is a set of two-sets (set of two elements) of edges (also <a id="_idIndexMarker006"/>called <strong class="bold">links</strong>), representing the connection between two nodes belonging to <em class="italic">V</em>. </p>
			<p>It is important to underline that since each element of <em class="italic">E</em> is a two-set, there is no order between each edge. To provide more detail, <em class="italic">{</em><img src="image/Formula_01_007.png" alt=""/><em class="italic">,</em><img src="image/Formula_01_008.png" alt=""/>  and <em class="italic">{</em><img src="image/Formula_01_009.png" alt=""/><em class="italic">,</em><img src="image/Formula_01_010.png" alt=""/>  represent the same edge.</p>
			<p>We now provide<a id="_idIndexMarker007"/> definitions for some basic properties of graphs and nodes, as follows:</p>
			<ul>
				<li>The <strong class="bold">order</strong> of a graph is the number of its vertices <em class="italic">|V|</em>. The <strong class="bold">size</strong> of a graph is the number of its edges <em class="italic">|E|</em>.</li>
				<li>The <strong class="bold">degree</strong> of a <a id="_idIndexMarker008"/>vertex is the number of edges that are adjacent to it. The <strong class="bold">neighbors</strong> of a<a id="_idIndexMarker009"/> vertex <em class="italic">v</em> in a graph <em class="italic">G</em> is a subset of vertex <img src="image/Formula_01_011.png" alt=""/> induced by all vertices adjacent to <em class="italic">v</em>.</li>
				<li>The <strong class="bold">neighborhood graph</strong> (also known as an ego graph) of a vertex <em class="italic">v</em> in a graph <em class="italic">G</em> is a <a id="_idIndexMarker010"/>subgraph of <em class="italic">G</em>, composed of the vertices adjacent to <em class="italic">v</em> and all edges connecting vertices adjacent to <em class="italic">v</em>.</li>
			</ul>
			<p>An example of what a graph looks like can be seen in the following screenshot:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B16069_01_01.jpg" alt="Figure 1.1 – Example of a graph&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Example of a graph</p>
			<p>According to this<a id="_idIndexMarker011"/> representation, since there is no direction, an edge from <strong class="bold">Milan</strong> to <strong class="bold">Paris</strong> is equal to an edge from <strong class="bold">Paris</strong> to <strong class="bold">Milan</strong>. Thus, it is possible to move in the two directions without any constraint. If we analyze the properties of the graph depicted in <em class="italic">Figure 1.1</em>, we can see that it has <em class="italic">order</em> and <em class="italic">size</em> equal to <strong class="source-inline">4</strong> (there are, in total, four vertices and four edges). The <strong class="bold">Paris</strong> and <strong class="bold">Dublin</strong> vertices have degree <strong class="source-inline">2</strong>, <strong class="bold">Milan</strong> has degree <strong class="source-inline">3</strong>, and <strong class="bold">Rome</strong> has degree <strong class="source-inline">1</strong>. The neighbors for each node are shown in the following list:</p>
			<ul>
				<li><strong class="source-inline">Paris</strong> = {<strong class="source-inline">Milan</strong>, <strong class="source-inline">Dublin</strong>} </li>
				<li><strong class="source-inline">Milan</strong> = {<strong class="source-inline">Paris</strong>, <strong class="source-inline">Dublin</strong>, <strong class="source-inline">Rome</strong>}</li>
				<li><strong class="source-inline">Dublin</strong> = {<strong class="source-inline">Paris</strong>, <strong class="source-inline">Milan</strong>}  </li>
				<li><strong class="source-inline">Rome</strong> = {<strong class="source-inline">Milan</strong>}</li>
			</ul>
			<p>The same graph can be represented in <strong class="source-inline">networkx</strong>, as follows:</p>
			<p class="source-code">import networkx as nx</p>
			<p class="source-code">G = nx.Graph()</p>
			<p class="source-code">V = {'Dublin', 'Paris', 'Milan', 'Rome'}</p>
			<p class="source-code">E = [('Milan','Dublin'), ('Milan','Paris'), ('Paris','Dublin'), ('Milan','Rome')]</p>
			<p class="source-code">G.add_nodes_from(V)</p>
			<p class="source-code">G.add_edges_from(E)</p>
			<p>Since by<a id="_idIndexMarker012"/> default, the <strong class="source-inline">nx.Graph()</strong> command generates an undirected graph, we do not need to specify both directions of each edge. In <strong class="source-inline">networkx</strong>, nodes can be any hashable object: strings, classes, or even other <strong class="source-inline">networkx</strong> graphs. Let's now compute some properties of the graph we previously generated.</p>
			<p>All the nodes and edges of the graph can be obtained by running the following code:</p>
			<p class="source-code">print(f"V = {G.nodes}")</p>
			<p class="source-code">print(f"E = {G.edges}")</p>
			<p>Here is the output of the previous commands: </p>
			<p class="source-code">V = ['Rome', 'Dublin', 'Milan', 'Paris']</p>
			<p class="source-code">E = [('Rome', 'Milan'), ('Dublin', 'Milan'), ('Dublin', 'Paris'), ('Milan', 'Paris')]</p>
			<p>We can also compute the graph order, the graph size, and the degree and neighbors for each of the nodes, using the following commands:</p>
			<p class="source-code">print(f"Graph Order: {G.number_of_nodes()}")</p>
			<p class="source-code">print(f"Graph Size: {G.number_of_edges()}")</p>
			<p class="source-code">print(f"Degree for nodes: { {v: G.degree(v) for v in G.nodes} }")</p>
			<p class="source-code">print(f"Neighbors for nodes: { {v: list(G.neighbors(v)) for v in G.nodes} }") </p>
			<p>The result will be the following:</p>
			<p class="source-code">Graph Order: 4</p>
			<p class="source-code">Graph Size: 4</p>
			<p class="source-code">Degree for nodes: {'Rome': 1, 'Paris': 2, 'Dublin':2, 'Milan': 3}</p>
			<p class="source-code">Neighbors for nodes: {'Rome': ['Milan'], 'Paris': ['Milan', 'Dublin'], 'Dublin': ['Milan', 'Paris'], 'Milan': ['Dublin', 'Paris', 'Rome']}</p>
			<p>Finally, we can also compute an ego graph of a specific node for the graph <strong class="source-inline">G</strong>, as follows:</p>
			<p class="source-code">ego_graph_milan = nx.ego_graph(G, "Milan")</p>
			<p class="source-code">print(f"Nodes: {ego_graph_milan.nodes}")</p>
			<p class="source-code">print(f"Edges: {ego_graph_milan.edges}")</p>
			<p>The result <a id="_idIndexMarker013"/>will be the following:</p>
			<p class="source-code">Nodes: ['Paris', 'Milan', 'Dublin', 'Rome']</p>
			<p class="source-code">Edges: [('Paris', 'Milan'), ('Paris', 'Dublin'), ('Milan', 'Dublin'), ('Milan', 'Rome')]</p>
			<p>The original graph can be also modified by adding new nodes and/or edges, as follows:</p>
			<p class="source-code">#Add new nodes and edges</p>
			<p class="source-code">new_nodes = {'London', 'Madrid'}</p>
			<p class="source-code">new_edges = [('London','Rome'), ('Madrid','Paris')]</p>
			<p class="source-code">G.add_nodes_from(new_nodes)</p>
			<p class="source-code">G.add_edges_from(new_edges)</p>
			<p class="source-code">print(f"V = {G.nodes}")</p>
			<p class="source-code">print(f"E = {G.edges}")</p>
			<p>This would output the following lines:</p>
			<p class="source-code">V = ['Rome', 'Dublin', 'Milan', 'Paris', 'London', 'Madrid']</p>
			<p class="source-code">E = [('Rome', 'Milan'), ('Rome', 'London'), ('Dublin', 'Milan'), ('Dublin', 'Paris'), ('Milan', 'Paris'), ('Paris', 'Madrid')]</p>
			<p>Removal of nodes can be done by running the following code:</p>
			<p class="source-code">node_remove = {'London', 'Madrid'}</p>
			<p class="source-code">G.remove_nodes_from(node_remove)</p>
			<p class="source-code">print(f"V = {G.nodes}")</p>
			<p class="source-code">print(f"E = {G.edges}")</p>
			<p>This is the result of the preceding commands:</p>
			<p class="source-code">V = ['Rome', 'Dublin', 'Milan', 'Paris']</p>
			<p class="source-code">E = [('Rome', 'Milan'), ('Dublin', 'Milan'), ('Dublin', 'Paris'), ('Milan', 'Paris')]</p>
			<p>As expected, all the edges that contain the removed nodes are automatically deleted from the edge list.</p>
			<p>Also, edges can be removed by running the following code:</p>
			<p class="source-code">node_edges = [('Milan','Dublin'), ('Milan','Paris')]</p>
			<p class="source-code">G.remove_edges_from(node_edges)</p>
			<p class="source-code">print(f"V = {G.nodes}")</p>
			<p class="source-code">print(f"E = {G.edges}")</p>
			<p>The final <a id="_idIndexMarker014"/>result will be as follows:</p>
			<p class="source-code">V = ['Dublin', 'Paris', 'Milan', 'Rome']</p>
			<p class="source-code">E = [('Dublin', 'Paris'), ('Milan', 'Rome')]</p>
			<p>The <strong class="source-inline">networkx</strong> library also allows us to remove a single node or a single edge from a graph <strong class="source-inline">G</strong> by using the following commands: <strong class="source-inline">G. remove_node('Dublin')</strong> and <strong class="source-inline">G.remove_edge('Dublin', 'Paris')</strong>.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor018"/>Types of graphs</h2>
			<p>In the previous section, we <a id="_idIndexMarker015"/>described how to create and modify simple undirected graphs. Here, we will show how we can extend this basic data structure in order to encapsulate more information, thanks to the introduction of <strong class="bold">directed graphs</strong> (<strong class="bold">digraphs</strong>), weighted graphs, and multigraphs.</p>
			<h3>Digraphs</h3>
			<p>A <a id="_idIndexMarker016"/>digraph <em class="italic">G</em> is defined <a id="_idIndexMarker017"/>as a couple <em class="italic">G=(V, E)</em>, where <em class="italic">V={</em><img src="image/Formula_01_012.png" alt=""/><em class="italic">, .., </em><img src="image/Formula_01_013.png" alt=""/><em class="italic">}</em> is a set of nodes and <em class="italic">E={(</em><img src="image/Formula_01_014.png" alt=""/><em class="italic">,</em><img src="image/Formula_01_015.png" alt=""/><em class="italic"> .., (</em><img src="image/Formula_01_016.png" alt=""/><em class="italic">,</em><img src="image/Formula_01_017.png" alt=""/><em class="italic">)}</em> is a set of ordered couples representing the connection between two nodes belonging to <em class="italic">V</em>. </p>
			<p>Since each element of <em class="italic">E</em> is an ordered couple, it enforces the direction of the connection. The edge <img src="image/Formula_01_018.png" alt=""/><em class="italic">,</em><img src="image/Formula_01_019.png" alt=""/> means <em class="italic">the node </em><img src="image/Formula_01_020.png" alt=""/><em class="italic"> goes into </em><img src="image/Formula_01_021.png" alt=""/>. This is different from <img src="image/Formula_01_022.png" alt=""/><em class="italic">,</em><img src="image/Formula_01_023.png" alt=""/> since it means <em class="italic">the node </em><img src="image/Formula_01_024.png" alt=""/><em class="italic"> goes to </em><img src="image/Formula_01_025.png" alt=""/>.The starting node <img src="image/Formula_01_026.png" alt=""/> is called the <em class="italic">head</em>, while the ending node is called the <em class="italic">tail</em>.</p>
			<p>Due to the presence of edge direction, the definition of node degree needs to be extended.</p>
			<p class="callout-heading">Indegree and outdegree</p>
			<p class="callout">For a vertex <em class="italic">v</em>, the number of head ends adjacent to <em class="italic">v</em> is <a id="_idIndexMarker018"/>called the <strong class="bold">indegree</strong> (indicated by <img src="image/Formula_01_027.png" alt=""/> of <em class="italic">v</em>, while the number of tail<a id="_idIndexMarker019"/> ends adjacent to <em class="italic">v</em> is its <strong class="bold">outdegree</strong> (indicated by <img src="image/Formula_01_028.png" alt=""/>).</p>
			<p>An example <a id="_idIndexMarker020"/>of what a <a id="_idIndexMarker021"/>digraph looks like is available in the following screenshot: </p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B16069_01_02.jpg" alt="Figure 1.2 – Example of a digraph&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Example of a digraph</p>
			<p>The<a id="_idIndexMarker022"/> direction of the edge is<a id="_idIndexMarker023"/> visible from the arrow—for example, <strong class="bold">Milan</strong> -&gt; <strong class="bold">Dublin</strong> means from <strong class="bold">Milan</strong> to <strong class="bold">Dublin</strong>. <strong class="bold">Dublin</strong> has <img src="image/Formula_01_029.png" alt=""/><em class="italic"> = 2</em> and <img src="image/Formula_01_030.png" alt=""/><em class="italic"> = 0</em>, <strong class="bold">Paris</strong> has <img src="image/Formula_01_031.png" alt=""/><em class="italic"> = 0</em> and <img src="image/Formula_01_032.png" alt=""/><em class="italic"> = 2</em>, <strong class="bold">Milan</strong> has <img src="image/Formula_01_033.png" alt=""/><em class="italic"> = 1</em> and <img src="image/Formula_01_034.png" alt=""/><em class="italic"> = 2</em>, and <strong class="bold">Rome</strong> has <img src="image/Formula_01_035.png" alt=""/><em class="italic"> = 1 </em>and <img src="image/Formula_01_036.png" alt=""/><em class="italic"> = 0</em>.</p>
			<p>The same graph can be represented in <strong class="source-inline">networkx</strong>, as follows:</p>
			<p class="source-code">G = nx.DiGraph()</p>
			<p class="source-code">V = {'Dublin', 'Paris', 'Milan', 'Rome'}</p>
			<p class="source-code">E = [('Milan','Dublin'), ('Paris','Milan'), ('Paris','Dublin'), ('Milan','Rome')]</p>
			<p class="source-code">G.add_nodes_from(V)</p>
			<p class="source-code">G.add_edges_from(E)</p>
			<p>The definition is the same as that used for simple undirected graphs; the only difference is in the <strong class="source-inline">networkx</strong> classes that are used to instantiate the object. For digraphs, the <strong class="source-inline">nx.DiGraph()</strong>class is used.</p>
			<p><strong class="source-inline">Indegree</strong> and <strong class="source-inline">Outdegree</strong> can be computed using the following commands:</p>
			<p class="source-code">print(f"Indegree for nodes: { {v: G.in_degree(v) for v in G.nodes} }")</p>
			<p class="source-code">print(f"Outdegree for nodes: { {v: G.out_degree(v) for v in G.nodes} }")</p>
			<p>The results will be as follows:</p>
			<p class="source-code">Indegree for nodes: {'Rome': 1, 'Paris': 0, 'Dublin': 2, 'Milan': 1}</p>
			<p class="source-code">Outdegree for nodes: {'Rome': 0, 'Paris': 2, 'Dublin': 0, 'Milan': 2}</p>
			<p>As for the<a id="_idIndexMarker024"/> undirected graphs, <strong class="source-inline">G.add_nodes_from()</strong>, <strong class="source-inline">G.add_edges_from()</strong>, <strong class="source-inline">G.remove_nodes_from()</strong>, and <strong class="source-inline">G.remove_edges_from()</strong> functions<a id="_idIndexMarker025"/> can be used to modify a given graph <strong class="source-inline">G</strong>.</p>
			<h3>Multigraph</h3>
			<p>We will now introduce the multigraph<a id="_idIndexMarker026"/> object, which is a generalization of the graph definition that allows multiple edges to have the same pair of start and end nodes.</p>
			<p>A <strong class="bold">multigraph G</strong> is defined<a id="_idIndexMarker027"/> as <em class="italic">G=(V, E)</em>, where <em class="italic">V</em> is a set of nodes and <em class="italic">E</em> is a multi-set (a set allowing multiple instances for each of its elements) of edges.</p>
			<p>A multigraph is called<a id="_idIndexMarker028"/> a <strong class="bold">directed multigraph</strong> if <em class="italic">E</em> is a multi-set of ordered couples; otherwise, if <em class="italic">E</em> is a <a id="_idIndexMarker029"/>multi-set of two-sets, then it is called an <strong class="bold">undirected multigraph</strong>.</p>
			<p>An example of a directed multigraph is available in the following screenshot:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B16069_01_03.jpg" alt="Figure 1.3 – Example of a multigraph&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Example of a multigraph</p>
			<p>In the following code snippet, we <a id="_idIndexMarker030"/>show how to use <strong class="source-inline">networkx</strong> in order to<a id="_idIndexMarker031"/> create a directed or an <a id="_idIndexMarker032"/>undirected multigraph:</p>
			<p class="source-code">directed_multi_graph = nx.MultiDiGraph()</p>
			<p class="source-code">undirected_multi_graph = nx.MultiGraph()</p>
			<p class="source-code">V = {'Dublin', 'Paris', 'Milan', 'Rome'}</p>
			<p class="source-code">E = [('Milan','Dublin'), ('Milan','Dublin'), ('Paris','Milan'), ('Paris','Dublin'), ('Milan','Rome'), ('Milan','Rome')]</p>
			<p class="source-code">directed_multi_graph.add_nodes_from(V)</p>
			<p class="source-code">undirected_multi_graph.add_nodes_from(V)</p>
			<p class="source-code">directed_multi_graph.add_edges_from(E)</p>
			<p class="source-code">undirected_multi_graph.add_edges_from(E)</p>
			<p>The only difference between a directed and an undirected multigraph is in the first two lines, where two different objects are created: <strong class="source-inline">nx.MultiDiGraph()</strong> is used to create a directed multigraph, while <strong class="source-inline">nx.MultiGraph()</strong> is used to build an undirected multigraph. The function used to add nodes and edges is the same for both objects.</p>
			<h3>Weighted graphs</h3>
			<p>We will now<a id="_idIndexMarker033"/> introduce<a id="_idIndexMarker034"/> directed, undirected, and multi-weighted graphs. </p>
			<p>An <strong class="bold">edge-weighted graph</strong> (or simply, a weighted graph) <em class="italic">G</em> is defined as <em class="italic">G=(V, E ,w) </em>where <em class="italic">V</em> is a set of nodes, <em class="italic">E</em> is a <a id="_idIndexMarker035"/>set of edges, and <img src="image/Formula_01_037.png" alt=""/> is the weighted function that assigns at each edge <img src="image/Formula_01_038.png" alt=""/> a weight expressed as a real number.</p>
			<p>A <strong class="bold">node-weighted graph</strong> <em class="italic">G</em> is defined as <em class="italic">G=</em>(<em class="italic">V, E ,w</em>) ,where <em class="italic">V</em> is a set of nodes, <em class="italic">E</em> is a set of edges, and <img src="image/Formula_01_039.png" alt=""/> is the <a id="_idIndexMarker036"/>weighted function that assigns at each node <img src="image/Formula_01_040.png" alt=""/> a weight expressed as a real number.</p>
			<p>Please keep the following points in mind:</p>
			<ul>
				<li>If <em class="italic">E</em> is a set of ordered couples, then we call <a id="_idIndexMarker037"/>it a <strong class="bold">directed weighted graph</strong>.</li>
				<li>If <em class="italic">E</em> is a set of two-sets, then we call it <a id="_idIndexMarker038"/>an <strong class="bold">undirected weighted graph</strong>. </li>
				<li>If <em class="italic">E</em> is a<a id="_idIndexMarker039"/> multi-set, we will <a id="_idIndexMarker040"/>call it a <strong class="bold">weighted multigraph</strong> (<strong class="bold">directed weighted multigraph</strong>). <strong class="bold"> </strong></li>
				<li>If <em class="italic">E</em> is a multi-set of ordered <a id="_idIndexMarker041"/>couples, it is an <strong class="bold">undirected weighted multigraph</strong>.</li>
			</ul>
			<p>An example of a <a id="_idIndexMarker042"/>directed edge-weighted graph is available in the following screenshot:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B16069_01_04.jpg" alt="Figure 1.4 – Example of a directed edge-weighted graph&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Example of a directed edge-weighted graph</p>
			<p>From <em class="italic">Figure 1.4</em>, it is<a id="_idIndexMarker043"/> easy to see how the presence of weights on graphs helps to add useful information to the data structures. Indeed, we can imagine the edge weight as a "cost" to reach a node from another node. For example, reaching <strong class="bold">Dublin</strong> from <strong class="bold">Milan</strong> has a "cost" of <strong class="source-inline">19</strong>, while reaching <strong class="bold">Dublin</strong> from <strong class="bold">Paris</strong> has a "cost" of <strong class="source-inline">11</strong>.</p>
			<p>In <strong class="source-inline">networkx</strong>, a directed weighted graph can be generated as follows:</p>
			<p class="source-code">G = nx.DiGraph()</p>
			<p class="source-code">V = {'Dublin', 'Paris', 'Milan', 'Rome'}</p>
			<p class="source-code">E = [('Milan','Dublin', 19), ('Paris','Milan', 8), ('Paris','Dublin', 11), ('Milan','Rome', 5)]</p>
			<p class="source-code">G.add_nodes_from(V)</p>
			<p class="source-code">G.add_weighted_edges_from(E)</p>
			<h3>Bipartite graphs</h3>
			<p>We will now introduce <a id="_idIndexMarker044"/>another type of graph that will be used in this section: multipartite graphs. Bi- and tripartite graphs—and, more generally, kth-partite graphs—are graphs whose<a id="_idIndexMarker045"/> vertices can be partitioned in two, three, or more k-th sets of nodes, respectively. Edges are only allowed across different sets and are not allowed within nodes belonging to the same set. In most cases, nodes belonging to different sets are also characterized by particular node types. In <em class="italic">Chapters 7, Text Analytics and Natural Language Processing Using Graphs,</em> and <a href="B16069_08_Final_JM_ePub.xhtml#_idTextAnchor129"><em class="italic">Chapter 8</em></a>,<em class="italic"> Graphs Analysis for Credit Cards Transaction</em>, we will deal with some practical examples of graph-based applications and you will see how multipartite graphs can indeed arise in several contexts—for example, in the following scenarios: </p>
			<ul>
				<li>When processing documents and structuring the information in a bipartite graph of documents and entities that appear in the documents</li>
				<li>When dealing with transactional data, in order to encode the relations between the buyers and the merchants</li>
			</ul>
			<p>A bipartite graph can be easily created in <strong class="source-inline">networkx</strong> with the following code:</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">n_nodes = 10</p>
			<p class="source-code">n_edges = 12</p>
			<p class="source-code">bottom_nodes = [ith for ith in range(n_nodes) if ith % 2 ==0]</p>
			<p class="source-code"> top_nodes = [ith for ith in range(n_nodes) if ith % 2 ==1]</p>
			<p class="source-code">iter_edges = zip(</p>
			<p class="source-code">    np.random.choice(bottom_nodes, n_edges),  </p>
			<p class="source-code">    np.random.choice(top_nodes, n_edges))</p>
			<p class="source-code">edges = pd.DataFrame([</p>
			<p class="source-code">    {"source": a, "target": b} for a, b in iter_edges])</p>
			<p class="source-code">B = nx.Graph()</p>
			<p class="source-code">B.add_nodes_from(bottom_nodes, bipartite=0)</p>
			<p class="source-code"> B.add_nodes_from(top_nodes, bipartite=1)</p>
			<p class="source-code"> B.add_edges_from([tuple(x) for x in edges.values])</p>
			<p>The<a id="_idIndexMarker046"/> network can also be conveniently plotted using the <strong class="source-inline">bipartite_layout</strong> utility function of <strong class="source-inline">networkx</strong>, as illustrated in the following code snippet: </p>
			<p class="source-code">from networkx.drawing.layout import bipartite_layout</p>
			<p class="source-code">pos = bipartite_layout(B, bottom_nodes)</p>
			<p class="source-code"> nx.draw_networkx(B, pos=pos)</p>
			<p>The <strong class="source-inline">bipatite_layout</strong> function <a id="_idIndexMarker047"/>produces a graph, as shown in the following screenshot: </p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B16069_01_05.jpg" alt="Figure 1.5 – Example of a bipartite graph&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Example of a bipartite graph</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/>Graph representations</h2>
			<p>As described in the<a id="_idIndexMarker048"/> previous sections, with <strong class="source-inline">networkx</strong>, we can actually define and manipulate a graph by using node and edge objects. In different use cases, such a representation would not be as easy to handle. In this section, we will show two ways to perform a compact representation of a graph data structure—namely, an adjacency matrix and an edge list.</p>
			<h3>Adjacency matrix</h3>
			<p>The <strong class="bold">adjacency matrix</strong> <em class="italic">M</em> of a graph <em class="italic">G=(V,E)</em> is a square matrix <em class="italic">(|V| × |V|</em>) matrix such that<a id="_idIndexMarker049"/> its element <img src="image/Formula_01_041.png" alt=""/> is 1 when there is an edge from node <em class="italic">i</em> to node <em class="italic">j</em>, and 0 when there is no edge. In the following screenshot, we show a simple example where the adjacency matrix of different types of graphs is displayed:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B16069_01_006.jpg" alt="Figure 1.6 – Adjacency matrix for an undirected graph, a digraph, a multigraph, and a weighted graph&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Adjacency matrix for an undirected graph, a digraph, a multigraph, and a weighted graph</p>
			<p>It is easy to see that adjacency matrices for undirected graphs are always symmetric, since no direction is defined for the edge. The symmetry instead is not guaranteed for the adjacency matrix of a digraph due to the presence of constraints in the direction of the edges. For a multigraph, we can instead have values greater than 1 since multiple edges can be used to connect the same couple of nodes. For a weighted graph, the value in a specific cell is<a id="_idIndexMarker050"/> equal to the weight of the edge <a id="_idIndexMarker051"/>connecting the two nodes.</p>
			<p>In <strong class="source-inline">networkx</strong>, the adjacency matrix for a given graph can be computed in two different ways. If <strong class="source-inline">G</strong> is the <strong class="source-inline">networkx</strong> of <em class="italic">Figure 1.6</em>, we can compute its adjacency matrix as follows:</p>
			<p class="source-code">nx.to_pandas_adjacency(G) #adjacency matrix as pd DataFrame</p>
			<p class="source-code">nt.to_numpy_matrix(G) #adjacency matrix as numpy matrix</p>
			<p>For the first and second line, we get the following results respectively:</p>
			<p class="source-code">          Rome  Dublin  Milan  Paris</p>
			<p class="source-code">Rome     0.0     0.0    0.0    0.0</p>
			<p class="source-code">Dublin   0.0     0.0    0.0    0.0</p>
			<p class="source-code">Milan    1.0     1.0    0.0    0.0</p>
			<p class="source-code">Paris    0.0     1.0    1.0    0.0</p>
			<p class="source-code">[[0. 0. 0. 0.]</p>
			<p class="source-code"> [0. 0. 0. 0.]</p>
			<p class="source-code"> [1. 1. 0. 0.]</p>
			<p class="source-code"> [0. 1. 1. 0.]]</p>
			<p>Since a <strong class="source-inline">numpy</strong> matrix cannot represent the name of the nodes, the order of the element in the adjacency matrix is the one defined in the <strong class="source-inline">G.nodes</strong> list.</p>
			<h3>Edge list</h3>
			<p>As well as an adjacency matrix, an edge list is another compact way to represent graphs. The idea behind this format is to represent a graph as a list of edges.</p>
			<p>The <strong class="bold">edge list</strong> <em class="italic">L</em> of a<a id="_idIndexMarker052"/> graph <em class="italic">G=(V,E)</em> is a list of size <em class="italic">|E|</em> matrix such that its element <img src="image/Formula_01_042.png" alt=""/> is a <a id="_idIndexMarker053"/>couple representing the tail and the end node of the edge <em class="italic">i</em>. An example of the edge list for each type of graph is available in the following screenshot: </p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B16069_01_007.jpg" alt="Figure 1.7 – Edge list for an undirected graph, a digraph, a multigraph, and a weighted graph&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Edge list for an undirected graph, a digraph, a multigraph, and a weighted graph</p>
			<p>In the following code snippet, we show how to compute in <strong class="source-inline">networkx</strong> the edge list of the simple undirected graph <em class="italic">G</em> available in <em class="italic">Figure 1.7</em>:</p>
			<p class="source-code">print(nx.to_pandas_edgelist(G))</p>
			<p>By running the<a id="_idIndexMarker054"/> preceding command, we <a id="_idIndexMarker055"/>get the following result:</p>
			<p class="source-code">  source  target</p>
			<p class="source-code">0  Milan  Dublin</p>
			<p class="source-code">1  Milan    Rome</p>
			<p class="source-code">2  Paris   Milan</p>
			<p class="source-code">3  Paris  Dublin</p>
			<p>Other representation methods, which we will not discuss in detail, are also available in <strong class="source-inline">networkx</strong>. Some examples are <strong class="source-inline">nx.to_dict_of_dicts(G)</strong> and <strong class="source-inline">nx.to_numpy_array(G)</strong>, among others.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor020"/>Plotting graphs</h1>
			<p>As we <a id="_idIndexMarker056"/>have seen in previous sections, graphs are intuitive data structures represented graphically. Nodes can be plotted as simple circles, while edges are lines connecting two nodes. </p>
			<p>Despite their simplicity, it could be quite difficult to make a clear representation when the number of edges and nodes increases. The source of this complexity is mainly related to the position (space/Cartesian coordinates) to assign to each node in the final plot. Indeed, it could be unfeasible to manually assign to a graph with hundreds of nodes the specific position of each node in the final plot.</p>
			<p>In this section, we will see how we can plot graphs without specifying coordinates for each node. We will exploit two different solutions: <strong class="source-inline">networkx</strong> and Gephi.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor021"/>networkx</h2>
			<p><strong class="source-inline">networkx</strong> offers a <a id="_idIndexMarker057"/>simple interface to plot graph objects through <a id="_idIndexMarker058"/>the <strong class="source-inline">nx.draw</strong> library. In the following code snippet, we show how to use the library in order to plot graphs:</p>
			<p class="source-code">def draw_graph(G, nodes_position, weight):</p>
			<p class="source-code">      nx.draw(G, pos_ position, with_labels=True, font_size=15, node_size=400, edge_color='gray', arrowsize=30)</p>
			<p class="source-code">             if plot_weight:</p>
			<p class="source-code">             edge_labels=nx.get_edge_attributes(G,'weight')</p>
			<p class="source-code">         nx.draw_networkx_edge_labels(G, pos_ position, edge_labels=edge_labels)</p>
			<p>Here, <strong class="source-inline">nodes_position</strong> is a dictionary where the keys are the nodes and the value assigned to each key is an array of length 2, with the Cartesian coordinate used for plotting the specific node. </p>
			<p>The <strong class="source-inline">nx.draw</strong> function will plot the whole graph by putting its nodes in the given positions. The <strong class="source-inline">with_labels</strong> option will plot its name on top of each node with the specific <strong class="source-inline">font_size</strong> value. <strong class="source-inline">node_size</strong> and <strong class="source-inline">edge_color</strong> will respectively specify the size of the circle, representing the node and the color of the edges. Finally, <strong class="source-inline">arrowsize</strong> will define the size of the arrow for directed edges. This option will be used when the graph to be plotted is a digraph.</p>
			<p>In the following<a id="_idIndexMarker059"/> code example, we show how to use the <strong class="source-inline">draw_graph</strong> function <a id="_idIndexMarker060"/>previously defined in order to plot a graph:</p>
			<p class="source-code">G = nx.Graph()</p>
			<p class="source-code">V = {'Paris', 'Dublin','Milan', 'Rome'}</p>
			<p class="source-code">E = [('Paris','Dublin', 11), ('Paris','Milan', 8),</p>
			<p class="source-code">     ('Milan','Rome', 5), ('Milan','Dublin', 19)]</p>
			<p class="source-code">G.add_nodes_from(V)</p>
			<p class="source-code">G.add_weighted_edges_from(E)</p>
			<p class="source-code">node_position = {"Paris": [0,0], "Dublin": [0,1], "Milan": [1,0], "Rome": [1,1]}</p>
			<p class="source-code">draw_graph(G, node_position, True)</p>
			<p>The result of the plot is available to view in the following screenshot:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B16069_01_08.jpg" alt="Figure 1.8 – Result of the plotting function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – Result of the plotting function</p>
			<p>The method previously described is simple but unfeasible to use in a real scenario since the <strong class="source-inline">node_position</strong> value could be difficult to decide. In order to solve this issue, <strong class="source-inline">networkx</strong> offers a different<a id="_idIndexMarker061"/> function to automatically compute the position of each node according to <a id="_idIndexMarker062"/>different layouts. In <em class="italic">Figure 1.9</em>, we show a series of plots of an undirected graph, obtained using the different layouts available in <strong class="source-inline">networkx</strong>. In order to use them in the function we proposed, we simply need to assign <strong class="source-inline">node_position</strong> to the result of the layout we want to use—for example, <strong class="source-inline">node_position = nx.circular_layout(G)</strong>. The plots can be seen in the following screenshot:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B16069_01_009.jpg" alt="Figure 1.9 – Plots of the same undirected graph with different layouts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9 – Plots of the same undirected graph with different layouts</p>
			<p><strong class="source-inline">networkx</strong> is a<a id="_idIndexMarker063"/> great tool for easily manipulating and analyzing graphs, but <a id="_idIndexMarker064"/>it does not offer good functionalities in order to perform complex and good-looking plots of graphs. In the next section, we will investigate another tool to perform complex graph visualization: Gephi.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/>Gephi</h2>
			<p>In<a id="_idIndexMarker065"/> this section, we<a id="_idIndexMarker066"/> will show how <strong class="bold">Gephi</strong> (an open source network analysis and visualization software) can be used for performing complex, fancy plots of graphs. For all the examples showed in this section, we will use the <strong class="source-inline">Les Miserables.gexf</strong> sample (a weighted undirected graph), which<a id="_idIndexMarker067"/> can be selected in the <strong class="bold">Welcome</strong> window when the application starts.</p>
			<p>The main interface of <a id="_idIndexMarker068"/>Gephi is shown in <em class="italic">Figure 1.10</em>. It can be divided into four main areas, as<a id="_idIndexMarker069"/> follows:</p>
			<ol>
				<li><strong class="bold">Graph</strong>: This section shows the final plot of the graph. The image is automatically updated each time a filter or a specific layout is applied.</li>
				<li><strong class="bold">Appearance</strong>: Here, it is possible to specify the appearance of nodes and edges.</li>
				<li><strong class="bold">Layout</strong>: In this section, it is possible to select the layout (as in <strong class="source-inline">networkx</strong>) to adjust the node position in the graph. Different algorithms, from a simple random position generator to a more complex Yifan Hu algorithm, are available.</li>
				<li><strong class="bold">Filters &amp; Statistics</strong>: In this set area, two main functions are available, outlined as follows:<p>a. <strong class="bold">Filters</strong>: In this tab, it is possible to filter and visualize specific subregions of the graph according to a set property computed using the <strong class="bold">Statistics</strong> tab.</p><p>b. <strong class="bold">Statistics</strong>: This tab contains a list of available graph metrics that can be computed on the graph using the <strong class="bold">Run</strong> button. Once metrics are computed, they can be used as properties to specify the edges' and nodes' appearance (such as node and edge size and color) or to filter a specific subregion of the graph.</p><p>You can see the main interface of Gephi in the following screenshot: </p></li>
			</ol>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B16069_01_010.jpg" alt="Figure 1.10 – Gephi main window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.10 – Gephi main window</p>
			<p>Our <a id="_idIndexMarker070"/>exploration of Gephi starts with the application of different layouts to the graph. As previously described, in <strong class="source-inline">networkx</strong> the layouts allow us to assign to each node a specific position in the final plot. In Gephi 1.2, different layouts are available. In order to apply a specific layout, we have to select from the <strong class="bold">Layout</strong> area one of the available layouts, and then click on the <strong class="bold">Run</strong> button that appears after the selection. </p>
			<p>The graph representation, visible<a id="_idIndexMarker071"/> in the <strong class="bold">Graph</strong> area, will be automatically updated according to the new coordinates defined by the layout. It should be noted that some layouts are parametric, hence the final graph plot can significantly change according to the parameters used. In the following screenshot, we propose several examples for the application of three different layouts:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B16069_01_011.jpg" alt="Figure 1.11 – Plot of the same graph with different layout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11 – Plot of the same graph with different layout</p>
			<p>We will now<a id="_idIndexMarker072"/> introduce the available options in the <strong class="bold">Appearance</strong> menu visible in <em class="italic">Figure 1.10</em>. In this section, it is possible to specify the style to be applied to edges and nodes. The style to be applied can be static or can be dynamically defined by specific properties of the nodes/edges. We can change the color and the size of the nodes by selecting the <strong class="bold">Nodes</strong> option in the menu. </p>
			<p>In order to change the color, we have to select the color palette icon and decide, using the specific button, if we <a id="_idIndexMarker073"/>want to assign a <strong class="bold">Unique</strong> color, a <strong class="bold">Partition</strong> (discrete values), or a <strong class="bold">Ranking</strong> (range of values) of colors. For <strong class="bold">Partition</strong> and <strong class="bold">Ranking</strong>, it is possible to select from the drop-down menu a specific <strong class="bold">Graph</strong> property to use as reference for the color range. Only the properties computed by clicking <strong class="bold">Run</strong> in the <strong class="bold">Statistics</strong> area are available in the drop-down menu. The same procedure can be used in order to set the size of the nodes. By selecting the concentric circles icon, it is possible to set a <strong class="bold">Unique </strong>size to all the nodes or to specify a <strong class="bold">Ranking</strong> of size according to a specific property.</p>
			<p>As for the nodes, it is also possible to change the style of the edges by selecting the <strong class="bold">Edges</strong> option in the menu. We can then select to assign a <strong class="bold">Unique</strong> color, a <strong class="bold">Partition</strong> (discrete values), or a <strong class="bold">Ranking</strong> (range of values) of colors. For <strong class="bold">Partition</strong> and <strong class="bold">Ranking</strong>, the reference value to build the color scale is defined by a specific <strong class="bold">Graph</strong> property that can be selected from the drop-down menu. </p>
			<p>It is important to remember that in order to apply a specific style to the graph, the <strong class="bold">Apply</strong> button should be clicked. As a result, the graph plot will be updated according to the style defined. In the following screenshot, we show an example where the color of the nodes is given by the <strong class="bold">Modularity Class</strong> value and the size of each node is given by its degree, while the color of each edge is defined by the edge weight:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B16069_01_012.jpg" alt="Figure 1.12 – Example of graph plot changing nodes’ and edges’ appearance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12 – Example of graph plot changing nodes' and edges' appearance</p>
			<p>Another<a id="_idIndexMarker074"/> important section that needs to be described is <strong class="bold">Filters &amp; Statistics</strong>. In this menu, it is possible to compute some statistics based on g<a id="_idTextAnchor023"/>raph metrics. </p>
			<p>Finally, we conclude our <a id="_idIndexMarker075"/>discussion on Gephi by introducing the functionalities available in the <strong class="bold">Statistics</strong> menu, visible in the right panel in <em class="italic">Figure 1.10</em>. Through this menu, it is possible to compute different statistics on the input graph. Those statistics can be easily used to set some properties of the final plot, such as nodes'/edges' color and size, or to filter the original graph to plot just a specific subset of it. In order to compute a specific statistic, the user then needs to explicitly select one of the metrics available in the menu and click on the <strong class="bold">Run</strong> button (<em class="italic">Figure 1.10</em>, right panel).</p>
			<p>Moreover, the user can select a subregion of the graph, using the options available in the <strong class="bold">Filters</strong> tab of the <strong class="bold">Statistics</strong> menu, visible in the right panel in <em class="italic">Figure 1.10</em>. An example of filtering a graph can be seen in <em class="italic">Figure 1.13</em>. To provide more details of this, we build and apply to the graph a filter, using the <strong class="bold">Degree</strong> property. The result of the filters is a subset of the original graph, where only the nodes (and their edges) having the specific range of values for the degree property are visible.</p>
			<p>This is<a id="_idIndexMarker076"/> illustrated<a id="_idIndexMarker077"/> in the following screenshot:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B16069_01_013.jpg" alt="Figure 1.13 – Example of a graph filtered according to a range of values for Degree&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13 – Example of a graph filtered according to a range of values for Degree</p>
			<p>Of course, Gephi allows us to perform more complex visualization tasks and contains a lot of functionalities that cannot be fully covered in this book. Some good references to better investigate all the features available in Gephi are the <a id="_idIndexMarker078"/>official Gephi guide (<a href="https://gephi.org/users/">https://gephi.org/users/</a>) or the <em class="italic">Gephi Cookbook</em> book by Packt Publishing.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor024"/>Graph properties</h1>
			<p>As we have already <a id="_idIndexMarker079"/>learned, a <em class="italic">graph</em> is a mathematical model that is used for describing relations between entities. However, each complex network presents intrinsic properties. Such properties can be measured by particular metrics, and each measure may characterize one or several local and global aspects of the graph.</p>
			<p>In a graph for a social network such as Twitter, for example, users (represented by the <em class="italic">nodes</em> of the graph) are connected to each other. However, there are users that are more connected than others (influencers). On the Reddit social graph, users with similar characteristics tend to group into communities.</p>
			<p>We have already mentioned some of the <em class="italic">basic features</em> of graphs, such as the <em class="italic">number of nodes and edges</em> in a graph, which constitute the size of the graph itself. Those properties already provide a good description of the structure of a network. Think about the Facebook graph, for example: it can be described in terms of the number of nodes and edges. Such numbers easily allow it to be distinguished from a much smaller network (for example, the social structure of an office) but fail to characterize more complex dynamics (for example, how <em class="italic">similar</em> nodes are connected). To this end, more advanced graph-derived <strong class="bold">metrics</strong> can be considered, which can be grouped into four main categories, outlined as follows:</p>
			<ul>
				<li><strong class="bold">Integration metrics</strong>: These <a id="_idIndexMarker080"/>measure how nodes tend to be interconnected with each other.</li>
				<li><strong class="bold">Segregation metrics</strong>: These<a id="_idIndexMarker081"/> quantify the presence of groups of interconnected nodes, known as communities or modules, within a network.</li>
				<li><strong class="bold">Centrality metrics</strong>: These<a id="_idIndexMarker082"/> assess the importance of individual nodes inside a network.</li>
				<li><strong class="bold">Resilience metrics</strong>: These<a id="_idIndexMarker083"/> can be thought of as a measure of how much a network is able to maintain and adapt its operational performance when facing failures or other adverse conditions.</li>
			</ul>
			<p>Those metrics are defined as <strong class="bold">global</strong> when expressing a measure of an overall network. On the other hand, <strong class="bold">local</strong> metrics measure values of individual network elements (nodes or edges). In weighted graphs, each property may or may not account for the <em class="italic">edge weights</em>, leading to <strong class="bold">weighted and unweighted metrics</strong>.</p>
			<p>In the following section, we describe some of the most commonly used metrics that measure global and local properties. For simplicity, unless specified differently in the text, we illustrate the global unweighted version of the metric. In several cases, this is obtained by averaging the local unweighted properties of the node.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor025"/>Integration metrics</h2>
			<p>In<a id="_idIndexMarker084"/> this section, some of the most frequently used integration metrics will be described.</p>
			<h3>Distance, path, and shortest path</h3>
			<p>The<a id="_idIndexMarker085"/> concept of <strong class="bold">distance</strong> in a graph is <a id="_idIndexMarker086"/>often related to the number of edges to traverse in order to reach a target node from a given source node. </p>
			<p>In particular, consider a source node <img src="image/Formula_01_043.png" alt=""/> and a target node <img src="image/Formula_01_044.png" alt=""/>. The set of edges connecting node <img src="image/Formula_01_045.png" alt=""/> to node<em class="italic"> </em><img src="image/Formula_01_046.png" alt=""/> is<a id="_idIndexMarker087"/> called a <strong class="bold">path</strong>. When<a id="_idIndexMarker088"/> studying complex networks, we are often interested in finding the <strong class="bold">shortest path</strong> between<a id="_idIndexMarker089"/> two nodes. A<a id="_idIndexMarker090"/> shortest path between a source node <img src="image/Formula_01_047.png" alt=""/> and a target node <img src="image/Formula_01_048.png" alt=""/> is the path having the lowest number of edges compared to all the possible paths between <img src="image/Formula_01_049.png" alt=""/> and <img src="image/Formula_01_050.png" alt=""/>. The <strong class="bold">diameter</strong> of a <a id="_idIndexMarker091"/>network is the number of edges contained in the longest shortest path among all possible shortest paths.</p>
			<p>Take a look at the following screenshot. There are different path<a id="_idIndexMarker092"/>s to reach <strong class="bold">Tokyo</strong> from <strong class="bold">Dublin</strong>. However, one of them is the shortest (the edges on the <a id="_idIndexMarker093"/>shortest path are highlighted):</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B16069_01_014.jpg" alt="Figure 1.14 – The shortest path between two nodes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.14 – The shortest path between two nodes</p>
			<p>The <strong class="source-inline">shortest_path</strong> function<a id="_idIndexMarker094"/> of the <strong class="source-inline">networkx</strong> Python library enables users to quickly compute the shortest path between two nodes in a graph. Consider the following code, in which a seven-node graph is created by using <strong class="source-inline">networkx</strong>:</p>
			<p class="source-code">G = nx.Graph()</p>
			<p class="source-code">nodes = {1:'Dublin',2:'Paris',3:'Milan',4:'Rome',5:'Naples',</p>
			<p class="source-code">         6:'Moscow',7:'Tokyo'}</p>
			<p class="source-code">G.add_nodes_from(nodes.keys())</p>
			<p class="source-code">G.add_edges_from([(1,2),(1,3),(2,3),(3,4),(4,5),(5,6),(6,7),(7,5)])</p>
			<p>The shortest path <a id="_idIndexMarker095"/>between a source node (for example, <strong class="source-inline">'Dublin'</strong>, identified by the key 1) and a target node (for example, <strong class="source-inline">'Tokyo'</strong>, identified by the key 7) can be obtained as follows:</p>
			<p class="source-code">path = nx.shortest_path(G,source=1,target=7)</p>
			<p>This should <a id="_idIndexMarker096"/>output the following:</p>
			<p class="source-code">[1,3,4,5,6]</p>
			<p>Here, <strong class="source-inline">[1,3,4,5,7]</strong> are the nodes contained in the shortest path between <strong class="source-inline">'Tokyo' </strong>and <strong class="source-inline">'Dublin'</strong>.</p>
			<h3>Characteristic path length</h3>
			<p>The <strong class="bold">characteristic path length</strong> is defined<a id="_idIndexMarker097"/> as the average of all the shortest path lengths between all possible pair of nodes. If <img src="image/Formula_01_051.png" alt=""/> is the average path length between the node<em class="italic"> </em><img src="image/Formula_01_052.png" alt=""/> and all the other nodes, the characteristic path length is computed as follows:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/Formula_01_053.jpg" alt=""/>
				</div>
			</div>
			<p>Here, <img src="image/Formula_01_054.png" alt=""/> is the set of nodes in the graph and <img src="image/Formula_01_055.png" alt=""/> represents its <em class="italic">order</em>. This is one of the most commonly used measures of how efficiently information is spread across a network. Networks having shorter characteristic path lengths promote the quick transfer of information and reduce costs. Characteristic path length can be computed through <strong class="source-inline">networkx</strong> using<a id="_idIndexMarker098"/> the following function:</p>
			<p class="source-code">nx.average_shortest_path_length(G)</p>
			<p>This should<a id="_idIndexMarker099"/> give us the following:</p>
			<p class="source-code">2.1904761904761907</p>
			<p>However, this metric cannot be always defined since it is not possible to compute a path among all the nodes in <em class="italic">disconnected graphs</em>. For this reason, <strong class="bold">network efficiency</strong> is also widely used.</p>
			<h3>Global and local efficiency</h3>
			<p><strong class="bold">Global efficiency</strong> is the <a id="_idIndexMarker100"/>average of the inverse shortest path length for all pairs of nodes. Such a metric can be seen as a measure of how efficiently information is exchanged across a network. Consider that <img src="image/Formula_01_056.png" alt=""/> is the shortest path between a node <img src="image/Formula_01_057.png" alt=""/> and a node <img src="image/Formula_01_058.png" alt=""/>. The network efficiency is defined as follows:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/Formula_01_059.jpg" alt=""/>
				</div>
			</div>
			<p>Efficiency is at a maximum when a graph is fully connected, while it is minimal for completely disconnected graphs. Intuitively, the shorter the path, the lower the measure.</p>
			<p>The <strong class="bold">local efficiency</strong> of a<a id="_idIndexMarker101"/> node can be computed by considering only the neighborhood of the node in the calculation, without the node itself. Global<a id="_idIndexMarker102"/> efficiency is computed in <strong class="source-inline">networkx</strong> using the following command:</p>
			<p class="source-code">nx.global_efficiency(G)</p>
			<p>The output should be as follows:</p>
			<p class="source-code">0.6111111111111109</p>
			<p>Average local efficiency is computed in <strong class="source-inline">networkx</strong> using the following command:</p>
			<p class="source-code">nx.local_efficiency(G)</p>
			<p>The output should be as follows:</p>
			<p class="source-code">0.6666666666666667</p>
			<p>In the following screenshot, two examples of graphs are depicted. As observed, a fully connected graph on the left presents a higher level of efficiency compared to a circular graph on the right. In a fully connected graph, each node can be reached from any other node in the graph, and information is exchanged rapidly across the network. However, in a circular graph, several nodes should instead be traversed to reach the target node, making it less efficient:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B16069_01_015.jpg" alt="Figure 1.15 – Global efficiency of a fully connected graph (left) and a circular graph (right)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.15 – Global efficiency of a fully connected graph (left) and a circular graph (right)</p>
			<p>Integration <a id="_idIndexMarker103"/>metrics well describe the connection among nodes. However, more information about the presence of groups can be extracted by considering segregation metrics.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor026"/>Segregation metrics</h2>
			<p>In this section, some of the<a id="_idIndexMarker104"/> most common segregation metrics will be described.</p>
			<h3>Clustering coefficient</h3>
			<p>The <strong class="bold">clustering coefficient</strong> is a <a id="_idIndexMarker105"/>measure of how much nodes cluster together. It is defined as the fraction of <strong class="bold">triangles</strong> (complete subgraph of three nodes and three edges) around a node and is equivalent to the fraction of the node's <em class="italic">neighbors</em> that are neighbors of each other. A global clustering coefficient is computed in <strong class="source-inline">networkx</strong> using the following command:</p>
			<p class="source-code">nx.average_clustering(G)</p>
			<p>This should output the following:</p>
			<p class="source-code">0.6666666666666667</p>
			<p>The local clustering coefficient is computed in <strong class="source-inline">networkx</strong> using the following command:</p>
			<p class="source-code">nx.clustering(G)</p>
			<p>This should output the following:</p>
			<p class="source-code">{1: 1.0,</p>
			<p class="source-code"> 2: 1.0,</p>
			<p class="source-code"> 3: 0.3333333333333333,</p>
			<p class="source-code"> 4: 0,</p>
			<p class="source-code"> 5: 0.3333333333333333,</p>
			<p class="source-code"> 6: 1.0,</p>
			<p class="source-code"> 7: 1.0}</p>
			<p>The output is a Python dictionary containing, for each node (identified by the respective key), the corresponding value. In the graph represented in <em class="italic">Figure 1.16</em>, two clusters of nodes can be <a id="_idIndexMarker106"/>easily identified. By computing the <a id="_idIndexMarker107"/>clustering coefficient for each single node, it can be observed that <strong class="bold">Rome</strong> has the lowest value. <strong class="bold">Tokyo</strong> and <strong class="bold">Moscow</strong>, as well as <strong class="bold">Paris</strong> and <strong class="bold">Dublin</strong>, are instead very well connected within their respective groups (notice the size of each node is drawn proportionally to each node's clustering coefficient). The graph can be seen in the following screenshot:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B16069_01_16.jpg" alt="Figure 1.16 – Local clustering coefficient representation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.16 – Local clustering coefficient representation</p>
			<h3>Transitivity</h3>
			<p>A common variant of the<a id="_idIndexMarker108"/> clustering coefficient is known as <strong class="bold">transitivity</strong>. This can simply be defined as the ratio between the observed number of <strong class="bold">closed triplets</strong> (complete subgraph with three nodes and two edges) and the maximum possible number of closed triplets in the graph. Transitivity can be computed using <strong class="source-inline">networkx</strong>, as follows:</p>
			<p class="source-code">nx.transitivity(G)</p>
			<p>The output should be as follows:</p>
			<p class="source-code">0.5454545454545454</p>
			<h3>Modularity</h3>
			<p><strong class="bold">Modularity</strong> was designed to <a id="_idIndexMarker109"/>quantify the division of a network in aggregated sets of highly interconnected nodes, commonly known as <strong class="bold">modules</strong>, <strong class="bold">communities</strong>, <strong class="bold">groups</strong>, or <strong class="bold">clusters</strong>. The main idea is that networks having high modularity will show dense connections within the module and sparse connections between modules. </p>
			<p>Consider a social <a id="_idIndexMarker110"/>network such as Reddit: members of communities related to video games tend to interact much more with other users in the same community, talking about recent news, favorite consoles, and so on. However, they will probably interact less with users talking about fashion. Differently from many other graph metrics, modularity is often computed by means of optimization algorithms.</p>
			<p>Modularity in <strong class="source-inline">networkx</strong> is computed using the <strong class="source-inline">modularity</strong> function of the <strong class="source-inline">networkx.algorithms.community</strong> module, as follows:</p>
			<p class="source-code">import networkx.algorithms.community as nx_comm</p>
			<p class="source-code">nx_comm.modularity(G, communities=[{1,2,3}, {4,5,6,7}])</p>
			<p>Here, the second argument—<strong class="source-inline">communities</strong>—is a list of sets, each representing a partition of the graph. The output should be as follows:</p>
			<p class="source-code">0.3671875</p>
			<p>Segregation metrics help to understand the presence of groups. However, each node in a graph has its own <em class="italic">importance</em>. To quantify it, we can use centrality metrics.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor027"/>Centrality metrics</h2>
			<p>In this section, some <a id="_idIndexMarker111"/>of the most common centrality metrics will be described.</p>
			<h3>Degree centrality</h3>
			<p>One of the most common and simple centrality metrics<a id="_idIndexMarker112"/> is the <strong class="bold">degree centrality</strong> metric. This is <a id="_idIndexMarker113"/>directly connected with the <em class="italic">degree</em> of a node, measuring the number of <em class="italic">incident</em> edges on a certain node <img src="image/Formula_01_060.png" alt=""/>. </p>
			<p>Intuitively, the more a<a id="_idIndexMarker114"/> node is connected to an other node, the more its degree centrality will assume high values. Note that, if a <a id="_idIndexMarker115"/>graph is <em class="italic">directed</em>, the <strong class="bold">in-degree centrality</strong> and <strong class="bold">out-degree centrality</strong> will <a id="_idIndexMarker116"/>be considered for each node, related to the number of <em class="italic">incoming</em> and <em class="italic">outcoming</em> edges, respectively. Degree centrality is computed in <strong class="source-inline">networkx</strong> by using the following command:</p>
			<p class="source-code">nx.degree_centrality(G)</p>
			<p>The output should be as follows:</p>
			<p class="source-code">{1: 0.3333333333333333, 2: 0.3333333333333333, 3: 0.5, 4: 0.3333333333333333, 5: 0.5, 6: 0.3333333333333333, 7: 0.3333333333333333}</p>
			<h3>Closeness centrality</h3>
			<p>The <strong class="bold">closeness centrality</strong> metric <a id="_idIndexMarker117"/>attempts to quantify how much a node is close (well connected) to other nodes. More formally, it refers to the average distance of a node <img src="image/Formula_01_061.png" alt=""/> to all other nodes in the network. If <img src="image/Formula_01_062.png" alt=""/> is the shortest path between node <img src="image/Formula_01_063.png" alt=""/> and node <img src="image/Formula_01_064.png" alt=""/>, the closeness centrality is defined as follows:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/Formula_01_065.jpg" alt=""/>
				</div>
			</div>
			<p>Here, <em class="italic">V</em> is the set of nodes in the graph. Closeness centrality can be computed in <strong class="source-inline">networkx</strong> using the following command:</p>
			<p class="source-code">nx.closeness_centrality(G)</p>
			<p>The output <a id="_idIndexMarker118"/>should be as follows:</p>
			<p class="source-code">{1: 0.4, 2: 0.4, 3: 0.5454545454545454, 4: 0.6, 5: 0.5454545454545454, 6: 0.4, 7: 0.4}</p>
			<h3>Betweenness centrality</h3>
			<p>The <strong class="bold">betweenness centrality</strong> metric <a id="_idIndexMarker119"/>evaluates how much a node acts as a <strong class="bold">bridge</strong> between other nodes. Even if poorly connected, a node <a id="_idIndexMarker120"/>can be strategically connected, helping to keep the whole network connected.</p>
			<p>If <img src="image/Formula_01_066.png" alt=""/> is the total number of shortest paths between node <img src="image/Formula_01_067.png" alt=""/> and node <img src="image/Formula_01_068.png" alt=""/> and <img src="image/Formula_01_069.png" alt=""/> is the total number of shortest paths between <img src="image/Formula_01_070.png" alt=""/> and <img src="image/Formula_01_071.png" alt=""/> passing through node <img src="image/Formula_01_072.png" alt=""/>, then the betweenness centrality is defined as follows:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/Formula_01_073.jpg" alt=""/>
				</div>
			</div>
			<p>If we observe the formula, we can notice that the higher the number of shortest paths passing through node <img src="image/Formula_01_074.png" alt=""/>, the higher the value of the betweenness centrality. Betweenness centrality is computed in <strong class="source-inline">networkx</strong> by using the following command:</p>
			<p class="source-code">nx.betweenness_centrality(G)</p>
			<p>The output<a id="_idIndexMarker121"/> should be as follows:</p>
			<p class="source-code">{1: 0.0, 2: 0.0, 3: 0.5333333333333333, 4: 0.6, 5: 0.5333333333333333, 6: 0.0, 7: 0.0}</p>
			<p>In <em class="italic">Figure 1.17</em>, we illustrate the difference between <em class="italic">degree centrality</em>, <em class="italic">closeness centrality</em>, and <em class="italic">betweenness centrality</em>. <strong class="bold">Milan</strong> and <strong class="bold">Naples</strong> have the highest degree centrality. <strong class="bold">Rome</strong> has the highest closeness centrality since it is the closest to any other node. It also shows the<a id="_idIndexMarker122"/> highest betweenness centrality because of its crucial role in connecting the two visible clusters and keeping the whole network connected. </p>
			<p>You can see the differences here:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B16069_01_017.jpg" alt="Figure 1.17 – Degree centrality (left), closeness centrality (center), and betweenness centrality (right)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.17 – Degree centrality (left), closeness centrality (center), and betweenness centrality (right)</p>
			<p>Centrality metrics allow us to measure the importance of a node inside the network. Finally, we <a id="_idIndexMarker123"/>will mention resilience metrics, which<a id="_idIndexMarker124"/> enable us to measure the vulnerability of a graph.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor028"/>Resilience metrics</h2>
			<p>There are several metrics that <a id="_idIndexMarker125"/>measure a network's resilience. Assortativity is one of the most used.</p>
			<h3>Assortativity coefficient</h3>
			<p><strong class="bold">Assortativity</strong> is<a id="_idIndexMarker126"/> used to<a id="_idIndexMarker127"/> quantify the tendency of nodes being connected to similar nodes. There are several ways to measure such correlations. One of the most commonly used methods is the <strong class="bold">Pearson correlation coefficient</strong> between the degrees of directly connected<a id="_idIndexMarker128"/> nodes (nodes on two opposite ends of a link). The coefficient assumes positive values when there is a correlation between nodes of a similar degree, while it assumes negative values when there is a correlation between nodes of a different degree. Assortativity using the Pearson correlation coefficient is computed in <strong class="source-inline">networkx</strong> by using the following command:</p>
			<p class="source-code">nx.degree_pearson_correlation_coefficient(G)</p>
			<p>The output should be as follows:</p>
			<p class="source-code">-0.6</p>
			<p>Social networks are mostly assortative. However, the so-called <em class="italic">influencers</em> (famous singers, football players, fashion bloggers) tend to be <em class="italic">followed</em> (incoming edges) by several standard users, while tending to be connected with each other and showing a disassortative behavior.</p>
			<p>It is important to remark that the previously presented properties are a subset of all the possible metrics used to describe graphs. A wider set of metrics and algorithms can be found at <a href="https://networkx.org/documentation/stable/reference/algorithms/">https://networkx.org/documentation/stable/reference/algorithms/</a>.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor029"/>Benchmarks and repositories</h1>
			<p>Now that we have understood the basic concepts and notions about graphs and network analysis, it is now time to dive into some practical examples that will help us to start to put into practice the<a id="_idIndexMarker129"/> general concepts we have learned so far. In this section, we will present some examples and toy problems that are generally used to study the properties of networks, as well as benchmark<a id="_idIndexMarker130"/> performances and effectiveness of networks' algorithms. We will also provide some useful links of repositories where network datasets can be found and downloaded, together with some tips on how to parse and process them.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor030"/>Examples of simple graphs</h2>
			<p>We start by looking at <a id="_idIndexMarker131"/>some very simple examples of networks. Fortunately, <strong class="source-inline">networkx </strong>already comes with a number of graphs already implemented, ready to be used and played with. Let's start by <a id="_idIndexMarker132"/>creating a <strong class="bold">fully connected undirected graph</strong>, as follows:</p>
			<p class="source-code">complete = nx.complete_graph(n=7)</p>
			<p>This has <img src="image/Formula_01_075.png" alt=""/> edges and a clustering coefficient <em class="italic">C=1</em>. Although fully connected graphs are not very interesting on their own, they represent a fundamental building block that may arise within larger graphs. A fully connected subgraph of <em class="italic">n</em> nodes <a id="_idIndexMarker133"/>within a larger graph is generally referred to as a <strong class="bold">clique</strong> of size <em class="italic">n</em>. </p>
			<p class="callout-heading">Definition  </p>
			<p class="callout">A <strong class="bold">clique</strong>, <em class="italic">C</em>, in an undirected graph is defined a subset of its vertices, <em class="italic">C </em><img src="image/Formula_01_077.png" alt=""/><em class="italic"> V</em>, such that every two distinct vertices in the subset are adjacent. This is equivalent to the condition that the induced subgraph of <em class="italic">G</em> induced by <em class="italic">C</em> is a fully connected graph. </p>
			<p>Cliques represent one of the basic concepts in graph theory and are often also used in mathematical problems where relations need to be encoded. Besides, they also represent the simplest unit when constructing more complex graphs. On the other hand, the task of finding cliques of a given size <em class="italic">n</em> in larger graphs (clique problem) is of great interest and it can be shown that it is a <strong class="bold">nondeterministic polynomial-time complete</strong> (<strong class="bold">NP-complete</strong>) problem<a id="_idIndexMarker134"/> often studied in computer science.  </p>
			<p>Some simple examples of <strong class="source-inline">networkx</strong> graphs can be seen in the following screenshot:</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B16069_01_18.jpg" alt="Figure 1.18 – Simple examples of graphs with networkx. (left) fully connected graph; (center) lollipop graph; (right) barbell graph"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.18 – Simple examples of graphs with networkx: (left) fully connected graph; (center) lollipop graph; (right) barbell graph</p>
			<p>In <em class="italic">Figure 1.18</em>, we <a id="_idIndexMarker135"/>showed a complete graph along with two other simple examples containing cliques that can be easily generated with <strong class="source-inline">networkx</strong>, outlined as follows:</p>
			<ul>
				<li>A<strong class="bold"> lollipop graph</strong> formed by a<a id="_idIndexMarker136"/> clique of size <em class="italic">n</em> and a branch of <em class="italic">m</em> nodes, as shown in the following code snippet:<p class="source-code">lollipop = nx.lollipop_graph(m=7, n=3)</p></li>
				<li>A <strong class="bold">barbell graph</strong> formed <a id="_idIndexMarker137"/>by two cliques of size <em class="italic">m1</em> and <em class="italic">m2</em> joined by a branch of nodes, which resembles the sample graph we used previously to characterize some of the global and local properties. The code to generate this is shown in the following snippet:<p class="source-code">barbell = nx.barbell_graph(m1=7, m2=4)</p></li>
			</ul>
			<p>Such simple graphs are basic building blocks that can be used to generate more complex networks by combining them. Merging subgraphs is very easy with <strong class="source-inline">networkx</strong> and can be done with just a few lines of code, as shown in the following code snippet, where the three graphs are merged <a id="_idIndexMarker138"/>together into a single graph and some random edges are placed to connect them:</p>
			<p class="source-code">def get_random_node(graph):</p>
			<p class="source-code">    return np.random.choice(graph.nodes)</p>
			<p class="source-code">allGraphs = nx.compose_all([complete, barbell, lollipop])</p>
			<p class="source-code">allGraphs.add_edge(get_random_node(lollipop), get_random_node(lollipop))</p>
			<p class="source-code">allGraphs.add_edge(get_random_node(complete), get_random_node(barbell))</p>
			<p>Other very simple graphs (that can then be merged and played around with) can be found at <a href="https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.classic">https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.classic</a>.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor031"/>Generative graph models </h2>
			<p>Although <a id="_idIndexMarker139"/>creating simple subgraphs and merging them is a way to generate new graphs of increasing complexity, networks may also be generated by means of <strong class="bold">probabilistic models</strong> and/or <strong class="bold">generative models</strong> that let a graph grow by itself. Such graphs usually share interesting properties with real networks and have long been used to create benchmarks and synthetic graphs, especially in times when the amount of data available was not as overwhelming as today. Here, we present some examples of random generated graphs, briefly describing the models that underlie them.</p>
			<h3>Watts and Strogatz (1998)</h3>
			<p>This<a id="_idIndexMarker140"/> model was used by the<a id="_idIndexMarker141"/> authors to study the behavior of <strong class="bold">small-world networks</strong>—that is to say, networks that resemble, to some extent, common social networks. The graph is generated by first displacing <em class="italic">n</em> nodes in a ring and connecting each node with its <em class="italic">k</em> neighbors. Each edge of such a graph then has a probability <em class="italic">p</em> of being rewired to a randomly chosen node. By ranging <em class="italic">p</em>, the Watts and Strogatz<a id="_idIndexMarker142"/> model allows a shift from a regular network (<em class="italic">p=0</em>) to a completely random network (<em class="italic">p=1</em>). In between, graphs exhibit small-world features; that is, they tend to bring this model closer to social network graphs. These<a id="_idIndexMarker143"/> kinds of graphs can be easily created with the following command: </p>
			<p class="source-code">graph = nx.watts_strogatz_graph(n=20, k=5, p=0.2)</p>
			<h3>Barabási-Albert (1999)</h3>
			<p>The model proposed by <a id="_idIndexMarker144"/>Albert and Barabási is based on a generative model that allows the creation of random scale-free networks by using a <strong class="bold">preferential attachment</strong> schema, where <a id="_idIndexMarker145"/>a network is created by progressively <a id="_idIndexMarker146"/>adding new nodes and attaching them to already existing nodes, with a preference for nodes that have more neighbors. Mathematically speaking, the underlying idea of this model is that the probability for a new node to be attached to an existing node <em class="italic">i</em> depends on the degree of the <em class="italic">i</em>-th node, according to the following formula:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/Formula_01_076.jpg" alt=""/>
				</div>
			</div>
			<p>Thus, nodes with a large number of edges (hubs) tend to develop even more edges, whereas nodes with few links will not develop other links (periphery). Networks generated by this model exhibit a <em class="italic">power-law distribution</em> for the connectivity (that is, degree) between nodes. Such a behavior is also found in real networks (for example, the <strong class="bold">World Wide Web</strong> (<strong class="bold">WWW</strong>) network<a id="_idIndexMarker147"/> and the actor collaboration network), interestingly showing that it is the popularity of a node (how many edges it already has) rather than its intrinsic node properties that influences the creation of new connections. The initial model has then been extended (and this is the version that is available on <strong class="source-inline">networkx</strong>) to also allow the preferential attachment of new edges or rewiring of existing edges.</p>
			<p>The Barabási-Albert model is illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B16069_01_19.jpg" alt="Figure 1.19 – Barabási-Albert model (left) with 20 nodes (right) distribution of connectivity with n=100.000 nodes, showing the scale-free power law distribution"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.19 – Barabási-Albert model (left) with 20 nodes (right) distribution of connectivity with n=100.000 nodes, showing the scale-free power law distribution</p>
			<p>In <em class="italic">Figure 1.19</em>, we showed an <a id="_idIndexMarker148"/>example of the Barabasi-Albert model for a small network, where you can already observe the emergence of<a id="_idIndexMarker149"/> hubs (on the left), as well as the probability distribution of the degree of the nodes, which exhibits a scale-free power-law behavior (on the right). The preceding distribution can easily be replicated in <strong class="source-inline">networkx</strong>, as follows:</p>
			<p class="source-code">ba_model = nx.extended_barabasi_albert_graph(n,m=1,p=0,q=0)</p>
			<p class="source-code">degree = dict(nx.degree(ba_model)).values()</p>
			<p class="source-code">bins = np.round(np.logspace(np.log10(min(degree)), np.log10(max(degree)), 10))</p>
			<p class="source-code">cnt = Counter(np.digitize(np.array(list(degree)), bins))</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor032"/>Benchmarks</h2>
			<p>Digitalization has profoundly<a id="_idIndexMarker150"/> changed our lives, and today, any activity, person, or process generates data, providing a huge amount of information to be drilled, analyzed, and used to promote data-driven decision making. A few decades ago, it was hard to find datasets ready to be used to develop or test new algorithms. On the other hand, there exist today plenty of repositories that provide us with datasets, even of fairly large dimensions, to be downloaded and analyzed. These repositories, where people can share datasets, also provide a benchmark where algorithms can be applied, validated, and compared with each other. </p>
			<p>In this section, we will briefly go through some of the main repositories and file formats used in network science, in order to provide you with all the tools needed to import datasets—of different sizes—to analyze and play around with. </p>
			<p>In such repositories, you will find <a id="_idIndexMarker151"/>network datasets coming from some of the common areas of network science, such as social networks, biochemistry, dynamic networks, documents, co-authoring and citations networks, and networks arising from financial transactions. In <em class="italic">Part 3</em>, <em class="italic">Advanced Applications of Graph Machine Learning</em>, we will discuss some of the most common type of networks (social networks, graphs arising when processing corpus documents, and financial networks) and analyze them more thoroughly by applying the techniques and algorithms described in <em class="italic">Part 2</em>, <em class="italic">Machine Learning on Graphs</em>. </p>
			<p>Also, <strong class="source-inline">networkx</strong> already comes with some basic (and very small) networks that are generally used to explain algorithms and basic measures, which can be found at <a href="https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.social">https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.social</a>. These datasets are, however, generally quite small. For larger datasets, refer to the repositories we present next.</p>
			<h3>Network Data Repository</h3>
			<p>The <strong class="bold">Network Data Repository</strong> is <a id="_idIndexMarker152"/>surely one of the largest repositories of <a id="_idIndexMarker153"/>network data (<a href="http://networkrepository.com/">http://networkrepository.com/</a>) with several thousand different networks, featuring users and donations from all over the world and top-tier academic institutions. If a network dataset is freely available, chances are that you will find it there. Datasets are classified in about <em class="italic">30 domains</em>, including biology, economics, citations, social network data, industrial applications (energy, road), and many others. Besides providing the data, the website also provides a tool for interactive visualization, exploration, and comparison of datasets, and we suggest you check it out and explore it. </p>
			<p>The data in the Network Data Repository is generally available under the <strong class="bold">Matrix Market Exchange Format</strong> (<strong class="bold">MTX</strong>) file<a id="_idIndexMarker154"/> format. The MTX file format is basically a file format for specifying dense or sparse matrices, real or complex, via readable <a id="_idIndexMarker155"/>text files (<strong class="bold">American Standard Code for Information Interchange</strong>, or <strong class="bold">ASCII</strong>). For more details, please refer to <a href="http://math.nist.gov/MatrixMarket/formats.html#MMformat">http://math.nist.gov/MatrixMarket/formats.html#MMformat</a>.</p>
			<p>A file in MTX format can be easily read in Python using <strong class="source-inline">scipy</strong>. Some of the files we downloaded from the Network Data Repository seemed slightly corrupted and required a minimal fix on a 10.15.2 OSX system. In order to fix them, just make sure the header of the file is compliant with the format specifications; that is, with a double <strong class="source-inline">%</strong> and no spaces at the beginning of the line, as in the following line:</p>
			<p class="source-code">%%MatrixMarket matrix coordinate pattern symmetric </p>
			<p>Matrices should be in coordinate format. In this case, the specification points also to an unweighted, undirected graph (as understood by <strong class="source-inline">pattern</strong> and <strong class="source-inline">symmetric</strong>). Some of the files have some comments after the first header line, which are preceded by a single <strong class="source-inline">%</strong>.</p>
			<p>As an example, we consider <a id="_idIndexMarker156"/>the <strong class="bold">Astro Physics</strong> (<strong class="bold">ASTRO-PH</strong>) collaboration network. The graph is generated using all the scientific papers available from the e-print <em class="italic">arXiv</em> repository published in the <em class="italic">Astrophysics</em> category in the period from January 1993 to April 2003. The network is built by connecting (via undirected edges) all the authors that co-authored a publication, thus resulting in a clique that includes all authors of a given paper. The code to generate the graph can be seen here:</p>
			<p class="source-code">from scipy.io import mmread</p>
			<p class="source-code">adj_matrix = mmread("ca-AstroPh.mtx")</p>
			<p class="source-code">graph = nx.from_scipy_sparse_matrix(adj_matrix)</p>
			<p>The dataset has 17,903 nodes, connected by 196,072 edges. Visualizing so many nodes cannot be done easily, and even if we were to do it, it might not be very informative, as understanding the underlying structure would not be very easy with so much information. However, we can get some insights by looking at specific subgraphs, as we will do next. </p>
			<p>First, we can start by computing some basic properties we described earlier and put them into a pandas <strong class="source-inline">DataFrame</strong> for our convenience to later use, sort, and analyze. The code to accomplish this is illustrated in the following snippet: </p>
			<p class="source-code">stats = pd.DataFrame({</p>
			<p class="source-code">    "centrality": nx.centrality.betweenness_centrality(graph), </p>
			<p class="source-code">    "C_i": nx.clustering(graph), </p>
			<p class="source-code">    "degree": nx.degree(graph)</p>
			<p class="source-code">})</p>
			<p>We can easily find out that the node with the<a id="_idIndexMarker157"/> largest <strong class="bold">degree centrality</strong> is the one with ID <strong class="source-inline">6933</strong>, which has 503 neighbors (surely a very popular and important scientist in astrophysics!), as illustrated in the following code snippet:</p>
			<p class="source-code">neighbors = [n for n in nx.neighbors(graph, 6933)]</p>
			<p>Of course, also plotting<a id="_idIndexMarker158"/> its <strong class="bold">ego network</strong> (the node with all its neighbors) would still be a bit messy. One way to produce some subgraphs that can be plotted is by sampling (for example, with a 0.1 ratio) its neighbors in three different ways: random (sorting by index is a sort of random sorting), selecting the most central neighbors, or selecting the neighbors with the largest <strong class="source-inline">C_i</strong> values. The code to accomplish this is shown in the following code snippet:</p>
			<p class="source-code">nTop = round(len(neighbors)*sampling)</p>
			<p class="source-code">idx = {</p>
			<p class="source-code">    "random": stats.loc[neighbors].sort_index().index[:nTop], </p>
			<p class="source-code">    "centrality": stats.loc[neighbors]\</p>
			<p class="source-code">         .sort_values("centrality", ascending=False)\</p>
			<p class="source-code">         .index[:nTop],</p>
			<p class="source-code">    "C_i": stats.loc[neighbors]\</p>
			<p class="source-code">         .sort_values("C_i", ascending=False)\</p>
			<p class="source-code">         .index[:nTop]</p>
			<p class="source-code">}</p>
			<p>We can then define a simple function for extracting and plotting a subgraph that includes only the nodes related to certain indices, as shown in the following code snippet: </p>
			<p class="source-code">def plotSubgraph(graph, indices, center = 6933):</p>
			<p class="source-code">    nx.draw_kamada_kawai(</p>
			<p class="source-code">        nx.subgraph(graph, list(indices) + [center])</p>
			<p class="source-code">    )</p>
			<p>Using the preceding function, we can plot the different subgraphs, obtained by filtering the ego network using the three different criteria, based on random sampling, centrality, and the clustering coefficient we presented previously. An example is provided here:</p>
			<p class="source-code">plotSubgraph(graph, idx["random"]) </p>
			<p>In <em class="italic">Figure 1.20</em>, we <a id="_idIndexMarker159"/>compare these results where the other networks have been obtained by changing the key value to <strong class="source-inline">centrality</strong> and <strong class="source-inline">C_i</strong>. The random representation seems to show some emerging structure with separated communities. The graph with the most central nodes clearly shows an almost fully connected network, possibly made up of all full professors and influential figures in astrophysics science, publishing on multiple topics and collaborating frequently with each other. Finally, the last representation, on the other hand, highlights some specific communities, possibly connected with a specific topic, by selecting the nodes that have a higher clustering coefficient. These nodes might not have a large degree of centrality, but they very well represent specific topics. You can see examples of the ego subgraph here:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B16069_01_20.jpg" alt="Figure 1.20 – Examples of the ego subgraph for the node that has largest degree in the ASTRO-PH dataset. Neighbors are sampled with a ratio=0.1. (left) random sampling; (center) nodes with largest betweenness centrality; (right) nodes with largest clustering coefficient"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.20 – Examples of the ego subgraph for the node that has largest degree in the ASTRO-PH dataset. Neighbors are sampled with a ratio=0.1. (left) random sampling; (center) nodes with largest betweenness centrality; (right) nodes with largest clustering coefficient</p>
			<p>Another option to visualize this in <strong class="source-inline">networkx</strong> could also be to use the <em class="italic">Gephi</em> software that allows for fast filtering and visualizations of graphs. In order to do so, we need to first export the data<a id="_idIndexMarker160"/> as <strong class="bold">Graph Exchange XML Format</strong> (<strong class="bold">GEXF</strong>) (which is a file format that can be imported in Gephi), as follows:</p>
			<p class="source-code">nx.write_gext(graph, "ca-AstroPh.gext")</p>
			<p>Once data is imported in Gephi, with few filters (by centrality or degree) and some computations (modularity), you can easily do plots as nice as the one shown in <em class="italic">Figure 1.21</em>, where nodes have been colored using modularity in order to highlight clusters. Coloring also allows us to easily spot nodes that connect the different communities and that therefore have large betweenness. </p>
			<p>Some of the datasets in the Network Data Repository may also be available in the <strong class="bold">EDGE file format</strong> (for instance, the citations networks). The EDGE file format <a id="_idIndexMarker161"/>slightly differs from the MTX file format, although it represents the same information. Probably the easiest way to import such files into <strong class="source-inline">networkx</strong> is to convert them by simply rewriting its header. Take, for instance, the <strong class="bold">Digital Bibliography and Library</strong> (<strong class="bold">DBLP</strong>) citation<a id="_idIndexMarker162"/> network. </p>
			<p>A sample plot can be<a id="_idIndexMarker163"/> seen in the following screenshot:</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B16069_01_21.jpg" alt="Figure 1.21 – Example of the visualization ASTRO-PH dataset with Gephi. Nodes are filtered by degree centrality and colored by modularity class; node sizes are proportional to the value of the degree"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.21 – Example of the visualization ASTRO-PH dataset with Gephi. Nodes are filtered by degree centrality and colored by modularity class; node sizes are proportional to the value of the degree</p>
			<p>Here is the code<a id="_idIndexMarker164"/> for the header of the file: </p>
			<p class="source-code">% asym unweighted</p>
			<p class="source-code">% 49743 12591 12591 </p>
			<p>This can be easily converted to comply with the MTX file format by replacing these lines with the following code:</p>
			<p class="source-code">%%MatrixMarket matrix coordinate pattern general</p>
			<p class="source-code">12591 12591 49743 </p>
			<p>Then, you can use the import functions described previously. </p>
			<h3>Stanford Large Network Dataset Collection</h3>
			<p>Another valuable <a id="_idIndexMarker165"/>source of network datasets is the website of the <strong class="bold">Stanford Network Analysis Platform</strong> (<strong class="bold">SNAP</strong>) (<a href="https://snap.stanford.edu/index.html">https://snap.stanford.edu/index.html</a>), which<a id="_idIndexMarker166"/> is a general-purpose network analysis library that was written in order to handle even fairly large graphs, with hundreds of millions of nodes and billions of edges. It is written in <em class="italic">C++</em> to achieve top computational performance, but it also features interfaces with Python in order to be imported and used in native Python applications. </p>
			<p>Although <strong class="source-inline">networkx</strong> is currently the main library to study <strong class="source-inline">networkx</strong>, SNAP or other libraries (more on this shortly) can be orders of magnitude faster than <strong class="source-inline">networkx</strong>, and they may be used in place of <strong class="source-inline">networkx</strong> for tasks that require higher performance. In the SNAP website, you will find a specific web page<a id="_idIndexMarker167"/> for <strong class="bold">Biomedical Network Datasets</strong> (<a href="https://snap.stanford.edu/biodata/index.html">https://snap.stanford.edu/biodata/index.html</a>), besides other more general networks (<a href="https://snap.stanford.edu/data/index.html">https://snap.stanford.edu/data/index.html</a>), covering similar domains and datasets as the Network Data Repository described previously. </p>
			<p>Data is generally provided in a <strong class="bold">text file format</strong> containing a list of edges. Reading such files can be done with <strong class="source-inline">networkx</strong> in one code line, using the following command:</p>
			<p class="source-code">g = nx.read_edgelist("amazon0302.txt")</p>
			<p>Some graphs might have extra information, other than about edges. Extra information is included in the archive of the dataset as a separated file—for example, where some metadata of the nodes is provided and is related to the graph via the <em class="italic">id</em> node. </p>
			<p>Graphs can also be read directly using the SNAP library and its interface via Python. If you have a working version of SNAP on your local machine, you can easily read the data as follows:</p>
			<p class="source-code">from snap import LoadEdgeList, PNGraph</p>
			<p class="source-code">graph = LoadEdgeList(PNGraph, "amazon0302.txt", 0, 1, '\t')</p>
			<p>Keep in mind that at this point, you will have an instance of a <strong class="source-inline">PNGraph</strong> object of the SNAP library, and you can't directly use <strong class="source-inline">networkx</strong> functionalities on this object. If you want to use some <strong class="source-inline">networkx</strong> functions, you first need to convert the <strong class="source-inline">PNGraph</strong> object to a <strong class="source-inline">networkx</strong> object. To make this process simpler, in the supplementary material for this book (available at <a href="https://github.com/PacktPublishing/Graph-Machine-Learning">https://github.com/PacktPublishing/Graph-Machine-Learning</a>), we have written some functions that will allow you to seamlessly swap back and forth between <strong class="source-inline">networkx</strong> and SNAP, as illustrated in the following code snippet:</p>
			<p class="source-code">networkx_graph = snap2networkx(snap_graph)</p>
			<p class="source-code">snap_graph = networkx2snap(networkx_graph) </p>
			<h3>Open Graph Benchmark</h3>
			<p>This is the most recent update (dated May 2020) in the graph benchmark landscape, and this repository is expected to gain increasing importance and support in the coming years. The <strong class="bold">Open Graph Benchmark</strong> (<strong class="bold">OGB</strong>) has <a id="_idIndexMarker168"/>been created to address one specific issue: current benchmarks are actually too small compared to real applications to be useful for <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>) advances. On one hand, some of the models developed on small datasets turn out to not be able to scale to large datasets, proving them unsuitable in real-world applications. On the other hand, large datasets also allow us to increase the capacity (complexity) of the models used in ML tasks and explore new algorithmic solutions (such as neural networks) that can benefit from a large sample size to be efficiently trained, allowing us to achieve very high performance. The datasets belong to diverse domains and they have been ranked on three different dataset sizes (small, medium, and large) where the small-size graphs, despite their name, already have more than 100,000 nodes and/or more than 1 million edges. On the other hand, large graphs feature networks with more than 100 million nodes and more than 1 billion edges, facilitating the development of scalable models. </p>
			<p>Beside the datasets, the OGB also provides, in a <em class="italic">Kaggle fashion</em>, an end-to-end ML pipeline that standardizes the data loading, experimental setup, and model evaluation. OGB creates a platform to compare and evaluate models against each other, publishing a <em class="italic">leaderboard</em> that allows tracking of the performance evolution and advancements on specific tasks of node, edge, and graph property prediction. For more details on the datasets and on the OGB project, please refer to <a href="https://arxiv.org/pdf/2005.00687.pdf">https://arxiv.org/pdf/2005.00687.pdf</a>.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor033"/>Dealing with large graphs</h1>
			<p>When approaching a use<a id="_idIndexMarker169"/> case or an analysis, it is very important to understand how large the data we focus on is or will be in the future, as the dimension of the datasets may very well impact both the technologies we use and the analysis that we can do. As already mentioned, some of the approaches that have been developed on small datasets hardly scale to real-world applications and larger datasets, making them useless in practice. </p>
			<p>When dealing with (possibly) large graphs, it is crucial to understand potential bottlenecks and limitation of the tools, technologies, and/or algorithms we use, assessing which part of our application/analysis may not scale when increasing the number of nodes or edges. Even more importantly, it is crucial to structure a data-driven application, however simple or at <a id="_idIndexMarker170"/>early <strong class="bold">proof of concept</strong> (<strong class="bold">POC</strong>) stages, in a way that would allow its scaling out in the future when data/users would increase, without rewriting the whole application. </p>
			<p>Creating a <a id="_idIndexMarker171"/>data-driven application that resorts to graphical representation/modeling is a challenging task that requires a design and implementation that is a lot more complicated than simply importing <strong class="source-inline">networkx</strong>. In particular, it is often useful to decouple the component that processes the graph—named <strong class="bold">graph processing engine</strong>—from <a id="_idIndexMarker172"/>the one that allows querying and traversing <a id="_idIndexMarker173"/>the graph—the <strong class="bold">graph storage layer</strong>. We will further discuss these concepts in <a href="B16069_09_Final_JM_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 9</em></a>, <em class="italic">Building a Data-Driven Draft-Powered Application</em>. Nevertheless, given the focus of the book on ML and analytical techniques, it makes sense to focus more on graph processing engines than on graph storage layers. We therefore find it useful to provide you already at this stage with some of the technologies that are used for graph processing engines to deal with large graphs, crucial when scaling out an application. </p>
			<p>In this respect, it is important to classify graph processing engines into two categories (that impact the tools/libraries/algorithms to be used), depending whether the graph can fit a <em class="italic">shared memory machine</em> or requires <em class="italic">distributed architectures</em> to be processed and analyzed.</p>
			<p>Note that there is no absolute definition of large and small graphs, but it also depends on the chosen architecture. Nowadays, thanks to the vertical scaling of infrastructures, you can find servers with <strong class="bold">random-access memory</strong> (<strong class="bold">RAM</strong>) larger than 1 <strong class="bold">terabyte</strong> (<strong class="bold">TB</strong>) (usually called <em class="italic">fat nodes</em>), and with tens of thousands of <strong class="bold">central processing units</strong> (<strong class="bold">CPUs</strong>) for multithreading in most cloud-provider offerings, although these infrastructures might not be economically viable. Even without scaling out to such extreme architectures, graphs with millions of nodes and tens of millions of edges can nevertheless be easily handled in single servers with ~100 <strong class="bold">gigabytes</strong> (<strong class="bold">GB</strong>) of RAM and ~50 CPUs. </p>
			<p>Although <strong class="source-inline">networkx</strong> is a<a id="_idIndexMarker174"/> very popular, user-friendly, and intuitive library, when scaling out to such reasonably large graphs it may not be the best available choice. <strong class="source-inline">networkx</strong>, being natively written in pure Python, which is an interpreted language, can be substantially outperformed by other graph engines fully or partly written in more performant programming languages (such as C++ and Julia) and that make use of multithreading, such as the following: </p>
			<ul>
				<li><strong class="bold">SNAP</strong> (<a href="http://snap.stanford.edu/">http://snap.stanford.edu/</a>), which <a id="_idIndexMarker175"/>we have already seen in the previous section, is a graph engine developed at Stanford and is written in C++ with available bindings in Python.</li>
				<li><strong class="bold">igraph</strong> (<a href="https://igraph.org/">https://igraph.org/</a>) is a C<a id="_idIndexMarker176"/> library and features bindings in Python, R, and Mathematica.</li>
				<li><strong class="bold">graph-tool</strong> (<a href="https://graph-tool.skewed.de/">https://graph-tool.skewed.de/</a>), despite being a Python module, has core algorithms and <a id="_idIndexMarker177"/>data-structures written in C++ and uses OpenMP parallelization to scale on multi-core architectures.</li>
				<li><strong class="bold">NetworKit</strong> (<a href="https://networkit.github.io/">https://networkit.github.io/</a>) is also written in C++ with OpenMP boost for parallelization for <a id="_idIndexMarker178"/>its core functionalities, integrated in a Python module.</li>
				<li><strong class="bold">LightGraphs</strong> (<a href="https://juliagraphs.org/LightGraphs.jl/latest/">https://juliagraphs.org/LightGraphs.jl/latest/</a>) is a library written in Julia that aims <a id="_idIndexMarker179"/>to mirroring <strong class="source-inline">networkx</strong> functionalities in a more performant and robust library.</li>
			</ul>
			<p>All the preceding libraries are valid alternatives to <strong class="source-inline">networkx</strong> when achieving better performance becomes an issue. Improvements can be very substantial, with speed-ups varying from 30 to 300 times faster, with the best performance generally achieved by LightGraphs. </p>
			<p>In the forthcoming chapters, we will mostly focus on <strong class="source-inline">networkx</strong> in order to provide a consistent presentation and provide the user with basic concepts on network analysis. We want you to be aware that other options are available, as this becomes extremely relevant when pushing the edge from a performance standpoint.  </p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor034"/>Summary </h1>
			<p>In this chapter, we refreshed concepts such as graphs, nodes, and edges. We reviewed graph <em class="italic">representation</em> methods and explored how to <em class="italic">visualize</em> graphs. We also defined <em class="italic">properties</em> that are used to characterize networks, or parts of them.</p>
			<p>We went through a well-known Python library to deal with graphs, <strong class="source-inline">networkx</strong>, and learned how to use it to apply theoretical concepts in practice.</p>
			<p>We then ran examples and toy problems that are generally used to study the properties of networks, as well as benchmark performance and effectiveness of network algorithms. We also provided you with some useful links of repositories where network datasets can be found and downloaded, together with some tips on how to parse and process them.</p>
			<p>In the next chapter, we will go beyond defining notions of ML on graphs. We will learn how more advanced and latent properties can be automatically found by specific ML algorithms.</p>
		</div>
	</body></html>