- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: ARIMA Models
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARIMA模型
- en: In this chapter, we will discuss univariate time series models. These are models
    that only consider a single variable and create forecasts based only on the previous
    samples in the time series. We will start by looking at models for stationary
    time series data and then progress to models for non-stationary time series data.
    We will also discuss how to identify appropriate models based on the characteristics
    of time series. This will provide a powerful set of models for forecasting time
    series.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论单变量时间序列模型。这些模型只考虑一个变量，并仅基于时间序列中的先前样本创建预测。我们将首先查看平稳时间序列数据的模型，然后过渡到非平稳时间序列数据的模型。我们还将讨论如何根据时间序列的特征识别适当的模型。这将提供一组强大的模型，用于时间序列预测。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Models for stationary time series
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定时间序列模型
- en: Models for non-stationary time series
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非平稳时间序列模型
- en: More on model evaluation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型评估的更多内容
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we use two additional Python libraries for time series analysis:
    `sktime` and `pmdarima`. Please install the following versions of these libraries
    to run the provided code. Instructions for installing libraries can be found in
    [*Chapter 1*](B18945_01.xhtml#_idTextAnchor015), *Sampling* *and Generalization*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用两个额外的Python库进行时间序列分析：`sktime`和`pmdarima`。请安装以下版本的这些库以运行提供的代码。有关安装库的说明，请参阅[*第1章*](B18945_01.xhtml#_idTextAnchor015)，*采样*
    *和泛化*。
- en: '`sktime==0.15.0`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sktime==0.15.0`'
- en: '`pmdarima==2.02`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pmdarima==2.02`'
- en: 'More information about `sktime` can be found at this link: [https://www.sktime.org/en/stable/get_started.xhtml](https://www.sktime.org/en/stable/get_started.xhtml)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`sktime`的更多信息可以在以下链接中找到：[https://www.sktime.org/en/stable/get_started.xhtml](https://www.sktime.org/en/stable/get_started.xhtml)
- en: 'More information about `pmdarima` can be found at this link: [http://alkaline-ml.com/pmdarima/](http://alkaline-ml.com/pmdarima/)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`pmdarima`的更多信息可以在以下链接中找到：[http://alkaline-ml.com/pmdarima/](http://alkaline-ml.com/pmdarima/)
- en: Models for stationary time series
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稳定时间序列模型
- en: In this section, we will discuss **Autoregressive** (**AR**), **Moving Average**
    (**MA**), and **Autoregressive Moving Average** (**ARMA**) models that are useful
    for stationary data. These models are useful when modeling patterns and variance
    around process means that output over time. *When we have data that does not exhibit
    autocorrelation, we can use statistical and machine learning models that do not
    make assumptions about time, such as Logistic Regression or Naïve Bayes, so long
    as the data supports such* *use cases*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论对平稳数据有用的**自回归**（**AR**）、**移动平均**（**MA**）和**自回归移动平均**（**ARMA**）模型。这些模型在建模过程均值周围的模式和方差时很有用。*当我们有不具有自相关性的数据时，我们可以使用不假设时间的统计和机器学习模型，例如逻辑回归或朴素贝叶斯，只要数据支持此类*
    *用例*。
- en: Autoregressive (AR) models
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自回归（AR）模型
- en: The AR(p) model
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AR(p)模型
- en: 'In [*Chapter 10*](B18945_10.xhtml#_idTextAnchor160), *Introduction to Time
    Series* we considered how the **Partial Auto-Correlation Function** (**PACF**)
    correlates one data point to another lag, controlling for those lags between.
    We also discussed how inspection of the PACF plot is a frequently used method
    for assessing the ordering of an autoregressive model. Thereto, the autoregressive
    model is one that considers specific points in the past to be directly correlated
    to the value of a given point at lag zero. Suppose we have a process y t with
    random, normally distributed white noise, ϵ t, where t = ± 1, ± 2, …. If – using
    real constants of ϕ 1, ϕ 2, … , ϕ p where ϕ p ≠ 0 – we can formulate the process
    in the following way:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B18945_10.xhtml#_idTextAnchor160)，*时间序列简介*中，我们考虑了**偏自相关函数**（**PACF**）如何将一个数据点与另一个滞后点相关联，同时控制这些滞后点之间的差异。我们还讨论了检查PACF图是评估自回归模型顺序的常用方法。因此，自回归模型是一种考虑过去特定点与零滞后给定点的值直接相关的模型。假设我们有一个具有随机、正态分布的白色噪声的过程y t，ϵ t，其中t
    = ± 1，± 2，……。如果我们使用实常数ϕ 1，ϕ 2，……，ϕ p（其中ϕ p ≠ 0）来制定过程，我们可以以下述方式制定过程：
- en: y t − μ − ϕ 1(y t−1 − μ) − ϕ 2(y t−2 − μ) − … − ϕ p(y p − μ) = ϵ t
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: y t − μ − ϕ 1(y t−1 − μ) − ϕ 2(y t−2 − μ) − … − ϕ p(y p − μ) = ϵ t
- en: 'Letting μ represent the overall process sample mean (in our examples, we will
    consider **zero-mean** processes), we can consider this to be an autoregressive
    process of order *p*, or AR(p) [*1*]. We can define the autocorrelation for the
    AR(p) model as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让μ代表整体过程样本均值（在我们的例子中，我们将考虑**零均值**过程），我们可以将其视为一个*p*阶自回归过程，或AR(p) [*1*]。我们可以定义AR(p)模型的自相关如下：
- en: ρ k = ϕ 1 |k|
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ρ k = ϕ 1 |k|
- en: 'There is also this example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 还有这个例子：
- en: ρ k = ϕ 1 ρ k−1 + … + ϕ p ρ k−p
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ρ k = ϕ 1 ρ k−1 + … + ϕ p ρ k−p
- en: In the preceding example, where ρ k is the lag *k* autocorrelation. ϕ 1 is both
    the slope and autocorrelation for an AR(1) process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，其中ρ k是滞后*k*自相关。ϕ 1是AR(1)过程的斜率和自相关。
- en: AR(p) model structure and components
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: AR(p)模型结构和组件
- en: To prevent confusion, note that with the equation y t − μ − ϕ 1(y t−1 − μ) −
    ϕ 2(y t−2 − μ) − … − ϕ p(y p − μ) = ϵ t we are attempting to build a mathematical
    model that represents the process such that if perfectly modeled, all that remains
    is the random, normally distributed white noise, ϵ t. This effectively means the
    model leaves zero residual error (in other words, a perfect fit). Each y t−k term
    – where *k* is a lag in time – represents the value at that point in time and
    each corresponding value of ϕ is the coefficient value required for the y t−k
    such that when taken in combination with all other values of *y*, the model statistically
    approximates zero error.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆，请注意，在方程y t − μ − ϕ 1(y t−1 − μ) − ϕ 2(y t−2 − μ) − … − ϕ p(y p − μ) =
    ϵ t中，我们试图构建一个数学模型来表示过程，如果完美建模，则剩下的只是随机、正态分布的白噪声，ϵ t。这实际上意味着模型留下零残差误差（换句话说，是一个完美的拟合）。每个y t−k项（其中*k*是时间滞后）代表该时间点的值，每个相应的φ值是y t−k所需的系数值，当与其他所有*y*值结合时，模型统计上近似零误差。
- en: The AR(1) model
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AR(1)模型
- en: 'The **backshift operator notation**, or simply **operator notation**, is a
    simplified, shorthand method of formulating models. It is called “backshift” because
    it shifts time back one lag from *t* to *t-1*. The purpose is to avoid the necessitation
    of writing the subscript (y t−k) following every φ coefficient and instead writing
    B k−1 while including only y t once, which is handy when writing AR(p) models
    with high orders of *p*. In the following equation, the zero-mean form of an AR(1)
    follows the following structure:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**后移算子符号**，或简称**算子符号**，是一种简化的、简写的方法来制定模型。它被称为“后移”，因为它将时间向后移动一个滞后，从*t*到*t-1*。其目的是避免在每一个φ系数后面都写上下标(y t−k)，而是写上B k−1，同时只包括一次y t，这在编写高阶*p*的AR(p)模型时很方便。在以下方程中，AR(1)的零均值形式遵循以下结构：'
- en: y t − μ − ϕ 1(y t−1 − μ) = ϵ t
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: y t − μ − ϕ 1(y t−1 − μ) = ϵ t
- en: 'The equation reduces to the following example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 方程简化为以下示例：
- en: y t − ϕ 1(y t−1) = ϵ t
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: y t − ϕ 1(y t−1) = ϵ t
- en: 'In backshift operator notation, we can say this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在后移算子符号中，我们可以这样说：
- en: ( 1 − ϕ 1 B)y t = 𝝐 t
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ( 1 − ϕ 1 B)y t = 𝝐 t
- en: Note on |𝝓 1| in an AR(1)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关于AR(1)中的|𝝓 1|的注释
- en: It’s worth noting at this point that an AR(1) process is stationary if |ϕ 1|
    < 1\. That is, when the absolute value of the lag-one autocorrelation is < 1,
    the AR(1) process is stationary. When |ϕ 1| = 1, an ARIMA model may still be useful,
    but when |ϕ 1| > 1, the process is considered to be explosive and should not be
    modeled. This is because a value |ϕ 1| < 1 means the root is outside of, and not
    bounded by, the unit circle. A value of |ϕ 1| = 1 is on the unit circle but can
    be differenced to remove the unit root. The root for the case of an AR(1) can
    be calculated as z = 1/ϕ 1\. A set of data producing |ϕ 1| > 1 cannot be filtered
    in a way that puts its root outside the unit circle.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上值得注意，如果|ϕ 1| < 1，则AR(1)过程是平稳的。也就是说，当滞后一阶自相关系数的绝对值小于1时，AR(1)过程是平稳的。当|ϕ 1|
    = 1时，ARIMA模型可能仍然有用，但当|ϕ 1| > 1时，该过程被认为是爆炸性的，不应进行建模。这是因为|ϕ 1| < 1的值意味着根位于单位圆之外，而不是被单位圆所限制。|ϕ 1|
    = 1的值位于单位圆上，但可以通过差分来消除单位根。AR(1)情况的根可以计算为z = 1/ϕ 1。产生|ϕ 1| > 1的数据集不能以使其根位于单位圆之外的方式进行过滤。
- en: When all roots of an AR(p) are outside the unit circle, the given realization
    (one time series sampled from a stochastic process) will converge to the mean,
    have constant variance, and be independent of time. This is an ideal scenario
    for time series data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当AR(p)的所有根都位于单位圆之外时，给定的实现（从随机过程中抽取的一个时间序列样本）将收敛到均值，具有恒定的方差，并且与时间无关。这是时间序列数据的一个理想场景。
- en: 'Let’s walk through an example of an AR(1) process with |ϕ 1| < 1 and therefore
    a stationary root. Assume we have identified the following first-order autoregressive
    process:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个AR(1)过程的例子来探讨，其中|ϕ_1| < 1，因此有一个平稳根。假设我们已经识别了以下一阶自回归过程：
- en: y t − 0.5 y t−1 = ϵ t
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: y_t − 0.5 y_{t−1} = ϵ_t
- en: 'This is converted to operator notation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这被转换为算子符号：
- en: (1 − 0.5B) y t = ϵ t
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: (1 − 0.5B) y_t = ϵ_t
- en: 'When looking for roots, we can use the following notation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当寻找根时，我们可以使用以下符号：
- en: (1 − 0.5z) = 0
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: (1 − 0.5z) = 0
- en: 'This gives us a root of *z*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了*z*的根：
- en: z =  1 _ ϕ 1  =  1 _ 0.5  = 2
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: z = 1 / ϕ_1 = 1 / 0.5 = 2
- en: 'Therefore, since the root is greater than 1 and thus outside the unit circle,
    the AR(1) representation of the process is stationary. In Python, we can build
    this process using the upcoming code. First, we build the AR(1) parameters, which
    we want to have a 0.5\. Because we substitute 0.5 into the model X t − ϕ 1(y t−1)
    = ϵ t, we insert *0.5* and not *-0.5* for `arparams`. Also, note based on ρ k
    = ϕ 1 |k| that *0.5* is the lag-1 autocorrelation. The process we build will have
    an arbitrary sample size of `nsample=200`. We build the (1 − 0.5B) component of
    (1 − 0.5B) y t = ϵ t using the `np.r_[1, -``arparams]` step:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于根大于1并且因此位于单位圆外，该过程的AR(1)表示是平稳的。在Python中，我们可以使用即将到来的代码构建此过程。首先，我们构建AR(1)参数，我们希望它为0.5。因为我们把0.5代入模型X_t
    − ϕ_1(y_{t−1}) = ϵ_t，所以我们插入*0.5*而不是*-0.5*作为`arparams`。另外，根据ρ_k = ϕ_1|k|，*0.5*是滞后1的自相关。我们构建的过程将具有任意的样本大小`nsample=200`。我们使用`np.r_[1,
    -arparams]`步骤构建(1 − 0.5B)的(1 − 0.5B) y_t = ϵ_t部分：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that we have the code to create the AR(1) we looked at the equation for,
    let’s see the roots and compare it to our manually calculated *z*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了创建我们查看的AR(1)方程的代码，让我们看看根并与我们手动计算的*z*进行比较：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`array([2.])`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`array([2.])`'
- en: 'We can see the Python output, `2.` is the same as the calculation we performed.
    We know that since the absolute value of the root is greater than 1, the AR(1)
    process is stationary, but let’s confirm with Python:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Python输出`2.`与我们进行的计算相同。我们知道，由于根的绝对值大于1，AR(1)过程是平稳的，但让我们用Python来确认：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`True`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`True`'
- en: 'We can observe by looking at the PACF that this is an autoregressive of order
    p = 5\. We can also observe by looking at the ACF that the value of ϕ 1 is approximately
    0.5\. For an autoregressive model, the PACF is used to identify the number of
    significant lags to include as the order of the AR, and the ACF is used to determine
    the values of the coefficients, ϕ k, included in that order. It is simple to observe
    the values for an AR(1) using the ACF, but less obvious when p > 1 since ACF does
    not control for individual lags when compared to the most recent point (lag zero)
    as the PACF does. Let’s generate the plots with Python:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察PACF，我们可以观察到这是一个p = 5的自回归。我们还可以通过观察ACF观察到ϕ_1的值大约为0.5。对于自回归模型，PACF用于确定作为AR阶数的显著滞后数量，ACF用于确定包含在该阶数中的系数，ϕ_k的值。使用ACF观察AR(1)的值很简单，但当p
    > 1时不太明显，因为ACF与最接近的点（滞后0）相比，不控制单个滞后，而PACF则控制。让我们用Python生成这些图：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Figure 11.1 – The AR(1) process](img/B18945_11_001.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – AR(1)过程](img/B18945_11_001.jpg)'
- en: Figure 11.1 – The AR(1) process
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – AR(1)过程
- en: Common for AR(1) processes, we see in *Figure 11**.1* a single significant partial
    autocorrelation in the PACF plot, excluding lag zero. Note there is some significance
    as we near lag 45, but because of the insignificance between lag 1 and those points,
    including those lags and constructing something such as an AR(50) would result
    in extreme overfitting; the coefficients from lag 2 through roughly lag 45 would
    fall between roughly 0 and ± 0.15\. As referenced in [*Chapter 4*](B18945_04.xhtml#_idTextAnchor070),
    *Parametric Tests*, the correlation between about ± 0.1 and ± 0.3 is generally
    considered a weak correlation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AR(1)过程，我们在*图11.1*中看到，除了滞后0之外，PACF图上只有一个显著的偏自相关。注意，当我们接近滞后45时，有一些显著性，但由于滞后1和这些点之间的不显著性，包括这些滞后并构建如AR(50)之类的模型会导致极端过拟合；从滞后2到大约滞后45的系数将介于大约0和±0.15之间。如[*第4章*](B18945_04.xhtml#_idTextAnchor070)中所述，*参数检验*，大约±0.1和±0.3之间的相关性通常被认为是一种弱相关性。
- en: The AR(2) model
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AR(2)模型
- en: 'Let’s look at the following stationary AR(2) process:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下平稳AR(2)过程：
- en: y t − 0.8 y t−1 − 0.48 y t−2 = ϵ t
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: y_t − 0.8 y_{t−1} − 0.48 y_{t−2} = ϵ_t
- en: 'Converted to backshift operator notation, we have the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为后移算子符号，我们得到以下内容：
- en: (1 − 0.8B − 0.48 B 2) y t = ϵ t
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: (1 − 0.8B − 0.48 B²) y_t = ϵ_t
- en: 'We also have this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有以下内容：
- en: (1 − 0.8z − 0.48 z 2) = 0
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: (1 − 0.8z − 0.48 z²) = 0
- en: 'Since we’re focusing on Python in this book, we won’t walk through the steps,
    but it may be useful to know second-order polynomials – such as AR(2) – follow
    the quadratic equation, a x 2 + bx + c (− 0.48 z 2 − 0.8z + 1 for our process).
    Therefore, we can use the quadratic formula:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这本书中专注于 Python，我们不会详细介绍步骤，但了解二次多项式（如 AR(2)）遵循二次方程 a x² + bx + c（对于我们的过程是
    -0.48 z² − 0.8z + 1）可能是有用的。因此，我们可以使用二次公式：
- en: − b ± √ _ b 2 − 4ac   ___________ 2a
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: − b ± √ b² − 4ac   ___________ 2a
- en: 'This is what we’ll use to find the roots. In Python, we can find the roots
    of this model using the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们用来找到根的依据。在 Python 中，我们可以使用以下方法找到该模型的根：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here we can see the unit roots identified using the `statmodels` ArmaProcess
    function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到使用 `statmodels` ArmaProcess 函数识别的单位根：
- en: '`AR(2) Roots: [-``0.83333333-1.1785113j -0.83333333+1.1785113j]`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`AR(2) 根：[-0.83333333-1.1785113j -0.83333333+1.1785113j]`'
- en: '`AR(2) Stationarity:` `True`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`AR(2) 站立性:` `True`'
- en: 'We can observe the roots are in complex conjugate form a ± bi. When a process
    has roots in complex conjugate form, it is expected the autocorrelations will
    exhibit an oscillatory pattern, which we can see in the ACF plot in *Figure 11**.2*.
    We can also observe the two significant lags in the PACF, which support the case
    of order p=2:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到根以复共轭形式 a ± bi 存在。当一个过程具有复共轭形式的根时，我们预期自相关将表现出振荡模式，这在 *图 11.2* 中的 ACF
    图中可以看到。我们还可以观察到 PACF 中的两个显著滞后，这支持了 p=2 的阶数：
- en: '![Figure 11.2 – AR(2) with complex conjugate roots](img/B18945_11_002.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 具有复共轭根的 AR(2)](img/B18945_11_002.jpg)'
- en: Figure 11.2 – AR(2) with complex conjugate roots
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 具有复共轭根的 AR(2)
- en: 'To mathematically test that complex conjugate roots are stationary (outside
    the unit circle), we take the magnitude of the vector of each root’s real and
    imaginary parts and check if it is greater than 1\. The magnitude for complex
    conjugate roots, *z*, following form a ± bi is the following equation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从数学上测试复共轭根是否稳定（位于单位圆外），我们取每个根的实部和虚部的向量的大小，并检查它是否大于1。复共轭根，*z*，按照形式 a ± bi 的模量如下方程：
- en: ‖z‖ = √ _ a 2 + b 2
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ‖z‖ = √ a² + b²
- en: 'The magnitude of our roots is this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根的模量如下：
- en: √ _________________  − 0.8333 2± 1.1785 2  = 1.4433
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: √ _________________  − 0.8333²± 1.1785²  = 1.4433
- en: Since 1.4433 > 1, we know our AR(2) model is stationary.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 1.4433 > 1，我们知道我们的 AR(2) 模型是稳定的。
- en: Identifying order p for AR models using the PACF
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PACF 识别 AR 模型的阶数 p
- en: When identifying a lag order p for an autoregressive process, AR(p), based on
    the PACF plot, we take the maximum lag where significant partial autocorrelation
    exists as the order for p. In observing *Figure 11**.3*, because the PACF dampens
    after lag 4 and through about lag 30, we will cut off order consideration after
    lag 4 because using more lags (consider them as features for a time series model)
    will likely result in overfitting. The order selected using PACF is based on the
    last significant lag before the partial autocorrelations dampen. While lags 2
    and 3 seem to be small and may not be significant, lag 4 is. Therefore, we may
    get the best model using an AR of order 4\. Typically, we test our assumptions
    using errors with information criteria, such as AIC or BIC.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当根据 PACF 图识别自回归过程 AR(p) 的滞后阶数 p 时，我们取存在显著偏自相关的最大滞后作为 p 的阶数。在观察 *图 11.3* 时，因为
    PACF 在滞后 4 后减弱，并通过大约滞后 30，我们将在滞后 4 后停止阶数考虑，因为使用更多的滞后（将它们视为时间序列模型的特征）可能会导致过拟合。使用
    PACF 选择的阶数是基于偏自相关减弱前的最后一个显著滞后。虽然滞后 2 和 3 看起来很小，可能不显著，但滞后 4 是显著的。因此，我们可能使用阶数为 4
    的 AR 模型获得最佳模型。通常，我们使用信息准则（如 AIC 或 BIC）的错误来测试我们的假设。
- en: '![Figure 11.3 – AR(p) order identification](img/B18945_11_003.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – AR(p) 阶数识别](img/B18945_11_003.jpg)'
- en: Figure 11.3 – AR(p) order identification
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – AR(p) 阶数识别
- en: AR(p) end-to-end example
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AR(p) 端到端示例
- en: 'Let us walk through an end-to-end example of AR(p) modeling in Python. First,
    we need to generate a dataset produced by an AR(4) process. We will use this data
    as the process we will attempt to model:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个 Python 中 AR(p) 模型端到端示例。首先，我们需要生成一个由 AR(4) 过程产生的数据集。我们将使用这些数据作为我们将尝试建模的过程：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For the following steps, let us assume data `y` is the output of a machine about
    which we know nothing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下步骤，让我们假设数据 `y` 是一个机器的输出，我们对它一无所知。
- en: Step 1 - visual inspection
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第 1 步 - 视觉检查
- en: 'We first visualize the original data and its ACF and PACF plots using the code
    we provided earlier in the chapter:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用本章前面提供的代码可视化原始数据及其 ACF 和 PACF 图：
- en: '![Figure 11.4 – Step 1 in model development: visual inspection](img/B18945_11_004.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 模型开发步骤 1：视觉检查](img/B18945_11_004.jpg)'
- en: 'Figure 11.4 – Step 1 in model development: visual inspection'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 模型开发步骤 1：视觉检查
- en: We can see based on the PACF plot we have what appears to be an AR(2), but possibly
    an AR(4). After lag 4, the partial autocorrelations lose statistical significance
    at the 5% level of significance. We can see, however, when considering the statistical
    significance of lag 4 in the PACF, however slight, lag 4 in the ACF is significant.
    While the value at lag 4 is not the value of the coefficient, its significance
    is useful in helping determine order p. Nonetheless, an AR(4) may overfit and
    fail to generalize as well as an AR(2). Next, we will use **Aikake Information
    Criterion** (**AIC**) and **Bayesian Information Criterion** (**BIC**) to help
    make our determination.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 PACF 图，我们可以看到似乎是一个 AR(2)，但可能是 AR(4)。在滞后 4 之后，偏自相关系数在 5% 的显著性水平上失去了统计显著性。然而，当我们考虑
    PACF 中滞后 4 的统计显著性时，尽管很微小，ACF 中滞后 4 是显著的。虽然滞后 4 的值不是系数的值，但其显著性有助于确定阶数 p。尽管如此，AR(4)
    可能会过拟合，并且不如 AR(2) 一样很好地泛化。接下来，我们将使用 **赤池信息量准则**（**AIC**）和 **贝叶斯信息量准则**（**BIC**）来帮助我们做出决定。
- en: Based on the constant mean and the fact we do not have an exponentially dampening
    (which would also need to be significant) ACF, there does not appear to be a trend.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 根据常数均值和我们没有指数衰减（这也需要是显著的）ACF 的事实，似乎没有趋势。
- en: Step 2 - selecting the order of AR(p)
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 步骤 2 - 选择 AR(p) 的阶数
- en: 'Since we are uncertain based on the visual inspection of the order we should
    use for the AR(p) model, we will use AIC and BIC to help our decision. The AIC
    and BIC process will fit models using order zero up to the `max_ar` value provided
    in the upcoming code. The models will fit the entire dataset. The order with the
    lowest error is generally the best. Their error calculations are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们根据对 AR(p) 模型应使用阶数的视觉检查不确定，我们将使用 AIC 和 BIC 来帮助我们做出决定。AIC 和 BIC 过程将使用从零阶到即将在代码中提供的
    `max_ar` 值的所有阶数来拟合模型。这些模型将拟合整个数据集。误差最低的阶数通常是最好的。它们的误差计算如下：
- en: AIC = 2k − 2ln( ˆ L )
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: AIC = 2k − 2ln(ˆL)
- en: BIC = kln(n) − 2ln( ˆ L )
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: BIC = kln(n) − 2ln(ˆL)
- en: This is where *k* is the number of lags – up to the maximum order tested – for
    the data,  ˆ L  is the maximum likelihood estimate, and *n* is the sample size
    (or length of the dataset being tested). For both tests, the lower error is better.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 *k* 是数据的滞后数 - 最多到测试的最大阶数，ˆL 是最大似然估计，*n* 是样本大小（或正在测试的数据集的长度）。对于这两个测试，误差越低越好。
- en: We will import `arma_order_select_ic` from `Statsmodels` and test it using up
    to a maximum of 4 lags based on our observation in the PACF plot in *Figure 11**.4*.
    As noted, based on our visual inspection, we do not appear to have a trend. However,
    we can verify this statistically with an OLS-based unit root test called the **Dickey-Fuller
    test**. The **null hypothesis** of the Dickey-Fuller test is that a unit root
    (and therefore, trend) is present at some point in the maximum number of lags
    tested (maxlag). The alternative hypothesis is that there is no unit root (no
    trend) in the data. For reference, the alternative hypothesis states that the
    data is an order zero - **I(0)** - integrated process while the null hypothesis
    states that the data is an order one - **I(1)** - integrated process. If the absolute
    value of the test statistic is greater than the critical value or the p-value
    is significant, we can conclude there is no trend present (no unit root).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `Statsmodels` 导入 `arma_order_select_ic` 并根据我们在 *图 11**.4* 中的 PACF 图中的观察结果，使用最多
    4 个滞后项进行测试。正如所注，根据我们的视觉检查，我们似乎没有趋势。然而，我们可以通过一个基于 OLS 的单位根测试，称为 **Dickey-Fuller
    测试** 来进行统计验证。Dickey-Fuller 测试的 **零假设** 是在测试的最大滞后数（maxlag）中的某个点存在单位根（因此，趋势）。备择假设是数据中没有单位根（没有趋势）。为了参考，备择假设表明数据是一个零阶
    - **I(0)** - 集成过程，而零假设表明数据是一个一阶 - **I(1)** - 集成过程。如果测试统计量的绝对值大于临界值或 p 值显著，我们可以得出没有趋势（没有单位根）的结论。
- en: The Dickey-Fuller test considers each data point out to the number of lags included
    in the regression test. We will need to analyze the ACF plot for this; because
    we want to consider as far out as a trend could be possible, we must choose the
    longest lag that has significance. The idea is that if we have a strong trend
    in our data, such as growth, for the most part, each sequential value will lead
    to another increasing subsequent value for as long as the trend exists. In our
    case, the maximum significant lag in the ACF plot is approximately 25\. The Dickey-Fuller
    test has relatively low statistical power (prone to Type II error or failing to
    reject the null when the null should be rejected) so a high order of lags is not
    concerning so long as it is practical; the risk is failing to include enough lags.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Dickey-Fuller 测试考虑回归测试中包含的滞后数目的每个数据点。我们需要分析 ACF 图来做到这一点；因为我们希望考虑趋势可能存在的最远范围，我们必须选择具有显著性的最长滞后。想法是，如果我们数据中有一个强烈的趋势，比如增长，那么在趋势存在期间，每个连续的值都将导致另一个后续值的增加。在我们的情况下，ACF
    图中的最大显著滞后大约是 25。由于 Dickey-Fuller 测试的统计功效相对较低（容易犯第二类错误或当应该拒绝零假设时未能拒绝），因此只要它是实用的，高阶滞后并不令人担忧；风险是未能包含足够的滞后。
- en: Dickey-Fuller unit roots
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Dickey-Fuller 单位根
- en: The Dickey-Fuller tests only if there is a trend unit root, but not if there
    is a seasonal unit root. We discuss the difference between trend and seasonal
    unit roots in the ARIMA section of this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Dickey-Fuller 测试仅当存在趋势单位根时才进行，但如果有季节性单位根则不进行。我们将在本章的 ARIMA 部分讨论趋势和季节性单位根之间的区别。
- en: 'In the upcoming code block, we add `maxlag=25` for our 25 lags from the ACF
    plot in *Figure 11**.4*. We will also include `regression=''c''`, which adds a
    constant (or intercept) into the OLS it performs; we will not need to manually
    add the constant in that case:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码块中，我们在 *图11**.4* 中的自相关图（ACF）中添加了 `maxlag=25`，对应于我们的25个滞后项。我们还将包括 `regression='c'`，这将在进行的
    OLS 回归中添加一个常数（或截距）；在这种情况下，我们不需要手动添加常数：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see based on the Dickey-Fuller test that we should reject the null hypothesis
    and conclude the process is order-zero integrated and therefore does not have
    trend:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Dickey-Fuller 测试，我们应该拒绝零假设，并得出结论该过程是零阶积分的，因此没有趋势：
- en: '`Dickey-Fuller p-value:` `1.6668842047161513e-06`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dickey-Fuller p值:` `1.6668842047161513e-06`'
- en: '`Dickey-Fuller test statistic: -``5.545206445371327`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dickey-Fuller 测试统计量: -5.545206445371327`'
- en: '`Dickey-Fuller critical value: -``2.8765564361715534`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dickey-Fuller 临界值: -2.8765564361715534`'
- en: 'We can therefore insert into our `arma_order_select_ic` function that `trend=''n''`
    (otherwise, we may want to difference the data, which we will show in the ARIMA
    section of the chapter):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将 `trend='n'` 插入到我们的 `arma_order_select_ic` 函数中（否则，我们可能想要对数据进行差分，我们将在本章的
    ARIMA 部分展示）：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here we can see the AR and MA orders identified to produce a fit with the lowest
    overall error according to our AIC and BIC tests:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到根据我们的 AIC 和 BIC 测试，识别出的 AR 和 MA 阶数，以产生最低的整体误差：
- en: '`AIC Order Selection: (``4, 0)`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`AIC 阶数选择: (4, 0)`'
- en: '`AIC Error:` `586.341`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`AIC 错误:` `586.341`'
- en: '`BIC Order Selection: (``2, 0)`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`BIC 阶数选择: (2, 0)`'
- en: '`BIC Error:` `597.642`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`BIC 错误:` `597.642`'
- en: We can see AIC selected an AR(4) and BIC selected an AR(2). It is preferable
    that both tests select the same term orders. However, as we noted already, the
    AR(2) may be less likely to overfit. Since the best order isn’t completely clear,
    we will proceed to test both models (using AR(2) and AR(4)) by comparing their
    errors and log-likelihood estimates.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 AIC 选择了一个 AR(4)，而 BIC 选择了一个 AR(2)。最好是两个测试都选择相同的项阶数。然而，正如我们之前提到的，AR(2)
    可能不太可能过度拟合。由于最佳阶数并不完全清楚，我们将通过比较它们的误差和对数似然估计来测试这两个模型（使用 AR(2) 和 AR(4)）。
- en: Step 3 - building the AR(p) model
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第 3 步 - 构建AR(p)模型
- en: 'In this step, we can add our arguments to the `statsmodels’` ARIMA function
    and fit it to the data with our prescribed AR(4). To be clear, an AR(4) is the
    same as an ARIMA(4,0,0). We want to include `enforce_stationarity=True` to ensure
    our model will produce useful results. If not, we will receive a warning and need
    to address the issue by either differencing, using a different model – such as
    SARIMA, changing our sampling method, changing our time binning (from days to
    weeks, for example), or abandoning time series modeling for the data altogether:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们可以将我们的参数添加到`statsmodels`的ARIMA函数中，并使用我们指定的AR(4)拟合数据。为了明确，AR(4)等同于ARIMA(4,0,0)。我们希望包含`enforce_stationarity=True`以确保我们的模型将产生有用的结果。如果不是，我们将收到警告，并需要通过差分、使用不同的模型（如SARIMA）、改变我们的采样方法、改变我们的时间分箱（例如从天到周）或完全放弃时间序列建模来解决这个问题：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In our model output, we can see the *SARIMAX Results* title and *Model: ARIMA(4,0,0)*.
    This can be disregarded. A SARIMAX with no seasonal component and no exogenous
    variables (in our case) is simply an ARIMA. Further, an ARIMA of order (4,0,0)
    is an *AR(4)*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模型输出中，我们可以看到*SARIMAX结果*标题和*模型：ARIMA(4,0,0)*。这可以忽略。没有季节成分和没有外生变量（在我们的情况下）的SARIMAX只是一个ARIMA。此外，阶数为(4,0,0)的ARIMA是一个*AR(4)*：
- en: '![Figure 11.5 – AR(4) model results](img/B18945_11_005.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5 – AR(4)模型结果](img/B18945_11_005.jpg)'
- en: Figure 11.5 – AR(4) model results
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – AR(4)模型结果
- en: The AR(4) process we modeled (the simulated process we built prior to step 1
    is
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建模的AR(4)过程（在步骤1之前构建的模拟过程）是：
- en: y t − 1.59 y t−1 + 0.544 y t−2 + 0.511 y t−3 − 0.222 y t−4 = ϵ t
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: y_{t-1} - 1.59 y_{t-1} + 0.544 y_{t-2} + 0.511 y_{t-3} - 0.222 y_{t-4} = ϵ_{t}
- en: 'and the AR(4) model we produced using the data from the input process is the
    following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用输入过程的数据生成的AR(4)模型如下：
- en: y t − 1.6217 y t−1 + 0.6877 y t−2 + 0.3066 y t−3 − 0.1158 y t−4 = ϵ t
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: y_{t-1} - 1.6217 y_{t-1} + 0.6877 y_{t-2} + 0.3066 y_{t-3} - 0.1158 y_{t-4}
    = ϵ_{t}
- en: 'In backshift operator notation, we have the following equation:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在后移算子符号表示法中，我们得到以下方程：
- en: (1 − 1.6217B + 0.6877 B 2 + 0.3066 B 3 − 0.1158 B 4) y t = ϵ t
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: (1 - 1.6217B + 0.6877 B^2 + 0.3066 B^3 - 0.1158 B^4) y_{t} = ϵ_{t}
- en: Notably, the term for lag 4 is not significant and the confidence interval contains
    0\. Therefore, including this term is a known risk for overfitting and something
    worth weighing if considering alternative models. It would be prudent to compare
    an AR(2) and even an AR(3) to our AR(4) based on AIC and BIC and choose a different
    model if the results are much improved, but we will skip this process for the
    sake of time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，滞后4的项并不显著，置信区间包含0。因此，包括这个项是过度拟合的已知风险，如果考虑替代模型，这是一个值得权衡的因素。如果基于AIC和BIC比较AR(2)甚至AR(3)与我们的AR(4)的结果有显著改善，那么选择不同的模型将是谨慎的，但为了节省时间，我们将跳过这个过程。
- en: Regarding the model summary metrics, we discussed the **Ljung-Box test** in
    the last chapter so will not cover the details here, but the high p-value *(Prob(Q)*)
    for that test indicates there is not correlated error at lag 1\. Typically, if
    there is serial correlation in the residuals of a model fit, the residuals will
    have lag 1 autocorrelation. The **Jarque-Bera test** assumes the errors are normally
    distributed under the null hypothesis and not normally distributed under the alternative
    hypothesis. The high p-value *(Prob(JB)*) for that test suggests the error is
    normally distributed. The test for **heteroskedasticity** tests the null that
    the residuals are constant (homoscedastic) with the alternative hypothesis being
    that they are non-constant, which is an issue for a time series regression fit.
    Here, our Heteroskedasticity p-value *(Prob(H)*) is high so we can assume our
    model’s residuals have constant variance. A **skew** score between [-0.5, 0.5]
    is considered not skewed, whereas between [-1, -0.5] or [0.5, 1] is moderately
    skewed and > ±2 is high. A perfect score for **kurtosis** is 3\. Kurtosis > ±7
    is high. Because our skew is 0.04 and our kurtosis score is 2.58, we can assume
    our residuals are normally distributed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 关于模型摘要指标，我们在上一章讨论了**Ljung-Box 检验**，所以这里不再详细说明，但该检验的高 p 值（Prob(Q)）表明在滞后 1 处没有相关误差。通常，如果模型拟合的残差中存在序列相关性，残差将具有滞后
    1 的自相关性。**Jarque-Bera 检验**假设在零假设下误差是正态分布的，而在备择假设下不是正态分布的。该检验的高 p 值（Prob(JB)）表明误差是正态分布的。**异方差性检验**检验的是残差是否恒定（同方差），备择假设是它们不是恒定的，这是时间序列回归拟合的问题。在这里，我们的异方差性
    p 值（Prob(H)）较高，因此我们可以假设我们的模型残差具有恒定的方差。**偏度**分数在 [-0.5, 0.5] 之间被认为是未偏斜的，而在 [-1,
    -0.5] 或 [0.5, 1] 之间是中度偏斜的，而 > ±2 是高度偏斜的。**峰度**的完美分数是 3。峰度 > ±7 是高度偏斜的。因为我们的偏度为
    0.04，我们的峰度分数为 2.58，我们可以假设我们的残差是正态分布的。
- en: Step 4 - test forecasting
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 步骤 4 - 测试预测
- en: 'Another method for validating a model is to forecast existing points using
    data leading up to those points. Here, we use the model to forecast the last 5
    points using the full dataset excluding those last 5 points. We then compare to
    get an idea of model performance. Note that we generated 200 samples and the index
    for those samples starts at 0\. Therefore, our 200th sample is at positional index
    199:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 验证模型的另一种方法是使用那些点之前的数据来预测现有点。在这里，我们使用模型来预测最后 5 个点，使用的是除了最后 5 个点之外的全数据集。然后我们进行比较，以了解模型性能。请注意，我们生成了
    200 个样本，这些样本的索引从 0 开始。因此，我们的第 200 个样本位于位置索引 199：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the following table, the *mean* column is the forecast. We manually appended
    the *actuals* column with the last 5 values in our data to compare to the forecast.
    *mean_se* is our mean squared error for our estimates compared to actuals. *y*
    is our index and the *ci* columns are for our 95% forecast confidence interval
    since we used `alpha=0.05` in the previous code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表格中，*mean* 列是预测值。我们手动将 *actuals* 列添加到我们数据的最后 5 个值中，以与预测值进行比较。*mean_se* 是我们估计值与实际值相比的均方误差。*y*
    是我们的索引，*ci* 列是我们 95% 预测置信区间，因为我们之前在代码中使用 `alpha=0.05`。
- en: '| **y** | **mean** | **mean_se** | **mean_ci_lower** | **mean_ci_upper** |
    **actuals** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **y** | **mean** | **mean_se** | **mean_ci_lower** | **mean_ci_upper** |
    **actuals** |'
- en: '| 195 | 24.70391 | 0.99906 | 22.74579 | 26.662035 | 25.5264 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 195 | 24.70391 | 0.99906 | 22.74579 | 26.662035 | 25.5264 |'
- en: '| 196 | 19.36453 | 0.99906 | 17.4064 | 21.322652 | 18.8797 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 196 | 19.36453 | 0.99906 | 17.4064 | 21.322652 | 18.8797 |'
- en: '| 197 | 7.525904 | 0.99906 | 5.567779 | 9.484028 | 7.4586 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 197 | 7.525904 | 0.99906 | 5.567779 | 9.484028 | 7.4586 |'
- en: '| 198 | -5.8744 | 0.99906 | -7.83252 | -3.916274 | -7.1316 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 198 | -5.8744 | 0.99906 | -7.83252 | -3.916274 | -7.1316 |'
- en: '| 199 | -19.5785 | 0.99906 | -21.5366 | -17.620356 | -17.9268 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 199 | -19.5785 | 0.99906 | -21.5366 | -17.620356 | -17.9268 |'
- en: Figure 11.6 – AR(4) model outputs versus actuals
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – AR(4) 模型输出与实际值对比
- en: 'We can see based on our mean squared error (0.999062) that our model provides
    a reasonable fit across a forecast horizon of 5 points on test data. Using the
    following code, we plot our test forecast against the corresponding actuals:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的均方误差（0.999062），我们可以看到我们的模型在测试数据上对 5 个点的预测范围内提供了合理的拟合。使用以下代码，我们绘制了我们的测试预测与相应的实际值：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Figure 11.7 – The AR(4) test forecast](img/B18945_11_007.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – AR(4) 测试预测](img/B18945_11_007.jpg)'
- en: Figure 11.7 – The AR(4) test forecast
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – AR(4) 测试预测
- en: Step 5 - building a forecast
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 步骤 5 - 构建预测
- en: 'Determining a reasonable forecast horizon is highly dependent on at least the
    data and the process it represents, and the lag used for modeling, in addition
    to model error. The time series practitioner should weigh all factors of model
    performance and business needs versus risks before providing forecasting to stakeholders.
    Adding the following code, we re-run the plot to see our true forecast with a
    5-point horizon:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 确定合理的预测范围高度依赖于至少数据及其所代表的过程，以及用于建模的滞后，以及模型误差。在向利益相关者提供预测之前，时间序列从业者应权衡模型性能和业务需求与风险的所有因素。添加以下代码，我们重新运行图表以查看具有5点预测范围的真正预测：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Figure 11.8 – The AR(4) forecast horizon = 5](img/B18945_11_008.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – AR(4)预测范围=5](img/B18945_11_008.jpg)'
- en: Figure 11.8 – The AR(4) forecast horizon = 5
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – AR(4)预测范围=5
- en: We will cover additional steps in the model evaluation section of this chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的模型评估部分介绍额外的步骤。
- en: Moving average (MA) models
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动平均（MA）模型
- en: The MA(q) model
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MA(q)模型
- en: Whereas the AR(p) model is a direct function of the correlation between lag
    zero and specific individual lags of order *p* over time, the moving average model
    of order *q*, MA(q), is a function of autocorrelation between lag zero and all
    previous lags included in order *q*. It acts as a low-pass filter that models
    errors to provide a useful fit to data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 而AR(p)模型是时间上滞后零与特定个体阶数*p*的滞后之间的相关性的直接函数，阶数*p*的移动平均模型，MA(q)，是滞后零与包括在阶数*p*中的所有先前滞后之间的自相关函数。它作为一个低通滤波器，通过建模误差来提供对数据的有效拟合。
- en: Let us take a process, y t, that has a mean of zero and a random, normally distributed
    white noise component, ϵ t, where t = ± 1, ± 2, …. If we can write this process
    as
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个过程，y t，它具有零均值和一个随机、正态分布的白噪声成分，ϵ t，其中t = ± 1, ± 2, …。如果我们能将此过程写成
- en: y t − μ = ϵ t − ϴ 1 ϵ t−1 − … − ϴ q ϵ t−q
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: y t − μ = ϵ t − ϴ 1 ϵ t−1 − … − ϴ q ϵ t−q
- en: 'and ϴ 1, ϴ 2, … , ϴ q are real constants and ϴ q ≠ 0, then we can call this
    a moving average process having order *q*, or MA(q). In backshift operator notation,
    we have the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 ϴ 1, ϴ 2, … , ϴ q 是实常数且 ϴ q ≠ 0，那么我们可以称这是一个具有阶数*q*的移动平均过程，或MA(q)。在向后移位算子记法中，我们有以下：
- en: y t − μ = (1 − ϴ 1 B − … − ϴ q B q) ϵ t
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: y t − μ = (1 − ϴ 1 B − … − ϴ q B q) ϵ t
- en: 'We can define the autocorrelations (ρ k) for the MA(q) model thusly:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样定义MA(q)模型的自相关（ρ k）：
- en: ρ k =  − ϴ k + ∑ j=1 q−k ϴ j ϴ j+k  _____________  1 + ∑ j=1 q  ϴ j 2
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ρ k =  − ϴ k + ∑ j=1 q−k ϴ j ϴ j+k  _____________  1 + ∑ j=1 q  ϴ j 2
- en: For all lags *k* in 1,2, … , q. Where k > q, we have ρ k = 0.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有滞后*k*在1,2, … , q中。当k > q时，我们有ρ k = 0。
- en: When discussing the AR(p) models, we explained how the roots of the AR model
    must be outside the unit circle. When considering MA(q) models, we have the concept
    of invertibility. **Invertibility** essentially ensures a *logical and stable
    correlation with the past*. Typically, this means the current point in time is
    more closely related to nearby points in the past than those more distant. The
    inability to model a process using invertible roots means we cannot ensure our
    model provides a unique solution for the set of model autocorrelations. If points
    in the distant past are more relevant to the current point than those nearby,
    we have a randomness in the process that cannot be reliably modeled or forecasted.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论AR(p)模型时，我们解释了AR模型的根必须位于单位圆外部。当考虑MA(q)模型时，我们有可逆性的概念。**可逆性**本质上确保了与过去的*逻辑和稳定的关联*。通常，这意味着当前时间点与过去附近的时间点比那些更远的时间点更紧密相关。无法使用可逆根来建模过程意味着我们无法确保我们的模型为模型自相关集提供唯一解。如果过去较远的时间点比附近的时间点对当前点更相关，那么过程中存在无法可靠建模或预测的随机性。
- en: Identifying MA(q) model invertibility
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 识别MA(q)模型的可逆性
- en: For a moving average model to be invertible, all roots must be outside the unit
    circle and non-imaginary; *all* roots must be greater than 1\. For an MA(1) process,
    it is invertible when |ϴ 1| < 1\. An invertible MA(q) process is equivalent to
    an infinite-order, converging AR(p). An AR(p) model converges if its coefficients
    converge to zero as lags k approach p. If an MA(q) is invertible, we can say y t
    = ϴ(B) ϵ t and ϴ −1(B) y t = ϵ t [*1*].
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使移动平均模型可逆，所有根必须位于单位圆外部且非虚数；*所有*根必须大于1。对于MA(1)过程，当|ϴ 1| < 1时，它是可逆的。一个可逆的MA(q)过程等价于一个无限阶、收敛的AR(p)过程。如果AR(p)模型的系数随着滞后k接近p而收敛到零，则该模型收敛。如果一个MA(q)是可逆的，我们可以说y t
    = ϴ(B) ϵ t 和 ϴ −1(B) y t = ϵ t [*1*]。
- en: The MA(1) model
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MA(1)模型
- en: 'For an MA(q) model of order 1, we have the following process:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一阶MA(q)模型，我们有以下过程：
- en: ρ 0 = 1
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ρ 0 = 1
- en: ρ 1 =  ϴ 1 _ 1 + ϴ 1 2
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ρ 1 =  ϴ 1 _ 1 + ϴ 1 2
- en: ρ k>1 = 0
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ρ k>1 = 0
- en: For a MA(q) model with zero autocorrelation, the pattern of whose process we
    are attempting to model is random, normally distributed white noise variance,
    which can – at best – only be modeled by its mean. It is important to note that
    as ϴ 1 → 0, ρ 1 → 0 and for an MA(1) process, this means the process can be approximated
    by white noise.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有零自相关函数的MA(q)模型，我们试图建模的过程模式是随机的，服从正态分布的白噪声方差，这最多只能通过其均值来建模。重要的是要注意，当 ϴ₁ →
    0 时，ρ₁ → 0，对于MA(1)过程，这意味着过程可以近似为白噪声。
- en: 'Let us consider the following MA(1) zero-mean model following the form y t
    − μ = ϵ t − ϴ 1 ϵ t−1:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下MA(1)零均值模型，其形式为y_t - μ = ϵ_t - ϴ₁ ϵ_{t-1}：
- en: y t − 0 = a t − 0.8 ϵ t−1
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: y_t - 0 = a_t - 0.8 ϵ_{t-1}
- en: 'In backshift notation we have the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在后移记号法中，我们有以下内容：
- en: y t = (1 − 0.8B) ϵ t
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: y_t = (1 - 0.8B) ϵ_t
- en: 'We know this process is invertible because |ϴ 1| < 1\. Let us confirm this
    with Python using the `ArmaProcess` function from the `statsmodels` `tsa` module:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这个过程是可逆的，因为 |ϴ₁| < 1。让我们使用Python中的`statsmodels.tsa`模块的`ArmaProcess`函数来确认这一点：
- en: '[PRE12]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`MA(1) Roots: [``1.25]`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`MA(1) Roots: [1.25]`'
- en: '`MA(1) Invertibility:` `True`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`MA(1) 可逆性:` `True`'
- en: 'Contrary to the AR(p) model, the MA(q) model’s order is identified using the
    ACF plot. Because the ACF does not control for lags and is a composite autocorrelation
    measure across all lags up to the lag whose autocorrelation measure is considered,
    the function is used to identify the relevant lag order for the moving average
    component. In *Figure 11**.9*, we can see the significant correlation at lag 1
    for our MA(1) process. There are two additional significant correlations at lags
    6 and 7, but using lags this far out typically results in overfitting, especially
    when taken alongside the fact that lags 2 through 5 are not significant at the
    5% level of significance:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与AR(p)模型相反，MA(q)模型的阶数是通过ACF图来确定的。因为ACF没有控制滞后，并且是考虑到的滞后阶数及其自相关测度的一个综合自相关度量，所以该函数用于确定移动平均成分的相关滞后阶数。在*图11*.*9*中，我们可以看到我们的MA(1)过程在滞后1处的显著相关性。在滞后6和7处还有两个额外的显著相关性，但使用如此远的滞后通常会导致过度拟合，尤其是当考虑到滞后2至5在5%的显著性水平上并不显著：
- en: '![Figure 11.9 – MA(1) plots](img/B18945_11_009.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – MA(1)图](img/B18945_11_009.jpg)'
- en: Figure 11.9 – MA(1) plots
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – MA(1)图
- en: Dampening ACFs and PACFs
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 消减ACF和PACF
- en: For an invertible moving average model, we can observe that the ACF will cut
    off at the order of significance, but the PACF will typically continue and dampen
    *overall* to statistical zero over time. It is not necessarily expected to happen
    smoothly and all at once as all data sets are different, but it is expected that
    over time, more and more lags will dampen to zero. We explain the reason for this
    behavior from the ACFs and PACFs in the ARMA section of this chapter, but it is
    worth noting this is to be expected for invertible processes. Conversely, stationary
    autoregressive processes are expected to cut off at the order of significance
    in the PACF plots while the ACFs dampen to zero over time.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可逆移动平均模型，我们可以观察到自相关函数（ACF）将在显著性阶数处截断，但偏自相关函数（PACF）通常会继续并随时间逐渐衰减至统计上的零。这并不一定期望会平滑且一次性发生，因为所有数据集都是不同的，但预计随着时间的推移，越来越多的滞后项将衰减至零。我们将在本章的ARMA部分解释这种行为的理由，但值得注意的是，对于可逆过程，这是可以预期的。相反，平稳自回归过程在PACF图中预计会在显著性阶数处截断，而ACF随时间衰减至零。
- en: The MA(2) model
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MA(2)模型
- en: 'For an MA(q) model of order 2, we have this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二阶的MA(q)模型，我们有以下公式：
- en: ρ 0 = 1
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ρ₀ = 1
- en: ρ 1 =  − ϴ 1 + ϴ 1 ϴ 2  _ 1 + ϴ 1 2 + ϴ 2 2
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ρ₁ = - ϴ₁ + ϴ₁ ϴ₂_1 + ϴ₁² + ϴ₂²
- en: ρ 2 =  − ϴ 2 _ 1 + ϴ 1 2 + ϴ 2 2
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ρ² = - ϴ²_1 + ϴ₁² + ϴ²_2
- en: ρ k>2 = 0
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ρ_k>2 = 0
- en: 'The following is an MA(2) example we will look at:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个我们将要研究的MA(2)示例：
- en: y t = (1 − 1.6B + 0.9 B 2) ϵ t
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: y_t = (1 - 1.6B + 0.9B²) ϵ_t
- en: 'Using the model’s polynomial in the quadratic equation form, we can find the
    approximate roots using the quadratic formula:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二次方程的模型多项式，我们可以使用二次公式找到近似根：
- en: 0.888 ± 0.567i
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 0.888 ± 0.567i
- en: 'Because we have two complex conjugate roots, we can take the same L 2 norm
    we did for the AR(p) process, using the form of a ± bi:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有两个共轭复根，我们可以使用与AR(p)过程相同的L²范数，使用形式为a ± bi：
- en: √ _____________  0.888 2 + 0.567 2  ≈ 1.054
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: √(0.888² + 0.567²) ≈ 1.054
- en: 'Because 1.054 is greater than 1, we can confirm the MA(2) has invertible roots
    and is thus capable of producing a unique solution and a model whose values are
    logically serially correlated to past values. Let us perform the same analysis
    in Python:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 1.054 大于 1，我们可以确认 MA(2) 有可逆根，因此能够产生一个唯一解和一个模型，其值在逻辑上是与过去值序列相关的。让我们在 Python
    中进行同样的分析：
- en: '[PRE13]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output we see highlighted in green confirms our calculated findings and
    the fact that since the magnitude of the complex conjugate roots is greater than
    0, we have an invertible MA(2) process:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用绿色突出显示的输出确认了我们的计算结果和事实，即由于复共轭根的幅度大于 0，我们有一个可逆的 MA(2) 过程：
- en: '`MA(2) Roots: [``0.88888889-0.56655772j 0.88888889+0.56655772j]`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`MA(2) 根: [0.88888889-0.56655772j 0.88888889+0.56655772j]`'
- en: '`MA(2) Invertibility:` `True`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`MA(2) 可逆性:` `True`'
- en: 'We can see in the ACF in *Figure 11**.10* that this is a second-order moving
    average process:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图 11**.10** 的自相关图中看到，这是一个二阶移动平均过程：
- en: '![Figure 11.10 – MA(2) plots](img/B18945_11_010.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – MA(2) 图](img/B18945_11_010.jpg)'
- en: Figure 11.10 – MA(2) plots
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – MA(2) 图
- en: The process and code for identifying model ordering, building the model, and
    generating a forecast are the same for the MA(q) model as it is for the AR(p)
    model. We have discussed that the order selection based on visual inspection for
    the MA(q) is performed using the ACF, whereas for the AR(p) this is done using
    the PACF, and that it is the only major difference in the process between the
    two models. Aside from that, `enforce_invertibility` should be set to equal `True`
    for MA(q) models in place of `enforce_stationarity=True`. Providing a `max_ar`
    or `max_ma` order higher or lower than useful in the `arma_order_select_ic` function
    may result in a *convergence warning or an invertibility warning*. One reason
    for these warnings is there was a higher order provided than possible to fit (such
    as when there is no order possible). Another reason is the presence of a **unit
    root**. If there is an apparent trend in the data, it *must be removed* before
    modeling. If there is no trend, it is possible to receive this error due to seasonality
    in the data, which presents a different order of unit root. We will discuss modeling
    in the case of unit roots associated with trend and seasonality in the ARIMA and
    seasonal ARIMA section of this chapter. It is also worth specifying that the Dickey-Fuller
    test can be used for moving average data since moving average processes can be
    influenced by trends.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 MA(q) 模型，识别模型阶数、构建模型和生成预测的过程与 AR(p) 模型相同。我们讨论过，对于 MA(q)，基于视觉检查的阶数选择是通过 ACF
    进行的，而对于 AR(p)，这是通过 PACF 进行的，这是两个模型之间过程的主要区别。除此之外，对于 MA(q) 模型，应将 `enforce_invertibility`
    设置为 `True` 而不是 `enforce_stationarity=True`。在 `arma_order_select_ic` 函数中提供比有用阶数更高或更低的
    `max_ar` 或 `max_ma` 阶数可能会导致收敛警告或可逆性警告。这些警告的一个原因是提供了比可能拟合的更高阶数（例如，当没有可能的阶数时）。另一个原因是存在一个**单位根**。如果数据中存在明显的趋势，则在建模之前必须将其**去除**。如果没有趋势，由于数据中的季节性，可能会收到此错误，这表现为不同的单位根阶数。我们将在本章的
    ARIMA 和季节性 ARIMA 部分讨论与趋势和季节性相关的单位根的建模。还值得指出的是，由于移动平均过程可能受到趋势的影响，因此可以使用 Dickey-Fuller
    测试来移动平均数据。
- en: Autoregressive moving average (ARMA) models
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自回归移动平均 (ARMA) 模型
- en: In the autoregressive model section, we discussed how an AR(p) model is used
    to model process output values using autocorrelation controlling for individual
    lags. The goal of the AR(p) model is to estimate exact values for points corresponding
    to lags in the future using the values for the same specific lags in the context
    of a past horizon. For example, the value at two points in the future is strongly
    correlated with the value at two points in the past. In the moving average model
    section, we discussed how MA(q) models act as low-pass filters that help a model
    explain noise in a process. Rather than seeking to model exact points, we use
    the MA(q) to model variance around the process.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在自回归模型部分，我们讨论了如何使用 AR(p) 模型通过自相关控制个体滞后来建模过程输出值。AR(p) 模型的目标是使用过去某个特定滞后下的值来估计未来对应滞后点的确切值。例如，未来两个点的值与过去两个点的值高度相关。在移动平均模型部分，我们讨论了
    MA(q) 模型如何作为低通滤波器，帮助模型解释过程中的噪声。我们不是寻求建模确切点，而是使用 MA(q) 来建模过程周围的方差。
- en: Consider an example of a four-cylinder car engine that produces constant output.
    Let us assume we have a worn-down motor mount near the fourth cylinder. We can
    expect consistent output vibration related to each cylinder firing, but the vibration
    will increase slightly for each stroke that is closer to the worn motor mount.
    Using an AR-only model would assume each cylinder vibrates a certain amount and
    be able to account for that, but we would be missing information. Adding a MA
    component would be able to model the fact that starting at cylinder one, each
    subsequent stroke up through cylinder four will have additional vibration related
    to the worn motor mount and thus explain much more of the overall process. This
    would reasonably be an ARMA(4,4) model. Suppose we replace the worn-down motor
    mount with a mount of equal wear compared to the other mounts; we would then have
    an ARMA(4,0) (or AR(4)) process.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个四缸汽车发动机的例子，该发动机产生恒定的输出。让我们假设我们有一个磨损的发动机支架靠近第四缸。我们可以预期与每个气缸点火相关的连续输出振动，但振动会随着接近磨损的发动机支架的每一下冲而略有增加。使用仅AR模型会假设每个气缸振动一定量并能解释这一点，但我们会丢失信息。添加一个MA成分将能够模拟从第一缸开始，每个后续冲程直到第四缸都会有与磨损的发动机支架相关的额外振动，从而解释更多的整体过程。这合理地是一个ARMA(4,4)模型。假设我们用磨损程度与其他支架相同的支架替换磨损的发动机支架；那么我们就会有ARMA(4,0)（或AR(4)）过程。
- en: 'In many cases, we find we have significant peaks in both autocorrelation and
    partial autocorrelation. Rather than using only MA(q) or AR(p) modeling, respectively,
    we can combine the two. This combination, represented as an ARMA(p,q), enables
    us to model the process as well as any noise component around the process that
    may correlate to specific lags. Because an ARMA(p,q) typically has fewer parameters
    (lower order) for each AR and MA component than AR or MA models do, the ARMA is
    considered a **parsimonious model**, which is a model that uses as few explanatory
    variables (in this case, time lags) as possible to achieve the desired level of
    performance. When y t is an invertible and stationary process, we can define it
    as an ARMA(p,q):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们发现自相关和偏自相关都有显著的峰值。而不是只使用MA(q)或AR(p)模型，我们可以将两者结合起来。这种组合，表示为ARMA(p,q)，使我们能够模拟过程以及可能与特定滞后相关的过程周围的任何噪声成分。因为ARMA(p,q)通常比AR或MA模型具有更少的参数（更低阶），ARMA被认为是一个**简约模型**，这是一个使用尽可能少的解释变量（在这种情况下，时间滞后）来实现所需性能水平的模型。当y t是一个可逆和平稳的过程时，我们可以将其定义为ARMA(p,q)：
- en: y t − μ = Φ 1(y t−1 − μ) − … − Φ p(y t−p − μ) = ϵ t − ϴ 1 ϵ t−1 − … − ϴ q ϵ t−q
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: y t − μ = Φ 1(y t−1 − μ) − … − Φ p(y t−p − μ) = ϵ t − ϴ 1 ϵ t−1 − … − ϴ q ϵ t−q
- en: 'Where Φ p ≠ 0 and ϴ q ≠ 0, we can re-write the equation for ARMA(p,q) in backshift
    operator notation:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当Φ p ≠ 0和ϴ q ≠ 0时，我们可以用后移算子符号重新写出ARMA(p,q)的方程：
- en: ΦB(y t − μ) = ϴ(B) ϵ t
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ΦB(y t − μ) = ϴ(B) ϵ t
- en: 'Practically speaking, we can expect that for an invertible moving average process,
    we see significant lags in the ACF up to the magnitude of the order *q*, but then
    the PACF will taper off thereafter, typically in lags beyond the order of the
    moving average process identified in the ACF. This is because a finite moving
    average process can be represented as an infinite-order autoregressive process.
    Conversely, because the moving average process that has this behavior is invertible,
    the inverse must also be true; that a finite autoregressive process can be represented
    as an infinite-order moving average process. Therefore, the PACF will dampen to
    zero for an invertible moving average process, and for a stationary autoregressive
    process, the ACF will dampen to zero. Because invertibility is a requirement of
    an ARMA process, it allows us to re-write the equation as an infinite-order MA
    process in general linear form:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际角度来说，我们可以预期对于一个可逆的移动平均过程，在自相关函数（ACF）中我们会看到显著的滞后，直到阶数 *q* 的量级，但随后偏自相关函数（PACF）将逐渐减小，通常在ACF中识别出的移动平均过程阶数之外。这是因为有限阶的移动平均过程可以被表示为一个无限阶的自回归过程。相反，由于具有这种行为的移动平均过程是可逆的，其逆过程也必须成立；即有限阶的自回归过程可以被表示为一个无限阶的移动平均过程。因此，对于可逆的移动平均过程，偏自相关函数将衰减到零，而对于平稳的自回归过程，自相关函数也将衰减到零。因为可逆性是ARMA过程的要求，它允许我们将方程重写为一般线性形式下的无限阶MA过程：
- en: y t = Φ −1(B)ϴ(B) ϵ t
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: y t = Φ −1(B)ϴ(B) ϵ t
- en: 'It also allows us to do so as an infinite-order AR process:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 它还允许我们将它作为一个无限阶的自回归过程：
- en: ϴ −1(B)Φ(B) y t = ϵ t
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ϴ −1(B)Φ(B) y t = ϵ t
- en: 'Let us walk through an example in Python. First, using the same imports we
    did before in this chapter, let us generate an invertible and stationary ARMA(2,1)
    process dummy dataset that satisfies the following equation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个 Python 中的例子来演示。首先，使用本章前面相同的导入，让我们生成一个可逆且平稳的 ARMA(2,1) 过程的虚拟数据集，该数据集满足以下方程：
- en: (1 − 1.28B + 0.682 B 2) y t = (1 − 0.58B) ϵ t
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: (1 − 1.28B + 0.682 B²) y_t = (1 − 0.58B) ε_t
- en: '[PRE14]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let us confirm stationary and invertibility:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认平稳性和可逆性：
- en: '[PRE15]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can use the quadratic formula to test, but we can trust the code to confirm:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用二次公式来测试，但我们可以相信代码来确认：
- en: '`AR(2) Roots: [``1.-0.81649658j 1.+0.81649658j]`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`AR(2) 根：` `[1.-0.81649658j 1.+0.81649658j]`'
- en: '`AR(2) Stationarity:` `True`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`AR(2) 平稳性：` `True`'
- en: '`MA(1) Roots: [``2.]`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`MA(1) 根：` `[2.]`'
- en: '`MA(1) Invertibility:` `True`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`MA(1) 可逆性：` `True`'
- en: 'Now that we have a stationary and invertible process, let us generate 200 samples
    from it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有一个平稳且可逆的过程，让我们从中生成 200 个样本：
- en: '[PRE16]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Step 1 – Visual inspection
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第 1 步 – 视觉检查
- en: 'Let us take a look at the plots we have been using to build intuition about
    the process that generated the data:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们一直在使用的图表，以构建关于生成数据的过程的直觉：
- en: '![Figure 11.11 – ARMA(p,q) process sample data](img/B18945_11_011.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11 – ARMA(p,q) 过程样本数据](img/B18945_11_011.jpg)'
- en: Figure 11.11 – ARMA(p,q) process sample data
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 – ARMA(p,q) 过程样本数据
- en: We can see using the ACF that we have what appears to be an MA(1) component.
    Based on the PACF, it looks as if we could have either an AR(2) or an AR(4). The
    realization appears to be a process that satisfies stationarity.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 ACF 看出，似乎有一个 MA(1) 的成分。根据 PACF，看起来我们可能有一个 AR(2) 或 AR(4)。实现看起来是一个满足平稳性的过程。
- en: Step 2 – Select order of ARMA(p,q)
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第 2 步 – 选择 ARMA(p,q) 的阶数
- en: 'Before we decide on an order for our ARMA model, let us use the Dickey-Fuller
    test to check if our data has any trend:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们决定 ARMA 模型的阶数之前，让我们使用 Dickey-Fuller 测试来检查我们的数据是否存在趋势：
- en: '[PRE17]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can see the statistical significance that confirms we do not have a unit
    root in the lags provided with `maxlag` (remember, H o : *the data has a unit
    root* and H a : *the data does not have a unit root*). Therefore, we can use the
    ARMA model without any first-order differencing, which would require at least
    an ARIMA:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到统计显著性，这证实了我们提供的滞后项中没有单位根（记住，H_0：*数据有一个单位根* 和 H_1：*数据没有单位根*）。因此，我们可以使用
    ARMA 模型而不需要任何一阶差分，这至少需要一个 ARIMA：
- en: '`Dickey-Fuller p-value:` `6.090665062133195e-16`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dickey-Fuller p 值：` `6.090665062133195e-16`'
- en: '`Dickey-Fuller test statistic: -``9.40370671340928`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dickey-Fuller 测试统计量：` `-9.40370671340928`'
- en: '`Dickey-Fuller critical value: -``2.876401960790147`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dickey-Fuller 临界值：` `-2.876401960790147`'
- en: 'Now let us use `statmodels` `arma_order_select_ic` to see what AIC and BIC
    select for the ARMA(p,q) order. We know the maximum order for an MA(q) is one,
    but since we are not sure if this is an AR(2) or an AR(4), we can use `max_ar=4`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `statmodels` 的 `arma_order_select_ic` 来查看 AIC 和 BIC 对 ARMA(p,q) 阶数的选择。我们知道
    MA(q) 的最大阶数是 1，但由于我们不确定这是 AR(2) 还是 AR(4)，我们可以使用 `max_ar=4`：
- en: '[PRE18]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can see that AIC selected an ARMA(4,1) and BIC selected an ARMA(2,1):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 AIC 选择了一个 ARMA(4,1)，而 BIC 选择了一个 ARMA(2,1)：
- en: '`AIC Order Selection: (``4, 1)`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`AIC 阶数选择：` `(4, 1)`'
- en: '`AIC Error:` `548.527`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`AIC 错误：` `548.527`'
- en: '`BIC Order Selection: (``2, 1)`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`BIC 阶数选择：` `(2, 1)`'
- en: '`BIC Error:` `565.019`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`BIC 错误：` `565.019`'
- en: The ARMA(4,1) has a lower error, but we know from this and previous chapters
    in the book that models with lower error on training data may be more likely to
    have more variance and thus be more likely to overfit. However, let us use ARMA(4,1).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ARMA(4,1) 具有较低的误差，但我们知道从这本书的此章节和前面的章节中，具有较低训练数据误差的模型可能更有可能具有更大的方差，因此更有可能过拟合。但是，让我们使用
    ARMA(4,1)。
- en: Step 3 – Building the AR(p) model
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第 3 步 – 构建 AR(p) 模型
- en: 'Now let us build our ARMA(4,1) model. Note the 0 is for the integrated first-order
    difference for an ARIMA(p,d,q) model. Since we do not have a trend-based unit
    root, we do not need to difference to remove any trend. Thus, d=0:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建我们的 ARMA(4,1) 模型。注意，0 是 ARIMA(p,d,q) 模型中一阶差分的积分。由于我们没有基于趋势的单位根，我们不需要差分来去除任何趋势。因此，d=0：
- en: '[PRE19]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we can see the model provides a reasonable fit based on the model metrics.
    However, there is one issue; our first three AR coefficients have no statistical
    significance (high p-values and confidence intervals containing zero). This is
    a big problem and confirms our model is overfitted. Our model includes terms it
    is not getting benefit from. Therefore, our model would most certainly fail to
    generalize well on unseen data and should be reconstructed:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到模型基于模型指标提供了一个合理的拟合。然而，有一个问题；我们前三个 AR 系数没有统计显著性（高 p 值和包含零的置信区间）。这是一个大问题，证实了我们的模型过度拟合。我们的模型包含了它没有从中获得益处的项。因此，我们的模型在未见过的数据上很可能无法很好地泛化，应该重建：
- en: '![Figure 11.12 – ARIMA(4,0,1) model results](img/B18945_11_012.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – ARIMA(4,0,1) 模型结果](img/B18945_11_012.jpg)'
- en: Figure 11.12 – ARIMA(4,0,1) model results
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – ARIMA(4,0,1) 模型结果
- en: 'Let us re-run this as an ARMA(2,1), which is the same as an ARIMA(2,0,1) since
    there is no differencing to be integrated. This is what we visually identified,
    and BIC selected the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新运行这个 ARMA(2,1)，它与 ARIMA(2,0,1) 相同，因为没有差分需要积分。这是我们通过视觉识别的，BIC 选择以下代码：
- en: '[PRE20]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can see now a much better fit for our variables. All coefficients are significant,
    and the model metrics remain sufficient. The model we have identified corresponds
    to the following equation:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到我们的变量有了更好的拟合。所有系数都是显著的，模型指标仍然足够。我们识别出的模型对应以下方程：
- en: (1 − 1.2765B + 0.6526 B 2) y t = (1 + 0.58B) ϵ t
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: (1 − 1.2765B + 0.6526 B 2) y t = (1 + 0.58B) ϵ t
- en: 'We can compare that to our dummy process:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些与我们的虚拟过程进行比较：
- en: (1 − 1.28B + 0.682 B 2) y t = (1 − 0.58B) ϵ t
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: (1 − 1.28B + 0.682 B 2) y t = (1 − 0.58B) ϵ t
- en: '![Figure 11.13 – ARIMA(2,0,1) model results](img/B18945_11_013.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – ARIMA(2,0,1) 模型结果](img/B18945_11_013.jpg)'
- en: Figure 11.13 – ARIMA(2,0,1) model results
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – ARIMA(2,0,1) 模型结果
- en: Step 4 – Test forecasting
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第 4 步 – 测试预测
- en: 'Now, let us cross-validate our model by training the model on data up through
    the last five points, then forecasting the last five points so that we can compare
    them to the actuals. Recall that our indexing starts at 0 so our dataset ends
    at index 199:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在最后五个数据点上训练模型来交叉验证我们的模型，然后预测最后五个点，以便我们可以将它们与实际值进行比较。记住，我们的索引从 0 开始，所以我们的数据集在索引
    199 结束：
- en: '[PRE21]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can see our predicted values in the *mean* column in the following table:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下表格的 *均值* 列中看到我们的预测值：
- en: '| **y** | **mean** | **mean_se** | **mean_ci_lower** | **mean_ci_upper** |
    **actuals** |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| **y** | **mean** | **mean_se** | **mean_ci_lower** | **mean_ci_upper** |
    **actuals** |'
- en: '| 195 | -0.01911 | 0.932933 | -1.84762 | 1.80940631 | 0.559875 |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 195 | -0.01911 | 0.932933 | -1.84762 | 1.80940631 | 0.559875 |'
- en: '| 196 | 0.58446 | 0.932933 | -1.24406 | 2.412975242 | 0.778127 |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 196 | 0.58446 | 0.932933 | -1.24406 | 2.412975242 | 0.778127 |'
- en: '| 197 | 0.479364 | 0.932933 | -1.34915 | 2.307879057 | 1.695218 |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 197 | 0.479364 | 0.932933 | -1.34915 | 2.307879057 | 1.695218 |'
- en: '| 198 | 0.914009 | 0.932933 | -0.91451 | 2.74252465 | 2.041826 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 198 | 0.914009 | 0.932933 | -0.91451 | 2.74252465 | 2.041826 |'
- en: '| 199 | 0.80913 | 0.932933 | -1.01939 | 2.637645206 | 0.578695 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 199 | 0.80913 | 0.932933 | -1.01939 | 2.637645206 | 0.578695 |'
- en: Figure 11.14 – AR(4) model outputs versus actuals
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – AR(4) 模型输出与实际值对比
- en: 'Let’s print out our model’s **Average Squared** **Error** (**ASE**):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印出我们模型的 **平均平方** **误差** (**ASE**)：
- en: '[PRE22]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here we see the ASE:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们看到 ASE：
- en: '`Average Squared Error:` `0.6352208223437921`'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`平均平方误差:` `0.6352208223437921`'
- en: 'Our test forecast plot is shown in *Figure 11**.15*. Note that our estimate
    appears conservative. Using ARMA(4,1) may have produced a closer, but less generalizable
    fit. One method for improving forecasting would be to build the model using only
    recent points (relative to subject matter knowledge of the process). Including
    a larger set of data will produce a fit that generalizes more to the overall process
    rather than to a possibly more relevant timeframe:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试预测图显示在 *图 11**.15* 中。注意，我们的估计看起来比较保守。使用 ARMA(4,1) 可能会产生更接近的拟合，但泛化性较差。改进预测的一个方法是通过仅使用最近的数据点（相对于过程的主题知识）来构建模型。包括更大的数据集将产生一个更适合整体过程的拟合，而不是可能更相关的时段：
- en: '![Figure 11.15 – ARMA(2,1) test forecast](img/B18945_11_015.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15 – ARMA(2,1) 测试预测](img/B18945_11_015.jpg)'
- en: Figure 11.15 – ARMA(2,1) test forecast
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – ARMA(2,1) 测试预测
- en: Step 5 – Building a forecast
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第 5 步 – 构建预测
- en: 'Now, let us forecast five ahead:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们预测五个点：
- en: '[PRE23]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Figure 11.16 – ARMA(2,1) forecast horizon = 5](img/B18945_11_016.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.16 – ARMA(2,1) 预测范围 = 5](img/B18945_11_016.jpg)'
- en: Figure 11.16 – ARMA(2,1) forecast horizon = 5
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16 – ARMA(2,1) 预测范围 = 5
- en: On a final note, regarding ARMA models, *we always assume process stationarity*.
    If stationarity cannot be assumed, neither autoregressive nor moving average models
    can be used. In the next section of this chapter, we will discuss integrating
    into ARMA models first-order differencing as a method for conditionally stationarizing
    a process to overcome limitations of non-stationarity.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于ARMA模型的一点，我们**总是假设过程平稳性**。如果无法假设平稳性，则既不能使用自回归模型也不能使用移动平均模型。在本章的下一节中，我们将讨论将一阶差分整合到ARMA模型中，作为条件平稳化过程以克服非平稳性局限性的方法。
- en: Models for non-stationary time series
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非平稳时间序列的模型
- en: 'In the previous section, we discussed ARMA models for stationary time series
    data. In this section, we will look at non-stationary time series data and extend
    our model to work with non-stationary data. Let us start by taking a look at some
    sample data (shown in *Figure 11**.17*). There are two series: US GDP (left) and
    airline passenger volume (right).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了适用于平稳时间序列数据的ARMA模型。在本节中，我们将探讨非平稳时间序列数据，并将我们的模型扩展到可以处理非平稳数据。让我们首先查看一些样本数据（如图*11.17*所示）。有两个序列：美国GDP（左）和航空旅客量（右）。
- en: '![Figure 11.17 – US GDP (left) and airline passenger (right) time series](img/B18945_11_017.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图11.17 – 美国GDP（左）和航空旅客（右）时间序列](img/B18945_11_017.jpg)'
- en: Figure 11.17 – US GDP (left) and airline passenger (right) time series
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 – 美国GDP（左）和航空旅客（右）时间序列
- en: The US GDP series appears to exhibit an upward trend with some variations in
    the series. The airline passenger volume series also exhibits an upward trend,
    but there also appears to be a repeated pattern in the series. The repeated pattern
    in the airline series is called **seasonality**. Both series are non-stationary
    because of the apparent trend. Additionally, the airline passenger volume series
    appears to exhibit non-constant variance. We will model the GDP series with ARIMA,
    and we will model the seasonal ARIMA. Let’s take a look at these models.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 美国GDP序列似乎表现出上升趋势，序列中也有一些变化。航空旅客量序列也表现出上升趋势，但序列中似乎也存在重复的模式。航空序列中的重复模式称为**季节性**。由于明显的趋势，这两个序列都是非平稳的。此外，航空旅客量序列似乎表现出非恒定的方差。我们将使用ARIMA模型来模拟GDP序列，并将模拟季节性ARIMA。让我们来看看这些模型。
- en: ARIMA models
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ARIMA模型
- en: '**ARIMA** is an acronym for **AutoRegressive Integrated Moving Average**. This
    model is a generalization of the ARMA model that can be applied to non-stationary
    time series data. The new part added to this model is “integrated,” which is a
    **differencing** operation applied to the time series to **stationarize** (to
    make stationary) the time series. After the time series is stationarized, we can
    fit an ARMA model to the differenced data. Let’s take a look at the mathematics
    of this model. We will start with understanding how differencing works, and then
    put the whole model ARIMA model together.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**ARIMA**是**自回归积分移动平均**的缩写。这个模型是ARMA模型的一种推广，可以应用于非平稳时间序列数据。这个模型新增的部分是“积分”，它是对时间序列进行**差分**操作以**平稳化**（使时间序列平稳）。时间序列平稳化后，我们可以对差分数据进行ARMA模型的拟合。让我们来看看这个模型的数学原理。我们将从理解差分是如何工作的开始，然后构建整个ARIMA模型。'
- en: Differencing
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 差分
- en: 'Differencing data is computing the difference between consecutive data points.
    The resulting data from differencing represents the *change* between each data
    point. We can write the difference as such:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 差分数据是计算连续数据点之间的差异。差分后的数据代表每个数据点之间的**变化**。我们可以将差分写成如下形式：
- en: y ′ t = y t − y t−1
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: y′t = yt − yt−1
- en: 'This equation is the first-order difference, meaning it is the first difference
    between the data points. It may be necessary to make additional differences between
    the data points to stationarize the series. The second difference represents the
    *change of changes* between the data points. The second-order difference can be
    written thusly:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程是一阶差分，意味着它是数据点之间的第一个差分。可能需要在对数据点进行额外的差分以使序列平稳化。二阶差分代表数据点之间的**变化的改变**。二阶差分可以写成如下形式：
- en: y ″ t = y ′  t − y ′  t−1 = (y t − y t−1) − (y t−1 − y t−2)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: y″t = y′t − y′t−1 = (yt − yt−1) − (yt−1 − yt−2)
- en: The “order” is simply the number of times a difference operation is applied.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: “阶数”简单地指差分操作应用的次数。
- en: The ARIMA model
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ARIMA模型
- en: 'As mentioned earlier, the ARIMA model is ARMA with the addition of differencing
    to make the time series stationary (stationarize the time series). Then we can
    express an ARIMA model mathematically as follows, where y′ t is the differenced
    series, differenced d times until it is stationary:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ARIMA模型是ARMA模型，通过添加差分使时间序列平稳（使时间序列平稳化）。然后我们可以将ARIMA模型数学上表示如下，其中y′ t是差分序列，差分d次直到它平稳：
- en: y′ t = c + ϕ 1 y′ t−1 + … + ϕ p y ′  t−p + ϵ t + θ 1 ϵ t−1 + … + ϕ q ϵ t−q
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: y′ t = c + ϕ 1 y′ t−1 + … + ϕ p y ′  t−p + ϵ t + θ 1 ϵ t−1 + … + ϕ q ϵ t−q
- en: 'The ARIMA model has three orders, which are denoted ARIMA(p,d,q):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA模型有三个阶数，分别表示为ARIMA(p,d,q)：
- en: p – the autoregressive order
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: p – 自回归阶数
- en: d – the differencing order
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: d – 差分阶数
- en: q – the moving average order
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: q – 移动平均阶数
- en: 'With more complicated models such as ARIMA, we will tend to describe them with
    backshift notation since it is easier to express these models with backshift notation.
    An ARIMA model will take the following form using backshift notation:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像ARIMA这样的更复杂模型，我们倾向于用后移符号来描述它们，因为用后移符号表达这些模型更容易。使用后移符号，ARIMA模型将采取以下形式：
- en: (1 − ϕ 1 B − … − ϕ p B p) (1 − B) d y t = c + (1 + θ 1 B + … + θ q B q) 𝝐 t
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: (1 − ϕ 1 B − … − ϕ p B p) (1 − B) d y t = c + (1 + θ 1 B + … + θ q B q) 𝝐 t
- en: ↑          ↑         ↑
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ↑          ↑         ↑
- en: AR(p) d differences               MA(q)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: AR(p) d差分             MA(q)
- en: 'Notice the term for the differences in the equation: (1 − B) d. In the previous
    section, we discussed roots as related to stationary models. In that context,
    the roots were always outside of the unit circle. With an ARIMA model, we add
    unit roots to the model. To understand the impact of a unit root, let’s simulate
    an AR(1) model and see what happens as the root of the model is moved toward one.
    These simulations are shown in *Figure 11**.18*.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意方程中差异项的表示：(1 − B) d。在上一节中，我们讨论了与平稳模型相关的根。在那个背景下，根始终位于单位圆之外。在ARIMA模型中，我们向模型中添加单位根。为了理解单位根的影响，让我们模拟一个AR(1)模型，并观察当模型根值接近1时会发生什么。这些模拟显示在图11.18中。
- en: '![Figure 11.18 – AR(1) simulations with root approaching 1](img/B18945_11_018.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图11.18 – 根值接近1的AR(1)模拟](img/B18945_11_018.jpg)'
- en: Figure 11.18 – AR(1) simulations with root approaching 1
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18 – 根值接近1的AR(1)模拟
- en: We can make two observations from the simulations shown in *Figure 11**.18*.
    The first observation is that the time series appear to exhibit more wandering
    behavior as the root increases toward one. For instance, the middle-time series
    shows more wandering from the mean than the top-time series. The bottom time series
    (with a root of one), does not appear to regress toward a mean such as the other
    two simulations. The second observation is about the autocorrelations. As the
    root of the AR(1) approaches 1, the autocorrelations get stronger and decrease
    slower over the lags. These two observations are characteristic of a series with
    a root near or at one. Additionally, the presence of unit roots will dominate
    the time series behavior, making it easy to recognize from the autocorrelation
    plot.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 从图11.18所示的模拟中，我们可以得出两个观察结果。第一个观察结果是，随着根值逐渐接近1，时间序列似乎表现出更多的游走行为。例如，中间时间序列相对于顶部时间序列，从平均值出发的游走行为更多。底部时间序列（根值为1）似乎不像其他两个模拟那样回归到平均值。第二个观察结果是关于自相关性的。随着AR(1)的根值接近1，自相关性变得更强，并且随着滞后时间的增加而减慢。这两个观察结果是根值接近或等于1的序列的特征。此外，单位根的存在将主导时间序列的行为，使得从自相关图上容易识别。
- en: Fitting an ARIMA model
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适配ARIMA模型
- en: 'There are two steps to fit an ARIMA model: (1) stationarize the series from
    differencing to determine the difference order and (2) fit an ARMA model to the
    resulting series. In the previous section, we discussed how to fit an ARMA model
    so in this section, we will focus on the first step.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 适配ARIMA模型有两个步骤：(1)通过差分使序列平稳以确定差分阶数，(2)将ARMA模型拟合到得到的序列。在上一节中，我们讨论了如何拟合ARMA模型，因此在本节中，我们将重点关注第一步。
- en: At the beginning of this section, we showed a time series of US GDP values.
    We will use that time series as a case study for fitting an ARIMA model. First,
    let’s take a look at the series and its autocorrelations again. The series and
    autocorrelations are shown in *Figure 11**.19*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开始，我们展示了一个美国GDP的时间序列。我们将使用这个时间序列作为拟合ARIMA模型的案例研究。首先，让我们再次查看该序列及其自相关性。序列和自相关性显示在图11.19中。
- en: '![Figure 11.19 – US GDP time series and autocorrelations](img/B18945_11_019.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图11.19 – 美国GDP时间序列和自相关性](img/B18945_11_019.jpg)'
- en: Figure 11.19 – US GDP time series and autocorrelations
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19 – 美国GDP时间序列和自相关图
- en: 'From the plots shown in *Figure 11**.19*, it appears that the time series of
    US GPD data is non-stationary time series. The time series exhibits wandering
    behavior, and the autocorrelations are strong and decrease slowly. As we discussed,
    this is characteristic behavior of unit roots. For secondary evidence, we can
    use the Dickey-Fuller test for unit root. The null hypothesis of the Dickey-Fuller
    test is that a unit root is present in the time series. The following code shows
    how to use the Dickey-Fuller test from `pmdarima`. The test returns a p-value
    of 0.74 indicating we cannot reject the null hypothesis, meaning that the time
    series should be differenced:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 从图11**.19**所示的图中可以看出，美国GDP数据的时间序列是非平稳时间序列。时间序列表现出游走行为，自相关性强且缓慢下降。正如我们讨论的那样，这是单位根的特征行为。作为次要证据，我们可以使用Dickey-Fuller测试来检验单位根。Dickey-Fuller测试的零假设是时间序列中存在单位根。以下代码显示了如何使用`pmdarima`中的Dickey-Fuller测试。测试返回的p值为0.74，这意味着我们不能拒绝零假设，这意味着时间序列应该进行差分：
- en: '[PRE24]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can take the first difference of time series using the `diff` function from
    `numpy`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`numpy`中的`diff`函数对时间序列进行第一次差分：
- en: '[PRE25]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Taking the first difference, we arrive at a new time series as shown in *Figure
    11**.20*:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 进行第一次差分后，我们得到一个新的时间序列，如图11**.20**所示：
- en: '![Figure 11.20 – The first difference of US GDP time series](img/B18945_11_020.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图11.20 – 美国GDP时间序列的第一差分](img/B18945_11_020.jpg)'
- en: Figure 11.20 – The first difference of US GDP time series
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20 – 美国GDP时间序列的第一差分
- en: 'The first difference of the US GDP time series shown in *Figure 11**.20* appears
    to be stationary. In fact, it appears to be consistent with an AR(2) model. We
    double-check whether we need to take an additional difference using the Dickey-Fuller
    test on the first differenced data:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 美国GDP时间序列图11**.20**中显示的第一个差异似乎具有平稳性。实际上，它似乎与AR(2)模型一致。我们通过在第一差分数据上使用Dickey-Fuller测试来双重检查是否需要额外的差分：
- en: '[PRE26]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Dickey-Fuller test returns a p-value of 0.01 for the first differenced data,
    which means we can reject the null hypothesis and we can stop differencing the
    data. That means that our ARIMA model for this data will have a difference order
    of 1 (d = 1).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Dickey-Fuller测试对第一差分数据返回的p值为0.01，这意味着我们可以拒绝零假设，我们可以停止对数据进行差分。这意味着我们的ARIMA模型对于这些数据将有一个差分阶数为1（d
    = 1）。
- en: 'After finding the difference order, we can fit an ARMA model to the differenced
    data. Since we have already discussed fitting ARMA models, we will use an automated
    fitting method provided by `pmdarima`. `pm.auto_arima` is a function for automatically
    fitting an ARIMA model to data, however, in this case, we will use it to fit the
    ARMA portion from the differenced series. The output of `pm.auto_arima` for the
    first difference data is shown in the following code block:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到差分阶数后，我们可以将ARMA模型拟合到差分数据上。由于我们已经讨论了ARMA模型的拟合，我们将使用`pmdarima`提供的自动拟合方法。`pm.auto_arima`是一个用于自动将ARIMA模型拟合到数据的函数，然而，在这种情况下，我们将使用它来拟合差分序列的ARMA部分。以下代码块显示了`pm.auto_arima`对第一差分数据的输出：
- en: '[PRE27]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Since the ARMA fit for the differenced data is ARMA(2,0), the ARIMA orders for
    the original time series would be ARIMA(2,1,0). Next, we will look at forecasting
    from an ARIMA model.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于差分数据的ARMA拟合是ARMA(2,0)，原始时间序列的ARIMA阶数将是ARIMA(2,1,0)。接下来，我们将查看从ARIMA模型进行预测。
- en: Forecasting with ARIMA
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ARIMA进行预测
- en: 'Once we have a fit model, we can forecast with that model. As mentioned in
    previous chapters, when making predictions we should create a train-test split,
    so we have data to compare with the predictions. The model should only fit the
    training data to avoid data leakage. We can use the `train_test_split` function
    from `pmdarima` to split the data. Then we proceed with the usual steps: split,
    train, and predict. The code for this is shown in the following code block:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个拟合的模型，我们就可以用该模型进行预测。如前几章所述，在做出预测时，我们应该创建一个训练-测试分割，以便我们有数据可以与预测进行比较。模型应该只拟合训练数据以避免数据泄露。我们可以使用`pmdarima`中的`train_test_split`函数来分割数据。然后我们进行常规步骤：分割、训练和预测。以下代码块显示了这一过程：
- en: '[PRE28]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code fits an ARIMA model with `auto_arima` and then forecasts
    the size of the test set using the `predict` method of the ARIMA object. The forecasts
    for the series generated by the code are shown in *Figure 11**.21*:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用`auto_arima`拟合ARIMA模型，然后使用ARIMA对象的`predict`方法预测测试集的大小。由代码生成的序列预测结果如图11**.21**所示：
- en: '![Figure 11.21 – US GDP ARIMA forecast over test split](img/B18945_11_021.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图11.21 – 测试分割上的美国GDP ARIMA预测](img/B18945_11_021.jpg)'
- en: Figure 11.21 – US GDP ARIMA forecast over test split
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21 – 测试分割上的美国GDP ARIMA预测
- en: The forecast of the US GDP in *Figure 11**.21* appears to follow the trend of
    the data but does not capture the small variations in the series. However, the
    variation is captured in the prediction interval (labeled as “interval”). This
    model appears to provide a reasonably good prediction of the test data. Note that
    the interval increases over time. This is because predictions become more uncertain
    farther in the future. Generally, shorter forecasts are more likely to be accurate.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图11.21*中，美国GDP的预测似乎遵循数据的趋势，但没有捕捉到序列中的小变化。然而，这种变化在预测区间（标记为“区间”）中被捕捉到。这个模型似乎为测试数据提供了相当好的预测。请注意，区间随时间增加。这是因为预测在未来的不确定性增加。一般来说，短期预测更可能准确。
- en: In this section, we built on the ARMA model and extended it to non-stationary
    data using differencing, which formed the ARIMA model. In the next section, we
    will look at non-stationary time series that include seasonal effects and make
    a further extension to the ARIMA model.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们基于ARMA模型，并使用差分将其扩展到非平稳数据，从而形成了ARIMA模型。在下一节中，我们将查看包含季节性影响的不平稳时间序列，并将进一步扩展ARIMA模型。
- en: Seasonal ARIMA models
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 季节性ARIMA模型
- en: Let’s look at another characteristic of time series called **seasonality**.
    Seasonality is the presence of a pattern in a time series that repeats at regular
    intervals. Seasonal time series are common in nature. For example, yearly weather
    patterns and daily sunshine patterns are seasonal patterns. Back at the start
    of the non-stationary section, we showed an example of a non-stationary time series
    with seasonality. This time series is shown again in *Figure 11**.22* along with
    its ACF plot.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看时间序列的另一个特征，称为**季节性**。季节性是指时间序列中存在一个在固定间隔重复的模式。季节性时间序列在自然界中很常见。例如，年天气模式和日阳光模式都是季节性模式。回到非平稳性部分的开始，我们展示了一个具有季节性的非平稳时间序列的例子。这个时间序列再次在*图11.22*中展示，并附有它的ACF图。
- en: '![Figure 11.22 – Airline volume data and ACF plot](img/B18945_11_022.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图11.22 – 航空客流量数据和ACF图](img/B18945_11_022.jpg)'
- en: Figure 11.22 – Airline volume data and ACF plot
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22 – 航空客流量数据和ACF图
- en: The time series shown in *Figure 11**.22* is the monthly total of international
    airline passengers from 1949 to 1960 [*3*]. There is a definite repeated pattern
    in this time series. To model this type of data, we will need to an additional
    term to the ARIMA model to account for seasonality.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.22*中显示的时间序列是1949年至1960年国际航空旅客的月度总计[*3*]。在这个时间序列中有一个明显的重复模式。为了模拟这类数据，我们需要在ARIMA模型中添加一个额外的项来解释季节性。'
- en: Seasonal differencing
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 季节性差分
- en: 'We will use a similar approach for modeling this type of time series as we
    did with ARIMA. We will start by using differencing to stationarize the data,
    then fit an ARMA model to the differenced data. With seasonal time series, we
    will need to use seasonal differencing to remove the seasonal effects, which we
    can show mathematically:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与ARIMA相同的方法来建模这种类型的时间序列。我们首先将使用差分来使数据平稳，然后对差分数据进行ARMA模型拟合。对于季节性时间序列，我们需要使用季节性差分来消除季节性影响，这可以通过数学公式表示：
- en: y ′ t = y t − y t−T
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: y′t = yt − yt−T
- en: 'Where T is the period of the season. For example, the time series in *Figure
    11**.22* exhibits monthly seasonality and each data point represents one month;
    therefore, the T = 12 for the airline volume data. Then, for the airline data,
    we would use the following difference equation to remove seasonality:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 其中T是季节的周期。例如，*图11.22*中的时间序列表现出月度季节性，每个数据点代表一个月；因此，航空客流量数据的T = 12。然后，对于航空数据，我们将使用以下差分方程来消除季节性：
- en: y ′ t = y t − y t−12
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: y′t = yt − yt−12
- en: We can also identify the seasonality by observing where peaks occur in the ACF
    plot. The ACF plot in *Figure 11**.22* shows a peak at 12, indicating a seasonal
    period of 12, which is consistent with our knowledge of the time series.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过观察ACF图中峰值出现的位置来识别季节性。*图11.22*中的ACF图显示在12处有一个峰值，表明季节周期为12，这与我们对时间序列的了解一致。
- en: We will see how to apply seasonal differences later in this section using `pmdarima`.
    Let’s take a look at how seasonality is included in the model.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节稍后，我们将使用`pmdarima`展示如何应用季节差分。让我们看看季节性是如何包含在模型中的。
- en: Seasonal ARIMA
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 季节性ARIMA
- en: 'As mentioned in the ARIMA section, we will be differencing the original series,
    then fitting a stationary model to the differenced data. Then our time series
    would be described by the following equation where y′ t is the differenced series
    (including seasonal and sequential differences):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如在ARIMA部分所述，我们将对原始序列进行差分，然后对差分数据进行平稳模型拟合。然后我们的时间序列将由以下方程描述，其中y′t是差分序列（包括季节性和顺序差分）：
- en: y′ t = c + ϕ 1 y′ t−1 + … + ϕ p y ′  t−p + ϵ t + θ 1 ϵ t−1 + … + ϕ q ϵ t−q
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: y′t = c + ϕ1 y′t−1 + … + ϕp y′t−p + ϵt + θ1 ϵt−1 + … + ϕq ϵt−q
- en: 'We can express the whole model with backshift notation:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用后移符号表示整个模型：
- en: (1 − ϕ 1 B − … − ϕ p B p) (1 − B) d (1 − B s)y t = c + (1 + θ 1 B + … + θ q
    B q) 𝝐 t
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: (1 − ϕ1 B − … − ϕp Bp) (1 − B) d (1 − Bs)y t = c + (1 + θ1 B + … + θq Bq) 𝝐t
- en: ↑     ↑    ↑                ↑
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ↑     ↑    ↑                ↑
- en: AR(p)         d diff   seasonal diff                              MA(q)
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: AR(p)         d 差分       季节差分                                 MA(q)
- en: 'We have a new term in the equation that accounts for seasonality: (1 − B s).
    We are adding a new order parameter to the model: s. This model is typically denoted
    ARUMA(p,d,q,s).'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在方程中添加了一个考虑季节性的新项：(1 − Bs)。我们向模型添加了一个新的阶数参数：s。此模型通常表示为ARUMA(p,d,q,s)。
- en: SARIMA models
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: SARIMA模型
- en: In this section, we are only covering seasonal differencing. There are more
    complex models that allow for moving average seasonality and autoregressive seasonality
    called SARIMA and denoted SARIMA(p,d,q)(P,D,Q)[m]. These models are beyond the
    scope of this chapter. However, we would encourage the reader to explore these
    models further after mastering the topics found in this chapter and the next chapter.
    The ARIMA model covered in this chapter is a subset of the SARIMA model, which
    accounts for seasonal differencing, which is the “D” order of SARIMA(p,d,q)(P,D,Q)[m].
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们仅涵盖季节差分。存在更复杂的模型，允许移动平均季节性和自回归季节性，称为SARIMA，表示为SARIMA(p,d,q)(P,D,Q)[m]。这些模型超出了本章的范围。然而，我们鼓励读者在掌握本章和下一章的主题后进一步探索这些模型。本章中涵盖的ARIMA模型是SARIMA模型的一个子集，它考虑了季节差分，即SARIMA(p,d,q)(P,D,Q)[m]中的“D”阶数。
- en: Just as the (1 − B) d term we added for ARIMA, the (1 − B s) term adds roots
    to the unit circle. However, unlike the roots from (1 − B) d, the roots from (1
    − B s) are distributed uniformly around the unit circle. These roots can be calculated
    and plotted programmatically with `numpy` and `matplotlib` or automatically with
    computational intelligence tools such as Wolfram Alpha ([https://www.wolframalpha.com/](https://www.wolframalpha.com/)).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们为ARIMA添加的(1 − B)d项一样，(1 − Bs)项向单位圆添加了根。然而，与(1 − B)d的根不同，(1 − Bs)的根均匀分布在单位圆周围。这些根可以使用`numpy`和`matplotlib`或使用计算智能工具（如Wolfram
    Alpha [https://www.wolframalpha.com/](https://www.wolframalpha.com/)）进行计算和绘制。
- en: Fitting an ARIMA model with seasonality
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拟合具有季节性的ARIMA模型
- en: 'We will take the following steps to fit an ARIMA model with seasonality:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取以下步骤来拟合具有季节性的ARIMA模型：
- en: Remove seasonality with differencing.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用差分去除季节性。
- en: Remove additional non-stationarity with differencing.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用差分去除额外的非平稳性。
- en: Fit a stationary model to the resulting series.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将平稳模型拟合到结果序列。
- en: This is essentially the same process we used to fit an ARIMA model, but there
    is an additional step to handle the seasonal component. Let us walk through an
    example with the airline data.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上是我们用来拟合ARIMA模型的过程，但有一个额外的步骤来处理季节性成分。让我们通过一个使用航空公司数据的例子来讲解。
- en: 'We will start with using differencing to remove the seasonal component of the
    time series. Recall that the seasonal period of the airline time series is 12,
    meaning that we need to perform differencing at lag 12 as shown with this equation:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用差分来去除时间序列的季节性成分。回想一下，航空公司时间序列的季节周期是12，这意味着我们需要在滞后12处进行差分，如下方程所示：
- en: y ′ t = y t − y t−12
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: y′t = yt − yt−12
- en: 'We can perform this difference using the `diff` function from `pmdarima`. The
    following code shows how to perform the 12th lagged difference on the airline
    data:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`pmdarima`中的`diff`函数执行此差分。以下代码显示了如何在航空公司数据上执行第12滞后差分：
- en: '[PRE29]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After performing the seasonal difference, we get the differenced series shown
    in *Figure 11**.23* along with the ACF plot. The seasonal portion of the time
    series appears to be completely removed. The differenced series does not appear
    to exhibit any repeating patterns. Additionally, the ACF plot does not show the
    seasonal peak that was present in the ACF plot of the original data:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行季节差分后，我们得到*图11.23*中显示的差分序列以及ACF图。时间序列的季节部分似乎已经完全去除。差分序列似乎没有显示出任何重复的模式。此外，ACF图没有显示原始数据ACF图中存在的季节性峰值：
- en: '![Figure 11.23 – Airline data after seasonal difference](img/B18945_11_023.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图11.23 – 季节差分后的航空公司数据](img/B18945_11_023.jpg)'
- en: Figure 11.23 – Airline data after seasonal difference
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23 – 季节差分后的航空公司数据
- en: 'With the seasonal portion of the time series removed, we need to determine
    whether we need to take any additional differences to stationarize the new time
    series. The differenced series in *Figure 11**.23* appears to exhibit a trend.
    The original data also exhibited a trend. As before, we can use the Dickey-Fuller
    test to get additional evidence on whether we should apply additional differences.
    Running the Dickey-Fuller test on this series will result in a p-value of 0.099,
    which suggests that we should take a difference in the series to account for a
    unit root:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在去除时间序列的季节部分后，我们需要确定是否需要取任何额外的差分来使新的时间序列平稳化。*图11.23*中的差分序列似乎显示出趋势。原始数据也显示出趋势。与之前一样，我们可以使用Dickey-Fuller测试来获取更多证据，以确定我们是否应该应用额外的差分。对这个序列运行Dickey-Fuller测试将得到一个p值为0.099，这表明我们应该对序列取差分以解释单位根：
- en: '[PRE30]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Taking the first difference of the series will result in the series shown in
    *Figure 11**.24*. After taking these two differences the series appears to be
    sufficiently stationarized.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 对序列取一阶差分将导致*图11.24*中显示的序列。在取这两个差分之后，序列似乎已经足够平稳化。
- en: '![Figure 11.24 – Airline data after seasonal and first difference](img/B18945_11_024.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图11.24 – 季节差分和一阶差分后的航空公司数据](img/B18945_11_024.jpg)'
- en: Figure 11.24 – Airline data after seasonal and first difference
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24 – 季节差分和一阶差分后的航空公司数据
- en: 'The series in *Figure 11**.24* shows the stationarized version of the airline
    data. Based on the ACF plot, we should be able to fit a relatively simple ARMA
    model to the stationarized series. We will use `auto_arima` function to make an
    automatic fit as we did in the ARIMA section:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.24*中的序列显示了航空公司数据的平稳化版本。根据ACF图，我们应该能够对平稳化序列拟合一个相对简单的ARMA模型。我们将使用`auto_arima`函数进行自动拟合，就像我们在ARIMA部分所做的那样：'
- en: '[PRE31]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Fitting the differenced data with `auto_arima` returns an AR(1) model. A simple
    model as we expected.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`auto_arima`对差分数据进行拟合返回一个AR(1)模型。正如我们所期望的，这是一个简单的模型。
- en: 'Putting this all together our resulting model is an ARUMA(1,1,0,12). As with
    the previous ARIMA example, we could have fit this model with `auto_arima`, but
    we walked through the differencing steps here to help build intuition for what
    each difference element does to the series. Let’s take a look at the direct fit
    from `auto_arima` now:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们得到的模型是ARUMA(1,1,0,12)。与之前的ARIMA示例一样，我们可以使用`auto_arima`来拟合这个模型，但我们在本例中详细说明了差分步骤，以帮助建立对每个差分元素对序列影响的理解。现在让我们看看`auto_arima`的直接拟合结果：
- en: '[PRE32]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We see that `auto_arima` found the same model that we did using manual differencing.
    Note the model is denoted in SARIMA format (see earlier callout about SARIMA).
    The (0,1,0)[12] means seasonality of 12 when one difference for the seasonality.
    Now that we have a fit model, let’s look at forecasting for our seasonal model.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`auto_arima`找到了与我们使用手动差分得到相同的模型。注意模型以SARIMA格式表示（参见关于SARIMA的早期说明）。(0,1,0)[12]表示当季节性有一个差分时，季节性为12。现在我们有了拟合模型，让我们看看我们对季节性模型的预测。
- en: Forecasting ARIMA with seasonality
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有季节性的ARIMA预测
- en: 'Once we have a fit model, we can forecast with that model. As mentioned in
    the section on forecasting with ARIMA, when should we make a train-test split
    so we have data to compare with the predictions? We will use the same procedure:
    split the data, train the model, and forecast over the test set size:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了拟合模型，我们就可以用这个模型进行预测。如ARIMA预测部分所述，我们应该何时进行训练-测试集划分以便我们有数据来比较预测结果？我们将使用相同的程序：分割数据，训练模型，并在测试集大小上进行预测：
- en: '[PRE33]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code fits a full SARIMA model with `auto_arima` and then forecasts
    the size of the test set using the `predict` method. The forecasts for the series
    generated by the code are shown in *Figure 11**.25*.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用`auto_arima`拟合了一个完整的SARIMA模型，然后使用`predict`方法预测测试集的大小。由代码生成的序列预测显示在*图11.25*中。
- en: '![Figure 11.25 – SARIMA forecast of the airline data](img/B18945_11_025.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图11.25 – 航空公司数据的SARIMA预测](img/B18945_11_025.jpg)'
- en: Figure 11.25 – SARIMA forecast of the airline data
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25 – 航空公司数据的SARIMA预测
- en: The forecast of the airline data in *Figure 11**.25* appears to capture the
    variation of the data very well. This is likely due to the strength of the seasonality
    component in the time series. Note that the prediction intervals increase over
    time just as with the ARIMA prediction intervals, but the intervals follow the
    general pattern of the series. This is an impact of the additional knowledge of
    seasonality in the series.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.25*中的航空公司数据预测似乎很好地捕捉了数据的变动。这可能是由于时间序列中季节性成分的强度。请注意，预测区间随着时间的推移而增加，就像ARIMA预测区间一样，但区间遵循序列的一般模式。这是由于对序列中季节性的额外知识的影响。'
- en: In this section, we discussed ARIMA models with seasonality and showed how to
    remove seasonal components. We also looked at forecasting a model with seasonality.
    In the next section, we will take a closer look at validating time series models.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了具有季节性的ARIMA模型，并展示了如何去除季节性成分。我们还研究了具有季节性的模型预测。在下一节中，我们将更详细地探讨验证时间序列模型。
- en: More on model evaluation
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于模型评估
- en: 'In the previous sections, we discussed other methods to prepare data, test
    and validate models. In this section, we will discuss how to validate time series
    models and introduce several methods for validating time series models. We will
    cover the following methods for model evaluation: **resampling**, **shifting**,
    **optimized persistence forecasting,** and **rolling** **window forecasting**.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了其他准备数据、测试和验证模型的方法。在本节中，我们将讨论如何验证时间序列模型，并介绍几种验证时间序列模型的方法。我们将涵盖以下模型评估方法：**重采样**、**移动**、**优化持久预测**和**滚动窗口预测**。
- en: 'The real-world dataset considered in this section is Coca Cola stock data collected
    from Yahoo Finance databases from 01/19/1962 to 12/19/2021 for stock price prediction.
    This is a time series analysis to forecast the future stock value of a given stock.
    The reader can download the dataset from the Kaggle platform for this analysis.
    To motivate the study, we first go to explore the Coco Cola stock dataset:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 本节考虑的实际数据集是从Yahoo Finance数据库中收集的1962年1月19日至2021年12月19日的可口可乐股票数据，用于股票价格预测。这是一项时间序列分析，用于预测给定股票的未来股票价值。读者可以从Kaggle平台下载该数据集进行分析。为了激发研究兴趣，我们首先去探索可口可乐股票数据集：
- en: '[PRE34]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![Figure 11.26 – Coco Cola dataset](img/B18945_11_026.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图11.26 – 可口可乐数据集](img/B18945_11_026.jpg)'
- en: Figure 11.26 – Coco Cola dataset
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.26 – 可口可乐数据集
- en: 'The Date index is related to 15096 trading days from 01/19/1962 to 12/19/2021\.
    The `High` and `Low` columns here refer to the maximum and minimum prices on each
    trading day. `Open` and `Close` refer to the stock prices when the market was
    open and closed on the same trading day. The total amount of trading stocks in
    each day refers to the `Volume` column and the last column (`Adj Close`) refers
    to adjusted values (combining with stock splits, dividends, etc.). To illustrate
    how resampling, shifting, rolling windows, and expanding windows perform, we narrow
    down to use only the `Open` column from the year 2016:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 日期索引与从1962年1月19日到2021年12月19日的15096个交易日相关。这里的`High`和`Low`列分别指每个交易日的最高和最低价格。`Open`和`Close`分别指在同一个交易日的市场开盘和收盘时的股价。每天交易的股票总量指的是`Volume`列，而最后一列（`Adj
    Close`）指的是调整后的值（结合股票分割、股息等）。为了说明重采样、移动、滚动窗口和扩展窗口的性能，我们仅使用2016年的`Open`列：
- en: '[PRE35]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The data was collected by trading dates. However, we will perform the study
    monthly. The **resampling** technique is used to aggregate data from days to months.
    This idea motivates us to introduce this technique.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是根据交易日期收集的。然而，我们将按月进行这项研究。使用**重采样**技术将数据从日聚合到月。这个想法激励我们引入这项技术。
- en: Resampling
  id: totrans-403
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重采样
- en: '`resample()` function to change time frequencies. The following code illustrates
    the resampling technique in Python:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`resample()`函数用于更改时间频率。以下代码展示了Python中的重采样技术：'
- en: '[PRE36]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is the output of the previous code:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前一段代码的输出：
- en: '![Figure 11.27 – Resampling for Coco Cola dataset](img/B18945_11_027.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图11.27 – Coco Cola数据集的重采样](img/B18945_11_027.jpg)'
- en: Figure 11.27 – Resampling for Coco Cola dataset
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.27 – Coco Cola数据集的重采样
- en: We observe that the plots become smoother when time frequencies decrease. Next,
    we discuss the shifting method used in time series.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到当时间频率降低时，图表变得更加平滑。接下来，我们将讨论时间序列中使用的平移方法。
- en: Shifting
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 平移
- en: 'In time series analysis, it is not uncommon to `shift()` function to create
    new features:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列分析中，使用`shift()`函数创建新特征并不罕见：
- en: '[PRE37]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Figure 11.28 – First five rows of Coco Cola stock data with price shifted
    once](img/B18945_11_028.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![图11.28 – Coco Cola股票数据的前五行，价格已调整一次](img/B18945_11_028.jpg)'
- en: Figure 11.28 – First five rows of Coco Cola stock data with price shifted once
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.28 – Coco Cola股票数据的前五行，价格已调整一次
- en: 'Observe that the first row of the `price_lag_1` column is filled with a NaN
    value. We can replace the missing value with the `fill_value` parameter:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到`price_lag_1`列的第一行填充了一个NaN值。我们可以用`fill_value`参数替换缺失值：
- en: '[PRE38]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, we discuss the forecasting methods such as **optimized persistence**
    and **rolling window forecasting**. Another resource related to these methods
    can be found in [*3*].
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论预测方法，如**优化持久性**和**滚动窗口预测**。有关这些方法的另一个资源可以在[*3*]中找到。
- en: Optimized persistence forecasting
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优化持久性预测
- en: 'We will convert the Coco Cola stock price time frequency to monthly frequency
    from 2016 using resampling and then we apply an optimized persistence forecasting
    technique to predict the future value using the previous observation. RMSE scores
    are considered to evaluate persistence models:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用重采样将Coco Cola股票价格的时间频率从2016年开始转换为月度频率，然后我们应用优化持久性预测技术，使用之前的观测值来预测未来的值。RMSE得分用于评估持久性模型：
- en: '[PRE39]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 11.29 – RMSE scores for Optimized persistence forecasting](img/B18945_11_029.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![图11.29 – 优化持久性预测的RMSE得分](img/B18945_11_029.jpg)'
- en: Figure 11.29 – RMSE scores for Optimized persistence forecasting
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.29 – 优化持久性预测的RMSE得分
- en: 'We observe that when p=6, the RMSE score is the smallest:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到当p=6时，RMSE得分是最小的：
- en: '![Figure 11.30 – Optimized Persistence Forecasting, test versus prediction](img/B18945_11_030.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![图11.30 – 优化持久性预测，测试与预测对比](img/B18945_11_030.jpg)'
- en: Figure 11.30 – Optimized Persistence Forecasting, test versus prediction
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.30 – 优化持久性预测，测试与预测对比
- en: 'Running the persistence test again with p=6, we can see the following:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行持久性测试，使用p=6，我们可以看到以下结果：
- en: '[PRE40]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we can produce a visualization:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以生成一个可视化：
- en: '![Figure 11.31 – Optimized Persistence Forecasting](img/B18945_11_031.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![图11.31 – 优化持久性预测](img/B18945_11_031.jpg)'
- en: Figure 11.31 – Optimized Persistence Forecasting
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.31 – 优化持久性预测
- en: The blue curve is the test value, and the orange curve is for the prediction.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色曲线是测试值，橙色曲线是预测值。
- en: Rolling window forecast
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 滚动窗口预测
- en: 'This technique creates a **rolling window** with a specified window size and
    then performs a statistic calculation in this window, using it for forecasting
    which rolls through the data used in a study. We conduct a similar study as in
    the last part on the Coco Cola stock price dataset from 2016 using a monthly resampling
    dataset:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术创建了一个具有指定窗口大小的**滚动窗口**，然后在这个窗口内进行统计计算，用于预测，该预测会滚动通过研究中使用的数据。我们使用2016年的Coco
    Cola股票价格数据集，采用月度重采样数据集进行类似的研究：
- en: '[PRE41]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![Figure 11.32 – Rolling window forecasting](img/B18945_11_032.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![图11.32 – 滚动窗口预测](img/B18945_11_032.jpg)'
- en: Figure 11.32 – Rolling window forecasting
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.32 – 滚动窗口预测
- en: With window size = 9, the RMSE of 3.808 is the smallest. Run the Python code
    again with window size = 9 we produce a similar visualization as with the Optimized
    Persistence Forecast.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口大小为9时，RMSE为3.808是最小的。再次运行Python代码，使用窗口大小=9，我们得到与优化持久性预测相似的可视化效果。
- en: Summary
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we discussed various methods for modeling univariate time series
    data from stationary time series models such as ARMA to non-stationary models
    such as ARIMA. We started with stationary models and discussed how to identify
    modeling approaches based on the characteristics of time series. Then we built
    on the stationary models by adding a term in the model to stationarize time series.
    Finally, we talked about seasonality and how to account for seasonality in an
    ARIMA model. While these methods are powerful for forecasting, they do not incorporate
    potential information from other external variables. As in the previous chapter,
    we will see that external variables can help improve forecasts. In the next chapter,
    we will look at multivariate methods for time series data to take advantage of
    other explanatory variables.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了从平稳时间序列模型（如ARMA）到非平稳模型（如ARIMA）的各种建模方法来建模一元时间序列数据。我们从平稳模型开始，讨论了如何根据时间序列的特征来识别建模方法。然后，我们在平稳模型的基础上通过在模型中添加一个项来使时间序列平稳化。最后，我们讨论了季节性和如何在ARIMA模型中考虑季节性。虽然这些方法在预测方面非常强大，但它们并没有结合来自其他外部变量的潜在信息。正如前一章所述，外部变量可以帮助提高预测。在下一章中，我们将探讨时间序列数据的多元方法，以利用其他解释变量。
- en: References
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: Please refer to the final word file for how the references should look.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考最终文档，了解参考文献的格式。
- en: '*APPLIED TIME SERIES ANALYSIS WITH R*, W. Woodward, H. Gray, A. Elliott. Taylor
    & Francis Group, LLC. 2017.'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*使用R进行应用时间序列分析*，W. Woodward, H. Gray, A. Elliott. Taylor & Francis Group, LLC.
    2017.'
- en: Box, G. E. P., Jenkins, G. M. and Reinsel, G. C. (1976) *Time Series Analysis,
    Forecasting and Control*. Third Edition. Holden-Day. Series G.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Box, G. E. P., Jenkins, G. M. 和 Reinsel, G. C. (1976) *时间序列分析、预测与控制*。第三版。Holden-Day.
    系列 G.
- en: Brownlee, J, (2017) *Simple Time Series Forecasting Models to Test So That You
    Don’t Fool* *Yourself* ([https://machinelearningmastery.com/simple-time-series-forecasting-models/](https://machinelearningmastery.com/simple-time-series-forecasting-models/)).
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Brownlee, J, (2017) *简单时间序列预测模型以测试您不要欺骗自己* ([https://machinelearningmastery.com/simple-time-series-forecasting-models/](https://machinelearningmastery.com/simple-time-series-forecasting-models/)).
