<html><head></head><body>
<div id="_idContainer012" class="Content">
<p class="hidden" data-amznremoved-m8="true" data-amznremoved="mobi7">1</p>
</div>
<div id="_idContainer013" class="Content">
<h1 id="_idParaDest-13"><a id="_idTextAnchor014"></a>
 Principles of Artificial Intelligence</h1>
</div>
<div id="_idContainer014" class="Content">
<h2>Learning Objectives</h2>
<p>By the end of this chapter, you will be able to:</p>
<ul>
<li class="bullets">Describe the various fields of AI</li>
<li class="bullets">Explain the main learning models used in AI</li>
<li class="bullets">Explain why Python is a popular language for AI projects</li>
<li class="bullets">Model the state space in AI for a given game</li>
</ul>
<p>In this chapter, you will learn about the purpose, fields, and applications of AI, coupled with a short summary of the features we'll use in Python.</p>
</div>
<div id="_idContainer020" class="Content">
<h2 id="_idParaDest-14"><a id="_idTextAnchor015"></a>
 Introduction</h2>
<p>Before discussing different AI techniques and algorithms, we will look at the fundamentals of artificial intelligence and machine learning and go over a few basic definitions. Then, using engaging examples, we will move forward in the book. Real-world examples will be used to present the basic concepts of artificial intelligence in an easy-to-digest way.</p>
<p>If you want to be an expert at something, you need to be very good at the fundamentals. So, let's begin by understanding what artificial intelligence is:</p>
<p>
<strong class="bold _idGenCharOverride-1">Definition</strong>
 : Artificial Intelligence (AI) is a science that's used to construct intelligence using hardware and software solutions.</p>
<p>It is inspired by reverse engineering, for example, in the way that neurons work in the human brain. Our brain consists of small units called neurons, and networks of neurons called neural networks. Beyond neural networks, there are many other models in neuroscience that can be used to solve real-world problems in artificial intelligence.</p>
<p>Machine learning is a term that is often confused with artificial intelligence. It originates from the 1950s, and it was first defined by Arthur Lee Samuel in 1959.</p>
<p>
<strong class="bold _idGenCharOverride-1">Definition</strong>
 : Machine learning is a field of study concerned with giving computers the ability to learn without being explicitly programmed.</p>
<p>Tom Mitchell proposed a more mathematically precise definition of machine learning.</p>
<p>
<strong class="bold _idGenCharOverride-1">Definition</strong>
 : A computer program is said to learn from experience, E, with respect to a task, T, and a performance measure, P, if its performance on T, as measured by P, improves with experience E.</p>
<p>From these two definitions, we can conclude that machine learning is one way to achieve artificial intelligence. However, you can have artificial intelligence without machine learning. For instance, if you hardcode rules and decision trees, or you apply search techniques, you create an artificial intelligence agent, even though your approach has little to do with machine learning.</p>
<h3 id="_idParaDest-15"><a id="_idTextAnchor016"></a>
 How does AI Solve Real World Problems?</h3>
<p>
<strong class="bold _idGenCharOverride-1">Artificial intelligence automates human intelligence based on the way human brain processes information.</strong>
</p>
<p class="_idGenParaOverride-1">Whenever we solve a problem or interact with people, we go through a process. Whenever we limit the scope of a problem or interaction, this process can often be modeled and automated.</p>
<div></div>
<p>
<strong class="bold _idGenCharOverride-1">AI makes computers appear to think like humans.</strong>
</p>
<p>Sometimes, it feels like AI knows what we need. Just think about the personalized coupons you receive after shopping online. By the end of this book, you will understand that to choose the most successful products, you need to be shown how to maximize your purchases â€“ this is a relatively simple task. However, it is also so efficient, that we often think that computers "know" what we need.</p>
<p>
<strong class="bold _idGenCharOverride-1">AI is performed by computers that are executing low-level instructions.</strong>
</p>
<p>Even though a solution may appear to be intelligent, we write code, just like with any other software solutions. Even if we are simulating neurons, simple machine code and computer hardware executes the "thinking" process.</p>
<p>Most AI applications have one primary objective. When we interact with an AI application, it seems human-like because it can restrict a problem domain to a primary objective. Therefore, we get a chance to break down complex processes and simulate intelligence with the help of low-level computer instructions.</p>
<p>
<strong class="bold _idGenCharOverride-1">AI may stimulate human senses and thinking processes for specialized fields.</strong>
</p>
<p>We must simulate human senses and thoughts, and sometimes trick AI into believing that we are interacting with another human. In special cases, we can even enhance our own senses.</p>
<p>Similarly, when we interact with a chatbot, we expect the bot to understand us. We expect the chatbot or even a voice recognition system to provide a computer-human interface that fulfills our expectations. In order to meet these expectations, computers need to emulate the human thought processes.</p>
<h3 id="_idParaDest-16"><a id="_idTextAnchor017"></a>
 Diversity of Disciplines</h3>
<p>A self-driving car that couldn't sense that other cars were driving on the same highway would be incredibly dangerous. The AI agent needs to process and sense what is around it in order to drive the car. But that is itself is not enough. Without understanding the physics of moving objects, driving the car in a normal environment would be an almost impossible, not to mention deadly, task.</p>
<p>In order to create a usable AI solution, different disciplines are involved. For example:</p>
<ul>
<li>
<strong class="keyword _idGenCharOverride-1">Robotics:</strong>
 To move objects in space</li>
<li>
<strong class="keyword _idGenCharOverride-1">Algorithm Theory:</strong>
 To construct efficient algorithms</li>
<li class="_idGenParaOverride-1">
<strong class="keyword _idGenCharOverride-1">Statistics:</strong>
 To derive useful results, predict the future, and analyze the past</li>
<li style="list-style: none; display: inline"><div></div>
</li>
<li>
<strong class="keyword _idGenCharOverride-1">Psychology:</strong>
 To model how the human brain works</li>
<li>
<strong class="keyword _idGenCharOverride-1">Software Engineering:</strong>
 To create maintainable solutions that endure the test of time</li>
<li>
<strong class="keyword _idGenCharOverride-1">Computer Science or Computer Programming:</strong>
 To implement our software solutions in practice</li>
<li>
<strong class="keyword _idGenCharOverride-1">Mathematics</strong>
 : To perform complex mathematical operations</li>
<li>
<strong class="keyword _idGenCharOverride-1">Control Theory</strong>
 : To create feed-forward and feedback systems</li>
<li>
<strong class="keyword _idGenCharOverride-1">Information Theory:</strong>
 To represent, encode, decode, and compress information</li>
<li>
<strong class="keyword _idGenCharOverride-1">Graph Theory:</strong>
 To model and optimize different points in space and to represent hierarchies</li>
<li>
<strong class="keyword _idGenCharOverride-1">Physics:</strong>
 To model the real world</li>
<li>
<strong class="keyword _idGenCharOverride-1">Computer Graphics and Image Processing</strong>
 to display and process images and movies</li>
</ul>
<p>In this book, we will cover a few of these disciplines. Remember, focus is power, and we are now focusing on a high-level understanding of artificial intelligence.</p>
<h2 id="_idParaDest-17"><a id="_idTextAnchor018"></a>
 Fields and Applications of Artificial Intelligence</h2>
<p>Now that we know what Artificial Intelligence is, let's move on and investigate different fields in which AI is applied.</p>
<p>
<strong class="bold _idGenCharOverride-1">Simulation of Human Behavior</strong>
</p>
<p>Humans have five basic senses simply divided into visual, auditory, kinesthetic, olfactory, and gustatory. However, for the purposes of understanding how to create intelligent machines, we can separate disciplines as follows:</p>
<ul>
<li>Listening and speaking</li>
<li>Understanding language</li>
<li>Remembering things</li>
<li>Thinking</li>
<li>Seeing</li>
<li class="_idGenParaOverride-1">Moving</li>
<li style="list-style: none; display: inline"><div></div>
</li>
</ul>
<p>A few of these are out of scope for us, because the purpose of this book is to understand the fundamentals. In order to move a robot arm, for instance, we would have to study complex university-level math to understand what's going on.</p>
<p>
<strong class="bold _idGenCharOverride-1">Listening and Speaking</strong>
</p>
<p>Using speech recognition system, AI can collect the information. Using speech synthesis, it can turn internal data into understandable sounds. Speech recognition and <a id="_idTextAnchor019"></a>
 <strong class="bold _idGenCharOverride-1">speech synthesis</strong>
 techniques deal with the recognition and construction of sounds humans emit or that humans can understand.</p>
<p>Imagine you are on a trip to a country where you don't speak the local language. You can speak into the microphone of your phone, expect it to "understand" what you say, and then translate it into the other language. The same can happen in reverse with the locals speaking and AI translating the sounds into a language you understand. Speech recognition and speech synthesis make this possible.</p>
<h4>Note</h4>
<p class="callout">An example of speech synthesis is Google Translate. You can navigate to <a href="https://translate.google.com/">https://translate.google.com/</a>
 and make the translator speak words in a non-English language by clicking the loudspeaker button below the translated word.</p>
<p>
<strong class="bold _idGenCharOverride-1">Understanding Language</strong>
</p>
<p>We can understand natural language by processing it. This field is called <strong class="bold _idGenCharOverride-1">natural language processing,</strong>
 or NLP for short.</p>
<p>When it comes to natural language processing, we tend to learn languages based on <strong class="bold _idGenCharOverride-1">statistical learning.</strong>
</p>
<p>
<strong class="bold _idGenCharOverride-1">Remembering Things</strong>
</p>
<p class="_idGenParaOverride-1">We need to represent things we know about the world. This is where creating <strong class="bold _idGenCharOverride-1">knowledge bases</strong>
 and hierarchical representations called <strong class="bold _idGenCharOverride-1">ontologies</strong>
 comes into play. Ontologies categorize things and ideas in our world and contain relations between these categories.</p>
<div></div>
<p>
<strong class="bold _idGenCharOverride-1">Thinking</strong>
</p>
<p>Our AI system has to be an expert in a certain domain by using an expert system. An <strong class="bold _idGenCharOverride-1">expert system</strong>
 can be based on mathematical logic in a deterministic way, as well as in a fuzzy, non-deterministic way.</p>
<p>The knowledge base of an expert system is represented using different techniques. As the problem domain grows, we create hierarchical ontologies.</p>
<p>We can replicate this structure by modeling the network on the building blocks of the brain. These building blocks are called neurons, and the network itself is called a <strong class="bold _idGenCharOverride-1">neural network</strong>
 .</p>
<p>There is another key term you need to connect to neural networks: <strong class="bold _idGenCharOverride-1">deep learning</strong>
 . Deep learning is deep because it goes beyond pattern recognition and categorization. Learning is imprinted into the neural structure of the network. One special deep learning task, for instance, is <strong class="bold _idGenCharOverride-1">object recognition</strong>
 using <strong class="bold _idGenCharOverride-1">computer vision</strong>
 .</p>
<p>
<strong class="bold _idGenCharOverride-1">Seeing</strong>
</p>
<p>We have to interact with the real world through our senses. We have only touched upon auditory senses so far, in regard to speech recognition and synthesis. What if we had to see things? Then, we would have to create <strong class="bold _idGenCharOverride-1">computer vision</strong>
 techniques to learn about our environment. After all, recognizing faces is useful, and most humans are experts at that.</p>
<p>Computer vision depends on <strong class="bold _idGenCharOverride-1">image processing</strong>
 . Although image processing is not directly an AI discipline, it is a required discipline for AI.</p>
<p>
<strong class="bold _idGenCharOverride-1">Moving</strong>
</p>
<p>Moving and touching are natural to us humans, but they are very complex tasks for computers. Moving is handled by <strong class="bold _idGenCharOverride-1">robotics</strong>
 . This is a very math-heavy topic.</p>
<p class="_idGenParaOverride-1">Robotics is based on <strong class="bold _idGenCharOverride-1">control theory</strong>
 , where you create a feedback loop and control the movement of your object based on the feedback gathered. Interestingly enough, control theory has applications in other fields that have absolutely nothing to do with moving objects in space. This is because the feedback loops required are similar to those modeled in economics.</p>
<div></div>
<h3 id="_idParaDest-18"><a id="_idTextAnchor020"></a>
 Simulating Intelligence â€“ The Turing Test</h3>
<p>Alan Turing, the inventor of the Turing machine, an abstract concept that's used in algorithm theory, suggested a way to test intelligence. This test is referred to as the <strong class="bold _idGenCharOverride-1">Turing test</strong>
 in AI literature.</p>
<p>Using a text interface, an interrogator chats to a human and a chatbot. The job of the chatbot is to mislead the interrogator to the extent that they cannot tell whether the computer is human or not.</p>
<p>What disciplines do we need to pass the Turing test?</p>
<p>First of all, we need to understand a spoken language to know what the interrogator is saying. We do this by using <strong class="keyword _idGenCharOverride-1">Natural Language Processing</strong>
 <strong class="bold _idGenCharOverride-1">(</strong>
 <strong class="keyword _idGenCharOverride-1">NLP</strong>
 <strong class="bold _idGenCharOverride-1">)</strong>
 . We also have to respond.</p>
<p>We need to be an expert on things that the human mind tends to be interested in. We need to build an <strong class="bold _idGenCharOverride-1">Expert System</strong>
 of humanity, involving the taxonomy of objects and abstract thoughts in our world, as well as historical events and even emotions.</p>
<p>Passing the Turing test is very hard. Current predictions suggest we won't be able to create a system good enough to pass the Turing test until the late 2020's. Pushing this even further, if this is not enough, we can advance to the Total Turing Test, which also includes movement and vision.</p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor021"></a>
 AI Tools and Learning Models</h2>
<p>In the previous sections, we discovered the fundamentals of artificial intelligence. One of the core tasks for artificial intelligence is learning.</p>
<p>
<strong class="keyword _idGenCharOverride-1">Intelligent Agents</strong>
</p>
<p>When solving AI problems, we create an actor in the environment that can gather data from its surroundings and influence its surroundings. This actor is called an intelligent agent.</p>
<p>An intelligent agent:</p>
<ul>
<li>Is autonomous</li>
<li>Observes its surroundings through sensors</li>
<li>Acts in its environment using actuators</li>
<li class="_idGenParaOverride-1">Directs its activities toward achieving goals</li>
<li style="list-style: none; display: inline"><div></div>
</li>
</ul>
<p>Agents may also learn and have access to a knowledge base.</p>
<p>We can think of an agent as a function that maps perceptions to actions. If the agent has an internal knowledge base, perceptions, actions, and reactions may alter the knowledge base as well.</p>
<p>Actions may be rewarded or punished. Setting up a correct goal and implementing a carrot and stick situation helps the agent learn. If goals are set up correctly, agents have a chance of beating the often more complex human brain. This is because the number one goal of the human brain is survival, regardless of the game we are playing. An agent's number one motive is reaching the goal itself. Therefore, intelligent agents do not get embarrassed when making a random move without any knowledge.</p>
<h3 id="_idParaDest-20"><a id="_idTextAnchor022"></a>
 Classification and Prediction</h3>
<p>Different goals require different processes. Let's explore the two most popular types of AI reasoning: <strong class="bold _idGenCharOverride-1">classification</strong>
 and <strong class="bold _idGenCharOverride-1">prediction</strong>
 .</p>
<p>
<strong class="keyword _idGenCharOverride-1">Classification</strong>
 is a process for figuring out how an object can be defined in terms of another object. For instance, a father is a male who has one or more children. If Jane is a parent of a child and Jane is female, then Jane is a mother. Also, Jane is a human, a mammal, and a living organism. We know that Jane has a nationality as well as a date of birth.</p>
<p>
<strong class="keyword _idGenCharOverride-1">Prediction</strong>
 is the process of predicting things, based on patterns and probabilities. For instance, if a customer in a standard supermarket buys organic milk, the same customer is more likely to buy organic yoghurt than the average customer.</p>
<h3 id="_idParaDest-21"><a id="_idTextAnchor023"></a>
 Learning Models</h3>
<p class="_idGenParaOverride-1">The process of AI learning can be done in a supervised or unsupervised way. Supervised learning is based on labeled data and inferring functions from training data. Linear regression is one example. Unsupervised learning is based on unlabeled data and often works on cluster analysis.</p>
<div></div>
<h2 id="_idParaDest-22"><a id="_idTextAnchor024"></a>
 The Role of Python in Artificial Intelligence</h2>
<p><a id="_idTextAnchor025"></a>
 In order to put the basic AI concepts into practice, we need a programming language that supports artificial intelligence. In this book, we have chosen Python. There are a few reasons why Python is such a good choice for AI:</p>
<ul>
<li>Python is a <strong class="bold _idGenCharOverride-1">high-level programming language</strong>
 . This means that you don't have to worry about memory allocation, pointers, or machine code in general. You can write code in a convenient fashion and rely on Python's robustness. Python is also <strong class="bold _idGenCharOverride-1">cross-platform compatible</strong>
 .</li>
<li>The strong emphasis on <strong class="bold _idGenCharOverride-1">developer experience</strong>
 makes Python a very popular choice among software developers. In fact, according to a 2018 developer survey by <a href="https://www.hackerrank.com">https://www.hackerrank.com</a>
 , across all ages, Python ranks as the number one preferred language of software developers. This is because Python is easily readable and simple. Therefore, Python is great for <strong class="bold _idGenCharOverride-1">rapid application development</strong>
 .</li>
<li>Despite being an interpreted language, Python is comparable to other languages used in data science such as R. Its main advantage is <strong class="bold _idGenCharOverride-1">memory efficiency</strong>
 , as Python can handle large, in-memory databases.<h4 class="_idGenParaOverride-2">Note</h4>
<p class="callout _idGenParaOverride-2">Python is a multi-purpose language. It can be used to create desktop applications, database applications, mobile applications, as well as games. The network programming features of Python are also worth mentioning. Furthermore, Python is an excellent prototyping tool.</p>
</li>
</ul>
<h3 id="_idParaDest-23"><a id="_idTextAnchor026"></a>
 Why is Python Dominant in Machine Learning, Data Science, and AI?</h3>
<p>To understand the dominant nature of Python in machine learning, data science, and AI, we have to compare Python to other languages also used in these fields.</p>
<p>One of the main alternatives is R. The advantage of Python compared to R is that Python is more general purpose and more practical.</p>
<p class="_idGenParaOverride-1">Compared to Java and C++, writing programs in Python is significantly faster. Python also provides a high degree of flexibility.</p>
<div></div>
<p>There are some languages that are similar in nature when it comes to flexibility and convenience: Ruby and JavaScript. Python has an advantage over these languages because of the AI ecosystem available for Python. In any field, open source, third-party library support vastly determines the success of that language. Python's third-party AI library support is excellent.</p>
<h3 id="_idParaDest-24"><a id="_idTextAnchor027"></a>
 Anaconda in Python</h3>
<p>We already installed Anaconda in the preface. Anaconda will be our number one tool when it comes to experimenting with artificial intelligence.</p>
<p>This list is by far incomplete, as there are more than 700 libraries available in Anaconda. However, if you know these libraries, then you're off to a good start because you will be able to implement fundamental AI algorithms in Python.</p>
<p>Anaconda comes with packages, IDEs, data visualization libraries, and high-performance tools for parallel computing in one place. Anaconda hides configuration problems and the complexity of maintaining a stack for data science, machine learning, and artificial intelligence. This feature is especially useful in Windows, where version mismatches and configuration problems tend to arise the most.</p>
<p>Anaconda comes with the IPython console, where you can write code and comments in documentation style. When you experiment with AI features, the flow of your ideas resembles an interactive tutorial where you run each step of your code.</p>
<h4>Note</h4>
<p class="callout _idGenParaOverride-1">IDE stands for Integrated Development Environment. While a text editor provides some functionalities to highlight and format code, an IDE goes beyond the features of text editors by providing tools to automatically refactor, test, debug, package, run, and deploy code.</p>
<div></div>
<h3 id="_idParaDest-25"><a id="_idTextAnchor028"></a>
 Python Libraries for Artificial Intelligence</h3>
<p>The list of libraries presented here is not complete as there are more than 700 available in Anaconda. However, these specific ones will get you off to a good start, because they will give you a good foundation to be able to implement fundamental AI algorithms in Python:</p>
<ul>
<li>
<strong class="keyword _idGenCharOverride-1">NumPy</strong>
 : NumPy is a computing library for Python. As Python does not come with a built-in array data structure, we have to use a library to model vectors and matrices efficiently. In data science, we need these data structures to perform simple mathematical operations. We will extensively use NumPy in future modules.</li>
<li>
<strong class="keyword _idGenCharOverride-1">SciPy</strong>
 : SciPy is an advanced library containing algorithms that are used for data science. It is a great complementary library to NumPy, because it gives you all the advanced algorithms you need, whether <a id="_idTextAnchor029"></a>
 it be a linear algebra algorithm, image processing tool, or a matrix operation.</li>
<li>
<strong class="keyword _idGenCharOverride-1">pandas</strong>
 : pandas provides fast, flexible, and expressive data structures such as one-dimensional series and two-dimensional DataFrames. It efficiently loads, formats, and handles complex tables of different types.</li>
<li>
<strong class="keyword _idGenCharOverride-1">scikit-learn</strong>
 : scikit-learn is Python's main machine learning library. It is based on the NumPy and SciPy libraries. scikit-learn provides you with the functionality required to perform both classification and regression, data preprocessing, as well as supervised and unsupervised learning.</li>
<li>
<strong class="keyword _idGenCharOverride-1">NLTK</strong>
 : We will not deal with natural language processing in this book but NLTK is still worth mentioning, because this library is the main natural language toolkit of Python. You can perform classification, tokenization, stemming, tagging, parsing, semantic reasoning, and many other services using this library.</li>
<li class="_idGenParaOverride-1">
<strong class="keyword _idGenCharOverride-1">TensorFlow</strong>
 : TensorFlow is Google's neural network library, and it is perfect for implementing deep learning artificial intelligence. The flexible core of TensorFlow can be used to solve a vast variety of numerical computation problems. Some real-world applications of TensorFlow include Google voice recognition and object identification.</li>
<li style="list-style: none; display: inline"><div></div>
</li>
</ul>
<h3 id="_idParaDest-26"><a id="_idTextAnchor030"></a>
 A Brief Introduction to the NumPy Library</h3>
<p>The NumPy library will play a major role in this book, so it is worth exploring it further.</p>
<p>After launching your IPython console, you can simply import NumPy as follows:</p>
<p class="snippet">import numpy as np</p>
<p>Once NumPy has been imported, you can access it using its alias, <strong class="keyword _idGenCharOverride-1">np</strong>
 . NumPy contains the efficient implementation of some data structures such as vectors and matrices. Python does not come with a built-in array structure, so NumPy's array comes in handy. Let's see how we can define vectors and matrices:</p>
<p class="snippet">np.array([1,3,5,7])</p>
<p>The output is as follows:</p>
<p class="snippet">array([1, 3, 5, 7])</p>
<p>We can declare a matrix using the following syntax:</p>
<p class="snippet">A = np.mat([[1,2],[3,3]])</p>
<p class="snippet">A</p>
<p>The output is as follows:</p>
<p class="snippet">matrix([[1, 2],</p>
<p class="snippet">        [3, 3]])</p>
<p>The array method creates an array data structure, while <strong class="inline _idGenCharOverride-2">mat</strong>
 creates a matrix.</p>
<p>We can perform many operations with matrices. These include addition, subtraction, and multiplication:</p>
<p>Addition in matrices:</p>
<p class="snippet">A + A</p>
<p>The output is as follows:</p>
<p class="snippet">matrix([[2, 4],</p>
<p class="snippet">        [6, 6]])</p>
<p>Subtraction in matrices:</p>
<p class="snippet">A - A</p>
<p>The output is as follows:</p>
<p class="snippet">matrix([[0, 0],</p>
<p class="snippet _idGenParaOverride-1">        [0, 0]])</p>
<div></div>
<p>Multiplication in matrices:</p>
<p class="snippet">A * A</p>
<p>The output is as follows:</p>
<p class="snippet">matrix([[ 7, 8],</p>
<p class="snippet">        [12, 15]])</p>
<p>Matrix addition and subtraction works cell by cell.</p>
<p>Matrix multiplication works according to linear algebra rules. To calculate matrix multiplication manually, you have to align the two matrices, as follows:</p>
<div class="_idGenObjectLayout-1">
<div id="_idContainer015" class="IMG---Figure"><img class="_idGenObjectAttribute-1" src="Image00001.jpg" alt="Figure 1.1: Multiplication calculation with two matrices" />
</div>
</div>
<h6>Figure 1.1: Multiplication calculation with two matrices</h6>
<p>To get the <em class="italics _idGenCharOverride-3">(i,j)th</em>
 element of the matrix, you compute the dot (scalar) product on the <em class="italics _idGenCharOverride-3">ith</em>
 row of the matrix with the <em class="italics _idGenCharOverride-3">jth</em>
 column. The scalar product of two vectors is the sum of the product of their corresponding coordinates.</p>
<p>Another frequent matrix operation is the determinant of the matrix. The determinant is a number associated with square matrices. Calculating the determinant using NumPy is easy:</p>
<p class="snippet">np.linalg.det( A )</p>
<p>The output is <strong class="inline _idGenCharOverride-2">-3.0000000000000004</strong>
 .</p>
<p class="_idGenParaOverride-1">Technically, the determinant can be calculated as <strong class="inline _idGenCharOverride-2">1*3 â€“ 2*3 = -3</strong>
 . Notice that NumPy calculates the determinant using floating-point arithmetic, and therefore, the accuracy of the result is not perfect. The error is due to the way floating-points are represented in most programming languages.</p>
<div></div>
<p>We can also transpose a matrix, like so:</p>
<p class="snippet">np.matrix.transpose(A)</p>
<p>The output is as follows:</p>
<p class="snippet">matrix([[1, 3],</p>
<p class="snippet">        [2, 3]])</p>
<p>When calculating the transpose of a matrix, we flip its values over its main diagonal.</p>
<p>NumPy has many other important features, and therefore, we will use it in most of the chapters in this book.</p>
<h3 id="_idParaDest-27"><a id="_idTextAnchor031"></a>
 Exercise 1: Matrix Operations Using NumPy</h3>
<p>We will be using IPython and the following matrix to solve this exercise. We will start by understanding the NumPy syntax:</p>
<div class="_idGenObjectLayout-1">
<div id="_idContainer016" class="IMG---Figure"><img class="_idGenObjectAttribute-1" src="Image00002.jpg" alt="Figure 1.2: Simple Matrix" />
</div>
</div>
<h6>Figure 1.2: Simple Matrix</h6>
<p>Using NumPy, calculate the following:</p>
<ul>
<li>The square of the matrix</li>
<li>The determinant of the matrix</li>
<li>The transpose of the matrix</li>
</ul>
<p>Let's begin with NumPy matrix operations:</p>
<ol>
<li value="1">Import the NumPy library.<p class="snippet _idGenParaOverride-3">import numpy as np</p>
</li>
<li value="2">Create a two-dimensional array storing the matrix:<p class="snippet _idGenParaOverride-3">A = np.mat([[1,2,3],[4,5,6],[7,8,9]])</p>
<p class="_idGenParaOverride-4">Notice the <strong class="inline _idGenCharOverride-2">np.mat</strong>
 construct. If you have created an <strong class="inline _idGenCharOverride-2">np.array</strong>
 instead of <strong class="inline _idGenCharOverride-2">np.mat</strong>
 , the solution for the array multiplication will be incorrect.</p>
<div></div>
</li>
<li value="3">NumPy supports matrix multiplication by using the asterisk:<p class="snippet _idGenParaOverride-3">A * A</p>
<p class="_idGenParaOverride-5">The output is as follows:</p>
<p class="snippet _idGenParaOverride-3">matrix([[ 30, 36, 42],</p>
<p class="snippet _idGenParaOverride-3">         [ 66, 81, 96],</p>
<p class="snippet _idGenParaOverride-3">         [102, 126, 150]])</p>
<p class="_idGenParaOverride-5">As you can see from the following code, the square of A has been calculated by performing matrix multiplication. For instance, the top-left element of the matrix is calculated as follows:</p>
<p class="snippet _idGenParaOverride-3">1 * 1 + 2 * 4 + 3 * 7</p>
<p class="_idGenParaOverride-5">The output is <strong class="inline _idGenCharOverride-2">30</strong>
 .</p>
</li>
<li value="4">Use <strong class="inline _idGenCharOverride-2">np.linalg.det</strong>
 to calculate the determinant of the matrix:<p class="snippet _idGenParaOverride-3">np.linalg.det( A )</p>
<p class="_idGenParaOverride-5">The output <strong class="inline _idGenCharOverride-2">is -9.51619735392994e-16</strong>
 .</p>
<p class="_idGenParaOverride-5">The determinant is almost zero according to the preceding calculations. This inefficiency is due to floating-point arithmetic. The actual determinant is zero.</p>
<p class="_idGenParaOverride-5">You can conclude this by calculating the determinant manually:</p>
<p class="snippet _idGenParaOverride-3">1*5*9 + 2*6*7 + 3*4*8 - 1*6*8 - 2*4*9 - 3*5*7</p>
<p class="_idGenParaOverride-5">The output is <strong class="inline _idGenCharOverride-2">0</strong>
 .</p>
<p class="_idGenParaOverride-5">Whenever you work with NumPy, make sure that you factor in the possibility of floating-point arithmetic rounding errors, even if you appear to be working with integers.</p>
</li>
<li value="5">Use <strong class="inline _idGenCharOverride-2">np.matrix.transpose</strong>
 to get the transpose of the matrix:<p class="snippet _idGenParaOverride-3">np.matrix.transpose(A)</p>
<p class="_idGenParaOverride-5">The output is as follows:</p>
<p class="snippet _idGenParaOverride-3">matrix([[1, 4, 7],</p>
<p class="snippet _idGenParaOverride-3">         [2, 5, 8],</p>
<p class="snippet _idGenParaOverride-3">         [3, 6, 9]])</p>
<p class="_idGenParaOverride-5">If <strong class="inline _idGenCharOverride-2">T</strong>
 is the transpose of matrix A, then <strong class="inline _idGenCharOverride-2">T[j][i]</strong>
 is equal to <strong class="inline _idGenCharOverride-2">A[i][j]</strong>
 .</p>
<p class="_idGenParaOverride-4">NumPy comes with many useful features for vectors, matrices, and other mathematical structures.</p>
<div></div>
</li>
</ol>
<h2 id="_idParaDest-28"><a id="_idTextAnchor032"></a>
 Python for Game AI</h2>
<p>An <strong class="bold _idGenCharOverride-1">AI game player</strong>
 is nothing but an <strong class="bold _idGenCharOverride-1">intelligent agent</strong>
 with a clear goal: to win the game and defeat all other players. Artificial Intelligence experiments have achieved surprising results when it comes to games. Today, no human can defeat an AI in the game of chess.</p>
<p>The game Go was the last game where human grandmasters could consistently defeat a computer player. However, in 2017, Google's game-playing AI defeated the Go grandmaster.</p>
<h3 id="_idParaDest-29"><a id="_idTextAnchor033"></a>
 Intelligent Agents in Games</h3>
<p>An intelligent agent plays according to the rules of the game. The agent can sense the <strong class="bold _idGenCharOverride-1">current state</strong>
 of the game through its <strong class="bold _idGenCharOverride-1">sensors</strong>
 and can evaluate the <strong class="bold _idGenCharOverride-1">utility</strong>
 of potential steps. Once the agent finds the <strong class="bold _idGenCharOverride-1">best possible step</strong>
 , it performs the action using its actuators. The agent finds the best possible action to <strong class="bold _idGenCharOverride-1">reach the goal</strong>
 based on the information it has. Actions are either <strong class="bold _idGenCharOverride-1">rewarded</strong>
 or <strong class="bold _idGenCharOverride-1">punished</strong>
 . The carrot and stick are excellent examples of rewards and punishment. Imagine a donkey in front of your cart. You put a carrot in front of the eyes of the donkey, so the poor animal starts walking toward it. As soon as the donkey stops, the rider may apply punishment with a stick. This is not a human way of moving, but rewards and punishment control living organisms to some extent. The same happens to humans at school, at work, and in everyday life as well. Instead of carrots and sticks, we have income and legal punishment to shape our behavior.</p>
<p>In most games and gamified applications, a good sequence of actions results in a reward. When a human player feels rewarded, a hormone called dopamine is released. Dopamine is also referred to as the chemical of reward. When a human achieves a goal or completes a task, dopamine is released. This hormone makes you feel happy. Humans tend to act in a way that maximizes their happiness. This sequence of actions is called a <strong class="bold _idGenCharOverride-1">compulsion loop</strong>
 . Intelligent agents, on the other hand, are only interested in their goal, which is to maximize their reward and minimize their punishment.</p>
<p>When modeling games, we must determine their <strong class="bold _idGenCharOverride-1">state space</strong>
 . An action causes a <strong class="bold _idGenCharOverride-1">state transition</strong>
 . When we explore the consequences of all possible actions, we get a <strong class="bold _idGenCharOverride-1">decision tree</strong>
 . This tree goes deeper as we start exploring the possible future actions of all players until the game ends.</p>
<p>The strength of AI is the execution of millions of possible steps each second. Therefore, game AI often boils down to a <strong class="bold _idGenCharOverride-1">search exercise</strong>
 . When exploring all of the possible sequences of moves in a game, we get the <strong class="bold _idGenCharOverride-1">state tree</strong>
 of a game.</p>
<p class="_idGenParaOverride-1">Consider a chess AI. What is the problem with evaluating all possible moves by building a state tree consisting of all of the possible sequences of moves?</p>
<div></div>
<p>Chess is an EXPTIME game complexity-wise. The number of possible moves explodes combinatorially.</p>
<p>White starts with 20 possible moves: the 8 pawns may move either one or two steps, and the two knights may move either up-up-left, or up-up-right. Then, black can make any of these twenty moves. There are already 20*20 = 400 possible combinations after just one move per player.</p>
<p>After the second move, we get 8,902 possible board constellations, and this number just keeps on growing. Just take seven moves, and you have to search through 10,921,506 possible constellations.</p>
<p>The average length of a chess game is approximately 40 moves. Some exceptional games take more than 200 moves to finish.</p>
<p>As a consequence, the computer player simply does not have time to explore the whole state space. Therefore, the search activity has to be guided with proper rewards, punishment, and simplifications of the rules.</p>
<h3 id="_idParaDest-30"><a id="_idTextAnchor034"></a>
 Breadth First Search and Depth First Search</h3>
<p>Creating a game AI is often a search exercise. Therefore, we need to be familiar with the two primary search techniques: Breadth First Search (BFS) and Depth First Search (DFS).</p>
<p>These search techniques are applied on a <strong class="bold _idGenCharOverride-1">directed rooted tree</strong>
 . A tree is a data structure that has nodes, and edges connecting these nodes in such a way that any two nodes of the tree are connected by exactly one path:</p>
<div class="_idGenObjectLayout-1">
<div id="_idContainer017" class="IMG---Figure"><img class="_idGenObjectAttribute-1" src="Image00003.jpg" alt="Figure 1.3: A directed rooted tree" />
</div>
</div>
<h6 class="_idGenParaOverride-1">Figure 1.3: A directed rooted tree</h6>
<div></div>
<p>When the tree is rooted, there is a special node in the tree called the root, where we begin our traversal. A directed tree is a tree where the edges may only be traversed in one direction. Nodes may be internal nodes or leaves. <strong class="bold _idGenCharOverride-1">Internal nodes</strong>
 have at least one edge through which we can leave the node. A <strong class="bold _idGenCharOverride-1">leaf</strong>
 has no edges pointing out from the node.</p>
<p>In AI search, the root of the tree is the starting state. We traverse from this state by generating successor nodes of the search tree. Search techniques differ regarding which order we visit these successor nodes in.</p>
<p>Suppose we have a tree defined by its root, and a function that generates all the successor nodes from the root. In this example, each node has a value and a depth. We start from 1 and may either increase the value by 1 or 2. Our goal is to reach the value 5.</p>
<p class="snippet">root = {'value': 1, 'depth': 1}</p>
<p class="snippet">def succ(node):</p>
<p class="snippet">    if node['value'] == 5:</p>
<p class="snippet">return []</p>
<p class="snippet">elif node['value'] == 4:</p>
<p class="snippet">return [{'value': 5,'depth': node['depth']+1}]</p>
<p class="snippet">else:</p>
<p class="snippet">return [</p>
<p class="snippet">{'value': node['value']+1, 'depth':node['depth']+1},</p>
<p class="snippet">{'value': node['value']+2, 'depth':node['depth']+1}</p>
<p class="snippet">]</p>
<p>We will first perform DFS on this example:</p>
<p class="snippet">def bfs_tree(node):</p>
<p class="snippet">nodes_to_visit = [node]</p>
<p class="snippet">visited_nodes = []</p>
<p class="snippet">while len(nodes_to_visit) &gt; 0:</p>
<p class="snippet">current_node = nodes_to_visit.pop(0)</p>
<p class="snippet">visited_bodes.append(current_node)</p>
<p class="snippet">nodes_to_visit.extend(succ(current_node))</p>
<p class="snippet">return visited_nodes</p>
<p class="snippet _idGenParaOverride-1">bfs_tree(root)</p>
<div></div>
<p>The output is as follows:</p>
<p class="snippet">[{'depth': 1, 'value': 1},</p>
<p class="snippet">{'depth': 2, 'value': 2},</p>
<p class="snippet">{'depth': 2, 'value': 3},</p>
<p class="snippet">{'depth': 3, 'value': 3},</p>
<p class="snippet">{'depth': 3, 'value': 4},</p>
<p class="snippet">{'depth': 3, 'value': 4},</p>
<p class="snippet">{'depth': 3, 'value': 5},</p>
<p class="snippet">{'depth': 4, 'value': 4},</p>
<p class="snippet">{'depth': 4, 'value': 5},</p>
<p class="snippet">{'depth': 4, 'value': 5},</p>
<p class="snippet">{'depth': 4, 'value': 5},</p>
<p class="snippet">{'depth': 5, 'value': 5}]</p>
<p>Notice that breadth first search finds the shortest path to a leaf first, because it enumerates all nodes in the order of increasing depth.</p>
<p>If we had to traverse a graph instead of a directed rooted tree, breadth first search would look different: whenever we visit a node, we would have to check whether the node had been visited before. If the node had been visited before, we would simply ignore it.</p>
<p>In this chapter, we only use <strong class="keyword _idGenCharOverride-1">Breadth First Traversal</strong>
 on trees. Depth First Search is surprisingly similar to Breadth First Search. The difference between <strong class="keyword _idGenCharOverride-1">Depth First Traversals</strong>
 and BFS is the sequence in which you access the nodes. While BFS visits all the children of a node before visiting any other nodes, DFS digs deep in the tree first:</p>
<p class="snippet">def dfs_tree(node):</p>
<p class="snippet">nodes_to_visit = [node]</p>
<p class="snippet">visited_nodes = []</p>
<p class="snippet">while len(nodes_to_visit) &gt; 0:</p>
<p class="snippet">current_node = nodes_to_visit.pop()</p>
<p class="snippet">visited_nodes.append(current_node)</p>
<p class="snippet">nodes_to_visit.extend(succ(current_node))</p>
<p class="snippet">return visited_nodes</p>
<p class="snippet _idGenParaOverride-1">dfs_tree(root)</p>
<div></div>
<p>The output is as follows:</p>
<p class="snippet">[{'depth': 1, 'value': 1},</p>
<p class="snippet">{'depth': 2, 'value': 3},</p>
<p class="snippet">{'depth': 3, 'value': 5},</p>
<p class="snippet">{'depth': 3, 'value': 4},</p>
<p class="snippet">{'depth': 4, 'value': 5},</p>
<p class="snippet">{'depth': 2, 'value': 2},</p>
<p class="snippet">{'depth': 3, 'value': 4},</p>
<p class="snippet">{'depth': 4, 'value': 5},</p>
<p class="snippet">{'depth': 3, 'value': 3},</p>
<p class="snippet">{'depth': 4, 'value': 5},</p>
<p class="snippet">{'depth': 4, 'value': 4},</p>
<p class="snippet">{'depth': 5, 'value': 5}]</p>
<p>As you can see, the DFS algorithm digs deep fast. It does not necessarily find the shortest path first, but it is guaranteed to find a leaf before exploring a second path.</p>
<p>In game AI, the BFS algorithm is often better for the evaluation of game states, because DFS may get lost. Imagine starting a chess game, where a DFS algorithm may easily get lost in searching.</p>
<h3 id="_idParaDest-31"><a id="_idTextAnchor035"></a>
 Exploring the State Space of a Game</h3>
<p>Let's explore the state space of a simple game: Tic-Tac-Toe.</p>
<p class="_idGenParaOverride-1">In Tic-Tac-Toe, a 3x3 game board is given. Two players play this game. One plays with the sign X, and the other plays with the sign O. X starts the game, and each player makes a move after the other. The goal of the game is to get three of your own signs horizontally, vertically, or diagonally.</p>
<div></div>
<p>Let's denote the cells of the Tic-Tac-Toe board as follows:</p>
<div class="_idGenObjectLayout-1">
<div id="_idContainer018" class="IMG---Figure"><img class="_idGenObjectAttribute-1" src="Image00004.jpg" alt="Figure 1.4: tic-tac-toe Board" />
</div>
</div>
<h6>Figure 1.4: Tic-Tac-Toe Board</h6>
<p>In the following example, X started at position 1. O retaliated at position 5, X made a move at position 9, and then O moved to position 3:</p>
<div class="_idGenObjectLayout-1">
<div id="_idContainer019" class="IMG---Figure"><img class="_idGenObjectAttribute-1" src="Image00005.jpg" alt="Figure 1.5: tic-tac-toe Board with noughts and crosses" />
</div>
</div>
<h6>Figure 1.5: Tic-Tac-Toe Board with noughts and crosses</h6>
<p>This was a mistake by the second player, because now X is forced to place a sign on cell 7, creating two future scenarios for winning the game. It does not matter whether O defends by moving to cell 4 or 8 â€“ X will win the game by selecting the other unoccupied cell.</p>
<h4>Note</h4>
<p class="callout">You can try out the game at <a href="http://www.half-real.net/tictactoe/">http://www.half-real.net/tictactoe/</a>
 .</p>
<p>For simplicity, we will only explore the state space belonging to the cases when the AI player starts. We will start with an AI player that plays randomly, placing a sign in an empty cell. After playing with this AI player, we will create a complete decision tree. Once we generate all possible game states, you will experience their combinatoric explosion. As our goal is to make these complexities simple, we will use several different techniques to make the AI player smarter, and to reduce the size of the decision tree. By the end of this experiment, we will have a decision tree that has less than 200 different game endings, and as a bonus, the AI player will never lose a single game.</p>
<p>To make a random move, you will have to know how to choose a random element from a list using Python. We will use the <strong class="inline _idGenCharOverride-2">choice</strong>
 function of the random library:</p>
<p class="snippet">from random import choice</p>
<p class="snippet">choice([2, 4, 6, 8])</p>
<p>The output is <strong class="inline _idGenCharOverride-2">6</strong>
 .</p>
<p>The output of the choice function is a random element of the list.</p>
<h4>Note</h4>
<p class="callout">We will use the factorial notation in the following exercise. Factorial is denoted by the "!" exclamation mark. By definition, 0! = 1, and n! = n*(n-1)!. In our example, 9! = 9* 8! = 9*8*7! = â€¦ = 9*8*7*6*5*4*3*2*1.</p>
<h3 id="_idParaDest-32"><a id="_idTextAnchor036"></a>
 Exercise 2: Estimating the Number of Possible States in Tic-Tac-Toe Game</h3>
<p>Make a rough estimate of the number of possible states on each level of the state space of the Tic-Tac-Toe game:</p>
<ul>
<li>In our estimation, we will not stop until all of the cells of the board have been filled. A player might win before the game ends, but for the sake of uniformity, we will continue the game.</li>
<li>The first player will choose one of the nine cells. The second player will choose one out of the eight remaining cells. The first player can then choose one out of the seven remaining cells. This goes on until either player wins the game, or the first player is forced to make the ninth and last move.</li>
<li class="_idGenParaOverride-1">The number of possible decision sequences are therefore 9! = 362880. A few of these sequences are invalid, because a player may win the game in less than nine moves. It takes at least five moves to win a game, because the first player needs to move three times.</li>
<li style="list-style: none; display: inline"><div></div>
</li>
<li>To calculate the exact size of the state space, we would have to calculate the number of games that are won in five, six, seven, and eight steps. This calculation is simple, but due to its exhaustive nature, it is out of scope for us. We will therefore settle for the magnitude of the state space.<h4 class="_idGenParaOverride-2">Note</h4>
<p class="callout _idGenParaOverride-2">After generating all possible Tic-Tac-Toe games, researchers counted 255,168 possible games. Out of those games, 131,184 were won by the first player, 77,904 were won by the second player, and 46,080 games ended with a draw. Visit <a href="http://www.half-real.net/tictactoe/allgamesoftictactoe.zip">http://www.half-real.net/tictactoe/allgamesoftictactoe.zip</a>
 to download all possible Tic-Tac-Toe games.</p>
</li>
</ul>
<p>Even a simple game like Tic-Tac-Toe has a lot of states. Just imagine how hard it would be to start exploring all possible chess games. Therefore, we can conclude that brute-force search is rarely ideal.</p>
<h3 id="_idParaDest-33"><a id="_idTextAnchor037"></a>
 Exercise 3: Creating an AI Randomly</h3>
<p>In this section, we'll create a framework for the Tic-Tac-Toe game for experimentation. We will be modelling the game on the assumption that the AI player always starts the game. Create a function that prints your internal representation and allow your opponent to enter a move randomly. Determine whether a player has won. To ensure that this happens correctly, you will need to have completed the previous exercises:</p>
<ol>
<li class="ParaOverride-1" value="1">We will import the choice function from the <strong class="inline _idGenCharOverride-2">random</strong>
 library:<p class="snippet _idGenParaOverride-3">from random import choice</p>
</li>
<li value="2">We will model the nine cells in a simple string for simplicity. A nine-character long Python string stores these cells in the following order: "<strong class="inline _idGenCharOverride-2">123456789</strong>
 ". Let's determine the index triples that must contain matching signs so that a player wins the game:<p class="snippet _idGenParaOverride-3">combo_indices = [</p>
<p class="snippet _idGenParaOverride-3">    [0, 1, 2],</p>
<p class="snippet _idGenParaOverride-3">    [3, 4, 5],</p>
<p class="snippet _idGenParaOverride-3">    [6, 7, 8],</p>
<p class="snippet _idGenParaOverride-3">    [0, 3, 6],</p>
<p class="snippet _idGenParaOverride-3">    [1, 4, 7],</p>
<p class="snippet _idGenParaOverride-3">    [2, 5, 8],</p>
<p class="snippet _idGenParaOverride-3">    [0, 4, 8],</p>
<p class="snippet _idGenParaOverride-3">    [2, 4, 6]</p>
<p class="snippet _idGenParaOverride-6">]</p>
<div></div>
</li>
<li value="3">Let's define the <em class="italics _idGenCharOverride-3">sign</em>
 constants for empty cells, the AI, and the opponent player:<p class="snippet _idGenParaOverride-3">EMPTY_SIGN = '.'</p>
<p class="snippet _idGenParaOverride-3">AI_SIGN = 'X'</p>
<p class="snippet _idGenParaOverride-3">OPPONENT_SIGN = 'O'</p>
</li>
<li value="4">Let's create a function that prints a board. We will add an empty row before and after the board so that we can easily read the game state:<p class="snippet _idGenParaOverride-3">def print_board(board):</p>
<p class="snippet _idGenParaOverride-3">    print(" ")</p>
<p class="snippet _idGenParaOverride-3">    print(' '.join(board[:3]))</p>
<p class="snippet _idGenParaOverride-3">    print(' '.join(board[3:6]))</p>
<p class="snippet _idGenParaOverride-3">    print(' '.join(board[6:]))</p>
<p class="snippet _idGenParaOverride-3">    print(" ")</p>
</li>
<li value="5">We will describe a move of the human player. The input arguments are the boards, the row numbers from 1 to 3, and the column numbers from 1 to 3. The return value of this function is a board containing the new move:<p class="snippet _idGenParaOverride-3">def opponent_move(board, row, column):</p>
<p class="snippet _idGenParaOverride-3">    index = 3 * (row - 1) + (column - 1)</p>
<p class="snippet _idGenParaOverride-3">    if board[index] == EMPTY_SIGN:</p>
<p class="snippet _idGenParaOverride-3">        return board[:index] + OPPONENT_SIGN + board[index+1:]</p>
<p class="snippet _idGenParaOverride-3">    return board</p>
</li>
<li value="6">It is time to define a random move of the AI player. We will generate all possible moves with the <strong class="inline _idGenCharOverride-2">all_moves_from_board</strong>
 function, and then we will select a random move from the list of possible moves:<p class="snippet _idGenParaOverride-3">def all_moves_from_board_list(board, sign):</p>
<p class="snippet _idGenParaOverride-3">    move_list = []</p>
<p class="snippet _idGenParaOverride-3">    for i, v in enumerate(board):</p>
<p class="snippet _idGenParaOverride-3">        if v == EMPTY_SIGN:</p>
<p class="snippet _idGenParaOverride-3">            move_list.append(board[:i] + sign + board[i+1:])</p>
<p class="snippet _idGenParaOverride-3">    return move_list</p>
<p class="snippet _idGenParaOverride-3">def ai_move(board):</p>
<p class="snippet _idGenParaOverride-6">    return choice(all_moves_from_board(board, AI_SIGN))</p>
<div></div>
</li>
<li value="7">After defining the moves, we have to determine whether a player has won the game:<p class="snippet _idGenParaOverride-3">def game_won_by(board):</p>
<p class="snippet _idGenParaOverride-3">    for index in combo_indices:</p>
<p class="snippet _idGenParaOverride-3">        if board[index[0]] == board[index[1]] == board[index[2]] != EMPTY_SIGN:</p>
<p class="snippet _idGenParaOverride-3">            return board[index[0]]</p>
<p class="snippet _idGenParaOverride-3">    return EMPTY_SIGN</p>
</li>
<li value="8">Last, but not least, we will create a game loop so that we can test the interaction between the computer player and the human player. Although we will carry out an exhaustive search in the following examples:<p class="snippet _idGenParaOverride-3">def game_loop():</p>
<p class="snippet _idGenParaOverride-3">    board = EMPTY_SIGN * 9</p>
<p class="snippet _idGenParaOverride-3">    empty_cell_count = 9</p>
<p class="snippet _idGenParaOverride-3">    is_game_ended = False</p>
<p class="snippet _idGenParaOverride-3">    while empty_cell_count &gt; 0 and not is_game_ended:</p>
<p class="snippet _idGenParaOverride-3">        if empty_cell_count % 2 == 1:</p>
<p class="snippet _idGenParaOverride-3">            board = ai_move(board)</p>
<p class="snippet _idGenParaOverride-3">        else:</p>
<p class="snippet _idGenParaOverride-3">            row = int(input('Enter row: '))</p>
<p class="snippet _idGenParaOverride-3">            col = int(input('Enter column: '))</p>
<p class="snippet _idGenParaOverride-3">            board = opponent_move(board,&amp;#9; row, col)</p>
<p class="snippet _idGenParaOverride-3">        print_board(board)</p>
<p class="snippet _idGenParaOverride-3">        is_game_ended = game_won_by(board) != EMPTY_SIGN</p>
<p class="snippet _idGenParaOverride-3">    empty_cell_count = sum(</p>
<p class="snippet _idGenParaOverride-3">            1 for cell in board if cell == EMPTY_SIGN</p>
<p class="snippet _idGenParaOverride-3">        )</p>
<p class="snippet _idGenParaOverride-3">    print('Game has been ended.')</p>
</li>
<li value="9">Use the <strong class="inline _idGenCharOverride-2">game_loop</strong>
 function to run the game:<p class="snippet _idGenParaOverride-3">game_loop()</p>
</li>
</ol>
<p class="_idGenParaOverride-1">As you can see, even an opponent who's playing randomly may win from time to time if their opponent makes a mistake.</p>
<div></div>
<h3 id="_idParaDest-34"><a id="_idTextAnchor038"></a>
 Activity 1: Generating All Possible Sequences of Steps in a Tic-Tac-Toe Game</h3>
<p>This activity will explore the combinatoric explosion that is possible when two players play randomly. We will be using a program, building on the previous results, that generates all possible sequences of moves between a computer player and a human player. Assume that the human player may make any possible move. In this example, given that the computer player is playing randomly, we will examine the wins, losses, and draws belonging to two randomly playing players:</p>
<ol>
<li class="ParaOverride-1" value="1">Create a function that maps the <strong class="inline _idGenCharOverride-2">all_moves_from_board</strong>
 function on each element of a list of board spaces/squares. This way, we will have all of the nodes of a decision tree.</li>
<li value="2">The decision tree starts with <strong class="inline _idGenCharOverride-2">[ EMPTY_SIGN * 9 ]</strong>
 , and expands after each move. Let's create a <strong class="inline _idGenCharOverride-2">filter_wins</strong>
 function that takes finished games out of the list of moves and appends them in an array containing the board states won by the AI player and the opponent player:</li>
<li value="3">Then, with a <strong class="inline _idGenCharOverride-2">count_possibilities</strong>
 function that prints the number of decision tree leaves that ended with a draw, were won by the first player, and were won by the second player.</li>
<li value="4">We have up to 9 steps in each state. In the 0th, 2nd, 4th, 6th, and 8th iteration, the AI player moves. In all other iterations, the opponent moves. We create all possible moves in all steps and take out finished games from the move list.</li>
<li value="5">Then, execute the number of possibilities to experience the combinatoric explosion.</li>
</ol>
<p class="_idGenParaOverride-1">As you can see, the tree of board states consists of 266,073 leaves. The <strong class="inline _idGenCharOverride-2">count_possibilities</strong>
 function essentially implements a BFS algorithm to traverse all the possible states of the game. Notice that we count these states multiple times because placing an X in the top-right corner on step 1 and placing an X in the top-left corner on step 3 leads to similar possible states as starting with the top-left corner and then placing an X in the top-right corner. If we implemented the detection of duplicate states, we would have to check fewer nodes. However, at this stage, due to the limited depth of the game, we'll omit this step.</p>
<div></div>
<p>A <strong class="bold _idGenCharOverride-1">decision tree</strong>
 is very similar to the data structure examined by <strong class="inline _idGenCharOverride-2">count_possibilities</strong>
 . In a decision tree, we explore the utility of each move by investigating all possible future steps up to a certain extent. In our example, we could calculate the utility of the first moves by observing the number of wins and losses after fixing the first few moves.</p>
<h4>Note</h4>
<p class="callout">The root of the tree is the initial state. An internal state of the tree is a state in which a game has not been ended and moves are possible. A leaf of the tree contains a state where a game has ended.</p>
<p class="callout">The solution for this activity can be found on page 258.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor039"></a>
 Summary</h2>
<p>In this chapter, we have learned what Artificial Intelligence is, as well as its multiple disciplines.</p>
<p>We have seen how AI can be used to enhance or substitute human brainpower, to listen, speak, understand language, store and retrieve information, think, see, and move. Then, we moved on to learn about intelligent agents that act in their environment, solving a problem in a seemingly intelligent way to pursue a previously determined goal. When agents learn, they can learn in a supervised or an unsupervised way. We can use intelligent agents to classify things or make predictions about the future.</p>
<p>We then introduced Python and learned about its role in the field of Artificial Intelligence. We looked at a few important Python libraries for developing intelligent agents and preparing data for agents. As a warm-up, we concluded this chapter with an example, where we used the NumPy library to perform some matrix operations in Python. We also learned how to create a search space for a Tic Tac Toe game. In the next chapter, we will learn how intelligence can be imparted with the help of search space.</p>
</div>
</body></html>