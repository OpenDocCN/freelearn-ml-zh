<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer081">
<h1 class="chapter-number" id="_idParaDest-95"><a id="_idTextAnchor096"/>7</h1>
<h1 id="_idParaDest-96"><a id="_idTextAnchor097"/>Deploying and Monitoring Machine Learning Models</h1>
<p>In previous chapters, we learned a lot about different models and techniques. Understanding the concepts and building a machine learning model is only the beginning of the journey toward realizing its true value. The successful deployment and ongoing monitoring of these models are crucial to ensuring their effectiveness and reliability in <span class="No-Break">real-world scenarios.</span></p>
<p>Ensuring that a model performs optimally, seamlessly integrates with existing systems, and adapts to evolving requirements requires a comprehensive understanding of the deployment process and the associated considerations. In the context of the Qlik platform, most of the typical pain points are handled by the platform itself and the design of the components, but there are still things we have to bear <span class="No-Break">in mind.</span></p>
<p>Once a machine learning model is deployed, it is vital to continuously monitor its performance to identify potential issues, maintain accuracy, and safeguard against unforeseen failures. Monitoring provides insights into the model’s behavior, helps detect data drift or concept drift, and facilitates the identification of performance degradation over time. By proactively monitoring and analyzing key metrics, organizations can make informed decisions regarding model maintenance, retraining, and updates as required to ensure reliable and <span class="No-Break">up-to-date predictions.</span></p>
<p>In this chapter, we will get familiar with the following <span class="No-Break">main topics:</span></p>
<ul>
<li>Building a model in an on-premises environment using Advanced <span class="No-Break">Analytics Integration</span></li>
<li>Monitoring and <span class="No-Break">debugging models</span></li>
</ul>
<p>This chapter focuses on on-premises environments. We will see how to deploy and monitor models using Qlik AutoML in our <span class="No-Break">next chapter.</span></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor098"/>Building a model in an on-premises environment using the Advanced Analytics connection</h1>
<p>In <a href="B19863_05.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, we<a id="_idIndexMarker417"/> prepared an environment for R and Python using the Advanced Analytics connection with Qlik. In this chapter, we are going to utilize this same environment. This<a id="_idIndexMarker418"/> exercise will use <span class="No-Break">R specifically.</span></p>
<p>In general, there are two ways to utilize the Advanced Analytics connection with Qlik applications. These are <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Live connection</strong>: A<a id="_idIndexMarker419"/> live connection interacts with the third-party machine learning environment from the user interface while the user interacts with the application. A live connection enables <em class="italic">what-if</em> scenarios, simulations, and similar use cases. It is best for light models that do not require extensive training. The idea behind live connections is explained in the <span class="No-Break">following diagram:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer073">
<img alt="Figure 7.1: Advanced Analytics connection" height="699" src="image/B19863_05_01.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: Advanced Analytics connection</p>
<ul>
<li><strong class="bold">Load time connection</strong>: A<a id="_idIndexMarker420"/> load time connection is a one-time prediction model run that takes place when a Qlik load script is executed. When the Advanced Analytics connection is utilized during load time, the results are saved into a table in the Qlik data model. These results can be then utilized when creating an application. A load time <a id="_idIndexMarker421"/>connection is suitable for use cases that only require one predicted value. For example, if we are predicting the future value of the sales of a product and would like to save the prediction in the data model<a id="_idIndexMarker422"/> for later analysis, a load time connection is used. It is also good <a id="_idIndexMarker423"/>for models that require extensive training. It is possible to combine a live connection with a load time connection to predict some values when data is loaded and utilize scenario <span class="No-Break">analysis interactively.</span></li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">A prepared model can be saved and reused during load time or in live mode. This way we can save some time during deployment if the parameters of a model haven’t changed and it is known to have performed well previously. To save a model in R, for example, we can use the <span class="No-Break">following commands:</span></p>
<p class="callout">Using the <strong class="source-inline">saveRDS()</strong> and <strong class="source-inline">readRDS()</strong> functions: This method allows you to save any R object, including machine learning models, to a file using the <strong class="source-inline">saveRDS()</strong> function and reload it <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">readRDS()</strong></span><span class="No-Break">.</span></p>
<p class="callout">Using the <strong class="source-inline">save()</strong> and <strong class="source-inline">load()</strong> functions: The <strong class="source-inline">save()</strong> function allows you to save multiple R objects, including models, to a file in binary format, which can be loaded using the <span class="No-Break"><strong class="source-inline">load()</strong></span><span class="No-Break"> function.</span></p>
<p class="callout">Using specific package functions: Some machine learning packages in R provide their own dedicated functions for saving and loading models. For example, if you’re using the <strong class="source-inline">caret</strong> package, you can use the <strong class="source-inline">saveModel()</strong> and <span class="No-Break"><strong class="source-inline">loadModel()</strong></span><span class="No-Break"> functions.</span></p>
<p>In the next hands-on example, we will utilize the Advanced Analytics connection during load time and create a simple K-means clustering model. To begin with, we should have our R environment running and our <strong class="source-inline">Sales Multi Table.xlsx</strong> loaded in the Qlik application with the prepared <span class="No-Break">data model.</span></p>
<p>In the following example, we would like to create clusters based on product categories, sales, and average discounts to examine how different product categories will produce sales compared to given discounts. We will also create a slicer to control the number of <span class="No-Break">clusters presented.</span></p>
<p>We will begin<a id="_idIndexMarker424"/> by creating a simple layout for our application. We will add a scatter plot <a id="_idIndexMarker425"/>object, a bar chart, a filter pane, a slicer for variables, and two KPI objects to the sheet. It should look like the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<img alt="Figure 7.2: Layout for clustering example" height="849" src="image/B19863_07_02.jpg" width="1558"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2: Layout for clustering example</p>
<p>To add a slicer for variable input, the dashboard extension bundle needs to be installed. Create a variable named <strong class="source-inline">clusters</strong> and set its default value to <strong class="source-inline">4</strong>. The settings for the variable and variable input are presented respectively in the <span class="No-Break">following screenshots:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<img alt="Figure 7.3: Variable settings" height="456" src="image/B19863_07_03.jpg" width="948"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3: Variable settings</p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<img alt="Figure 7.4: Variable input settings" height="731" src="image/B19863_07_04.jpg" width="254"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4: Variable input settings</p>
<p>Next, we<a id="_idIndexMarker426"/> configure<a id="_idIndexMarker427"/> our scatter plot and start creating our cluster model. Begin by adding <strong class="source-inline">ProductName</strong> as a dimension, <strong class="source-inline">sum(Sales)</strong> as the <em class="italic">x</em>-axis measure, and <strong class="source-inline">avg(Discount)</strong> as the <em class="italic">y</em>-axis measure. This should produce the <span class="No-Break">following graph:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<img alt="Figure 7.5: Scatter plot with dimensions and measures" height="610" src="image/B19863_07_05.jpg" width="782"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5: Scatter plot with dimensions and measures</p>
<p>We <a id="_idIndexMarker428"/>would like the bubble color to be defined using the cluster model from R. Let’s start by <a id="_idIndexMarker429"/>selecting <strong class="bold">Appearance</strong> � <strong class="bold">Colors and legend</strong>. Turn off the auto coloring and select <strong class="bold">Color </strong><span class="No-Break"><strong class="bold">by expression</strong></span><span class="No-Break">.</span></p>
<p>Enter the following formula in the <span class="No-Break"><strong class="bold">Expression</strong></span><span class="No-Break"> field:</span></p>
<pre class="source-code">
R.ScriptEval('
q$id &lt;- 1:nrow(q);
F2 &lt;- q[order(q$sales,q$discount),];
F3 &lt;- data.frame(sales=F2$sales ,discount=F2$discount);
rows &lt;- nrow(F2);
if(rows &gt;= $(clusters)){
     set.seed(5);
     clusterdata &lt;- kmeans(F3,$(clusters),nstart = 20);
    df &lt;- data.frame(rowid=F2$id,data=clusterdata$cluster);
     out &lt;- df[order(df$rowid),];
}else{
     out$data &lt;- c(rep(1,rows))
}
out$data',
Sum(Sales) as sales,
avg(Discount) as discount)</pre> <p>The <a id="_idIndexMarker430"/>preceding code starts with the <strong class="source-inline">R.ScriptEval</strong> function, which tells the Qlik engine that the <a id="_idIndexMarker431"/>expression should be executed using the Advanced Analytics connection. <strong class="source-inline">R</strong> is the connection name and <strong class="source-inline">ScriptEval</strong> is the function used in this example. In total, the following expression types are supported <a id="_idIndexMarker432"/>by the R <strong class="bold">server-side </strong><span class="No-Break"><strong class="bold">extension</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SSE</strong></span><span class="No-Break">):</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Function Name</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Function Type</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Argument Type</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Return Type</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">ScriptEval</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Scalar, Tensor</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Numeric</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Numeric</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">ScriptEvalStr</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Scalar, Tensor</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">String</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">String</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">ScriptAggr</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Aggregation</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Numeric</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Numeric</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">ScriptAggrStr</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Aggregation</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">String</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">String</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">ScriptEvalEx</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Scalar, Tensor</span></p>
</td>
<td class="No-Table-Style">
<p>Numeric <span class="No-Break">or String</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Numeric</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">ScriptEvalExStr</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Scalar, Tensor</span></p>
</td>
<td class="No-Table-Style">
<p>Numeric <span class="No-Break">or String</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">String</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">ScriptAggrEx</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Aggregation</span></p>
</td>
<td class="No-Table-Style">
<p>Numeric <span class="No-Break">or String</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Numeric</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">ScriptAggrExStr</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Aggregation</span></p>
</td>
<td class="No-Table-Style">
<p>Numeric <span class="No-Break">or String</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">String</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">ScriptEvalEx</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Scalar, Tensor</span></p>
</td>
<td class="No-Table-Style">
<p>Numeric <span class="No-Break">or String</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Numeric</span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.1: Functions supported by the R SSE</p>
<p>After <a id="_idIndexMarker433"/>the initial function call, we can write our actual R code. In the preceding example, we use the k-means function to calculate the cluster number for each of our products. The <a id="_idIndexMarker434"/>last two lines are data taken from Qlik and passed to the R environment. The Qlik engine creates a dataframe named <em class="italic">q</em> that contains the data sent. In this case, it contains our aggregated sales as <strong class="source-inline">q$sales</strong> and our discount as <strong class="source-inline">q$discount</strong>. We are using our previously created variable clusters to describe the number of clusters in our code. The following is a step-by-step breakdown of <span class="No-Break">the code:</span></p>
<ol>
<li><strong class="source-inline">q$id &lt;- 1:nrow(q)</strong>: This line creates a new column in the <strong class="source-inline">q</strong> dataframe called <strong class="source-inline">id</strong> and assigns it values from <strong class="source-inline">1</strong> to the number of rows in <strong class="source-inline">0071</strong>. This column is used to preserve the original row order during sorting <span class="No-Break">and clustering.</span></li>
<li><strong class="source-inline">F2 &lt;- q[order(q$sales, q$discount), ]</strong>: Here, the <strong class="source-inline">q</strong> dataframe is sorted in ascending order based on the <strong class="source-inline">sales</strong> column first, and then within each <strong class="source-inline">sales</strong> value, it is sorted based on the <strong class="source-inline">discount</strong> column. The sorted data is stored in the <span class="No-Break"><strong class="source-inline">F2</strong></span><span class="No-Break"> dataframe.</span></li>
<li><strong class="source-inline">F3 &lt;- data.frame(sales = F2$sales, discount = F2$discount)</strong>: This line creates a new <strong class="source-inline">F3</strong> dataframe that contains only the <strong class="source-inline">sales</strong> and <strong class="source-inline">discount</strong> columns from <strong class="source-inline">F2</strong>. It essentially extracts those two columns for <span class="No-Break">further processing.</span></li>
<li><strong class="source-inline">rows &lt;- nrow(F2)</strong>: This line calculates the number of rows in the <strong class="source-inline">F2</strong> dataframe and assigns it to the <span class="No-Break"><strong class="source-inline">rows</strong></span><span class="No-Break"> variable.</span></li>
<li><strong class="source-inline">if(rows &gt;= clusters) { ... } else { ... }</strong>: This is an if-else statement that checks whether the number of rows in <strong class="source-inline">F2</strong> is greater than or equal to the value of the <strong class="source-inline">clusters</strong> variable. If it is, clustering is performed; otherwise, a default value of <strong class="source-inline">1</strong> is assigned to <span class="No-Break">all rows.</span></li>
<li><strong class="source-inline">set.seed(5)</strong>: This line sets a seed value for reproducible results in the clustering algorithm. The seed value of <strong class="source-inline">5</strong> is used in <span class="No-Break">this case.</span></li>
<li><strong class="source-inline">clusterdata &lt;- kmeans(F3, clusters, nstart = 20)</strong>: This line applies<a id="_idIndexMarker435"/> the k-means clustering algorithm to the <strong class="source-inline">F3</strong> dataframe. The <strong class="source-inline">clusters</strong> variable <a id="_idIndexMarker436"/>determines the number of clusters to be formed, and <strong class="source-inline">nstart = 20</strong> specifies the number of times the algorithm will be restarted with different initial <span class="No-Break">cluster assignments.</span></li>
<li><strong class="source-inline">df &lt;- data.frame(rowid = F2$id, data = clusterdata$cluster)</strong>: Here, a new <strong class="source-inline">df</strong> dataframe is created with two columns, <strong class="source-inline">rowid</strong> and <strong class="source-inline">data</strong>. The <strong class="source-inline">rowid</strong> column contains the original row identifiers from <strong class="source-inline">F2</strong>, and the <strong class="source-inline">data</strong> column contains the cluster assignments obtained from the <span class="No-Break"><strong class="source-inline">clusterdata</strong></span><span class="No-Break"> object.</span></li>
<li><strong class="source-inline">out &lt;- df[order(df$rowid), ]</strong>: This line rearranges the rows of the <strong class="source-inline">df</strong> dataframe in the original row order by sorting based on the <strong class="source-inline">rowid</strong> column. The sorted dataframe is stored in the <span class="No-Break"><strong class="source-inline">out</strong></span><span class="No-Break"> variable.</span></li>
<li><strong class="source-inline">out$data</strong>: Finally, this line retrieves the <strong class="source-inline">data</strong> column from the <strong class="source-inline">out</strong> dataframe, which represents the cluster assignments or the default value of <strong class="source-inline">1</strong> for <span class="No-Break">each row.</span></li>
</ol>
<p>Qlik takes the data field from the <strong class="source-inline">out</strong> dataframe and assigns values to each product name. We can then use the cluster number as our color dimension in our <span class="No-Break">scatter plot.</span></p>
<p>To get visible results, we should disable the <strong class="bold">The expression is a color code</strong> setting and select <strong class="bold">Diverging classes</strong> as the color scheme. The result with five clusters (you can use the slicer to set the variable value to five) should look like the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<img alt="Figure 7.6: Scatterplot with clusters as color" height="583" src="image/B19863_07_06.jpg" width="928"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6: Scatterplot with clusters as color</p>
<p>As you <a id="_idIndexMarker437"/>can see, we have five different groups of items that have similar characteristics in <a id="_idIndexMarker438"/>terms of total sales and the average discount applied. The cluster number can be seen if you hover over the <span class="No-Break">single bubble.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">Using master items is always encouraged. In production environments, clusters should be created as master items. This way, changes made to the model will be inherited by <span class="No-Break">all graphs.</span></p>
<p>As a final step, we can finish our layout. Insert <strong class="bold">sum(Sales)</strong> and <strong class="bold">avg(Discount)</strong> into KPI objects and take some dimensions into filter pane. Finally, add sales by product name into bar chart. You should get a view that looks like <span class="No-Break">the following:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<img alt="Figure 7.7: Final layout" height="585" src="image/B19863_07_07.jpg" width="1370"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7: Final layout</p>
<p>We have <a id="_idIndexMarker439"/>now <a id="_idIndexMarker440"/>successfully created our first model using R and Advanced Analytics Integration. Next, we will take a closer look at debugging and monitoring. We will implement another model with a slightly more advanced use case in <a href="B19863_10.xhtml#_idTextAnchor124"><span class="No-Break"><em class="italic">Chapter 10</em></span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor099"/>Monitoring and debugging models</h1>
<p>Debugging a<a id="_idIndexMarker441"/> model during development is a crucial development step. With Advanced Analytics Integration in on-premises environments, we have several options to debug our model and figure out how it <span class="No-Break">is performing.</span></p>
<p>The first and most logical place to start<a id="_idIndexMarker442"/> debugging in an interactive scenario is to look at the chart output. If there is something wrong with the code, you will get an error message here. In the following example, we can see that a library called <strong class="source-inline">forecast</strong> is missing from <span class="No-Break">the environment:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<img alt="Figure 7.8: Error message in chart" height="337" src="image/B19863_07_08.jpg" width="779"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8: Error message in chart</p>
<p>Sometimes, you <a id="_idIndexMarker443"/>may need more comprehensive information or debug prints from the actual R code. Since R is running as a service, there is no easy way to get debug prints during execution. You can, however, use file writing. Returning to our previous <strong class="source-inline">Rserve</strong> example, adding the following code will produce a file called <strong class="source-inline">debug.txt</strong> in our <strong class="source-inline">Rserve</strong> home folder (the added code is shown <span class="No-Break">in </span><span class="No-Break"><strong class="bold">bold</strong></span><span class="No-Break">):</span></p>
<pre class="source-code">
R.ScriptEval('
q$id &lt;- 1:nrow(q);
F2 &lt;- q[order(q$sales,q$discount),];
F3 &lt;- data.frame(sales=F2$sales ,discount=F2$discount);
rows &lt;- nrow(F2);
<strong class="bold">write(c("----------------"),file="debug.txt",append=TRUE);</strong>
<strong class="bold">summary&lt;-summary(q);</strong>
<strong class="bold">head&lt;-capture.output(head(q))</strong>
<strong class="bold">write(summary,file="debug.txt",append=TRUE);</strong>
<strong class="bold">write(c("----------------"),file="debug.txt",append=TRUE);</strong>
<strong class="bold">write(head,file="debug.txt",append=TRUE);</strong>
<strong class="bold">write(c("----------------"),file="debug.txt",append=TRUE);</strong>
if(rows &gt;= $(clusters)){
     set.seed(5);
     clusterdata &lt;- kmeans(F3,$(clusters),nstart = 20);
    df &lt;- data.frame(rowid=F2$id,data=clusterdata$cluster);
     out &lt;- df[order(df$rowid),];
}else{
     out$data &lt;- c(rep(1,rows))
}
out$data',
Sum(Sales) as sales,
avg(Discount) as discount)</pre> <p>The preceding <a id="_idIndexMarker444"/>code will print a summary of the <strong class="source-inline">q</strong> dataframe and a sample of it using the <strong class="source-inline">capture.output</strong> function. The result file will look like <span class="No-Break">the following:</span></p>
<pre class="source-code">
----------------
Min.   :   348.8
1st Qu.:  6491.4
Median : 10984.5
Mean   : 23157.8
3rd Qu.: 25525.6
Max.   :408674.5
Min.   :  1.224
1st Qu.: 11.709
Median : 28.048
Mean   : 47.583
3rd Qu.: 52.524
Max.   :609.970
Min.   : 1
1st Qu.:20
Median :39
Mean   :39
3rd Qu.:58
Max.   :77
----------------
      sales discount id
1  6833.144 15.36303  1
2  7815.963 11.11661  2
3 13523.793 15.85746  3
4 24966.158 41.04122  4
5  3633.208 11.70914  5
6 15295.435 45.96056  6
----------------</pre> <p class="callout-heading">Note</p>
<p class="callout">You can define the file path in the file parameter if so desired. If a path is not defined, the file will be written to the <strong class="source-inline">Rserve</strong> home directory. An example path is <span class="No-Break"><strong class="source-inline">C:\Program Files\R\R-4.3.0\library\Rserve\libs\x64</strong></span><span class="No-Break">.</span></p>
<p>If you need to debug the operation of the bridge component, there are log files stored in the <strong class="source-inline">/logs</strong> folder under the root directory of the server-side extension. Log files are created and stored daily. If there is something wrong with the code execution, these log files are a good way to start debugging. You can also monitor the returned data and execution<a id="_idIndexMarker445"/> times using these log files. The following is some sample input written during the execution of our <span class="No-Break">clustering example:</span></p>
<pre class="source-code">
2023-05-30 21:12:10.3865 INFO EvaluateScript called from client (ipv6:[::1]:49924), hashid (38116153)
2023-05-30 21:12:10.3865 DEBUG EvaluateScript header info: AppId (bedcb600-18c3-4e6e-a1dc-55562ac21e48), UserId (UserDirectory=QMI-QS-06C0; UserId=qmi), Cardinality (77 rows)
2023-05-30 21:12:10.3865 INFO EvaluateScript call with hashid(38116153) got Param names:  sales discount
2023-05-30 21:12:10.3865 DEBUG Evaluating R script, hashid (38116153):
q$id &lt;- 1:nrow(q);
F2 &lt;- q[order(q$sales,q$discount),];
F3 &lt;- data.frame(sales=F2$sales ,discount=F2$discount);
rows &lt;- nrow(F2);
write(c("----------------"),file="debug.txt",append=TRUE);
summary&lt;-summary(q);
head&lt;-capture.output(head(q))
write(summary,file="debug.txt",append=TRUE);
write(c("----------------"),file="debug.txt",append=TRUE);
write(head,file="debug.txt",append=TRUE);
write(c("----------------"),file="debug.txt",append=TRUE);
if(rows &gt;= 4){
     set.seed(5);
     clusterdata &lt;- kmeans(F3,4,nstart = 20);
    df &lt;- data.frame(rowid=F2$id,data=clusterdata$cluster);
     out &lt;- df[order(df$rowid),];
}else{
     out$data &lt;- c(rep(1,rows))
}
out$data
2023-05-30 21:12:10.4115 INFO Rserve result: 77 rows, hashid (38116153)
2023-05-30 21:12:10.4115 DEBUG Took 23 ms, hashid (38116153)</pre> <p>The preceding<a id="_idIndexMarker446"/> log entry first gives us some information about incoming requests from the Qlik engine. It details which user is making the call and from what application. It also tells us the cardinality of the data. This information is important when <span class="No-Break">evaluating performance.</span></p>
<p>Next, we get information about the function used and the parameters passed from Qlik. It will also print the entire code into the log if <strong class="source-inline">DEBUG-level</strong> is enabled. Finally, we get information about the total execution time and the rows returned. These log entries are a good starting point when evaluating model performance. More comprehensive performance metrics can be written into the model code and evaluated using the method described previously in <span class="No-Break">this section.</span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor100"/>Summary</h1>
<p>In this chapter, we took a closer look at model creation and deployment using Advanced Analytics Integration and the server-side R extension in an on-premises environment (having done the initial environment setup in <a href="B19863_05.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">).</span></p>
<p>We started our journey in this chapter by getting familiar with the two concepts of utilizing Advanced Analytics Integration. We then took a closer look at an on-the-fly data analytics use case and created a k-means clustering example with real-time integration <span class="No-Break">with R.</span></p>
<p>We built a simple dashboard to support our analysis and took a deeper look at the Advanced Analytics Integration syntax. In the latter part of this chapter, we learned how to debug and monitor our models running in <span class="No-Break">on-premises environments.</span></p>
<p>In the next chapter, we will shift our focus toward Qlik AutoML. We will learn the implementation model used with AutoML and how to utilize this tool both in Qlik Cloud and on-premises. We will also learn how to deploy and monitor models <span class="No-Break">using AutoML.</span></p>
</div>
</div></body></html>