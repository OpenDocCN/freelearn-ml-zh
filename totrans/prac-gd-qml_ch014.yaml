- en: Chapter 6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章
- en: 'GAS: Grover Adaptive Search'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'GAS: Grover自适应搜索'
- en: '*If you do not expect the unexpected, you will not find it, for it is not*
    *to be reached by search or trail.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你不期待意外，你就不会找到它，因为它不是* *可以通过搜索或追踪来达到的*。'
- en: — Heraclitus
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ——赫拉克利特
- en: In this chapter, we are going to introduce another quantum method for solving
    combinatorial optimization problems. In this case, we are going to take Grover’s
    algorithm — one of the most famous and celebrated quantum methods out there —
    as a starting point. Grover’s algorithm is used to find elements that satisfy
    specific conditions in unsorted data structures. But, as we will soon see, it
    can be easily adapted to function minimization tasks — exactly what we need for
    our optimization problems! The resulting method is sometimes called **Grover Adaptive
    Search** or **GAS**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍另一种解决组合优化问题的量子方法。在这种情况下，我们将以Grover算法——最著名和备受赞誉的量子方法之一——为起点。Grover算法用于在未排序的数据结构中找到满足特定条件的元素。但是，正如我们很快就会看到的，它可以很容易地适应函数最小化任务——这正是我们优化问题所需要的！这种方法有时被称为**Grover自适应搜索**或**GAS**。
- en: It is important to note that GAS is essentially different from the kind of quantum
    algorithms that we have been studying so far in this part of the book. This method
    is not designed specifically for NISQ devices and would need fault-tolerant quantum
    computers to fully realize its potential. However, we have still decided to cover
    it because it is readily implemented in some quantum programming libraries — such
    as Qiskit — and it can be helpful in comparing and benchmarking other quantum
    optimization algorithms.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，GAS与我们在本书的这一部分所研究的量子算法本质上不同。这种方法不是专门为NISQ设备设计的，需要容错量子计算机才能完全实现其潜力。然而，我们仍然决定介绍它，因为它可以在某些量子编程库中轻松实现——例如Qiskit——并且它可以帮助比较和基准测试其他量子优化算法。
- en: We will start the chapter by refreshing some details about Grover’s algorithm,
    including the circuits that we need in order to implement it and the role that
    **oracles** play in it. Then, we will talk about the **Dürr-Høyer** method, which
    uses Grover’s techniques to find the minimum of certain types of functions. After
    that, we will particularize the algorithm to QUBO problems and we will study how
    to implement the kind of oracle that they require.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章从回顾Grover算法的一些细节开始，包括实现它所需的电路以及**oracles**在其中扮演的角色。然后，我们将讨论**Dürr-Høyer**方法，该方法使用Grover技术来寻找某些类型函数的最小值。之后，我们将特别针对QUBO问题细化算法，并研究如何实现它们所需的oracles。
- en: With all those tools, we will have everything that we need in order to formulate
    and solve optimization problems with GAS, so we will turn to explain how to use
    Qiskit’s implementation of the algorithm. We will study the different options
    that are available to run the method and we will test it on several different
    examples.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所有这些工具，我们将拥有解决GAS优化问题的公式化和求解所需的一切，因此我们将转向解释如何使用Qiskit算法的实现。我们将研究运行此方法的不同选项，并在几个不同的示例上对其进行测试。
- en: After reading this chapter, you will understand the theoretical foundations
    of Grover Adaptive Search, you will know how to implement efficient oracles for
    optimization problems and how to use them with GAS, and you will be able to run
    Qiskit’s implementation of the algorithm to solve your own optimization problems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，你将了解Grover自适应搜索的理论基础，你将知道如何实现优化问题的有效oracles以及如何与GAS一起使用它们，你将能够运行Qiskit算法的实现来解决你自己的优化问题。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Grover’s algorithm
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grover算法
- en: Quantum oracles for combinatorial optimization
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合优化的量子或acles
- en: Using GAS with Qiskit
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qiskit进行GAS
- en: 6.1 Grover’s algorithm
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.1 Grover算法
- en: In this section, we will cover the most important properties of Grover’s algorithm.
    We will not cover all the theoretical details behind the procedure — for that,
    we recommend the book by Nielsen and Chuang [[69](ch030.xhtml#Xnielsen11quantum)]
    and, especially, the lecture notes by John Watrous [[95](ch030.xhtml#Xwatrous2005quantum)]
    — but we need to at least get familiar with how the method operates, what oracles
    are and how they are used in the algorithm, and what kind of circuits are needed
    to implement it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍Grover算法最重要的特性。我们不会涵盖该过程背后的所有理论细节——为此，我们推荐Nielsen和Chuang的书籍[[69](ch030.xhtml#Xnielsen11quantum)]，特别是John
    Watrous的讲义[[95](ch030.xhtml#Xwatrous2005quantum)]——但我们至少需要熟悉该方法的工作方式、预言机是什么以及它们如何在算法中使用，以及实现它所需的电路类型。
- en: Let’s start with the basics. Grover’s algorithm is used for searching elements
    that satisfy certain conditions. More formally, the algorithm assumes that we
    have a collection of elements indexed by strings of ![n](img/file244.png "n")
    bits, and a Boolean function ![f](img/file778.png "f") that takes those binary
    strings and returns ”true” (or ![1](img/file13.png "1")) if the element indexed
    by the string satisfies the condition and ”false” (or ![0](img/file12.png "0"))
    otherwise. For instance, imagine that we are searching among 8 different elements
    and that the ones that satisfy the condition are indexed by the strings ![010](img/file779.png
    "010") and ![100](img/file389.png "100"). Then, ![f](img/file778.png "f") will
    be the Boolean function such that ![f(x) = 1](img/file780.png "f(x) = 1") if ![x
    = 010](img/file781.png "x = 010") or ![x = 100](img/file782.png "x = 100"), and
    ![f(x) = 0](img/file783.png "f(x) = 0") otherwise. To simplify the notation, from
    now on we will identify an element with the string ![x](img/file269.png "x") that
    is used to index it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础知识开始。Grover算法用于搜索满足特定条件的元素。更正式地说，该算法假设我们有一个由![n](img/file244.png "n")位字符串索引的元素集合，以及一个布尔函数![f](img/file778.png
    "f")，该函数接受这些二进制字符串并返回“true”（或![1](img/file13.png "1"）），如果由字符串索引的元素满足条件，否则返回“false”（或![0](img/file12.png
    "0"））。例如，假设我们在8个不同的元素中进行搜索，并且满足条件的元素由字符串![010](img/file779.png "010")和![100](img/file389.png
    "100")索引。那么，![f](img/file778.png "f")将是这样一个布尔函数，当![x = 010](img/file781.png "x
    = 010")或![x = 100](img/file782.png "x = 100")时，![f(x) = 1](img/file780.png "f(x)
    = 1")，否则![f(x) = 0](img/file783.png "f(x) = 0"）。为了简化符号，从现在起我们将用用于索引元素的字符串![x](img/file269.png
    "x")来标识元素。
- en: 'It is important to notice that, in this setting, we have no access to the inner
    workings of ![f](img/file778.png "f"). It acts like a black box. The only thing
    that we can do with the ![f](img/file778.png "f") function is call it on inputs
    and observe the outputs, thus checking whether the given input satisfies the condition
    that we are considering or not. Since we do not have any information about the
    indices of the elements that satisfy the condition, we cannot favour any position
    over any other. Thus, with a classical algorithm, if we are searching among ![N](img/file784.png
    "N") elements and only one of them satisfies the condition we are interested in,
    we will need to call ![f](img/file778.png "f") about ![\left. N\slash 2 \right.](img/file785.png
    "\left. N\slash 2 \right.") times on average in order to find it. The element
    could be just anywhere! In fact, if we are extremely unlucky, we might need to
    use ![N - 1](img/file786.png "N - 1") calls (notice that we wouldn’t need ![N](img/file784.png
    "N") calls: if we don’t find the element after ![N - 1](img/file786.png "N - 1")
    different calls, we already know the remaining position to be the one where the
    element is located).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在这种情况下，我们无法访问![f](img/file778.png "f")的内部工作原理。它就像一个黑盒。我们能做的唯一一件事就是调用![f](img/file778.png
    "f")函数并观察输出，从而检查给定的输入是否满足我们正在考虑的条件。由于我们没有关于满足条件的元素索引的任何信息，我们无法偏向任何位置。因此，在经典算法中，如果我们正在搜索![N](img/file784.png
    "N")个元素，并且只有一个元素满足我们感兴趣的特定条件，我们平均需要调用![f](img/file778.png "f")大约![\left. N\slash
    2 \right.](img/file785.png "\left. N\slash 2 \right.")次才能找到它。元素可能就在任何地方！实际上，如果我们非常不幸，我们可能需要使用![N
    - 1](img/file786.png "N - 1")次调用（请注意，我们不需要![N](img/file784.png "N")次调用：如果我们经过![N
    - 1](img/file786.png "N - 1")次不同的调用后还没有找到元素，我们已经知道剩余的位置就是元素所在的位置）。
- en: It may come as a big surprise, then, that with Grover’s algorithm it is possible
    to find the hidden element with high probability (much more on this later in this
    section) by calling ![f](img/file778.png "f") around ![\sqrt{N}](img/file787.png
    "\sqrt{N}") times! This means that if we are searching among ![1\, 000\, 000](img/file788.png
    "1\, 000\, 000") elements, with a classical computer you would need to check ![f](img/file778.png
    "f") about ![500\, 000](img/file789.png "500\, 000") times on average, but calling
    ![f](img/file778.png "f") less than ![1000](img/file790.png "1000") times would
    suffice in order to solve the problem with a quantum computer, at least with a
    high likelihood. What is more, the difference in the number of calls between the
    classical and the quantum methods grows bigger if ![N](img/file784.png "N") is
    higher.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用Grover算法，我们有可能通过大约![\sqrt{N}](img/file787.png "\sqrt{N}")次调用![f](img/file778.png
    "f")来以高概率找到隐藏的元素（关于这一点，本节后面将详细介绍）。这意味着如果我们正在搜索![1\, 000\, 000](img/file788.png
    "1\, 000\, 000")个元素，使用经典计算机平均需要检查![f](img/file778.png "f")大约![500\, 000](img/file789.png
    "500\, 000")次，但使用量子计算机，至少以高概率，调用![f](img/file778.png "f")少于![1000](img/file790.png
    "1000")次就足够解决问题了。更重要的是，当![N](img/file784.png "N")更高时，经典方法和量子方法之间的调用次数差异会更大。
- en: How is this possible? It seems to defy all logic, but it rests on properties
    that we are already familiar with, such as superposition and entanglement. In
    fact, Grover’s algorithm will query ![f](img/file778.png "f") with elements that
    are in superposition. But in order to understand this, we need to explore what
    quantum oracles are and how they can be used, so let’s get to it!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这怎么可能呢？这似乎违反了所有逻辑，但它基于我们已经熟悉的属性，比如叠加和纠缠。事实上，Grover算法将使用处于叠加状态的元素查询![f](img/file778.png
    "f")。但为了理解这一点，我们需要探索量子或门是什么以及它们如何被使用，那么让我们开始吧！
- en: 6.1.1 Quantum oracles
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1.1 量子或门
- en: We have mentioned that, in the setting of the search problem solved by Grover’s
    algorithm, we are given a Boolean function ![f](img/file778.png "f") that we can
    use to determine whether an element is the one we are looking for or not. But
    what do we mean when we say that we are ”given” this function?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，在Grover算法解决的搜索问题设置中，我们被给定一个布尔函数![f](img/file778.png "f")，我们可以用它来确定一个元素是否是我们正在寻找的。但当我们说“给定”这个函数时，我们是什么意思呢？
- en: In the classical case, this is more or less straightforward. If we were writing
    our code in Python, we could be given a function object that receives an ![n](img/file244.png
    "n")-bit string and returns `True` or `False`. Then, we could use that function
    in our own code to check the elements that we want to consider, without necessarily
    knowing how it is implemented.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典情况下，这基本上是直截了当的。如果我们用Python编写代码，我们可能会得到一个接收![n](img/file244.png "n")位字符串并返回`True`或`False`的函数对象。然后，我们可以在自己的代码中使用这个函数来检查我们想要考虑的元素，而不必知道它是如何实现的。
- en: But…what is the equivalent to that function definition when we are working with
    quantum circuits? The most natural assumption is that we are provided with a new
    quantum gate ![O_{f}](img/file791.png "O_{f}") that implements ![f](img/file778.png
    "f") and that we can use in our circuits whenever we need it. However, a quantum
    gate needs to be a unitary operation and, in particular, reversible, so we need
    to be a little bit careful in how we design it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但是……当我们与量子电路一起工作时，那个函数定义的等价物是什么？最自然的假设是我们被提供了一个新的量子门![O_{f}](img/file791.png
    "O_{f}")，它实现了![f](img/file778.png "f")，并且我们可以在需要时在我们的电路中使用它。然而，量子门需要是一个单位可逆操作，特别是可逆的，因此我们在设计它时需要稍微小心一些。
- en: In the classical case, we had ![n](img/file244.png "n") inputs — the ![n](img/file244.png
    "n") bits of the string — and just one output. In the quantum case, we need at
    least ![n](img/file244.png "n") inputs — ![n](img/file244.png "n") qubits — but
    just one output would not work, because then it would be impossible to make the
    operation reversible, let alone unitary. In fact, as you surely remember, every
    quantum gate has the same number of inputs and outputs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典情况下，我们拥有![n](img/file244.png "n")个输入——字符串的![n](img/file244.png "n")位——以及仅仅一个输出。在量子情况下，我们至少需要![n](img/file244.png
    "n")个输入——![n](img/file244.png "n")个量子比特——但仅仅一个输出是不够的，因为那样的话，操作将无法实现可逆性，更不用说单位可逆性了。实际上，正如你肯定记得的那样，每个量子门都有相同数量的输入和输出。
- en: The usual approach, then, is to consider a quantum gate on ![n + 1](img/file792.png
    "n + 1") qubits. The first ![n](img/file244.png "n") of these qubits will serve
    as the input and the additional one will be used to store the output. More formally,
    on any input ![\left| x \right\rangle\left| y \right\rangle](img/file793.png "\left|
    x \right\rangle\left| y \right\rangle"), where ![x](img/file269.png "x") is an
    ![n](img/file244.png "n")-bit string and ![y](img/file270.png "y") is a single
    bit, the output of the ![O_{f}](img/file791.png "O_{f}") gate will be ![\left|
    x \right\rangle\left| {y \oplus f(x)} \right\rangle](img/file794.png "\left| x
    \right\rangle\left| {y \oplus f(x)} \right\rangle"), where ![\oplus](img/file195.png
    "\oplus") denotes addition modulo 2 (see *Appendix* * [*B*](ch025.xhtml#x1-226000B)*,
    Basic Linear Algebra*, for a refresher on modular arithmetic). This defines the
    action of the gate on the computational basis states and then we can extend it
    to the rest of the quantum states by linearity, as usual.*
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常的方法是考虑一个在![n + 1](img/file792.png "n + 1")个量子比特上的量子门。这其中的前![n](img/file244.png
    "n")个量子比特将作为输入，额外的那个将用于存储输出。更正式地说，对于任何输入![\left| x \right\rangle\left| y \right\rangle](img/file793.png
    "\left| x \right\rangle\left| y \right\rangle")，其中![x](img/file269.png "x")是一个![n](img/file244.png
    "n")位字符串，![y](img/file270.png "y")是一个单比特，![O_{f}](img/file791.png "O_{f}")门的输出将是![\left|
    x \right\rangle\left| {y \oplus f(x)} \right\rangle](img/file794.png "\left| x
    \right\rangle\left| {y \oplus f(x)} \right\rangle")，其中![\oplus](img/file195.png
    "\oplus")表示模2加法（参见*附录* * [*B*](ch025.xhtml#x1-226000B)*，*基础线性代数*，以复习模算术）。这定义了该门在计算基态上的作用，然后我们可以通过线性扩展到其他量子态，就像通常那样。
- en: '*This may look like an odd choice. The ”natural” thing to do might seem to
    be requiring the output to be ![\left| x \right\rangle\left| {f(x)} \right\rangle](img/file795.png
    "\left| x \right\rangle\left| {f(x)} \right\rangle"), right? But that would not
    be reversible in general, because we would obtain the same output over the inputs
    ![\left| x \right\rangle\left| 0 \right\rangle](img/file796.png "\left| x \right\rangle\left|
    0 \right\rangle") and ![\left| x \right\rangle\left| 1 \right\rangle](img/file797.png
    "\left| x \right\rangle\left| 1 \right\rangle"). With our choice, though, the
    operation is reversible. If we applied ![O_{f}](img/file791.png "O_{f}") twice,
    we would obtain ![\left| x \right\rangle\left| {y \oplus f(x) \oplus f(x)} \right\rangle](img/file798.png
    "\left| x \right\rangle\left| {y \oplus f(x) \oplus f(x)} \right\rangle"), which
    is equal to ![\left| x \right\rangle\left| y \right\rangle](img/file793.png "\left|
    x \right\rangle\left| y \right\rangle") because, when we are performing addition
    modulo ![2](img/file302.png "2"), ![f(x) \oplus f(x) = 0](img/file799.png "f(x)
    \oplus f(x) = 0") no matter the value of ![f(x)](img/file800.png "f(x)").'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*这看起来可能是一个奇怪的选择。最“自然”的事情可能是要求输出为![\left| x \right\rangle\left| {f(x)} \right\rangle](img/file795.png
    "\left| x \right\rangle\left| {f(x)} \right\rangle")，对吧？但这种情况在一般情况下是不可逆的，因为我们会在输入![\left|
    x \right\rangle\left| 0 \right\rangle](img/file796.png "\left| x \right\rangle\left|
    0 \right\rangle")和![\left| x \right\rangle\left| 1 \right\rangle](img/file797.png
    "\left| x \right\rangle\left| 1 \right\rangle")上获得相同的输出。然而，根据我们的选择，操作是可逆的。如果我们对![O_{f}](img/file791.png
    "O_{f}")应用两次，我们会得到![\left| x \right\rangle\left| {y \oplus f(x) \oplus f(x)} \right\rangle](img/file798.png
    "\left| x \right\rangle\left| {y \oplus f(x) \oplus f(x)} \right\rangle")，这等于![\left|
    x \right\rangle\left| y \right\rangle](img/file793.png "\left| x \right\rangle\left|
    y \right\rangle")，因为当我们执行模![2](img/file302.png "2")加法时，![f(x) \oplus f(x) = 0](img/file799.png
    "f(x) \oplus f(x) = 0")，无论![f(x)](img/file800.png "f(x)")的值是多少。'
- en: Exercise 6.1
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.1
- en: Prove that ![O_{f}](img/file791.png "O_{f}") is not only reversible but also
    unitary and hence it deserves the name ”quantum gate.”
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 证明![O_{f}](img/file791.png "O_{f}")不仅可逆，而且是幺正的，因此它值得被称为“量子门”。
- en: Usually, ![O_{f}](img/file791.png "O_{f}") is said to be a quantum oracle for
    ![f](img/file778.png "f"), because we can consult it to get the value of ![f](img/file778.png
    "f") on any input ![x](img/file269.png "x") without having to worry about its
    internal workings. In fact, if the input to ![O_{f}](img/file791.png "O_{f}")
    is ![\left| x \right\rangle\left| 0 \right\rangle](img/file796.png "\left| x \right\rangle\left|
    0 \right\rangle"), then the output is ![\left| x \right\rangle\left| {0 \oplus
    f(x)} \right\rangle = \left| x \right\rangle\left| {f(x)} \right\rangle](img/file801.png
    "\left| x \right\rangle\left| {0 \oplus f(x)} \right\rangle = \left| x \right\rangle\left|
    {f(x)} \right\rangle") and we could hence recover ![f(x)](img/file800.png "f(x)")
    just by measuring the last qubit.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，![O_{f}](img/file791.png "O_{f}") 被称为 ![f](img/file778.png "f") 的量子 Oracle，因为我们可以在不担心其内部工作原理的情况下查询它，以获取任何输入
    ![x](img/file269.png "x") 上 ![f](img/file778.png "f") 的值。实际上，如果 ![O_{f}](img/file791.png
    "O_{f}") 的输入是 ![\left| x \right\rangle\left| 0 \right\rangle](img/file796.png
    "\left| x \right\rangle\left| 0 \right\rangle")，那么输出是 ![\left| x \right\rangle\left|
    {0 \oplus f(x)} \right\rangle = \left| x \right\rangle\left| {f(x)} \right\rangle](img/file801.png
    "\left| x \right\rangle\left| {0 \oplus f(x)} \right\rangle = \left| x \right\rangle\left|
    {f(x)} \right\rangle")，因此我们可以通过测量最后一个量子比特来恢复 ![f(x)](img/file800.png "f(x)")。
- en: For any ![f](img/file778.png "f"), it is always possible to construct ![O_{f}](img/file791.png
    "O_{f}") by using just NOT and multi-controlled NOT gates — even if the resulting
    circuit is not the most efficient one in most cases. For instance, if ![f](img/file778.png
    "f") is a Boolean function on 3-bit strings such that ![f](img/file778.png "f")
    takes value ![1](img/file13.png "1") just on ![101](img/file802.png "101") and
    ![011](img/file803.png "011"), then we can use the circuit depicted in *Figure*
    * [*6.1*](#Figure6.1). Notice how we have used NOT gates before and after the
    multi-controlled gates to select those qubits that should be ![0](img/file12.png
    "0") in the input and to restore them to their original values.*
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何 ![f](img/file778.png "f")，总可以通过仅使用 NOT 和多控制 NOT 门来构建 ![O_{f}](img/file791.png
    "O_{f}")，即使在这种情况下得到的电路在大多数情况下不是最有效的。例如，如果 ![f](img/file778.png "f") 是一个作用在 3 位字符串上的布尔函数，且
    ![f](img/file778.png "f") 仅在 ![101](img/file802.png "101") 和 ![011](img/file803.png
    "011") 上取值 ![1](img/file13.png "1")，那么我们可以使用 *图* *[*6.1*](#Figure6.1) 中所示的电路。注意我们是如何在多控制门前后使用
    NOT 门来选择那些在输入中应为 ![0](img/file12.png "0") 的量子比特，并将它们恢复到原始值的。
- en: '*![Figure 6.1: Oracle for the Boolean function f that takes value 1 on 101
    and 011, and value 0 on the rest of the 3-bit strings](img/file804.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*![图 6.1: 布尔函数 ![f](img/file778.png "f") 的 Oracle，它在 101 和 011 上取值 ![1](img/file13.png
    "1")，在其余的 3 位字符串上取值 ![0](img/file12.png "0")](img/file804.jpg)'
- en: '**Figure 6.1**: Oracle for the Boolean function ![f](img/file778.png "f") that
    takes value ![1](img/file13.png "1") on ![101](img/file802.png "101") and ![011](img/file803.png
    "011"), and value ![0](img/file12.png "0") on the rest of the 3-bit strings'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.1**: 布尔函数 ![f](img/file778.png "f") 的 Oracle，它在 ![101](img/file802.png
    "101") 和 ![011](img/file803.png "011") 上取值 ![1](img/file13.png "1")，在其余的 3 位字符串上取值
    ![0](img/file12.png "0")'
- en: Exercise 6.2
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.2
- en: Construct a circuit for ![O_{f}](img/file791.png "O_{f}") where ![f](img/file778.png
    "f") is a 4-bit Boolean function that takes value ![1](img/file13.png "1") on
    ![0111](img/file805.png "0111"), ![1110](img/file806.png "1110"), and ![0101](img/file807.png
    "0101"), and value ![0](img/file12.png "0") on any other input.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个 ![O_{f}](img/file791.png "O_{f}") 电路，其中 ![f](img/file778.png "f") 是一个 4
    位布尔函数，它在 ![0111](img/file805.png "0111")、![1110](img/file806.png "1110") 和 ![0101](img/file807.png
    "0101") 上取值 ![1](img/file13.png "1")，在其余输入上取值 ![0](img/file12.png "0")。
- en: 'This settles how we are going to receive the Boolean function ![f](img/file778.png
    "f") that we can use to check whether a given element satisfies the conditions
    that we are interested in: the function will be given to us as a quantum oracle.
    Now it’s time for us to show how we can use these quantum oracles in Grover’s
    algorithm.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这就解决了我们将如何接收布尔函数 ![f](img/file778.png "f")，我们可以用它来检查给定的元素是否满足我们感兴趣的条件：该函数将以量子
    Oracle 的形式提供给我们。现在是我们展示如何使用这些量子 Oracle 在 Grover 算法中发挥作用的时候了。
- en: 6.1.2 Grover’s circuits
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1.2 Grover 电路
- en: Let’s say that we want to apply Grover’s algorithm to a Boolean function ![f](img/file778.png
    "f") which receives binary strings of length ![n](img/file244.png "n"). In addition
    to the ![O_{f}](img/file791.png "O_{f}") oracle described in the previous section,
    the circuit used in Grover’s algorithm involves two other blocks, as you can see
    in *Figure* * [*6.2*](#Figure6.2).*
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将 Grover 算法应用于接收长度为 ![n](img/file244.png "n") 的二进制字符串的布尔函数 ![f](img/file778.png
    "f")。除了上一节中描述的 ![O_{f}](img/file791.png "O_{f}") Oracle 之外，Grover 算法中使用的电路还涉及两个其他部分，如
    *图* *[*6.2*](#Figure6.2) 所示。
- en: '*![Figure 6.2: Circuit for Grover’s algorithm in the case in which f receives
    strings of length 3 as input. The oracle O_{f} and Grover’s diffusion operator
    are repeated, in that order, a number of times before the final measurements ](img/file808.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*![图6.2：当f接收长度为3的字符串作为输入时，Grover算法的电路。在最终测量之前，O_{f}和Grover扩散算子按顺序重复多次](img/file808.jpg)'
- en: '**Figure 6.2**: Circuit for Grover’s algorithm in the case in which ![f](img/file778.png
    "f") receives strings of length ![3](img/file472.png "3") as input. The oracle
    ![O_{f}](img/file791.png "O_{f}") and Grover’s diffusion operator are repeated,
    in that order, a number of times before the final measurements'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6.2**：当![f](img/file778.png "f")接收长度为![3](img/file472.png "3")的字符串作为输入时，Grover算法的电路。在最终测量之前，![O_{f}](img/file791.png
    "O_{f}")和Grover扩散算子按顺序重复多次'
- en: The first block is composed of one-qubit gates that are applied to the initial
    state ![\left| {0\cdots 0} \right\rangle\left| 0 \right\rangle](img/file809.png
    "\left| {0\cdots 0} \right\rangle\left| 0 \right\rangle"), where the first register
    is of length ![n](img/file244.png "n") and the second one is of length ![1](img/file13.png
    "1"). Thus, the state just before applying the oracle is
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个块由作用于初始状态![\left| {0\cdots 0} \right\rangle\left| 0 \right\rangle](img/file809.png
    "\left| {0\cdots 0} \right\rangle\left| 0 \right\rangle")的单量子比特门组成，其中第一个寄存器的长度为![n](img/file244.png
    "n")，第二个寄存器的长度为![1](img/file13.png "1")。因此，在应用或然性算子之前的状态是
- en: '![H^{\otimes n + 1}\left| 0 \right\rangle^{\otimes n}\left| 1 \right\rangle
    = \left| + \right\rangle^{\otimes n}\left| - \right\rangle = \frac{1}{\sqrt{2^{n}}}\left(
    {(\left| 0 \right\rangle + \left| 1 \right\rangle)\cdots(\left| 0 \right\rangle
    + \left| 1 \right\rangle)} \right)\left| - \right\rangle = \frac{1}{\sqrt{2^{n}}}\sum\limits_{x
    = 0}^{2^{n} - 1}\left| x \right\rangle\left| - \right\rangle,](img/file810.png
    "H^{\otimes n + 1}\left| 0 \right\rangle^{\otimes n}\left| 1 \right\rangle = \left|
    + \right\rangle^{\otimes n}\left| - \right\rangle = \frac{1}{\sqrt{2^{n}}}\left(
    {(\left| 0 \right\rangle + \left| 1 \right\rangle)\cdots(\left| 0 \right\rangle
    + \left| 1 \right\rangle)} \right)\left| - \right\rangle = \frac{1}{\sqrt{2^{n}}}\sum\limits_{x
    = 0}^{2^{n} - 1}\left| x \right\rangle\left| - \right\rangle,")'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![H^{\otimes n + 1}\left| 0 \right\rangle^{\otimes n}\left| 1 \right\rangle
    = \left| + \right\rangle^{\otimes n}\left| - \right\rangle = \frac{1}{\sqrt{2^{n}}}\left(
    {(\left| 0 \right\rangle + \left| 1 \right\rangle)\cdots(\left| 0 \right\rangle
    + \left| 1 \right\rangle)} \right)\left| - \right\rangle = \frac{1}{\sqrt{2^{n}}}\sum\limits_{x
    = 0}^{2^{n} - 1}\left| x \right\rangle\left| - \right\rangle,](img/file810.png
    "H^{\otimes n + 1}\left| 0 \right\rangle^{\otimes n}\left| 1 \right\rangle = \left|
    + \right\rangle^{\otimes n}\left| - \right\rangle = \frac{1}{\sqrt{2^{n}}}\left(
    {(\left| 0 \right\rangle + \left| 1 \right\rangle)\cdots(\left| 0 \right\rangle
    + \left| 1 \right\rangle)} \right)\left| - \right\rangle = \frac{1}{\sqrt{2^{n}}}\sum\limits_{x
    = 0}^{2^{n} - 1}\left| x \right\rangle\left| - \right\rangle,")'
- en: because we apply the first ![X](img/file9.png "X") gate to ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle") to obtain ![\left| 1 \right\rangle](img/file14.png "\left|
    1 \right\rangle").
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将第一个![X](img/file9.png "X")门应用于![\left| 0 \right\rangle](img/file6.png "\left|
    0 \right\rangle")以获得![\left| 1 \right\rangle](img/file14.png "\left| 1 \right\rangle")。
- en: Notice that the first register of this state is a superposition of all basis
    states ![\left| x \right\rangle](img/file267.png "\left| x \right\rangle"). This
    is exactly what we will use in order to evaluate ![f](img/file778.png "f") ”in
    superposition” with our application of the ![O_{f}](img/file791.png "O_{f}") oracle.
    Indeed, by the definition of ![O_{f}](img/file791.png "O_{f}"), the state that
    we will have after the application of the oracle is
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个状态的第一个寄存器是所有基态![\left| x \right\rangle](img/file267.png "\left| x \right\rangle")的叠加。这正是我们将使用我们的![O_{f}](img/file791.png
    "O_{f}")或然性算子来评估“叠加”中的![f](img/file778.png "f")”时所需要的东西。实际上，根据![O_{f}](img/file791.png
    "O_{f}")的定义，我们在应用或然性算子之后将得到的状态是
- en: '![\begin{matrix} {O_{f}\left( {\frac{1}{\sqrt{2^{n}}}\sum\limits_{x = 0}^{2^{n}
    - 1}\left| x \right\rangle\left| - \right\rangle} \right) = O_{f}\left( {\frac{1}{\sqrt{2^{n
    + 1}}}\sum\limits_{x = 0}^{2^{n} - 1}\left| x \right\rangle(\left| 0 \right\rangle
    - \left| 1 \right\rangle)} \right) =} & \\ {\frac{1}{\sqrt{2^{n + 1}}}\sum\limits_{x
    = 0}^{2^{n} - 1}O_{f}\left| x \right\rangle(\left| 0 \right\rangle - \left| 1
    \right\rangle) = \frac{1}{\sqrt{2^{n + 1}}}\sum\limits_{x = 0}^{2^{n} - 1}\left|
    x \right\rangle(\left| {0 \oplus f(x)} \right\rangle - \left| {1 \oplus f(x)}
    \right\rangle),} & \\ \end{matrix}](img/file811.png "\begin{matrix} {O_{f}\left(
    {\frac{1}{\sqrt{2^{n}}}\sum\limits_{x = 0}^{2^{n} - 1}\left| x \right\rangle\left|
    - \right\rangle} \right) = O_{f}\left( {\frac{1}{\sqrt{2^{n + 1}}}\sum\limits_{x
    = 0}^{2^{n} - 1}\left| x \right\rangle(\left| 0 \right\rangle - \left| 1 \right\rangle)}
    \right) =} & \\ {\frac{1}{\sqrt{2^{n + 1}}}\sum\limits_{x = 0}^{2^{n} - 1}O_{f}\left|
    x \right\rangle(\left| 0 \right\rangle - \left| 1 \right\rangle) = \frac{1}{\sqrt{2^{n
    + 1}}}\sum\limits_{x = 0}^{2^{n} - 1}\left| x \right\rangle(\left| {0 \oplus f(x)}
    \right\rangle - \left| {1 \oplus f(x)} \right\rangle),} & \\ \end{matrix}")'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{matrix} {O_{f}\left( {\frac{1}{\sqrt{2^{n}}}\sum\limits_{x = 0}^{2^{n}
    - 1}\left| x \right\rangle\left| - \right\rangle} \right) = O_{f}\left( {\frac{1}{\sqrt{2^{n
    + 1}}}\sum\limits_{x = 0}^{2^{n} - 1}\left| x \right\rangle(\left| 0 \right\rangle
    - \left| 1 \right\rangle)} \right) =} & \\ {\frac{1}{\sqrt{2^{n + 1}}}\sum\limits_{x
    = 0}^{2^{n} - 1}O_{f}\left| x \right\rangle(\left| 0 \right\rangle - \left| 1
    \right\rangle) = \frac{1}{\sqrt{2^{n + 1}}}\sum\limits_{x = 0}^{2^{n} - 1}\left|
    x \right\rangle(\left| {0 \oplus f(x)} \right\rangle - \left| {1 \oplus f(x)}
    \right\rangle),} & \\ \end{matrix}](img/file811.png "\begin{matrix} {O_{f}\left(
    {\frac{1}{\sqrt{2^{n}}}\sum\limits_{x = 0}^{2^{n} - 1}\left| x \right\rangle\left|
    - \right\rangle} \right) = O_{f}\left( {\frac{1}{\sqrt{2^{n + 1}}}\sum\limits_{x
    = 0}^{2^{n} - 1}\left| x \right\rangle(\left| 0 \right\rangle - \left| 1 \right\rangle)}
    \right) =} & \\ {\frac{1}{\sqrt{2^{n + 1}}}\sum\limits_{x = 0}^{2^{n} - 1}O_{f}\left|
    x \right\rangle(\left| 0 \right\rangle - \left| 1 \right\rangle) = \frac{1}{\sqrt{2^{n
    + 1}}}\sum\limits_{x = 0}^{2^{n} - 1}\left| x \right\rangle(\left| {0 \oplus f(x)}
    \right\rangle - \left| {1 \oplus f(x)} \right\rangle),} & \\ \end{matrix}")'
- en: where in the last two equalities he have used linearity together with the definition
    of ![O_{f}](img/file791.png "O_{f}").
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 其中在最后两个等式中，他使用了线性性质以及 ![O_{f}](img/file791.png "O_{f}") 的定义。
- en: Let’s focus on the ![\left| {0 \oplus f(x)} \right\rangle - \left| {1 \oplus
    f(x)} \right\rangle](img/file812.png "\left| {0 \oplus f(x)} \right\rangle - \left|
    {1 \oplus f(x)} \right\rangle") term. If ![f(x) = 0](img/file783.png "f(x) = 0"),
    then it is just ![\left| 0 \right\rangle - \left| 1 \right\rangle](img/file813.png
    "\left| 0 \right\rangle - \left| 1 \right\rangle"). However, if ![f(x) = 1](img/file780.png
    "f(x) = 1"), we have
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注 ![\left| {0 \oplus f(x)} \right\rangle - \left| {1 \oplus f(x)} \right\rangle](img/file812.png
    "\left| {0 \oplus f(x)} \right\rangle - \left| {1 \oplus f(x)} \right\rangle")
    这一项。如果 ![f(x) = 0](img/file783.png "f(x) = 0"), 那么它就是 ![\left| 0 \right\rangle
    - \left| 1 \right\rangle](img/file813.png "\left| 0 \right\rangle - \left| 1 \right\rangle").
    然而，如果 ![f(x) = 1](img/file780.png "f(x) = 1"), 我们有
- en: '![\left| {0 \oplus f(x)} \right\rangle - \left| {1 \oplus f(x)} \right\rangle
    = \left| {0 \oplus 1} \right\rangle - \left| {1 \oplus 1} \right\rangle = \left|
    1 \right\rangle - \left| 0 \right\rangle = - (\left| 0 \right\rangle - \left|
    1 \right\rangle),](img/file814.png "\left| {0 \oplus f(x)} \right\rangle - \left|
    {1 \oplus f(x)} \right\rangle = \left| {0 \oplus 1} \right\rangle - \left| {1
    \oplus 1} \right\rangle = \left| 1 \right\rangle - \left| 0 \right\rangle = -
    (\left| 0 \right\rangle - \left| 1 \right\rangle),")'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![\left| {0 \oplus f(x)} \right\rangle - \left| {1 \oplus f(x)} \right\rangle
    = \left| {0 \oplus 1} \right\rangle - \left| {1 \oplus 1} \right\rangle = \left|
    1 \right\rangle - \left| 0 \right\rangle = - (\left| 0 \right\rangle - \left|
    1 \right\rangle),](img/file814.png "\left| {0 \oplus f(x)} \right\rangle - \left|
    {1 \oplus f(x)} \right\rangle = \left| {0 \oplus 1} \right\rangle - \left| {1
    \oplus 1} \right\rangle = \left| 1 \right\rangle - \left| 0 \right\rangle = -
    (\left| 0 \right\rangle - \left| 1 \right\rangle),")'
- en: because ![1 \oplus 1 = 0](img/file815.png "1 \oplus 1 = 0"). In both cases,
    we can write
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ![1 \oplus 1 = 0](img/file815.png "1 \oplus 1 = 0"). 在这两种情况下，我们可以写成
- en: '![\left| {0 \oplus f(x)} \right\rangle - \left| {1 \oplus f(x)} \right\rangle
    = {( - 1)}^{f(x)}(\left| 0 \right\rangle - \left| 1 \right\rangle),](img/file816.png
    "\left| {0 \oplus f(x)} \right\rangle - \left| {1 \oplus f(x)} \right\rangle =
    {( - 1)}^{f(x)}(\left| 0 \right\rangle - \left| 1 \right\rangle),")'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![\left| {0 \oplus f(x)} \right\rangle - \left| {1 \oplus f(x)} \right\rangle
    = {( - 1)}^{f(x)}(\left| 0 \right\rangle - \left| 1 \right\rangle),](img/file816.png
    "\left| {0 \oplus f(x)} \right\rangle - \left| {1 \oplus f(x)} \right\rangle =
    {( - 1)}^{f(x)}(\left| 0 \right\rangle - \left| 1 \right\rangle),")'
- en: because ![{( - 1)}^{0} = 1](img/file817.png "{( - 1)}^{0} = 1") and ![{( - 1)}^{1}
    = - 1](img/file818.png "{( - 1)}^{1} = - 1").
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ![{( - 1)}^{0} = 1](img/file817.png "{( - 1)}^{0} = 1") 和 ![{( - 1)}^{1}
    = - 1](img/file818.png "{( - 1)}^{1} = - 1").
- en: Note how, thanks to these transformations, there is information about the value
    ![f(x)](img/file800.png "f(x)") coded into the amplitude of the state now. As
    you will soon see, this is a key ingredient of the algorithm.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于这些变换，现在状态振幅中编码了关于值![f(x)](img/file800.png "f(x)")的信息。正如你很快就会看到的，这是算法的关键组成部分。
- en: If we take this to our expression for the state after the oracle application,
    we get
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个应用到我们的或然应用后的状态表达式中，我们得到
- en: '![\begin{matrix} {O_{f}\left( {\frac{1}{\sqrt{2^{n}}}\sum\limits_{x = 0}^{2^{n}
    - 1}\left| x \right\rangle\left| - \right\rangle} \right) = \frac{1}{\sqrt{2^{n
    + 1}}}\sum\limits_{x = 0}^{2^{n} - 1}\left| x \right\rangle(\left| {0 \oplus f(x)}
    \right\rangle - \left| {1 \oplus f(x)} \right\rangle) =} & \\ {\frac{1}{\sqrt{2^{n
    + 1}}}\sum\limits_{x = 0}^{2^{n} - 1}{( - 1)}^{f(x)}\left| x \right\rangle(\left|
    0 \right\rangle - \left| 1 \right\rangle) = \frac{1}{\sqrt{2^{n}}}\sum\limits_{x
    = 0}^{2^{n} - 1}{( - 1)}^{f(x)}\left| x \right\rangle\frac{1}{\sqrt{2}}(\left|
    0 \right\rangle - \left| 1 \right\rangle) =} & \\ {\frac{1}{\sqrt{2^{n}}}\sum\limits_{x
    = 0}^{2^{n} - 1}{( - 1)}^{f(x)}\left| x \right\rangle\left| - \right\rangle.}
    & \\ \end{matrix}](img/file819.png "\begin{matrix} {O_{f}\left( {\frac{1}{\sqrt{2^{n}}}\sum\limits_{x
    = 0}^{2^{n} - 1}\left| x \right\rangle\left| - \right\rangle} \right) = \frac{1}{\sqrt{2^{n
    + 1}}}\sum\limits_{x = 0}^{2^{n} - 1}\left| x \right\rangle(\left| {0 \oplus f(x)}
    \right\rangle - \left| {1 \oplus f(x)} \right\rangle) =} & \\ {\frac{1}{\sqrt{2^{n
    + 1}}}\sum\limits_{x = 0}^{2^{n} - 1}{( - 1)}^{f(x)}\left| x \right\rangle(\left|
    0 \right\rangle - \left| 1 \right\rangle) = \frac{1}{\sqrt{2^{n}}}\sum\limits_{x
    = 0}^{2^{n} - 1}{( - 1)}^{f(x)}\left| x \right\rangle\frac{1}{\sqrt{2}}(\left|
    0 \right\rangle - \left| 1 \right\rangle) =} & \\ {\frac{1}{\sqrt{2^{n}}}\sum\limits_{x
    = 0}^{2^{n} - 1}{( - 1)}^{f(x)}\left| x \right\rangle\left| - \right\rangle.}
    & \\ \end{matrix}")'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: \[\begin{matrix} {O_{f}\left( {\frac{1}{\sqrt{2^{n}}}\sum\limits_{x = 0}^{2^{n}
    - 1}\left| x \right\rangle\left| - \right\rangle} \right) = \frac{1}{\sqrt{2^{n
    + 1}}}\sum\limits_{x = 0}^{2^{n} - 1}\left| x \right\rangle(\left| {0 \oplus f(x)}
    \right\rangle - \left| {1 \oplus f(x)} \right\rangle) =} \\ {\frac{1}{\sqrt{2^{n
    + 1}}}\sum\limits_{x = 0}^{2^{n} - 1}{( - 1)}^{f(x)}\left| x \right\rangle(\left|
    0 \right\rangle - \left| 1 \right\rangle) = \frac{1}{\sqrt{2^{n}}}\sum\limits_{x
    = 0}^{2^{n} - 1}{( - 1)}^{f(x)}\left| x \right\rangle\frac{1}{\sqrt{2}}(\left|
    0 \right\rangle - \left| 1 \right\rangle) =} \\ {\frac{1}{\sqrt{2^{n}}}\sum\limits_{x
    = 0}^{2^{n} - 1}{( - 1)}^{f(x)}\left| x \right\rangle\left| - \right\rangle.}
    & \\ \end{matrix}\]
- en: Notice how the application of ![O_{f}](img/file791.png "O_{f}") has introduced
    a relative phase in some of the states ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle") of the superposition. This technique is called **phase
    kickback**, because we have only used the register in state ![\left| - \right\rangle](img/file63.png
    "\left| - \right\rangle") to create the phase but it ends up affecting the whole
    state. It is used in other famous quantum methods such as the Deutsch-Jozsa and
    Simon’s algorithms (see the book by Yanofsky and Mannucci [[100](ch030.xhtml#Xyanofsky2008quantum)]
    for an excellent explanation of these methods).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到![O_{f}](img/file791.png "O_{f}")的应用如何在叠加态中的某些状态![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle")中引入了相对相。这种技术被称为**相位回弹**，因为我们只使用了状态![\left| - \right\rangle](img/file63.png
    "\left| - \right\rangle")的寄存器来创建相位，但它最终影响了整个状态。它被用于其他著名的量子方法，如Deutsch-Jozsa算法和Simon算法（参见Yanofsky和Mannucci的书籍[[100](ch030.xhtml#Xyanofsky2008quantum)]，其中对这些方法的解释非常出色）。
- en: As we have proved, the phase that goes with the basis state ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle") depends only on ![f(x)](img/file800.png "f(x)") and
    it is ![1](img/file13.png "1") if ![f(x) = 0](img/file783.png "f(x) = 0") and
    ![- 1](img/file312.png "- 1") if ![f(x) = 1](img/file780.png "f(x) = 1"). In this
    way, we say that we have **marked** those elements that satisfy the conditions
    that we are interested in, that is, those elements ![x](img/file269.png "x") such
    that ![f(x) = 1](img/file780.png "f(x) = 1"). Remarkably, we have done this with
    just one call to ![O_{f}](img/file791.png "O_{f}"), exploiting the possibility
    of evaluating it in superposition. That is an exponential number of function evaluations
    with just one call! It sounds like magic, doesn’t it?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所证明的，与基态![\left| x \right\rangle](img/file267.png "\left| x \right\rangle")相关的相只依赖于![f(x)](img/file800.png
    "f(x)")，如果![f(x) = 0](img/file783.png "f(x) = 0")，则它是![1](img/file13.png "1")，如果![f(x)
    = 1](img/file780.png "f(x) = 1")，则它是![ - 1](img/file312.png "- 1")。这样，我们说我们已经**标记**了满足我们感兴趣条件的元素，即那些![x](img/file269.png
    "x")元素，使得![f(x) = 1](img/file780.png "f(x) = 1")。值得注意的是，我们只通过一次调用![O_{f}](img/file791.png
    "O_{f}")就完成了这一点，利用了它在叠加中评估的可能性。这只是一个调用就进行了指数级数量的函数评估！这听起来像是魔法，不是吗？
- en: However, although after applying ![O_{f}](img/file791.png "O_{f}") we have somehow
    separated the elements ![x](img/file269.png "x") that satisfy ![f(x) = 1](img/file780.png
    "f(x) = 1") from the rest, we do not seem to be closer to finding one of them.
    If we measure the state as it is, the probability of measuring an ![x](img/file269.png
    "x") such that ![f(x) = 1](img/file780.png "f(x) = 1") is the same as it was before
    applying ![O_{f}](img/file791.png "O_{f}"). The phase that we have introduced
    has an absolute value equal to ![1](img/file13.png "1") and, consequently, does
    not affect the measurement probability.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管在应用![O_{f}](img/file791.png "O_{f}")之后，我们 somehow 将满足![f(x) = 1](img/file780.png
    "f(x) = 1")的元素![x](img/file269.png "x")与其他元素分离，但我们似乎并没有更接近找到其中之一。如果我们像现在这样测量状态，测量满足![f(x)
    = 1](img/file780.png "f(x) = 1")的![x](img/file269.png "x")的概率与应用![O_{f}](img/file791.png
    "O_{f}")之前相同。我们引入的相的绝对值等于![1](img/file13.png "1")，因此不会影响测量概率。
- en: 'But, wait! There is more to Grover’s algorithm. There is another circuit block
    that we apply after ![O_{f}](img/file791.png "O_{f}"): it’s called **Grover’s
    diffusion operator** and we will use it to increase the probability of measuring
    the marked states. Describing its inner workings in full detail would take us
    astray from our path — for that, we recommend checking out Dancing with Qubits
    [[92](ch030.xhtml#Xsutor2019dancing)], by Robert Sutor, which offers a perfect
    explanation of its behaviour — but let’s at least give a quick overview of what
    it does.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，等等！Grover算法还有更多内容。在应用![O_{f}](img/file791.png "O_{f}")之后，我们还有一个电路块要应用：它被称为**Grover的扩散算子**，我们将用它来增加测量标记状态的概率。详细描述其内部工作原理可能会让我们偏离正轨——为此，我们建议您阅读Robert
    Sutor的《与量子比特共舞》[[92](ch030.xhtml#Xsutor2019dancing)]，其中提供了对其行为的完美解释——但至少让我们快速概述一下它所做的工作。
- en: Grover’s diffusion operator implements an operation called **inversion about
    the** **mean**. This may sound complicated, but in fact it is quite simple. First,
    the average value ![m](img/file259.png "m") of all the amplitudes of the states
    is computed. Then, every amplitude ![a](img/file16.png "a") is replaced with ![2m
    - a](img/file820.png "2m - a"). After this transformation, the positive amplitudes
    will be a little bit smaller, but the negative ones will be a little bit bigger.
    This is why the technique used by Grover’s algorithm is called **amplitude amplification**.
    Again, we recommend you checking Sutor’s book [[92](ch030.xhtml#Xsutor2019dancing)]
    for a detailed description of how this operation works.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Grover的扩散算子实现了一个称为**关于平均值的反转**的操作。这可能听起来很复杂，但实际上相当简单。首先，计算所有状态振幅的平均值![m](img/file259.png
    "m")。然后，将每个振幅![a](img/file16.png "a")替换为![2m - a](img/file820.png "2m - a")。经过这种转换后，正振幅会稍微小一点，但负振幅会稍微大一点。这就是为什么Grover算法使用的技巧被称为**振幅放大**。再次建议您查阅Sutor的书籍[[92](ch030.xhtml#Xsutor2019dancing)]，以详细了解这种操作是如何工作的。
- en: So, after this first application of Grover’s diffusion operator, the amplitudes
    of the elements that we are interested in finding are a little bit larger. But,
    in general, this will still not be enough to guarantee a high probability of measuring
    one of them. For this reason, we will need to mark the elements again with ![O_{f}](img/file791.png
    "O_{f}") and then apply the diffusion operator once more. We will repeat this
    procedure, applying first ![O_{f}](img/file791.png "O_{f}") and then the diffusion
    operator, several times until the probability of measuring one of the states we
    are looking for is high enough (close to ![1](img/file13.png "1")). And that is
    the moment when we can measure the whole state and observe the result to, hopefully,
    obtain one element that satisfies the conditions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: But how many times should we apply ![O_{f}](img/file791.png "O_{f}") followed
    by the diffusion operator? This is a crucial point in Grover’s algorithm that
    we will study in more detail in the next subsection.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.3 Probability of finding a marked element
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have just seen, when using Grover’s algorithm, we are repeatedly applying
    for a certain number of times the quantum oracle given to us followed by the diffusion
    operator. Of course, we would like the number of repetitions to be as small as
    possible — so that the algorithm runs faster — while guaranteeing a high probability
    of finding one of the marked elements. How can we go about this?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: One possible approach in order to analyze the behaviour of Grover’s algorithm
    could be studying the properties of the inversion about the mean operation that
    we mentioned in the previous subsection. However, there is a better way. It turns
    out that the combination of ![O_{f}](img/file791.png "O_{f}") and Grover’s diffusion
    operator acts like a rotation in a two-dimensional space. We will not give the
    full details — check the lecture notes by John Watrous [[95](ch030.xhtml#Xwatrous2005quantum)]
    for a very thorough and readable explanation — but, if we have ![n](img/file244.png
    "n")-bit strings and there is only one marked element ![x_{1}](img/file712.png
    "x_{1}"), it can be proved that the state that we reach after ![m](img/file259.png
    "m") applications of ![O_{f}](img/file791.png "O_{f}") followed by the diffusion
    operator is
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![\cos(2m + 1)\theta\left| x_{0} \right\rangle + \sin(2m + 1)\theta\left| x_{1}
    \right\rangle,](img/file821.png "\cos(2m + 1)\theta\left| x_{0} \right\rangle
    + \sin(2m + 1)\theta\left| x_{1} \right\rangle,")'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: where
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| x_{0} \right\rangle = \sum\limits_{x \in {\{ 0,1\}}^{n},x \neq x_{1}}\sqrt{\frac{1}{2^{n}
    - 1}}\left| x \right\rangle](img/file822.png "\left| x_{0} \right\rangle = \sum\limits_{x
    \in {\{ 0,1\}}^{n},x \neq x_{1}}\sqrt{\frac{1}{2^{n} - 1}}\left| x \right\rangle")'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: and ![\left. \theta \in (0,\pi\slash 2) \right.](img/file823.png "\left. \theta
    \in (0,\pi\slash 2) \right.") is such that
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![\cos\theta = \sqrt{\frac{2^{n} - 1}{2^{n}}},\qquad\sin\theta = \sqrt{\frac{1}{2^{n}}}.](img/file824.png
    "\cos\theta = \sqrt{\frac{2^{n} - 1}{2^{n}}},\qquad\sin\theta = \sqrt{\frac{1}{2^{n}}}.")'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![\cos\theta = \sqrt{\frac{2^{n} - 1}{2^{n}}},\qquad\sin\theta = \sqrt{\frac{1}{2^{n}}}.](img/file824.png
    "\cos\theta = \sqrt{\frac{2^{n} - 1}{2^{n}}},\qquad\sin\theta = \sqrt{\frac{1}{2^{n}}}.")'
- en: Notice that ![\left| x_{0} \right\rangle](img/file825.png "\left| x_{0} \right\rangle")
    is just the uniform superposition of the states ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle") such that ![f(x) = 0](img/file783.png "f(x) = 0"). Then,
    what we want to obtain is a state in which ![\sin(2m + 1)\theta](img/file826.png
    "\sin(2m + 1)\theta") is close to ![1](img/file13.png "1"), because then we would
    have a high probability of finding ![x_{1}](img/file712.png "x_{1}") when we measure.
    For that, ideally, we would like to have
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，![\left| x_{0} \right\rangle](img/file825.png "\left| x_{0} \right\rangle")
    只是状态 ![ \left| x \right\rangle](img/file267.png "\left| x \right\rangle") 的均匀叠加，使得
    ![f(x) = 0](img/file783.png "f(x) = 0")。那么，我们想要获得的状态是 ![\sin(2m + 1)\theta](img/file826.png
    "\sin(2m + 1)\theta") 接近 ![1](img/file13.png "1")，因为这样在我们测量时会有很高的概率找到 ![x_{1}](img/file712.png
    "x_{1}")。为此，理想情况下，我们希望有
- en: '![(2m + 1)\theta \approx \frac{\pi}{2},](img/file827.png "(2m + 1)\theta \approx
    \frac{\pi}{2},")'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![(2m + 1)\theta \approx \frac{\pi}{2},](img/file827.png "(2m + 1)\theta \approx
    \frac{\pi}{2},")'
- en: because ![\left. \sin\pi\slash 2 = 1 \right.](img/file828.png "\left. \sin\pi\slash
    2 = 1 \right.").
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ![\left. \sin\pi\slash 2 = 1 \right.](img/file828.png "\left. \sin\pi\slash
    2 = 1 \right.")。
- en: Solving for ![m](img/file259.png "m"), we obtain
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 解出 ![m](img/file259.png "m")，我们得到
- en: '![m \approx \frac{\pi}{4\theta} - \frac{1}{2}.](img/file829.png "m \approx
    \frac{\pi}{4\theta} - \frac{1}{2}.")'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![m \approx \frac{\pi}{4\theta} - \frac{1}{2}.](img/file829.png "m \approx
    \frac{\pi}{4\theta} - \frac{1}{2}.")'
- en: What is more, we know that ![\sin\theta = \sqrt{\left. 1\slash 2^{n} \right.}](img/file830.png
    "\sin\theta = \sqrt{\left. 1\slash 2^{n} \right.}"), so, for a big enough ![n](img/file244.png
    "n"), we will have
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们知道 ![\sin\theta = \sqrt{\left. 1\slash 2^{n} \right.}](img/file830.png
    "\sin\theta = \sqrt{\left. 1\slash 2^{n} \right.}"), 因此，对于足够大的 ![n](img/file244.png
    "n")，我们将有
- en: '![\theta \approx \sqrt{\frac{1}{2^{n}}}](img/file831.png "\theta \approx \sqrt{\frac{1}{2^{n}}}")'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![\theta \approx \sqrt{\frac{1}{2^{n}}}] (img/file831.png "\theta \approx \sqrt{\frac{1}{2^{n}}}
    ")'
- en: and then we can choose
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以选择
- en: '![m = \left\lfloor {\frac{\pi}{4}\sqrt{2^{n}}} \right\rfloor,](img/file832.png
    "m = \left\lfloor {\frac{\pi}{4}\sqrt{2^{n}}} \right\rfloor,")'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![m = \left\lfloor {\frac{\pi}{4}\sqrt{2^{n}}} \right\rfloor,](img/file832.png
    "m = \left\lfloor {\frac{\pi}{4}\sqrt{2^{n}}} \right\rfloor,")'
- en: that is, the biggest integer that is less than or equal to ![\left. (\pi\slash
    4)\sqrt{2^{n}} \right.](img/file833.png "\left. (\pi\slash 4)\sqrt{2^{n}} \right.").
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 即小于或等于 ![\left. (\pi\slash 4)\sqrt{2^{n}} \right.](img/file833.png "\left. (\pi\slash
    4)\sqrt{2^{n}} \right.") 的最大整数。
- en: Notice that there are exactly ![2^{n}](img/file256.png "2^{n}") elements but
    only one of them satisfies the conditions we are interested in. This means that,
    with a classical algorithm, if we can only use ![f](img/file778.png "f") to check
    if an element ![x](img/file269.png "x") is the one we are looking for — that is,
    to check if ![f(x) = 1](img/file780.png "f(x) = 1") — then we would need about
    ![\left. 2^{n}\slash 2 \right.](img/file834.png "\left. 2^{n}\slash 2 \right.")
    calls to ![f](img/file778.png "f") on average to find ![x](img/file269.png "x").
    However, with Grover’s algorithm, we only need about ![\sqrt{2^{n}}](img/file835.png
    "\sqrt{2^{n}}"). That is a quadratic speedup!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，恰好有 ![2^{n}](img/file256.png "2^{n}") 个元素，但其中只有一个满足我们感兴趣的条件。这意味着，使用经典算法，如果我们只能使用
    ![f](img/file778.png "f") 来检查元素 ![x](img/file269.png "x") 是否是我们正在寻找的——即检查 ![f(x)
    = 1](img/file780.png "f(x) = 1") ——那么我们平均需要大约 ![\left. 2^{n}\slash 2 \right.](img/file834.png
    "\left. 2^{n}\slash 2 \right.") 次调用 ![f](img/file778.png "f") 才能找到 ![x](img/file269.png
    "x")。然而，使用Grover算法，我们只需要大约 ![\sqrt{2^{n}}](img/file835.png "\sqrt{2^{n}}")。这是一个平方速度提升！
- en: Nevertheless, there is a subtlety here. In the classical setting, if we use
    ![f](img/file778.png "f") more times, the probability of finding the marked element
    increases. But with Grover’s algorithm, if ![m](img/file259.png "m") is not selected
    wisely, we can overshoot and actually decrease the success probability instead
    of increasing it!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个微妙之处。在经典设置中，如果我们多次使用 ![f](img/file778.png "f")，找到标记元素的几率会增加。但是，使用Grover算法，如果
    ![m](img/file259.png "m") 没有被明智地选择，我们可能会超过目标，实际上降低成功几率而不是提高它！
- en: This sounds baffling. How is it possible that by searching more we find ourselves
    with less possibilities of finding the hidden element? The key is that, as we
    have shown, the probability of measuring ![x_{1}](img/file712.png "x_{1}") is
    ![{(\sin(2m + 1)\theta)}^{2}](img/file836.png "{(\sin(2m + 1)\theta)}^{2}"). This
    function is periodic and oscillates between ![0](img/file12.png "0") and ![1](img/file13.png
    "1"), so after reaching values close to ![1](img/file13.png "1"), it goes back
    down to ![0](img/file12.png "0").
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来令人困惑。我们如何通过搜索更多反而发现自己找到隐藏元素的可能性更小了呢？关键在于，正如我们所展示的，测量![x_{1}](img/file712.png
    "x_{1}")的概率是![{(\sin(2m + 1)\theta)}^{2}](img/file836.png "{(\sin(2m + 1)\theta)}^{2}").
    这个函数是周期性的，在![0](img/file12.png "0")和![1](img/file13.png "1")之间振荡，所以当达到接近![1](img/file13.png
    "1")的值后，它会回到![0](img/file12.png "0")。
- en: Let’s illustrate this with an example. In *Figure* *[*6.3*](#Figure6.3), we
    consider the case ![n = 4](img/file837.png "n = 4") and we show how the probability
    of finding exactly one marked element changes as we vary the number of Grover
    iterations ![m](img/file259.png "m"), from ![0](img/file12.png "0") to ![20](img/file588.png
    "20"). In this case, ![\left. \lfloor(\pi\slash 4)\sqrt{2^{n}}\rfloor \right.](img/file838.png
    "\left. \lfloor(\pi\slash 4)\sqrt{2^{n}}\rfloor \right.") is ![3](img/file472.png
    "3") and, as you can see, the success probability with ![m = 3](img/file839.png
    "m = 3") is close to ![1](img/file13.png "1"). However, for ![m = 5](img/file840.png
    "m = 5") the probability has decreased dramatically, and for ![m = 6](img/file841.png
    "m = 6") it is nearly ![0](img/file12.png "0").*
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明这一点。在*图* *[*6.3*](#Figure6.3)中，我们考虑![n = 4](img/file837.png "n =
    4")的情况，并展示当我们改变Grover迭代的次数![m](img/file259.png "m")，从![0](img/file12.png "0")到![20](img/file588.png
    "20")时，找到恰好一个标记元素的概率是如何变化的。在这种情况下，![\left. \lfloor(\pi\slash 4)\sqrt{2^{n}}\rfloor
    \right.](img/file838.png "\left. \lfloor(\pi\slash 4)\sqrt{2^{n}}\rfloor \right.")是![3](img/file472.png
    "3")，并且正如你所看到的，当![m = 3](img/file839.png "m = 3")时，成功概率接近![1](img/file13.png "1")。然而，对于![m
    = 5](img/file840.png "m = 5")，概率急剧下降，对于![m = 6](img/file841.png "m = 6")，它几乎接近![0](img/file12.png
    "0")。
- en: '*![Figure 6.3: Probability of finding one marked element among 16 when using
    Grover’s algorithm with a number of iterations that varies from 0 to 20](img/file842.png)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*![图6.3：使用Grover算法且迭代次数从0到20变化时，在16个元素中找到单个标记元素的概率](img/file842.png)*'
- en: '**Figure 6.3**: Probability of finding one marked element among 16 when using
    Grover’s algorithm with a number of iterations that varies from ![0](img/file12.png
    "0") to ![20](img/file588.png "20")'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6.3**：使用Grover算法且迭代次数从![0](img/file12.png "0")到![20](img/file588.png "20")变化时，在16个元素中找到单个标记元素的概率'
- en: This shows that we need to be very careful when selecting the number of iterations
    ![m](img/file259.png "m") in Grover’s algorithm. For the case in which there is
    only one marked element, we have obtained a good choice for ![m](img/file259.png
    "m"). But what if there is more than one marked element? It turns out — check
    the lecture notes by John Watrous [[95](ch030.xhtml#Xwatrous2005quantum)] — that
    if there are ![k](img/file317.png "k") marked elements, we can repeat our previous
    reasoning and show that a good value for ![m](img/file259.png "m") is
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明在选择Grover算法中的迭代次数![m](img/file259.png "m")时，我们需要非常小心。对于只有一个标记元素的情况，我们已经为![m](img/file259.png
    "m")找到了一个不错的选择。但是，如果有多个标记元素呢？结果——请参阅John Watrous的讲义[[95](ch030.xhtml#Xwatrous2005quantum)]——如果存在![k](img/file317.png
    "k")个标记元素，我们可以重复之前的推理，并表明一个合适的![m](img/file259.png "m")值是
- en: '![m = \left\lfloor {\frac{\pi}{4}\sqrt{\frac{2^{n}}{k}}} \right\rfloor,](img/file843.png
    "m = \left\lfloor {\frac{\pi}{4}\sqrt{\frac{2^{n}}{k}}} \right\rfloor,")'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![m = \left\lfloor {\frac{\pi}{4}\sqrt{\frac{2^{n}}{k}}} \right\rfloor,](img/file843.png
    "m = \left\lfloor {\frac{\pi}{4}\sqrt{\frac{2^{n}}{k}}} \right\rfloor,")'
- en: provided that ![k](img/file317.png "k") is small compared to ![2^{n}](img/file256.png
    "2^{n}"). If ![k](img/file317.png "k") is not small compared to ![2^{n}](img/file256.png
    "2^{n}"), don’t worry; then the probability of finding a marked element just by
    choosing at random is ![\left. k\slash 2^{n} \right.](img/file844.png "\left.
    k\slash 2^{n} \right."), which will be sizeable, so you wouldn’t even need a quantum
    computer in the first place.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在![k](img/file317.png "k")相对于![2^{n}](img/file256.png "2^{n}")较小的情况下。如果![k](img/file317.png
    "k")相对于![2^{n}](img/file256.png "2^{n}")不是较小，请不要担心；那么随机选择找到标记元素的概率是![\left. k\slash
    2^{n} \right.](img/file844.png "\left. k\slash 2^{n} \right."), 这将是相当大的，所以你甚至一开始就根本不需要量子计算机。
- en: This solves our problem if we know how many marked elements there are. But,
    in the most general case, we may lack that information. In that circumstance,
    we can apply the results of a very useful paper by Boyer, Brassard, Høyer, and
    Tapp [[20](ch030.xhtml#Xboyer1998tight)]. They showed that by choosing ![m](img/file259.png
    "m") at random in a range that increases dynamically, we can still be guaranteed
    that will find a marked element with high probability while keeping the average
    number of iterations as ![O(\sqrt{2^{n}})](img/file845.png "O(\sqrt{2^{n}})")
    (see *Appendix* * [*C*](ch026.xhtml#x1-233000C)*, Computational Complexity*, for
    a refresher on asymptotic notation).*
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道有多少标记元素，这就能解决我们的问题。但在最一般的情况下，我们可能缺乏这方面的信息。在这种情况下，我们可以应用Boyer、Brassard、Høyer和Tapp发表的一篇非常有用的论文的结果[[20](ch030.xhtml#Xboyer1998tight)]。他们证明了通过在动态增加的范围内随机选择![m](img/file259.png
    "m")，我们仍然可以保证以高概率找到标记元素，同时保持平均迭代次数为![O(\sqrt{2^{n}})](img/file845.png "O(\sqrt{2^{n}})")（有关渐近记号的复习，请参阅*附录*
    * [*C*](ch026.xhtml#x1-233000C)*，计算复杂性）。*
- en: '*In fact, they proved that the probability of finding a marked element with
    their method is at least ![\left. 1\slash 4 \right.](img/file846.png "\left. 1\slash
    4 \right."). This might seem unimpressive, but we can easily see how that is more
    than enough. Indeed, the probability of not finding a marked element is then no
    more than ![\left. 3\slash 4 \right.](img/file847.png "\left. 3\slash 4 \right.").
    So, suppose that we repeat the process ![1000](img/file790.png "1000") times.
    Then, the probability of failure is at most ![\left. (3\slash 4) \right.^{1000}](img/file848.png
    "\left. (3\slash 4) \right.^{1000}"), which is extremely low. In fact, the chance
    of a meteorite hitting your quantum computer while running your circuits is much,
    much bigger than that!'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*事实上，他们证明了使用他们的方法找到标记元素的概率至少是 ![\left. 1\slash 4 \right.](img/file846.png "\left.
    1\slash 4 \right.")。这看起来可能并不令人印象深刻，但我们很容易看出这已经足够多了。实际上，找不到标记元素的概率不会超过 ![\left.
    3\slash 4 \right.](img/file847.png "\left. 3\slash 4 \right.")。因此，假设我们重复这个过程 ![1000](img/file790.png
    "1000") 次。那么，失败的概率最多是 ![\left. (3\slash 4) \right.^{1000}](img/file848.png "\left.
    (3\slash 4) \right.^{1000}")，这非常低。实际上，一颗陨石在运行你的电路时撞击你的量子计算机的概率比这要大得多！*'
- en: So far in this section, we have covered all that we need to know in order to
    apply Grover’s algorithm in search problems. However, our main goal is solving
    optimization problems. We explore the connection between both tasks in the next
    subsection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本节中，我们已经涵盖了应用Grover算法解决搜索问题所需的所有知识。然而，我们的主要目标是解决优化问题。我们将在下一小节中探讨这两个任务之间的联系。
- en: 6.1.4 Finding minima with Grover’s algorithm
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1.4 使用Grover算法寻找最小值
- en: 'Optimization problems are obviously related to search problems. In fact, when
    solving an optimization problem, we are trying to find a value with a special
    property: it should be a minimum or maximum among all the possible values. This
    connection was exploited by Dürr and Høyer in a 1996 paper [[33](ch030.xhtml#Xdurr1996quantum)]
    in which they introduced a quantum algorithm, based on Grover’s search, to find
    minima of functions. The main idea behind the algorithm is quite straightforward.
    Suppose we want to find a minimum of a function ![g](img/file849.png "g") that
    is computed over binary strings of length ![n](img/file244.png "n"). We select
    one such string ![x_{0}](img/file443.png "x_{0}") at random and we compute ![g(x_{0})](img/file850.png
    "g(x_{0})"). Now we apply Grover’s algorithm with an oracle that, on input ![x](img/file269.png
    "x"), returns ![1](img/file13.png "1") if ![g(x) < g(x_{0})](img/file851.png "g(x)
    < g(x_{0})") and ![0](img/file12.png "0") otherwise. If the element that we measure
    after applying Grover’s search, call it ![x_{1}](img/file712.png "x_{1}"), really
    achieves a value that is lower than ![g(x_{0})](img/file850.png "g(x_{0})"), we
    replace ![x_{0}](img/file443.png "x_{0}") with it and repeat the process but now
    with an oracle that checks the condition ![g(x) < g(x_{1})](img/file852.png "g(x)
    < g(x_{1})"). If not, we keep using ![x_{0}](img/file443.png "x_{0}"). We repeat
    this process several times and we return the element with the lowest value among
    the ones that we have considered.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 优化问题显然与搜索问题相关。事实上，在解决优化问题时，我们试图找到一个具有特殊属性的值：它应该是所有可能值中的最小值或最大值。Dürr和Høyer在1996年的一篇论文[[33](ch030.xhtml#Xdurr1996quantum)]中利用了这种联系，他们介绍了一种基于Grover搜索的量子算法，用于寻找函数的最小值。算法背后的主要思想相当简单。假设我们想要找到一个长度为![n](img/file244.png
    "n")的二进制字符串上的函数![g](img/file849.png "g")的最小值。我们随机选择这样一个字符串![x_{0}](img/file443.png
    "x_{0}")并计算![g(x_{0})](img/file850.png "g(x_{0})")。现在我们应用Grover算法，其中oracles在输入![x](img/file269.png
    "x")时，如果![g(x) < g(x_{0})](img/file851.png "g(x) < g(x_{0})")则返回![1](img/file13.png
    "1")，否则返回![0](img/file12.png "0")。如果我们测量应用Grover搜索后的元素，称之为![x_{1}](img/file712.png
    "x_{1}")，并且它确实达到了比![g(x_{0})](img/file850.png "g(x_{0})")更低的值，我们就用它替换![x_{0}](img/file443.png
    "x_{0}")并重复这个过程，但现在使用检查条件![g(x) < g(x_{1})](img/file852.png "g(x) < g(x_{1})")的oracles。如果不是，我们继续使用![x_{0}](img/file443.png
    "x_{0}").我们重复这个过程几次，并返回我们考虑过的元素中值最低的元素。
- en: There are a couple of details that we need to flesh out here. The first one
    is how to construct the oracles. In general, of course, it will depend on the
    function ![g](img/file849.png "g"). For that reason, in the next section we will
    focus on circuits that we can use with the Dürr-Høyer algorithm to solve QUBO
    and HOBO problems.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要详细说明几个细节。第一个是如何构建oracles。当然，一般来说，这取决于函数![g](img/file849.png "g")。因此，在下一节中，我们将重点关注可以使用Dürr-Høyer算法解决QUBO和HOBO问题的电路。
- en: On the other hand, we should take care of the number of iterations that we will
    use in each application of Grover’s algorithm and, also, of the number of times
    that we need to repeat the procedure for selecting a new element and constructing
    a new oracle. The original paper by Dürr and Høyer gives all the details, but
    let’s just mention that it uses the method proposed by Boyer, Brassard, Høyer,
    and Tapp [[20](ch030.xhtml#Xboyer1998tight)] that we explained in the previous
    subsection, and it guarantees that a minimum will be found with a probability
    of at least ![\left. 1\slash 2 \right.](img/file136.png "\left. 1\slash 2 \right.")
    with a number of calls to the oracle that is ![O(\sqrt{2^{n}})](img/file845.png
    "O(\sqrt{2^{n}})").
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们应该注意在每次应用Grover算法时使用的迭代次数，以及我们需要重复选择新元素和构建新oracles的次数。Dürr和Høyer的原始论文提供了所有细节，但让我们只提一下，它使用了Boyer、Brassard、Høyer和Tapp提出的方法[[20](ch030.xhtml#Xboyer1998tight)]，我们在前面的子节中已经解释过，并且它保证了至少以![\left.
    1\slash 2 \right.](img/file136.png "\left. 1\slash 2 \right.")的概率找到最小值，所需的oracles调用次数为![O(\sqrt{2^{n}})](img/file845.png
    "O(\sqrt{2^{n}})").
- en: With this, we have now covered all the concepts that we need in order to apply
    this search method to solve QUBO and HOBO problems. We will devote the next section
    to explaining how to construct quantum oracles for these kinds of problems.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们现在已经涵盖了应用这种搜索方法解决QUBO和HOBO问题所需的所有概念。在下一节中，我们将解释如何为这类问题构建量子oracles。
- en: 6.2 Quantum oracles for combinatorial optimization
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.2 组合优化的量子或acles
- en: As we have seen, the Dürr-Høyer algorithm can be used to find the minimum of
    a function ![g](img/file849.png "g") with high probability and with a quadratic
    speedup over brute force search. However, in order to use it, we need a quantum
    oracle that, given binary strings ![x](img/file269.png "x") and ![y](img/file270.png
    "y"), checks whether ![g(x) < g(y)](img/file853.png "g(x) < g(y)").
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Dürr-Høyer算法可以用以以高概率找到函数![g](img/file849.png "g")的最小值，并且比暴力搜索有二次加速。然而，为了使用它，我们需要一个量子或然，该或然在给定二进制字符串![x](img/file269.png
    "x")和![y](img/file270.png "y")的情况下，检查![g(x) < g(y)](img/file853.png "g(x) < g(y)")是否成立。
- en: 'In our case, we are interested in functions ![g](img/file849.png "g") that
    can appear in QUBO and HOBO problems. This means that ![g](img/file849.png "g")
    will be a polynomial with real coefficients and binary variables, and we could
    implement the quantum oracle with a straightforward approach: design a classical
    circuit for it using AND, OR, and NOT gates, and then simulate the classical gates
    with the Toffoli quantum gate, as we showed in *Section* * [*1.5.2*](ch008.xhtml#x1-370001.5.2).*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们对可以出现在QUBO和HOBO问题中的函数![g](img/file849.png "g")感兴趣。这意味着![g](img/file849.png
    "g")将是一个具有实系数和二进制变量的多项式，我们可以通过直接的方法实现量子或然：设计一个使用AND、OR和NOT门的经典电路，然后使用我们在*第1.5.2节*
    [[ch008.xhtml#x1-370001.5.2]]中展示的Toffoli量子门来模拟经典门。
- en: '*However, in 2021, Gilliam, Woerner, and Gonciulea, introduced an improved
    way of implementing quantum oracles for QUBO and HOBO problems in a paper titled
    *Grover adaptive search for constrained polynomial binary* *optimization* [[45](ch030.xhtml#Xgilliam2021grover)].'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*然而，在2021年，Gilliam、Woerner和Gonciulea在一篇题为*“Grover自适应搜索用于约束多项式二进制**优化**”*的论文中介绍了一种改进的量子或然实现量子QUBO和HOBO问题的方法
    [[45](ch030.xhtml#Xgilliam2021grover)]。'
- en: 'In this section, we will study in detail the techniques that they proposed
    and how to use them to implement our quantum oracles. We will start by considering
    the case in which all the coefficients of the polynomial are integer numbers and,
    then, we will extend our study to the most general case when the coefficients
    are real numbers. But, before we get to that, we need to take a brief detour to
    talk about one of the most important subroutines in all of quantum computing:
    the **quantum Fourier** **transform**.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细研究他们提出的技巧以及如何使用它们来实现我们的量子或然。我们将首先考虑多项式的所有系数都是整数的情况，然后我们将扩展我们的研究到系数为实数的最一般情况。但在我们到达那里之前，我们需要简要地谈谈量子计算中最重要的子程序之一：**量子傅里叶**
    **变换**。
- en: 6.2.1 The quantum Fourier transform
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2.1 量子傅里叶变换
- en: The quantum Fourier transform (usually abbreviated as **QFT**) is, beyond any
    doubt, one of the most useful tools in quantum computing. It is an essential part
    of Shor’s algorithm for integer factorization [[87](ch030.xhtml#Xshor99polynomial)]
    and it is behind the speedups of other famous quantum algorithms such as HHL [[49](ch030.xhtml#Xharrow2009quantum)].
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 量子傅里叶变换（通常简称为**QFT**）毫无疑问是量子计算中最有用的工具之一。它是Shor算法进行整数分解的必要部分 [[87](ch030.xhtml#Xshor99polynomial)]，也是其他著名量子算法（如HHL
    [[49](ch030.xhtml#Xharrow2009quantum)]）加速背后的原因。
- en: We will use the QFT to help us implement the arithmetical operations that we
    need to compute the values of the polynomial function of our QUBO and HOBO problems.
    We could, for instance, implement these operations in a basis representation.
    As an example, we might design a unitary transformation taking ![\left| x \right\rangle\left|
    y \right\rangle\left| 0 \right\rangle](img/file854.png "\left| x \right\rangle\left|
    y \right\rangle\left| 0 \right\rangle") to ![\left| x \right\rangle\left| y \right\rangle\left|
    {x + y} \right\rangle](img/file855.png "\left| x \right\rangle\left| y \right\rangle\left|
    {x + y} \right\rangle"), where ![x](img/file269.png "x") and ![y](img/file270.png
    "y") are binary numbers and ![x + y](img/file856.png "x + y") is their addition.
    However, this could involve a big number of one- and two-qubit gates.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用QFT来帮助我们实现所需的算术运算，以便计算QUBO和HOBO问题的多项式函数的值。例如，我们可以在基表示中实现这些运算。作为一个例子，我们可能会设计一个幺正变换，将![\left|
    x \right\rangle\left| y \right\rangle\left| 0 \right\rangle](img/file854.png "\left|
    x \right\rangle\left| y \right\rangle\left| 0 \right\rangle")变换为![\left| x \right\rangle\left|
    y \right\rangle\left| {x + y} \right\rangle](img/file855.png "\left| x \right\rangle\left|
    y \right\rangle\left| {x + y} \right\rangle")，其中![x](img/file269.png "x")和![y](img/file270.png
    "y")是二进制数，而![x + y](img/file856.png "x + y")是它们的和。然而，这可能会涉及到大量的单比特和双比特门。
- en: Instead, we will use the approach proposed by Gilliam, Woerner, and Gonciulea
    in [[45](ch030.xhtml#Xgilliam2021grover)] and we will compute the arithmetical
    operations using the state amplitudes. We will explain in detail how to do that
    in the next subsections. But, before that, we will study how to use the QFT to
    recover information from the amplitudes of a quantum state.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用Gilliam、Woerner和Gonciulea在[[45](ch030.xhtml#Xgilliam2021grover)]中提出的方法，并使用状态振幅来计算算术运算。我们将在下一小节中详细解释如何做到这一点。但在那之前，我们将研究如何使用QFT从量子状态振幅中恢复信息。
- en: The QFT on ![m](img/file259.png "m") qubits is defined as the unitary transformation
    that takes the basis states ![\left| j \right\rangle](img/file257.png "\left|
    j \right\rangle") to
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在![m](img/file259.png "m")个量子比特上的QFT定义为将基态![\left| j \right\rangle](img/file257.png
    "\left| j \right\rangle")变换为
- en: '![\frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m} - 1}e^{\frac{2\pi ijk}{2^{m}}}\left|
    k \right\rangle,](img/file857.png "\frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m}
    - 1}e^{\frac{2\pi ijk}{2^{m}}}\left| k \right\rangle,")'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![\frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m} - 1}e^{\frac{2\pi ijk}{2^{m}}}\left|
    k \right\rangle,](img/file857.png "\frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m}
    - 1}e^{\frac{2\pi ijk}{2^{m}}}\left| k \right\rangle,")'
- en: where ![i](img/file49.png "i") is the imaginary unit. Its action is extended
    to the rest of the states by linearity.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![i](img/file49.png "i")是虚数单位。其作用通过线性扩展到其他状态。
- en: We will not study the properties of the QFT in detail. For that, you can refer
    to *Dancing with Qubits*, by Robert Sutor [[92](ch030.xhtml#Xsutor2019dancing)].
    However, we need to know that the QFT can be implemented with a number of one-
    and two-qubit gates that is quadratic in ![m](img/file259.png "m"). This is an
    exponential speedup over the best algorithm that we have for the analogous classical
    operation (the **discrete Fourier transform**).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会详细研究QFT的性质。为此，你可以参考Robert Sutor的《与量子比特共舞》[[92](ch030.xhtml#Xsutor2019dancing)]。然而，我们需要知道QFT可以用数量为![m](img/file259.png
    "m")的平方的单一和双量子比特门来实现。这比我们目前最好的类似经典操作（**离散傅里叶变换**）的算法要快指数级。
- en: For example, the circuit for the QFT on three qubits is shown in *Figure* *[*6.4*](#Figure6.4).
    In it, the rightmost gate, which acts on the top and bottom qubits, is the SWAP
    gate. As we mentioned in *Section* *[*1.4.3*](ch008.xhtml#x1-300001.4.3), this
    gate swaps the states of two qubits and it can be implemented by means of CNOT
    gates. Moreover, this QFT circuit uses the **phase gate**, denoted by ![P(\theta)](img/file858.png
    "P(\theta)"). This is a parametrized gate that depends on an angle ![\theta](img/file89.png
    "\theta") and whose coordinate matrix is**
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，三个量子比特上的QFT电路如图*6.4*所示。在这个电路中，最右侧的门作用于顶部和底部的量子比特，是SWAP门。正如我们在*第1.4.3节*中提到的，这个门交换两个量子比特的状态，可以通过CNOT门实现。此外，这个QFT电路使用了**相位门**，表示为![P(\theta)](img/file858.png
    "P(\theta)")。这是一个依赖于角度![\theta](img/file89.png "\theta")的参数化门，其坐标矩阵为**
- en: '**![\begin{pmatrix} 1 & 0 \\ 0 & e^{i\theta} \\ \end{pmatrix}.](img/file859.png
    "\begin{pmatrix} 1 & 0 \\ 0 & e^{i\theta} \\ \end{pmatrix}.")'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**![\begin{pmatrix} 1 & 0 \\ 0 & e^{i\theta} \\ \end{pmatrix}.](img/file859.png
    "\begin{pmatrix} 1 & 0 \\ 0 & e^{i\theta} \\ \end{pmatrix}.")**'
- en: '![Figure 6.4: Circuit for the quantum Fourier transform on 3 qubits](img/file860.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4：3个量子比特上的量子傅里叶变换电路](img/file860.jpg)'
- en: '**Figure 6.4**: Circuit for the quantum Fourier transform on ![3](img/file472.png
    "3") qubits'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6.4**：3个量子比特上的量子傅里叶变换电路'
- en: Important note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The phase gate is very similar to the ![R_{Z}](img/file120.png "R_{Z}") gate
    that we introduced in *Section* * [*1.3.4*](ch008.xhtml#x1-250001.3.4). In fact,
    when applied on its own to a qubit, ![P(\theta)](img/file858.png "P(\theta)")
    is equivalent to ![R_{Z}(\theta)](img/file861.png "R_{Z}(\theta)") up to an unimportant
    global phase. However, in the QFT circuit, we are using a controlled version of
    the phase gate and the global phase becomes a relative one, which is not unimportant
    at all!*
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 相位门与我们之前在*第1.3.4节*中介绍的![R_{Z}](img/file120.png "R_{Z}")门非常相似。事实上，当单独应用于一个量子比特时，![P(\theta)](img/file858.png
    "P(\theta)")相当于![R_{Z}(\theta)](img/file861.png "R_{Z}(\theta)")，直到一个不重要的全局相位。然而，在量子场论电路中，我们使用的是相位门的受控版本，全局相位变成了相对相位，这绝对不是不重要的！
- en: '*As we have seen, the QFT acts by introducing phases of the form ![e^{2\pi
    ijk \slash 2^{m}}](img/file862.png "e^{2\pi ijk \slash 2^{m}}") when it is applied
    on basis states ![\left| j \right\rangle](img/file257.png "\left| j \right\rangle").
    Nevertheless, for the purposes of our computations, we are more interested in
    recovering the values ![j](img/file258.png "j") from those phases. For that, we
    will need the **inverse quantum Fourier transform**, usually denoted QFT![{}^{\dagger}](img/file863.png
    "{}^{\dagger}"). Of course, its action is the inverse of that of the QFT, meaning
    that it takes a state such as'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![\frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m} - 1}e^{\frac{2\pi ijk}{2^{m}}}\left|
    k \right\rangle](img/file864.png "\frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m}
    - 1}e^{\frac{2\pi ijk}{2^{m}}}\left| k \right\rangle")'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: to the basis state ![\left| j \right\rangle](img/file257.png "\left| j \right\rangle").
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The circuit for the inverse QFT can be obtained from that of the QFT by reading
    the circuit backwards and using the inverse of each gate we find. For example,
    the circuit for the inverse QFT on ![3](img/file472.png "3") qubits is shown in
    *Figure* * [*6.5*](#Figure6.5). Notice that the inverse of ![P(\theta)](img/file858.png
    "P(\theta)") is ![P( - \theta)](img/file865.png "P( - \theta)"), while the ![H](img/file10.png
    "H") and SWAP gates are their own inverses.*
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 6.5: Circuit for the inverse quantum Fourier transform on 3 qubits](img/file866.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 6.5**: Circuit for the inverse quantum Fourier transform on ![3](img/file472.png
    "3") qubits'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: When designing a quantum oracle to minimize a function ![g](img/file849.png
    "g"), our goal will be to perform the computation in such a way that the ![g(x)](img/file867.png
    "g(x)") values appear as exponents in the amplitudes of our states so that we
    can later recover them by means of the inverse QFT. This may sound like a difficult
    endeavour, but as we will show in the following subsections, we already have all
    the tools that we need in order to succeed. We will start by showing how to encode
    integer values in exactly the way that we require.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2 Encoding and adding integer numbers
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As will become apparent soon in this section, the most convenient way of working
    with integer numbers in the context of GAS oracles is using their **two’s complement**
    representation. In it, we can encode numbers from ![- 2^{m - 1}](img/file868.png
    "- 2^{m - 1}") to ![2^{m - 1} - 1](img/file869.png "2^{m - 1} - 1") by using ![m](img/file259.png
    "m")-bit strings. Positive numbers are represented in the usual way for binary
    numbers, but a negative number ![x](img/file269.png "x") is represented by ![2^{m}
    - x](img/file870.png "2^{m} - x").
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if ![m = 4](img/file871.png "m = 4"), we represent ![3](img/file472.png
    "3") by ![0011](img/file872.png "0011"), and ![- 5](img/file591.png "- 5") by
    ![1011](img/file606.png "1011") (which is the binary representation of ![11 =
    16 - 5](img/file873.png "11 = 16 - 5")). One advantage of this representation
    is that the most significant bit indicates the sign of the encoded number: positive
    numbers always start with ![0](img/file12.png "0"), while negative numbers start
    with ![1](img/file13.png "1").'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Another perk of two’s complement representation is that, with it, we can compute
    additions involving both positive and negative numbers by simply performing regular
    binary addition and discarding the last carry-out, if it exists. For instance,
    if we add ![0011](img/file872.png "0011") (which is ![3](img/file472.png "3"))
    and ![1011](img/file606.png "1011") (which is ![- 5](img/file591.png "- 5")),
    we obtain ![1110](img/file806.png "1110") which is, indeed, the encoding of ![-
    2](img/file333.png "- 2") (because ![14 = 16 - 2](img/file874.png "14 = 16 - 2")).
    Similarly, if we add ![0110](img/file875.png "0110") (which is ![6](img/file576.png
    "6")) and ![1100](img/file876.png "1100") (which is ![- 4](img/file330.png "-
    4")) we obtain ![0010](img/file877.png "0010") (after discarding the last carry-out),
    which is ![2](img/file302.png "2"), as expected. These facts about two’s complement
    arithmetic will be very helpful in implementing our quantum oracle, as we show
    next.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.3
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Using two’s complement with 5 qubits, represent ![10](img/file161.png "10")
    and ![- 7](img/file470.png "- 7") and perform their addition.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: As we have mentioned in the previous subsection, when computing ![g(x)](img/file867.png
    "g(x)") with an oracle, we are interested in obtaining the state
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![\frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m} - 1}e^{\frac{2\pi ig(x)k}{2^{m}}}\left|
    k \right\rangle](img/file878.png "\frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m}
    - 1}e^{\frac{2\pi ig(x)k}{2^{m}}}\left| k \right\rangle")'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: so that we can then apply the inverse QFT to get ![\left| {g(x)} \right\rangle](img/file879.png
    "\left| {g(x)} \right\rangle"). We will achieve this step by step.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Notice that ![g(x)](img/file867.png "g(x)") is always a sum of products of integer
    values. So, let’s first deal with integer addition, and leave multiplication for
    the next subsection.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Following the notation of [[82](ch030.xhtml#Xruiz2017quantum)], we will call
    the state
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![\frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m} - 1}e^{\frac{2\pi ijk}{2^{m}}}\left|
    k \right\rangle](img/file864.png "\frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m}
    - 1}e^{\frac{2\pi ijk}{2^{m}}}\left| k \right\rangle")'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: the **phase encoding** of ![j](img/file258.png "j"). Then, for our purposes,
    it is enough to be able to know how to prepare the phase encoding of ![0](img/file12.png
    "0") and to know how to add a given integer ![l](img/file514.png "l") to the phase
    encoding of any other integer. In that way, we can start from ![0](img/file12.png
    "0") and add all the terms in the polynomial expression of ![g](img/file849.png
    "g") one by one.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the phase encoding of ![0](img/file12.png "0") could not be easier.
    We just need to apply the Hadamard gate to each and every qubit that we are using
    to represent the integer values. In this way, we will obtain the state
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![\frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m} - 1}\left| k \right\rangle
    = \frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m} - 1}e^{\frac{2\pi i0k}{2^{m}}}\left|
    k \right\rangle,](img/file880.png "\frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m}
    - 1}\left| k \right\rangle = \frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m}
    - 1}e^{\frac{2\pi i0k}{2^{m}}}\left| k \right\rangle,")'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: which is, indeed, the phase encoding of ![0](img/file12.png "0").
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Suppose now that we have a state that phase-encodes ![j](img/file258.png "j")
    and we want to add ![l](img/file514.png "l") to it. We first assume that ![l](img/file514.png
    "l") is non-negative and, later, we will deal with negative numbers. To add ![l](img/file514.png
    "l") in phase encoding, we just need to apply the gates shown in *Figure* * [*6.6*](#Figure6.6).*
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 6.6: Circuit for adding l to a state in phase encoding when we have
    m qubits](img/file881.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 6.6**: Circuit for adding ![l](img/file514.png "l") to a state in
    phase encoding when we have ![m](img/file259.png "m") qubits'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, when we apply those gates to a basis state ![\left| k \right\rangle](img/file882.png
    "\left| k \right\rangle"), we obtain ![e^{2\pi ikl \slash 2^{m}}\left| k \right\rangle](img/file883.png
    "e^{2\pi ikl \slash 2^{m}}\left| k \right\rangle"). To prove it, just notice how,
    if the ![h](img/file519.png "h")-th qubit of ![\left| k \right\rangle](img/file882.png
    "\left| k \right\rangle") is ![1](img/file13.png "1"), the circuit of *Figure*
    * [*6.6*](#Figure6.6) adds a phase of value ![e^{\pi il \slash 2^{h}} = e^{2^{m
    - h}\pi il \slash 2^{m}}](img/file884.png "e^{\pi il \slash 2^{h}} = e^{2^{m -
    h}\pi il \slash 2^{m}}") (we start counting qubits from ![0](img/file12.png "0"))
    and no phase otherwise. When we sum all these phases over the qubits of ![\left|
    k \right\rangle](img/file882.png "\left| k \right\rangle") that have value ![1](img/file13.png
    "1"), we obtain exactly ![e^{2\pi ilk \slash 2^{m}}](img/file885.png "e^{2\pi
    ilk \slash 2^{m}}"). Thus, by linearity, when we apply the circuit to the phase
    encoding of ![j](img/file258.png "j"), we get*
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '*![\frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m} - 1}e^{\frac{2\pi ijk}{2^{m}}}e^{}](img/file886.png
    "\frac{1}{\sqrt{2^{m}}}\sum\limits_{k = 0}^{2^{m} - 1}e^{\frac{2\pi ijk}{2^{m}}}e^{}")'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 2![\pi ilk2^{m}\left| k \right\rangle = \frac{1}{\sqrt{2^{m}}}{\sum}_{k = 0}^{2^{m}
    - 1}e^{\frac{2\pi i(j + l)k}{2^{m}}}\left| k \right\rangle,](img/file887.png "\pi
    ilk2^{m}\left| k \right\rangle = \frac{1}{\sqrt{2^{m}}}{\sum}_{k = 0}^{2^{m} -
    1}e^{\frac{2\pi i(j + l)k}{2^{m}}}\left| k \right\rangle,")![whichisthephaseencodingof](img/file888.png
    "whichisthephaseencodingof")j+l![,asdesired.](img/file889.png ",asdesired.")
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: So, this works beautifully for non-negative numbers. But, what about negative
    ones? It turns out that, if ![l](img/file514.png "l") is negative, we can again
    use the very circuit in *Figure* * [*6.6*](#Figure6.6) — no further adjustments
    required. The key observation is that, for any integer ![0 \leq h \leq m - 1](img/file890.png
    "0 \leq h \leq m - 1"), it holds that*
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '*![e^{}](img/file891.png "e^{}")'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![\pi i(2^{m} + l)2^{h} = e^{}](img/file892.png "\pi i(2^{m} + l)2^{h} = e^{}")'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: '![\pi il2^{h}e^{\frac{\pi i2^{m}}{2^{h}}} = e^{}](img/file893.png "\pi il2^{h}e^{\frac{\pi
    i2^{m}}{2^{h}}} = e^{}")'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: '![\pi il2^{h}e^{\pi i2^{m - h}} = e^{}](img/file894.png "\pi il2^{h}e^{\pi
    i2^{m - h}} = e^{}")'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: '![\pi il2^{h},](img/file895.png "\pi il2^{h},")![because](img/file896.png "because")m-h¿0![,making](img/file897.png
    ",making")2ˆm-h![evenandimplying](img/file898.png "evenandimplying")eˆ![\pi i2^{m
    - h} = 1.](img/file899.png "\pi i2^{m - h} = 1.")'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: This means that if we plug in ![l](img/file514.png "l") or ![2^{m} + l](img/file900.png
    "2^{m} + l") in the gates of *Figure* * [*6.6*](#Figure6.6), we obtain exactly
    the same circuit. Thus, we can work with the two’s complement representation of
    ![l](img/file514.png "l") instead of ![l](img/file514.png "l") and the results
    for the addition that we proved previously for non-negative integers will also
    hold for negative integers. The only concern could be that, when adding in two’s
    complement a positive and a negative number, we get a carry-out (like, for instance,
    when we added ![6](img/file576.png "6") and ![- 4](img/file330.png "- 4") in a
    previous example). However, in that case, the carry-out will give us an even power
    of two and, again, the corresponding phase will be ![1](img/file13.png "1"), leaving
    the result unchanged. Effectively, we are performing arithmetic modulo ![2^{m}](img/file901.png
    "2^{m}"), so we are safe. Notice, nevertheless, that, if we add two positive or
    two negative integers and we get a carry-out, then we will get a wrong result
    — in this case, modular arithmetic turns against us!*
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '*Important note'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: You always need to use a number of qubits that is large enough to represent,
    in two’s complement, any integer number that may arise from the computations.
    If you are working with a polynomial ![g(x)](img/file867.png "g(x)"), you can
    simply add up the absolute value of all the coefficients in ![g(x)](img/file867.png
    "g(x)") to obtain a constant ![K](img/file902.png "K"). Then, you can choose any
    ![m](img/file259.png "m") such that ![- 2^{m - 1} \leq - K \leq K \leq 2^{m -
    1} - 1](img/file903.png "- 2^{m - 1} \leq - K \leq K \leq 2^{m - 1} - 1"). If
    you want to be even more precise, you can select ![K](img/file902.png "K") as
    the maximum between the sum of all positive coefficients and the sum of the absolute
    value of all the negative coefficients.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: As an example, in *Figure* *[*6.7*](#Figure6.7), we present a circuit that prepares
    the phase representation of ![0](img/file12.png "0"), adds ![3](img/file472.png
    "3") to it, and then adds ![- 5](img/file591.png "- 5") (or, equivalently, subtracts
    ![5](img/file296.png "5")). Notice that some of the gates could be simplified.
    For instance, ![P(3\pi)](img/file904.png "P(3\pi)") is just ![P(\pi)](img/file905.png
    "P(\pi)"). We could also merge consecutive ![P](img/file1.png "P") gates into
    single gates by adding their angles together (for instance, ![P( - 5\frac{\pi}{2})P(3\frac{\pi}{2})
    = P( - 2\frac{\pi}{2}) = P(\pi)](img/file906.png "P( - 5\frac{\pi}{2})P(3\frac{\pi}{2})
    = P( - 2\frac{\pi}{2}) = P(\pi)")). For the sake of clarity, throughout this section,
    we will keep the gates in their original form, without any simplification.*
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 6.7: Circuit for preparing the phase representation of 0, adding
    3 to it and then subtracting 5](img/file907.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 6.7**: Circuit for preparing the phase representation of ![0](img/file12.png
    "0"), adding ![3](img/file472.png "3") to it and then subtracting ![5](img/file296.png
    "5")'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.4
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Derive a circuit that prepares the phase representation of ![0](img/file12.png
    "0"), adds ![6](img/file576.png "6") to it and then subtracts ![4](img/file143.png
    "4"). Use ![4](img/file143.png "4") qubits.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the first ingredient that we need in order to compute the ![g(x)](img/file867.png
    "g(x)") polynomial: adding integers in phase encoding. In the next subsection,
    we will learn how to deal with the product of binary variables.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.3 Computing the whole polynomial
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be tempted to think that performing the multiplications that we need
    to compute our polynomial ![g(x)](img/file867.png "g(x)") will be much harder
    than performing the additions. But not quite! Let’s look into this.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: All the variables that we are considering are binary, and this means that, when
    we perform a multiplication such as ![x_{0}x_{1}](img/file908.png "x_{0}x_{1}"),
    we always obtain either ![0](img/file12.png "0") or ![1](img/file13.png "1") as
    a result. Thus, if ![g(x)](img/file867.png "g(x)") is, for example, ![3x_{0}x_{1}
    - 2x_{1}x_{2} + 1](img/file909.png "3x_{0}x_{1} - 2x_{1}x_{2} + 1"), we will need
    to add ![1](img/file13.png "1") always (because it is the independent term and,
    as the name suggests, does not depend on the value of the variables), but we will
    only need to add ![3](img/file472.png "3") when both ![x_{0}](img/file443.png
    "x_{0}") and ![x_{1}](img/file712.png "x_{1}") are ![1](img/file13.png "1") and
    we will only need to subtract ![2](img/file302.png "2") when both ![x_{1}](img/file712.png
    "x_{1}") and ![x_{2}](img/file444.png "x_{2}") take value ![1](img/file13.png
    "1").
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Does this sound familiar? Well, it should, because these computations that we
    have described correspond, precisely, to the application of controlled operations.
    Therefore, in order to calculate the contribution of a term such as ![3x_{0}x_{1}](img/file910.png
    "3x_{0}x_{1}"), we can use the circuit that we derived in the previous subsection
    to add ![3](img/file472.png "3") in phase encoding, but with each gate controlled
    by both ![x_{0}](img/file443.png "x_{0}") and ![x_{1}](img/file712.png "x_{1}").
    Notice that there is nothing special in using just two qubits as the controls,
    so we could also consider polynomials with terms such as ![- 2x_{0}x_{2}x_{4}](img/file911.png
    "- 2x_{0}x_{2}x_{4}") or ![5x_{1}x_{2}x_{3}x_{5}](img/file912.png "5x_{1}x_{2}x_{3}x_{5}").
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: To better illuminate these techniques, in *Figure* *[*6.8*](#Figure6.8), we
    show a circuit that computes ![3x_{0}x_{1} - 2x_{1}x_{2} + 1](img/file909.png
    "3x_{0}x_{1} - 2x_{1}x_{2} + 1"). The first column of gates prepares the phase
    encoding of ![0](img/file12.png "0"). The second one adds the independent term
    of the polynomial. The next one adds ![3](img/file472.png "3"), but only if ![x_{0}
    = x_{1} = 1](img/file913.png "x_{0} = x_{1} = 1") (that is why all the gates are
    controlled by the ![\left| x_{0} \right\rangle](img/file825.png "\left| x_{0}
    \right\rangle") and ![\left| x_{1} \right\rangle](img/file914.png "\left| x_{1}
    \right\rangle") qubits). Similarly, the last column subtracts ![2](img/file302.png
    "2"), but only when ![x_{1} = x_{2} = 1](img/file915.png "x_{1} = x_{2} = 1").*
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 6.8: Circuit for computing 3x_{0}x_{1} - 2x_{1}x_{2} + 1 in phase
    encoding](img/file916.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 6.8**: Circuit for computing ![3x_{0}x_{1} - 2x_{1}x_{2} + 1](img/file909.png
    "3x_{0}x_{1} - 2x_{1}x_{2} + 1") in phase encoding'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of technical details to discuss about the circuit in *Figure*
    *[*6.8*](#Figure6.8). First, we have adopted the usual convention of setting all
    the one-qubit gates that are controlled by the same qubits in a single column.
    In fact, we could consider them as a single multi-qubit gate, but in some quantum
    computers you may need to separate them and apply them in sequence (in any case,
    this is something that the transpiler should take care of, don’t worry). Also,
    notice that these gates are multi-controlled, but — using techniques like the
    ones described in *Section 4.3* of [[69](ch030.xhtml#Xnielsen11quantum)] — you
    can transform them into a combination of one- and two-qubit gates with Toffoli
    gates, which, in turn, can be decomposed into just one- and two-qubit gates.*
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '*Exercise 6.5'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Design a circuit for computing ![x_{1}x_{2} - 3x_{0} + 2](img/file917.png "x_{1}x_{2}
    - 3x_{0} + 2") in phase encoding. Use multi-qubit and multi-controlled gates.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: So now we know how to compute, in phase encoding, the values of polynomials
    on binary variables with integer coefficients. But what about the case in which
    the coefficients are real numbers? We have two options to deal with that situation.
    The first one is to approximate them by using fractions with the same denominator.
    For instance, if your coefficients are ![0.25](img/file615.png "0.25") and ![-
    1.17](img/file918.png "- 1.17"), you can represent them by ![\left. 25\slash 100
    \right.](img/file919.png "\left. 25\slash 100 \right.") and ![\left. - 117\slash
    100 \right.](img/file920.png "\left. - 117\slash 100 \right."). Then, you can
    multiply the whole polynomial by ![100](img/file389.png "100") without changing
    the variable values at which the minimum is attained and work with ![25](img/file921.png
    "25") and ![- 117](img/file922.png "- 117"), which are integers. The other option
    is to use the real numbers directly in the encoding. For instance, in the circuit
    of *Figure* * [*6.6*](#Figure6.6), you would use ![l](img/file514.png "l") even
    if it is not an integer. In this case, you will work with a superposition of approximations
    of the real coefficient, with the better approximations having the larger amplitudes
    (see the discussion in [[45](ch030.xhtml#Xgilliam2021grover)] for all the details).*
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '*This completes our discussion on how to compute, in phase encoding, the value
    of any polynomial on binary variables. However, we are not quite done yet! In
    the next subsection, we will use our newly-acquired knowledge to finally implement
    the oracles that we need for the GAS algorithm.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.4 Constructing the oracle
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far in this section we have covered a lot of ground. However, we should
    not forget what our final goal is: we want to implement an oracle that, given
    ![x](img/file269.png "x") and ![y](img/file270.png "y"), returns whether ![g(x)
    < g(y)](img/file853.png "g(x) < g(y)") or not. This is what we need in order to
    use the **Dürr-Høyer** algorithm to find a minimum of ![g](img/file849.png "g").
    In the previous subsection, we showed how to build a circuit that, given ![x](img/file269.png
    "x"), computes ![g(x)](img/file867.png "g(x)") in phase encoding. For the sake
    of simplicity, in the circuits that we will use in this subsection, we will denote
    the sequence of gates that implements ![g(x)](img/file867.png "g(x)"), excluding
    the initial column of ![H](img/file10.png "H") gates, by just a big box with ![g(x)](img/file867.png
    "g(x)") inside. In a similar way, when we need to use the QFT or its inverse,
    we will use a box labeled QFT or QFT![{}^{\dagger}](img/file863.png "{}^{\dagger}").'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Using this notation, an oracle to determine whether ![g(x) < g(y)](img/file853.png
    "g(x) < g(y)") can be implemented by using the circuit depicted in *Figure* *
    [*6.9*](#Figure6.9).*
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 6.9: Oracle to determine whether g(x) < g(y)](img/file923.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 6.9**: Oracle to determine whether ![g(x) < g(y)](img/file853.png
    "g(x) < g(y)")'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explain bit by bit the elements of the circuit. First, notice that the
    upper qubits are reserved for the inputs ![x](img/file269.png "x") and ![y](img/file270.png
    "y") and, consequently, are registers of ![n](img/file244.png "n") qubits each.
    Next, we have ![m](img/file259.png "m") auxiliary qubits that we will use to compute
    the values of the polynomials (as we mentioned previously, you need to select
    ![m](img/file259.png "m") so that it is big enough to store all the intermediate
    results). Finally, the bottom qubit will store the result of checking whether
    ![g(x) < g(y)](img/file853.png "g(x) < g(y)").
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: From what we have studied in this section and under the assumption that all
    the coefficients in ![g](img/file849.png "g") are integers, we know that the state
    just before the CNOT gate is ![\left| x \right\rangle\left| y \right\rangle\left|
    {g(x) - g(y)} \right\rangle\left| 0 \right\rangle](img/file924.png "\left| x \right\rangle\left|
    y \right\rangle\left| {g(x) - g(y)} \right\rangle\left| 0 \right\rangle"). Now,
    if ![g(x) < g(y)](img/file853.png "g(x) < g(y)"), then ![g(x) - g(y) < 0](img/file925.png
    "g(x) - g(y) < 0") and the most significant bit of ![g(x) - g(y)](img/file926.png
    "g(x) - g(y)") will be ![1](img/file13.png "1"), because we are working with two’s
    complement representation. Thus, when we apply the CNOT gate, we will set the
    bottom qubit to ![\left| 1 \right\rangle](img/file14.png "\left| 1 \right\rangle")
    if ![g(x) < g(y)](img/file853.png "g(x) < g(y)"), and we will leave it in state
    ![\left| 0 \right\rangle](img/file6.png "\left| 0 \right\rangle") otherwise. This
    is the value that we will denote ![\left| z \right\rangle](img/file927.png "\left|
    z \right\rangle").
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be natural to think that we could end the circuit after applying the
    CNOT gate. After all, we have already computed the result that we needed: ![z](img/file81.png
    "z") will be ![1](img/file13.png "1") if ![g(x) < g(y)](img/file853.png "g(x)
    < g(y)") and it will be ![0](img/file12.png "0") otherwise. Nevertheless, we need
    to set the ![m](img/file259.png "m") auxiliary qubits back to ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle"). This is the value that is expected for the correct
    behaviour of the subsequent applications of the oracle (remember that we are using
    Grover’s algorithm, so there will be several repetitions of the oracle circuit).
    What is more, we also need to set these qubits back to ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle") to disentangle them from the rest of the qubits in the
    circuit. If they remain entangled, they may prevent the rest of the circuit from
    working correctly.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of setting the qubits back to ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle") is known as **uncomputation** and it is a very important
    technique in many quantum algorithms. Since all quantum gates are reversible,
    we cannot just ”erase” the content of some qubits (that would be extremely irreversible,
    because we would be forgetting the original values and it would be impossible
    to restore them). We need to perform the same computations that we carried out,
    but in reverse: hence the name ”uncomputation.” In our case, we use the QFT to
    go back to phase encoding and then we add ![g(y) - g(x)](img/file928.png "g(y)
    - g(x)"), which, of course, is the inverse of adding ![g(x) - g(y)](img/file926.png
    "g(x) - g(y)"). Consequently, after the ![g(y) - g(x)](img/file928.png "g(y) -
    g(x)") gate, the auxiliary qubits contain the phase encoding of ![0](img/file12.png
    "0") and, when we apply the column of ![H](img/file10.png "H") gates, we obtain
    ![\left| 0 \right\rangle](img/file6.png "\left| 0 \right\rangle"), as desired.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: We have, finally, completed our construction of the oracle that we need for
    GAS. However, there are a couple of additional details that may be useful in practice.
    On the one hand, notice that, in each application of Grover’s algorithm in GAS,
    the value of ![y](img/file270.png "y") is fixed (it is ![x_{0}](img/file443.png
    "x_{0}"), the best solution that we have found by then). Thus, we can simplify
    the design of the oracle in *Figure* * [*6.9*](#Figure6.9) by eliminating the
    qubits reserved for ![\left| y \right\rangle](img/file268.png "\left| y \right\rangle"),
    computing ![g(x_{0})](img/file850.png "g(x_{0})") with a classical computer, and
    using ![g(x) - g(x_{0})](img/file929.png "g(x) - g(x_{0})") and ![g(x_{0}) - g(x)](img/file930.png
    "g(x_{0}) - g(x)") in the gates that compute the values of the polynomial.*
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '*On the other hand, using techniques similar to the ones that we have studied
    in this section, we can create oracles to check whether polynomial constraints
    are met or not. For instance, if one of the constraints in our problem is ![3x_{0}
    - 2x_{0}x_{1} < 3](img/file931.png "3x_{0} - 2x_{0}x_{1} < 3"), we can easily
    adapt our oracle construction to check whether that condition is met. Thus, we
    do not always need to transform our optimization problems into a pure QUBO form,
    but we can keep (some of) the constraints and check them directly. This might
    be more convenient than working with penalty terms in some cases.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: But enough of theoretical considerations for now. In the next section, we will
    explain how to use GAS in Qiskit in order to solve combinatorial optimization
    problems.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 6.3 Using GAS with Qiskit
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to practice what you have learned in this chapter about Grover’s
    search, the Dürr-Høyer algorithm, and the construction of oracles, you can try
    to implement your own version of GAS in Qiskit from scratch. It is not a difficult
    project and it can be very satisfactory. However, there is no need for that. In
    the Qiskit Optimization module, you can find a ready-to-use implementation of
    Grover Adaptive Search (we will be using **version 0.4.0** of the package). Let’s
    see how to use it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: One additional advantage of working with Qiskit’s GAS implementation is that
    it accepts the optimization problem format that we used with QAOA in *Section*
    *[*5.2.2*](ch013.xhtml#x1-1030005.2.2). The simplest way of using it is by defining
    a QUBO problem like the one that we can create with the following piece of code:*
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE0]'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the execution is the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you surely recognize, this is the type of problem that we have been extensively
    working with in the last few chapters. To solve it with GAS in Qiskit, we need
    to define a `GroverOptimizer` object as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that we have set seed values for reproducibility and we have created
    a quantum instance based on the Aer simulator. Of course, if you want to use a
    real quantum computer, you just need to create the quantum instance from one of
    the quantum devices, as we have seen in previous chapters. Then, we have defined
    a `GroverOptimizer` object that uses ![3](img/file472.png "3") qubits to represent
    the values of the polynomial (what we have denoted as ![m](img/file259.png "m")
    in the previous section) and that stops the execution if it has seen no improvement
    in ![2](img/file302.png "2") consecutive iterations (the `num_iterations` parameter).
    Notice that ![3](img/file472.png "3") qubits are enough to represent all the possible
    values of our polynomial in two’s complement, but ![2](img/file302.png "2") qubits
    would be too few.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this `GroverOptimizer` object to solve our problem, we can run the following
    instructions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will give us the following output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is, indeed, the optimal solution to the problem, as you can check by trying
    the ![4](img/file143.png "4") possible options. That was easy, wasn’t it?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.6
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Write the code needed to use GAS in Qiskit to find the solution of the QUBO
    problem with binary variables ![x](img/file269.png "x"), ![y](img/file270.png
    "y"), and ![z](img/file81.png "z") and objective function ![3x + 2y - 3z + 3xy](img/file932.png
    "3x + 2y - 3z + 3xy").
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you want to solve a more complicated problem? It turns out that
    the Grover Optimizer class also can work with problems with constraints. Imagine
    that we define a problem with the following instructions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we execute the code, we obtain the following output, which corresponds to
    a quadratic program with linear constraints:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We could create a `GroverOptimizer` object and directly use its `solve` method
    with `qp`. Then, the `GroverOptimizer` object will convert the constrained problem
    into a QUBO one and solve it. Easy peasy. However, there is a small problem: how
    can we know how many qubits we should use for the polynomial values? Since we
    don’t know the penalty terms that will be introduced in the conversion, we don’t
    know the coefficients of the polynomial. Of course, we could use a big enough
    value to be sure that there will be no problems, but that will make the execution
    slower, especially in the simulator. And if we use too few qubits, our results
    could be erroneous.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'For that reason, we recommend converting the problem first into QUBO form and
    then solving it with GAS. In this way, we can more accurately determine the number
    of qubits that we need. For instance, for the problem that we have just defined,
    we can obtain the transformed QUBO problem with the following instructions:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, this is now a bona fide QUBO problem. Moreover, by inspecting
    the polynomial coefficients, we can notice that ![10](img/file161.png "10") qubits,
    for instance, are enough to store the polynomial values. Thus, we can solve the
    problem with the following piece of code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we run it, we obtain the following, which is indeed the solution to the
    problem:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, this involves the slack variables used in the transformation. If you
    don’t want to see them, you can alternatively run GAS on the original problem,
    now that we know how many qubits to use:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this case, the output is the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is exactly the same solution that we obtained with the transformed problem,
    but now without the slack variables.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: This is all you need to know if you want to use GAS in Qiskit. In the next chapter,
    we will study the **Variational Quantum Eigensolver**, a generalization of QAOA
    that will allow us to solve many interesting optimization problems.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about Grover’s search algorithm and how it
    can be adapted to find minima of functions with the Dürr-Høyer algorithm. We have
    also learned about quantum oracles and their role in these two methods.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: After that, we learned how to perform arithmetic in phase encoding and how to
    retrieve the results by using the mighty Quantum Fourier Transform. We also studied
    how to use all these techniques to implement oracles that can be used in Grover’s
    Adaptive Search to solve combinatorial optimization problems.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also learned how to use GAS with Qiskit to obtain solutions of both
    QUBO problems and constrained quadratic programs.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, get ready for the next chapter: we will be studying the Variational Quantum
    Eigensolver and some of its most important applications!*********************'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
