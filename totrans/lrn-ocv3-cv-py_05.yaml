- en: Chapter 5. Detecting and Recognizing Faces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. 识别人脸
- en: Among the many reasons that make computer vision a fascinating subject is the
    fact that computer vision makes very *futuristic*-sounding tasks a reality. One
    such feature is face detection. OpenCV has a built-in facility to perform face
    detection, which has virtually infinite applications in the real world in all
    sorts of contexts, from security to entertainment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多使计算机视觉成为一个迷人主题的原因中，计算机视觉使许多听起来非常**未来主义**的任务成为现实。其中一项功能就是人脸检测。OpenCV内置了执行人脸检测的功能，这在现实世界的各种环境中几乎有无限的应用，从安全到娱乐。
- en: This chapter introduces some of OpenCV's face detection functionalities, along
    with the data files that define particular types of trackable objects. Specifically,
    we look at Haar cascade classifiers, which analyze contrast between adjacent image
    regions to determine whether or not a given image or subimage matches a known
    type. We consider how to combine multiple Haar cascade classifiers in a hierarchy,
    such that one classifier identifies a parent region (for our purposes, a face)
    and other classifiers identify child regions (eyes, nose, and mouth).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了OpenCV的一些人脸检测功能，以及定义特定类型可追踪对象的数据文件。具体来说，我们研究了Haar级联分类器，这些分类器通过分析相邻图像区域之间的对比度来确定给定的图像或子图像是否与已知类型匹配。我们考虑了如何将多个Haar级联分类器组合成一个层次结构，以便一个分类器识别父区域（在我们的目的中是脸部），而其他分类器识别子区域（眼睛、鼻子和嘴巴）。
- en: We also take a detour into the humble but important subject of rectangles. By
    drawing, copying, and resizing rectangular image regions, we can perform simple
    manipulations on image regions that we are tracking.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还简要地探讨了矩形这个谦逊但重要的主题。通过绘制、复制和调整矩形图像区域的大小，我们可以对我们正在追踪的图像区域进行简单的操作。
- en: By the end of this chapter, we will integrate face tracking and rectangle manipulations
    into Cameo. Finally, we'll have some face-to-face interaction!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将把人脸追踪和矩形操作集成到Cameo中。最后，我们将实现一些面对面互动！
- en: Conceptualizing Haar cascades
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念化Haar级联
- en: When we talk about classifying objects and tracking their location, what exactly
    are we hoping to pinpoint? What constitutes a recognizable part of an object?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论分类对象和追踪它们的位置时，我们究竟希望精确到什么程度？构成物体可识别部分的是什么？
- en: Photographic images, even from a webcam, may contain a lot of detail for our
    (human) viewing pleasure. However, image detail tends to be unstable with respect
    to variations in lighting, viewing angle, viewing distance, camera shake, and
    digital noise. Moreover, even real differences in physical detail might not interest
    us for the purpose of classification. I was taught in school that no two snowflakes
    look alike under a microscope. Fortunately, as a Canadian child, I had already
    learned how to recognize snowflakes without a microscope, as the similarities
    are more obvious in bulk.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 照片图像，即使是来自网络摄像头的，也可能包含大量的细节，以满足我们（人类）观看的愉悦。然而，图像细节在光照、视角、观看距离、相机抖动和数字噪声变化方面往往是不稳定的。此外，即使是物理细节的真实差异，也可能对我们进行分类的目的不感兴趣。我在学校学到的是，在显微镜下，没有两片雪花看起来是相同的。幸运的是，作为一个加拿大孩子，我已经学会了如何在没有显微镜的情况下识别雪花，因为在大批量中，它们的相似性更为明显。
- en: Thus, some means of abstracting image detail is useful in producing stable classification
    and tracking results. The abstractions are called **features**, which are said
    to be **extracted** from the image data. There should be far fewer features than
    pixels, though any pixel might influence multiple features. The level of similarity
    between two images can be evaluated based on Euclidean distances between the images'
    corresponding features.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在产生稳定的分类和追踪结果时，抽象图像细节的一些方法是有用的。这些抽象被称为**特征**，据说它们是从图像数据中**提取**出来的。尽管任何像素都可能影响多个特征，但特征的数量应该远少于像素。两个图像之间的相似程度可以根据图像对应特征的欧几里得距离来评估。
- en: For example, distance might be defined in terms of spatial coordinates or color
    coordinates. Haar-like features are one type of feature that is often applied
    to real-time face tracking. They were first used for this purpose in the paper,
    *Robust Real-Time Face Detection*, *Paul Viola and Michael Jones*, *Kluwer Academic
    Publishers*, *2001* (available at [http://www.vision.caltech.edu/html-files/EE148-2005-Spring/pprs/viola04ijcv.pdf](http://www.vision.caltech.edu/html-files/EE148-2005-Spring/pprs/viola04ijcv.pdf)).
    Each Haar-like feature describes the pattern of contrast among adjacent image
    regions. For example, edges, vertices, and thin lines each generate distinctive
    features.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，距离可以定义为空间坐标或颜色坐标。Haar 类似特征是常用于实时人脸跟踪的一种特征类型。它们首次在论文 *Robust Real-Time Face
    Detection* 中被用于此目的，作者为 *Paul Viola and Michael Jones*，出版于 *Kluwer Academic Publishers*，2001年（可在
    [http://www.vision.caltech.edu/html-files/EE148-2005-Spring/pprs/viola04ijcv.pdf](http://www.vision.caltech.edu/html-files/EE148-2005-Spring/pprs/viola04ijcv.pdf)
    获取）。每个 Haar 类似特征描述了相邻图像区域之间的对比度模式。例如，边缘、顶点和细线各自生成独特的特征。
- en: For any given image, the features may vary depending on the region's size; this
    may be called the **window size**. Two images that differ only in scale should
    be capable of yielding similar features, albeit for different window sizes. Thus,
    it is useful to generate features for multiple window sizes. Such a collection
    of features is called a **cascade**. We may say a Haar cascade is scale-invariant
    or, in other words, robust to changes in scale. OpenCV provides a classifier and
    tracker for scale-invariant Haar cascades that it expects to be in a certain file
    format.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的图像，特征可能会根据区域的大小而变化；这可以称为 **窗口大小**。只有缩放不同的两个图像应该能够产生相似的特征，尽管窗口大小不同。因此，为多个窗口大小生成特征是有用的。这种特征集合被称为
    **级联**。我们可以说 Haar 级联是尺度不变的，换句话说，对尺度变化具有稳健性。OpenCV 提供了一个分类器和跟踪器，用于处理期望以特定文件格式存在的尺度不变
    Haar 级联。
- en: Haar cascades, as implemented in OpenCV, are not robust to changes in rotation.
    For example, an upside-down face is not considered similar to an upright face
    and a face viewed in profile is not considered similar to a face viewed from the
    front. A more complex and more resource-intensive implementation could improve
    Haar cascades' robustness to rotation by considering multiple transformations
    of images as well as multiple window sizes. However, we will confine ourselves
    to the implementation in OpenCV.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 中实现的 Haar 级联对旋转变化不稳健。例如，一个颠倒的脸不被认为是直立脸的相似，侧面看脸也不被认为是正面看脸的相似。一个更复杂且资源消耗更大的实现可以通过考虑图像的多个变换以及多个窗口大小来提高
    Haar 级联对旋转的稳健性。然而，我们将局限于 OpenCV 中的实现。
- en: Getting Haar cascade data
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取 Haar 级联数据
- en: Once you have a copy of the source code of OpenCV 3, you will find a folder,
    `data/haarcascades`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了 OpenCV 3 的源代码副本，你将找到一个名为 `data/haarcascades` 的文件夹。
- en: This folder contains all the XML files used by the OpenCV face detection engine
    to detect faces in still images, videos, and camera feeds.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹包含 OpenCV 人脸检测引擎用于在静态图像、视频和摄像头流中检测人脸所使用的所有 XML 文件。
- en: 'Once you find `haarcascades`, create a directory for your project; in this
    folder, create a subfolder called `cascades`, and copy the following files from
    `haarcascades` into `cascades`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到 `haarcascades`，为你的项目创建一个目录；在这个文件夹中，创建一个名为 `cascades` 的子文件夹，并将以下文件从 `haarcascades`
    复制到 `cascades`：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As their names suggest, these cascades are for tracking faces, eyes, noses,
    and mouths. They require a frontal, upright view of the subject. We will use them
    later when building a face detector. If you are curious about how these data sets
    are generated, refer to *Appendix B*, *Generating Haar Cascades for Custom Targets*,
    *OpenCV Computer Vision with Python*. With a lot of patience and a powerful computer,
    you can make your own cascades and train them for various types of objects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，这些级联用于跟踪人脸、眼睛、鼻子和嘴巴。它们需要被检测对象的正面、直立视角。我们将在构建人脸检测器时使用它们。如果你对如何生成这些数据集感兴趣，请参阅
    *附录 B*，*为自定义目标生成 Haar 级联*，*使用 Python 的 OpenCV 计算机视觉*。有了足够的耐心和一台强大的计算机，你可以制作自己的级联并为各种类型的对象进行训练。
- en: Using OpenCV to perform face detection
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenCV 进行人脸检测
- en: 'Unlike what you may think from the outset, performing face detection on a still
    image or a video feed is an extremely similar operation. The latter is just the
    sequential version of the former: face detection on videos is simply face detection
    applied to each frame read into the program from the camera. Naturally, a whole
    host of concepts are applied to video face detection such as tracking, which does
    not apply to still images, but it''s always good to know that the underlying theory
    is the same.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与你一开始可能想到的不同，在静态图像或视频流上执行人脸检测是一个极其相似的操作。后者只是前者的顺序版本：在视频中的人脸检测只是将人脸检测应用到从摄像头读入程序中的每一帧。自然地，许多概念都应用于视频人脸检测，例如跟踪，这在静态图像中不适用，但了解底层理论是相同的。
- en: So let's go ahead and detect some faces.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续检测一些人脸。
- en: Performing face detection on a still image
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在静态图像上执行人脸检测
- en: The first and most basic way to perform face detection is to load an image and
    detect faces in it. To make the result visually meaningful, we will draw rectangles
    around faces on the original image.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 执行人脸检测的第一种也是最基本的方法是加载一张图像并在其中检测人脸。为了使结果在视觉上具有意义，我们将在原始图像上的人脸周围绘制矩形。
- en: Now that you have `haarcascades` included in your project, let's go ahead and
    create a basic script to perform face detection.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将 `haarcascades` 包含在你的项目中，让我们继续创建一个基本的脚本来执行人脸检测。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's go through the code. First, we use the obligatory `cv2` import (you'll
    find that every script in this book will start like this, or almost similar).
    Secondly, we declare the `detect` function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下代码。首先，我们使用必要的 `cv2` 导入（你会发现这本书中的每个脚本都会这样开始，或者几乎相似）。其次，我们声明 `detect` 函数。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Within this function, we declare a `face_cascade` variable, which is a `CascadeClassifier`
    object for faces, and responsible for face detection.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们声明一个 `face_cascade` 变量，它是一个用于人脸的 `CascadeClassifier` 对象，负责人脸检测。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We then load our file with `cv2.imread`, and convert it to grayscale, because
    that's the color space in which the face detection happens.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `cv2.imread` 加载我们的文件，并将其转换为灰度图，因为人脸检测是在这个颜色空间中进行的。
- en: The next step (`face_cascade.detectMultiScale`) is where we operate the actual
    face detection.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步（`face_cascade.detectMultiScale`）是我们执行实际人脸检测的地方。
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The parameters passed are `scaleFactor` and `minNeighbors`, which determine
    the percentage reduction of the image at each iteration of the face detection
    process, and the minimum number of neighbors retained by each face rectangle at
    each iteration. This may all seem a little complex in the beginning but you can
    check all the options out in the official documentation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的参数是 `scaleFactor` 和 `minNeighbors`，它们决定了在人脸检测过程的每一迭代中图像的百分比缩减，以及每个迭代中每个脸矩形保留的最小邻居数。一开始这可能看起来有点复杂，但你可以在官方文档中查看所有选项。
- en: The value returned from the detection operation is an array of tuples that represent
    the face rectangles. The utility method, `cv2.rectangle`, allows us to draw rectangles
    at the specified coordinates (`x` and `y` represent the left and top coordinates,
    `w` and `h` represent the width and height of the face rectangle).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 检测操作返回的值是一个表示脸矩形的元组数组。实用方法 `cv2.rectangle` 允许我们在指定的坐标处绘制矩形（`x` 和 `y` 代表左上坐标，`w`
    和 `h` 代表脸矩形的宽度和高度）。
- en: We will draw blue rectangles around all the faces we find by looping through
    the faces variable, making sure we use the original image for drawing, not the
    gray version.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过遍历 `faces` 变量来绘制我们找到的所有人脸周围的蓝色矩形，确保我们使用原始图像进行绘制，而不是灰度版本。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Lastly, we create a `namedWindow` instance and display the resulting processed
    image in it. To prevent the image window from closing automatically, we insert
    a call to `waitKey`, which closes the window down at the press of any key.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个 `namedWindow` 实例，并在其中显示处理后的图像。为了防止图像窗口自动关闭，我们插入一个 `waitKey` 调用，按下任意键时关闭窗口。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And there we go, a whole set of Vikings have been detected in our image, as
    shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们已经在图像中检测到了一整队维京人，如下面的截图所示：
- en: '![Performing face detection on a still image](img/image00213.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![在静态图像上执行人脸检测](img/image00213.jpeg)'
- en: Performing face detection on a video
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在视频上执行人脸检测
- en: We now have a good foundation to understand how to perform face detection on
    a still image. As mentioned previously, we can repeat the process on the individual
    frames of a video (be it a camera feed or a video) and perform face detection.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个很好的基础来理解如何在静态图像上执行人脸检测。如前所述，我们可以在视频的各个帧上重复此过程（无论是摄像头流还是视频）并执行人脸检测。
- en: 'The script will perform the following tasks: it will open a camera feed, it
    will read a frame, it will examine that frame for faces, it will scan for eyes
    within the faces detected, and then it will draw blue rectangles around the faces
    and green rectangles around the eyes.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将执行以下任务：它将打开摄像头流，读取一帧，检查该帧中的人脸，扫描检测到的人脸内的眼睛，然后将在脸部周围绘制蓝色矩形，在眼睛周围绘制绿色矩形。
- en: 'Let''s create a file called `face_detection.py` and start by importing the
    necessary module:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `face_detection.py` 的文件，并首先导入必要的模块：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After this, we declare a method, `detect()`, which will perform face detection.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们声明一个名为 `detect()` 的方法，它将执行人脸检测。
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first thing we need to do inside the `detect()` method is to load the Haar
    cascade files so that OpenCV can operate face detection. As we copied the cascade
    files in the local `cascades/` folder, we can use a relative path. Then, we open
    a `VideoCapture` object (the camera feed). The `VideoCapture` constructor takes
    a parameter, which indicates the camera to be used; `zero` indicates the first
    camera available.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `detect()` 方法内部，我们首先需要加载 Haar 级联文件，以便 OpenCV 可以执行人脸检测。由于我们在本地的 `cascades/`
    文件夹中复制了级联文件，我们可以使用相对路径。然后，我们打开一个 `VideoCapture` 对象（摄像头流）。`VideoCapture` 构造函数接受一个参数，表示要使用的摄像头；`zero`
    表示第一个可用的摄像头。
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next up, we capture a frame. The `read()` method returns two values: a Boolean
    indicating the success of the frame read operation, and the frame itself. We capture
    the frame, and then we convert it to grayscale. This is a necessary operation,
    because face detection in OpenCV happens in the grayscale color space:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们捕获一帧。`read()` 方法返回两个值：一个布尔值表示读取帧操作的成功，以及帧本身。我们捕获帧，然后将其转换为灰度。这是一个必要的操作，因为
    OpenCV 中的人脸检测是在灰度颜色空间中进行的：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Much like the single still image example, we call `detectMultiScale` on the
    grayscale version of the frame.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与单个静态图像示例类似，我们在帧的灰度版本上调用 `detectMultiScale`。
- en: '[PRE11]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are a few additional parameters in the eye detection. Why? The method
    signature for `detectMultiScale` takes a number of optional parameters: in the
    case of detecting a face, the default options were good enough to detect faces.
    However, eyes are a smaller feature of the face, and self-casting shadows in my
    beard or my nose and random shadows in the frame were triggering **false positives**.'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在眼检测中还有一些额外的参数。为什么？`detectMultiScale` 方法的签名接受一些可选参数：在检测人脸的情况下，默认选项已经足够检测到人脸。然而，眼睛是人脸的一个较小特征，我胡须或鼻子的自阴影以及画面中的随机阴影都会触发**假阳性**。
- en: By limiting the search for eyes to a minimum size of 40x40 pixels, I was able
    to discard all false positives. Go ahead and test these parameters until you reach
    a point at which your application performs as you expected it to (for example,
    you can try and specify a maximum size for the feature too, or increase the scale
    factor and number of neighbors).
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过将眼睛搜索限制在最小尺寸 40x40 像素，我能够排除所有假阳性。继续测试这些参数，直到你的应用程序达到你期望的性能水平（例如，你可以尝试指定特征的最大尺寸，或者增加缩放因子和邻居数量）。
- en: 'Here we have a further step compared to the still image example: we create
    a region of interest corresponding to the face rectangle, and within this rectangle,
    we operate "eye detection". This makes sense as you wouldn''t want to go looking
    for eyes outside a face (well, for human beings at least!).'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与静态图像示例相比，这里有一个额外的步骤：我们创建一个与脸矩形对应的感兴趣区域，并在该矩形内进行“眼检测”。这很有意义，因为你不希望在人脸之外寻找眼睛（至少对于人类来说是这样！）。
- en: '[PRE12]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Again, we loop through the resulting eye tuples and draw green rectangles around
    them.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们遍历结果眼睛元组，并在它们周围绘制绿色矩形。
- en: '[PRE13]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, we show the resulting frame in the window. All being well, if any face
    is within the field of view of the camera, you will have a blue rectangle around
    their face and a green rectangle around each eye, as shown in this screenshot:![Performing
    face detection on a video](img/image00214.jpeg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在窗口中显示结果帧。如果一切顺利，如果相机视野内有任何人脸，你将在其脸部周围看到一个蓝色矩形，在每个眼睛周围看到一个绿色矩形，如图所示：![在视频上执行人脸检测](img/image00214.jpeg)
- en: Performing face recognition
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行人脸识别
- en: 'Detecting faces is a fantastic feature of OpenCV and one that constitutes the
    basis for a more advanced operation: face recognition. What is face recognition?
    It''s the ability of a program, given an image or a video feed, to identify a
    person. One of the ways to achieve this (and the approach adopted by OpenCV) is
    to "train" the program by feeding it a set of classified pictures (a facial database),
    and operate the recognition against those pictures.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 检测人脸是OpenCV的一个非常棒的功能，也是构成更高级操作（人脸识别）的基础。什么是人脸识别？它是指一个程序，在给定一个图像或视频流的情况下，能够识别一个人的能力。实现这一目标的一种方法（也是OpenCV采用的方法）是通过“训练”程序，给它提供一组分类图片（一个面部数据库），然后对这些图片进行识别操作。
- en: This is the process that OpenCV and its face recognition module follow to recognize
    faces.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是OpenCV及其人脸识别模块遵循的过程来识别人脸。
- en: Another important feature of the face recognition module is that each recognition
    has a confidence score, which allows us to set thresholds in real-life applications
    to limit the amount of false reads.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 人脸识别模块的另一个重要特性是每个识别都有一个置信度分数，这允许我们在实际应用中设置阈值以限制错误读取的数量。
- en: 'Let''s start from the very beginning; to operate face recognition, we need
    faces to recognize. You can do this in two ways: supply the images yourself or
    obtain freely available face databases. There are a number of face databases on
    the Internet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一开始；要操作人脸识别，我们需要识别的面孔。你可以通过两种方式来做这件事：自己提供图像或获取免费的人脸数据库。互联网上有许多人脸数据库：
- en: '**The Yale** **face database (Yalefaces)**: [http://vision.ucsd.edu/content/yale-face-database](http://vision.ucsd.edu/content/yale-face-database)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**耶鲁** **人脸数据库（Yalefaces）**：[http://vision.ucsd.edu/content/yale-face-database](http://vision.ucsd.edu/content/yale-face-database)'
- en: '**The** **AT&T**: [http://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html](http://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AT&T**：[http://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html](http://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html)'
- en: '**The** **Extended Yale or Yale B**: [http://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html](http://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展耶鲁或耶鲁B**：[http://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html](http://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html)'
- en: 'To operate face recognition on these samples, you would then have to run face
    recognition on an image that contains the face of one of the sampled people. That
    may be an educational process, but I found it to be not as satisfying as providing
    images of my own. In fact, I probably had the same thought that many people had:
    I wonder if I could write a program that recognizes my face with a certain degree
    of confidence.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要在这些样本上操作人脸识别，你将不得不在一个包含样本人物面孔的图像上运行人脸识别。这可能是一个教育过程，但我发现它不如提供自己的图像那么令人满意。事实上，我可能和许多人有同样的想法：我想知道我能否编写一个程序，以一定程度的置信度识别我的面孔。
- en: Generating the data for face recognition
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成人脸识别的数据
- en: 'So let''s go ahead and write a script that will generate those images for us.
    A few images containing different expressions are all that we need, but we have
    to make sure the sample images adhere to certain criteria:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们编写一个脚本来生成这些图像。我们只需要一些包含不同表情的图像，但我们必须确保样本图像符合某些标准：
- en: Images will be grayscale in the `.pgm` format
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像将以`.pgm`格式的灰度图形式存在
- en: Square shape
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正方形形状
- en: All the same size images (I used 200 x 200; most freely available sets are smaller
    than that)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有相同大小的图像（我使用了200 x 200；大多数免费提供的集合都小于这个大小）
- en: 'Here''s the script itself:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是脚本本身：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What is quite interesting about this exercise is that we are going to generate
    sample images building on our newfound knowledge of how to detect a face in a
    video feed. Effectively, what we are doing is detecting a face, cropping that
    region of the gray-scaled frame, resizing it to be 200x200 pixels, and saving
    it with a name in a particular folder (in my case, `jm`; you can use your initials)
    in the `.pgm` format.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习相当有趣的地方在于，我们将基于我们新获得的知识来生成样本图像，这些知识是关于如何在视频流中检测人脸的。实际上，我们正在做的是检测人脸，裁剪灰度帧的该区域，将其调整大小为200x200像素，并以特定的文件夹（在我的情况下，是`jm`；你可以使用你的首字母）中的`.pgm`格式保存。
- en: I inserted a variable, `count`, because we needed progressive names for the
    images. Run the script for a few seconds, change expressions a few times, and
    check the destination folder you specified in the script. You will find a number
    of images of your face, grayed, resized, and named with the format, `<count>.pgm`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我插入了一个变量 `count`，因为我们需要为图像设置递增的名称。运行脚本几秒钟，改变几次表情，并检查脚本中指定的目标文件夹。您将找到许多您的面部图像，它们被灰度化、调整大小并以
    `<count>.pgm` 格式命名。
- en: Let's now move on to try and recognize our face in a video feed. This should
    be fun!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来尝试在视频流中识别我们的面部。这应该很有趣！
- en: Recognizing faces
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别面部
- en: 'OpenCV 3 comes with three main methods for recognizing faces, based on three
    different algorithms: **Eigenfaces**, **Fisherfaces**, and **Local Binary Pattern
    Histograms** (**LBPH**). It is beyond the scope of this book to get into the nitty-gritty
    of the theoretical differences between these methods, but we can give a high-level
    overview of the concepts.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 3 提供了三种主要的面部识别方法，基于三种不同的算法：**Eigenfaces**、**Fisherfaces**和**局部二值模式直方图**（**LBPH**）。本书的范围不包括深入探讨这些方法之间理论差异的细节，但我们可以提供一个概念的高级概述。
- en: 'I will refer you to the following links for a detailed description of the algorithms:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我将为您提供以下链接，以详细描述算法：
- en: '**Principal** **Component Analysis (PCA)**: A very intuitive introduction by
    Jonathon Shlens is available at [http://arxiv.org/pdf/1404.1100v1.pdf](http://arxiv.org/pdf/1404.1100v1.pdf).
    This algorithm was invented in 1901 by K. Pearson, and the original paper, *On
    Lines and Planes of Closest Fit to Systems of Points in Space*, is available at
    [http://stat.smmu.edu.cn/history/pearson1901.pdf](http://stat.smmu.edu.cn/history/pearson1901.pdf).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主成分分析（PCA）**：Jonathon Shlens 提供了一个非常直观的介绍，可在[http://arxiv.org/pdf/1404.1100v1.pdf](http://arxiv.org/pdf/1404.1100v1.pdf)找到。该算法由
    K. Pearson 在 1901 年发明，原始论文《On Lines and Planes of Closest Fit to Systems of Points
    in Space》可在[http://stat.smmu.edu.cn/history/pearson1901.pdf](http://stat.smmu.edu.cn/history/pearson1901.pdf)找到。'
- en: '**Eigenfaces**: The paper, *Eigenfaces for Recognition*, *M. Turk and A. Pentland*,
    *1991*, is available at [http://www.cs.ucsb.edu/~mturk/Papers/jcn.pdf](http://www.cs.ucsb.edu/~mturk/Papers/jcn.pdf).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eigenfaces**：论文《Eigenfaces for Recognition》，作者 M. Turk 和 A. Pentland，1991
    年，可在[http://www.cs.ucsb.edu/~mturk/Papers/jcn.pdf](http://www.cs.ucsb.edu/~mturk/Papers/jcn.pdf)找到。'
- en: '**Fisherfaces**: The seminal paper, *THE USE OF MULTIPLE MEASUREMENTS IN TAXONOMIC
    PROBLEMS*, *R.A. Fisher*, *1936*, is available at [http://onlinelibrary.wiley.com/doi/10.1111/j.1469-1809.1936.tb02137.x/pdf](http://onlinelibrary.wiley.com/doi/10.1111/j.1469-1809.1936.tb02137.x/pdf).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fisherfaces**：开创性论文《THE USE OF MULTIPLE MEASUREMENTS IN TAXONOMIC PROBLEMS》，作者
    R.A. Fisher，1936 年，可在[http://onlinelibrary.wiley.com/doi/10.1111/j.1469-1809.1936.tb02137.x/pdf](http://onlinelibrary.wiley.com/doi/10.1111/j.1469-1809.1936.tb02137.x/pdf)找到。'
- en: '**Local** **Binary Pattern**: The first paper describing this algorithm is
    *Performance evaluation of texture measures with classification based on Kullback
    discrimination of distributions*, *T. Ojala, M. Pietikainen, D. Harwood* and is
    available at [http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=576366&searchWithin%5B%5D=%22Authors%22%3A.QT.Ojala%2C+T..QT.&newsearch=true](http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=576366&searchWithin%5B%5D=%22Authors%22%3A.QT.Ojala%2C+T..QT.&newsearch=true).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部二值模式**：描述此算法的第一篇论文是《Performance evaluation of texture measures with classification
    based on Kullback discrimination of distributions》，作者 T. Ojala、M. Pietikainen
    和 D. Harwood，可在[http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=576366&searchWithin%5B%5D=%22Authors%22%3A.QT.Ojala%2C+T..QT.&newsearch=true](http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=576366&searchWithin%5B%5D=%22Authors%22%3A.QT.Ojala%2C+T..QT.&newsearch=true)找到。'
- en: 'First and foremost, all methods follow a similar process; they all take a set
    of classified observations (our face database, containing numerous samples per
    individual), get "trained" on it, perform an analysis of faces detected in an
    image or video, and determine two elements: whether the subject is identified,
    and a measure of the confidence of the subject really being identified, which
    is commonly known as the confidence score.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，所有方法都遵循一个类似的过程；它们都从一组分类观察（我们的面部数据库，包含每个个体的多个样本）中获取，并在其上进行“训练”，对图像或视频中检测到的面部进行分析，并确定两个要素：是否识别了主题，以及主题真正被识别的置信度度量，这通常被称为置信度分数。
- en: Eigenfaces performs a so called PCA, which—of all the mathematical concepts
    you will hear mentioned in relation to computer vision—is possibly the most descriptive.
    It basically identifies principal components of a certain set of observations
    (again, your face database), calculates the **divergence** of the current observation
    (the faces being detected in an image or frame) compared to the dataset, and it
    produces a value. The smaller the value, the smaller the difference between face
    database and detected face; hence, a value of `0` is an exact match.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Fisherfaces derives from PCA and evolves the concept, applying more complex
    logic. While computationally more intensive, it tends to yield more accurate results
    than Eigenfaces.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: LBPH instead roughly (again, from a very high level) divides a detected face
    into small cells and compares each cell to the corresponding cell in the model,
    producing a histogram of matching values for each area. Because of this flexible
    approach, LBPH is the only face recognition algorithm that allows the model sample
    faces and the detected faces to be of different shape and size. I personally found
    this to be the most accurate algorithm generally speaking, but each algorithm
    has its strengths and weaknesses.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the training data
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have our data, we need to load these sample pictures into our face
    recognition algorithms. All face recognition algorithms take two parameters in
    their `train()` method: an array of images and an array of labels. What do these
    labels represent? They are the IDs of a certain individual/face so that when face
    recognition is performed, we not only know the person was recognized but also
    who—among the many people available in our database—the person is.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we need to create a **comma-separated value** (**CSV**) file, which
    will contain the path to a sample picture followed by the ID of that person. In
    my case, I have 20 pictures generated with the previous script, in the subfolder,
    `jm/`, of the folder, `data/at/`, which contains all the pictures of all the individuals.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'My CSV file therefore looks like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dots are all the missing numbers. The `jm/` instance indicates the subfolder,
    and the `0` value at the end is the ID for my face.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: OK, at this stage, we have everything we need to instruct OpenCV to recognize
    our face.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Loading the data and recognizing faces
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next up, we need to load these two resources (the array of images and CSV file)
    into the face recognition algorithm, so it can be trained to recognize our face.
    To do this, we build a function that reads the CSV file and—for each line of the
    file—loads the image at the corresponding path into the images array and the ID
    into the labels array.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Performing an Eigenfaces recognition
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''re ready to test the face recognition algorithm. Here''s the script to
    perform it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There are a few lines that may look a bit mysterious, so let's analyze the script.
    First of all, there's an array of names declared; those are the actual names of
    the individual people I stored in my database of faces. It's great to identify
    a person as ID `0`, but printing `'Joe'` on top of a face that's been correctly
    detected and recognized is much more dramatic.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有几行可能看起来有点神秘，所以让我们分析一下脚本。首先，有一个名字数组被声明了；这些是我存储在人脸数据库中的实际个人名字。将一个人识别为ID `0` 是很棒的，但在正确检测和识别到的人脸上打印
    `'Joe'` 要戏剧性得多。
- en: So whenever the script recognizes an ID, we will print the corresponding name
    in the `names` array instead of an ID.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所以每当脚本识别到一个ID时，我们将在`names`数组中打印相应的名字，而不是ID。
- en: 'After this, we load the images as described in the previous function, create
    the face recognition model with `cv2.createEigenFaceRecognizer()`, and train it
    by passing the two arrays of images and labels (IDs). Note that the Eigenface
    recognizer takes two important parameters that you can specify: the first one
    is the number of principal components you want to keep and the second is a float
    value specifying a confidence threshold.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们按照前一个函数中描述的方式加载图像，使用`cv2.createEigenFaceRecognizer()`创建人脸识别模型，并通过传递图像和标签（ID）数组来训练它。请注意，Eigenface识别器接受两个重要的参数，你可以指定：第一个是你想要保留的主成分数量，第二个是一个指定置信度阈值的浮点值。
- en: Next up, we repeat a similar process to the face detection operation. This time,
    though, we extend the processing of the frames by also operating face recognition
    on any face that's been detected.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们重复与面部检测操作类似的过程。不过，这次，我们通过在检测到的任何面部上执行人脸识别来扩展帧的处理。
- en: 'This happens in two steps: firstly, we resize the detected face to the expected
    size (in my case, samples were 200x200 pixels), and then we call the `predict()`
    function on the resized region.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这分为两个步骤：首先，我们将检测到的人脸调整到期望的大小（在我的情况下，样本是200x200像素），然后我们在调整大小后的区域上调用`predict()`函数。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is a bit of a simplified process, and it serves the purpose of enabling
    you to have a basic application running and understand the process of face recognition
    in OpenCV 3\. In reality, you will apply a few more optimizations, such as correctly
    aligning and rotating detected faces, so the accuracy of the recognition is maximized.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化的过程，它的目的是让你能够运行一个基本的应用程序并理解OpenCV 3中人脸识别的过程。实际上，你将应用一些额外的优化，例如正确对齐和旋转检测到的人脸，以最大限度地提高识别的准确性。
- en: 'Lastly, we obtain the results of the recognition and, just for effect, we draw
    it in the frame:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们获得识别结果，并且为了效果，我们在帧中绘制它：
- en: '![Performing an Eigenfaces recognition](img/image00215.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![使用Eigenfaces进行识别](img/image00215.jpeg)'
- en: Performing face recognition with Fisherfaces
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Fisherfaces进行人脸识别
- en: 'What about Fisherfaces? The process doesn''t change much; we simply need to
    instantiate a different algorithm. So, the declaration of our model variable would
    look like so:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那Fisherfaces呢？过程没有太大变化；我们只需要实例化一个不同的算法。所以，我们的模型变量声明将如下所示：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Fisherface takes the same two arguments as Eigenfaces: the Fisherfaces to keep
    and the confidence threshold. Faces with confidence above this threshold will
    be discarded.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Fisherface与Eigenfaces具有相同的两个参数：要保留的Fisherfaces和置信度阈值。置信度高于此阈值的面孔将被丢弃。
- en: Performing face recognition with LBPH
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用LBPH进行人脸识别
- en: 'Finally, let''s take a quick look at the LBPH algorithm. Again, the process
    is very similar. However, the parameters taken by the algorithm factory are a
    bit more complex as they indicate in order: `radius`, `neighbors`, `grid_x`, `grid_y`,
    and the confidence threshold. If you don''t specify these values, they will automatically
    be set to 1, 8, 8, 8, and 123.0\. The model declaration will look like so:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们快速看一下LBPH算法。同样，过程非常相似。然而，算法工厂接受的参数要复杂一些，因为它们按顺序指示：`radius`，`neighbors`，`grid_x`，`grid_y`，以及置信度阈值。如果你不指定这些值，它们将自动设置为1，8，8，8，和123.0。模型声明将如下所示：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that with LBPH, you won't need to resize images, as the division in grids
    allows comparing patterns identified in each cell.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用LBPH，你不需要调整图像大小，因为网格的划分允许比较每个单元格中识别出的模式。
- en: Discarding results with confidence score
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 丢弃置信度分数的结果
- en: 'The `predict()` method returns a two-element array: the first element is the
    label of the recognized individual and the second is the confidence score. All
    algorithms come with the option of setting a confidence score threshold, which
    measures the distance of the recognized face from the original model, therefore
    a score of 0 signifies an exact match.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`predict()`方法返回一个包含两个元素的数组：第一个元素是识别个体的标签，第二个是置信度分数。所有算法都提供了设置置信度分数阈值的选项，这衡量了识别的面与原始模型之间的距离，因此分数为0表示完全匹配。'
- en: There may be cases in which you would rather retain all recognitions, and then
    apply further processing, so you can come up with your own algorithms to estimate
    the confidence score of a recognition; for example, if you are trying to identify
    people in a video, you may want to analyze the confidence score in subsequent
    frames to establish whether the recognition was successful or not. In this case,
    you can inspect the confidence score obtained by the algorithm and draw your own
    conclusions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有这样的情况，你宁愿保留所有识别，然后进行进一步的处理，这样你可以提出自己的算法来估计识别的置信度分数；例如，如果你试图在视频中识别人，你可能想分析后续帧中的置信度分数，以确定识别是否成功。在这种情况下，你可以检查算法获得的置信度分数，并得出自己的结论。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The confidence score value is completely different in Eigenfaces/Fisherfaces
    and LBPH. Eigenfaces and Fisherfaces will produce values (roughly) in the range
    0 to 20,000, with any score below 4-5,000 being quite a confident recognition.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 置信度分数在Eigenfaces/Fisherfaces和LBPH中完全不同。Eigenfaces和Fisherfaces将产生（大约）在0到20,000范围内的值，任何低于4-5,000的分数都表示相当有信心的识别。
- en: LBPH works similarly; however, the reference value for a good recognition is
    below 50, and any value above 80 is considered as a low confidence score.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: LBPH的工作原理类似；然而，良好识别的参考值低于50，任何高于80的值都被认为是低置信度分数。
- en: A normal custom approach would be to hold-off drawing a rectangle around a recognized
    face until we have a number of frames with a satisfying arbitrary confidence score,
    but you have total freedom to use OpenCV's face recognition module to tailor your
    application to your needs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的定制方法是在获得足够数量的具有令人满意的任意置信度分数的帧之前，不绘制识别面的矩形，但你完全自由地使用OpenCV的人脸识别模块来定制你的应用程序以满足你的需求。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By now, you should have a good understanding of how face detection and face
    recognition work, and how to implement them in Python and OpenCV 3.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经很好地理解了人脸检测和识别的工作原理，以及如何在Python和OpenCV 3中实现它们。
- en: Face detection and face recognition are constantly evolving branches of computer
    vision, with algorithms being developed continuously, and they will evolve even
    faster in the near future with the emphasis posed on robotics and the Internet
    of things.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 人脸检测和识别是计算机视觉中不断发展的分支，算法正在不断发展，并且随着对机器人和物联网的重视，它们将在不久的将来发展得更快。
- en: For now, the accuracy of detection and recognition heavily depends on the quality
    of the training data, so make sure you provide your applications with high-quality
    face databases and you will be satisfied with the results.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，检测和识别的准确性高度依赖于训练数据的质量，所以请确保为你的应用程序提供高质量的面对面数据库，你将对自己的结果感到满意。
