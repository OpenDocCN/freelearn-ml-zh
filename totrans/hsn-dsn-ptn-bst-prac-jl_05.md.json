["```py\n# Space war game!\n\nmutable struct Position\n    x::Int\n    y::Int\nend\n\nstruct Size\n    width::Int\n    height::Int\nend\n\nstruct Widget\n    name::String\n    position::Position\n    size::Size\nend\n```", "```py\n# single-line functions\nmove_up!(widget, v)    = widget.position.y -= v\nmove_down!(widget, v)  = widget.position.y += v\nmove_left!(widget, v)  = widget.position.x -= v\nmove_right!(widget, v) = widget.position.x += v\n```", "```py\n# long version\nfunction move_up!(widget, v)\n    widget.position.y -= v\nend\n```", "```py\nmove_up!(widget::Widget, v::Int) = widget.position.y -= v\n```", "```py\n# Define pretty print functions\nBase.show(io::IO, p::Position) = print(io, \"(\", p.x, \",\", p.y, \")\")\nBase.show(io::IO, s::Size) = print(io, s.width, \" x \", s.height)\nBase.show(io::IO, w::Widget) = print(io, w.name, \" at \", w.position, \" size \", w.size)\n```", "```py\n# let's test these functions\nw = Widget(\"asteroid\", Position(0, 0), Size(10, 20))\nmove_up!(w, 10)\nmove_down!(w, 10)\nmove_left!(w, 20)\nmove_right!(w, 20)\n\n# should be back to position (0,0)\nprint(w) \n```", "```py\n# Make a bunch of asteroids\nfunction make_asteroids(N::Int, pos_range = 0:200, size_range = 10:30)\n    pos_rand() = rand(pos_range)\n    sz_rand() = rand(size_range)\n    return [Widget(\"Asteroid #$i\", \n                Position(pos_rand(), pos_rand()), \n                Size(sz_rand(), sz_rand())) \n        for i in 1:N]\nend\n```", "```py\nfunction make_asteroids2(N::Int; pos_range = 0:200, size_range = 10:30)\n    pos_rand() = rand(pos_range)\n    sz_rand() = rand(size_range)\n    return [Widget(\"Asteroid #$i\", \n                Position(pos_rand(), pos_rand()), \n                Size(sz_rand(), sz_rand())) \n        for i in 1:N]\nend\n```", "```py\nfunction make_asteroids3(; N::Int, pos_range = 0:200, size_range = 10:30)\n    pos_rand() = rand(pos_range)\n    sz_rand() = rand(size_range)\n    return [Widget(\"Asteroid #$i\", \n                Position(pos_rand(), pos_rand()), \n                Size(sz_rand(), sz_rand())) \n        for i in 1:N]\nend\n```", "```py\n# Shoot any number of targets\nfunction shoot(from::Widget, targets::Widget...)\n    println(\"Type of targets: \", typeof(targets))\n    for target in targets\n        println(from.name, \" --> \", target.name)\n    end\nend\n```", "```py\nspaceship = Widget(\"Spaceship\", Position(0, 0), Size(30,30))\ntarget1 = asteroids[1]\ntarget2 = asteroids[2]\ntarget3 = asteroids[3]\n```", "```py\n# Special arrangement before attacks\nfunction triangular_formation!(s1::Widget, s2::Widget, s3::Widget)\n    x_offset = 30\n    y_offset = 50\n    s2.position.x = s1.position.x - x_offset\n    s3.position.x = s1.position.x + x_offset\n    s2.position.y = s3.position.y = s1.position.y - y_offset\n    (s1, s2, s3)\nend\n```", "```py\nfunction random_move()\n    return rand([move_up!, move_down!, move_left!, move_right!])\nend\n\nfunction random_leap!(w::Widget, move_func::Function, distance::Int)\n    move_func(w, distance)\n    return w\nend\n```", "```py\nfunction explode(x)\n    println(x, \" exploded!\")\nend\n\nfunction clean_up_galaxy(asteroids)\n    foreach(explode, asteroids)\nend\n```", "```py\nfunction clean_up_galaxy(asteroids)\n    foreach(x -> println(x, \" exploded!\"), asteroids)\nend\n```", "```py\nfunction clean_up_galaxy(asteroids, spaceships)\n    ep = x -> println(x, \" exploded!\")\n    foreach(ep, asteroids)\n    foreach(ep, spaceships)\nend\n```", "```py\n# Random healthiness function for testing\nhealthy(spaceship) = rand(Bool)\n\n# make sure that the spaceship is healthy before any operation \nfunction fire(f::Function, spaceship::Widget)\n    if healthy(spaceship)\n        f(spaceship)\n    else\n        println(\"Operation aborted as spaceship is not healthy\")\n    end\n    return nothing\nend\n```", "```py\nfire(s -> begin\n        move_up!(s, 100)\n        println(s, \" launched missile!\")\n        move_down!(s, 100)\n    end, spaceship)\n```", "```py\nfire(spaceship) do s\n    move_up!(s, 100)\n    println(s, \" launched missile!\")\n    move_down!(s, 100)\nend\n```", "```py\nfunction process_file(func::Function, filename::AbstractString)\n    ios = nothing\n    try\n        ios = open(filename)\n        func(ios)\n    finally\n        close(ios)\n    end\nend\n```", "```py\nisascii(c::Char) \nisascii(s::AbstractString) \nisascii(c::AbstractChar) \n```", "```py\n# A thing is anything that exist in the universe.\n# Concrete type of Thing should always have the following fields:\n#     1\\. position\n#     2\\. size\nabstract type Thing end\n\n# Functions that are applied for all Thing's\nposition(t::Thing) = t.position\nsize(t::Thing) = t.size\nshape(t::Thing) = :unknown\n```", "```py\n# Type of weapons\n@enum Weapon Laser Missile\n```", "```py\n# Spaceship \nstruct Spaceship <: Thing\n    position::Position\n    size::Size\n    weapon::Weapon\nend\nshape(s::Spaceship) = :saucer\n\n# Asteroid \nstruct Asteroid <: Thing\n    position::Position\n    size::Size\nend\n```", "```py\nstruct Rectangle\n    top::Int\n    left::Int\n    bottom::Int\n    right::Int\n    # return two upper-left and lower-right points of the rectangle\n    Rectangle(p::Position, s::Size) = \n        new(p.y+s.height, p.x, p.y, p.x+s.width)\nend\n\n# check if the two rectangles (A & B) overlap\nfunction overlap(A::Rectangle, B::Rectangle)\n    return A.left < B.right && A.right > B.left &&\n        A.top > B.bottom && A.bottom < B.top\nend\n```", "```py\nfunction collide(A::Thing, B::Thing)\n    println(\"Checking collision of thing vs. thing\")\n    rectA = Rectangle(position(A), size(A))\n    rectB = Rectangle(position(B), size(B))\n    return overlap(rectA, rectB)\nend\n```", "```py\nfunction collide(A::Spaceship, B::Spaceship)\n    println(\"Checking collision of spaceship vs. spaceship\")\n    return true   # just a test\nend \n```", "```py\nfunction collide(A::Asteroid, B::Thing)\n    println(\"Checking collision of asteroid vs. thing\")\n    return true\nend\n\nfunction collide(A::Thing, B::Asteroid)\n    println(\"Checking collision of thing vs. asteroid\")\n    return false\nend\n```", "```py\nfunction collide(A::Asteroid, B::Asteroid)\n    println(\"Checking collision of asteroid vs. asteroid\")\n    return true # just a test\nend\n```", "```py\n# randomly pick two things and check\nfunction check_randomly(things)\n    for i in 1:5\n        two = rand(things, 2)\n        collide(two...)\n    end\nend\n```", "```py\n# explode an array of objects\nfunction explode(things::AbstractVector{Any})\n    for t in things\n        println(\"Exploding \", t)\n    end\nend\n```", "```py\n# explode an array of objects (parametric version)\nfunction explode(things::AbstractVector{T}) where {T}\n    for t in things\n        println(\"Exploding \", t)\n    end\nend\n```", "```py\n# Same function with a more narrow type\nfunction explode(things::AbstractVector{T}) where {T <: Thing}\n    for t in things\n        println(\"Exploding thing => \", t)\n    end\nend\n```", "```py\n# specifying abstract/concrete types in method signature\nfunction tow(A::Spaceship, B::Thing)\n    \"tow 1\"\nend\n```", "```py\n# equivalent of parametric type \nfunction tow(A::Spaceship, B::T) where {T <: Thing}\n    \"tow 2\"\nend\n```", "```py\nfunction group_anything(A::Thing, B::Thing)\n    println(\"Grouped \", A, \" and \", B)\nend\n```", "```py\nfunction group_same_things(A::T, B::T) where {T <: Thing}\n    println(\"Grouped \", A, \" and \", B)\nend\n```", "```py\neltype(things::AbstractVector{T}) where {T <: Thing} = T\n```", "```py\nmodule Vehicle\n# 1\\. Export/Imports\n# 2\\. Interface documentation\n# 3\\. Generic definitions for the interface\n# 4\\. Game logic \nend # module\n```", "```py\n# 1\\. Export/Imports\nexport go!\n```", "```py\n# 2\\. Interface documentation\n# A vehicle (v) must implement the following functions:\n#\n# power_on!(v) - turn on the vehicle's engine\n# power_off!(v) - turn off the vehicle's engine\n# turn!(v, direction) - steer the vehicle to the specified direction \n# move!(v, distance) - move the vehicle by the specified distance\n# position(v) - returns the (x,y) position of the vehicle\n```", "```py\n# 3\\. Generic definitions for the interface\nfunction power_on! end\nfunction power_off! end\nfunction turn! end\nfunction move! end\nfunction position end\n```", "```py\n# 4\\. Game logic \n\n# Returns a travel plan from current position to destination\nfunction travel_path(position, destination)\n    return round(Ï€/6, digits=2), 1000 # just a test\nend\n\n# Space travel logic\nfunction go!(vehicle, destination) \n    power_on!(vehicle)\n    direction, distance = travel_path(position(vehicle), destination)\n    turn!(vehicle, direction)\n    move!(vehicle, distance)\n    power_off!(vehicle)\n    nothing\nend\n```", "```py\n# A vehicle must implement the following functions:\n\n# power_on!(v) - turn on the vehicle's engine\n# power_off!(v) - turn off the vehicle's engine\n# turn!(v, direction) - steer the vehicle to the specified direction \n# move!(v, distance) - move the vehicle by the specified distance\n# position(v) - returns the (x,y) position of the vehicle\n```", "```py\nfunction power_on! end\nfunction power_off! end\nfunction turn! end\nfunction move! end\nfunction position end\n```", "```py\n\"\"\"\nPower on the vehicle so it is ready to go.\n\"\"\"\nfunction power_on! end\n```", "```py\n\"FighterJet is a very fast vehicle with powerful weapons.\"\nmutable struct FighterJet\n\n    \"power status: true = on, false = off\"\n    power::Bool \n\n    \"current direction in radians\"\n    direction::Float64\n\n    \"current position coordinate (x,y)\"\n    position::Tuple{Float64, Float64} \n\nend\n```", "```py\n# Import generic functions\nimport Vehicle: power_on!, power_off!, turn!, move!, position\n\n# Implementation of Vehicle interface\nfunction power_on!(fj::FighterJet)\n    fj.power = true\n    println(\"Powered on: \", fj)\n    nothing\nend\n\nfunction power_off!(fj::FighterJet)\n    fj.power = false\n    println(\"Powered off: \", fj)\n    nothing\nend\n```", "```py\nfunction turn!(fj::FighterJet, direction)\n    fj.direction = direction\n    println(\"Changed direction to \", direction, \": \", fj)\n    nothing\nend\n```", "```py\nfunction move!(fj::FighterJet, distance) \n    x, y = fj.position\n    dx = round(distance * cos(fj.direction), digits = 2)\n    dy = round(distance * sin(fj.direction), digits = 2)\n    fj.position = (x + dx, y + dy)\n    println(\"Moved (\", dx, \",\", dy, \"): \", fj)\n    nothing\nend\n```", "```py\nfunction position(fj::FighterJet)\n    fj.position\nend\n```", "```py\n# 2\\. Interface documentation\n# A vehicle (v) must implement the following functions:\n#\n# power_on!(v) - turn on the vehicle's engine\n# power_off!(v) - turn off the vehicle's engine\n# turn!(v, direction) - steer the vehicle to the specified direction \n# move!(v, distance) - move the vehicle by the specified distance\n# position(v) - returns the (x,y) position of the vehicle\n# engage_wheels!(v) - engage wheels for landing. Optional.\n\n# 3\\. Generic definitions for the interface\n# hard contracts\n# ...\n# soft contracts\nengage_wheels!(args...) = nothing\n```", "```py\n# Landing\nfunction land!(vehicle)\n    engage_wheels!(vehicle)\n    println(\"Landing vehicle: \", vehicle)\nend\n```", "```py\n# trait\nhas_wheels(vehicle) = error(\"Not implemented.\")\n```", "```py\n# Landing (using trait)\nfunction land2!(vehicle)\n    has_wheels(vehicle) && engage_wheels!(vehicle)\n    println(\"Landing vehicle: \", vehicle)\nend\n```"]