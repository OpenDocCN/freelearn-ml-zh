<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0; Building Real-Time Recommendations with Neo4j" id="aid-1MBG21"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8.  Building Real-Time Recommendations with Neo4j </h1></div></div></div><p>The world we live in is a big, interconnected place. Anything and everything that exists in this world is connected together in some way. Relationships and connections exist among the entities that inhabit this world.</p><p>The human brain tries to store or extract information in the form of networks and relations. Perhaps this is a more optimal way of representing data, so that storing and retrieval of information is fast and efficient. What if we have a system that works in a similar way. We can use graphs; they are a systematic and methodical approach to representing data.</p><p>Before we move ahead with this chapter it is essential to understand the background and necessity of graphs.</p><p>Credit for the concept behind the graph theory is given to the 18<sup>th</sup> Century mathematician, Leonhard Euler, who solved the age-old problem known as The Bridges of Konigsberg, which is essentially a pathfinding problem. Although we won't look further at this problem, I suggest that readers attempt to understand how Euler has come up with a new paradigm approach in understanding and solving the problem.</p><p>Graphs are found everywhere in today's world and are one of the most efficient and natural ways of working with data.</p><p>Graph can represent how two or more real world entities, represented as nodes, are connected to each other. We also learn how each of them are related to the other, and how this helps to communicate information in a  fast, efficient , visual way. Since graph systems allow us to express anything in an expressive, structured way, we can apply these systems across domains such as social networks, medicine, science and technology and many more.</p><p>To better understand graph representation, we can take an example of networking on Facebook. Let us assume there are three friends <span class="strong"><strong>John</strong></span>, <span class="strong"><strong>Paul</strong></span> and <span class="strong"><strong>Krish</strong></span>, connected on Facebook. JOHN-KRISH are mutual friends, PAUL-KRISH are mutual friends and PAUL is <code class="literal">
<span class="strong"><strong>FriendOf</strong></span>
</code> of JOHN. How do we represent this information? Take a look at the following diagram:</p><div class="mediaobject"><img src="../Images/image00419.jpeg" alt="Building Real-Time Recommendations with Neo4j"/></div><p style="clear:both; height: 1em;"> </p><p>Don't we feel that the above representation is one of the  most efficient and natural ways of representing data and its relations? In the previous diagram, JOHN-KRISH-PAUL are <span class="emphasis"><em>Nodes</em></span> representing User entities, and <code class="literal">FriendOf</code> arrows are edges which represents the <span class="emphasis"><em>relationships</em></span> between the Nodes. We can also store the demographic details of User Nodes - such as age and details of relationship  (such as FriendSince) - as <span class="emphasis"><em>Properties</em></span> in the Graphs. By applying Graph Theory concepts we can find similar Users in a Network or suggest new Friends to Users within the Friends Network. We shall learn about more on this in later sections.</p><div class="section" title="Discerning different graph databases"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Discerning different graph databases</h1></div></div></div><p>Graph databases have revolutionized the way people discover new products and share information with one another. In the human mind, we remember people, things, places, and so on, as graphs, relations, and networks. When we try to fetch information from these networks we go directly to the required connection or graph and fetch information accurately. In a similar fashion, graph databases allow us to store the users and product information in graphs as nodes and edges (relations). Searching a graph database is fast.</p><p>A graph database is a type of NoSQL database that uses graph theory to store, map and query relationships. Graph databases excel at managing highly connected data and managing complex queries. They are mainly used for analyzing the interconnections between data. Here, the priority is given to relations, so that we don't have to bother with the foreign keys, as in the case of SQL.</p><p>Graph databases mainly consist of nodes and edges, wherein nodes represent the entities and edges the relations between them. The edges are directed lines or arrows that connect the nodes. In the preceding diagram, the circles are the nodes that represent the entities, and the lines connecting the nodes are called the edges - these represent relationships. The orientation of arrows follows the flow of information. By presenting all nodes and links of the graph, it helps users get a global view of the structure.</p><p>Neo4j, FlockDB, AllegroGraph, GraphDB, and InfiniteGraph are some of the graph databases available. Let us have a look at Neo4j, one of the most popular among them, made by Neo Technology.</p><p>Neo4j is so popular because of its strength, swiftness and scalability. It is mainly implemented in Scala and Java. It is available in both the community and enterprise editions. The enterprise edition has the same features as the community one, with additional features like enterprise-grade availability, management and scale-up and scale-out capabilities. In the case of RDBMS, the performance degrades exponentially as the number of relations increases, whereas in Neo4j it is linear. The following image shows the various graph databases:</p><div class="mediaobject"><img src="../Images/image00420.jpeg" alt="Discerning different graph databases"/></div><p style="clear:both; height: 1em;"> </p><div class="section" title="Labeled property graph"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec92"/>Labeled property graph</h2></div></div></div><p>In the introduction section, we have seen an example of a Social Network representation of three friends. This graph representation of data which contains directed connections between entities/nodes, relationships between nodes, and properties associated with nodes and relationships is called a <span class="strong"><strong>labeled property graph data model</strong></span>.</p><p>A labeled property graph data model has the following properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Graph contains nodes and relationships</li><li class="listitem">Nodes may contain properties (key-value pairs)</li><li class="listitem">Nodes may be labeled with one or more labels</li><li class="listitem">Relationships are named and directed, and always have a start and end node</li><li class="listitem">Relationships may also contain properties</li></ul></div><p>Listed concepts are explained in the following section.</p><div class="section" title="Understanding GraphDB core concepts"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec34"/>Understanding GraphDB core concepts</h3></div></div></div><p>The following list enumerates all the elements of a graph:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Nodes</strong></span>: Nodes are the fundamental unit of a graph. Nodes are the vertices in the graph. It mostly refers to the main object that is being referred. Nodes can contains labels and properties. From the story, we can pull three different objects and make three nodes. Two of those are for friends and the other one is for the movie.</li><li class="listitem"><span class="strong"><strong>Labels</strong></span>: Labels are the way to differentiate between the same kinds of objects. Labels are generally given to each node with similar characteristics. Nodes can have more than one label. In the example story, we gave labels of <span class="strong"><strong>PERSON</strong></span> and <span class="strong"><strong>MOVIE</strong></span>. This optimized the graph traversal and also helped in logically querying the model efficiently.</li><li class="listitem"><span class="strong"><strong>Relationships</strong></span>: Relationships are the edge between two nodes. They can be unidirectional and bidirectional. They can also contain the property for which the relationship is being created. Relationships are named and directed, and always have a start and end node. For example, there is a relationship of <span class="emphasis"><em>Friend Of</em></span> between two friends. This shows the connection between different nodes. There is also a relation of <span class="emphasis"><em>Has Watched</em></span> between each of the friends with the movie node.</li><li class="listitem"><span class="strong"><strong>Properties</strong></span>: Properties are key value pairs. Properties can be used for both nodes and relationships. They are used to save the details about a particular node or relationship. In the example, the Person node has the properties of name and age. These properties are used to distinguish different nodes. Relation Has Watched also has the properties of date and rating.</li></ul></div><p>In the following diagram, <span class="strong"><strong>JOHN</strong></span>, <span class="strong"><strong>KRISH</strong></span>, and <span class="strong"><strong>PAUL</strong></span> are nodes that are mapped as User labels. Also, observe the edges that show relations. Both nodes and relations can have properties to further describe them:</p><div class="mediaobject"><img src="../Images/image00421.jpeg" alt="Understanding GraphDB core concepts"/></div><p style="clear:both; height: 1em;"> </p></div></div></div></div>
<div class="section" title="Neo4j"><div class="titlepage" id="aid-1NA0K2"><div><div><h1 class="title"><a id="ch08lvl1sec51"/>Neo4j</h1></div></div></div><p>Neo4j is an open-source Graph Database implemented in Java and Scala. Neo4j implements labeled property graph model efficiently. Like any other database, Neo4j provides ACID transactions, runtime fail-over and cluster support, allowing it for developing production ready applications. This graph database architecture is designed for efficient data storage and faster traversal between Nodes and relations. To work with the data for storing, retrievals and traversal, we use <span class="strong"><strong>CYPHER query language</strong></span> which is Neo4j's query language based on patterns.</p><div class="section" title="Cypher query language"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec93"/>Cypher query language</h2></div></div></div><p>Cypher is the query language for Neo4j that follows SQL-like queries. It is a declarative query language that focuses on what to retrieve from the graph, rather than how to retrieve it. We know that Neo4j property graphs consist of nodes and relationships; though these nodes and relationships are the basic building blocks, the real power of a graph database is to identify the underlying patterns that exist between nodes and relationships. This pattern extraction capability of graph databases, such as Neo4j, helps us to perform complex operations very quickly and efficiently.</p><p>Neo4j's Cypher query language is based on patterns. These patterns are used for matching underlying graph structures so that we may make use of patterns for further processing, such as building recommendation engines, in our case.</p><p>An example of extracting patterns using a Cypher query is shown later. The following Cypher query matches all <span class="emphasis"><em>friendof </em></span>patterns between pairs of users and returns them as a graph:</p><div class="mediaobject"><img src="../Images/image00422.jpeg" alt="Cypher query language"/></div><p style="clear:both; height: 1em;"> </p><div class="section" title="Cypher query basics"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec35"/>Cypher query basics</h3></div></div></div><p>Before we go into building recommendations using Neo4j, let us look into the basics of Cypher query. As we mentioned earlier, Cypher is the query language for Neo4j that follows SQL-like queries. Being a declarative language, Cypher focuses on what to retrieve from the graph rather than how to retrieve it. The key principles and capabilities of Cypher are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Cypher matches key patterns between nodes and relationships in the graph to extract information from the graph.</li><li class="listitem">Cypher has many capabilities similar to SQL such as create, delete, and update. These operations are applied to nodes and relationships to fetch information.</li><li class="listitem">Indexing and constraints similar to SQL are also present.</li></ul></div></div></div><div class="section" title="Node syntax"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec94"/>Node syntax</h2></div></div></div><p>Cypher uses pairs of parentheses <code class="literal">() </code>or pairs of parenthesis with text inside to represent nodes. Furthermore, we can assign labels, and properties of nodes are given as key-value pairs.</p><p>Look at the following example to understand the concept better. In the following queries, node is represented using <code class="literal">()</code> or <code class="literal">(user)</code>, label is represented with <code class="literal">u</code>, <code class="literal">(u:user)</code> and properties of the node are assigned with key-value pairs as <code class="literal">(u:user{name:'Toby'}) </code>:</p><pre class="programlisting">() 
(user) 
(u:user) 
(u:user{name:'Toby'}) 
</pre></div><div class="section" title="Relationship syntax"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec95"/>Relationship syntax</h2></div></div></div><p>Cypher uses <code class="literal">-[]-&gt;</code> to represent relationships between two nodes. These relationships allow developers to represent complex relations between nodes, making them easier to read or understand.</p><p>Let us look at the following example:</p><pre class="programlisting"> -[]-&gt; 
(user) -[f:friendof]-&gt;(user) 
(user) -[f:friendof {since: 2016}]-&gt;(user) 
</pre><p>In the preceding example, a <code class="literal">friendof</code> relationship is established between two user nodes and the relationship is having property <code class="literal">since:2016</code>.</p></div><div class="section" title="Building your first graph"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec96"/>Building your first graph</h2></div></div></div><p>Now that we saw the node syntax and relationship syntax, let us practice what we have learned so far by creating a Facebook social network graph similar to the following diagram:</p><div class="mediaobject"><img src="../Images/image00423.jpeg" alt="Building your first graph"/></div><p style="clear:both; height: 1em;"> </p><p>In order to create the above graph, we need following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create 3 nodes Person with labels JOHN, PAUL, KRISH</li><li class="listitem">Create relationships between 3 Nodes</li><li class="listitem">Set properties</li><li class="listitem">Display results used with all the patterns</li></ol><div style="height:10px; width: 1px"/></div><div class="section" title="Creating nodes"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec36"/>Creating nodes</h3></div></div></div><p>We use the <code class="literal">CREATE</code> clause to create graph elements such as nodes and relations. The below example shows us how to create a single node Person labeled as john and having the property name:<code class="literal">JOHN</code>. When we run the below query in Neo4j browser, we get the graph as shown in the following screenshot:</p><pre class="programlisting">CREATE (john:Person {name:"JOHN"})  RETURN  john 
</pre><div class="mediaobject"><img src="../Images/image00424.jpeg" alt="Creating nodes"/></div><p style="clear:both; height: 1em;"> </p><div class="note" title="Note"><h3 class="title"><a id="note18"/>Note</h3><p>The RETURN clause helps to return the result set, namely Node - PERSON</p></div><p>Instead of just creating one node, we can create multiple nodes as follows:</p><pre class="programlisting">CREATE (paul:Person {name:"PAUL"})  
CREATE (krish:Person {name:"KRISH"})  
</pre><p>Earlier code will create three nodes, and Person labelled <code class="literal">JOHN</code>, <code class="literal">PAUL</code>, <code class="literal">KRISH</code>. Let's see what we have created so far; to see the results we have to use <code class="literal">MATCH</code> clause. <code class="literal">MATCH</code> clause will check for the required patterns and return the retrieved patterns using <code class="literal">RETURN</code> clause. In the below query, <code class="literal">MATCH</code> will look for patterns such as Person nodes with labels names <code class="literal">k</code>,<code class="literal">p</code>,<code class="literal">j</code> and their corresponding labels:</p><pre class="programlisting">MATCH(k:Person{name:'KRISH'}),(p:Person{name:'PAUL'}),(j:Person{name:'JOHN'}) RETURN k,p,j 
</pre><div class="mediaobject"><img src="../Images/image00425.jpeg" alt="Creating nodes"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Creating relationships"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec37"/>Creating relationships</h3></div></div></div><p>With creation of nodes we are half done. Now, let's complete the remaining portion by creating relations.</p><p>Instructions for creating relationships are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Extract the nodes from the database using the <code class="literal">MATCH</code> clause</li><li class="listitem">Create the required relationships between the <code class="literal">Persons</code> using the <code class="literal">CREATE</code> clause</li></ul></div><p>In the following query, we are extracting all the <code class="literal">Person</code> nodes and then creating relationships called <code class="literal">FRIENDOF</code> between the nodes:</p><pre class="programlisting">MATCH(k:Person{name:'KRISH'}),(p:Person{name:'PAUL'}),(j:Person{name:'JOHN'})  
CREATE (k)-[:FRIENDOF]-&gt;(j) 
CREATE (j)-[:FRIENDOF]-&gt;(k) 
CREATE (p)-[:FRIENDOF]-&gt;(j) 
CREATE (p)-[:FRIENDOF]-&gt;(k) 
CREATE (k)-[:FRIENDOF]-&gt;(p) 
</pre><p>The following screenshot shows the result displayed when we run the earlier query:</p><div class="mediaobject"><img src="../Images/image00426.jpeg" alt="Creating relationships"/></div><p style="clear:both; height: 1em;"> </p><p>Now we have created all the required nodes and relationships. To see what we have achieved, run the following query, which displays Nodes and relationships between the nodes:</p><pre class="programlisting">match(n:Person)-[f:FRIENDOF]-&gt;(q:Person) return f 
</pre><div class="mediaobject"><img src="../Images/image00427.jpeg" alt="Creating relationships"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Setting properties to relations"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec38"/>Setting properties to relations</h3></div></div></div><p>The final step is to set properties to node labels and relationships, and is explained as follows:</p><p>We use the <code class="literal">SET</code> clause to set the properties. For setting properties to relations we need to follow two steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extract all the relations , <code class="literal">FRIENDOF</code></li><li class="listitem">Use the <code class="literal">SET</code> clause to set the properties to these relations</li></ol><div style="height:10px; width: 1px"/></div><p>In the following example, we set the properties to the relation <code class="literal">FRIENDOF</code> between <code class="literal">KRISH</code> and <code class="literal">PAUL</code> with the property <code class="literal">friendsince</code> as follows:</p><pre class="programlisting">MATCH (k:Person{name:'KRISH'})-[f1:FRIENDOF]-&gt; (p:Person{name:'PAUL'}), 
(k1:Person{name:'KRISH'})&lt;-[f2:FRIENDOF]- (p1:Person{name:'PAUL'}) 
SET f1.friendsince = '2016', f2.friendsince = '2015' 
</pre><div class="mediaobject"><img src="../Images/image00428.jpeg" alt="Setting properties to relations"/></div><p style="clear:both; height: 1em;"> </p><div class="note" title="Note"><h3 class="title"><a id="note19"/>Note</h3><p>In the previous query ,<code class="literal"> ()-[]-&gt;</code> pattern extracts relation <code class="literal">Krish</code> is <code class="literal">friendOfPaul</code> and <code class="literal">() &lt;- [] - </code>pattern extracts relation <code class="literal">Paul</code> is <code class="literal">friendOf</code> of <code class="literal">Krish.</code></p></div><p>Let's display the results so far as follows:</p><pre class="programlisting">match(n:Person)-[f:FRIENDOF]-&gt;(q:Person) return f 
</pre><p>The following diagram shows the nodes, relationships and properties added in the previous query.</p><div class="mediaobject"><img src="../Images/image00429.jpeg" alt="Setting properties to relations"/></div><p style="clear:both; height: 1em;"> </p><p>In the preceding diagram we can see that for <code class="literal">KRISH</code> and <code class="literal">PAUL</code> the property for the <code class="literal">FRIENDOF</code> relation has been set as <code class="literal">friendsince</code>.</p><p>Similarly, we can set the properties to the nodes as follows:</p><pre class="programlisting">MATCH(k:Person{name:'KRISH'}),(p:Person{name:'PAUL'}),(j:Person{name:'JOHN'})  
SET k.age = '26' ,p.age='28', j.age='25',k.gender='M',p.gender='M',j.gender='M' 
</pre><div class="mediaobject"><img src="../Images/image00430.jpeg" alt="Setting properties to relations"/></div><p style="clear:both; height: 1em;"> </p><p>Let's verify the results here using the following query, which displays nodes, relationships, labels, properties to nodes, and relationships:</p><pre class="programlisting">match(n:Person)-[f:FRIENDOF]-&gt;(q:Person) return f 
</pre><div class="mediaobject"><img src="../Images/image00431.jpeg" alt="Setting properties to relations"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Loading data from csv"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec39"/>Loading data from csv</h3></div></div></div><p>In the previous section, we created nodes, relationships, and properties manually. Most of the time, we create nodes by loading data from csv files. To achieve this, we use the <code class="literal">LOAD CSV</code> command readily available in Neo4j, to load data into the Neo4j browser.</p><p>The following screenshot shows the dataset we will be using for this section which contains user-movie-rating data.</p><div class="mediaobject"><img src="../Images/image00432.jpeg" alt="Loading data from csv"/></div><p style="clear:both; height: 1em;"> </p><p>Query below to load csv data given below:</p><pre class="programlisting">LOAD CSV WITH HEADERS FROM 'file:///C:/ Neo4J/test.csv' AS RATINGSDATA RETURN RATINGSDATA 
</pre><p>In the preceding query:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><strong>HEADERS</strong></span> keyword allows us to ask the query engine to consider the first row as header information</li><li class="listitem">The <span class="strong"><strong>WITH</strong></span> keyword is similar to the return keyword; it separate portions of the query explicitly and allows us to define which values or variables we should carry forward to the next parts of the query</li><li class="listitem">The<span class="strong"><strong> AS </strong></span>keyword is used to create an alias name to variables</li></ul></div><p>When we run the above query, two things happen:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>CSV</strong></span> data will be loaded to the graph database</li><li class="listitem">The<span class="strong"><strong> RETURN</strong></span> clause will display the loaded data, as shown in the following screenshot:<div class="mediaobject"><img src="../Images/image00433.jpeg" alt="Loading data from csv"/></div><p style="clear:both; height: 1em;"> </p></li></ul></div></div></div></div>
<div class="section" title="Neo4j Windows installation"><div class="titlepage" id="aid-1O8H62"><div><div><h1 class="title"><a id="ch08lvl1sec52"/>Neo4j Windows installation</h1></div></div></div><p>In this section, we will see how to install Neo4j for Windows. We can download the Neo4j Windows installer from the following URL:</p><p><a class="ulink" href="https://neo4j.com/download/">https://neo4j.com/download/</a></p><div class="mediaobject"><img src="../Images/image00434.jpeg" alt="Neo4j Windows installation"/></div><p style="clear:both; height: 1em;"> </p><p>Once the installer is downloaded, click on the installer to get the following screen to proceed with installation:</p><div class="mediaobject"><img src="../Images/image00435.jpeg" alt="Neo4j Windows installation"/></div><p style="clear:both; height: 1em;"> </p><p>After successful installation, start the Neo4j Community Edition. For the first time you will see the following screen, asking you to choose a directory to store the graph database, and then click on <span class="strong"><strong>Start</strong></span>:</p><div class="mediaobject"><img src="../Images/image00436.jpeg" alt="Neo4j Windows installation"/></div><p style="clear:both; height: 1em;"> </p><p>In our case we have chosen the default directory where the <code class="literal">graphdb</code> database is created as follows:</p><pre class="programlisting">C:\Users\Suresh\Documents\Neo4J\default.graphdb 
</pre><p>After we click the start button, as shown in the preceding screenshot, start Neo4j will be started and will be displayed as below. We are now ready to start working on Neo4j.</p><div class="mediaobject"><img src="../Images/image00437.jpeg" alt="Neo4j Windows installation"/></div><p style="clear:both; height: 1em;"> </p><p>Now that we have started Neo4j, we can access it from the browser by using:</p><p><code class="literal">http://localhost:7474</code></p></div>
<div class="section" title="Installing Neo4j on the Linux platform" id="aid-1P71O1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec53"/>Installing Neo4j on the Linux platform</h1></div></div></div><p>In this section we learn about downloading and installing Neo4j on the CentOS Linux platform.</p><div class="section" title="Downloading Neo4j"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec97"/>Downloading Neo4j</h2></div></div></div><p>We can download the latest version of the Neo4j 3 Linux source file from the Neo4j home page:</p><p><a class="ulink" href="https://neo4j.com/">https://Neo4J.com/</a></p><p>Click on the <span class="strong"><strong>Download Neo4J</strong></span> button on the page shown as follows:</p><div class="mediaobject"><img src="../Images/image00438.jpeg" alt="Downloading Neo4j"/></div><p style="clear:both; height: 1em;"> </p><div class="note" title="Note"><h3 class="title"><a id="note20"/>Note</h3><p>Alternatively you can download it directly from the following URL:<a class="ulink" href="http://info.neo4j.com/download-thanks.html?edition=community&amp;release=3.0.6&amp;flavour=unix&amp;_ga=1.171681440.1829638272.1475574249">http://info.Neo4J.com/download-thanks.html?edition=community&amp;release=3.0.6&amp;flavour=unix&amp;_ga=1.171681440.1829638272.1475574249</a></p></div><p>This will download a <code class="literal">tar</code> file - <code class="literal">Neo4J-community-3.0.6-unix.tar.gz</code> as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00439.jpeg" alt="Downloading Neo4j"/></div><p style="clear:both; height: 1em;"> </p><div class="note" title="Note"><h3 class="title"><a id="note21"/>Note</h3><p>We can find the developer resources at <a class="ulink" href="https://Neo4J.com/developer/get-started/">https://Neo4J.com/developer/get-started/</a></p></div></div><div class="section" title="Setting up Neo4j"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec98"/>Setting up Neo4j</h2></div></div></div><p>Extract the <code class="literal">tar</code> file and you will get a folder called <code class="literal">Neo4J-community-3.0.6</code> containing the following files:</p><div class="mediaobject"><img src="../Images/image00440.jpeg" alt="Setting up Neo4j"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Starting Neo4j from the command line"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec99"/>Starting Neo4j from the command line</h2></div></div></div><p>Make sure you install Java 8 in your PC, as Neo4j 3.0 version requires Java 8. Check the Neo4j requirements before you install.</p><p>Once you have installed Java 8 then we can go ahead and run our Neo4j instance, but before that, let us set the <code class="literal">Neo4J</code> path in the <code class="literal">bashrc</code> file as follows:</p><pre class="programlisting">gedit ~/.bashrc 
export NEO4J_PATH=/home/1060929/Softwares/Neo4J/Neo4J-community-3.0.6 
export PATH=$PATH:$NEO4J_PATH/bin 
source ~/.bashrc 
</pre><p>We Start the <code class="literal">Neo4j</code> in command line using the following command:</p><pre class="programlisting">Neo4J start 
</pre><div class="mediaobject"><img src="../Images/image00441.jpeg" alt="Starting Neo4j from the command line"/></div><p style="clear:both; height: 1em;"> </p><p>We can observe that the Neo4j has been started and we can access the graph <code class="literal">dbcapabilites</code> from the browser at <code class="literal">http://localhost:7474/</code></p><p>For the first time, running Neo4j in the browser requires you to set the <span class="strong"><strong>Username</strong></span> and <span class="strong"><strong>Password</strong></span>:</p><div class="mediaobject"><img src="../Images/image00442.jpeg" alt="Starting Neo4j from the command line"/></div><p style="clear:both; height: 1em;"> </p><p>Once we have set the credentials it will redirect to the following page:</p><div class="mediaobject"><img src="../Images/image00443.jpeg" alt="Starting Neo4j from the command line"/></div><p style="clear:both; height: 1em;"> </p><p>If you are using it for the first time, spend some time on the browser to get acquainted with its features and explore the different options available on the left-hand panel. Enter the following command in the browser to display the connection details:</p><pre class="programlisting">:server connect 
</pre><div class="mediaobject"><img src="../Images/image00444.jpeg" alt="Starting Neo4j from the command line"/></div><p style="clear:both; height: 1em;"> </p><pre class="programlisting">basic usage :  
getting help on Neo4J in the browser: 
:help 
</pre></div></div>
<div class="section" title="Building recommendation engines"><div class="titlepage" id="aid-1Q5IA2"><div><div><h1 class="title"><a id="ch08lvl1sec54"/>Building recommendation engines</h1></div></div></div><p>In this section, we will learn how to generate collaborative filtering recommendations using three approaches. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A simple count of co-rated movies</li><li class="listitem">Euclidean distance</li><li class="listitem">Cosine similarity</li></ul></div><p>I would like to highlight a point at this junction. In earlier chapters, we learnt that for building recommendation engines using heuristic approaches, we used similarity calculations such as Euclidean distance/cosine distance. It is not necessary to use only these approaches; we are free to choose our own way of computing the closeness or extracting the similarity between two users just by simple counts as well, for example, similarity between two users can be extracted just by counting the number of the same movies two users have co-rated. If more movies have been co-rated by two users then we may assume that they are similar to each other. If the count of co-rated movies between two people is less then we may assume that their tastes are different.</p><p>This assumption is taken to build our first recommendation engine and is explained as follows:</p><p>For building a collaborative movie recommendation engine, we will build a system based on past movie rating behavior of users. The steps we follow can be summarized as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Loading data into an environment</li><li class="listitem">Extracting relations and extracting similarity between users</li><li class="listitem">Recommendation step</li></ol><div style="height:10px; width: 1px"/></div><div class="section" title="Loading data into Neo4j"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec100"/>Loading data into Neo4j</h2></div></div></div><p>Though we have multiple ways of loading data into Neo4j, we use the <code class="literal">Load CSV</code> option to import the data into the browser tool. The following diagram shows the workflow of the process of loading the CSV process:</p><div class="mediaobject"><img src="../Images/image00445.jpeg" alt="Loading data into Neo4j"/></div><p style="clear:both; height: 1em;"> </p><p>The dataset we use for this section is the small sample data set containing Users-Movies-ratings, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00446.jpeg" alt="Loading data into Neo4j"/></div><p style="clear:both; height: 1em;"> </p><p>Let's load the MovieLens data into the Neo4j browser tool as follows:</p><pre class="programlisting">LOAD CSV WITH HEADERS FROM file:///ratings.csv AS line 
</pre><p>Now let's create Users and Movies as nodes and the ratings given by Users to Movies as the relations.</p><p>The <code class="literal">MERGE</code> clause will find the query patterns in the data, and if it doesn't find any it will create one. In the following example below, first it look for a User Node (pattern) and then creates one if it doesn't exist. Since we have just loaded the data into GraphDB, we need to create nodes and establish relationships. Following code will first looks for the mentioned nodes and relationships; if not found it will create new nodes and relationships:</p><pre class="programlisting">LOAD CSV WITH HEADERS FROM file:///C:/Neo4J/test.csv AS line MERGE (U:USER {USERID : line.UserID}) 
WITH line, U 
MERGE (M:MOVIE {ITEMID : line.ItemId}) 
WITH line,M,U 
MERGE (U)-[:hasRated{RATING:line.Rating}]-&gt;(M); 
</pre><p>When we run the previous query, nodes, relationships, and properties will be created as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00447.jpeg" alt="Loading data into Neo4j"/></div><p style="clear:both; height: 1em;"> </p><p>Now, we shall understand each line one by one to make our understanding more clear.</p><p>Merge will create <code class="literal">USER</code> Node from <code class="literal">UserID</code> columns from the original data:</p><pre class="programlisting">MERGE (U:USER {USERID : line.UserID}) 
</pre><p>The <code class="literal">With </code>command will take the <code class="literal">User</code> node and line object to the next part of the query as follows:</p><pre class="programlisting">WITH line, U 
</pre><p>Now we will create <code class="literal">Movie</code> Node using <code class="literal">MERGE</code> and <code class="literal">line.ItemId</code> object as follows:</p><pre class="programlisting">MERGE (M:MOVIE {ITEMID : line.ItemId}) 
</pre><p>We carry forward the Movie, User nodes, and line object to the next part of the query as follows:</p><pre class="programlisting">WITH line,M,U 
</pre><p>We create a relation between <code class="literal">USER</code> node and <code class="literal">MOVIE</code> node as follows:</p><pre class="programlisting">MERGE (U)-[:hasRated{RATING:line.Rating}]-&gt;(M); 
</pre><p>Now that we have loaded the data into Neo4j, we can visualize the movie ratings data with users, movies and ratings as follows:</p><pre class="programlisting">MATCH (U:USER)-[R:hasRated]-&gt;(M:MOVIE) RETURN R 
</pre><p>In the following image, all users are created in green color, and movies are created in red color. We can also see the relationships as arrows with directions.</p><div class="mediaobject"><img src="../Images/image00448.jpeg" alt="Loading data into Neo4j"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Generating recommendations using Neo4j"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec101"/>Generating recommendations using Neo4j</h2></div></div></div><p>We have now created all the required graphs for building our first recommendation engine using Neo4j. Let's get started.</p><div class="note" title="Note"><h3 class="title"><a id="note22"/>Note</h3><p>In the following query <code class="literal">COUNT()</code> function will count the number of instances, <code class="literal">collect()</code> will.</p></div><p>The following screenshot will return movie recommendations to the sample user <code class="literal">'TOBY'</code>:</p><pre class="programlisting">match(u1:USER)-[:hasRated]-&gt;(i1:MOVIE)&lt;-[:hasRated]-(u2:USER)- [:hasRated]-&gt;(i2:MOVIE)  
with u1,u2, count(i1) as cnt , collect(i1) as Shareditems,i2 
where not(u1-[:hasRated]-&gt;i2) and u1.USERID='Toby' and cnt&gt; 2  
return distinct i2.ITEMID as Recommendations 
</pre><p>The following query shows the recommendations made to Toby when we run the earlier query:</p><div class="mediaobject"><img src="../Images/image00449.jpeg" alt="Generating recommendations using Neo4j"/></div><p style="clear:both; height: 1em;"> </p><p>The concept behind making recommendations in the previous query is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Extract pair of users who have rated the same movies</li><li class="listitem">Take the count of commonly rated movies by each pair of users</li><li class="listitem">The higher the commonly rated movie count, the more similar two users are to each other</li><li class="listitem">The final step is to extract all the movies which similar users have rated, but which have not been rated by the active user, and suggest these new movies as recommendations to the active user</li></ul></div><p>Let's understand the query we just saw step by step:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">In line one, for each user (say <code class="literal">USER1</code>) who has rated a movie (say <code class="literal">MOVIE1</code>), select all the users (say <code class="literal">USER2</code>) who have also rated <code class="literal">MOVIE1</code>. For this <code class="literal">USER2</code>, also extract other movies rated by him, apart from <code class="literal">MOVIE1</code>.</li><li class="listitem">In line two, we carry similar users (<code class="literal">u1</code>,<code class="literal">u2</code>), calculating the count of co-rated movies by <code class="literal">u1</code>,<code class="literal">u2</code>, and extracting shared/co-rated movies by <code class="literal">u1</code>,<code class="literal">u2</code> to the next part of the query.</li><li class="listitem">In line three, we now apply a filter where we choose those movies that are not being rated by <code class="literal">u1</code> and the count of co-rated movies greater than two.</li><li class="listitem">In line 4 we return new movies rated by similar users to <code class="literal">u1</code> as recommendations.</li></ul></div></div><div class="section" title="Collaborative filtering using the Euclidean distance"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec102"/>Collaborative filtering using the Euclidean distance</h2></div></div></div><p>In the previous section, we saw how to build recommendation engines using a simple count-based approach for identifying similar users, and then we chose movies from similar users which the active user has not rated or recommended.</p><p>In this section, instead of computing the similarity between two users based on the simple count of co-rated movies, let us make use of the rating information and calculate the Euclidean distance, to come up with the similarity score.</p><p>The following cypher query will generate recommendations for the user, Toby, based on the Euclidean similarity:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step is to extract co-rated users by movies and calculate the Euclidean distance between co-rated users as follows:<pre class="programlisting">        MATCH (u1:USER)-[x:hasRated]-&gt; (b:MOVIE)&lt;-[y:hasRated]-
          (u2:USER) 
        WITH count(b) AS CommonMovies, u1.username AS user1,
          u2.username AS user2, u1, u2,
        collect((toFloat(x.RATING)-toFloat(y.RATING))^2) AS ratings,
        collect(b.name) AS movies
        WITH CommonMovies, movies, u1, u2, ratings
        MERGE (u1)-[s:EUCSIM]-&gt;(u2) SET s.EUCSIM = 1-   
          (SQRT(reduce(total=0.0, k in extract(i in ratings | 
            i/CommonMovies) | total+k))/4)
</pre><div class="note" title="Note"><h3 class="title"><a id="note23"/>Note</h3><p>In this code we are using <code class="literal">reduce()</code> and <code class="literal">extract()</code> to calculate the Euclidean distance. In order to apply mathematical calculations, we have changed the values to floating point numbers using the <code class="literal">float()</code> function in the following query.</p></div><p>To see the Euclidean distance values between pairs of users, run the below query:</p><pre class="programlisting">        MATCH (u1:USER)-[x:hasRated]-&gt; (b:MOVIE)&lt;-[y:hasRated]-
          (u2:USER) 
        WITH count(b) AS CommonMovies, u1.username AS user1,    
          u2.username AS user2, u1, u2, 
        collect((toFloat(x.RATING)-toFloat(y.RATING))^2) AS ratings, 
        collect(b.name) AS movies 
        WITH CommonMovies, movies, u1, u2, ratings 
        MERGE (u1)-[s:EUCSIM]-&gt;(u2) SET s.EUCSIM = 1-
          (SQRT(reduce(total=0.0, k in extract(i in ratings |   
            i/CommonMovies) | total+k))/4) return s as SIMVAL,  
              u1.USERID as USER,u2.USERID as Co_USER;</pre><div class="mediaobject"><img src="../Images/image00450.jpeg" alt="Collaborative filtering using the Euclidean distance"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">In the second step, we calculate the Euclidean distance using the formula <span class="emphasis"><em>sqrt(sum((R1-R2)*(R1-R2)))</em></span>, where <span class="emphasis"><em>R1</em></span> is the rating given by <code class="literal">Toby</code> for a <code class="literal">movie1</code> and <span class="emphasis"><em>R2</em></span> is the other co-rated user's rating for the same <code class="literal">movie1</code>, and we take the top three similar users, as follows:<pre class="programlisting">        MATCH (p1:USER {USERID:'Toby'})-[s:EUCSIM]-(p2:USER) 
        WITH p2, s.EUCSIM AS sim 
        ORDER BY sim DESC 
        RETURN distinct p2.USERID AS CoReviewer, sim AS similarity 
</pre></li><li class="listitem">The final step is to suggest or recommend non-rated movies from the top three similar users to <code class="literal">Toby</code> as follows:<pre class="programlisting">        MATCH (b:USER)-[r:hasRated]-&gt;(m:MOVIE), (b)-[s:EUCSIM]-(a:USER  
          {USERID:'Toby'}) 
        WHERE NOT((a)-[:hasRated]-&gt;(m)) 
        WITH m, s.EUCSIM AS similarity, r.RATING AS rating 
        ORDER BY m.ITEMID, similarity DESC 
        WITH m.ITEMID AS MOVIE, COLLECT(rating) AS ratings 
        WITH MOVIE, REDUCE(s = 0, i IN ratings |toInt(s) +  
          toInt(i))*1.0 / size(ratings) AS reco 
        ORDER BY recoDESC 
        RETURN MOVIE AS MOVIE, reco AS Recommendation 
</pre><div class="mediaobject"><img src="../Images/image00451.jpeg" alt="Collaborative filtering using the Euclidean distance"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div style="height:10px; width: 1px"/></div><p>Let us explain the preceding query in detail as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">As we explained in the first step, we extract co-rated movies by users along with their ratings as follows:<p>In our example, Toby has rated three movies: Snakes on a Planet, Superman Returns, and You Me and Dupree. Now we have to extract other common users who have co-rated the same three movies as Toby. For this, we use the following query:</p><pre class="programlisting">        MATCH (u1:USER{USERID:'Toby'})-[x:hasRated]-&gt; (b:MOVIE)&lt;- 
          [y:hasRated]-(u2:USER)
        return u1, u2,
        collect(b.ITEMID) AS CommonMovies,
        collect(x.RATING) AS user1Rating,
        collect(y.RATING) AS user2Rating</pre><div class="mediaobject"><img src="../Images/image00452.jpeg" alt="Collaborative filtering using the Euclidean distance"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">The second step is to calculate the Euclidean distance between the ratings given to each co-rated movie by the other users, to the movies of Toby, and this is calculated using the following query:<pre class="programlisting">        MATCH (u1:USER)-[x:hasRated]-&gt; (b:MOVIE)&lt;-[y:hasRated]- 
          (u2:USER) 
        WITH count(b) AS CommonMovies, u1.username AS user1, 
          u2.username AS user2, u1, u2, 
        collect((toFloat(x.RATING)-toFloat(y.RATING))^2) AS ratings, 
        collect(b.name) AS movies 
        WITH CommonMovies, movies, u1, u2, ratings 
        MERGE (u1)-[s:EUCSIM]-&gt;(u2) SET s.EUCSIM = 1- 
          (SQRT(reduce(total=0.0, k in extract(i in ratings |  
            i/CommonMovies) | total+k))/4) 
</pre><p>In the preceding query, we create and merge new relationships between each of the co-rated users to show the distance between two users, using the MERGE clause. Also, we set the property of the relationship as EUCSIM (which represents the Euclidean distance between each of the co-rated users) using the SET clause.</p><p>Now that we have created new relations and set the values of the similarity distances, let us view the results as given by the following query:</p><pre class="programlisting">        MATCH (p1:USER {USERID:'Toby'})-[s:EUCSIM]-(p2:USER) 
        WITH p2, s.EUCSIM AS sim 
        ORDER BY sim DESC 
        RETURN distinct p2.USERID AS CoReviewer, sim AS similarity 
</pre><p>The following screenshot shows the similarity value for Toby with other users:</p><div class="mediaobject"><img src="../Images/image00453.jpeg" alt="Collaborative filtering using the Euclidean distance"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">The final step is to predict the non-rated movies by Toby, and then recommend the top-rating predicted items. To achieve this, we employ the following steps:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Extract the movies rated by similar users to Toby, but not rated by Toby himself</li><li class="listitem">Take the ratings given for all the non-rated movies and average them, to predict the ratings that Toby might give to these movies.</li><li class="listitem">Display the sorted results as per the predicted rating, in descending order.</li></ul></div><p>To achieve this, use the following query:</p><pre class="programlisting">        MATCH (b:USER)-[r:hasRated]-&gt;(m:MOVIE), (b)-[s:EUCSIM]-(a:USER  
          {USERID:'Toby'}) 
        WHERE NOT((a)-[:hasRated]-&gt;(m)) 
        WITH m, s.EUCSIM AS similarity, r.RATING AS rating ORDER BY     
          similarity DESC 
        WITH m.ITEMID AS MOVIE, COLLECT(rating) AS ratings 
        WITH MOVIE, REDUCE(s = 0, i IN ratings |toInt(s) + 
          toInt(i))*1.0 / size(ratings) AS reco 
        ORDER BY reco DESC 
        RETURN MOVIE AS MOVIE, reco AS Recommendation 
</pre><div class="mediaobject"><img src="../Images/image00454.jpeg" alt="Collaborative filtering using the Euclidean distance"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div style="height:10px; width: 1px"/></div><p>Let us understand the recommendations query line-by-line as follows:</p><p>The following query fetches the patterns of all the users who are similar to Toby, and all the movies rated by similar users, as follows:</p><pre class="programlisting">MATCH (b:USER)-[r:hasRated]-&gt;(m:MOVIE), (b)-[s:EUCSIM]-(a:USER {USERID:'Toby'}) 
</pre><p>The <code class="literal">WHERE NOT</code> clause will filter out all the movies that have been rated by similar users but not by Toby, as follows:</p><pre class="programlisting">WHERE NOT((a)-[:hasRated]-&gt;(m)) 
</pre><p>Movies, similarity values and ratings given by the co-users are passed to the next part of the query using the <code class="literal">WITH</code> clause and the results are ordered by descending similarity value as follows:</p><pre class="programlisting">WITH m, s.EUCSIM AS similarity, r.RATING AS rating ORDER BY similarity DESC 
</pre><p>After sorting the results based on the similarity values, we further allow values, such as movie name and ratings, to the next part of the query using the <code class="literal">WITH</code> clause, as follows:</p><pre class="programlisting">WITH m.ITEMID AS MOVIE, COLLECT(rating) AS ratings 
</pre><p>This is the main step for recommending movies to Toby, predicting the ratings for non-rated movies by Toby by taking the average of movie ratings by similar users to Toby, and using the <code class="literal">REDUCE</code> clause, as follows:</p><pre class="programlisting">WITH MOVIE, REDUCE(s = 0, i IN ratings |toInt(s) + toInt(i))*1.0 / size(ratings) AS reco 
</pre><p>Finally, we sort the final results and return the top movies to Toby as follows:</p><pre class="programlisting">ORDER BY recoDESC 
RETURN MOVIE AS MOVIE, reco AS Recommendation 
</pre></div><div class="section" title="Collaborative filtering using Cosine similarity"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec103"/>Collaborative filtering using Cosine similarity</h2></div></div></div><p>Now that we have seen recommendations based on simple count and Euclidean distances for identifying similar users, let us use Cosine similarity to calculate the similarity between users.</p><p>The following query is used to create a new relation called similarity between users:</p><pre class="programlisting">MATCH (p1:USER)-[x:hasRated]-&gt;(m:MOVIE)&lt;-[y:hasRated]-(p2:USER) 
WITH SUM(toFloat(x.RATING) * toFloat(y.RATING)) AS xyDotProduct, 
SQRT(REDUCE(xDot = 0.0, a IN COLLECT(toFloat(x.RATING)) | xDot +toFloat(a)^2)) AS xLength, 
SQRT(REDUCE(yDot = 0.0, b IN COLLECT(toFloat(y.RATING)) | yDot + toFloat(b)^2)) AS yLength, 
p1, p2 
MERGE (p1)-[s:SIMILARITY]-(p2) 
SET s.similarity = xyDotProduct / (xLength * yLength) 
</pre><div class="mediaobject"><img src="../Images/image00455.jpeg" alt="Collaborative filtering using Cosine similarity"/></div><p style="clear:both; height: 1em;"> </p><p>Let us explore the similarity values as follows:</p><pre class="programlisting">match(u:USER)-[s:SIMILARITY]-&gt;(u2:USER) return s; 
</pre><div class="mediaobject"><img src="../Images/image00456.jpeg" alt="Collaborative filtering using Cosine similarity"/></div><p style="clear:both; height: 1em;"> </p><p>We calculate the similar users for Toby as follows:</p><p>For the active user Toby, let us display the similarity values with respect to other users as follows:</p><pre class="programlisting">MATCH (p1:USER {USERID:'Toby'})-[s:SIMILARITY]-(p2:USER) 
WITH p2, s.similarity AS sim 
ORDER BY sim DESC 
LIMIT 5 
RETURN p2.USERID AS Neighbor, sim AS Similarity 
</pre><p>The following image displays the results by running the previous Cypher query; the results show the similarity value for Toby, with respect to other users.</p><div class="mediaobject"><img src="../Images/image00457.jpeg" alt="Collaborative filtering using Cosine similarity"/></div><p style="clear:both; height: 1em;"> </p><p>Now let us start our recommendations of movies to Toby. The recommendation process is very similar to what we have done in the previous approach, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Extract movies rated by similar users to Toby but not rated by Toby himself</li><li class="listitem">Take the ratings given for all the non-rated movies and average them to predict the ratings that Toby might give to these movies</li><li class="listitem">Display the sorted results as per the predicted rating, in descending order</li></ul></div><p>We use the following code:</p><pre class="programlisting">MATCH (b:USER)-[r:hasRated]-&gt;(m:MOVIE), (b)-[s:SIMILARITY]-(a:USER  
  {USERID:'Toby'}) 
WHERE NOT((a)-[:hasRated]-&gt;(m)) 
WITH m, s.similarity AS similarity, r.RATING AS rating 
ORDER BY m.ITEMID, similarity DESC 
WITH m.ITEMID AS MOVIE, COLLECT(rating) AS ratings 
WITH MOVIE, REDUCE(s = 0, i IN ratings |toInt(s) + toInt(i))*1.0 / 
  size(ratings) AS reco 
ORDER BY reco DESC 
RETURN MOVIE AS MOVIE, reco AS Recommendation 
</pre><div class="mediaobject"><img src="../Images/image00458.jpeg" alt="Collaborative filtering using Cosine similarity"/></div><p style="clear:both; height: 1em;"> </p></div></div>
<div class="section" title="Summary" id="aid-1R42S1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec55"/>Summary</h1></div></div></div><p>Kudos! We have created recommendation engines using the Neo4j graph database. Let us recap what we have learned in this chapter. We started the chapter by giving a very brief introduction to graphs and graph databases. We covered a very short introduction to the core Neo4j graph database concepts such as the labeled property graph model, Nodes, Labels, Relationships, Cypher query language, Patterns, Node syntax, and Relationship Syntax.</p><p>We also touched upon Cypher clauses that are useful in building recommendations, such as <code class="literal">MATCH</code> ,<code class="literal">CREATE</code> ,<code class="literal">LOADCSV</code> ,<code class="literal">RETURN</code> ,<code class="literal">AS</code> ,and <code class="literal">WITH</code>.</p><p>Then we moved onto installation and setting up Neo4j from the browser tool in the Windows and Linux platforms.</p><p>Once the entire working environment was setup to build our recommendation engines, we chose sample movie ratings data and implemented three types of collaborative filtering, such as simple distance based, Euclidean similarity based, and Cosine similarity based recommendations. In the next chapter, we will be exploring Mahout, a machine learning library available on Hadoop, for building scalable recommender systems.</p></div></body></html>