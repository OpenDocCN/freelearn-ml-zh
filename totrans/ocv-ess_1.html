<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Getting Started</h1></div></div></div><p class="calibre7">This chapter deals with the basic installation steps and settings required to develop applications with the OpenCV library. Also, it introduces the essential concepts in order to use the <strong class="calibre8">Application Programming Interface</strong> (<strong class="calibre8">API</strong>) provided by the library and the basic <a id="id0" class="calibre1"/>datatypes supplied. This chapter includes a section with full examples of code that illustrate how to read/write images and video files, and access images from live cameras. These examples also show how to get access to live input from cameras connected to a computer.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec08" class="calibre1"/>Setting up OpenCV</h1></div></div></div><p class="calibre7">OpenCV <a id="id1" class="calibre1"/>can be downloaded from <a class="calibre1" href="http://opencv.org/">http://opencv.org/</a>, and is available for<a id="id2" class="calibre1"/> the most popular operating systems, such<a id="id3" class="calibre1"/> as Unix (Linux/Mac), Microsoft Windows (Windows), Android, and iOS. In this book, the last stable release (2.4.9) of OpenCV for Windows 7 (SP1) has been used. For Windows, this release comes in the form of a self-extracting archive (<code class="email">opencv-2.4.9.exe</code>), which should be extracted to the desired location (for example, <code class="email">OPENCV_SCR</code> for <code class="email">C:\opencv-src</code>). It should be noted that in Windows it is strongly recommended to allocate the source and binaries at absolute paths without white spaces because errors might appear later.</p><p class="calibre7">After extracting the archive, the obtained files are organized in two subdirectories under <code class="email">OPENCV_SCR</code>: <code class="email">build</code> and <code class="email">sources</code>. The first one (<code class="email">build</code>) includes precompiled (binaries) versions with Microsoft Visual C++ compilers (MSVC, v. 10, 11, and 12) for 32- and 64-bit architectures (located in the x 86 and x 64 subdirectories respectively). The <code class="email">sources</code> subdirectory contains the source code of the OpenCV library. This code might be compiled with other compilers (for example, GNU g++).</p><div><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre7">Using the precompiled versions of OpenCV is the easiest option and only requires setting the location of OpenCV's dynamic libraries binaries (DLL files) in the <strong class="calibre8">Path</strong> environment variable. For instance, in our setup, this location could be <code class="email">OPENCV_SCR/build/x86/vc12/bin</code> where the binaries compiled with MS VC version 12 for the 32 bit architecture are located. Remember that changing the environment variables in Windows 7 (SP1) can be done on <strong class="calibre8">Advanced System Settings</strong> under <strong class="calibre8">Properties</strong> of <strong class="calibre8">My Computer</strong>. The <strong class="calibre8">Rapid Environment Editor</strong> tool (available at <a class="calibre1" href="http://www.rapidee.com">http://www.rapidee.com</a>) provides a convenient way to change <strong class="calibre8">Path</strong> and other<a id="id4" class="calibre1"/> environment variables in Windows 7.</p></div><p class="calibre7">This chapter <a id="id5" class="calibre1"/>covers a detailed installation process of OpenCV on Windows 7 (SP1). For Linux and other operating systems, you can have a look at the <a id="id6" class="calibre1"/>OpenCV online documentation (<em class="calibre12">OpenCV Tutorials, Introduction to OpenCV</em> section) available at <a class="calibre1" href="http://docs.opencv.org/doc/tutorials/tutorials.html">http://docs.opencv.org/doc/tutorials/tutorials.html</a>.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec08" class="calibre1"/>Compiled versus precompiled library</h2></div></div></div><p class="calibre7">The <a id="id7" class="calibre1"/>OpenCV distribution includes the source code of the library that can be compiled when a different binary version<a id="id8" class="calibre1"/> is required. One such <a id="id9" class="calibre1"/>situation comes when we need to use the Qt-based user interface functions available in OpenCV (which are not included in the precompiled versions). Besides, the build process (compilation) for the OpenCV library is required if our compiler (for example, GNU g++) doesn't match the precompiled version of the library.</p><p class="calibre7">The requirements that have to be met in order to compile OpenCV with Qt are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre8">A compatible C++ compiler</strong>: We use the GNU g++ compiler included with MinGW (Minimal GNU GCC for Windows). This is a standard compiler on Unix<a id="id10" class="calibre1"/> and it is appropriate to guarantee code compatibility. Prior to the build process, it is quite convenient to add the location of the compiler binaries (g++ and gmake) to the <strong class="calibre8">Path</strong> environment variable (for example, in our local system, the location is <code class="email">C:\Qt\Qt5.2.1\Tools\mingw48_32\bin</code>).</li><li class="listitem"><strong class="calibre8">The Qt library</strong>: In <a id="id11" class="calibre1"/>particular, the Qt 5.2.1 bundle (available at <a class="calibre1" href="http://qt-project.org/">http://qt-project.org/</a>) is customized for an easy setup because<a id="id12" class="calibre1"/> it includes the Qt library and the complete development IDE Qt Creator with MinGW 4.8 and OpenGL. Qt Creator is a full-fledged IDE with free software license that we <a id="id13" class="calibre1"/>recommend. The Qt binaries location must also be added to the <strong class="calibre8">Path</strong> environment variable (for example, <code class="email">C:\Qt\Qt5.2.1\5.2.1\mingw48_32\bin</code>).</li><li class="listitem"><strong class="calibre8">The CMake build system</strong>: This cross-platform build system is available at <a class="calibre1" href="http://www.cmake.org/">http://www.cmake.org/</a>. It consists of a set of tools that help the user prepare <a id="id14" class="calibre1"/>and generate<a id="id15" class="calibre1"/> the suitable <a id="id16" class="calibre1"/>configuration<a id="id17" class="calibre1"/> files used for building (compiling), testing, and packaging<a id="id18" class="calibre1"/> a large code project such as OpenCV.</li></ul></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec01" class="calibre1"/>Configuring OpenCV with CMake</h3></div></div></div><p class="calibre7">In this <a id="id19" class="calibre1"/>section, we illustrate the configuration steps for <a id="id20" class="calibre1"/>OpenCV with CMake, with the help of screenshots of the steps involved:</p><div><ol class="orderedlist"><li class="listitem" value="1">The first step involves the selection of directories and compilers. Once CMake is launched, both the source directory (<code class="email">OPENCV_SCR</code>) and the build directory (<code class="email">OPENCV_BUILD</code>) can be set in the proper text fields in the CMake main window. Also, the checkboxes labeled as <strong class="calibre8">Grouped</strong> and <strong class="calibre8">Advanced</strong> should be marked in the CMake main window. We continue clicking on the <strong class="calibre8">Configure</strong> button. At this point, the tool prompts the user to specify the desired compiler and we choose <strong class="calibre8">MinGW Makefiles</strong> using the native compilers. If we choose the <strong class="calibre8">Specify native compilers</strong> option, it is possible to specify a particular location for the compiler and make tools. After clicking on the <strong class="calibre8">Finish</strong> button, the configuration step continues checking the settings of the system. The following screenshot shows the CMake window at the end of this preconfiguration process:<div><img src="img/00002.jpeg" alt="Configuring OpenCV with CMake" class="calibre9"/><div><p class="calibre13">CMake at the end of the preconfiguration step</p></div></div><p class="calibre14"> </p><div><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre7">For the purpose of simplicity, we use in this text <code class="email">OPENCV_BUILD</code> and <code class="email">OPENCV_SCR</code> to denote respectively the target and source directories of the OpenCV local setup. Keep in mind that all directories should match the current local configuration.</p></div></li><li class="listitem" value="2">The <a id="id21" class="calibre1"/>next step is the selection of the <a id="id22" class="calibre1"/>build options. At the center of the main CMake window, the red entries might be changed if desired. In our setup, we open the entries grouped with the label <strong class="calibre8">WITH</strong> and there we set the <strong class="calibre8">WITH_QT</strong> entry to <strong class="calibre8">ON</strong>, and then we click on <strong class="calibre8">Configure</strong> again to obtain a new set of options.</li><li class="listitem" value="3">Now, the next stage is to set the Qt directories. In the main CMake window, a few entries are marked in red. These are the required directories to build OpenCV with Qt. The next entries to be set are: <code class="email">Qt5Concurrent_DIR</code>, <code class="email">Qt5Core_DIR</code>, <code class="email">Qt5Gui_DIR</code>, <code class="email">Qt5OpenGL_DIR</code>, <code class="email">Qt5Test_DIR</code>, and <code class="email">Qt5Widgets_DIR</code> (refer to the following figure). In our setup, these directories can be found under <code class="email">C:/Qt/Qt5.2.1/5.2.1/mingw48_32/lib/cmake</code>.<p class="calibre15">By clicking on the <strong class="calibre8">Configure</strong> button once, we obtain no further red entries and the configuration process is finally done, as shown in the following screenshot:</p><div><img src="img/00003.jpeg" alt="Configuring OpenCV with CMake" class="calibre9"/><div><p class="calibre13">Setting Qt directories for CMake</p></div></div><p class="calibre14"> </p></li><li class="listitem" value="4">The<a id="id23" class="calibre1"/> last step is to generate the project. In<a id="id24" class="calibre1"/> this step, we click on the <strong class="calibre8">Generate</strong> button to obtain the suitable project files to build OpenCV in the target platform. Then, the CMake GUI should be closed to continue with the compilation.</li></ol><div></div><p class="calibre7">In the process just described, it is possible to change the configuration options as many times as desired before the generation step. Some other convenient options to be set are listed as follows:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre8">BUILD_EXAMPLES</strong>: This option is used to compile the source code of several examples included in the distribution</li><li class="listitem"><strong class="calibre8">BUILD_SHARED_LIBS</strong>: Uncheck this option to get a static version of the libraries</li><li class="listitem"><strong class="calibre8">CMAKE_BUILD_TYPE</strong>: Set this to <strong class="calibre8">Debug</strong> to get a version for debugging purposes and so on</li><li class="listitem"><strong class="calibre8">WITH_TBB</strong>: Set <a id="id25" class="calibre1"/>this option to activate <a id="id26" class="calibre1"/>the use of Intel® Threading Building Block that lets you easily write parallel C++ code</li><li class="listitem"><strong class="calibre8">WITH_CUDA</strong>: Set this option to use processing by GPU through CUDA libraries</li></ul></div></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec02" class="calibre1"/>Building and installing the library</h3></div></div></div><p class="calibre7">The compilation should be launched from the console at the target directory (<code class="email">OPENCV_BUILD</code>) set<a id="id27" class="calibre1"/> during the configuration with CMake (that is, step 1 from the previous list). The command should be as follows:</p><div><pre class="programlisting">
<strong class="calibre8">OPENCV_BUILD&gt;mingw32-make</strong>
</pre></div><p class="calibre7">This <a id="id28" class="calibre1"/>command launches a build process using the generated<a id="id29" class="calibre1"/> files by CMake. Compilation typically takes several minutes. If the compilation ends without errors, the installation continues with the execution of the following command:</p><div><pre class="programlisting">
<strong class="calibre8">OPENCV_BUILD&gt;mingw32-make install</strong>
</pre></div><p class="calibre7">This command copies the OpenCV binaries to the following directory:</p><div><pre class="programlisting">
<strong class="calibre8">C:\opencv-buildQt\install</strong>
</pre></div><p class="calibre7">If something goes wrong during the compilation, we should return to CMake to change the options selected in the previous steps. Installation ends by adding the location of the library binaries (DLL files) to the <strong class="calibre8">Path</strong> environment variable. In our setup, this directory is located at <code class="email">OPENCV_BUILD\install\x64\mingw\bin</code>.</p><p class="calibre7">To check the success of the installation process, it is possible to run some of the examples compiled along with the library (if the <strong class="calibre8">BUILD_EXAMPLES</strong> option was set with CMake). The code samples can be found at <code class="email">OPENCV_BUILD\install\x64\mingw\samples\cpp</code>.</p><div><img src="img/00004.jpeg" alt="Building and installing the library" class="calibre9"/><div><p class="calibre13">Canny edge detection sample</p></div></div><p class="calibre10"> </p><p class="calibre7">The preceding<a id="id30" class="calibre1"/> screenshot shows the output window for the<a id="id31" class="calibre1"/> sample <code class="email">cpp-example-edge.exe</code> file, which demonstrates<a id="id32" class="calibre1"/> the Canny edge detection on the <code class="email">fruits.jpg</code> input file included with the source OpenCV distribution.</p><p class="calibre7">In the next section, we summarize the recipe used to set up OpenCV 2.4.9 in our Windows 7-x32 platform with Qt 5.2.1 (MinGW 4.8).</p></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec09" class="calibre1"/>Quick recipe for setting up OpenCV</h2></div></div></div><p class="calibre7">The whole <a id="id33" class="calibre1"/>process for setting up OpenCV can be done using the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Download<a id="id34" class="calibre1"/> and install Qt5 (available at <a class="calibre1" href="http://qt-project.org/">http://qt-project.org/</a>).</li><li class="listitem" value="2">Add the MinGW bin directory (for g++ and gmake) to the <strong class="calibre8">Path</strong> environment variable (for example, <code class="email">C:\Qt\Qt5.2.1\Tools\mingw48_32\bin\</code>).</li><li class="listitem" value="3">Add the Qt bin directory (for DLLs) to the <strong class="calibre8">Path</strong> environment variable (for example, <code class="email">C:\Qt\Qt5.2.1\5.2.1\mingw48_32\bin\</code>).</li><li class="listitem" value="4">Download <a id="id35" class="calibre1"/>and install CMake (available at <a class="calibre1" href="http://www.cmake.org/">http://www.cmake.org/</a>).</li><li class="listitem" value="5">Download <a id="id36" class="calibre1"/>OpenCV archive (available at <a class="calibre1" href="http://opencv.org/">http://opencv.org/</a>).</li><li class="listitem" value="6">Extract the downloaded archive to an <code class="email">OPENCV_SRC</code> directory.</li><li class="listitem" value="7">Configure the OpenCV build project with CMake using the following steps:<div><ol class="orderedlist1"><li class="listitem" value="1">Choose the source (<code class="email">OPENCV_SCR</code>) and target (<code class="email">OPENCV_BUILD</code>) directories.</li><li class="listitem" value="2">Mark the <strong class="calibre8">Grouped</strong> and <strong class="calibre8">Advanced</strong> checkboxes and click on <strong class="calibre8">Configure</strong>.</li><li class="listitem" value="3">Choose a compiler.</li><li class="listitem" value="4">Set the <strong class="calibre8">BUILD_EXAMPLES</strong> and <strong class="calibre8">WITH_QT</strong> options, and finally click on the <strong class="calibre8">Configure</strong> button.</li><li class="listitem" value="5">Set the following Qt directories: <code class="email">Qt5Concurrent_DIR</code>, <code class="email">Qt5Core_DIR</code>, <code class="email">Qt5Gui_DIR</code>, <code class="email">Qt5OpenGL_DIR</code>, <code class="email">Qt5Test_DIR</code>, <code class="email">Qt5Widgets_DIR</code>. Then, click on <strong class="calibre8">Configure</strong> again.</li><li class="listitem" value="6">If no errors are reported (marked in red in the CMake window), you can click on the <strong class="calibre8">Generate</strong> button. If some error is reported, the wrong options should be corrected and the <strong class="calibre8">Configure</strong> steps should be repeated. Close CMake after the <strong class="calibre8">Generate</strong> step.</li></ol><div></div></li><li class="listitem" value="8">Open a <a id="id37" class="calibre1"/>console under the <code class="email">OPENCV_BUILD</code> directory and run the <code class="email">mingw32-make</code> command to start the compilation.</li><li class="listitem" value="9">If the build process doesn't produce an error, run <code class="email">mingw32-make install</code> on the command line.</li><li class="listitem" value="10">Add the OpenCV bin directory (for DLLs) to the <strong class="calibre8">Path</strong> environment variable (for example, <code class="email">OPENCV_BUILD\install\x64\mingw\bin\</code>).</li></ol><div></div><p class="calibre7">To check the right installation of the OpenCV library, you can run some of the examples included at <code class="email">OPENCV_BUILD\install\x64\mingw\samples\cpp</code>.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec09" class="calibre1"/>API concepts and basic datatypes</h1></div></div></div><p class="calibre7">After <a id="id38" class="calibre1"/>installation, preparing <a id="id39" class="calibre1"/>a new<a id="id40" class="calibre1"/> OpenCV code project is quite a straightforward <a id="id41" class="calibre1"/>process that requires including the header files and instructing the compiler to find the files and libraries used in the project.</p><p class="calibre7">OpenCV is composed of several modules, grouping related functionalities. Each module has an associated <a id="id42" class="calibre1"/>header file (for example, <code class="email">core.hpp</code>) located in the directory <a id="id43" class="calibre1"/>with the same name as that of the module (that is, <code class="email">OPENCV_BUILD\install\include\opencv2\&lt;module&gt;</code>). The supplied modules<a id="id44" class="calibre1"/> with the current version of OpenCV are as <a id="id45" class="calibre1"/>follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">core</code>: This module <a id="id46" class="calibre1"/>defines the basic (core) functions <a id="id47" class="calibre1"/>used by all the other modules and fundamental <a id="id48" class="calibre1"/>data structures, including the dense multidimensional array, <code class="email">Mat</code>.</li><li class="listitem"><code class="email">highgui</code>: This <a id="id49" class="calibre1"/>module provides simple <strong class="calibre8">user interface</strong> (<strong class="calibre8">UI</strong>) capabilities and an easy interface for video and image capturing. Building <a id="id50" class="calibre1"/>the library with the Qt option allows UI <a id="id51" class="calibre1"/>compatibility with such frameworks.</li><li class="listitem"><code class="email">imgproc</code>: This<a id="id52" class="calibre1"/> module includes image-processing <a id="id53" class="calibre1"/>functions that include filtering (linear and nonlinear), geometric transformations, color space conversion, and so on.</li><li class="listitem"><code class="email">features2d</code>: This <a id="id54" class="calibre1"/>module includes functions<a id="id55" class="calibre1"/> for feature detection (corners and planar objects), feature description, feature matching, and so on.</li><li class="listitem"><code class="email">objdetect</code>: This<a id="id56" class="calibre1"/> module includes functions<a id="id57" class="calibre1"/> for object detection and instances of the predefined detection classes (for example, face, eyes, smile, people, cars, and so on).</li><li class="listitem"><code class="email">video</code>: This<a id="id58" class="calibre1"/> module supplies the functionality <a id="id59" class="calibre1"/>of video analysis (motion estimation, background extraction, and object tracking).</li><li class="listitem"><code class="email">gpu</code>: This <a id="id60" class="calibre1"/>module provides a collection of GPU-accelerated <a id="id61" class="calibre1"/>algorithms for some functions in the other OpenCV modules.</li><li class="listitem"><code class="email">ml</code>: This<a id="id62" class="calibre1"/> module includes functions to implement <a id="id63" class="calibre1"/>machine-learning tools such as statistical classification, regression, and data clustering.</li><li class="listitem">Some other less usual miscellaneous modules oriented are camera calibration, clustering, computational photography, images stitching, OpenCL-accelerated CV, super resolution, and others.</li></ul></div><p class="calibre7">All OpenCV classes and functions are in the <code class="email">cv</code> namespace. Consequently, we will have the following<a id="id64" class="calibre1"/> two options in our source code:</p><div><ul class="itemizedlist"><li class="listitem">Add the <code class="email">using namespace cv</code> declaration after including the header files (this is the option used in all the code samples in this book).</li><li class="listitem">Append the <code class="email">cv::</code> specifier<a id="id65" class="calibre1"/> as a prefix to all the OpenCV classes, functions, and data structures that we use. This option is recommended if the external names provided by OpenCV conflict with the <strong class="calibre8">standard template library</strong> (<strong class="calibre8">STL</strong>)<a id="id66" class="calibre1"/> or other <a id="id67" class="calibre1"/>libraries.</li></ul></div><p class="calibre7">The <code class="email">DataType</code> class defines the primitive datatypes<a id="id68" class="calibre1"/> for OpenCV. The primitive datatypes <a id="id69" class="calibre1"/>can be <code class="email">bool</code>, <code class="email">unsigned char</code>, <code class="email">signed char</code>, <code class="email">unsigned short</code>, <code class="email">signed short</code>, <code class="email">int</code>, <code class="email">float</code>, <code class="email">double</code>, or a <a id="id70" class="calibre1"/>tuple <a id="id71" class="calibre1"/>of values of one of <a id="id72" class="calibre1"/>these <a id="id73" class="calibre1"/>primitive <a id="id74" class="calibre1"/>types. Any primitive type can be <a id="id75" class="calibre1"/>defined<a id="id76" class="calibre1"/> by an identifier in the following form:</p><div><pre class="programlisting">CV_&lt;bit depth&gt;{U|S|F}C(&lt;number of channels&gt;)</pre></div><p class="calibre7">In the <a id="id77" class="calibre1"/>preceding <a id="id78" class="calibre1"/>code, <code class="email">U</code>, <code class="email">S</code>, and <code class="email">F</code> stand for<a id="id79" class="calibre1"/> unsigned, signed, and float respectively. For the single channel arrays, the following enumeration is applied describing the datatypes:</p><div><pre class="programlisting">enum {CV_8U=0, CV_8S=1, CV_16U=2, CV_16S=3, CV_32S=4, CV_32F=5, CV_64F=6};</pre></div><p class="calibre7">The following diagram shows a graphical representation of a single channel (4 x 4) array with 8 bits of unsigned integers (<code class="email">CV_8U</code>). In this case, each element should have a value from zero to 255, which may be represented by a grayscale image.</p><div><img src="img/00005.jpeg" alt="API concepts and basic datatypes" class="calibre9"/><div><p class="calibre13">Single channel array of 8 bit unsigned integers for a greyscale image</p></div></div><p class="calibre10"> </p><p class="calibre7">We can define all of the preceding datatypes for multichannel arrays (up to 512 channels). The following diagram illustrates a graphical representation of three channels 4 x 4 array of 8 bits of unsigned integers (<code class="email">CV_8UC3</code>). In this example, the array consists of tuples of three <a id="id80" class="calibre1"/>elements corresponding to an RGB image.</p><div><img src="img/00006.jpeg" alt="API concepts and basic datatypes" class="calibre9"/><div><p class="calibre13">A three-channel array of 8 bit unsigned integers for an RGB image</p></div></div><p class="calibre10"> </p><div><h3 class="title2"><a id="note03" class="calibre1"/>Note</h3><p class="calibre7">Here, it should be noted that the following three declarations are equivalent: <code class="email">CV_8U</code>, <code class="email">CV_8UC1</code>, and <code class="email">CV_8UC(1)</code>.</p></div><p class="calibre7">The OpenCV <code class="email">Mat</code> class<a id="id81" class="calibre1"/> is used for dense n-dimensional single or multichannel arrays. It can store <a id="id82" class="calibre1"/>real or complex-valued vectors and matrices, colored or grayscale<a id="id83" class="calibre1"/> images, histograms, point clouds, and so on. There are many different ways to create a <code class="email">Mat</code> object, the most popular being the <a id="id84" class="calibre1"/>constructor where the size and type of the array are specified as follows:</p><div><pre class="programlisting">Mat(nrows, ncols, type[, fillValue])</pre></div><p class="calibre7">The initial value for the array elements might be set by the <code class="email">Scalar</code> class as a typical four-element vector (for the RGB and transparency components of the image stored in the array). Next, we show some usage examples of <code class="email">Mat</code> as follows:</p><div><pre class="programlisting">Mat img_A(640, 480, CV_8U, Scalar(255)); // white image
// 640 x 480 single-channel array with 8 bits of unsigned integers
// (up to 255 values, valid for a grayscale image, for example,
// 255=white)
…
Mat img_B(Size(800, 600), CV_8UC3, Scalar(0,255,0)); // Green image
// 800 x 600 three channel array with 8 bits of unsigned integers
// (up to 24 bits color depth, valid for a RGB color image)</pre></div><div><h3 class="title2"><a id="note04" class="calibre1"/>Note</h3><p class="calibre7">Note that OpenCV allocates colored RGB images to a three channel (and a fourth for the transparency, that is, alpha channel) array, following the BGR order with the higher values corresponding to brighter pixels.</p></div><p class="calibre7">The <code class="email">Mat</code> class is the main data structure that stores and manipulates images. OpenCV has implemented <a id="id85" class="calibre1"/>mechanisms to allocate and release memory automatically<a id="id86" class="calibre1"/> for these data structures. However, the programmer <a id="id87" class="calibre1"/>should still take special care when data structures <a id="id88" class="calibre1"/>share the same buffer memory.</p><p class="calibre7">Many functions in OpenCV process dense single or multichannel arrays usually using the <code class="email">Mat</code> class. However, in some cases, a different datatype may be convenient, such as <code class="email">std::vector&lt;&gt;</code>, <code class="email">Matx&lt;&gt;</code>, <code class="email">Vec&lt;&gt;</code>, or <code class="email">Scalar</code>. For this purpose, OpenCV provides the proxy classes, <code class="email">InputArray</code> and <code class="email">OutputArray</code>, which allow any of the previous types to be used as parameters for functions.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Our first program – reading and writing images and videos</h1></div></div></div><p class="calibre7">To prepare the <a id="id89" class="calibre1"/>examples for this book, we used the Qt Creator IDE (included in the Qt 5.2 bundle) and OpenCV 2.4.9 compiled with MinGW g++ 4.8 and Qt functionality. Qt Creator is a free multiplatform IDE with very helpful <a id="id90" class="calibre1"/>features for C++ programming. However, the user can choose the tool chain to build the executables that best fit its needs.</p><p class="calibre7">Our first Qt Creator project with OpenCV will be quite a simple flip-image tool, named <code class="email">flipImage</code>. This tool reads a color image file and transforms it into a grayscale image, flipped and saved into an output file.</p><p class="calibre7">For this application, we choose to create a new code project by navigating to <strong class="calibre8">File</strong> | <strong class="calibre8">New File</strong> or <strong class="calibre8">File</strong> | <strong class="calibre8">Project…</strong>, and then navigate to <strong class="calibre8">Non-Qt Project</strong> | <strong class="calibre8">Plain C++ Project</strong>. Then, we have to choose a project name and location. The next step is to pick a kit (that is, compiler) for the project (in our case, <strong class="calibre8">Desktop Qt 5.2.1 MinGW 32 bit</strong>) and location for the binaries generated. Usually, two possible build configurations (profiles) are used: <code class="email">debug</code> and <code class="email">release</code>. These profiles set the appropriate flags to build and run the binaries.</p><p class="calibre7">When a <a id="id91" class="calibre1"/>Qt Creator project is created, two special files (with the <code class="email">.pro</code> and <code class="email">.pro.user</code> extension) are generated to configure the build and run processes. The build process is determined by the kit chosen during the creation of the project. With the <strong class="calibre8">Desktop Qt 5.2.1 MinGW 32 bit</strong> kit, this process relies on the <code class="email">qmake</code> and <code class="email">mingw32-make</code> tools. With the <code class="email">.pro</code> files as input, <code class="email">qmake</code> generates the <strong class="calibre8">makefiles</strong> for Make (that is, <code class="email">mingw32-make</code>) that drive the build process for each profile (that is, <code class="email">release</code> and <code class="email">debug</code>).</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec10" class="calibre1"/>The qmake project file</h2></div></div></div><p class="calibre7">For <a id="id92" class="calibre1"/>our <code class="email">flipImage</code> sample project, the <code class="email">flipImage.pro</code> file<a id="id93" class="calibre1"/> looks like the following code:</p><div><pre class="programlisting">TARGET: flipImage
TEMPLATE = app
CONFIG += console
CONFIG -= app_bundle
CONFIG -= qt

SOURCES += \
    flipImage.cpp
INCLUDEPATH += C:\\opencv-buildQt\\install\\include
LIBS += -LC:\\opencv-buildQt\\install\\x64\mingw\\lib \
    -lopencv_core249.dll \
    -lopencv_highgui249.dll</pre></div><p class="calibre7">The preceding file illustrates the options that <code class="email">qmake</code> needs to generate the appropriate makefiles to build the binaries for our project. Each line starts with a tag indicating an option (<code class="email">TARGET</code>, <code class="email">CONFIG</code>, <code class="email">SOURCES</code>, <code class="email">INCLUDEPATH</code>, and <code class="email">LIBS</code>) followed with a mark to add (<code class="email">+=</code>) or remove (<code class="email">-=</code>) the value of the option. In this sample project, we deal with the non-Qt console application. The executable file is <code class="email">flipImage.exe</code> (<code class="email">TARGET</code>) and the source file is <code class="email">flipImage.cpp</code> (<code class="email">SOURCES</code>). Since this project is an OpenCV application, the two last tags point out to the location of the header files (<code class="email">INCLUDEPATH</code>) and the OpenCV libraries (<code class="email">LIBS</code>) used by this particular project (for example, <code class="email">core</code> and <code class="email">highgui</code>). Note that a backslash at the end of the line denotes continuation in the next line. In Windows, path backslashes should be duplicated, as shown in the preceding example.</p><p class="calibre7">The <a id="id94" class="calibre1"/>following code shows the source<a id="id95" class="calibre1"/> code for the <code class="email">flipImage</code> project:</p><div><pre class="programlisting">
<strong class="calibre8">#include "opencv2/core/core.hpp"</strong>
<strong class="calibre8">#include "opencv2/highgui/highgui.hpp"</strong>
#include &lt;iostream&gt;

using namespace std;
<strong class="calibre8">using namespace cv;</strong>

int main(int argc, char *argv[])
{
    int flip_code=0;
    Mat out_image; // Output image

    if (argc != 4) {//Check args. number
        cout &lt;&lt; "Usage: &lt;cmd&gt; &lt;flip_code&gt; &lt;file_in&gt; &lt;file_out&gt;\n";
        return -1;
    }
<strong class="calibre8">    Mat in_image = imread(argv[2], CV_LOAD_IMAGE_GRAYSCALE);</strong>
    if (<strong class="calibre8">in_image.empty()</strong>) { // Check if read
        cout &lt;&lt; "Error! Input image cannot be read...\n";
        return -1;
    }
    sscanf(argv[1], "%d", &amp;flip_code); // Read flip code
<strong class="calibre8">    flip(in_image, out_image, flip_code);</strong>
    <strong class="calibre8">imwrite(argv[3], out_image);</strong> // Write image to file
    <strong class="calibre8">namedWindow("Flipped…");</strong> // Creates a window
    <strong class="calibre8">imshow(win, out_image);</strong> // Shows output image on window
    cout &lt;&lt; "Press any key to exit...\n";
    <strong class="calibre8">waitKey();</strong> // Wait infinitely for key press
    return 0;
}</pre></div><p class="calibre7">After building the project, we can run the <code class="email">flipImage</code> application from the following command line:</p><div><pre class="programlisting">
<strong class="calibre8">CV_SAMPLES/flipImage_build/debug&gt;flipImage.exe -1 lena.jpg lena_f.jpg</strong>
</pre></div><p class="calibre7">The following screenshot shows the window with the output image after flipping on both the axes (horizontal and vertical):</p><div><img src="img/00007.jpeg" alt="The qmake project file" class="calibre9"/><div><p class="calibre13">Input image (left) and output image after the flipImage tool has been applied (right)</p></div></div><p class="calibre10"> </p><p class="calibre7">The source <a id="id96" class="calibre1"/>code starts with the inclusion <a id="id97" class="calibre1"/>of the header files (<code class="email">core.hpp</code> and <code class="email">highgui.hpp</code>) associated with the modules used by the application. Note that it is also possible to include only the <code class="email">opencv.hpp</code> header since it will in turn include all the header files of OpenCV.</p><p class="calibre7">The <code class="email">flipImage</code> example gets the flip code and two file names (for the input and output images) as the command-line arguments. These arguments are obtained from the <code class="email">argv[]</code> variable. The following example illustrates several essential tasks in an OpenCV application:</p><div><ol class="orderedlist"><li class="listitem" value="1">Read an image from the file (<code class="email">imread</code>) to a <code class="email">Mat</code> class and check whether the target variable is not empty (<code class="email">Mat::empty</code>).</li><li class="listitem" value="2">Call a procedure (for example, <code class="email">flip</code>) with the proxy classes, <code class="email">InputArray</code> (<code class="email">in_image</code>) and <code class="email">OutputArray</code> (<code class="email">out_image</code>).</li><li class="listitem" value="3">Write an image to a file (<code class="email">imwrite</code>).</li><li class="listitem" value="4">Create an output window (<code class="email">namedWindow</code>) and show (<code class="email">imshow</code>) an image on it.</li><li class="listitem" value="5">Wait for a key (<code class="email">waitKey</code>).</li></ol><div></div><p class="calibre7">The code explanation is given as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">Mat imread(const string&amp; filename, int flags=1)</code>: This function loads<a id="id98" class="calibre1"/> an image from the specified file and returns it. It also returns an empty matrix if the image cannot be read. It supports the most usual image formats of the files, detected by their content rather than by their extension. The <code class="email">flags</code> parameter <a id="id99" class="calibre1"/>indicates the color of the<a id="id100" class="calibre1"/> image loaded in the memory, which may differ from the original color of the image stored in the file. In the example code, this function is used as follows:<div><pre class="programlisting">Mat in_image = imread(argv[2], CV_LOAD_IMAGE_GRAYSCALE);</pre></div><p class="calibre15">Here, the filename is obtained from the command-line arguments (the second argument after the command name). The <code class="email">CV_LOAD_IMAGE_GRAYSCALE</code> flag indicates that the image should be loaded in the memory as an 8 bit grayscale image. For a description of the available tags, it is recommended to read the OpenCV online documentation (available at <a class="calibre1" href="http://docs.opencv.org/">http://docs.opencv.org/</a>).</p></li><li class="listitem"><code class="email">bool imwrite(const string&amp; filename, InputArray img, const vector&lt;int&gt;&amp; params=vector&lt;int&gt;())</code>: This function writes an image to a given<a id="id101" class="calibre1"/> file where some optional format parameters are specified after the second argument. The format of the output file is determined by the file extension. In our example code, this function is used without the format parameters as follows:<div><pre class="programlisting">imwrite(argv[3], out_image);</pre></div></li><li class="listitem"><code class="email">void namedWindow(const string&amp; winname, int flags=WINDOW_AUTOSIZE)</code>: This function creates a window without displaying it. The first argument is a string used as a name for the window and its <a id="id102" class="calibre1"/>identifier. The second argument is a flag or flag combination, which controls some window properties (for example, enable resize). Next, we show how this function is used in the example using a constant string as a name for the created window, as follows:<div><pre class="programlisting">namedWindow("Flipped …"); // Creates a window</pre></div><p class="calibre15">Compiling OpenCV with Qt adds some new functionality to the <code class="email">highgui</code> module (more on that later). Then, the window created with Qt and the <code class="email">namedWindow</code> function uses the default flags: <code class="email">CV_WINDOW_AUTOSIZE</code>, <code class="email">CV_WINDOW_KEEPRATIO</code>, or <code class="email">CV_GUI_EXPANDED</code>.</p></li><li class="listitem"><code class="email">void imshow(const string&amp; winname, InputArray mat)</code>: This function <a id="id103" class="calibre1"/>displays an array (image) in a window with the properties set previously with the specified flags when the window was created. In the example, this function is used as follows:<div><pre class="programlisting">imshow(win, out_image); // Shows output image on window</pre></div></li><li class="listitem"><code class="email">int waitKey(int delay=0)</code>: This function waits for a key press or the milliseconds specified by <code class="email">delay</code> (if <code class="email">delay</code> is greater than zero). If <code class="email">delay</code> is less than<a id="id104" class="calibre1"/> or equal to zero, it <a id="id105" class="calibre1"/>waits infinitely. It returns the key code if<a id="id106" class="calibre1"/> pressed or <code class="email">-1</code> if a key is not pressed after the delay. This function has to be used after creating and activating a window. In the example code, it is used as follows:<div><pre class="programlisting">waitKey(); // Wait infinitely for key press</pre></div></li></ul></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Reading and playing a video file</h1></div></div></div><p class="calibre7">A video deals <a id="id107" class="calibre1"/>with moving images rather than still images, that is, display of a<a id="id108" class="calibre1"/> frame sequence at a proper rate (<strong class="calibre8">FPS</strong> or <strong class="calibre8">frames per second</strong>). The following <code class="email">showVideo</code> example illustrates how to read and play a <a id="id109" class="calibre1"/>video file with OpenCV:</p><div><pre class="programlisting">//… (omitted for simplicity)
int main(int argc, char *argv[])
{
    Mat frame; // Container for each frame

    <strong class="calibre8">VideoCapture vid(argv[1]);</strong> // Open original video file
    if (!<strong class="calibre8">vid.isOpened()</strong>) // Check whether the file was opened
        return -1;
    int fps = (int)<strong class="calibre8">vid.get(CV_CAP_PROP_FPS)</strong>;
    namedWindow(argv[1]); // Creates a window
    while (1) {
        if (!<strong class="calibre8">vid.read(frame)</strong>) // Check end of the video file
            break;
        imshow(argv[1], frame); // Show current frame on window
        if (waitKey(1000/fps) &gt;= 0)
            break;
    }
    return 0;
}</pre></div><p class="calibre7">The code explanation is given as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">VideoCapture::VideoCapture(const string&amp; filename)</code> – This class constructor <a id="id110" class="calibre1"/>provides a C++ API to grab a video from the files and cameras. The constructor can have <a id="id111" class="calibre1"/>one argument, either a filename or a device index for a camera. In our code example, it is used with a filename obtained from the command-line arguments as follows:<div><pre class="programlisting">VideoCapture vid(argv[1]);</pre></div></li><li class="listitem"><code class="email">double VideoCapture::get(int propId)</code> – This method returns the specified <code class="email">VideoCapture</code> property. If a property is not supported by the backend <a id="id112" class="calibre1"/>used by the <code class="email">VideoCapture</code> class, the value returned is <code class="email">0</code>. In the following example, this method is <a id="id113" class="calibre1"/>used to get the frames per second of the video file:<div><pre class="programlisting">int fps = (int)vid.get(CV_CAP_PROP_FPS);</pre></div><p class="calibre15">Since the method returns a <code class="email">double</code> value, an explicit cast to <code class="email">int</code> is done.</p></li><li class="listitem"><code class="email">bool VideoCapture::read(Mat&amp; image)</code> – This method grabs, decodes, and <a id="id114" class="calibre1"/>returns a video frame from the <code class="email">VideoCapture</code> object. The frame is stored in a <code class="email">Mat</code> variable. If it fails (for example, when the end of the file is reached), it returns <code class="email">false</code>. In the code example, this method is used as follows, also checking the end of file condition:<div><pre class="programlisting">if (!vid.read(frame)) // Check end of the video file
break;</pre></div></li></ul></div><p class="calibre7">In the preceding example, the <code class="email">waitKey</code> function<a id="id115" class="calibre1"/> is used with a computed number of milliseconds (<code class="email">1000/fps</code>) trying to play the video file at the same rate it was originally recorded. Playing a video at a faster/slower rate (more/less fps) than that will produce a faster/slower playback.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Live input from a camera</h1></div></div></div><p class="calibre7">Usually, the computer vision problems we face are related with processing live video input from <a id="id116" class="calibre1"/>one or several cameras. In this <a id="id117" class="calibre1"/>section, we will describe the <code class="email">recLiveVid</code> example, which grabs a video stream from a webcam (connected to our computer), displays the stream in a window, and records it in a file (<code class="email">recorded.avi</code>). By default, in the following example, the video capture is taken from the camera with <code class="email">cam_id=0</code>. However, it is possible to handle a second camera (<code class="email">cam_id=1</code>) and grab the video from it, setting an argument at the command line:</p><div><pre class="programlisting">//… (omitted for brevity)
int main(int argc, char *argv[])
{
    Mat frame;
    const char win_name[]="Live Video...";
    const char file_out[]="recorded.avi";
    int cam_id=0; // Webcam connected to the USB port
    double fps=20;

    if (argc == 2)
        sscanf(argv[1], "%d", &amp;cam_id);

    <strong class="calibre8">VideoCapture inVid(cam_id)</strong>; // Open camera with cam_id
    if (!inVid.isOpened())
        return -1;

    int width = (int)inVid.get(CV_CAP_PROP_FRAME_WIDTH);
    int height = (int)inVid.get(CV_CAP_PROP_FRAME_HEIGHT);
    <strong class="calibre8">VideoWriter recVid(file_out, CV_FOURCC('F','F','D','S'), fps, Size(width, height));</strong>
    if (!recVid.isOpened()) 
        return -1;

    namedWindow(win_name);
    while (1) {
        <strong class="calibre8">inVid &gt;&gt; frame</strong>; // Read frame from camera
        <strong class="calibre8">recVid &lt;&lt; frame</strong>; // Write frame to video file
        imshow(win_name, frame); // Show frame
        if (waitKey(1000/fps) &gt;= 0)
            break;
    }
    <strong class="calibre8">inVid.release()</strong>; // Close camera
    return 0;
}</pre></div><p class="calibre7">The code <a id="id118" class="calibre1"/>explanation is given as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">VideoCapture::VideoCapture(int device)</code> – This class constructor initializes a <code class="email">VideoCapture</code> object to receive a video from a camera rather than <a id="id119" class="calibre1"/>a file. In the following code example, it is used with a camera identifier:<div><pre class="programlisting">VideoCapture inVid(cam_id); // Open camera with cam_id</pre></div></li><li class="listitem"><code class="email">VideoWriter::VideoWriter(const string&amp; filename, int fourcc, double fps, Size frameSize, bool isColor=true)</code> – This class<a id="id120" class="calibre1"/> constructor creates an object <a id="id121" class="calibre1"/>to write a video stream to a file with the name passed as the first argument. The second argument identifies the video codec with a code of four single characters (for example, in the previous sample code, FFDS stands for <code class="email">ffdshow</code>). Obviously, only codecs actually installed in the local system can be used. The third argument indicates the frames per second of the recording. This property can be obtained from the <code class="email">VideoCapture</code> object with the <code class="email">VideoCapture::get</code> method, although it may return <code class="email">0</code> if the property is not supported by the backend. The <code class="email">frameSize</code> argument indicates the total size for each frame of the video that is going to be written. This size should be the same as the input video grabbed. Finally, the last argument allows writing the frame in color (default) or in grayscale. In the example code, the constructor is used with the <code class="email">ffdshow</code> codec and the size of the video capture is as follows:<div><pre class="programlisting">int width = (int)inVid.get(CV_CAP_PROP_FRAME_WIDTH);
int height = (int)inVid.get(CV_CAP_PROP_FRAME_HEIGHT);
<strong class="calibre8">VideoWriter recVid(file_out, CV_FOURCC('F','F','D','S'), fps,Size(width, height));</strong>
</pre></div></li><li class="listitem"><code class="email">void VideoCapture::release()</code> – This method closes the capturing device (webcam) or the video file. This method is always called implicitly at the end <a id="id122" class="calibre1"/>of the program. However, in the preceding example, it is called explicitly to avoid wrong termination of the output file (only noticeable when playing the recorded video).</li></ul></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec13" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">This chapter started with an explanation of how to build and install the OpenCV library with Qt (using CMake, the GNU g++ compiler, and GNU Make). Then, it is given a quick look to the modules organization of the library with an easy explanation of its basic API concepts. The chapter follows up with a more detailed revision of the fundamental data structures to store arrays and manipulate images. Also, three examples of code, such as <code class="email">flipImage</code>, <code class="email">showVideo</code> , and <code class="email">recLiveVid</code> are explained to illustrate the basic use of the OpenCV library. The next chapter will introduce you to the two mainstream options available to provide graphical user interface capabilities for OpenCV programs.</p></div></body></html>