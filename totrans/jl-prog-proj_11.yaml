- en: Creating Julia Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've come a long way since the beginning of our journey toward learning Julia.
    I hope you enjoyed this process of discovery as much as I did! We've covered a
    lot of ground, learning about many key topics while developing quite a suite of
    fully functional applications. Yet, there's one thing left in order to fully earn
    our Julia developer badge. The signature of every proficient Julia programmer—(drumroll,
    please!)—creating, publishing, and registering our own *official* Julia package!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll build a REPL app and we''ll wrap it into a package.
    Our product will help Julia developers to easily report bugs they encounter in
    other Julia packages. Once the users install and configure our package, they will
    be able to open GitHub issues into the corresponding repo, without having to leave
    their REPL or IDE. In the process, we''ll learn about many other very important
    aspects of programming with Julia, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Pkg to scaffold packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package versioning and dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driven development in Julia and how to unit test our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking and performance optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the GitHub API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting the code base and generating documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing packages (with a little help from Julia's bots!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ready? I sure hope so. Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Julia package ecosystem is under continuous development and new package
    versions are released on a daily basis. Most of the times this is great news,
    as new releases bring new features and bug fixes. However, since many of the packages
    are still in beta (version 0.x), any new release can introduce breaking changes.
    As a result, the code presented in the book can stop working. In order to ensure
    that your code will produce the same results as described in the book, it is recommended
    to use the same package versions. Here are the external packages used in this
    chapter and their specific versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to install a specific version of a package you need to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively you can install all the used packages by downloading the `Project.toml`
    file provided with the chapter and using `pkg>` instantiate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating a new Julia package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to create a new package, we must first satisfy a few prerequisites.
    To start with, we need `git` installed and configured on the development machine.
    The obvious reason for this is that, by default, Julia uses `git` and GitHub ([https://github.com/](https://github.com/))
    to host packages (although third-party, including private package, registries
    can also be used). If your current choice of operating system does not come with
    `git` preinstalled, please visit [https://git-scm.com/downloads](https://git-scm.com/downloads)
    for the official download page. Pick the right version for your OS and follow
    the installation instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Second, if you don't already have a GitHub account, you'll need one. Please
    visit [https://github.com](https://github.com) and set up a free account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have `git` installed and a GitHub account, let''s set up some global
    configuration options, as they''ll come in handy. Open a new Terminal window and
    execute the following—please make sure to replace the placeholder text within
    `<...>` with your actual information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So for example, in my case, the first command will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Please check that all went well by running `git config -l`. You should get
    an output similar to mine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! We're now ready to get down to the business of setting up our package.
  prefs: []
  type: TYPE_NORMAL
- en: Generating packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Julia''s package manager, `Pkg`, expects a certain file structure in order
    to manage dependencies, run tests, build binaries, generate documentation, and
    so on. Thankfully, we don''t have to create all these manually: we will use `Pkg`
    itself, namely the `generate` command. All we need to do is pass it the name of
    our package. Let''s call it `IssueReporter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A new folder was created for us, named `IssueReporter/`. Within it, we can find
    a `Project.toml` file and a subfolder, `src/`, which includes an `IssueReporter.jl`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The Project.toml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Project.toml` file is very special for `Pkg`, as it''s used for managing
    packages and their dependencies. It is meant to include meta-information, such
    as the name of the package, its unique identifier (called the **UUID**), the version
    number, the author''s name, and the list of dependencies. `Pkg` has already prepopulated
    it, to get us started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `Pkg` has picked up the correct author information based on
    my Git settings; it has filled up the package's name and generated a new UUID,
    and assigned the version number `0.1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: The src folder and the main module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `src/` folder also plays a special role. A path of the form `<Package Name>/src/<Package
    Name>.jl` is used by Julia to identify the entry point into a package—that is,
    its main module. This path will be searched when we invoke `using IssueReporter`.
    To get us to a good start, the `IssueReporter.jl` file has already been filled
    up with a few lines of code, just enough to bootstrap the corresponding module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using our new package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now activate the project and load our package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, our package''s environment has been activated and the included
    modules are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Excellent—everything is set up and ready for us to add logic, tests, and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the requirements for our package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of our project is to create a Julia package that will make it very
    easy to report bugs in other Julia packages. We want to allow the users of our
    library to access a simple API for programmatic reporting of issues, without the
    need to go to GitHub ([https://github.com/](https://github.com/)) to manually
    create a new issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we need to implement the following two features—a way
    to find out the GitHub URL of a registered package; and the means to access the
    GitHub API to register a new issue on the found repo. Given that `Pkg` is capable
    of cloning a package from GitHub using only the name of the package, we can safely
    assume that the information is available with our Julia install, and that somehow
    we''ll be able to access that information ourselves. Then, the aptly named `GitHub`
    package will help us to interface with GitHub''s API. We can start by adding it.
    Please make sure that the currently active project is `IssueReporter`. This should
    be indicated by the `(IssuerReporter)` prefix, placed in front of the `pkg>` cursor.
    If that is not the case, as previously explained, you need to `cd` into our package''s
    directory and then run `pkg> activate .` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'While we''re at it, let''s also add the `URIParser` package—we''ll work a lot
    with repo URLs and this functionality will come in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And, one more thing—we''ll use **test-driven development** (**TDD**) in order
    to build our project, so we''ll also need Julia''s `Test` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, all the packages have been added to the list of dependencies.
    You can confirm this by checking the `Project.toml` file, which is under the `[deps]`
    section and should now show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now we have all the prerequisites for adding our logic, the TDD way.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with test-driven Julia development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test-driven development is a software development practice based on a simple
    workflow that puts automated testing center stage. The basic idea is that the
    requirements are turned into very specific, well-defined, and targeted test cases.
    Each test should address only one piece of functionality. Once the test is ready,
    we run the whole test suite. Obviously, as we first write the test, it will initially
    fail. Next, we add the minimal implementation to make the test pass. That's it—all
    we need to do is repeat the same process until all the requirements are implemented.
    This approach ensures that our code base is thoroughly tested and that we focus
    on delivering just the requirements, avoiding feature creep.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia provides built-in unit testing capabilities under the `Test` module.
    It is very straightforward and easy to use, providing enough methods to cover
    all the basic testing scenarios: value and exception checking, approximate values,
    types, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The most important ones are the `@test`, `@test_throws`, and `@testset` macros.
    The `@test` macro checks that the `expression` passed as argument evaluates to
    true, returning a `PassResult`. If the test does not pass, it will return either
    a `FailResult` when the expression evaluates to `false`—or an `ErrorResult` if
    the expression can't be evaluated at all. The `@test_throws` macro checks that
    the evaluated expression throws an exception. Finally, `@testset` is used to group
    tests into sets. All the tests in a test set will run, and at the end of the test
    set, a summary of the results will be displayed. If any of the tests failed, or
    could not be evaluated due to an error, the test set will throw a `TestSetException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous snippet shows the output from both a passing and a failing test.
    The following one illustrates the use of test sets, with one passing and one failing
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this is how exceptions are handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the testing theory covered, let's continue by writing our first
    test. We will need a method that will take a package name and return the corresponding
    GitHub repo URL. This URL will be used in order to later interact with the GitHub
    API and open the issue into the corresponding repo. For now, we'll just check
    that the return value is a valid URL. We'll use the `URIParser` package to check
    the validity.
  prefs: []
  type: TYPE_NORMAL
- en: Julia makes it easy to add and run tests for our package, again, through the
    functionality provided by `Pkg` under the `test` command. When we run `(IssueReporter)
    pkg> test`, the `Pkg` library will look for a file called `runtests.jl` in the
    `test/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to add them—from within the Julia REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the newly created `runtests.jl` file in the editor, for example,
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Please make sure your `runtests.jl` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A test set block, defined by the `@testset` macro, groups multiple tests and/or
    other tests sets. The reason for using test sets is that when a test fails, an
    exception is thrown, causing the execution of the script to stop. However, when
    we have a large batch of tests, we usually prefer to allow all the tests to run
    and get a full report of what failed and what worked. With a test set, all the
    tests within the set will be run and a summary will be displayed at the end of
    the set. If any of the tests fail, or cannot be evaluated due to an error, the
    test set will then throw a `TestSetException`.
  prefs: []
  type: TYPE_NORMAL
- en: Test sets should have self-explanatory names relevant to the batch of tests
    they represent, as these labels are outputted when the tests are run.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It will fail with an informative message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The important bit is `UndefVarError: packageuri not defined`. This is unsurprising,
    as we have not yet defined the `IssueReporter.packageuri` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Peeking into Julia's registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we were saying, we need a way to retrieve the GitHub URI of a package, based
    on the package's name. Now, given that we're able to successfully execute operations
    such as `add` and `develop` with `Pkg`, without having to provide the GitHub URI,
    we can assume that there is a way to convert a package name to a package URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, Julia manages a repository of all the packages that are known to `Pkg`.
    These packages are grouped into multiple registries that are copied to your computer.
    By default, Julia comes with the so-called `General` registry, which can be found
    in the `.julia/` folder in your home directory. The `General` registry itself
    is nothing but a folder that contains subfolders named after each letter in the
    English alphabet (thus, from `A` to `Z`). Within each of these folders, we can
    find all the packages whose names start with that letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6abab19b-7d55-4b66-b195-3497520fd947.png)'
  prefs: []
  type: TYPE_IMG
- en: This screenshot shows a part of the `General` registry, with some of its folders
    (from `A` to `D`) and some of the packages starting with the letter `D`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make package retrieval more efficient, a special index file, called
    `Registry.toml`, is also placed inside the `General` folder. This file defines
    a hash-based index that maps package UUIDs to a dictionary of `name` and `path`
    values—the path being relative and pointing to a folder within the `General` registry.
    For example, this is the entry corresponding to the `D3Trees` package, the first
    one under the letter `D`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on, if we peek into the `D3Trees/` folder itself, we''ll see that it
    contains four files, each of them containing important metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60224858-81ad-498f-9ca5-402cd18423fb.png)'
  prefs: []
  type: TYPE_IMG
- en: The screenshot shows the four `Pkg` metadata files belonging to the `D3Trees`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: The `Deps.toml` file includes the list of dependencies (those packages required
    by `D3Trees` itself). The `Compat.toml` file stores compatibility requirements
    for the dependencies and for the Julia versions. `Package.toml` defines information
    such as name, UUID, and repo URL, and finally, `Versions.toml` shows all the known
    versions of `D3Trees` together with their corresponding Git references. It looks
    like we need the information within the `Package.toml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow, then, is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the path to Julia's `General` registry
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the `Registry.toml` file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for a package with the name that we're searching for
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the package exists, get its path in the `General` registry
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the corresponding `Package.toml` file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the package's GitHub URL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working with TOML files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tom''s Obvious, Minimal Language** (**TOML**) is a minimal configuration
    file format created by Tom Preston-Werner. TOML files serve the same purpose as
    other configuration formats, for example, the famous INI—although TOML''s goal
    is to be easier to read and easier to parse. YAML and JSON are other very popular
    configuration formats that you may have encountered. `Pkg` makes extensive usage
    of TOML for storing package metadata.'
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about TOML, including the full specification, at [https://github.com/toml-lang/toml](https://github.com/toml-lang/toml).
  prefs: []
  type: TYPE_NORMAL
- en: 'A TOML parser for Julia is available at [https://github.com/wildart/TOML.jl](https://github.com/wildart/TOML.jl),
    but we don''t need to explicitly add it as `Pkg` comes bundled with a TOML parser
    that we will use instead. But, this means that we do have to declare `Pkg` as
    a dependency of `IssueReporter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, to implement the preceding workflow. First, the path to the `General` registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia keeps track of a list of locations where important information is stored.
    This info includes configuration files, environments, installed packages, and
    registries. In Julia''s lingo, these are called **depots** and are stored in the
    `DEPOT_PATH` global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The contents of the `DEPOT_PATH` array on my computer are shown here. Your output
    will be different, but similar.
  prefs: []
  type: TYPE_NORMAL
- en: The first entry is the user depot where registries are cloned, new package versions
    are installed, package repos are cloned, log files are written, development packages
    are checked out by default, and global configuration data is saved. Later entries
    in the depot path are read-only and are used for operations performed by system
    administrators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new (failing) test for getting the `General` registry path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the implementation, we will want to loop over each entry in the `DEPOT_PATH`
    and check if it contains a `registries/General` path of directories. These should
    be in the user depot, but a more extensive lookup will make our code more robust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the path to the `General` registry, we''ll want to parse the `Registry.toml`
    file and extract the information corresponding to the package we''ll be searching
    for. Once parsed, the `Registry.toml` file produces in a dictionary with five
    entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re only interested in the *packages* data, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And actually, we don''t want all that, since we don''t care about the UUID;
    only the name and the path. Let''s add a new function to the `IssueReporter` module,
    to reflect this spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the function is similar to this, an array of `Dict` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have this, it is very easy to perform a package lookup by name. We
    simply iterate over each item and compare the `"name"` value against the search
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After we identify a package by name, we can use the path value to build the
    path to the folder that contains the package's metadata information. Remember
    that we're after the `Package.toml` file, as this contains the repo URI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it all together, we can finally write our `IssueReporter.packageuri`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `IssueReporter.jl` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The IssueReporter.jl package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running the tests again will be successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e7c324e-9905-43ac-b1ca-b8e9282253f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you''re curious, the GitHub repo URI for `DataFrames`, according to `IssueReporter`,
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can check for yourself in the web browser to confirm that it
    is indeed, the correct URI.
  prefs: []
  type: TYPE_NORMAL
- en: Performance testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our code works correctly so far, but what about it's performance? Besides its
    readable syntax, liberal license, rich package ecosystem, and welcoming community,
    performance is one of the top reasons why data scientists and software developers
    choose Julia. The compiler does a great job of providing excellent performance
    out of the box, but there are certain best practices that we as developers must
    keep in mind to ensure that we basically don't hinder the compiler. We'll go over
    the most important ones by looking at a few examples while running some benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given its focus on performance, it should come as no surprise that both core
    Julia and the ecosystem provide a variety of tools for inspecting our code, looking
    for bottlenecks and measuring runtime and memory usage. One of the simplest is
    the `@time` macro. It takes an expression and then prints its execution time,
    number of allocations, and the total number of bytes the execution caused to be
    allocated, before returning the result of the expression. For example, note the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Generating an array of one million integers by iterating from one to one million
    takes 0.03 seconds. Not bad, but what if I told you that we can do better—much
    better? We just committed one of the cardinal sins of Julia—code should not be
    run (nor benchmarked) in the global scope. So, rule one—always wrap your code
    into functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous snippet can easily be refactored as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the benchmark is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: All right, that's clearly faster—but not much faster. However, what if we run
    the benchmark one more time?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Wow, that's an order of magnitude faster! So, what gives?
  prefs: []
  type: TYPE_NORMAL
- en: If you remember from our coverage of functions and methods, Julia uses a **just-in-time**
    (**JIT**) compiler; that is, a function is compiled in real time when it is invoked
    for the first time. So, our initial benchmark also included the compilation time.
    This brings us to the second rule—don't benchmark the first run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to accurately measure the performance of a piece of code, thus,
    would be to execute it multiple times and then compute the mean. There is a great
    tool, specially designed for this use case, called `BenchmarkTools`. Let''s add
    it and give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`BenchmarkTools` took `1788` samples, with an evals to sample ratio of `1`.
    Here, a sample represents a measurement, while an evaluation is an execution of
    the benchmark expression. We got a maximum time of 55 milliseconds, driven by
    the garbage collection, with a minimum of 1.3 milliseconds, and a mean of 2.7
    milliseconds. That is in line with what the second `@time` execution revealed,
    at 2.4 milliseconds—but this benchmark is far more accurate. We can also use the
    more compact `@btime` macro, which has an output similar to `@time`, but executes
    an equally comprehensive benchmark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`BenchmarkTools` exposes a very rich API and it''s worth getting to know it
    well. You can read more about it at [https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/doc/manual.md](https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/doc/manual.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Type stability is key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there is one thing that has a direct and massive impact on the performance
    of Julia code, it's the type system. And the most important thing about it is
    to write code that is type-stable. Type stability means that the type of a variable
    (including the return value of a function) must not vary with time or under different
    inputs. Understanding how to leverage type stability is key to writing fast software.
    Now that we know how to measure our code's execution time, we can see the effect
    of type instability with a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take this innocent-looking function, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing fancy about it. We have a variable, `x`, which is initialized
    to `0`—and then a loop from `1` to `10`, where we add the `sin` of a number to
    `x`. And then we return `x`. Nothing to see, right? Well, actually, quite the
    contrary—a few bad things, performance-wise, are happening here. And they all
    have to do with type instability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia provides a great tool for inspecting and diagnosing code for type-related
    issues—the `@code_warntype` macro. Here''s what we get when we use it with our
    `f1` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acb8a124-d316-4c01-8f17-d5985117cd02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This time, I''m using a screenshot for the output, in order to illustrate the
    color coding. As you might expect, green is good and red is bad. I am also marking
    the red flags with a rectangle. The problems are with `Body::Union{Float64, Int64}` on
    the first line, `(#4 => 0, #14 => %29)::Union{Float64, Int64}` on line `12`, and
    `(#13 => %29, #4 => 0)::Union{Float64, Int64}` on the penultimate line.'
  prefs: []
  type: TYPE_NORMAL
- en: On the first line, the `Body::Union{Float64, Int64}`, as well as on the penultimate
    line, `::Union{Float64, Int64}`, tell us the same thing—the function returns a
    `Union{Float64, Int64}`, meaning that the function can return either a `Float`
    or an `Integer`. This is textbook type instability and bad news for performance.
    Next, on line `12`, *something* has a type of `Union{Float64, Int64}` and this
    value is then returned as the result of the function. In case you're wondering,
    that *something* is `x`.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that we unsuspectingly initialized `x` to `0`, an `Integer`.
    However, the `sin` function will return a `Float`. Adding a `Float` to an `Integer`
    will result in a `Float`, causing the type of `x` to change accordingly. Thus,
    `x` has two types during the execution of the function, and since we return `x`,
    our function is also type-unstable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Granted, understanding the output of `@code_warntype` is not easy, although
    it does get easier with time. However, we can make our job easier by using the
    super-useful `Traceur` package. It provides a `@trace` macro, which generates
    human-friendly information. Let''s add it and try it out; you''ll appreciate it,
    I''m sure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How cool is that? Crystal clear!
  prefs: []
  type: TYPE_NORMAL
- en: 'With this feedback in mind, we can refactor our code into a new `f2` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Awesome, nothing to report! No news is good news!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can benchmark `f1` and `f2` to see the result of our refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: That's nice—79 versus 129 nanoseconds! If you're thinking that *It's just 50
    nanoseconds, what's all the fuss about?*, you need to look at it this way—`f2`,
    the type-stable variant, is almost twice as fast as `f1`! And that's a really
    big deal!
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to apply what we''ve learned to our own code base. Heads up, I have
    intentionally sneaked in a few problems, to spice things up a bit. Let''s fix
    them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10c7d5ce-3ae9-42aa-8b1f-cf29fb6ea23f.png)'
  prefs: []
  type: TYPE_IMG
- en: This is all very interesting—let's see what we can learn from it.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with line `1`, the `IssueReporter.generalregistrypath` function returns
    a `Union{Nothing, String}`. The reason is that our function does not handle the
    case when the `for` loop is not entered, or when the `if` statement is not executed.
    We should make sure that our function always returns a value and that the type
    of this return value does not change. To be extra sure, we can also add a type
    assertion to the function definition itself. If we accidentally return the wrong
    type, Julia will try to convert it to the declared type—if that doesn't work,
    an error is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to redefine the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, on to the line starting with `%2` (the third line)—the `searchregistry`
    function returns a value of type `Any`. The issue here is that we return an item
    coming from the invocation of `generalregistry`, so we need to look at that first.
    We'll add a check for the return value of `generalregistrypath`, and we add a
    default return value, an empty `Vector{Dict{String,Any}}`. Then, for `searchregistry`,
    we'll also add a default return value—since it returns an item from this `Vector`,
    it will be of type `Dict{String,Any}`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in regards to the `packageuri` function, in the line starting with `%9` (on
    line `11`), we can see something about a `KeyError` and `repo`. Julia is warning
    us that it's possible that we won't have a key named `repo`, thus leading to a
    `KeyError`. Also, the function returns an object of type `Any`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the three functions, refactored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now recheck our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aec1e4c4-9374-4937-8a4e-952d886aaccd.png)'
  prefs: []
  type: TYPE_IMG
- en: Excellent, almost everything is green! There's just one red `Any`, coming from
    the `TOML.parsefile` function itself, but it's just not worth optimizing that
    away; the extra work would cancel the benefit.
  prefs: []
  type: TYPE_NORMAL
- en: It's definitely worth spending some time going over the official performance
    recommendations, available online at [https://docs.julialang.org/en/v1/manual/performance-tips/](https://docs.julialang.org/en/v1/manual/performance-tips/).
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the GitHub API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can retrieve the GitHub URI for any package in the `General` registry,
    we can use it to interact with the GitHub API. Julia developers have access to
    a powerful GitHub library provided by the GitHub package. It's what we'll use
    in order to create new issues on the packages' GitHub repos.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating with the GitHub API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to be allowed to interact with the GitHub API, we have to authenticate.
    This will permit our package to execute actions on GitHub under the user''s account
    as if done directly through the website. Please access [https://github.com/settings/tokens/new](https://github.com/settings/tokens)
    to set up a new GitHub access token. If you''re not familiar with the concept
    and would like to learn more about this, please read on and follow the official
    instructions at [https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/).
    Give the token a good description and, very importantly, make sure that you check
    the repo scope, just as you can see in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4109ce90-615c-403b-ac74-a4fe1de71118.png)'
  prefs: []
  type: TYPE_IMG
- en: Once generated, write down the token—once you leave that page, you won't see
    it again.
  prefs: []
  type: TYPE_NORMAL
- en: The access tokens must be manipulated with care—and must not be committed to
    git or other source control systems where they can be accessed by other users.
    Anybody that gets your access token can use it to impersonate you on GitHub. To
    be on the safe side, please make sure that for this project, you only check the
    repo scope.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a bit of logic to make the access token available to our package without
    compromising security. It should work as follows—first, we check if the access
    token is provided as a command line parameter to the Julia process—meaning that
    it will be available in the `ENV` collection. If it's not, we'll look for a file
    called `secrets.jl` in the root folder of the package and include it. The file
    will contain the access token so we'll add it to `.gitignore`, to make sure it's
    not accidentally committed to git.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s write the tests. Append the following at the end of `runtests.jl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The tests will fail, of course, so let's make them pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these function definitions to `IssueReporter.jl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `tokenisdefined` function, we check if the `GITHUB_ACCESS_TOKEN` environment
    variable is already defined—if not, we check for the `secrets.jl` file and, if
    it exists, we include it. Once included, the `secrets.jl` file should define the
    variable, so finally, we check again for the existence of `GITHUB_ACCESS_TOKEN`.
    If the token is still not defined, the function returns `false`—otherwise, `true`.
    We''ve also added a token function that invokes `tokenisdefined`, giving the module
    the chance to set up `GITHUB_ACCESS_TOKEN`. If the token is available, it returns
    it—if not, this time an error is thrown. Our tests should now pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This is it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f998ece-b5fe-420e-8b2b-7854bd0c9201.png)'
  prefs: []
  type: TYPE_IMG
- en: Success!
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, we need to add the `secrets.jl` file to `.gitignore`—committing
    this to a public GitHub repo would be a huge security error. From the Julia REPL,
    note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you need to create the `secrets.jl` file itself and make sure that it
    contains something similar to the next snippet, but adding your own GitHub access
    token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Excellent, we're ready to report issues!
  prefs: []
  type: TYPE_NORMAL
- en: Reporting GitHub issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're now down to the last step—using the GitHub API to report problems. In
    order to register an issue, we need two pieces of information—the title and the
    body. As such, we'll have to define a new function, called `report`, which will
    accept *three* string arguments—the name of the package, plus two more for the
    title and the body of the issue. Internally, the function will make an authenticated
    call to the corresponding GitHub API via the GitHub package.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the documentation, a call to the `GitHub.create_issue` method
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the GitHub token to authenticate and generate the required `GitHub.OAuth2`
    authentication object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Starting from the Julia package name, compute the GitHub username and repo info—for
    this, we'll use the already implemented `IssueReporter.packageurl`, plus some
    extra processing to remove the unwanted parts from the URL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the call to `GitHub.create_issue`, passing in all the required arguments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we''re doing TDD, let''s begin by converting these specifications into
    tests. Add the following at the very bottom of the `runtests.jl` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The tests mirror, in the exact same order, the requirements we previously expressed
    in plain English. The first one invokes a function that we'll have to write, called
    `IssueReporter.githubauth`, which will perform the GitHub authentication and will
    return a `GitHub.OAuth2` object if successful. Next, we'll need a new `repoid`
    function, which will take the name of a package and will return the GitHub username
    and repo name. Notice that we're using my repo of the `IssueReporter` package
    as the guinea pig for our testing. Finally, we test the issue creation, which
    will be done by the `IssueReporter.report` method—on success, we expect a `GitHub.Issue`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Don't use Julia for anything evil! The code we're writing will actually register
    new issues on live GitHub repos. Please be respectful of the hard work of the
    open source contributors and don't overload them with fake issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to make the tests pass by writing the implementations. Make sure that
    the `using` directive of the `IssueReporter` module reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, add the following functions to the bottom of the `IssueReporter`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Pretty straightforward. The `githubauth` function invokes the `GitHub.authenticate`
    method, passing it the auth token provided by a call to the token function.
  prefs: []
  type: TYPE_NORMAL
- en: The `repoid` method accepts a string parameter for the name of the repo, then
    invokes the `packageuri` and the `URIParse.parse_url` to generate a URI object
    corresponding to the GitHub repo. We then extract the path component of the URI
    and process it to keep only the GitHub username and the repo name. In other words,
    starting with the package named `IssueReporter`, we retrieve the GitHub repo URL,
    which is `git://github.com/essenciary/IssueReporter.jl.git`. The path component
    is `/essenciary/IssueReporter.jl.git`. We use replace with the `r".git$"` regex
    to remove the `.git` ending before returning the substring starting from the second
    letter. At the end, we have what we need—`essenciary/IssueReporter.jl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, the report function puts it all together by invoking the `GitHub.create_issue`
    method and passing it the `repoid`, the authentication object, and the title and
    body of the issue within a `Dict`. All the tests should pass now and the issues
    are successfully created on Github.com ([https://github.com/](https://github.com/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/668b4028-4bd8-4a21-8f2f-5f67691461b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Please note that the sample code provided with the chapter has the `create issue`
    functionality commented out—and instead it has hard-coded a dummy repository.
    Again, out of respect for the contributors and followers of the real repos, the
    actual issues will be created on a dummy repository that I created especially
    for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting our package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our package is now complete! Let's make it easy for our users to take advantage
    of the amazing convenience provided by `IssueReporter`—we'll supply them an informative
    documentation. We already know how to document our code by using `DocStrings`
    - which can be used by ourselves and other developers to understand our source
    code. It's also used by the REPL's help system (remember from [Chapter 1](90a7f09d-d63b-45d7-baf5-576470d0910f.xhtml), *Getting
    Started with Julia Programming* that you can type `?` at the beginning of the
    line to switch the REPL to help mode). You'll be happy to hear that we can also
    generate package documentation using the same `DocStrings`, with the help of a
    package called `Documenter`. Please add it with `(IssueReporter) pkg> add Documenter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first thing to do is add some `DocStrings` to our functions. Keep in
    mind that the *official* recommendation is to include the function''s signature
    together with a small description and a few examples. For instance, the documentation
    for the `IssueReporter.packageuri` function could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62] jldoctest julia> IssueReporter.packageuri("IssueReporter") "git://github.com/essenciary/IssueReporter.jl.git"
    [PRE63]'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced documentation tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Another valuable feature of `DocStrings` is that the examples can also serve
    as tests. This kind of testing is called a **doctest**. Basically, when we provide
    a REPL example together with the corresponding output, if we tag this as a *jldoctest*,
    the `Documenter` package used to generate the documentation will also run the
    examples and compare the result against the provided output, thus testing the
    examples and, implicitly, our code. Check the next snippet to see what the previous
    example looks like after we apply these optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have added comments to all the functions that represent the *public* API
    of `IssueReporter`. Here are the updated function definitions (you can get the
    full file from this chapter''s repo at [https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter11/IssueReporter/src/IssueReporter.jl](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter11/IssueReporter/src/IssueReporter.jl)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]julia-repl'
  prefs: []
  type: TYPE_NORMAL
- en: julia> IssueReporter.packageuri("IssueReporter")
  prefs: []
  type: TYPE_NORMAL
- en: '"git://github.com/essenciary/IssueReporter.jl.git"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]jldoctest'
  prefs: []
  type: TYPE_NORMAL
- en: julia> IssueReporter.repo_id("IssueReporter")
  prefs: []
  type: TYPE_NORMAL
- en: '"essenciary/IssueReporter.jl"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Generating the documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to create our documentation, we'll need to first create a `docs/` folder
    inside our `IssueReporter` root directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `docs/` folder, we need two more things—first, a `src/` folder,
    which will contain the markdown template that will be used to build the documentation,
    the `index.md` file; second, a `make.jl` file that will control the documentation
    building process. Here is the full file structure of our package, for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/125def3c-c57d-4429-af88-e08d85d9bce4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, open the `docs/make.jl` file in the editor and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open the `index.md` file in the editor and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]@meta'
  prefs: []
  type: TYPE_NORMAL
- en: CurrentModule = IssueReporter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]@contents'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]@docs'
  prefs: []
  type: TYPE_NORMAL
- en: packageuri(pkgname::String)
  prefs: []
  type: TYPE_NORMAL
- en: tokenisdefined()
  prefs: []
  type: TYPE_NORMAL
- en: token()
  prefs: []
  type: TYPE_NORMAL
- en: githubauth()
  prefs: []
  type: TYPE_NORMAL
- en: repoid(package_name::String)
  prefs: []
  type: TYPE_NORMAL
- en: report(package_name::String, title::String, body::String)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]@index'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This is the markdown template of our documentation. At the top, we have the
    title of the page. Then, the `@meta` block contains information for `Documenter`,
    passing in the name of the module. The `@contents` block will be replaced with
    the table of contents. The `@docs` block will contain the documentation for each
    of the functions included. At the bottom, the `@index` block will be replaced
    by a list of links to each of the documented functions.
  prefs: []
  type: TYPE_NORMAL
- en: That's all. In order to generate the documentation, we need to run `$ julia
    --color make.jl` from an OS Terminal, from within the `docs/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the command will show the progress of building the docs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated documentation can be found at `docs/build/index.html`, and looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31055def-d852-4a81-afb9-24d2dcf03d2f.png)'
  prefs: []
  type: TYPE_IMG
- en: Registering our package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, for the last step—making our package available to the world! For starters,
    we need to create the remote GitHub repository and push our code to it. The easiest
    way to do this is with the `hub` binary, provided by GitHub. Please follow the
    installation instructions for your platform, as described at [https://github.com/github/hub](https://github.com/github/hub).
    Once ready, we''ll need to run `hub create` in the root of the `IssueReporter`
    folder. We can do it in Julia''s REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You'll be prompted for your GitHub username and password—and if all goes well,
    you'll see the output confirming that the repo was created.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we need to commit and push our changes—but before doing that, let's make
    a final change to `.gitignore` to also add `docs/build` to the list of ignored
    files. It is a bad practice to include the built docs into the GitHub commits—for
    more information about hosting documentation on GitHub, please read the official
    `Documenter` info at [https://juliadocs.github.io/Documenter.jl/latest/man/guide/#Usage-1](https://juliadocs.github.io/Documenter.jl/latest/man/guide/#Usage-1)
    and [https://juliadocs.github.io/Documenter.jl/latest/man/hosting/#Hosting-Documentation-1](https://juliadocs.github.io/Documenter.jl/latest/man/hosting/#Hosting-Documentation-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re at it, let''s also add a `README.md` file to the root folder of
    `IssueReporter`, to include a bit of info:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using your favorite git client, `add`, `commit`, and `push` the code base.
    I''m going to use the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Unleashing Julia's army of bots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our package is looking great—it's now time to tag a release and register it.
  prefs: []
  type: TYPE_NORMAL
- en: Julia contributors have developed a series of very useful GitHub integrations,
    namely, *bots*. These bots help us, humans, to automate a series of boring tasks
    so that we can focus on the really important things (mmm, pizza!).
  prefs: []
  type: TYPE_NORMAL
- en: 'One of them is Attobot, a package release bot for Julia. It creates pull requests
    to Julia''s `General` registry when releases are tagged in GitHub. Try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To set up Attobot, open your `IssueReporter` GitHub repo and go to [https://github.com/integration/attobot](https://github.com/integration/attobot).
    Please make sure that you're logged into your GitHub account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click Configure to select the repositories you wish to add.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Only select repositories, and then select `IssueReporter` and click Save.
    Now, Attobot is configured to monitor packages with the standard `.jl` extension—and
    publish them on the `Global` registry when new releases are tagged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For more details about Attobot, please visit [https://github.com/attobot/attobot](https://github.com/attobot/attobot).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to go to our repo''s GitHub page and click on the releases link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/887ff6ff-9ca3-4050-976f-2baca06e9d2f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we are given the option to Create a new release:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2332f178-74bb-4118-b178-c0024c3a803a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the next screen, we''ll be able to tag our release. Julia uses semantic
    versioning (which looks like vX.Y.Z) and recommends starting with `v0.0.1`. Let''s
    do just that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bb2f8d04-78ad-4343-9f98-0a5f327362a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, click Publish release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are any problems, Attobot will open issues in the repo—make sure you
    address them. Once done, the package will be registered! Victory!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is exciting to see our package finally ready!
  prefs: []
  type: TYPE_NORMAL
- en: While developing it, we've also learned about Julia's powerful toolbox, and
    about some of the most important best practices of software development in general—TDD,
    unit testing, benchmarking, and documenting our code base and publishing the resulting documentation.
  prefs: []
  type: TYPE_NORMAL
- en: This also concludes our journey into learning the Julia language. We've come
    a long way since opening the REPL for the first time—and you have achieved some
    impressive feats! Data analysis, plotting, web scraping, recommenders, supervised
    and unsupervised machine learning, and time series analysis and forecasting! You
    are now able to do all these things using Julia. Wow! That's quite an amazing
    track record indeed! And, if doing all this seemed easy, it's all due to Julia's
    incredible features. The productive REPL, the simple package installation, the
    handy plotting packages, or the readable syntax; they all make programming easy
    and fun.
  prefs: []
  type: TYPE_NORMAL
- en: Julia really is a new breed of programming language. As it is new, it is able
    to learn from the most successful programming languages by borrowing from their
    strengths, and avoid their mistakes. Julia was specifically designed to efficiently
    address the needs of our generation—machine learning, artificial intelligence,
    high performance, parallel, GPU, and distributed cloud computing—these are all
    areas where the language excels.
  prefs: []
  type: TYPE_NORMAL
- en: But, not only does Julia provide efficient language constructs for writing highly
    performant code—it also makes for a productive development experience. The powerful
    REPL (one of the best REPLs in all existing programming languages, period!) and
    the JIT compilation make it easy to quickly prototype solutions, slice and dice
    large amounts of data, or experiment with data models on the fly. The integrated
    help mode and the powerful shell mode empower developers, boosting productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Then there's the seamless integration with Jupyter Notebooks via IJulia—and
    the incredible cross-language integration with established programming languages
    such as Python and R. If you've used with these technologies, switching to Julia
    should be straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: But the fact that Julia is new, just reaching version 1, does not mean that
    Julia is not a mature language. It's been crafted with care and attention for
    over six years—with contributions from thousands of developers. So, I encourage
    you to start using Julia for solving real problems. You'd be joining tens of thousands
    of other developers using the language professionally, for scientific computing,
    data science, AI, fintech, web development, teaching, and much more. Household
    names such as Apple, Amazon, Facebook, and Oracle—to name just a few—were all
    looking to hire Julia programmers in 2017.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed reading this book as much as I enjoyed writing it. You are
    now prepared—and I hope eager—to use Julia in your projects. So, instead of *Goodbye*,
    I'd like to say—*Welcome to the wonderful world of Julia programming!*
  prefs: []
  type: TYPE_NORMAL
