- en: Creating Julia Packages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Julia 包
- en: We've come a long way since the beginning of our journey toward learning Julia.
    I hope you enjoyed this process of discovery as much as I did! We've covered a
    lot of ground, learning about many key topics while developing quite a suite of
    fully functional applications. Yet, there's one thing left in order to fully earn
    our Julia developer badge. The signature of every proficient Julia programmer—(drumroll,
    please!)—creating, publishing, and registering our own *official* Julia package!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自我们从学习 Julia 的旅程开始以来，我们已经走了很长的路。我希望你享受这个发现过程，就像我一样！我们已经覆盖了很多领域，在开发一系列完全功能的应用程序的同时，学习了众多关键主题。然而，为了完全获得我们的
    Julia 开发者徽章，我们还有一件事要做。每位熟练的 Julia 程序员的标志——（敲鼓声，请！）——创建、发布和注册我们自己的 *官方* Julia 包！
- en: 'In this chapter, we''ll build a REPL app and we''ll wrap it into a package.
    Our product will help Julia developers to easily report bugs they encounter in
    other Julia packages. Once the users install and configure our package, they will
    be able to open GitHub issues into the corresponding repo, without having to leave
    their REPL or IDE. In the process, we''ll learn about many other very important
    aspects of programming with Julia, such as the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个 REPL 应用程序，并将其封装成一个包。我们的产品将帮助 Julia 开发者轻松地报告他们在其他 Julia 包中遇到的错误。一旦用户安装并配置了我们的包，他们就能直接在相应的仓库中打开
    GitHub 问题，而无需离开他们的 REPL 或 IDE。在这个过程中，我们将学习到许多其他与 Julia 编程密切相关的重要方面，例如以下内容：
- en: Using Pkg to scaffold packages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pkg 搭建包
- en: Package versioning and dependencies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包版本控制和依赖关系
- en: Test-driven development in Julia and how to unit test our code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 中的测试驱动开发以及如何进行单元测试我们的代码
- en: Benchmarking and performance optimization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试和性能优化
- en: Interacting with the GitHub API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 GitHub API 交互
- en: Documenting the code base and generating documentation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录代码库并生成文档
- en: Publishing packages (with a little help from Julia's bots!)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布包（在 Julia 的机器人的一点点帮助下！）
- en: Ready? I sure hope so. Let's go!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？我确实希望如此。让我们开始吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The Julia package ecosystem is under continuous development and new package
    versions are released on a daily basis. Most of the times this is great news,
    as new releases bring new features and bug fixes. However, since many of the packages
    are still in beta (version 0.x), any new release can introduce breaking changes.
    As a result, the code presented in the book can stop working. In order to ensure
    that your code will produce the same results as described in the book, it is recommended
    to use the same package versions. Here are the external packages used in this
    chapter and their specific versions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的包生态系统正在不断发展，每天都有新的包版本发布。大多数时候，这是一个好消息，因为新版本带来了新功能和错误修复。然而，由于许多包仍在测试版（版本
    0.x）中，任何新版本都可能引入破坏性更改。因此，书中展示的代码可能会停止工作。为了确保你的代码会产生与书中描述相同的结果，建议使用相同的包版本。以下是本章中使用的外部包及其特定版本：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to install a specific version of a package you need to run:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装特定版本的包，你需要运行：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively you can install all the used packages by downloading the `Project.toml`
    file provided with the chapter and using `pkg>` instantiate as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以通过下载本章提供的 `Project.toml` 文件，并使用 `pkg>` 实例化来安装所有使用的包，如下所示：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating a new Julia package
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的 Julia 包
- en: In order to create a new package, we must first satisfy a few prerequisites.
    To start with, we need `git` installed and configured on the development machine.
    The obvious reason for this is that, by default, Julia uses `git` and GitHub ([https://github.com/](https://github.com/))
    to host packages (although third-party, including private package, registries
    can also be used). If your current choice of operating system does not come with
    `git` preinstalled, please visit [https://git-scm.com/downloads](https://git-scm.com/downloads)
    for the official download page. Pick the right version for your OS and follow
    the installation instructions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个新的包，我们首先必须满足一些先决条件。首先，我们需要在开发机器上安装并配置 `git`。显然，这是因为默认情况下，Julia 使用 `git`
    和 GitHub ([https://github.com/](https://github.com/)) 来托管包（尽管也可以使用第三方，包括私有包的注册表）。如果你的操作系统没有预装
    `git`，请访问 [https://git-scm.com/downloads](https://git-scm.com/downloads) 获取官方下载页面。选择适合你操作系统的正确版本，并按照安装说明进行操作。
- en: Second, if you don't already have a GitHub account, you'll need one. Please
    visit [https://github.com](https://github.com) and set up a free account.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，如果你还没有GitHub账户，你需要一个。请访问[https://github.com](https://github.com)并设置一个免费账户。
- en: 'Now that we have `git` installed and a GitHub account, let''s set up some global
    configuration options, as they''ll come in handy. Open a new Terminal window and
    execute the following—please make sure to replace the placeholder text within
    `<...>` with your actual information:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了`git`并拥有GitHub账户，让我们设置一些全局配置选项，因为它们将很有用。打开一个新的终端窗口并执行以下操作——请确保将`<...>`内的占位文本替换为你的实际信息：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So for example, in my case, the first command will be as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我的情况下，第一个命令将是以下内容：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Please check that all went well by running `git config -l`. You should get
    an output similar to mine:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请通过运行`git config -l`来检查一切是否顺利。你应该会得到一个类似于我的输出：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Excellent! We're now ready to get down to the business of setting up our package.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 极好！我们现在已经准备好开始设置我们的包。
- en: Generating packages
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成包
- en: 'Julia''s package manager, `Pkg`, expects a certain file structure in order
    to manage dependencies, run tests, build binaries, generate documentation, and
    so on. Thankfully, we don''t have to create all these manually: we will use `Pkg`
    itself, namely the `generate` command. All we need to do is pass it the name of
    our package. Let''s call it `IssueReporter`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的包管理器`Pkg`期望一定的文件结构以便管理依赖项、运行测试、构建二进制文件、生成文档等。幸运的是，我们不必手动创建所有这些：我们将使用`Pkg`本身，即`generate`命令。我们只需要传递我们包的名称。让我们称它为`IssueReporter`：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A new folder was created for us, named `IssueReporter/`. Within it, we can find
    a `Project.toml` file and a subfolder, `src/`, which includes an `IssueReporter.jl`
    file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们创建了一个新文件夹，命名为`IssueReporter/`。在其中，我们可以找到一个`Project.toml`文件和一个子文件夹`src/`，它包含一个`IssueReporter.jl`文件。
- en: The Project.toml file
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Project.toml文件
- en: 'The `Project.toml` file is very special for `Pkg`, as it''s used for managing
    packages and their dependencies. It is meant to include meta-information, such
    as the name of the package, its unique identifier (called the **UUID**), the version
    number, the author''s name, and the list of dependencies. `Pkg` has already prepopulated
    it, to get us started:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Project.toml`文件对于`Pkg`来说非常特殊，因为它用于管理包及其依赖项。它旨在包含元信息，例如包的名称、其唯一标识符（称为**UUID**）、版本号、作者的姓名以及依赖项列表。`Pkg`已经预先填充了它，以帮助我们开始：'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, `Pkg` has picked up the correct author information based on
    my Git settings; it has filled up the package's name and generated a new UUID,
    and assigned the version number `0.1.0`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Pkg`已经根据我的Git设置提取了正确的作者信息；它已经填写了包的名称并生成了一个新UUID，并分配了版本号`0.1.0`。
- en: The src folder and the main module
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: src文件夹和主模块
- en: 'The `src/` folder also plays a special role. A path of the form `<Package Name>/src/<Package
    Name>.jl` is used by Julia to identify the entry point into a package—that is,
    its main module. This path will be searched when we invoke `using IssueReporter`.
    To get us to a good start, the `IssueReporter.jl` file has already been filled
    up with a few lines of code, just enough to bootstrap the corresponding module:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/`文件夹也扮演着特殊角色。Julia使用形式为`<Package Name>/src/<Package Name>.jl`的路径来识别包的入口点——即其主模块。当我们调用`using
    IssueReporter`时，将会搜索这个路径。为了让我们有一个良好的开始，`IssueReporter.jl`文件已经填充了一些代码行，足以启动相应的模块：'
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using our new package
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我们的新包
- en: 'We can now activate the project and load our package:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以激活项目并加载我们的包：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At this point, our package''s environment has been activated and the included
    modules are available:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的包环境已经激活，并包含了模块：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Excellent—everything is set up and ready for us to add logic, tests, and documentation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 极好——一切都已经设置好，准备让我们添加逻辑、测试和文档。
- en: Defining the requirements for our package
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们包的需求
- en: The goal of our project is to create a Julia package that will make it very
    easy to report bugs in other Julia packages. We want to allow the users of our
    library to access a simple API for programmatic reporting of issues, without the
    need to go to GitHub ([https://github.com/](https://github.com/)) to manually
    create a new issue.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的目标是创建一个Julia包，使得报告其他Julia包中的错误变得非常容易。我们希望允许我们库的用户访问一个简单的API，用于程序化报告问题，而无需手动前往GitHub
    ([https://github.com](https://github.com))创建一个新的问题。
- en: 'In order to do this, we need to implement the following two features—a way
    to find out the GitHub URL of a registered package; and the means to access the
    GitHub API to register a new issue on the found repo. Given that `Pkg` is capable
    of cloning a package from GitHub using only the name of the package, we can safely
    assume that the information is available with our Julia install, and that somehow
    we''ll be able to access that information ourselves. Then, the aptly named `GitHub`
    package will help us to interface with GitHub''s API. We can start by adding it.
    Please make sure that the currently active project is `IssueReporter`. This should
    be indicated by the `(IssuerReporter)` prefix, placed in front of the `pkg>` cursor.
    If that is not the case, as previously explained, you need to `cd` into our package''s
    directory and then run `pkg> activate .` as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要实现以下两个功能——一种找出已注册包的GitHub URL的方法；以及访问GitHub API在找到的仓库上注册新问题的手段。鉴于`Pkg`能够仅使用包名从GitHub克隆包，我们可以安全地假设这些信息与我们的Julia安装一起可用，并且我们将在某种方式下能够访问这些信息。然后，名为`GitHub`的包将帮助我们与GitHub的API进行接口。我们可以先添加它。请确保当前活动项目是`IssueReporter`。这应该由放在`pkg>`光标前的`(IssuerReporter)`前缀表示。如果不是这种情况，如前所述，您需要`cd`到我们的包目录，然后按照以下方式运行`pkg>
    activate .`：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'While we''re at it, let''s also add the `URIParser` package—we''ll work a lot
    with repo URLs and this functionality will come in handy:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们忙于这件事时，也可以添加`URIParser`包——我们将大量使用仓库URL，这个功能将很有用：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And, one more thing—we''ll use **test-driven development** (**TDD**) in order
    to build our project, so we''ll also need Julia''s `Test` module:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一件事——我们将使用**测试驱动开发**（**TDD**）来构建我们的项目，因此我们还需要Julia的`Test`模块：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point, all the packages have been added to the list of dependencies.
    You can confirm this by checking the `Project.toml` file, which is under the `[deps]`
    section and should now show the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有包都已添加到依赖项列表中。您可以通过检查`Project.toml`文件来确认这一点，该文件位于`[deps]`部分，现在应显示以下内容：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we have all the prerequisites for adding our logic, the TDD way.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经具备了添加逻辑的所有先决条件，采用TDD方式。
- en: Beginning with test-driven Julia development
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从测试驱动的Julia开发开始
- en: Test-driven development is a software development practice based on a simple
    workflow that puts automated testing center stage. The basic idea is that the
    requirements are turned into very specific, well-defined, and targeted test cases.
    Each test should address only one piece of functionality. Once the test is ready,
    we run the whole test suite. Obviously, as we first write the test, it will initially
    fail. Next, we add the minimal implementation to make the test pass. That's it—all
    we need to do is repeat the same process until all the requirements are implemented.
    This approach ensures that our code base is thoroughly tested and that we focus
    on delivering just the requirements, avoiding feature creep.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发是一种基于简单工作流程的软件开发实践，将自动化测试置于核心位置。基本思想是将需求转化为非常具体、定义良好且具有针对性的测试用例。每个测试用例应仅针对一个功能点。一旦测试准备就绪，我们就运行整个测试套件。显然，由于我们首先编写测试，它最初会失败。接下来，我们添加最小实现以使测试通过。就是这样——我们所需做的就是重复相同的流程，直到所有需求都得到实现。这种方法确保我们的代码库得到彻底测试，并且我们专注于仅交付需求，避免功能蔓延。
- en: 'Julia provides built-in unit testing capabilities under the `Test` module.
    It is very straightforward and easy to use, providing enough methods to cover
    all the basic testing scenarios: value and exception checking, approximate values,
    types, and so on.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Julia在`Test`模块下提供了内置的单元测试功能。它非常简单易用，提供了足够的方法来覆盖所有基本测试场景：值和异常检查、近似值、类型等。
- en: The most important ones are the `@test`, `@test_throws`, and `@testset` macros.
    The `@test` macro checks that the `expression` passed as argument evaluates to
    true, returning a `PassResult`. If the test does not pass, it will return either
    a `FailResult` when the expression evaluates to `false`—or an `ErrorResult` if
    the expression can't be evaluated at all. The `@test_throws` macro checks that
    the evaluated expression throws an exception. Finally, `@testset` is used to group
    tests into sets. All the tests in a test set will run, and at the end of the test
    set, a summary of the results will be displayed. If any of the tests failed, or
    could not be evaluated due to an error, the test set will throw a `TestSetException`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是 `@test`、`@test_throws` 和 `@testset` 宏。`@test` 宏检查作为参数传递的表达式是否评估为真，返回一个
    `PassResult`。如果测试未通过，当表达式评估为 `false` 时，它将返回一个 `FailResult`——或者如果表达式根本无法评估，则返回一个
    `ErrorResult`。`@test_throws` 宏检查评估的表达式是否抛出异常。最后，`@testset` 用于将测试分组。测试集中的所有测试都将运行，并在测试集末尾显示结果摘要。如果任何测试失败，或由于错误无法评估，测试集将抛出
    `TestSetException`。
- en: 'For example, consider the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下内容：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The previous snippet shows the output from both a passing and a failing test.
    The following one illustrates the use of test sets, with one passing and one failing
    test:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个片段显示了通过和失败测试的输出。以下一个片段说明了测试集的使用，其中一个测试通过，另一个测试失败：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, this is how exceptions are handled:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是处理异常的方式：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we have the testing theory covered, let's continue by writing our first
    test. We will need a method that will take a package name and return the corresponding
    GitHub repo URL. This URL will be used in order to later interact with the GitHub
    API and open the issue into the corresponding repo. For now, we'll just check
    that the return value is a valid URL. We'll use the `URIParser` package to check
    the validity.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了测试理论，让我们继续编写我们的第一个测试。我们需要一个方法，该方法将接受一个包名并返回相应的GitHub仓库URL。这个URL将用于稍后与GitHub
    API交互并在相应的仓库中打开问题。目前，我们只需检查返回值是否为有效的URL。我们将使用 `URIParser` 包来检查其有效性。
- en: Julia makes it easy to add and run tests for our package, again, through the
    functionality provided by `Pkg` under the `test` command. When we run `(IssueReporter)
    pkg> test`, the `Pkg` library will look for a file called `runtests.jl` in the
    `test/` folder.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Julia通过 `Pkg` 提供的功能使我们能够轻松添加和运行测试，再次通过 `test` 命令下的功能。当我们运行 `(IssueReporter)
    pkg> test` 时，`Pkg` 库将在 `test/` 文件夹中查找名为 `runtests.jl` 的文件。
- en: 'Time to add them—from within the Julia REPL:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候在Julia REPL内部添加它们了：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, open the newly created `runtests.jl` file in the editor, for example,
    by running the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在编辑器中打开新创建的 `runtests.jl` 文件，例如，通过运行以下命令：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Please make sure your `runtests.jl` file looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您的 `runtests.jl` 文件看起来像这样：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A test set block, defined by the `@testset` macro, groups multiple tests and/or
    other tests sets. The reason for using test sets is that when a test fails, an
    exception is thrown, causing the execution of the script to stop. However, when
    we have a large batch of tests, we usually prefer to allow all the tests to run
    and get a full report of what failed and what worked. With a test set, all the
    tests within the set will be run and a summary will be displayed at the end of
    the set. If any of the tests fail, or cannot be evaluated due to an error, the
    test set will then throw a `TestSetException`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试集块，由 `@testset` 宏定义，将多个测试和/或其他测试集组合在一起。使用测试集的原因是，当测试失败时，会抛出异常，导致脚本执行停止。然而，当我们有一大批测试时，我们通常更喜欢允许所有测试运行，并得到一个完整的失败和成功的报告。使用测试集，集合内的所有测试都将运行，并在集合末尾显示摘要。如果任何测试失败，或由于错误无法评估，测试集将抛出
    `TestSetException`。
- en: Test sets should have self-explanatory names relevant to the batch of tests
    they represent, as these labels are outputted when the tests are run.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 测试集应该有自解释的名称，与它们所代表的测试批次相关，因为这些标签在运行测试时会被输出。
- en: 'We can run the test as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式运行测试：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It will fail with an informative message:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它将以一条信息丰富的消息失败：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The important bit is `UndefVarError: packageuri not defined`. This is unsurprising,
    as we have not yet defined the `IssueReporter.packageuri` function.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '重要的是 `UndefVarError: packageuri 未定义`。这并不令人惊讶，因为我们还没有定义 `IssueReporter.packageuri`
    函数。'
- en: Peeking into Julia's registry
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看Julia的注册表
- en: As we were saying, we need a way to retrieve the GitHub URI of a package, based
    on the package's name. Now, given that we're able to successfully execute operations
    such as `add` and `develop` with `Pkg`, without having to provide the GitHub URI,
    we can assume that there is a way to convert a package name to a package URL.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，我们需要一种方法来根据软件包的名称检索软件包的GitHub URI。现在，鉴于我们能够成功执行`add`和`develop`等操作，而无需提供GitHub
    URI，我们可以假设有一种方法可以将软件包名称转换为软件包URL。
- en: 'Indeed, Julia manages a repository of all the packages that are known to `Pkg`.
    These packages are grouped into multiple registries that are copied to your computer.
    By default, Julia comes with the so-called `General` registry, which can be found
    in the `.julia/` folder in your home directory. The `General` registry itself
    is nothing but a folder that contains subfolders named after each letter in the
    English alphabet (thus, from `A` to `Z`). Within each of these folders, we can
    find all the packages whose names start with that letter:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Julia管理着一个所有已知软件包的仓库。这些软件包被分组到多个注册表中，并复制到您的计算机上。默认情况下，Julia附带所谓的`通用`注册表，它位于您家目录中的`.julia/`文件夹中。`通用`注册表本身只是一个包含以英语字母表中的每个字母命名的子文件夹的文件夹（因此，从`A`到`Z`）。在这些文件夹中，我们可以找到所有以该字母开头的软件包：
- en: '![](img/6abab19b-7d55-4b66-b195-3497520fd947.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6abab19b-7d55-4b66-b195-3497520fd947.png)'
- en: This screenshot shows a part of the `General` registry, with some of its folders
    (from `A` to `D`) and some of the packages starting with the letter `D`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此截图显示了`通用`注册表的一部分，其中包含一些文件夹（从`A`到`D`）和一些以字母`D`开头的软件包。
- en: 'In order to make package retrieval more efficient, a special index file, called
    `Registry.toml`, is also placed inside the `General` folder. This file defines
    a hash-based index that maps package UUIDs to a dictionary of `name` and `path`
    values—the path being relative and pointing to a folder within the `General` registry.
    For example, this is the entry corresponding to the `D3Trees` package, the first
    one under the letter `D`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使软件包检索更高效，还在`通用`文件夹内放置了一个特殊的索引文件，称为`Registry.toml`。此文件定义了一个基于哈希的索引，将软件包UUID映射到包含`name`和`path`值的字典——`path`是相对路径，指向`通用`注册表内的一个文件夹。例如，这是对应于`D3Trees`软件包的条目，位于字母`D`下的第一个：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Moving on, if we peek into the `D3Trees/` folder itself, we''ll see that it
    contains four files, each of them containing important metadata:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们查看`D3Trees/`文件夹本身，我们会看到它包含四个文件，每个文件都包含重要的元数据：
- en: '![](img/60224858-81ad-498f-9ca5-402cd18423fb.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60224858-81ad-498f-9ca5-402cd18423fb.png)'
- en: The screenshot shows the four `Pkg` metadata files belonging to the `D3Trees`
    package.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 截图显示了属于`D3Trees`软件包的四个`Pkg`元数据文件。
- en: The `Deps.toml` file includes the list of dependencies (those packages required
    by `D3Trees` itself). The `Compat.toml` file stores compatibility requirements
    for the dependencies and for the Julia versions. `Package.toml` defines information
    such as name, UUID, and repo URL, and finally, `Versions.toml` shows all the known
    versions of `D3Trees` together with their corresponding Git references. It looks
    like we need the information within the `Package.toml` file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deps.toml`文件包含了依赖项列表（`D3Trees`自身所需的软件包）。`Compat.toml`文件存储了依赖项和Julia版本的兼容性要求。`Package.toml`定义了诸如名称、UUID和仓库URL等信息，最后，`Versions.toml`显示了所有已知的`D3Trees`版本及其相应的Git引用。看起来我们需要`Package.toml`文件中的信息。'
- en: 'The workflow, then, is the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，工作流程如下：
- en: Get the path to Julia's `General` registry
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取Julia的`通用`注册表的路径
- en: Read the `Registry.toml` file
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取`Registry.toml`文件
- en: Look for a package with the name that we're searching for
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找我们要搜索的软件包名称
- en: If the package exists, get its path in the `General` registry
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该软件包存在，则在`通用`注册表中获取其路径
- en: Read the corresponding `Package.toml` file
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取相应的`Package.toml`文件
- en: Extract the package's GitHub URL
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取软件包的GitHub URL
- en: Working with TOML files
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与TOML文件一起工作
- en: '**Tom''s Obvious, Minimal Language** (**TOML**) is a minimal configuration
    file format created by Tom Preston-Werner. TOML files serve the same purpose as
    other configuration formats, for example, the famous INI—although TOML''s goal
    is to be easier to read and easier to parse. YAML and JSON are other very popular
    configuration formats that you may have encountered. `Pkg` makes extensive usage
    of TOML for storing package metadata.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tom的明显、最小语言**（**TOML**）是由Tom Preston-Werner创建的最小配置文件格式。TOML文件与其他配置格式（例如著名的INI）具有相同的目的——尽管TOML的目标是更容易阅读和解析。YAML和JSON是其他非常流行的配置格式，你可能已经遇到过。`Pkg`广泛使用TOML来存储包元数据。'
- en: You can read more about TOML, including the full specification, at [https://github.com/toml-lang/toml](https://github.com/toml-lang/toml).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/toml-lang/toml](https://github.com/toml-lang/toml)了解更多关于TOML的信息，包括完整的规范。
- en: 'A TOML parser for Julia is available at [https://github.com/wildart/TOML.jl](https://github.com/wildart/TOML.jl),
    but we don''t need to explicitly add it as `Pkg` comes bundled with a TOML parser
    that we will use instead. But, this means that we do have to declare `Pkg` as
    a dependency of `IssueReporter`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的TOML解析器可在[https://github.com/wildart/TOML.jl](https://github.com/wildart/TOML.jl)找到，但我们不需要显式添加它，因为`Pkg`附带了一个我们将使用的TOML解析器。但这意味着我们必须将`Pkg`声明为`IssueReporter`的依赖项：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, to implement the preceding workflow. First, the path to the `General` registry.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，来实现前面的工作流程。首先，`General`注册表的路径。
- en: 'Julia keeps track of a list of locations where important information is stored.
    This info includes configuration files, environments, installed packages, and
    registries. In Julia''s lingo, these are called **depots** and are stored in the
    `DEPOT_PATH` global variable:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Julia跟踪一个存储重要信息的位置的列表。这些信息包括配置文件、环境、已安装的包和注册表。在Julia的术语中，这些被称为**存储库**，并存储在`DEPOT_PATH`全局变量中：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The contents of the `DEPOT_PATH` array on my computer are shown here. Your output
    will be different, but similar.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我电脑上`DEPOT_PATH`数组的内容如下所示。你的输出将不同，但类似。
- en: The first entry is the user depot where registries are cloned, new package versions
    are installed, package repos are cloned, log files are written, development packages
    are checked out by default, and global configuration data is saved. Later entries
    in the depot path are read-only and are used for operations performed by system
    administrators.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条记录是用户存储库，其中包含注册表的克隆、新包版本的安装、包仓库的克隆、日志文件的写入、默认检出开发包以及保存全局配置数据。存储库路径中的后续条目是只读的，用于系统管理员执行的操作。
- en: 'Let''s add a new (failing) test for getting the `General` registry path:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个新的（失败的）测试来获取`General`注册表的路径：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As for the implementation, we will want to loop over each entry in the `DEPOT_PATH`
    and check if it contains a `registries/General` path of directories. These should
    be in the user depot, but a more extensive lookup will make our code more robust:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实现，我们希望遍历`DEPOT_PATH`中的每个条目，并检查它是否包含`registries/General`目录路径。这些应该在用户存储库中，但更广泛的查找会使我们的代码更健壮：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once we have the path to the `General` registry, we''ll want to parse the `Registry.toml`
    file and extract the information corresponding to the package we''ll be searching
    for. Once parsed, the `Registry.toml` file produces in a dictionary with five
    entries:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`General`注册表的路径，我们希望解析`Registry.toml`文件并提取与我们要搜索的包对应的信息。一旦解析，`Registry.toml`文件将生成一个包含五个条目的字典：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''re only interested in the *packages* data, which looks like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对`*packages*`数据感兴趣，它看起来像这样：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And actually, we don''t want all that, since we don''t care about the UUID;
    only the name and the path. Let''s add a new function to the `IssueReporter` module,
    to reflect this spec:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们并不需要所有这些，因为我们不关心UUID；只关心名称和路径。让我们向`IssueReporter`模块添加一个新函数，以反映这个规范：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output of the function is similar to this, an array of `Dict` elements:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的输出类似于这个，一个`Dict`元素的数组：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once we have this, it is very easy to perform a package lookup by name. We
    simply iterate over each item and compare the `"name"` value against the search
    string:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个，通过名称进行包查找就非常容易了。我们只需遍历每个项目，并将`"name"`值与搜索字符串进行比较：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After we identify a package by name, we can use the path value to build the
    path to the folder that contains the package's metadata information. Remember
    that we're after the `Package.toml` file, as this contains the repo URI.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 识别出包的名称后，我们可以使用路径值来构建包含包元数据信息的文件夹的路径。记住，我们正在寻找`Package.toml`文件，因为它包含仓库URI。
- en: 'Putting it all together, we can finally write our `IssueReporter.packageuri`
    function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们最终可以写出我们的`IssueReporter.packageuri`函数：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Your `IssueReporter.jl` file should look like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`IssueReporter.jl`文件应该看起来像这样：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The IssueReporter.jl package
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IssueReporter.jl包
- en: 'Running the tests again will be successful:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试将会成功：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/1e7c324e-9905-43ac-b1ca-b8e9282253f9.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e7c324e-9905-43ac-b1ca-b8e9282253f9.png)'
- en: 'If you''re curious, the GitHub repo URI for `DataFrames`, according to `IssueReporter`,
    is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇，根据`IssueReporter`，`DataFrames`的GitHub仓库URI如下：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you want, you can check for yourself in the web browser to confirm that it
    is indeed, the correct URI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想的话，可以在网络浏览器中自行检查以确认它确实是正确的URI。
- en: Performance testing
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试
- en: Our code works correctly so far, but what about it's performance? Besides its
    readable syntax, liberal license, rich package ecosystem, and welcoming community,
    performance is one of the top reasons why data scientists and software developers
    choose Julia. The compiler does a great job of providing excellent performance
    out of the box, but there are certain best practices that we as developers must
    keep in mind to ensure that we basically don't hinder the compiler. We'll go over
    the most important ones by looking at a few examples while running some benchmarks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码到目前为止运行正确，但它的性能如何呢？除了其可读的语法、宽松的许可、丰富的包生态系统和友好的社区，性能也是数据科学家和软件开发者选择Julia的主要原因之一。编译器能够提供出色的性能，但有一些最佳实践是我们作为开发者必须牢记在心的，以确保我们基本上不会阻碍编译器。我们将通过查看一些示例并在运行基准测试的同时，来介绍最重要的几个。
- en: Benchmarking tools
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试工具
- en: 'Given its focus on performance, it should come as no surprise that both core
    Julia and the ecosystem provide a variety of tools for inspecting our code, looking
    for bottlenecks and measuring runtime and memory usage. One of the simplest is
    the `@time` macro. It takes an expression and then prints its execution time,
    number of allocations, and the total number of bytes the execution caused to be
    allocated, before returning the result of the expression. For example, note the
    following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它专注于性能，所以Julia的核心和生态系统提供各种工具来检查我们的代码，寻找瓶颈并测量运行时间和内存使用，这并不令人惊讶。其中最简单的一个是`@time`宏。它接受一个表达式，然后打印其执行时间、分配的数量以及执行导致的总字节数，在返回表达式的结果之前。例如，注意以下内容：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Generating an array of one million integers by iterating from one to one million
    takes 0.03 seconds. Not bad, but what if I told you that we can do better—much
    better? We just committed one of the cardinal sins of Julia—code should not be
    run (nor benchmarked) in the global scope. So, rule one—always wrap your code
    into functions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过迭代从一到一百万生成一百万个整数的数组需要0.03秒。不错，但如果我告诉你我们可以做得更好——好得多呢？我们犯了一个Julia的致命错误——代码不应该在全局范围内运行（或基准测试）。所以，第一条规则——总是将你的代码封装成函数。
- en: 'The previous snippet can easily be refactored as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段可以轻松重构如下：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, the benchmark is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基准测试如下：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: All right, that's clearly faster—but not much faster. However, what if we run
    the benchmark one more time?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这确实更快——但并没有快很多。然而，如果我们再运行一次基准测试会怎样呢？
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Wow, that's an order of magnitude faster! So, what gives?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这快了一个数量级！那么，这是怎么回事呢？
- en: If you remember from our coverage of functions and methods, Julia uses a **just-in-time**
    (**JIT**) compiler; that is, a function is compiled in real time when it is invoked
    for the first time. So, our initial benchmark also included the compilation time.
    This brings us to the second rule—don't benchmark the first run.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得我们关于函数和方法的介绍，Julia使用的是**即时编译**（**JIT**）编译器；也就是说，一个函数在第一次被调用时实时编译。因此，我们的初始基准测试也包括了编译时间。这引出了第二条规则——不要基准测试第一次运行。
- en: 'The best way to accurately measure the performance of a piece of code, thus,
    would be to execute it multiple times and then compute the mean. There is a great
    tool, specially designed for this use case, called `BenchmarkTools`. Let''s add
    it and give it a try:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，准确测量代码性能的最佳方式是多次执行它，然后计算平均值。有一个专为这种用例设计的优秀工具，称为`BenchmarkTools`。让我们添加它并尝试一下：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`BenchmarkTools` took `1788` samples, with an evals to sample ratio of `1`.
    Here, a sample represents a measurement, while an evaluation is an execution of
    the benchmark expression. We got a maximum time of 55 milliseconds, driven by
    the garbage collection, with a minimum of 1.3 milliseconds, and a mean of 2.7
    milliseconds. That is in line with what the second `@time` execution revealed,
    at 2.4 milliseconds—but this benchmark is far more accurate. We can also use the
    more compact `@btime` macro, which has an output similar to `@time`, but executes
    an equally comprehensive benchmark:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`BenchmarkTools` 捕获了 `1788` 个样本，评估到样本的比例为 `1`。在这里，一个样本代表一个测量值，而一个评估是对基准表达式的执行。我们得到了最大
    55 毫秒的时间，由垃圾回收驱动，最小为 1.3 毫秒，平均为 2.7 毫秒。这与第二个 `@time` 执行所揭示的 2.4 毫秒相符——但这个基准要准确得多。我们还可以使用更紧凑的
    `@btime` 宏，它的输出类似于 `@time`，但执行了一个同样全面的基准：'
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`BenchmarkTools` exposes a very rich API and it''s worth getting to know it
    well. You can read more about it at [https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/doc/manual.md](https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/doc/manual.md).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`BenchmarkTools` 提供了一个非常丰富的 API，值得深入了解。你可以在[https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/doc/manual.md](https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/doc/manual.md)了解更多信息。'
- en: Type stability is key
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型稳定性至关重要
- en: If there is one thing that has a direct and massive impact on the performance
    of Julia code, it's the type system. And the most important thing about it is
    to write code that is type-stable. Type stability means that the type of a variable
    (including the return value of a function) must not vary with time or under different
    inputs. Understanding how to leverage type stability is key to writing fast software.
    Now that we know how to measure our code's execution time, we can see the effect
    of type instability with a few examples.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一件事对 Julia 代码的性能有直接和巨大的影响，那就是类型系统。最重要的是编写类型稳定的代码。类型稳定性意味着变量的类型（包括函数的返回值）必须不会随时间或不同的输入而变化。了解如何利用类型稳定性是编写快速软件的关键。现在我们知道了如何测量代码的执行时间，我们可以通过几个例子看到类型不稳定性的影响。
- en: 'Let''s take this innocent-looking function, for example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以这个看起来很无辜的函数为例：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There's nothing fancy about it. We have a variable, `x`, which is initialized
    to `0`—and then a loop from `1` to `10`, where we add the `sin` of a number to
    `x`. And then we return `x`. Nothing to see, right? Well, actually, quite the
    contrary—a few bad things, performance-wise, are happening here. And they all
    have to do with type instability.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它并没有什么特别之处。我们有一个变量 `x`，它被初始化为 `0`，然后是一个从 `1` 到 `10` 的循环，我们将一个数字的正弦值加到 `x` 上。然后我们返回
    `x`。没有什么可看的，对吧？实际上，恰恰相反——这里发生了一些性能上的不良情况。它们都与类型不稳定性有关。
- en: 'Julia provides a great tool for inspecting and diagnosing code for type-related
    issues—the `@code_warntype` macro. Here''s what we get when we use it with our
    `f1` function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 提供了一个出色的工具来检查和诊断与类型相关的问题——`@code_warntype` 宏。当我们用它与我们的 `f1` 函数一起使用时，我们得到以下结果：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/acb8a124-d316-4c01-8f17-d5985117cd02.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acb8a124-d316-4c01-8f17-d5985117cd02.png)'
- en: 'This time, I''m using a screenshot for the output, in order to illustrate the
    color coding. As you might expect, green is good and red is bad. I am also marking
    the red flags with a rectangle. The problems are with `Body::Union{Float64, Int64}` on
    the first line, `(#4 => 0, #14 => %29)::Union{Float64, Int64}` on line `12`, and
    `(#13 => %29, #4 => 0)::Union{Float64, Int64}` on the penultimate line.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '这次，我使用截图来展示输出，以便说明颜色编码。正如你所预期的那样，绿色是好的，红色是坏的。我还用矩形标记了红旗。问题出在第一行的 `Body::Union{Float64,
    Int64}`，第 `12` 行的 `(#4 => 0, #14 => %29)::Union{Float64, Int64}`，以及倒数第二行的 `(#13
    => %29, #4 => 0)::Union{Float64, Int64}`。'
- en: On the first line, the `Body::Union{Float64, Int64}`, as well as on the penultimate
    line, `::Union{Float64, Int64}`, tell us the same thing—the function returns a
    `Union{Float64, Int64}`, meaning that the function can return either a `Float`
    or an `Integer`. This is textbook type instability and bad news for performance.
    Next, on line `12`, *something* has a type of `Union{Float64, Int64}` and this
    value is then returned as the result of the function. In case you're wondering,
    that *something* is `x`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，`Body::Union{Float64, Int64}`，以及倒数第二行，`::Union{Float64, Int64}`，告诉我们同样的事情——该函数返回一个
    `Union{Float64, Int64}`，这意味着该函数可以返回一个 `Float` 或一个 `Integer`。这是典型的类型不稳定性，对性能来说是个坏消息。接下来，在第
    `12` 行，*某个东西* 的类型是 `Union{Float64, Int64}`，然后这个值作为函数的结果返回。如果你想知道，那个 *某个东西* 就是
    `x`。
- en: The problem is that we unsuspectingly initialized `x` to `0`, an `Integer`.
    However, the `sin` function will return a `Float`. Adding a `Float` to an `Integer`
    will result in a `Float`, causing the type of `x` to change accordingly. Thus,
    `x` has two types during the execution of the function, and since we return `x`,
    our function is also type-unstable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们无意中将`x`初始化为`0`，一个`Integer`。然而，`sin`函数将返回一个`Float`。将一个`Float`加到一个`Integer`上会导致结果是一个`Float`，从而改变`x`的类型。因此，`x`在函数执行过程中有两个类型，因为我们返回`x`，所以我们的函数也是类型不稳定的。
- en: 'Granted, understanding the output of `@code_warntype` is not easy, although
    it does get easier with time. However, we can make our job easier by using the
    super-useful `Traceur` package. It provides a `@trace` macro, which generates
    human-friendly information. Let''s add it and try it out; you''ll appreciate it,
    I''m sure:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，理解`@code_warntype`的输出并不容易，尽管随着时间的推移它会变得容易一些。然而，我们可以通过使用超级有用的`Traceur`包来简化我们的工作。它提供了一个`@trace`宏，它生成易于理解的信息。让我们添加它并尝试一下；我相信你会喜欢的：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How cool is that? Crystal clear!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这得多酷啊？清晰明了！
- en: 'With this feedback in mind, we can refactor our code into a new `f2` function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个反馈，我们可以将我们的代码重构到一个新的`f2`函数中：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Awesome, nothing to report! No news is good news!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，没有要报告的事情！没有消息就是好消息！
- en: 'Now, we can benchmark `f1` and `f2` to see the result of our refactoring:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以对`f1`和`f2`进行基准测试，看看重构的结果：
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That's nice—79 versus 129 nanoseconds! If you're thinking that *It's just 50
    nanoseconds, what's all the fuss about?*, you need to look at it this way—`f2`,
    the type-stable variant, is almost twice as fast as `f1`! And that's a really
    big deal!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这真不错——79纳秒与129纳秒的对比！如果你在想“这不过是50纳秒，有什么大惊小怪的？”，那你得这样看——`f2`，这个类型稳定的变体，比`f1`快近一倍！这可是个真正的大事！
- en: Benchmarking our code
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试我们的代码
- en: 'It''s time to apply what we''ve learned to our own code base. Heads up, I have
    intentionally sneaked in a few problems, to spice things up a bit. Let''s fix
    them together:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将我们所学应用到自己的代码库中了。请注意，我故意加入了一些问题，让事情变得更有趣。让我们一起来解决它们：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/10c7d5ce-3ae9-42aa-8b1f-cf29fb6ea23f.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10c7d5ce-3ae9-42aa-8b1f-cf29fb6ea23f.png)'
- en: This is all very interesting—let's see what we can learn from it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都非常有趣——让我们看看我们能从中学到什么。
- en: Starting with line `1`, the `IssueReporter.generalregistrypath` function returns
    a `Union{Nothing, String}`. The reason is that our function does not handle the
    case when the `for` loop is not entered, or when the `if` statement is not executed.
    We should make sure that our function always returns a value and that the type
    of this return value does not change. To be extra sure, we can also add a type
    assertion to the function definition itself. If we accidentally return the wrong
    type, Julia will try to convert it to the declared type—if that doesn't work,
    an error is thrown.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从第1行开始，`IssueReporter.generalregistrypath`函数返回一个`Union{Nothing, String}`。原因是我们的函数没有处理`for`循环未进入或`if`语句未执行的情况。我们应该确保我们的函数总是返回一个值，并且这个返回值的类型不会改变。为了更加保险，我们还可以在函数定义本身中添加类型断言。如果我们意外地返回了错误类型，Julia
    将尝试将其转换为声明的类型——如果这不起作用，则会抛出错误。
- en: 'We need to redefine the function as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将函数重新定义为以下内容：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, on to the line starting with `%2` (the third line)—the `searchregistry`
    function returns a value of type `Any`. The issue here is that we return an item
    coming from the invocation of `generalregistry`, so we need to look at that first.
    We'll add a check for the return value of `generalregistrypath`, and we add a
    default return value, an empty `Vector{Dict{String,Any}}`. Then, for `searchregistry`,
    we'll also add a default return value—since it returns an item from this `Vector`,
    it will be of type `Dict{String,Any}`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到以`%2`开头（第三行）的行——`searchregistry`函数返回一个`Any`类型的值。这里的问题是，我们返回了从`generalregistry`调用中来的一个项，因此我们需要先看看那个。我们将添加对`generalregistrypath`返回值的检查，并添加一个默认返回值，一个空的`Vector{Dict{String,Any}}`。然后，对于`searchregistry`，我们也将添加一个默认返回值——因为它从这个`Vector`中返回一个项，所以它将是`Dict{String,Any}`类型。
- en: Next, in regards to the `packageuri` function, in the line starting with `%9` (on
    line `11`), we can see something about a `KeyError` and `repo`. Julia is warning
    us that it's possible that we won't have a key named `repo`, thus leading to a
    `KeyError`. Also, the function returns an object of type `Any`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，关于`packageuri`函数，在以`%9`开头（第11行）的行中，我们可以看到有关`KeyError`和`repo`的信息。Julia 正在警告我们，可能我们没有名为`repo`的键，这会导致`KeyError`。此外，该函数返回一个`Any`类型的对象。
- en: 'Here are the three functions, refactored:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是三个重构后的函数：
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can now recheck our code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以重新检查我们的代码：
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/aec1e4c4-9374-4937-8a4e-952d886aaccd.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aec1e4c4-9374-4937-8a4e-952d886aaccd.png)'
- en: Excellent, almost everything is green! There's just one red `Any`, coming from
    the `TOML.parsefile` function itself, but it's just not worth optimizing that
    away; the extra work would cancel the benefit.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，几乎一切都很绿色！只有一个红色的 `Any`，来自 `TOML.parsefile` 函数本身，但这不值得优化掉；额外的努力会抵消好处。
- en: It's definitely worth spending some time going over the official performance
    recommendations, available online at [https://docs.julialang.org/en/v1/manual/performance-tips/](https://docs.julialang.org/en/v1/manual/performance-tips/).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间查看官方的性能建议绝对是值得的，这些建议可在[https://docs.julialang.org/en/v1/manual/performance-tips/](https://docs.julialang.org/en/v1/manual/performance-tips/)在线找到。
- en: Interacting with the GitHub API
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 GitHub API 交互
- en: Now that we can retrieve the GitHub URI for any package in the `General` registry,
    we can use it to interact with the GitHub API. Julia developers have access to
    a powerful GitHub library provided by the GitHub package. It's what we'll use
    in order to create new issues on the packages' GitHub repos.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在 `General` 注册表中检索任何包的 GitHub URI，我们可以使用它来与 GitHub API 交互。Julia 开发者可以访问由
    GitHub 包提供的强大 GitHub 库。这就是我们将用它来在包的 GitHub 仓库中创建新问题的方法。
- en: Authenticating with the GitHub API
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub API 进行身份验证
- en: 'In order to be allowed to interact with the GitHub API, we have to authenticate.
    This will permit our package to execute actions on GitHub under the user''s account
    as if done directly through the website. Please access [https://github.com/settings/tokens/new](https://github.com/settings/tokens)
    to set up a new GitHub access token. If you''re not familiar with the concept
    and would like to learn more about this, please read on and follow the official
    instructions at [https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/).
    Give the token a good description and, very importantly, make sure that you check
    the repo scope, just as you can see in this screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许与 GitHub API 交互，我们必须进行身份验证。这将允许我们的包在用户的账户下执行操作，就像直接通过网站执行一样。请访问 [https://github.com/settings/tokens/new](https://github.com/settings/tokens)
    来设置新的 GitHub 访问令牌。如果您不熟悉这个概念并且想了解更多，请继续阅读并遵循[https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/)中的官方说明。为令牌提供一个好的描述，并且非常重要，确保您检查了仓库范围，就像您可以在下面的截图中所看到的那样：
- en: '![](img/4109ce90-615c-403b-ac74-a4fe1de71118.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4109ce90-615c-403b-ac74-a4fe1de71118.png)'
- en: Once generated, write down the token—once you leave that page, you won't see
    it again.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 生成后，请记下令牌——一旦离开该页面，您就再也看不到它了。
- en: The access tokens must be manipulated with care—and must not be committed to
    git or other source control systems where they can be accessed by other users.
    Anybody that gets your access token can use it to impersonate you on GitHub. To
    be on the safe side, please make sure that for this project, you only check the
    repo scope.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌必须谨慎操作——并且不得提交到 git 或其他源代码控制系统中，这些系统可能被其他用户访问。任何获得您的访问令牌的人都可以用它来在 GitHub
    上冒充您。为了安全起见，请确保对于这个项目，您只检查仓库范围。
- en: Let's add a bit of logic to make the access token available to our package without
    compromising security. It should work as follows—first, we check if the access
    token is provided as a command line parameter to the Julia process—meaning that
    it will be available in the `ENV` collection. If it's not, we'll look for a file
    called `secrets.jl` in the root folder of the package and include it. The file
    will contain the access token so we'll add it to `.gitignore`, to make sure it's
    not accidentally committed to git.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在不损害安全性的前提下，给我们的包添加一些逻辑，以便使访问令牌可用。它应该按以下方式工作——首先，我们检查访问令牌是否作为命令行参数提供给 Julia
    进程——这意味着它将在 `ENV` 集合中可用。如果没有，我们将在包的根目录中寻找一个名为 `secrets.jl` 的文件并将其包含进来。该文件将包含访问令牌，因此我们将将其添加到
    `.gitignore` 中，以确保它不会意外地提交到 git。
- en: 'So, let''s write the tests. Append the following at the end of `runtests.jl`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们编写测试。在 `runtests.jl` 的末尾追加以下内容：
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The tests will fail, of course, so let's make them pass.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 测试当然会失败，所以让我们让它们通过。
- en: 'Add these function definitions to `IssueReporter.jl`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下函数定义添加到 `IssueReporter.jl`：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the `tokenisdefined` function, we check if the `GITHUB_ACCESS_TOKEN` environment
    variable is already defined—if not, we check for the `secrets.jl` file and, if
    it exists, we include it. Once included, the `secrets.jl` file should define the
    variable, so finally, we check again for the existence of `GITHUB_ACCESS_TOKEN`.
    If the token is still not defined, the function returns `false`—otherwise, `true`.
    We''ve also added a token function that invokes `tokenisdefined`, giving the module
    the chance to set up `GITHUB_ACCESS_TOKEN`. If the token is available, it returns
    it—if not, this time an error is thrown. Our tests should now pass:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tokenisdefined`函数中，我们检查`GITHUB_ACCESS_TOKEN`环境变量是否已经定义——如果没有，我们检查`secrets.jl`文件是否存在，如果存在，则将其包含进来。一旦包含，`secrets.jl`文件应该定义该变量，因此最后我们再次检查`GITHUB_ACCESS_TOKEN`的存在。如果令牌仍然未定义，函数返回`false`——否则，返回`true`。我们还添加了一个调用`tokenisdefined`的令牌函数，给模块设置`GITHUB_ACCESS_TOKEN`的机会。如果令牌可用，则返回它——如果不可以，这次会抛出一个错误。我们的测试现在应该通过了：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is it, as shown here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如此，正如这里所示：
- en: '![](img/6f998ece-b5fe-420e-8b2b-7854bd0c9201.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f998ece-b5fe-420e-8b2b-7854bd0c9201.png)'
- en: Success!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！
- en: 'Before moving on, we need to add the `secrets.jl` file to `.gitignore`—committing
    this to a public GitHub repo would be a huge security error. From the Julia REPL,
    note the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要将`secrets.jl`文件添加到`.gitignore`中——将此提交到公共GitHub仓库将是一个巨大的安全错误。从Julia
    REPL中，请注意以下内容：
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, you need to create the `secrets.jl` file itself and make sure that it
    contains something similar to the next snippet, but adding your own GitHub access
    token:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要创建`secrets.jl`文件本身，并确保它包含类似于以下片段的内容，但添加你自己的GitHub访问令牌：
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Excellent, we're ready to report issues!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们现在准备好报告问题！
- en: Reporting GitHub issues
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 报告GitHub问题
- en: We're now down to the last step—using the GitHub API to report problems. In
    order to register an issue, we need two pieces of information—the title and the
    body. As such, we'll have to define a new function, called `report`, which will
    accept *three* string arguments—the name of the package, plus two more for the
    title and the body of the issue. Internally, the function will make an authenticated
    call to the corresponding GitHub API via the GitHub package.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只剩下最后一步——使用GitHub API来报告问题。为了注册一个问题，我们需要两个信息——标题和正文。因此，我们将定义一个新的函数，称为`report`，它将接受三个字符串参数——包名，以及两个用于问题标题和正文的参数。内部，该函数将通过GitHub包对相应的GitHub
    API进行认证调用。
- en: 'According to the documentation, a call to the `GitHub.create_issue` method
    looks like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，调用`GitHub.create_issue`方法看起来是这样的：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This means that we need to do the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要做以下事情：
- en: Use the GitHub token to authenticate and generate the required `GitHub.OAuth2`
    authentication object
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用GitHub令牌进行认证并生成所需的`GitHub.OAuth2`认证对象
- en: Starting from the Julia package name, compute the GitHub username and repo info—for
    this, we'll use the already implemented `IssueReporter.packageurl`, plus some
    extra processing to remove the unwanted parts from the URL
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Julia包名开始，计算GitHub用户名和仓库信息——为此，我们将使用已经实现的`IssueReporter.packageurl`，并对其进行一些额外的处理以从URL中移除不需要的部分
- en: Make the call to `GitHub.create_issue`, passing in all the required arguments
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`GitHub.create_issue`，传入所有必要的参数
- en: 'Since we''re doing TDD, let''s begin by converting these specifications into
    tests. Add the following at the very bottom of the `runtests.jl` file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在进行TDD，让我们首先将这些规范转换为测试。在`runtests.jl`文件的底部添加以下内容：
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The tests mirror, in the exact same order, the requirements we previously expressed
    in plain English. The first one invokes a function that we'll have to write, called
    `IssueReporter.githubauth`, which will perform the GitHub authentication and will
    return a `GitHub.OAuth2` object if successful. Next, we'll need a new `repoid`
    function, which will take the name of a package and will return the GitHub username
    and repo name. Notice that we're using my repo of the `IssueReporter` package
    as the guinea pig for our testing. Finally, we test the issue creation, which
    will be done by the `IssueReporter.report` method—on success, we expect a `GitHub.Issue`
    object.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 测试与之前用普通英语表达的要求完全相同，顺序一致。第一个调用一个我们将要编写的函数，称为`IssueReporter.githubauth`，该函数将执行GitHub认证，并在成功时返回一个`GitHub.OAuth2`对象。接下来，我们需要一个新的`repoid`函数，它将接受一个包名，并返回GitHub用户名和仓库名。请注意，我们正在使用`IssueReporter`包的我的仓库作为测试的豚鼠。最后，我们测试问题创建，这将通过`IssueReporter.report`方法完成——在成功的情况下，我们期望得到一个`GitHub.Issue`对象。
- en: Don't use Julia for anything evil! The code we're writing will actually register
    new issues on live GitHub repos. Please be respectful of the hard work of the
    open source contributors and don't overload them with fake issues.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 不要用Julia做任何邪恶的事情！我们编写的代码实际上会在GitHub的实时仓库上注册新问题。请尊重开源贡献者的辛勤工作，不要用虚假的问题来压垮他们。
- en: 'Time to make the tests pass by writing the implementations. Make sure that
    the `using` directive of the `IssueReporter` module reads as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候通过编写实现来确保测试通过了。确保`IssueReporter`模块的`using`指令如下所示：
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And then, add the following functions to the bottom of the `IssueReporter`
    module:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下函数添加到`IssueReporter`模块的底部：
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Pretty straightforward. The `githubauth` function invokes the `GitHub.authenticate`
    method, passing it the auth token provided by a call to the token function.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 非常直接。`githubauth`函数调用`GitHub.authenticate`方法，并传递由token函数调用提供的认证令牌。
- en: The `repoid` method accepts a string parameter for the name of the repo, then
    invokes the `packageuri` and the `URIParse.parse_url` to generate a URI object
    corresponding to the GitHub repo. We then extract the path component of the URI
    and process it to keep only the GitHub username and the repo name. In other words,
    starting with the package named `IssueReporter`, we retrieve the GitHub repo URL,
    which is `git://github.com/essenciary/IssueReporter.jl.git`. The path component
    is `/essenciary/IssueReporter.jl.git`. We use replace with the `r".git$"` regex
    to remove the `.git` ending before returning the substring starting from the second
    letter. At the end, we have what we need—`essenciary/IssueReporter.jl`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`repoid`方法接受一个字符串参数作为仓库名称，然后调用`packageuri`和`URIParse.parse_url`来生成对应GitHub仓库的URI对象。然后我们提取URI的路径组件并对其进行处理，只保留GitHub用户名和仓库名。换句话说，从名为`IssueReporter`的包开始，我们检索GitHub仓库URL，它是`git://github.com/essenciary/IssueReporter.jl.git`。路径组件是`/essenciary/IssueReporter.jl.git`。我们使用`r".git$"`正则表达式来移除返回子串前的`.git`后缀。最后，我们得到了我们需要的——`essenciary/IssueReporter.jl`。'
- en: 'Lastly, the report function puts it all together by invoking the `GitHub.create_issue`
    method and passing it the `repoid`, the authentication object, and the title and
    body of the issue within a `Dict`. All the tests should pass now and the issues
    are successfully created on Github.com ([https://github.com/](https://github.com/)):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，报告函数通过调用`GitHub.create_issue`方法，并传递`repoid`、认证对象以及问题标题和正文的`Dict`来将所有内容整合在一起。现在所有测试都应该通过，并且问题已经在Github.com上成功创建（[https://github.com/](https://github.com/))：
- en: '![](img/668b4028-4bd8-4a21-8f2f-5f67691461b2.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/668b4028-4bd8-4a21-8f2f-5f67691461b2.png)'
- en: Please note that the sample code provided with the chapter has the `create issue`
    functionality commented out—and instead it has hard-coded a dummy repository.
    Again, out of respect for the contributors and followers of the real repos, the
    actual issues will be created on a dummy repository that I created especially
    for this purpose.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本章提供的示例代码中的`create issue`功能已被注释掉——取而代之的是硬编码了一个虚拟仓库。出于对真实仓库的贡献者和追随者的尊重，实际的问题将创建在我特别为此目的创建的虚拟仓库上。
- en: Documenting our package
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录我们的包
- en: Our package is now complete! Let's make it easy for our users to take advantage
    of the amazing convenience provided by `IssueReporter`—we'll supply them an informative
    documentation. We already know how to document our code by using `DocStrings`
    - which can be used by ourselves and other developers to understand our source
    code. It's also used by the REPL's help system (remember from [Chapter 1](90a7f09d-d63b-45d7-baf5-576470d0910f.xhtml), *Getting
    Started with Julia Programming* that you can type `?` at the beginning of the
    line to switch the REPL to help mode). You'll be happy to hear that we can also
    generate package documentation using the same `DocStrings`, with the help of a
    package called `Documenter`. Please add it with `(IssueReporter) pkg> add Documenter`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的产品包现在已经完整！让我们让用户能够轻松利用`IssueReporter`提供的惊人便利——我们将为他们提供一份信息丰富的文档。我们已经知道如何通过使用`DocStrings`来记录我们的代码——这些可以被我们自己和其他开发者用来理解我们的源代码。它也被REPL的帮助系统所使用（记得从[第1章](90a7f09d-d63b-45d7-baf5-576470d0910f.xhtml)，*开始使用Julia编程*，你可以在行首输入`?`来将REPL切换到帮助模式）。你会很高兴地听到，我们还可以使用相同的`DocStrings`，借助一个名为`Documenter`的包来生成包文档。请使用`(IssueReporter)
    pkg> add Documenter`来添加它。
- en: 'So, the first thing to do is add some `DocStrings` to our functions. Keep in
    mind that the *official* recommendation is to include the function''s signature
    together with a small description and a few examples. For instance, the documentation
    for the `IssueReporter.packageuri` function could look like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先要做的是在我们的函数中添加一些 `DocStrings`。请记住，*官方* 建议包括函数的签名、一小段描述和一些示例。例如，`IssueReporter.packageuri`
    函数的文档可能看起来像这样：
- en: '[PRE62] jldoctest julia> IssueReporter.packageuri("IssueReporter") "git://github.com/essenciary/IssueReporter.jl.git"
    [PRE63]'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE62] jldoctest julia> `IssueReporter.packageuri("IssueReporter")` "git://github.com/essenciary/IssueReporter.jl.git"
    [PRE63]'
- en: Advanced documentation tips
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级文档技巧
- en: '[PRE64]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Another valuable feature of `DocStrings` is that the examples can also serve
    as tests. This kind of testing is called a **doctest**. Basically, when we provide
    a REPL example together with the corresponding output, if we tag this as a *jldoctest*,
    the `Documenter` package used to generate the documentation will also run the
    examples and compare the result against the provided output, thus testing the
    examples and, implicitly, our code. Check the next snippet to see what the previous
    example looks like after we apply these optimizations.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`DocStrings` 的另一个宝贵特性是示例也可以作为测试。这种测试称为 **doctest**。基本上，当我们提供一个交互式示例及其相应的输出时，如果我们将其标记为
    *jldoctest*，用于生成文档的 `Documenter` 包也会运行这些示例，并将结果与提供的输出进行比较，从而测试示例，并隐含地测试我们的代码。查看下一个片段，看看在应用这些优化后前一个示例的样子。'
- en: 'I have added comments to all the functions that represent the *public* API
    of `IssueReporter`. Here are the updated function definitions (you can get the
    full file from this chapter''s repo at [https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter11/IssueReporter/src/IssueReporter.jl](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter11/IssueReporter/src/IssueReporter.jl)):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为表示 `IssueReporter` 的 *公共* API 的所有函数添加了注释。以下是更新后的函数定义（你可以从本章的仓库中获取完整文件，链接为
    [https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter11/IssueReporter/src/IssueReporter.jl](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter11/IssueReporter/src/IssueReporter.jl)）：
- en: '[PRE65]julia-repl'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE65]julia-repl'
- en: julia> IssueReporter.packageuri("IssueReporter")
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: julia> `IssueReporter.packageuri("IssueReporter")`
- en: '"git://github.com/essenciary/IssueReporter.jl.git"'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '"git://github.com/essenciary/IssueReporter.jl.git"'
- en: '[PRE66]jldoctest'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE66]jldoctest'
- en: julia> IssueReporter.repo_id("IssueReporter")
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: julia> `IssueReporter.repo_id("IssueReporter")`
- en: '"essenciary/IssueReporter.jl"'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '"essenciary/IssueReporter.jl"'
- en: '[PRE67]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Generating the documentation
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成文档
- en: In order to create our documentation, we'll need to first create a `docs/` folder
    inside our `IssueReporter` root directory.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的文档，我们首先需要在 `IssueReporter` 根目录内创建一个 `docs/` 文件夹。
- en: 'Within the `docs/` folder, we need two more things—first, a `src/` folder,
    which will contain the markdown template that will be used to build the documentation,
    the `index.md` file; second, a `make.jl` file that will control the documentation
    building process. Here is the full file structure of our package, for reference:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `docs/` 文件夹中，我们还需要两样东西——首先是一个 `src/` 文件夹，它将包含用于构建文档的 markdown 模板，以及 `index.md`
    文件；其次是一个 `make.jl` 文件，它将控制文档构建过程。以下是我们的包的完整文件结构，仅供参考：
- en: '![](img/125def3c-c57d-4429-af88-e08d85d9bce4.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/125def3c-c57d-4429-af88-e08d85d9bce4.png)'
- en: 'Now, open the `docs/make.jl` file in the editor and add the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在编辑器中打开 `docs/make.jl` 文件并添加以下内容：
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, open the `index.md` file in the editor and add the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在编辑器中打开 `index.md` 文件并添加以下内容：
- en: '[PRE69]@meta'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE69]@meta'
- en: CurrentModule = IssueReporter
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`CurrentModule = IssueReporter`'
- en: '[PRE70]@contents'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE70]@contents'
- en: '[PRE71]@docs'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE71]@docs'
- en: packageuri(pkgname::String)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`packageuri(pkgname::String)`'
- en: tokenisdefined()
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokenisdefined()`'
- en: token()
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`token()`'
- en: githubauth()
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`githubauth()`'
- en: repoid(package_name::String)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`repoid(package_name::String)`'
- en: report(package_name::String, title::String, body::String)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`report(package_name::String, title::String, body::String)`'
- en: '[PRE72]@index'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE72]@index'
- en: '[PRE73]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This is the markdown template of our documentation. At the top, we have the
    title of the page. Then, the `@meta` block contains information for `Documenter`,
    passing in the name of the module. The `@contents` block will be replaced with
    the table of contents. The `@docs` block will contain the documentation for each
    of the functions included. At the bottom, the `@index` block will be replaced
    by a list of links to each of the documented functions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的文档的Markdown模板。在顶部，我们有页面的标题。然后，`@meta`块包含传递模块名称的`Documenter`信息。`@contents`块将被替换为目录。`@docs`块将包含每个包含函数的文档。在底部，`@index`块将被替换为指向每个已记录函数的链接列表。
- en: That's all. In order to generate the documentation, we need to run `$ julia
    --color make.jl` from an OS Terminal, from within the `docs/` folder.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部了。为了生成文档，我们需要在`docs/`文件夹中从OS终端运行`$ julia --color make.jl`。
- en: 'The output of the command will show the progress of building the docs:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出将显示构建文档的进度：
- en: '[PRE74]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The generated documentation can be found at `docs/build/index.html`, and looks
    like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文档可以在`docs/build/index.html`中找到，看起来像这样：
- en: '![](img/31055def-d852-4a81-afb9-24d2dcf03d2f.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/31055def-d852-4a81-afb9-24d2dcf03d2f.png)'
- en: Registering our package
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册我们的包
- en: 'Now, for the last step—making our package available to the world! For starters,
    we need to create the remote GitHub repository and push our code to it. The easiest
    way to do this is with the `hub` binary, provided by GitHub. Please follow the
    installation instructions for your platform, as described at [https://github.com/github/hub](https://github.com/github/hub).
    Once ready, we''ll need to run `hub create` in the root of the `IssueReporter`
    folder. We can do it in Julia''s REPL:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于最后一步——让我们的包对全世界可用！首先，我们需要创建远程GitHub仓库并将我们的代码推送到它。最简单的方法是使用GitHub提供的`hub`二进制文件。请按照您平台上的说明进行安装，请参阅[https://github.com/github/hub](https://github.com/github/hub)。一旦准备好，我们将在`IssueReporter`文件夹的根目录下运行`hub
    create`。我们可以在Julia的REPL中这样做：
- en: '[PRE75]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You'll be prompted for your GitHub username and password—and if all goes well,
    you'll see the output confirming that the repo was created.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被提示输入您的GitHub用户名和密码——如果一切顺利，您将看到确认创建仓库的输出。
- en: Finishing touches
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的修饰
- en: Next, we need to commit and push our changes—but before doing that, let's make
    a final change to `.gitignore` to also add `docs/build` to the list of ignored
    files. It is a bad practice to include the built docs into the GitHub commits—for
    more information about hosting documentation on GitHub, please read the official
    `Documenter` info at [https://juliadocs.github.io/Documenter.jl/latest/man/guide/#Usage-1](https://juliadocs.github.io/Documenter.jl/latest/man/guide/#Usage-1)
    and [https://juliadocs.github.io/Documenter.jl/latest/man/hosting/#Hosting-Documentation-1](https://juliadocs.github.io/Documenter.jl/latest/man/hosting/#Hosting-Documentation-1).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要提交和推送我们的更改——但在做之前，让我们先对`.gitignore`进行最后的修改，将`docs/build`也添加到忽略文件列表中。将构建的文档包含在GitHub提交中是一种不好的做法——有关在GitHub上托管文档的更多信息，请阅读官方`Documenter`信息，请参阅[https://juliadocs.github.io/Documenter.jl/latest/man/guide/#Usage-1](https://juliadocs.github.io/Documenter.jl/latest/man/guide/#Usage-1)和[https://juliadocs.github.io/Documenter.jl/latest/man/hosting/#Hosting-Documentation-1](https://juliadocs.github.io/Documenter.jl/latest/man/hosting/#Hosting-Documentation-1)。
- en: 'While we''re at it, let''s also add a `README.md` file to the root folder of
    `IssueReporter`, to include a bit of info:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这里时，让我们也向`IssueReporter`的根目录添加一个`README.md`文件，以包含一些信息：
- en: '[PRE76]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Setting up the repository
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置仓库
- en: 'Using your favorite git client, `add`, `commit`, and `push` the code base.
    I''m going to use the Terminal:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的git客户端，`add`、`commit`和`push`代码库。我将使用终端：
- en: '[PRE77]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Unleashing Julia's army of bots
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解放Julia的机器人军团
- en: Our package is looking great—it's now time to tag a release and register it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目看起来很棒——现在是时候标记一个版本并注册它了。
- en: Julia contributors have developed a series of very useful GitHub integrations,
    namely, *bots*. These bots help us, humans, to automate a series of boring tasks
    so that we can focus on the really important things (mmm, pizza!).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的贡献者开发了一系列非常实用的GitHub集成，即*机器人*。这些机器人帮助我们人类自动化一系列无聊的任务，以便我们可以专注于真正重要的事情（嗯，披萨！）。
- en: 'One of them is Attobot, a package release bot for Julia. It creates pull requests
    to Julia''s `General` registry when releases are tagged in GitHub. Try the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是Attobot，它是Julia的包发布机器人。当在GitHub上标记版本时，它会为Julia的`General`注册表创建拉取请求。尝试以下操作：
- en: To set up Attobot, open your `IssueReporter` GitHub repo and go to [https://github.com/integration/attobot](https://github.com/integration/attobot).
    Please make sure that you're logged into your GitHub account.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置 Attobot，请打开您的 `IssueReporter` GitHub 仓库并访问 [https://github.com/integration/attobot](https://github.com/integration/attobot)。请确保您已登录到您的
    GitHub 账户。
- en: Then, click Configure to select the repositories you wish to add.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击配置以选择您希望添加的仓库。
- en: Choose Only select repositories, and then select `IssueReporter` and click Save.
    Now, Attobot is configured to monitor packages with the standard `.jl` extension—and
    publish them on the `Global` registry when new releases are tagged.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅选择仓库，然后选择 `IssueReporter` 并点击保存。现在，Attobot 已配置为监控具有标准 `.jl` 扩展名的包，并在标记新版本时将它们发布到
    `Global` 仓库。
- en: For more details about Attobot, please visit [https://github.com/attobot/attobot](https://github.com/attobot/attobot).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Attobot 的更多详细信息，请访问 [https://github.com/attobot/attobot](https://github.com/attobot/attobot)。
- en: 'Now, we need to go to our repo''s GitHub page and click on the releases link:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要前往我们的仓库的 GitHub 页面并点击版本链接：
- en: '![](img/887ff6ff-9ca3-4050-976f-2baca06e9d2f.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/887ff6ff-9ca3-4050-976f-2baca06e9d2f.png)'
- en: 'Next, we are given the option to Create a new release:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将有创建新版本的选择：
- en: '![](img/2332f178-74bb-4118-b178-c0024c3a803a.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2332f178-74bb-4118-b178-c0024c3a803a.png)'
- en: 'On the next screen, we''ll be able to tag our release. Julia uses semantic
    versioning (which looks like vX.Y.Z) and recommends starting with `v0.0.1`. Let''s
    do just that:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，我们将能够标记我们的版本。Julia 使用语义版本控制（看起来像 vX.Y.Z），并建议从 `v0.0.1` 开始。让我们就这样做：
- en: '![](img/bb2f8d04-78ad-4343-9f98-0a5f327362a6.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb2f8d04-78ad-4343-9f98-0a5f327362a6.png)'
- en: Then, click Publish release.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击发布版本。
- en: If there are any problems, Attobot will open issues in the repo—make sure you
    address them. Once done, the package will be registered! Victory!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何问题，Attobot 将在仓库中打开问题——确保您已经解决了它们。一旦完成，该包将被注册！胜利！
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: It is exciting to see our package finally ready!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 看到我们的包终于准备就绪，真是令人兴奋！
- en: While developing it, we've also learned about Julia's powerful toolbox, and
    about some of the most important best practices of software development in general—TDD,
    unit testing, benchmarking, and documenting our code base and publishing the resulting documentation.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们还学习了关于 Julia 强大工具箱的知识，以及一些关于软件开发的一般最佳实践——TDD、单元测试、基准测试，以及记录我们的代码库并发布生成的文档。
- en: This also concludes our journey into learning the Julia language. We've come
    a long way since opening the REPL for the first time—and you have achieved some
    impressive feats! Data analysis, plotting, web scraping, recommenders, supervised
    and unsupervised machine learning, and time series analysis and forecasting! You
    are now able to do all these things using Julia. Wow! That's quite an amazing
    track record indeed! And, if doing all this seemed easy, it's all due to Julia's
    incredible features. The productive REPL, the simple package installation, the
    handy plotting packages, or the readable syntax; they all make programming easy
    and fun.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这也标志着我们学习 Julia 语言的旅程的结束。自从第一次打开 REPL 以来，我们已经走了很长的路——您已经取得了令人印象深刻的成就！数据分析、绘图、网络爬取、推荐系统、监督和未监督机器学习，以及时间序列分析和预测！现在您可以使用
    Julia 做所有这些事情。哇！这确实是一个相当令人印象深刻的记录！而且，如果做所有这些看起来很简单，那都是因为 Julia 的不可思议的特性。高效的 REPL、简单的包安装、方便的绘图包，或者可读的语法；它们都让编程变得简单而有趣。
- en: Julia really is a new breed of programming language. As it is new, it is able
    to learn from the most successful programming languages by borrowing from their
    strengths, and avoid their mistakes. Julia was specifically designed to efficiently
    address the needs of our generation—machine learning, artificial intelligence,
    high performance, parallel, GPU, and distributed cloud computing—these are all
    areas where the language excels.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 确实是一种新型的编程语言。由于它是新的，它能够通过借鉴最成功的编程语言的优势，避免它们的错误来学习。Julia 被特别设计来高效地满足我们这一代人的需求——机器学习、人工智能、高性能、并行、GPU
    和分布式云计算——这些都是在这些领域表现出色的领域。
- en: But, not only does Julia provide efficient language constructs for writing highly
    performant code—it also makes for a productive development experience. The powerful
    REPL (one of the best REPLs in all existing programming languages, period!) and
    the JIT compilation make it easy to quickly prototype solutions, slice and dice
    large amounts of data, or experiment with data models on the fly. The integrated
    help mode and the powerful shell mode empower developers, boosting productivity.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 但，Julia不仅提供了编写高性能代码的高效语言结构——它还提供了富有成效的开发体验。强大的REPL（所有现有编程语言中最好的REPL之一！）和即时编译功能使得快速原型设计解决方案、切割和分割大量数据，或即时实验数据模型变得容易。集成的帮助模式和强大的shell模式赋予了开发者力量，提升了生产力。
- en: Then there's the seamless integration with Jupyter Notebooks via IJulia—and
    the incredible cross-language integration with established programming languages
    such as Python and R. If you've used with these technologies, switching to Julia
    should be straightforward.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是通过IJulia与Jupyter Notebooks的无缝集成——以及与Python和R等现有编程语言的惊人跨语言集成。如果您已经使用过这些技术，切换到Julia应该会很直接。
- en: But the fact that Julia is new, just reaching version 1, does not mean that
    Julia is not a mature language. It's been crafted with care and attention for
    over six years—with contributions from thousands of developers. So, I encourage
    you to start using Julia for solving real problems. You'd be joining tens of thousands
    of other developers using the language professionally, for scientific computing,
    data science, AI, fintech, web development, teaching, and much more. Household
    names such as Apple, Amazon, Facebook, and Oracle—to name just a few—were all
    looking to hire Julia programmers in 2017.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 但Julia是新的，刚刚达到版本1，并不意味着Julia不是一个成熟的编程语言。它经过六年的精心打磨和关注——来自数千名开发者的贡献。因此，我鼓励您开始使用Julia来解决实际问题。您将加入成千上万的开发者行列，他们正在专业地使用这种语言进行科学计算、数据科学、人工智能、金融科技、Web开发、教学等领域。像苹果、亚马逊、Facebook和甲骨文这样的知名公司——仅举几个例子——在2017年都在寻找Julia程序员。
- en: I hope you enjoyed reading this book as much as I enjoyed writing it. You are
    now prepared—and I hope eager—to use Julia in your projects. So, instead of *Goodbye*,
    I'd like to say—*Welcome to the wonderful world of Julia programming!*
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您阅读这本书的乐趣和我写作这本书的乐趣一样。您现在已经准备好了——我希望您渴望——在您的项目中使用Julia！所以，与其说“再见”，我更想说的是——*欢迎来到Julia编程的奇妙世界！*
