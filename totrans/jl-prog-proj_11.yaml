- en: Creating Julia Packages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Julia 包
- en: We've come a long way since the beginning of our journey toward learning Julia.
    I hope you enjoyed this process of discovery as much as I did! We've covered a
    lot of ground, learning about many key topics while developing quite a suite of
    fully functional applications. Yet, there's one thing left in order to fully earn
    our Julia developer badge. The signature of every proficient Julia programmer—(drumroll,
    please!)—creating, publishing, and registering our own *official* Julia package!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自我们从学习 Julia 的旅程开始以来，我们已经走了很长的路。我希望你享受这个发现过程，就像我一样！我们已经覆盖了很多领域，在开发一系列完全功能的应用程序的同时，学习了众多关键主题。然而，为了完全获得我们的
    Julia 开发者徽章，我们还有一件事要做。每位熟练的 Julia 程序员的标志——（敲鼓声，请！）——创建、发布和注册我们自己的 *官方* Julia 包！
- en: 'In this chapter, we''ll build a REPL app and we''ll wrap it into a package.
    Our product will help Julia developers to easily report bugs they encounter in
    other Julia packages. Once the users install and configure our package, they will
    be able to open GitHub issues into the corresponding repo, without having to leave
    their REPL or IDE. In the process, we''ll learn about many other very important
    aspects of programming with Julia, such as the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个 REPL 应用程序，并将其封装成一个包。我们的产品将帮助 Julia 开发者轻松地报告他们在其他 Julia 包中遇到的错误。一旦用户安装并配置了我们的包，他们就能直接在相应的仓库中打开
    GitHub 问题，而无需离开他们的 REPL 或 IDE。在这个过程中，我们将学习到许多其他与 Julia 编程密切相关的重要方面，例如以下内容：
- en: Using Pkg to scaffold packages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pkg 搭建包
- en: Package versioning and dependencies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包版本控制和依赖关系
- en: Test-driven development in Julia and how to unit test our code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 中的测试驱动开发以及如何进行单元测试我们的代码
- en: Benchmarking and performance optimization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试和性能优化
- en: Interacting with the GitHub API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 GitHub API 交互
- en: Documenting the code base and generating documentation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录代码库并生成文档
- en: Publishing packages (with a little help from Julia's bots!)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布包（在 Julia 的机器人的一点点帮助下！）
- en: Ready? I sure hope so. Let's go!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？我确实希望如此。让我们开始吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The Julia package ecosystem is under continuous development and new package
    versions are released on a daily basis. Most of the times this is great news,
    as new releases bring new features and bug fixes. However, since many of the packages
    are still in beta (version 0.x), any new release can introduce breaking changes.
    As a result, the code presented in the book can stop working. In order to ensure
    that your code will produce the same results as described in the book, it is recommended
    to use the same package versions. Here are the external packages used in this
    chapter and their specific versions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的包生态系统正在不断发展，每天都有新的包版本发布。大多数时候，这是一个好消息，因为新版本带来了新功能和错误修复。然而，由于许多包仍在测试版（版本
    0.x）中，任何新版本都可能引入破坏性更改。因此，书中展示的代码可能会停止工作。为了确保你的代码会产生与书中描述相同的结果，建议使用相同的包版本。以下是本章中使用的外部包及其特定版本：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to install a specific version of a package you need to run:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装特定版本的包，你需要运行：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively you can install all the used packages by downloading the `Project.toml`
    file provided with the chapter and using `pkg>` instantiate as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以通过下载本章提供的 `Project.toml` 文件，并使用 `pkg>` 实例化来安装所有使用的包，如下所示：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating a new Julia package
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的 Julia 包
- en: In order to create a new package, we must first satisfy a few prerequisites.
    To start with, we need `git` installed and configured on the development machine.
    The obvious reason for this is that, by default, Julia uses `git` and GitHub ([https://github.com/](https://github.com/))
    to host packages (although third-party, including private package, registries
    can also be used). If your current choice of operating system does not come with
    `git` preinstalled, please visit [https://git-scm.com/downloads](https://git-scm.com/downloads)
    for the official download page. Pick the right version for your OS and follow
    the installation instructions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个新的包，我们首先必须满足一些先决条件。首先，我们需要在开发机器上安装并配置 `git`。显然，这是因为默认情况下，Julia 使用 `git`
    和 GitHub ([https://github.com/](https://github.com/)) 来托管包（尽管也可以使用第三方，包括私有包的注册表）。如果你的操作系统没有预装
    `git`，请访问 [https://git-scm.com/downloads](https://git-scm.com/downloads) 获取官方下载页面。选择适合你操作系统的正确版本，并按照安装说明进行操作。
- en: Second, if you don't already have a GitHub account, you'll need one. Please
    visit [https://github.com](https://github.com) and set up a free account.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，如果你还没有GitHub账户，你需要一个。请访问[https://github.com](https://github.com)并设置一个免费账户。
- en: 'Now that we have `git` installed and a GitHub account, let''s set up some global
    configuration options, as they''ll come in handy. Open a new Terminal window and
    execute the following—please make sure to replace the placeholder text within
    `<...>` with your actual information:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了`git`并拥有GitHub账户，让我们设置一些全局配置选项，因为它们将很有用。打开一个新的终端窗口并执行以下操作——请确保将`<...>`内的占位文本替换为你的实际信息：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So for example, in my case, the first command will be as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我的情况下，第一个命令将是以下内容：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Please check that all went well by running `git config -l`. You should get
    an output similar to mine:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请通过运行`git config -l`来检查一切是否顺利。你应该会得到一个类似于我的输出：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Excellent! We're now ready to get down to the business of setting up our package.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 极好！我们现在已经准备好开始设置我们的包。
- en: Generating packages
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成包
- en: 'Julia''s package manager, `Pkg`, expects a certain file structure in order
    to manage dependencies, run tests, build binaries, generate documentation, and
    so on. Thankfully, we don''t have to create all these manually: we will use `Pkg`
    itself, namely the `generate` command. All we need to do is pass it the name of
    our package. Let''s call it `IssueReporter`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的包管理器`Pkg`期望一定的文件结构以便管理依赖项、运行测试、构建二进制文件、生成文档等。幸运的是，我们不必手动创建所有这些：我们将使用`Pkg`本身，即`generate`命令。我们只需要传递我们包的名称。让我们称它为`IssueReporter`：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A new folder was created for us, named `IssueReporter/`. Within it, we can find
    a `Project.toml` file and a subfolder, `src/`, which includes an `IssueReporter.jl`
    file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们创建了一个新文件夹，命名为`IssueReporter/`。在其中，我们可以找到一个`Project.toml`文件和一个子文件夹`src/`，它包含一个`IssueReporter.jl`文件。
- en: The Project.toml file
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Project.toml文件
- en: 'The `Project.toml` file is very special for `Pkg`, as it''s used for managing
    packages and their dependencies. It is meant to include meta-information, such
    as the name of the package, its unique identifier (called the **UUID**), the version
    number, the author''s name, and the list of dependencies. `Pkg` has already prepopulated
    it, to get us started:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Project.toml`文件对于`Pkg`来说非常特殊，因为它用于管理包及其依赖项。它旨在包含元信息，例如包的名称、其唯一标识符（称为**UUID**）、版本号、作者的姓名以及依赖项列表。`Pkg`已经预先填充了它，以帮助我们开始：'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, `Pkg` has picked up the correct author information based on
    my Git settings; it has filled up the package's name and generated a new UUID,
    and assigned the version number `0.1.0`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Pkg`已经根据我的Git设置提取了正确的作者信息；它已经填写了包的名称并生成了一个新UUID，并分配了版本号`0.1.0`。
- en: The src folder and the main module
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: src文件夹和主模块
- en: 'The `src/` folder also plays a special role. A path of the form `<Package Name>/src/<Package
    Name>.jl` is used by Julia to identify the entry point into a package—that is,
    its main module. This path will be searched when we invoke `using IssueReporter`.
    To get us to a good start, the `IssueReporter.jl` file has already been filled
    up with a few lines of code, just enough to bootstrap the corresponding module:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/`文件夹也扮演着特殊角色。Julia使用形式为`<Package Name>/src/<Package Name>.jl`的路径来识别包的入口点——即其主模块。当我们调用`using
    IssueReporter`时，将会搜索这个路径。为了让我们有一个良好的开始，`IssueReporter.jl`文件已经填充了一些代码行，足以启动相应的模块：'
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using our new package
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我们的新包
- en: 'We can now activate the project and load our package:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以激活项目并加载我们的包：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At this point, our package''s environment has been activated and the included
    modules are available:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的包环境已经激活，并包含了模块：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Excellent—everything is set up and ready for us to add logic, tests, and documentation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 极好——一切都已经设置好，准备让我们添加逻辑、测试和文档。
- en: Defining the requirements for our package
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们包的需求
- en: The goal of our project is to create a Julia package that will make it very
    easy to report bugs in other Julia packages. We want to allow the users of our
    library to access a simple API for programmatic reporting of issues, without the
    need to go to GitHub ([https://github.com/](https://github.com/)) to manually
    create a new issue.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的目标是创建一个Julia包，使得报告其他Julia包中的错误变得非常容易。我们希望允许我们库的用户访问一个简单的API，用于程序化报告问题，而无需手动前往GitHub
    ([https://github.com](https://github.com))创建一个新的问题。
- en: 'In order to do this, we need to implement the following two features—a way
    to find out the GitHub URL of a registered package; and the means to access the
    GitHub API to register a new issue on the found repo. Given that `Pkg` is capable
    of cloning a package from GitHub using only the name of the package, we can safely
    assume that the information is available with our Julia install, and that somehow
    we''ll be able to access that information ourselves. Then, the aptly named `GitHub`
    package will help us to interface with GitHub''s API. We can start by adding it.
    Please make sure that the currently active project is `IssueReporter`. This should
    be indicated by the `(IssuerReporter)` prefix, placed in front of the `pkg>` cursor.
    If that is not the case, as previously explained, you need to `cd` into our package''s
    directory and then run `pkg> activate .` as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要实现以下两个功能——一种找出已注册包的GitHub URL的方法；以及访问GitHub API在找到的仓库上注册新问题的手段。鉴于`Pkg`能够仅使用包名从GitHub克隆包，我们可以安全地假设这些信息与我们的Julia安装一起可用，并且我们将在某种方式下能够访问这些信息。然后，名为`GitHub`的包将帮助我们与GitHub的API进行接口。我们可以先添加它。请确保当前活动项目是`IssueReporter`。这应该由放在`pkg>`光标前的`(IssuerReporter)`前缀表示。如果不是这种情况，如前所述，您需要`cd`到我们的包目录，然后按照以下方式运行`pkg>
    activate .`：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'While we''re at it, let''s also add the `URIParser` package—we''ll work a lot
    with repo URLs and this functionality will come in handy:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们忙于这件事时，也可以添加`URIParser`包——我们将大量使用仓库URL，这个功能将很有用：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And, one more thing—we''ll use **test-driven development** (**TDD**) in order
    to build our project, so we''ll also need Julia''s `Test` module:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一件事——我们将使用**测试驱动开发**（**TDD**）来构建我们的项目，因此我们还需要Julia的`Test`模块：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point, all the packages have been added to the list of dependencies.
    You can confirm this by checking the `Project.toml` file, which is under the `[deps]`
    section and should now show the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有包都已添加到依赖项列表中。您可以通过检查`Project.toml`文件来确认这一点，该文件位于`[deps]`部分，现在应显示以下内容：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we have all the prerequisites for adding our logic, the TDD way.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经具备了添加逻辑的所有先决条件，采用TDD方式。
- en: Beginning with test-driven Julia development
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从测试驱动的Julia开发开始
- en: Test-driven development is a software development practice based on a simple
    workflow that puts automated testing center stage. The basic idea is that the
    requirements are turned into very specific, well-defined, and targeted test cases.
    Each test should address only one piece of functionality. Once the test is ready,
    we run the whole test suite. Obviously, as we first write the test, it will initially
    fail. Next, we add the minimal implementation to make the test pass. That's it—all
    we need to do is repeat the same process until all the requirements are implemented.
    This approach ensures that our code base is thoroughly tested and that we focus
    on delivering just the requirements, avoiding feature creep.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发是一种基于简单工作流程的软件开发实践，将自动化测试置于核心位置。基本思想是将需求转化为非常具体、定义良好且具有针对性的测试用例。每个测试用例应仅针对一个功能点。一旦测试准备就绪，我们就运行整个测试套件。显然，由于我们首先编写测试，它最初会失败。接下来，我们添加最小实现以使测试通过。就是这样——我们所需做的就是重复相同的流程，直到所有需求都得到实现。这种方法确保我们的代码库得到彻底测试，并且我们专注于仅交付需求，避免功能蔓延。
- en: 'Julia provides built-in unit testing capabilities under the `Test` module.
    It is very straightforward and easy to use, providing enough methods to cover
    all the basic testing scenarios: value and exception checking, approximate values,
    types, and so on.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Julia在`Test`模块下提供了内置的单元测试功能。它非常简单易用，提供了足够的方法来覆盖所有基本测试场景：值和异常检查、近似值、类型等。
- en: The most important ones are the `@test`, `@test_throws`, and `@testset` macros.
    The `@test` macro checks that the `expression` passed as argument evaluates to
    true, returning a `PassResult`. If the test does not pass, it will return either
    a `FailResult` when the expression evaluates to `false`—or an `ErrorResult` if
    the expression can't be evaluated at all. The `@test_throws` macro checks that
    the evaluated expression throws an exception. Finally, `@testset` is used to group
    tests into sets. All the tests in a test set will run, and at the end of the test
    set, a summary of the results will be displayed. If any of the tests failed, or
    could not be evaluated due to an error, the test set will throw a `TestSetException`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是 `@test`、`@test_throws` 和 `@testset` 宏。`@test` 宏检查作为参数传递的表达式是否评估为真，返回一个
    `PassResult`。如果测试未通过，当表达式评估为 `false` 时，它将返回一个 `FailResult`——或者如果表达式根本无法评估，则返回一个
    `ErrorResult`。`@test_throws` 宏检查评估的表达式是否抛出异常。最后，`@testset` 用于将测试分组。测试集中的所有测试都将运行，并在测试集末尾显示结果摘要。如果任何测试失败，或由于错误无法评估，测试集将抛出
    `TestSetException`。
- en: 'For example, consider the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下内容：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The previous snippet shows the output from both a passing and a failing test.
    The following one illustrates the use of test sets, with one passing and one failing
    test:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个片段显示了通过和失败测试的输出。以下一个片段说明了测试集的使用，其中一个测试通过，另一个测试失败：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, this is how exceptions are handled:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是处理异常的方式：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we have the testing theory covered, let's continue by writing our first
    test. We will need a method that will take a package name and return the corresponding
    GitHub repo URL. This URL will be used in order to later interact with the GitHub
    API and open the issue into the corresponding repo. For now, we'll just check
    that the return value is a valid URL. We'll use the `URIParser` package to check
    the validity.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了测试理论，让我们继续编写我们的第一个测试。我们需要一个方法，该方法将接受一个包名并返回相应的GitHub仓库URL。这个URL将用于稍后与GitHub
    API交互并在相应的仓库中打开问题。目前，我们只需检查返回值是否为有效的URL。我们将使用 `URIParser` 包来检查其有效性。
- en: Julia makes it easy to add and run tests for our package, again, through the
    functionality provided by `Pkg` under the `test` command. When we run `(IssueReporter)
    pkg> test`, the `Pkg` library will look for a file called `runtests.jl` in the
    `test/` folder.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Julia通过 `Pkg` 提供的功能使我们能够轻松添加和运行测试，再次通过 `test` 命令下的功能。当我们运行 `(IssueReporter)
    pkg> test` 时，`Pkg` 库将在 `test/` 文件夹中查找名为 `runtests.jl` 的文件。
- en: 'Time to add them—from within the Julia REPL:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候在Julia REPL内部添加它们了：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, open the newly created `runtests.jl` file in the editor, for example,
    by running the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在编辑器中打开新创建的 `runtests.jl` 文件，例如，通过运行以下命令：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Please make sure your `runtests.jl` file looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您的 `runtests.jl` 文件看起来像这样：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A test set block, defined by the `@testset` macro, groups multiple tests and/or
    other tests sets. The reason for using test sets is that when a test fails, an
    exception is thrown, causing the execution of the script to stop. However, when
    we have a large batch of tests, we usually prefer to allow all the tests to run
    and get a full report of what failed and what worked. With a test set, all the
    tests within the set will be run and a summary will be displayed at the end of
    the set. If any of the tests fail, or cannot be evaluated due to an error, the
    test set will then throw a `TestSetException`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试集块，由 `@testset` 宏定义，将多个测试和/或其他测试集组合在一起。使用测试集的原因是，当测试失败时，会抛出异常，导致脚本执行停止。然而，当我们有一大批测试时，我们通常更喜欢允许所有测试运行，并得到一个完整的失败和成功的报告。使用测试集，集合内的所有测试都将运行，并在集合末尾显示摘要。如果任何测试失败，或由于错误无法评估，测试集将抛出
    `TestSetException`。
- en: Test sets should have self-explanatory names relevant to the batch of tests
    they represent, as these labels are outputted when the tests are run.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 测试集应该有自解释的名称，与它们所代表的测试批次相关，因为这些标签在运行测试时会被输出。
- en: 'We can run the test as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式运行测试：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It will fail with an informative message:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它将以一条信息丰富的消息失败：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The important bit is `UndefVarError: packageuri not defined`. This is unsurprising,
    as we have not yet defined the `IssueReporter.packageuri` function.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '重要的是 `UndefVarError: packageuri 未定义`。这并不令人惊讶，因为我们还没有定义 `IssueReporter.packageuri`
    函数。'
- en: Peeking into Julia's registry
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看Julia的注册表
- en: As we were saying, we need a way to retrieve the GitHub URI of a package, based
    on the package's name. Now, given that we're able to successfully execute operations
    such as `add` and `develop` with `Pkg`, without having to provide the GitHub URI,
    we can assume that there is a way to convert a package name to a package URL.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, Julia manages a repository of all the packages that are known to `Pkg`.
    These packages are grouped into multiple registries that are copied to your computer.
    By default, Julia comes with the so-called `General` registry, which can be found
    in the `.julia/` folder in your home directory. The `General` registry itself
    is nothing but a folder that contains subfolders named after each letter in the
    English alphabet (thus, from `A` to `Z`). Within each of these folders, we can
    find all the packages whose names start with that letter:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6abab19b-7d55-4b66-b195-3497520fd947.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: This screenshot shows a part of the `General` registry, with some of its folders
    (from `A` to `D`) and some of the packages starting with the letter `D`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make package retrieval more efficient, a special index file, called
    `Registry.toml`, is also placed inside the `General` folder. This file defines
    a hash-based index that maps package UUIDs to a dictionary of `name` and `path`
    values—the path being relative and pointing to a folder within the `General` registry.
    For example, this is the entry corresponding to the `D3Trees` package, the first
    one under the letter `D`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Moving on, if we peek into the `D3Trees/` folder itself, we''ll see that it
    contains four files, each of them containing important metadata:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60224858-81ad-498f-9ca5-402cd18423fb.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: The screenshot shows the four `Pkg` metadata files belonging to the `D3Trees`
    package.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The `Deps.toml` file includes the list of dependencies (those packages required
    by `D3Trees` itself). The `Compat.toml` file stores compatibility requirements
    for the dependencies and for the Julia versions. `Package.toml` defines information
    such as name, UUID, and repo URL, and finally, `Versions.toml` shows all the known
    versions of `D3Trees` together with their corresponding Git references. It looks
    like we need the information within the `Package.toml` file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow, then, is the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Get the path to Julia's `General` registry
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the `Registry.toml` file
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for a package with the name that we're searching for
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the package exists, get its path in the `General` registry
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the corresponding `Package.toml` file
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the package's GitHub URL
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working with TOML files
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tom''s Obvious, Minimal Language** (**TOML**) is a minimal configuration
    file format created by Tom Preston-Werner. TOML files serve the same purpose as
    other configuration formats, for example, the famous INI—although TOML''s goal
    is to be easier to read and easier to parse. YAML and JSON are other very popular
    configuration formats that you may have encountered. `Pkg` makes extensive usage
    of TOML for storing package metadata.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tom的明显、最小语言**（**TOML**）是由Tom Preston-Werner创建的最小配置文件格式。TOML文件与其他配置格式（例如著名的INI）具有相同的目的——尽管TOML的目标是更容易阅读和解析。YAML和JSON是其他非常流行的配置格式，你可能已经遇到过。`Pkg`广泛使用TOML来存储包元数据。'
- en: You can read more about TOML, including the full specification, at [https://github.com/toml-lang/toml](https://github.com/toml-lang/toml).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/toml-lang/toml](https://github.com/toml-lang/toml)了解更多关于TOML的信息，包括完整的规范。
- en: 'A TOML parser for Julia is available at [https://github.com/wildart/TOML.jl](https://github.com/wildart/TOML.jl),
    but we don''t need to explicitly add it as `Pkg` comes bundled with a TOML parser
    that we will use instead. But, this means that we do have to declare `Pkg` as
    a dependency of `IssueReporter`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的TOML解析器可在[https://github.com/wildart/TOML.jl](https://github.com/wildart/TOML.jl)找到，但我们不需要显式添加它，因为`Pkg`附带了一个我们将使用的TOML解析器。但这意味着我们必须将`Pkg`声明为`IssueReporter`的依赖项：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, to implement the preceding workflow. First, the path to the `General` registry.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，来实现前面的工作流程。首先，`General`注册表的路径。
- en: 'Julia keeps track of a list of locations where important information is stored.
    This info includes configuration files, environments, installed packages, and
    registries. In Julia''s lingo, these are called **depots** and are stored in the
    `DEPOT_PATH` global variable:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Julia跟踪一个存储重要信息的位置的列表。这些信息包括配置文件、环境、已安装的包和注册表。在Julia的术语中，这些被称为**存储库**，并存储在`DEPOT_PATH`全局变量中：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The contents of the `DEPOT_PATH` array on my computer are shown here. Your output
    will be different, but similar.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我电脑上`DEPOT_PATH`数组的内容如下所示。你的输出将不同，但类似。
- en: The first entry is the user depot where registries are cloned, new package versions
    are installed, package repos are cloned, log files are written, development packages
    are checked out by default, and global configuration data is saved. Later entries
    in the depot path are read-only and are used for operations performed by system
    administrators.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条记录是用户存储库，其中包含注册表的克隆、新包版本的安装、包仓库的克隆、日志文件的写入、默认检出开发包以及保存全局配置数据。存储库路径中的后续条目是只读的，用于系统管理员执行的操作。
- en: 'Let''s add a new (failing) test for getting the `General` registry path:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个新的（失败的）测试来获取`General`注册表的路径：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As for the implementation, we will want to loop over each entry in the `DEPOT_PATH`
    and check if it contains a `registries/General` path of directories. These should
    be in the user depot, but a more extensive lookup will make our code more robust:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实现，我们希望遍历`DEPOT_PATH`中的每个条目，并检查它是否包含`registries/General`目录路径。这些应该在用户存储库中，但更广泛的查找会使我们的代码更健壮：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once we have the path to the `General` registry, we''ll want to parse the `Registry.toml`
    file and extract the information corresponding to the package we''ll be searching
    for. Once parsed, the `Registry.toml` file produces in a dictionary with five
    entries:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`General`注册表的路径，我们希望解析`Registry.toml`文件并提取与我们要搜索的包对应的信息。一旦解析，`Registry.toml`文件将生成一个包含五个条目的字典：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''re only interested in the *packages* data, which looks like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对`*packages*`数据感兴趣，它看起来像这样：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And actually, we don''t want all that, since we don''t care about the UUID;
    only the name and the path. Let''s add a new function to the `IssueReporter` module,
    to reflect this spec:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们并不需要所有这些，因为我们不关心UUID；只关心名称和路径。让我们向`IssueReporter`模块添加一个新函数，以反映这个规范：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output of the function is similar to this, an array of `Dict` elements:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的输出类似于这个，一个`Dict`元素的数组：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once we have this, it is very easy to perform a package lookup by name. We
    simply iterate over each item and compare the `"name"` value against the search
    string:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个，通过名称进行包查找就非常容易了。我们只需遍历每个项目，并将`"name"`值与搜索字符串进行比较：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After we identify a package by name, we can use the path value to build the
    path to the folder that contains the package's metadata information. Remember
    that we're after the `Package.toml` file, as this contains the repo URI.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 识别出包的名称后，我们可以使用路径值来构建包含包元数据信息的文件夹的路径。记住，我们正在寻找`Package.toml`文件，因为它包含仓库URI。
- en: 'Putting it all together, we can finally write our `IssueReporter.packageuri`
    function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们最终可以写出我们的`IssueReporter.packageuri`函数：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Your `IssueReporter.jl` file should look like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`IssueReporter.jl`文件应该看起来像这样：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The IssueReporter.jl package
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IssueReporter.jl包
- en: 'Running the tests again will be successful:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试将会成功：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/1e7c324e-9905-43ac-b1ca-b8e9282253f9.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e7c324e-9905-43ac-b1ca-b8e9282253f9.png)'
- en: 'If you''re curious, the GitHub repo URI for `DataFrames`, according to `IssueReporter`,
    is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇，根据`IssueReporter`，`DataFrames`的GitHub仓库URI如下：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you want, you can check for yourself in the web browser to confirm that it
    is indeed, the correct URI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想的话，可以在网络浏览器中自行检查以确认它确实是正确的URI。
- en: Performance testing
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试
- en: Our code works correctly so far, but what about it's performance? Besides its
    readable syntax, liberal license, rich package ecosystem, and welcoming community,
    performance is one of the top reasons why data scientists and software developers
    choose Julia. The compiler does a great job of providing excellent performance
    out of the box, but there are certain best practices that we as developers must
    keep in mind to ensure that we basically don't hinder the compiler. We'll go over
    the most important ones by looking at a few examples while running some benchmarks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码到目前为止运行正确，但它的性能如何呢？除了其可读的语法、宽松的许可、丰富的包生态系统和友好的社区，性能也是数据科学家和软件开发者选择Julia的主要原因之一。编译器能够提供出色的性能，但有一些最佳实践是我们作为开发者必须牢记在心的，以确保我们基本上不会阻碍编译器。我们将通过查看一些示例并在运行基准测试的同时，来介绍最重要的几个。
- en: Benchmarking tools
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试工具
- en: 'Given its focus on performance, it should come as no surprise that both core
    Julia and the ecosystem provide a variety of tools for inspecting our code, looking
    for bottlenecks and measuring runtime and memory usage. One of the simplest is
    the `@time` macro. It takes an expression and then prints its execution time,
    number of allocations, and the total number of bytes the execution caused to be
    allocated, before returning the result of the expression. For example, note the
    following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它专注于性能，所以Julia的核心和生态系统提供各种工具来检查我们的代码，寻找瓶颈并测量运行时间和内存使用，这并不令人惊讶。其中最简单的一个是`@time`宏。它接受一个表达式，然后打印其执行时间、分配的数量以及执行导致的总字节数，在返回表达式的结果之前。例如，注意以下内容：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Generating an array of one million integers by iterating from one to one million
    takes 0.03 seconds. Not bad, but what if I told you that we can do better—much
    better? We just committed one of the cardinal sins of Julia—code should not be
    run (nor benchmarked) in the global scope. So, rule one—always wrap your code
    into functions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过迭代从一到一百万生成一百万个整数的数组需要0.03秒。不错，但如果我告诉你我们可以做得更好——好得多呢？我们犯了一个Julia的致命错误——代码不应该在全局范围内运行（或基准测试）。所以，第一条规则——总是将你的代码封装成函数。
- en: 'The previous snippet can easily be refactored as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段可以轻松重构如下：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, the benchmark is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基准测试如下：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: All right, that's clearly faster—but not much faster. However, what if we run
    the benchmark one more time?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这确实更快——但并没有快很多。然而，如果我们再运行一次基准测试会怎样呢？
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Wow, that's an order of magnitude faster! So, what gives?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这快了一个数量级！那么，这是怎么回事呢？
- en: If you remember from our coverage of functions and methods, Julia uses a **just-in-time**
    (**JIT**) compiler; that is, a function is compiled in real time when it is invoked
    for the first time. So, our initial benchmark also included the compilation time.
    This brings us to the second rule—don't benchmark the first run.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得我们关于函数和方法的介绍，Julia使用的是**即时编译**（**JIT**）编译器；也就是说，一个函数在第一次被调用时实时编译。因此，我们的初始基准测试也包括了编译时间。这引出了第二条规则——不要基准测试第一次运行。
- en: 'The best way to accurately measure the performance of a piece of code, thus,
    would be to execute it multiple times and then compute the mean. There is a great
    tool, specially designed for this use case, called `BenchmarkTools`. Let''s add
    it and give it a try:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，准确测量代码性能的最佳方式是多次执行它，然后计算平均值。有一个专为这种用例设计的优秀工具，称为`BenchmarkTools`。让我们添加它并尝试一下：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`BenchmarkTools` took `1788` samples, with an evals to sample ratio of `1`.
    Here, a sample represents a measurement, while an evaluation is an execution of
    the benchmark expression. We got a maximum time of 55 milliseconds, driven by
    the garbage collection, with a minimum of 1.3 milliseconds, and a mean of 2.7
    milliseconds. That is in line with what the second `@time` execution revealed,
    at 2.4 milliseconds—but this benchmark is far more accurate. We can also use the
    more compact `@btime` macro, which has an output similar to `@time`, but executes
    an equally comprehensive benchmark:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`BenchmarkTools` 捕获了 `1788` 个样本，评估到样本的比例为 `1`。在这里，一个样本代表一个测量值，而一个评估是对基准表达式的执行。我们得到了最大
    55 毫秒的时间，由垃圾回收驱动，最小为 1.3 毫秒，平均为 2.7 毫秒。这与第二个 `@time` 执行所揭示的 2.4 毫秒相符——但这个基准要准确得多。我们还可以使用更紧凑的
    `@btime` 宏，它的输出类似于 `@time`，但执行了一个同样全面的基准：'
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`BenchmarkTools` exposes a very rich API and it''s worth getting to know it
    well. You can read more about it at [https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/doc/manual.md](https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/doc/manual.md).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`BenchmarkTools` 提供了一个非常丰富的 API，值得深入了解。你可以在[https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/doc/manual.md](https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/doc/manual.md)了解更多信息。'
- en: Type stability is key
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型稳定性至关重要
- en: If there is one thing that has a direct and massive impact on the performance
    of Julia code, it's the type system. And the most important thing about it is
    to write code that is type-stable. Type stability means that the type of a variable
    (including the return value of a function) must not vary with time or under different
    inputs. Understanding how to leverage type stability is key to writing fast software.
    Now that we know how to measure our code's execution time, we can see the effect
    of type instability with a few examples.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一件事对 Julia 代码的性能有直接和巨大的影响，那就是类型系统。最重要的是编写类型稳定的代码。类型稳定性意味着变量的类型（包括函数的返回值）必须不会随时间或不同的输入而变化。了解如何利用类型稳定性是编写快速软件的关键。现在我们知道了如何测量代码的执行时间，我们可以通过几个例子看到类型不稳定性的影响。
- en: 'Let''s take this innocent-looking function, for example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以这个看起来很无辜的函数为例：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There's nothing fancy about it. We have a variable, `x`, which is initialized
    to `0`—and then a loop from `1` to `10`, where we add the `sin` of a number to
    `x`. And then we return `x`. Nothing to see, right? Well, actually, quite the
    contrary—a few bad things, performance-wise, are happening here. And they all
    have to do with type instability.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它并没有什么特别之处。我们有一个变量 `x`，它被初始化为 `0`，然后是一个从 `1` 到 `10` 的循环，我们将一个数字的正弦值加到 `x` 上。然后我们返回
    `x`。没有什么可看的，对吧？实际上，恰恰相反——这里发生了一些性能上的不良情况。它们都与类型不稳定性有关。
- en: 'Julia provides a great tool for inspecting and diagnosing code for type-related
    issues—the `@code_warntype` macro. Here''s what we get when we use it with our
    `f1` function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 提供了一个出色的工具来检查和诊断与类型相关的问题——`@code_warntype` 宏。当我们用它与我们的 `f1` 函数一起使用时，我们得到以下结果：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/acb8a124-d316-4c01-8f17-d5985117cd02.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acb8a124-d316-4c01-8f17-d5985117cd02.png)'
- en: 'This time, I''m using a screenshot for the output, in order to illustrate the
    color coding. As you might expect, green is good and red is bad. I am also marking
    the red flags with a rectangle. The problems are with `Body::Union{Float64, Int64}` on
    the first line, `(#4 => 0, #14 => %29)::Union{Float64, Int64}` on line `12`, and
    `(#13 => %29, #4 => 0)::Union{Float64, Int64}` on the penultimate line.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '这次，我使用截图来展示输出，以便说明颜色编码。正如你所预期的那样，绿色是好的，红色是坏的。我还用矩形标记了红旗。问题出在第一行的 `Body::Union{Float64,
    Int64}`，第 `12` 行的 `(#4 => 0, #14 => %29)::Union{Float64, Int64}`，以及倒数第二行的 `(#13
    => %29, #4 => 0)::Union{Float64, Int64}`。'
- en: On the first line, the `Body::Union{Float64, Int64}`, as well as on the penultimate
    line, `::Union{Float64, Int64}`, tell us the same thing—the function returns a
    `Union{Float64, Int64}`, meaning that the function can return either a `Float`
    or an `Integer`. This is textbook type instability and bad news for performance.
    Next, on line `12`, *something* has a type of `Union{Float64, Int64}` and this
    value is then returned as the result of the function. In case you're wondering,
    that *something* is `x`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，`Body::Union{Float64, Int64}`，以及倒数第二行，`::Union{Float64, Int64}`，告诉我们同样的事情——该函数返回一个
    `Union{Float64, Int64}`，这意味着该函数可以返回一个 `Float` 或一个 `Integer`。这是典型的类型不稳定性，对性能来说是个坏消息。接下来，在第
    `12` 行，*某个东西* 的类型是 `Union{Float64, Int64}`，然后这个值作为函数的结果返回。如果你想知道，那个 *某个东西* 就是
    `x`。
- en: The problem is that we unsuspectingly initialized `x` to `0`, an `Integer`.
    However, the `sin` function will return a `Float`. Adding a `Float` to an `Integer`
    will result in a `Float`, causing the type of `x` to change accordingly. Thus,
    `x` has two types during the execution of the function, and since we return `x`,
    our function is also type-unstable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Granted, understanding the output of `@code_warntype` is not easy, although
    it does get easier with time. However, we can make our job easier by using the
    super-useful `Traceur` package. It provides a `@trace` macro, which generates
    human-friendly information. Let''s add it and try it out; you''ll appreciate it,
    I''m sure:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How cool is that? Crystal clear!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'With this feedback in mind, we can refactor our code into a new `f2` function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Awesome, nothing to report! No news is good news!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can benchmark `f1` and `f2` to see the result of our refactoring:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That's nice—79 versus 129 nanoseconds! If you're thinking that *It's just 50
    nanoseconds, what's all the fuss about?*, you need to look at it this way—`f2`,
    the type-stable variant, is almost twice as fast as `f1`! And that's a really
    big deal!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking our code
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to apply what we''ve learned to our own code base. Heads up, I have
    intentionally sneaked in a few problems, to spice things up a bit. Let''s fix
    them together:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10c7d5ce-3ae9-42aa-8b1f-cf29fb6ea23f.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: This is all very interesting—let's see what we can learn from it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Starting with line `1`, the `IssueReporter.generalregistrypath` function returns
    a `Union{Nothing, String}`. The reason is that our function does not handle the
    case when the `for` loop is not entered, or when the `if` statement is not executed.
    We should make sure that our function always returns a value and that the type
    of this return value does not change. To be extra sure, we can also add a type
    assertion to the function definition itself. If we accidentally return the wrong
    type, Julia will try to convert it to the declared type—if that doesn't work,
    an error is thrown.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to redefine the function as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, on to the line starting with `%2` (the third line)—the `searchregistry`
    function returns a value of type `Any`. The issue here is that we return an item
    coming from the invocation of `generalregistry`, so we need to look at that first.
    We'll add a check for the return value of `generalregistrypath`, and we add a
    default return value, an empty `Vector{Dict{String,Any}}`. Then, for `searchregistry`,
    we'll also add a default return value—since it returns an item from this `Vector`,
    it will be of type `Dict{String,Any}`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Next, in regards to the `packageuri` function, in the line starting with `%9` (on
    line `11`), we can see something about a `KeyError` and `repo`. Julia is warning
    us that it's possible that we won't have a key named `repo`, thus leading to a
    `KeyError`. Also, the function returns an object of type `Any`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the three functions, refactored:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can now recheck our code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aec1e4c4-9374-4937-8a4e-952d886aaccd.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: Excellent, almost everything is green! There's just one red `Any`, coming from
    the `TOML.parsefile` function itself, but it's just not worth optimizing that
    away; the extra work would cancel the benefit.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: It's definitely worth spending some time going over the official performance
    recommendations, available online at [https://docs.julialang.org/en/v1/manual/performance-tips/](https://docs.julialang.org/en/v1/manual/performance-tips/).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the GitHub API
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can retrieve the GitHub URI for any package in the `General` registry,
    we can use it to interact with the GitHub API. Julia developers have access to
    a powerful GitHub library provided by the GitHub package. It's what we'll use
    in order to create new issues on the packages' GitHub repos.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating with the GitHub API
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to be allowed to interact with the GitHub API, we have to authenticate.
    This will permit our package to execute actions on GitHub under the user''s account
    as if done directly through the website. Please access [https://github.com/settings/tokens/new](https://github.com/settings/tokens)
    to set up a new GitHub access token. If you''re not familiar with the concept
    and would like to learn more about this, please read on and follow the official
    instructions at [https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/).
    Give the token a good description and, very importantly, make sure that you check
    the repo scope, just as you can see in this screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4109ce90-615c-403b-ac74-a4fe1de71118.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: Once generated, write down the token—once you leave that page, you won't see
    it again.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The access tokens must be manipulated with care—and must not be committed to
    git or other source control systems where they can be accessed by other users.
    Anybody that gets your access token can use it to impersonate you on GitHub. To
    be on the safe side, please make sure that for this project, you only check the
    repo scope.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a bit of logic to make the access token available to our package without
    compromising security. It should work as follows—first, we check if the access
    token is provided as a command line parameter to the Julia process—meaning that
    it will be available in the `ENV` collection. If it's not, we'll look for a file
    called `secrets.jl` in the root folder of the package and include it. The file
    will contain the access token so we'll add it to `.gitignore`, to make sure it's
    not accidentally committed to git.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s write the tests. Append the following at the end of `runtests.jl`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The tests will fail, of course, so let's make them pass.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these function definitions to `IssueReporter.jl`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the `tokenisdefined` function, we check if the `GITHUB_ACCESS_TOKEN` environment
    variable is already defined—if not, we check for the `secrets.jl` file and, if
    it exists, we include it. Once included, the `secrets.jl` file should define the
    variable, so finally, we check again for the existence of `GITHUB_ACCESS_TOKEN`.
    If the token is still not defined, the function returns `false`—otherwise, `true`.
    We''ve also added a token function that invokes `tokenisdefined`, giving the module
    the chance to set up `GITHUB_ACCESS_TOKEN`. If the token is available, it returns
    it—if not, this time an error is thrown. Our tests should now pass:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is it, as shown here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f998ece-b5fe-420e-8b2b-7854bd0c9201.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: Success!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, we need to add the `secrets.jl` file to `.gitignore`—committing
    this to a public GitHub repo would be a huge security error. From the Julia REPL,
    note the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, you need to create the `secrets.jl` file itself and make sure that it
    contains something similar to the next snippet, but adding your own GitHub access
    token:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Excellent, we're ready to report issues!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Reporting GitHub issues
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're now down to the last step—using the GitHub API to report problems. In
    order to register an issue, we need two pieces of information—the title and the
    body. As such, we'll have to define a new function, called `report`, which will
    accept *three* string arguments—the name of the package, plus two more for the
    title and the body of the issue. Internally, the function will make an authenticated
    call to the corresponding GitHub API via the GitHub package.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the documentation, a call to the `GitHub.create_issue` method
    looks like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This means that we need to do the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Use the GitHub token to authenticate and generate the required `GitHub.OAuth2`
    authentication object
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Starting from the Julia package name, compute the GitHub username and repo info—for
    this, we'll use the already implemented `IssueReporter.packageurl`, plus some
    extra processing to remove the unwanted parts from the URL
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the call to `GitHub.create_issue`, passing in all the required arguments
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we''re doing TDD, let''s begin by converting these specifications into
    tests. Add the following at the very bottom of the `runtests.jl` file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The tests mirror, in the exact same order, the requirements we previously expressed
    in plain English. The first one invokes a function that we'll have to write, called
    `IssueReporter.githubauth`, which will perform the GitHub authentication and will
    return a `GitHub.OAuth2` object if successful. Next, we'll need a new `repoid`
    function, which will take the name of a package and will return the GitHub username
    and repo name. Notice that we're using my repo of the `IssueReporter` package
    as the guinea pig for our testing. Finally, we test the issue creation, which
    will be done by the `IssueReporter.report` method—on success, we expect a `GitHub.Issue`
    object.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Don't use Julia for anything evil! The code we're writing will actually register
    new issues on live GitHub repos. Please be respectful of the hard work of the
    open source contributors and don't overload them with fake issues.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to make the tests pass by writing the implementations. Make sure that
    the `using` directive of the `IssueReporter` module reads as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And then, add the following functions to the bottom of the `IssueReporter`
    module:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Pretty straightforward. The `githubauth` function invokes the `GitHub.authenticate`
    method, passing it the auth token provided by a call to the token function.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The `repoid` method accepts a string parameter for the name of the repo, then
    invokes the `packageuri` and the `URIParse.parse_url` to generate a URI object
    corresponding to the GitHub repo. We then extract the path component of the URI
    and process it to keep only the GitHub username and the repo name. In other words,
    starting with the package named `IssueReporter`, we retrieve the GitHub repo URL,
    which is `git://github.com/essenciary/IssueReporter.jl.git`. The path component
    is `/essenciary/IssueReporter.jl.git`. We use replace with the `r".git$"` regex
    to remove the `.git` ending before returning the substring starting from the second
    letter. At the end, we have what we need—`essenciary/IssueReporter.jl`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, the report function puts it all together by invoking the `GitHub.create_issue`
    method and passing it the `repoid`, the authentication object, and the title and
    body of the issue within a `Dict`. All the tests should pass now and the issues
    are successfully created on Github.com ([https://github.com/](https://github.com/)):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/668b4028-4bd8-4a21-8f2f-5f67691461b2.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: Please note that the sample code provided with the chapter has the `create issue`
    functionality commented out—and instead it has hard-coded a dummy repository.
    Again, out of respect for the contributors and followers of the real repos, the
    actual issues will be created on a dummy repository that I created especially
    for this purpose.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Documenting our package
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our package is now complete! Let's make it easy for our users to take advantage
    of the amazing convenience provided by `IssueReporter`—we'll supply them an informative
    documentation. We already know how to document our code by using `DocStrings`
    - which can be used by ourselves and other developers to understand our source
    code. It's also used by the REPL's help system (remember from [Chapter 1](90a7f09d-d63b-45d7-baf5-576470d0910f.xhtml), *Getting
    Started with Julia Programming* that you can type `?` at the beginning of the
    line to switch the REPL to help mode). You'll be happy to hear that we can also
    generate package documentation using the same `DocStrings`, with the help of a
    package called `Documenter`. Please add it with `(IssueReporter) pkg> add Documenter`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first thing to do is add some `DocStrings` to our functions. Keep in
    mind that the *official* recommendation is to include the function''s signature
    together with a small description and a few examples. For instance, the documentation
    for the `IssueReporter.packageuri` function could look like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62] jldoctest julia> IssueReporter.packageuri("IssueReporter") "git://github.com/essenciary/IssueReporter.jl.git"
    [PRE63]'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Advanced documentation tips
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Another valuable feature of `DocStrings` is that the examples can also serve
    as tests. This kind of testing is called a **doctest**. Basically, when we provide
    a REPL example together with the corresponding output, if we tag this as a *jldoctest*,
    the `Documenter` package used to generate the documentation will also run the
    examples and compare the result against the provided output, thus testing the
    examples and, implicitly, our code. Check the next snippet to see what the previous
    example looks like after we apply these optimizations.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'I have added comments to all the functions that represent the *public* API
    of `IssueReporter`. Here are the updated function definitions (you can get the
    full file from this chapter''s repo at [https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter11/IssueReporter/src/IssueReporter.jl](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter11/IssueReporter/src/IssueReporter.jl)):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]julia-repl'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: julia> IssueReporter.packageuri("IssueReporter")
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '"git://github.com/essenciary/IssueReporter.jl.git"'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]jldoctest'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: julia> IssueReporter.repo_id("IssueReporter")
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '"essenciary/IssueReporter.jl"'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Generating the documentation
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to create our documentation, we'll need to first create a `docs/` folder
    inside our `IssueReporter` root directory.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `docs/` folder, we need two more things—first, a `src/` folder,
    which will contain the markdown template that will be used to build the documentation,
    the `index.md` file; second, a `make.jl` file that will control the documentation
    building process. Here is the full file structure of our package, for reference:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/125def3c-c57d-4429-af88-e08d85d9bce4.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: 'Now, open the `docs/make.jl` file in the editor and add the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, open the `index.md` file in the editor and add the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]@meta'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: CurrentModule = IssueReporter
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]@contents'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]@docs'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: packageuri(pkgname::String)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: tokenisdefined()
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: token()
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: githubauth()
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: repoid(package_name::String)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: report(package_name::String, title::String, body::String)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]@index'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This is the markdown template of our documentation. At the top, we have the
    title of the page. Then, the `@meta` block contains information for `Documenter`,
    passing in the name of the module. The `@contents` block will be replaced with
    the table of contents. The `@docs` block will contain the documentation for each
    of the functions included. At the bottom, the `@index` block will be replaced
    by a list of links to each of the documented functions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: That's all. In order to generate the documentation, we need to run `$ julia
    --color make.jl` from an OS Terminal, from within the `docs/` folder.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the command will show the progress of building the docs:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The generated documentation can be found at `docs/build/index.html`, and looks
    like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31055def-d852-4a81-afb9-24d2dcf03d2f.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: Registering our package
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, for the last step—making our package available to the world! For starters,
    we need to create the remote GitHub repository and push our code to it. The easiest
    way to do this is with the `hub` binary, provided by GitHub. Please follow the
    installation instructions for your platform, as described at [https://github.com/github/hub](https://github.com/github/hub).
    Once ready, we''ll need to run `hub create` in the root of the `IssueReporter`
    folder. We can do it in Julia''s REPL:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You'll be prompted for your GitHub username and password—and if all goes well,
    you'll see the output confirming that the repo was created.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Finishing touches
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we need to commit and push our changes—but before doing that, let's make
    a final change to `.gitignore` to also add `docs/build` to the list of ignored
    files. It is a bad practice to include the built docs into the GitHub commits—for
    more information about hosting documentation on GitHub, please read the official
    `Documenter` info at [https://juliadocs.github.io/Documenter.jl/latest/man/guide/#Usage-1](https://juliadocs.github.io/Documenter.jl/latest/man/guide/#Usage-1)
    and [https://juliadocs.github.io/Documenter.jl/latest/man/hosting/#Hosting-Documentation-1](https://juliadocs.github.io/Documenter.jl/latest/man/hosting/#Hosting-Documentation-1).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re at it, let''s also add a `README.md` file to the root folder of
    `IssueReporter`, to include a bit of info:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Setting up the repository
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using your favorite git client, `add`, `commit`, and `push` the code base.
    I''m going to use the Terminal:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Unleashing Julia's army of bots
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our package is looking great—it's now time to tag a release and register it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Julia contributors have developed a series of very useful GitHub integrations,
    namely, *bots*. These bots help us, humans, to automate a series of boring tasks
    so that we can focus on the really important things (mmm, pizza!).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'One of them is Attobot, a package release bot for Julia. It creates pull requests
    to Julia''s `General` registry when releases are tagged in GitHub. Try the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: To set up Attobot, open your `IssueReporter` GitHub repo and go to [https://github.com/integration/attobot](https://github.com/integration/attobot).
    Please make sure that you're logged into your GitHub account.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click Configure to select the repositories you wish to add.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Only select repositories, and then select `IssueReporter` and click Save.
    Now, Attobot is configured to monitor packages with the standard `.jl` extension—and
    publish them on the `Global` registry when new releases are tagged.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For more details about Attobot, please visit [https://github.com/attobot/attobot](https://github.com/attobot/attobot).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to go to our repo''s GitHub page and click on the releases link:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/887ff6ff-9ca3-4050-976f-2baca06e9d2f.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: 'Next, we are given the option to Create a new release:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2332f178-74bb-4118-b178-c0024c3a803a.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
- en: 'On the next screen, we''ll be able to tag our release. Julia uses semantic
    versioning (which looks like vX.Y.Z) and recommends starting with `v0.0.1`. Let''s
    do just that:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bb2f8d04-78ad-4343-9f98-0a5f327362a6.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: Then, click Publish release.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are any problems, Attobot will open issues in the repo—make sure you
    address them. Once done, the package will be registered! Victory!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is exciting to see our package finally ready!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: While developing it, we've also learned about Julia's powerful toolbox, and
    about some of the most important best practices of software development in general—TDD,
    unit testing, benchmarking, and documenting our code base and publishing the resulting documentation.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: This also concludes our journey into learning the Julia language. We've come
    a long way since opening the REPL for the first time—and you have achieved some
    impressive feats! Data analysis, plotting, web scraping, recommenders, supervised
    and unsupervised machine learning, and time series analysis and forecasting! You
    are now able to do all these things using Julia. Wow! That's quite an amazing
    track record indeed! And, if doing all this seemed easy, it's all due to Julia's
    incredible features. The productive REPL, the simple package installation, the
    handy plotting packages, or the readable syntax; they all make programming easy
    and fun.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Julia really is a new breed of programming language. As it is new, it is able
    to learn from the most successful programming languages by borrowing from their
    strengths, and avoid their mistakes. Julia was specifically designed to efficiently
    address the needs of our generation—machine learning, artificial intelligence,
    high performance, parallel, GPU, and distributed cloud computing—these are all
    areas where the language excels.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: But, not only does Julia provide efficient language constructs for writing highly
    performant code—it also makes for a productive development experience. The powerful
    REPL (one of the best REPLs in all existing programming languages, period!) and
    the JIT compilation make it easy to quickly prototype solutions, slice and dice
    large amounts of data, or experiment with data models on the fly. The integrated
    help mode and the powerful shell mode empower developers, boosting productivity.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Then there's the seamless integration with Jupyter Notebooks via IJulia—and
    the incredible cross-language integration with established programming languages
    such as Python and R. If you've used with these technologies, switching to Julia
    should be straightforward.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: But the fact that Julia is new, just reaching version 1, does not mean that
    Julia is not a mature language. It's been crafted with care and attention for
    over six years—with contributions from thousands of developers. So, I encourage
    you to start using Julia for solving real problems. You'd be joining tens of thousands
    of other developers using the language professionally, for scientific computing,
    data science, AI, fintech, web development, teaching, and much more. Household
    names such as Apple, Amazon, Facebook, and Oracle—to name just a few—were all
    looking to hire Julia programmers in 2017.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed reading this book as much as I enjoyed writing it. You are
    now prepared—and I hope eager—to use Julia in your projects. So, instead of *Goodbye*,
    I'd like to say—*Welcome to the wonderful world of Julia programming!*
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
