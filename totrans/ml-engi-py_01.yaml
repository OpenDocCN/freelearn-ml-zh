- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to ML Engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the second edition of *Machine Learning Engineering with Python*,
    a book that aims to introduce you to the exciting world of making **machine learning**
    (**ML**) systems production-ready.
  prefs: []
  type: TYPE_NORMAL
- en: In the two years since the first edition of this book was released, the world
    of ML has moved on substantially. There are now far more powerful modeling techniques
    available, more complex technology stacks, and a whole host of new frameworks
    and paradigms to keep up to date with. To help extract the signal from the noise,
    the second edition of this book covers a far larger variety of topics in more
    depth than the first edition, while still focusing on the critical tools and techniques
    you will need to build up your ML engineering expertise. This edition will cover
    the same core topics such as how to manage your ML projects, how to create your
    own high-quality Python ML packages, and how to build and deploy reusable training
    and monitoring pipelines, while adding discussion around more modern tooling.
    It will also showcase and dissect different deployment architectures in more depth
    and discuss more ways to scale your applications using AWS and cloud-agnostic
    tooling. This will all be done using a variety of the most popular and latest
    open-source packages and frameworks, from classics like **Scikit-Learn** and **Apache
    Spark** to **Kubeflow**, **Ray**,and **ZenML**. Excitingly, this edition also
    has new sections dedicated entirely to Transformers and **Large Language Models**
    (**LLMs**) like ChatGPT and GPT-4, including examples using Hugging Face and OpenAI
    APIs to fine-tune and build pipelines using these extraordinary new models. As
    in the first edition, the focus is on equipping you with the solid foundation
    you need to go far deeper into each of these components of ML engineering. The
    aim is that by the end of this book, you will be able to confidently build, scale,
    and deploy production-grade ML systems in Python using these latest tools and
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: You will get a lot from this book even if you do not run the technical examples,
    or even if you try to apply the main points in other programming languages or
    with different tools. As already mentioned, the aim is to create a solid conceptual
    foundation you can build on. In covering the key principles, the aim is that you
    come away from this book feeling more confident in tackling your own ML engineering
    challenges, whatever your chosen toolset.
  prefs: []
  type: TYPE_NORMAL
- en: In this first chapter, you will learn about the different types of data roles
    relevant to ML engineering and why they are important, how to use this knowledge
    to build and work within appropriate teams, some of the key points to remember
    when building working ML products in the real world, how to start to isolate appropriate
    problems for engineered ML solutions, and how to create your own high-level ML
    system designs for a variety of typical business problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover these topics in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a taxonomy of data disciplines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assembling your team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ML engineering in the real world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does an ML solution look like?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-level ML system design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have explained what we are going after in this first chapter, let’s
    get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout the book, all code examples will assume the use of Python 3.10.8
    unless specified otherwise. Examples in this edition have been run on a 2022 Macbook
    Pro with an M2 Apple silicon chip, with Rosetta 2 installed to allow backward
    compatibility with Intel-based applications and packages. Most examples have also
    been tested on a Linux machine running Ubuntu 22.04 LTS. The required Python packages
    for each chapter are stored in `conda` environment `.yml` files in the appropriate
    chapter folder in the book’s Git repository. We will discuss package and environment
    management in detail later in the book. But in the meantime, assuming you have
    a GitHub account and have configured your environment to be able to pull and push
    from GitHub remote repositories, to get started you can clone the book repository
    from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming you have Anaconda or Miniconda installed, you can then navigate to
    the *Chapter01* folder of the Git repository for this book and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will set up the environment you can use to run the examples given in this
    chapter. A similar procedure can be followed for each chapter, but each section
    will also call out any installation requirements specific to those examples.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have done some setup, we will start to explore the world of ML engineering
    and how it fits into a modern data ecosystem. Let’s begin our exploration of the
    world of ML engineering!
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Before running the `conda` commands given in this section you may have
    to install a specific library manually. Some versions of the Facebook Prophet
    library require versions of PyStan that can struggle to build on Macbooks running
    Apple silicon. If you run into this issue, then you should try to install the
    package `httpstan` manually. First, go to [https://github.com/stan-dev/httpstan/tags](https://github.com/stan-dev/httpstan/tags)
    and select a version of the package to install. Download the `tar.gz` or `.zip`
    of that version and extract it. Then you can navigate to the extracted folder
    and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also run into an error like the following when you call `model.fit()`
    in the later example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If this is the case you will have to run the following commands, substituting
    in the correct path for your Prophet installation location in the Conda environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Oh, the joys of doing ML on Apple silicon!
  prefs: []
  type: TYPE_NORMAL
- en: Defining a taxonomy of data disciplines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The explosion of data and the potential applications of it over the past few
    years have led to a proliferation of job roles and responsibilities. The debate
    that once raged over how a *data scientist* was different from a *statistician*
    has now become extremely complex. I would argue, however, that it does not have
    to be so complicated. The activities that have to be undertaken to get value from
    data are pretty consistent, no matter what business vertical you are in, so it
    should be reasonable to expect that the skills and roles you need to perform these
    steps will also be relatively consistent. In this chapter, we will explore some
    of the main data disciplines that I think you will always need in any data project.
    As you can guess, given the name of this book, I will be particularly keen to
    explore the notion of *ML engineering* and how this fits into the mix.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at some of the roles involved in using data in the modern landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Data scientist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the *Harvard Business Review* declared that being a data scientist was
    *The Sexiest Job of the 21st Century* ([https://hbr.org/2012/10/data-scientist-the-sexiest-job-of-the-21st-century](https://hbr.org/2012/10/data-scientist-the-sexiest-job-of-the-21st-century)),
    this job role became one of the most sought after, but also hyped, in the mix.
    Its popularity remains high, but the challenges of taking advanced analytics and
    ML into production have meant there has been more and more of a shift toward engineering
    roles within data-driven organizations. The traditional data scientist role can
    cover an entire spectrum of duties, skills, and responsibilities depending on
    the business vertical, the organization, or even just personal preference. No
    matter how this role is defined, however, there are some key areas of focus that
    should always be part of the data scientist’s job profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Analysis**: A data scientist should be able to wrangle, munge, manipulate,
    and consolidate datasets before performing calculations on the data that help
    us to understand it. *Analysis* is a broad term, but it’s clear that the end result
    is knowledge of your dataset that you didn’t have before you started, no matter
    how basic or complex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modeling**: The thing that gets everyone excited (potentially including you,
    dear reader) is the idea of modeling phenomena found in your data. A data scientist
    usually has to be able to apply statistical, mathematical, and ML techniques to
    data, in order to explain processes or relationships contained within it and to
    perform some sort of prediction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working with the customer or user**: The data scientist role usually has
    some more business-directed elements so that the results of the previous two points
    can support decision-making in an organization. This could be done by presenting
    the results of the analysis in PowerPoint presentations or Jupyter notebooks,
    or even sending an email with a summary of the key results. It involves communication
    and business acumen in a way that goes beyond classic tech roles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ML engineer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The gap between creating ML proof-of-concept and building robust software, what
    I often refer to in talks as “the chasm,” has led to the rise of what I would
    now argue is one of the most important roles in technology. The ML engineer serves
    an acute need to translate the world of data science modeling and exploration
    into the world of software products and systems engineering. Since this is no
    easy feat, the ML engineer has become increasingly sought after and is now a critical
    piece of the data-driven software value chain. If you cannot get things into production,
    you are not generating value, and if you are not generating value, well we know
    that’s not great!
  prefs: []
  type: TYPE_NORMAL
- en: You can articulate the need for this type of role quite nicely by considering
    a classic voice assistant. In this case, a data scientist would usually focus
    on translating the business requirements into a working *speech-to-text* model,
    potentially a very complex neural network, and showing that it can perform the
    desired voice transcription task *in principle*. ML engineering is then all about
    how you take that speech-to-text model and build it into a product, service, or
    tool that can be used *in production*. Here, it may mean building some software
    to train, retrain, deploy, and track the performance of the model as more transcription
    data is accumulated, or as user preferences are understood. It may also involve
    understanding how to interface with other systems and provide results from the
    model in the appropriate formats. For example, the results of the model may need
    to be packaged into a JSON object and sent via a REST API call to an online supermarket,
    in order to fulfill an order.
  prefs: []
  type: TYPE_NORMAL
- en: Data scientists and ML engineers have a lot of overlapping skillsets and competencies
    but have different areas of focus and strengths (more on this later), so they
    will usually be part of the same project team and may have either title, but it
    will be clear what hat they wear from what they do in that project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the data scientist, we can define the key areas of focus for the
    ML engineer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Translation**: Taking models and research code in a variety of formats and
    translating them into slicker, more robust pieces of code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can be done using OO programming, functional programming, a mix, or something
    else, but it basically helps to take the *proof-of-concept*work of the data scientist
    and turn it into something that is far closer to being trusted in a production
    environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Architecture**: Deployments of any piece of software do not occur in a vacuum
    and will always involve lots of integrated parts. This is true of ML solutions
    as well. The ML engineer has to understand how the appropriate tools and processes
    link together so that the models built with the data scientist can do their job
    and do it at scale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Productionization**: The ML engineer is focused on delivering a solution
    and so should understand the customer’s requirements inside out, as well as be
    able to understand what that means for the project development. The end goal of
    the ML engineer is not to provide a good model (though that is part of it), nor
    is it to provide something that *basically works*. Their job is to make sure that
    the hard work on the data science side of things generates the maximum potential
    value in a real-world setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ML operations engineer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ML engineering will be the focus of this book, but there is an important role
    now emerging with the aim of enabling ML engineers to do their work with higher
    quality, at greater pace, and at a larger scale. These are the **Machine Learning
    Operations** (**MLOps**) engineers. This role is all about building out the tools
    and capabilities that enable the tasks of the ML engineer and data scientists.
    This role focuses more on building out the tooling, platforms, and automation
    used by the other roles, and so connects them nicely. That is not to say MLOps
    engineers will not be used in specific projects or builds; it is just that their
    main value-add comes not from this but from enabling the capabilities used during
    a specific project or build. If we revisit the example of the speech-to-text solution
    described in the *ML engineer* section, we can get a flavor of this. Where the
    ML engineer will be worried about building out a solution that works seamlessly
    in production, the MLOps engineer will work hard to build out the platform or
    toolset that the ML engineer uses to do this. The ML engineer will build pipelines,
    but the MLOps engineer may build pipeline templates; the ML engineer may use **continuous
    integration/continuous deployment** (**CI/CD**) practices (more on this later),
    but the MLOps engineer will enable that capability and define the best practice
    to use CI/CD smoothly. Finally, where the ML engineer thinks “How do I solve this
    specific problem robustly using the proper tools and techniques?”, the MLOps engineer
    asks “How do I make sure that the ML engineers and data scientists will be able
    to, in general, solve the types of problems they need to, and how can I continually
    update and improve that setup?”
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did with the data scientist and ML engineer, let us define some of the
    key areas of focus for the MLOps engineer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automation**: Increasing the level of automation across the data science
    and ML engineering workflows through the use of techniques such as CI/CD and **Infrastructure-as-Code**
    (**IAC**). Pre-package software that can be deployed to allow for smoother deployments
    of solutions through these capabilities and more, such as automation scripts or
    standardized templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform engineering**: Working to integrate a series of useful services
    together in order to build out the ML platform for the different data-driven teams
    to use. This can include developing integrations across orchestration tools, compute,
    and more data-driven services until they become a holistic whole for use by ML
    engineers and data scientists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enabling key MLOps capabilities**: MLOps consists of a set of practices and
    techniques that enable the productionization of ML models by the other engineers
    in the team. Capabilities such as model management and model monitoring should
    be enabled by the MLOps engineers in a way that can be used at scale across multiple
    projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be noted that some of the topics covered in this book could be carried
    out by an MLOps engineer and that there is naturally some overlap. This should
    not concern us too much, as MLOps is based on quite a generic set of practices
    and capabilities that can be encompassed by multiple roles (see *Figure 1.1*).
  prefs: []
  type: TYPE_NORMAL
- en: Data engineer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data engineers are the people responsible for getting the commodity that
    everything else in the preceding sections is based on from A to B with high fidelity,
    appropriate latency, and as little effort on the part of the other team members
    as possible. You cannot create any type of software product, never mind an ML
    product, without data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key areas of focus for a data engineer are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quality**: Getting data from A to B is a pointless exercise if the data is
    garbled, fields are missing, or IDs are screwed up. The data engineer cares about
    avoiding this and uses a variety of techniques and tools, generally to ensure
    that the data that left the source system is what lands in your data storage layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stability**: Similar to the previous point on quality, if the data comes
    from A to B but it only arrives every second Wednesday if it’s not a rainy day,
    then what’s the point?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data engineers spend a lot of time and effort and use their considerable skills
    to ensure that data pipelines are robust, reliable, and can be trusted to deliver
    when promised.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Access**: Finally, the aim of getting data from A to B is for it to be used
    by applications, analyses, and ML models, so the nature of *B* is important. The
    data engineer will have a variety of technologies to hand to surface data and
    should work with the data consumers (our data scientists and ML engineers, among
    others) to define and create appropriate data models within these solutions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.1 – A diagram showing the relationships between data science, ML
    engineering, and data engineering ](img/B19525_01_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: A diagram showing the relationships between data science, ML engineering,
    and data engineering.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, this book focuses on the work of the ML engineer and
    how you can learn some of the skills useful for that role, but it is important
    to remember that you will not be working in a vacuum. Always keep in mind the
    profiles of the other roles (and many more not covered here that will exist in
    your project team) so that you work most effectively together. Data is a team
    sport after all!
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the key roles in a modern data team and how they cover
    the spectrum of activities required to build successful ML products, let’s look
    at how you can put them together to work efficiently and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Working as an effective team
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern software organizations, there are many different methodologies to
    organize teams and get them to work effectively together. We will cover some of
    the project management methodologies that are relevant in *Chapter 2*, *The Machine
    Learning Development Process*, but in the meantime, this section will discuss
    some important points you should consider if you are ever involved in forming
    a team, or even if you just work as part of a team, that will help you become
    an effective teammate or lead.
  prefs: []
  type: TYPE_NORMAL
- en: First, always bear in mind that *nobody can do everything*. You can find some
    very talented people out there, but do not ever think one person can do everything
    you will need to the level you require. This is not just unrealistic; it is bad
    practice and will negatively impact the quality of your products. Even when you
    are severely resource-constrained, the key is for your team members to have a
    laser-like focus to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Second, *blended is best*. We all know the benefits of diversity for organizations
    and teams in general and this should, of course, apply to your ML team as well.
    Within a project, you will need mathematics, code, engineering, project management,
    communication, and a variety of other skills to succeed. So, given the previous
    point, make sure you cover this in at least some sense across your team.
  prefs: []
  type: TYPE_NORMAL
- en: Third, *tie your team structure to your projects in a dynamic way*. If you work
    on a project that is mostly about getting the data in the right place and the
    actual ML models are really simple, focus your team profile on the engineering
    and data modeling aspects. If the project requires a detailed understanding of
    the model, and it is quite complex, then reposition your team to make sure this
    is covered. This is just sensible and frees up team members who would otherwise
    have been underutilized to work on other projects.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, suppose that you have been tasked with building a system that
    classifies customer data as it comes into your shiny new data lake, and the decision
    has been taken that this should be done at the point of ingestion via a streaming
    application. The classification has already been built for another project. It
    is already clear that this solution will heavily involve the skills of the data
    engineer and the ML engineer, but not so much the data scientist, since that portion
    of the work will have been completed in another project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at some important points to consider when
    deploying your team on a real-world business problem.
  prefs: []
  type: TYPE_NORMAL
- en: ML engineering in the real world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The majority of us who work in ML, analytics, and related disciplines do so
    for organizations with a variety of different structures and motives. These could
    be for for-profit corporations, not-for-profits, charities, or public sector organizations
    like government or universities. In pretty much all of these cases, we do not
    do this work in a vacuum and not with an infinite budget of time or resources.
    It is important, therefore, that we consider some of the important aspects of
    doing this type of work in the *real world*.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the ultimate goal of your work is to generate **value**. This
    can be calculated and defined in a variety of ways, but fundamentally your work
    has to improve something for the company or its customers in a way that justifies
    the investment put in. This is why most companies will not be happy for you to
    take a year to play with new tools and then generate nothing concrete to show
    for it, or to spend your days only reading the latest papers. Yes, these things
    are part of any job in technology, and they can definitely be super-fun, but you
    have to be strategic about how you spend your time and always be aware of your
    value proposition.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, to be a successful ML engineer in the real world, you cannot just
    understand the technology; you must understand *the business*. You will have to
    understand how the company works day to day, you will have to understand how the
    different pieces of the company fit together, and you will have to understand
    the people of the company and their roles. Most importantly, you have to understand
    *the customer*, both of the business and your work. If you do not know the motivations,
    pains, and needs of the people you build for, then how can you be expected to
    build the right thing?
  prefs: []
  type: TYPE_NORMAL
- en: Finally, and this may be controversial, the most important skill for you to
    become a successful ML engineer in the real world is one that this book will not
    teach you, and that is the ability to communicate effectively. You will have to
    work in a team, with a manager, with the wider community and business, and, of
    course, with your customers, as mentioned above. If you can do this and you know
    the technology and techniques (many of which are discussed in this book), then
    what can stop you?
  prefs: []
  type: TYPE_NORMAL
- en: 'But what kinds of problems can you solve with ML when you work in the real
    world? Well, let’s start with another potentially controversial statement: *a
    lot of the time, ML is not the answer*. This may seem strange given the title
    of this book, but it is just as important to know when *not* to apply ML as when
    to apply it. This will save you tons of expensive development time and resources.'
  prefs: []
  type: TYPE_NORMAL
- en: ML is ideal for cases when you want to do a semi-routine task faster, with more
    accuracy, or at a far larger scale than is possible with other solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some typical examples are given in the following table, along with some discussion
    as to whether or not ML would be an appropriate tool to solve the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Requirement** | **Is ML Appropriate?** | **Details** |'
  prefs: []
  type: TYPE_TB
- en: '| Anomaly detection of energy pricing signals. | Yes | You will want to do
    this on large numbers of points on potentially varying time signals. |'
  prefs: []
  type: TYPE_TB
- en: '| Improving data quality in an ERP system. | No | This sounds more like a process
    problem. You can try and apply ML to this but often it is better to make the data
    entry process more automated or the process more robust. |'
  prefs: []
  type: TYPE_TB
- en: '| Forecasting item consumption for a warehouse. | Yes | ML will be able to
    do this more accurately than a human can, so this is a good area of application.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Summarizing data for business reviews. | Maybe | This can be required at
    scale but it is not an ML problem – simple queries against your data will do.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.1: Potential use cases for ML.'
  prefs: []
  type: TYPE_NORMAL
- en: As this table of simple examples hopefully starts to make clear, the cases where
    ML *is* the answer are ones that can usually be very well framed as a mathematical
    or statistical problem. After all, this is what ML really is – a series of algorithms
    rooted in mathematics that can iterate some internal parameters based on data.
    Where the lines start to blur in the modern world are through advances in areas
    such as deep learning or reinforcement learning, where problems that we previously
    thought would be very hard to phrase appropriately for standard ML algorithms
    can now be tackled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other tendency to watch out for in the real world (to go along with *let’s
    use ML for everything*) is the worry that people have about ML coming for their
    job and that it should not be trusted. This is understandable: a report by PwC
    in 2018 suggested that 30% of UK jobs will be impacted by automation by the 2030s
    (*Will Robots Really Steal Our Jobs?*: [https://www.pwc.co.uk/economic-services/assets/international-impact-of-automation-feb-2018.pdf](https://www.pwc.co.uk/economic-services/assets/international-impact-of-automation-feb-2018.pdf)).
    What you have to try and make clear when working with your colleagues and customers
    is that what you are building is there to supplement and augment their capabilities,
    not to replace them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s conclude this section by revisiting an important point: the fact that
    you work for a company means, of course, that the aim of the game is to create
    value appropriate to the investment. In other words, you need to show a good **Return
    on Investment** (**ROI**). This means a couple of things for you practically:'
  prefs: []
  type: TYPE_NORMAL
- en: You have to understand how different designs require different levels of investment.
    If you can solve your problem by training a deep neural net on a million images
    with a GPU running 24/7 for a month, or you know you can solve the same problem
    with some basic clustering and a few statistics on some standard hardware in a
    few hours, which should you choose?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to be clear about the *value* you will generate. This means you need
    to work with experts and try to translate the results of your algorithm into actual
    dollar values. This is so much more difficult than it sounds, so you should take
    the time you need to get it right. And never, ever over-promise. *You should always
    under-promise and over-deliver*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adoption is not guaranteed. Even when building products for your colleagues
    within a company, it is important to understand that your solution will be tested
    every time someone uses it post-deployment. If you build shoddy solutions, then
    people will not use them, and the value proposition of what you have done will
    start to disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand some of the important points when using ML to solve
    business problems, let’s explore what these solutions can look like.
  prefs: []
  type: TYPE_NORMAL
- en: What does an ML solution look like?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you think of ML engineering, you would be forgiven for defaulting to imagining
    working on voice assistance and visual recognition apps (I fell into this trap
    in previous pages – did you notice?). The power of ML, however, lies in the fact
    that wherever there is data and an appropriate problem, it can help and be integral
    to the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples might help make this clearer. When you type a text message and
    your phone suggests the next words, it can very often be using a natural language
    model under the hood. When you scroll any social media feed or watch a streaming
    service, recommendation algorithms are working double time. If you take a car
    journey and an app forecasts when you are likely to arrive at your destination,
    there is going to be some kind of regression at work. Your loan application often
    results in your characteristics and application details being passed through a
    classifier. These applications are not the ones shouted about on the news (perhaps
    with the exception of when they go horribly wrong), but they are all examples
    of brilliantly put-together ML engineering.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, the examples we will work through will be more like these – typical
    scenarios for ML encountered in products and businesses every day. These are solutions
    that, if you can build them confidently, will make you an asset to any organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should start by considering the broad elements that should constitute any
    ML solution, as indicated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19525_01_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Schematic of the general components or layers of any ML solution
    and what they are responsible for.'
  prefs: []
  type: TYPE_NORMAL
- en: Your **storage layer** constitutes the endpoint of the data engineering process
    and the beginning of the ML one. It includes your data for training, your results
    from running your models, your artifacts, and important metadata. We can also
    consider this as the layer including your stored code.
  prefs: []
  type: TYPE_NORMAL
- en: The **compute layer** is where the *magic* happens and where most of the focus
    of this book will be. It is where training, testing, prediction, and transformation
    all (mostly) happen. This book is all about making this layer as well engineered
    as possible and interfacing with the other layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can break this layer down to incorporate these pieces as shown in the following
    workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – The key elements of the compute layer ](img/B19525_01_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: The key elements of the compute layer.'
  prefs: []
  type: TYPE_NORMAL
- en: IMPORTANT NOTE
  prefs: []
  type: TYPE_NORMAL
- en: The details are discussed later in the book, but this highlights the fact that
    at a fundamental level, your compute processes for any ML solution are really
    just about taking some data in and pushing some data out.
  prefs: []
  type: TYPE_NORMAL
- en: The **application layer** is where you share your ML solution’s results with
    other systems. This could be through anything from application database insertion
    to API endpoints, message queues, or visualization tools. This is the layer through
    which your customer eventually gets to use the results, so you must engineer your
    system to provide clean and understandable outputs, something we will discuss
    later.
  prefs: []
  type: TYPE_NORMAL
- en: And that is it in a nutshell. We will go into detail about all of these layers
    and points later, but for now, just remember these broad concepts and you will
    start to understand how all the detailed technical pieces fit together.
  prefs: []
  type: TYPE_NORMAL
- en: Why Python?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before moving on to more detailed topics, it is important to discuss why Python
    has been selected as the programming language for this book. Everything that follows
    that pertains to higher-level topics, such as architecture and system design,
    can be applied to solutions using any or multiple languages, but Python has been
    singled out here for a few reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Python is colloquially known as the *lingua franca* of data. It is a non-compiled,
    not strongly typed, and multi-paradigm programming language that has a clear and
    simple syntax. Its tooling ecosystem is also extensive, especially in the analytics
    and ML space.
  prefs: []
  type: TYPE_NORMAL
- en: Packages such as scikit-learn, numpy, scipy, and a host of others form the backbone
    of a huge amount of technical and scientific development across the world. Almost
    every major new software library for use in the data world has a Python API. It
    is the most popular programming language in the world, according to the **TIOBE
    index** ([https://www.tiobe.com/tiobe-index/](https://www.tiobe.com/tiobe-index/))
    at the time of writing (August 2023).
  prefs: []
  type: TYPE_NORMAL
- en: Given this, being able to build your systems using Python means you will be
    able to leverage all of the excellent ML and data science tools available in this
    ecosystem, while also ensuring that you build applications that can play nicely
    with other software.
  prefs: []
  type: TYPE_NORMAL
- en: High-level ML system design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you get down to the nuts and bolts of building your solution, there are
    so many options for tools, tech, and approaches that it can be very easy to be
    overwhelmed. However, as alluded to in the previous sections, a lot of this complexity
    can be abstracted to understand the bigger picture via some *back-of-the-envelope*
    architecture and designs. This is always a useful exercise once you know what
    problem you will try and solve, and it is something I recommend doing before you
    make any detailed choices about implementation.
  prefs: []
  type: TYPE_NORMAL
- en: To give you an idea of how this works in practice, what follows are a few worked-through
    examples where a team has to create a high-level ML systems design for some typical
    business problems. These problems are similar to ones I have encountered before
    and will likely be similar to ones you will encounter in your own work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Batch anomaly detection service'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You work for a tech-savvy taxi ride company with a fleet of thousands of cars.
    The organization wants to start making ride times more consistent and understand
    longer journeys in order to improve the customer experience and, thereby, increase
    retention and return business. Your ML team is employed to create an anomaly detection
    service to find rides that have unusual ride time or ride length behaviors. You
    all get to work, and your data scientists find that if you perform clustering
    on sets of rides using the features of ride distance and time, you can clearly
    identify outliers worth investigating by the operations team. The data scientists
    present the findings to the CTO and other stakeholders before getting the go-ahead
    to develop this into a service that will provide an outlier flag as a new field
    in one of the main tables of the company’s internal analysis tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will simulate some data to show how the taxi company’s
    data scientists could proceed. In the repository for the book, which can be found
    at [https://github.com/PacktPublishing/Machine-Learning-Engineering-with-Python-Second-Edition](https://github.com/PacktPublishing/Machine-Learning-Engineering-with-Python-Second-Edition),
    if you navigate to the folder *Chapter01*, you will see a script called `clustering_example.py`.
    If you have activated the `conda` environment provided via the `mlewp-chapter01.yml`
    environment file, then you can run this script with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After a successful run you should see that three files are created: `taxi-rides.csv`,
    `taxi-labels.json`, and `taxi-rides.png`. The image in `taxi-rides.png` should
    look something like that shown in *Figure 1.4*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will walk through how this script is built up:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s define a function that will simulate some ride distances based
    on the random distribution given in `numpy` and return a `numpy` array containing
    the results. The reason for the repeated lines is so that we can create some base
    behavior and anomalies in the data, and you can clearly compare against the speeds
    we will generate for each set of taxis in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now do the exact same thing for speeds, and again we have split the
    taxis into sets of `370`, `10`, `10`, and `10` so that we can create some data
    with “typical” behavior and some sets of anomalies, while allowing for clear matching
    of the values with the `distances` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now use both of these helper functions inside a function that will call
    them and bring them together to create a simulated dataset containing ride IDs,
    speeds, distances, and times. The result is returned as a `pandas` DataFrame for
    use in modeling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we get to the core of what data scientists produce in their projects, which
    is a simple function that wraps some `sklearn` code to return a dictionary with
    the clustering run metadata and results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We include the relevant imports here for ease:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the function in *step 4* leverages a utility function for plotting
    that is shown below:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, this is all brought together at the entry point of the program, as
    shown below:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script, once run, creates a dataset showing each simulated taxi journey
    with its clustering label in `taxi-labels.json`, as well as the simulated dataset
    in `taxi-rides.csv` and the plot showing the results of the clustering in `taxi-rides.png`,
    as shown in *Figure 1.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – An example set of results from performing clustering on some
    taxi ride data ](img/B19525_01_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: An example set of results from performing clustering on some taxi
    ride data.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic model that works, you have to start thinking about
    how to pull this into an engineered solution – how could you do it?
  prefs: []
  type: TYPE_NORMAL
- en: Well, since the solution here will support longer-running investigations by
    another team, there is no need for a very low-latency solution. The stakeholders
    agree that the insights from clustering can be delivered at the end of each day.
    Working with the data science part of the team, the ML engineers (led by you)
    understand that if clustering is run daily, this provides enough data to give
    appropriate clusters, but doing the runs any more frequently could lead to poorer
    results due to smaller amounts of data. So, a daily batch process is agreed upon.
  prefs: []
  type: TYPE_NORMAL
- en: The next question is, how do you schedule that run? Well, you will need an orchestration
    layer, which is a tool or tools that will enable you to schedule and manage pre-defined
    jobs. A tool like Apache Airflow would do exactly this.
  prefs: []
  type: TYPE_NORMAL
- en: What do you do next? Well, you know the frequency of runs is daily, but the
    volume of data is still very high, so it makes sense to leverage a distributed
    computing paradigm. Two options immediately come to mind and are skillsets that
    exist within the team, Apache Spark and Ray. To provide as much decoupling as
    possible from the underlying infrastructure and minimize the refactoring of your
    code required, you decide to use Ray. You know that the end consumer of the data
    is a table in a SQL database, so you need to work with the database team to design
    an appropriate handover of the results. Due to security and reliability concerns,
    it is not a good idea to write to the production database directly. You, therefore,
    agree that another database in the cloud will be used as an intermediate staging
    area for the data, which the main database can query against on its daily builds.
  prefs: []
  type: TYPE_NORMAL
- en: It might not seem like we have done anything technical here, but actually, you
    have already performed the high-level system design for your project. The rest
    of this book tells you how to fill in the gaps in the following diagram!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Example 1 workflow ](img/B19525_01_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Example 1 workflow.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now move on to the next example!
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: Forecasting API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, you work for the logistics arm of a large retail chain. To
    maximize the flow of goods, the company would like to help regional logistics
    planners get ahead of particularly busy periods and avoid product sell-outs. After
    discussions with stakeholders and subject matter experts across the business,
    it is agreed that the ability for planners to dynamically request and explore
    forecasts for particular warehouse items through a web-hosted dashboard is optimal.
    This allows the planners to understand likely future demand profiles before they
    make orders.
  prefs: []
  type: TYPE_NORMAL
- en: The data scientists come good again and find that the data has very predictable
    behavior at the level of any individual store. They decide to use the Facebook
    Prophet library for their modeling to help speed up the process of training many
    different models. In the following example we will show how they could do this,
    but we will not spend time optimizing the model to create the best predictive
    performance, as this is just for illustration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example will use the Kaggle API in order to retrieve an exemplar dataset
    for sales in a series of different retail stores. In the book repository under
    *Chapter01/forecasting* there is a script called `forecasting_example.py`. If
    you have your Python environment configured appropriately you can run this example
    with the following command at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The script downloads the dataset, transforms it, and uses it to train a Prophet
    forecasting model, before running a prediction on a test set and saving a plot.
    As mentioned, this is for illustration purposes only and so does not create a
    validation set or perform any more complex hyperparameter tuning than the defaults
    provided by the Prophet library.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you see how this example is pieced together, we will now break down
    the different components of the script. Any functionality that is purely for plotting
    or logging is excluded here for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the main block of the script, we can see that the first steps
    all concern reading in the dataset if it is already in the correct directory,
    or downloading and then reading it in otherwise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function that performed the download used the Kaggle API and is given below;
    you can refer to the Kaggle API documentation to ensure this is set up correctly
    (which requires a Kaggle account):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the script calls a function to transform the dataset called `prep_store_data`.
    This is called with two default values, one for a store ID and the other specifying
    that we only want to see data for when the store was open. The definition of this
    function is given below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Prophet forecasting model is then trained on the first 80% of the data
    and makes a prediction on the remaining 20% of the data. Seasonality parameters
    are provided to the model in order to guide its optimization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The definition of the `train_predict` method is given below, and you can see
    that it wraps some further data prep and the main calls to the Prophet package:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, finally, a utility plotting function is called, which when run will create
    the output shown in *Figure 1.6*. This shows a zoomed-in view of the prediction
    on the test dataset. The details of this function are not given here for brevity,
    as discussed above:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/B19525_01_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Forecasting store sales.'
  prefs: []
  type: TYPE_NORMAL
- en: One issue here is that implementing a forecasting model like the one above for
    every store can quickly lead to hundreds or even thousands of models if the chain
    gathers enough data. Another issue is that not all stores are on the resource
    planning system used at the company yet, so some planners would like to retrieve
    forecasts for other stores they know are similar to their own. It is agreed that
    if users like this can explore regional profiles they believe are similar to their
    own data, then they can still make the optimal decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Given this and the customer requirements for dynamic, ad hoc requests, you quickly
    rule out a full batch process. This wouldn’t cover the use case for regions not
    on the core system and wouldn’t allow for dynamic retrieval of up-to-date forecasts
    via the website, which would allow you to deploy models that forecast at a variety
    of time horizons in the future. It also means you could save on compute as you
    don’t need to manage the storage and updating of thousands of forecasts every
    day and your resources can be focused on model training.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you decide that, actually, a web-hosted API with an endpoint that
    can return forecasts as needed by the user makes the most sense. To give efficient
    responses, you have to consider what happens in a typical user session. By workshopping
    with the potential users of the dashboard, you quickly realize that although the
    requests are dynamic, most planners will focus on particular items of interest
    in any one session. They will also not look at many regions. You then decide that
    it makes sense to have a caching strategy, where you take certain requests that
    you think might be common and cache them for reuse in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that after the user makes their first selections, results can be
    returned more quickly for a better user experience. This leads to the rough system
    sketch in *Figure 1.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Example 2 workflow ](img/B19525_01_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: Example 2 workflow.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at the final example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3: Classification pipeline'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this final example, you work for a web-based company that wants to classify
    users based on their usage patterns as targets for different types of advertising,
    in order to more effectively target marketing spend. For example, if the user
    uses the site less frequently, we may want to entice them with more aggressive
    discounts. One of the key requirements from the business is that the end results
    become part of the data landed in a data store used by other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Based on these requirements, your team determines that a pipeline running a
    classification model is the simplest solution that ticks all the boxes. The data
    engineers focus their efforts on building the ingestion and data store infrastructure,
    while the ML engineer works to wrap up the classification model the data science
    team has trained on historical data. The base algorithm that the data scientists
    settle on is implemented in `sklearn`, which we will work through below by applying
    it to a marketing dataset that would be similar to that produced in this use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'This hypothetical example aligns with a lot of classic datasets, including
    the Bank Marketing dataset from the UCI ML repository: [https://archive.ics.uci.edu/ml/datasets/Bank+Marketing#](https://archive.ics.uci.edu/ml/datasets/Bank+Marketing#).
    As in the previous example, there is a script you can run from the command line,
    this time in the *Chapter01/classifying* folder and called `classify_example.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this script will read in the downloaded bank data, rebalance the training
    dataset, and then execute a hyperparameter optimization run on a randomized grid
    search for a random forest classifier. Similarly to before, we will show how these
    pieces work to give a flavor of how a data science team might have approached
    this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main block of the script contains all the relevant steps, which are neatly
    wrapped up into methods we will dissect over the next few steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ingest_and_prep_data` function is given below, and it does assume that
    the `bank.csv` data is stored in a directory called `bank_data` in the current
    folder. It reads the data into a `pandas` DataFrame, before performing a train-test
    split on the data and one-hot encoding the training features, before returning
    all the train and test features and targets. As in the other examples, most of
    these concepts and tools will be explained throughout the book, particularly in
    *Chapter 3*, *From Model to Model Factory*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because the data is imbalanced, we need to rebalance the training data with
    an oversampling technique. In this example, we will use the **Synthetic Minority
    Over-Sampling Technique** (**SMOTE**) from the `imblearn` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will move on to the main ML components of the script. We will perform
    a hyperparameter search (there’ll be more on this in *Chapter 3*, *From Model
    to Model Factory*), so we have to define a grid to search over:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then finally, this grid of hyperparameters will be used in the definition of
    a `RandomisedSearchCV` object that allows us to optimize an estimator (here, a
    `RandomForestClassifier`) over the hyperparameter values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The example above highlights the basic components of creating a typical classification
    model, but the question we have to ask ourselves as engineers is, “Then what?”
    It is clear that we have to actually run predictions with the model that has been
    produced, so we’ll need to persist it somewhere and read it in later. This is
    similar to the other use cases discussed in this chapter. Where things are more
    challenging here is that in this case, the engineers may actually consider not
    running in a batch or request-response scenario but in a streaming context. This
    means we will have to consider new technologies like **Apache Kafka** that enable
    you to both publish and subscribe to “topics” where packets of data called “events”
    can be shared. Not only that, but we will also have to make decisions about how
    to interact with data in this way using an ML model, raising questions about the
    appropriate model hosting mechanism. There will also be some subtleties around
    how often you want to retrain your algorithm to make sure that the classifier
    does not go stale. This is before we consider questions of latency or of monitoring
    the model’s performance in this very different setting. As you can see, this means
    that the ML engineer’s job here is quite a complex one. *Figure 1.8* subsumes
    all this complexity into a very high-level diagram that would allow you to start
    considering the sort of system interactions you would need to build if you were
    the engineer on this project.
  prefs: []
  type: TYPE_NORMAL
- en: We will not cover streaming in that much detail in this book, but we will cover
    all of the other key components that would help you build out this example into
    a real solution in a lot of detail. For more details on streaming ML applications
    please see the book *Machine Learning for Streaming Data with Python* by Joose
    Korstanje, Packt, 2022.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Example 3 workflow ](img/B19525_01_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: Example 3 workflow.'
  prefs: []
  type: TYPE_NORMAL
- en: We have now explored three high-level ML system designs and discussed the rationale
    behind our workflow choices. We have also explored in detail the sort of code
    that would often be produced by data scientists working on modeling, but which
    would act as input to future ML engineering work. This section should, therefore,
    have given us an appreciation of where our engineering work begins in a typical
    project and what types of problems we aim to solve. And there you go. You are
    already on your way to becoming an ML engineer!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the idea of ML engineering and how that fits
    within a modern team building valuable solutions based on data. There was a discussion
    of how the focus of ML engineering is complementary to the strengths of data science
    and data engineering and where these disciplines overlap. Some comments were made
    about how to use this information to assemble an appropriately resourced team
    for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: The challenges of building ML products in modern real-world organizations were
    then discussed, along with pointers to help you overcome some of these challenges.
    In particular, the notions of reasonably estimating value and effectively communicating
    with your stakeholders were emphasized.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter then rounded off with a taster of the technical content to come
    in later chapters, through a discussion of what typical ML solutions look like
    and how they should be designed (at a high level) for some common use cases.
  prefs: []
  type: TYPE_NORMAL
- en: These topics are important to cover before we dive deeper into the rest of the
    book, as they will help you to understand why ML engineering is such a critical
    discipline and how it ties into the complex ecosystem of data-focused teams and
    organizations. It also helps to give a taster of the complex challenges that ML
    engineering encompasses, while giving you some of the conceptual tools to start
    reasoning about those challenges. My hope is that this not only motivates you
    to engage with the material in the rest of this edition, but it also sets you
    down the path of exploration and self-study that will be required to have a successful
    career as an ML engineer.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will focus on how to set up and implement your development
    processes to build the ML solutions you want, providing some insight into how
    this is different from standard software development processes. Then there will
    be a discussion of some of the tools you can use to start managing the tasks and
    artifacts from your projects without creating major headaches. This will set you
    up for the technical details of how to build the key elements of your ML solutions
    in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/mle](https://packt.link/mle)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code102810325355484.png)'
  prefs: []
  type: TYPE_IMG
