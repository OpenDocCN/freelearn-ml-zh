["```py\n    // Read input image \n    cv::Mat image= cv::imread(\"binary.bmp\"); \n\n    // Erode the image \n    // with the default 3x3 structuring element (SE) \n    cv::Mat eroded;  // the destination image \n    cv::erode(image,eroded,cv::Mat()); \n\n    // Dilate the image \n    cv::Mat dilated;  // the destination image \n    cv::dilate(image,dilated,cv::Mat()); \n\n```", "```py\n    // Erode the image with a larger SE \n    // create a 7x7 mat with containing all 1s \n    cv::Mat element(7,7,CV_8U,cv::Scalar(1)); \n    // erode the image with that SE \n    cv::erode(image,eroded,element); \n\n```", "```py\n    // Erode the image 3 times \n    cv::erode(image,eroded,cv::Mat(),cv::Point(-1,-1), 3); \n\n```", "```py\n    cv::erode(image,image,cv::Mat()); \n\n```", "```py\n    // Close the image \n    cv::Mat element5(5,5,CV_8U,cv::Scalar(1)); \n    cv::Mat closed; \n    cv::morphologyEx(image,closed,    // input and output images \n                     cv::MORPH_CLOSE, // operator code \n                     element5);       // structuring element \n\n```", "```py\n    cv::Mat opened; \n    cv::morphologyEx(image, opened, cv::MORPH_OPEN, element5); \n\n```", "```py\n    // dilate original image \n    cv::dilate(image, result, cv::Mat()); \n    // in-place erosion of the dilated image \n    cv::erode(result, result, cv::Mat()); \n\n```", "```py\n    // Get the gradient image using a 3x3 structuring element \n    cv::Mat result; \n    cv::morphologyEx(image, result,\n                     cv::MORPH_GRADIENT, cv::Mat()); \n\n```", "```py\n    // Apply the black top-hat transform using a 7x7 structuring element \n    cv::Mat element7(7, 7, CV_8U, cv::Scalar(1)); \n    cv::morphologyEx(image, result, cv::MORPH_BLACKHAT, element7); \n\n```", "```py\n    class WatershedSegmenter { \n\n      private: \n      cv::Mat markers; \n\n      public: \n      void setMarkers(const cv::Mat& markerImage) { \n\n      // Convert to image of ints \n      markerImage.convertTo(markers,CV_32S); \n    } \n\n    cv::Mat process(const cv::Mat &image) { \n\n      // Apply watershed \n      cv::watershed(image,markers); \n      return markers; \n    } \n\n```", "```py\n    // Eliminate noise and smaller objects \n    cv::Mat fg; \n    cv::erode(binary,fg,cv::Mat(),cv::Point(-1,-1),4); \n\n```", "```py\n    // Identify image pixels without objects \n    cv::Mat bg; \n    cv::dilate(binary,bg,cv::Mat(),cv::Point(-1,-1),4); \n    cv::threshold(bg,bg,1,128,cv::THRESH_BINARY_INV); \n\n```", "```py\n    // Create markers image \n    cv::Mat markers(binary.size(),CV_8U,cv::Scalar(0)); \n    markers= fg+bg; \n\n```", "```py\n    // Create watershed segmentation object \n    WatershedSegmenter segmenter; \n\n    // Set markers and process \n    segmenter.setMarkers(markers); \n    segmenter.process(image); \n\n```", "```py\n    // Return result in the form of an image \n    cv::Mat getSegmentation() { \n\n      cv::Mat tmp; \n      // all segment with label higher than 255 \n      // will be assigned value 255 \n      markers.convertTo(tmp,CV_8U); \n\n      return tmp; \n    } \n\n```", "```py\n    // Return watershed in the form of an image \n    cv::Mat getWatersheds() { \n\n      cv::Mat tmp; \n      // Each pixel p is transformed into \n      // 255p+255 before conversion \n      markers.convertTo(tmp,CV_8U,255,255); \n\n      return tmp; \n    } \n\n```", "```py\n    // Identify background pixels \n    cv::Mat imageMask(image.size(),CV_8U,cv::Scalar(0)); \n    cv::rectangle(imageMask, cv::Point(5,5),  \n                  cv::Point(image.cols-5, image.rows-5),   \n                  cv::Scalar(255), 3); \n    // Identify foreground pixels \n    // (in the middle of the image) \n    cv::rectangle(imageMask,\n                  cv::Point(image.cols/2-10,image.rows/2-10),\n                  cv::Point(image.cols/2+10,image.rows/2+10),\n                  cv::Scalar(1), 10); \n\n```", "```py\n    // basic MSER detector \n    cv::Ptr<cv::MSER> ptrMSER=  \n     cv::MSER::create(5,     // delta value for local detection \n                      200,   // min acceptable area \n                      2000); // max acceptable area \n\n```", "```py\n    // vector of point sets \n    std::vector<std::vector<cv::Point> > points; \n    // vector of rectangles \n    std::vector<cv::Rect> rects; \n    // detect MSER features \n    ptrMSER->detectRegions(image, points, rects); \n\n```", "```py\n    // create white image \n    cv::Mat output(image.size(),CV_8UC3); \n    output= cv::Scalar(255,255,255); \n\n    // OpenCV random number generator \n    cv::RNG rng; \n\n    // Display the MSERs in color areas \n    // for each detected feature \n    // reverse order to display the larger MSER first \n    for (std::vector<std::vector<cv::Point> >::reverse_iterator  \n             it= points.rbegin(); \n             it!= points.rend(); ++it) { \n\n        // generate a random color \n        cv::Vec3b c(rng.uniform(0,254),  \n                    rng.uniform(0,254), rng.uniform(0,254)); \n\n        // for each point in MSER set \n        for (std::vector<cv::Point>::iterator itPts= it->begin(); \n                    itPts!= it->end(); ++itPts) { \n\n          // do not overwrite MSER pixels \n          if (output.at<cv::Vec3b>(*itPts)[0]==255) { \n            output.at<cv::Vec3b>(*itPts)= c; \n          } \n        } \n      } \n\n```", "```py\n    // Extract and display the rectangular MSERs \n    std::vector<cv::Rect>::iterator itr = rects.begin(); \n    std::vector<std::vector<cv::Point> >::iterator itp = points.begin(); \n    for (; itr != rects.end(); ++itr, ++itp) { \n      // ratio test \n      if (static_cast<double>(itp->size())/itr->area() > 0.6) \n        cv::rectangle(image, *itr, cv::Scalar(255), 2); \n    } \n\n```", "```py\n    // Extract and display the elliptic MSERs \n    for (std::vector<std::vector<cv::Point> >::iterator  \n              it = points.begin(); \n              it != points.end(); ++it) { \n       // for each point in MSER set \n       for (std::vector<cv::Point>::iterator itPts = it->begin(); \n              itPts != it->end(); ++itPts) { \n\n           // Extract bouding rectangles \n          cv::RotatedRect rr = cv::minAreaRect(*it); \n          // check ellipse elongation \n          if (rr.size.height / rr.size.height > 0.6 ||  \n              rr.size.height / rr.size.height < 1.6) \n              cv::ellipse(image, rr, cv::Scalar(255), 2); \n      } \n    }   \n\n```"]