- en: 'Chapter 6: Social Network Graphs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The growth of social networking sites has been one of the most active trends
    in digital media over the years. Since the late 1990s, when the first social applications
    were published, they have attracted billions of active users worldwide, many of
    whom have integrated digital social interactions into their daily lives. New ways
    of communication are being driven by social networks such as Facebook, Twitter,
    and Instagram, among others. Users can share ideas, post updates and feedback,
    or engage in activities and events while sharing their broader interests on social
    networking sites.
  prefs: []
  type: TYPE_NORMAL
- en: Besides, social networks constitute a huge source of information for studying
    user behaviors, interpreting interaction among people, and predicting their interests.
    Structuring them as graphs, where a vertex corresponds to a person and an edge
    represents the connection between them, enables a powerful tool to extract useful
    knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: However, understanding the dynamics that drive the evolution of a social network
    is a complex problem due to a large number of variable parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk about how we can analyze the Facebook social network
    using graph theory and how we can solve useful problems such as link prediction
    and community detection using machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network topology and community detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding for supervised and unsupervised tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using *Jupyter* notebooks with *Python* 3.8 for all of our exercises.
    The following is a list of the Python libraries that need to be installed for
    this chapter using `pip`. For example, run `pip install networkx==2.5` on the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the rest of this chapter, if not clearly stated, we will refer to `nx`,
    `pd`, and `np` as results of the following Python commands: `import networkx`
    as `nx`, `import pandas` as `pd`, and `import numpy` as `np`.'
  prefs: []
  type: TYPE_NORMAL
- en: All code files relevant to this chapter are available at [https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter06](https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using the **Social circles SNAP Facebook public dataset**, from Stanford
    University ([https://snap.stanford.edu/data/ego-Facebook.html](https://snap.stanford.edu/data/ego-Facebook.html)).
  prefs: []
  type: TYPE_NORMAL
- en: The dataset was created by collecting Facebook user information from survey
    participants. Ego networks were created from 10 users. Each user was asked to
    identify all the **circles** (list of friends) to which their friends belong.
    On average, each user identified 19 circles in their **ego networks**, where each
    circle has on average 22 friends.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each user, the following information was collected:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Edges**: An edge exists if two users are friends on Facebook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` if the user has this property in their profile and `0` otherwise. Features
    have been anonymized since the names of the features would reveal private data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 10 ego networks were then unified in a single graph that we are going to
    study.
  prefs: []
  type: TYPE_NORMAL
- en: Dataset download
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dataset can be retrieved using the following URL: [https://snap.stanford.edu/data/ego-Facebook.html](https://snap.stanford.edu/data/ego-Facebook.html).
    In particular, three files can be downloaded: `facebook.tar.gz`, `facebook_combined.txt.gz`,
    and `readme-Ego.txt`. Let''s inspect each file separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '`facebook.tar.gz`: This is an archive containing four files for each `nodeId.extension`
    where `nodeId` is the node ID of the ego user and `extension` is either `edges`,
    `circles`, `feat`, `egofeat`, or `featnames`. The following provides more details:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a. `nodeId.edges`: This contains a list of edges for the network of the `nodeId`
    node.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b. `nodeId.circles`: This contains several lines (one for each circle). Each
    line consists of a name (the circle name) followed by a series of node IDs.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'c. `nodeId.feat`: This contains the features (`0` if `nodeId` has the feature,
    `1` otherwise) for each node in the ego network.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'd. `nodeId.egofeat`: This contains the features for the ego user.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'e. `nodeId.featname`: This contains the names of the features.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`facebook_combined.txt.gz`: This is an archive containing a single file, `facebook_combined.txt`,
    which is a list of edges from all the ego networks combined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readme-Ego.txt`: This contains a description for the previously mentioned
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at those files by yourself. It is strongly suggested to explore
    and become as comfortable as possible with the dataset before starting any machine
    learning task.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the dataset using networkx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step of our analysis will be loading the aggregated ego networks using
    `networkx`. As we have seen in previous chapters, `networkx` is powerful for graph
    analysis and, given the size of the datasets, will be the perfect tool for the
    analysis that we will be doing in this chapter. However, for larger social network
    graphs with billions of nodes and edges, more specific tools might be required
    for loading and processing them. We will cover the tools and technologies used
    for scaling out the analysis in[*Chapter 9*](B16069_09_Final_JM_ePub.xhtml#_idTextAnchor141),
    *Building a Data-Driven Graph-Powered Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen, the combined ego network is represented as a list of edges.
    We can create an undirected graph from a list of edges using `networkx` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s print some basic information about the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the aggregated network contains `4039` nodes and `88234` edges.
    This is a fairly connected network with a number of edges more than 20 times the
    number of nodes. Indeed, several clusters should be present in the aggregated
    networks (likely the small worlds of each ego user).
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing the network will also help in better understanding what we are going
    to analyze. We can draw the graph using `networkx` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The aggregated Facebook ego network'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_06_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – The aggregated Facebook ego network
  prefs: []
  type: TYPE_NORMAL
- en: We can observe the presence of highly interconnected hubs. This is interesting
    from a social network analysis point of view since they might be the result of
    underlying social mechanisms that can be further investigated for better understanding
    the structure of an individual's relationships with respect to their world.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing our analysis, let's save the IDs of the ego user nodes inside
    the network. We can retrieve them from the files contained in the `facebook.tar.gz`
    archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, unpack the archive. The extracted folder will be named `facebook`. Let''s
    run the following Python code for retrieving the IDs by taking the first part
    of each filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready for analyzing the graph. In particular, in the next section,
    we will better understand the structure of the graph by inspecting its properties.
    This will help us to have a clearer idea of its topology and its relevant characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Network topology and community detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the topology of the network as well as the role of its nodes is
    a crucial step in the analysis of a social network. It is important to keep in
    mind that, in this context, nodes are actually users, each with their own interests,
    habits, and behaviors. Such knowledge will be extremely useful when performing
    predictions and/or finding insights.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using `networkx` to compute most of the useful metrics we have seen
    in [*Chapter 1*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014), *Getting Started
    with Graphs*. We will try to give them an interpretation to collect insight into
    the graph. Let''s begin as usual, by importing the required libraries and defining
    some variables that we will use throughout the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can now proceed to the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Topology overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have already seen before, our combined network has 4,039 nodes and more
    than 80,000 edges. The next metric we will compute is assortativity. It will reveal
    information about the tendency of users to be connected with users with a similar
    degree. We can do that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we can observe a positive assortativity, likely showing that well-connected
    individuals associate with other well-connected individuals (as we have seen in
    [*Chapter 1*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014), *Getting Started
    with Graphs*). This is expected since inside each circle users might tend to be
    highly connected to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transitivity could also help at better understanding how individuals are connected.
    Recall transitivity indicates the mean probability that two people with a common
    friend are themselves friends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here we have the probability of around 50% that two friends can or cannot have
    common friends.
  prefs: []
  type: TYPE_NORMAL
- en: 'The observation is also confirmed by computing the average clustering coefficient.
    Indeed, it can be considered as an alternative definition of transitivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the clustering coefficient tends to be higher than transitivity.
    Indeed, by definition, it puts more weight on vertices with a low degree, since
    they have a limited number of possible pairs of neighbors (the denominator of
    the local clustering coefficient).
  prefs: []
  type: TYPE_NORMAL
- en: Node centrality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have a clearer idea of what the overall topology looks like, we can
    proceed by investigating the importance of each individual inside the network.
    As we have seen in [*Chapter 1*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014),
    *Getting Started with Graphs*, the first definition of importance can be given
    by means of the betweenness centrality metric. It measures how many shortest paths
    pass through a given node, giving an idea of how *central* that node is for the
    spreading of information inside the network. We can compute it using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The average betweenness centrality is pretty low, which is understandable given
    the large amount of non-bridging nodes inside the network. However, we could collect
    better insight by visual inspection of the graph. In particular, we will draw
    the combined ego network by enhancing nodes with the highest betweenness centrality.
    Let''s define a proper function for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s invoke it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Betweenness centrality'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_06_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Betweenness centrality
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also inspect the degree centrality of each node. Since this metric is
    related to the number of neighbors of a node, we will have a clearer idea of how
    well the nodes are connected to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a representation of the degree centrality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Degree centrality'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_06_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Degree centrality
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s also have a look at the closeness centrality. This will help
    us understand how close nodes are to each other in terms of the shortest path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a representation of the closeness centrality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Closeness centrality'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_06_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Closeness centrality
  prefs: []
  type: TYPE_NORMAL
- en: From the centrality analysis, it is interesting to observe that each central
    node seems to be part of a sort of community (this is reasonable, since the central
    nodes might correspond to the ego nodes of the network). It is also interesting
    to notice the presence of a bunch of highly interconnected nodes (especially from
    the closeness centrality analysis). Let's thus identify these communities in the
    next part of our analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Community detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we are performing social network analysis, it is worth exploring one
    of the most interesting graph structures for social networks: communities. If
    you use Facebook, it is very likely that your friends reflect different aspects
    of your life: friends from an educational environment (high school, college, and
    so on), friends from your weekly football match, friends you have met at parties,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: An interesting aspect of social network analysis is to automatically identify
    such groups. This can be done automatically, inferring them from topological properties,
    or semi-automatically, exploiting some prior insight.
  prefs: []
  type: TYPE_NORMAL
- en: One good criterion is to try to minimize intra-community edges (edges connecting
    members of different communities) while maximizing inter-community edges (connecting
    members within the same community).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do that in `networkx` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Detected communities using networkx'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_06_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Detected communities using networkx
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, it is also interesting to investigate whether the ego users
    occupy some roles inside the detected communities. Let''s enhance the size and
    color of the ego user nodes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Detected communities using networkx with the ego users node
    size enhanced'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_06_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – Detected communities using networkx with the ego users node size
    enhanced
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to notice that some ego users belong to the same community.
    It is possible that ego users are actual friends on Facebook, and therefore their
    ego networks are partially shared.
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed our basic understanding of the graph structure. We now
    know that some important nodes can be identified inside the network. We have also
    seen the presence of well-defined communities to which those nodes belong. Keep
    in mind these observations while performing the next part of the analysis, which
    is applying machine learning methods for supervised and unsupervised tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding for supervised and unsupervised tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Social media represents, nowadays, one of the most interesting and rich sources
    of information. Every day, thousands of new connections arise, new users join
    communities, and billions of posts are shared. Graphs mathematically represent
    all those interactions, helping to make order of all such spontaneous and unstructured
    traffic.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with social graphs, there are many interesting problems that can
    be addressed using machine learning. Under the correct settings, it is possible
    to extract useful insights from this huge amount of data, for improving your marketing
    strategy, identifying users with dangerous behaviors (for example, terrorist networks),
    and predicting the likelihood that a user will read your new post.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, link prediction is one of the most interesting and important research
    topics in this field. Depending on what a *connection* in your social graph represents,
    by predicting future edges, you will be able to predict your next suggested friend,
    the next suggested movie, and which product you are likely to buy.
  prefs: []
  type: TYPE_NORMAL
- en: As we have already seen in [*Chapter 5*](B16069_05_Final_JM_ePub.xhtml#_idTextAnchor079),
    *Problems with Machine Learning on Graphs*, the link prediction task aims at forecasting
    the likelihood of a future connection between two nodes and it can be solved using
    several machine learning algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In the next examples, we will be applying supervised and unsupervised machine
    learning graph embedding algorithms for predicting future connections on the SNAP
    Facebook social graph. Furthermore, we will evaluate the contribution of node
    features in the prediction task.
  prefs: []
  type: TYPE_NORMAL
- en: Task preparation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform the link prediction task, it is necessary to prepare our
    dataset. The problem will be treated as a supervised task. Pairs of nodes will
    be provided to each algorithm as input, while the target will be binary, that
    is, *connected* if the two nodes are actually connected in the network, and *not
    connected* otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Since we aim to cast this problem as a supervised learning task, we need to
    create a training and testing dataset. We will therefore create two new subgraphs
    with the same numbers of nodes but different numbers of edges (as some edges will
    be removed and treated as positive samples for training/testing the algorithm).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `stellargraph` library provides a useful tool for splitting the data and
    creating training and test reduced subgraphs. This process is similar to the one
    we have already seen in [*Chapter 5*](B16069_05_Final_JM_ePub.xhtml#_idTextAnchor079),
    *Problems with Machine Learning on Graphs*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `EdgeSplitter` class to extract a fraction (`p`=10%) of all
    the edges in `G`, as well as the same number of negative edges, in order to obtain
    a reduced graph, `graph_test`. The `train_test_split` method also returns a list
    of node pairs, `samples_test` (where each pair corresponds to an existing or not
    existing edge in the graph), and a list of binary targets (`labels_test`) of the
    same length of the `samples_test` list. Then, from such a reduced graph, we are
    repeating the operation to obtain another reduced graph, `graph_train`, as well
    as the corresponding `samples_train` and `labels_train` lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be comparing three different methods for predicting missing edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method 1**: node2vec will be used to learn a node embedding without supervision.
    The learned embedding will be used as input for a supervised classification algorithm
    to determine whether the input pair is actually connected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method 2**: The graph neural network-based algorithm GraphSAGE will be used
    to jointly learn the embedding and perform the classification task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method 3**: Hand-crafted features will be extracted from the graph and used
    as inputs for a supervised classifier, together with the nodes'' IDs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's analyze them in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: node2vec-based link prediction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The herein proposed method is carried out in several steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use node2vec to generate node embeddings without supervision from the training
    graph. This can be done using the `node2vec` Python implementation, as we have
    already seen in [*Chapter 5*](B16069_05_Final_JM_ePub.xhtml#_idTextAnchor079)*,*
    *Problems with Machine Learning on Graphs*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we use `HadamardEmbedder` for generating an embedding for each pair of
    embedded nodes. Such feature vectors will be used as input to train the classifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It''s time for training our supervised classifier. We will be using the RandomForest
    classifier, a powerful decision tree-based ensemble algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s apply the trained model for creating the embedding of the test
    set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we are ready to perform the prediction on the test set using our trained
    model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Not bad at all! We can observe that the node2vec-based embedding already provides
    a powerful representation for actually predicting links on the combined Facebook
    ego network.
  prefs: []
  type: TYPE_NORMAL
- en: GraphSAGE-based link prediction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we will use GraphSAGE for learning node embeddings and classifying edges.
    We will build a two-layer GraphSAGE architecture that, given labeled pairs of
    nodes, outputs a pair of node embeddings. Then, a fully connected neural network
    will be used to process these embeddings and produce link predictions. Notice
    that the GraphSAGE model and the fully connected network will be concatenated
    and trained end to end so that the embeddings learning stage is influenced by
    the predictions.
  prefs: []
  type: TYPE_NORMAL
- en: Featureless approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before starting, we may recall from *Chapters 4, Supervised Graph Learning*,
    and [*Chapter 5*](B16069_05_Final_JM_ePub.xhtml#_idTextAnchor079), *Problems with
    Machine Learning on Graphs*, that GraphSAGE needs node descriptors (features).
    Such features may or may not be available in your dataset. Let's begin our analysis
    by not considering available node features. In this case, a common approach is
    to assign to each node a one-hot feature vector of length |*V*| (the number of
    nodes in the graph), where only the cell corresponding to the given node is 1,
    while the remaining cells are 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done in Python and `networkx` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We created an identity matrix of size |*V*|. Each row of the matrix is the one-hot
    vector we need for each node in the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we created a Python dictionary where, for each `nodeID` (used as the key),
    we assign the corresponding row of the previously created identity matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the dictionary was passed to the `networkx` `set_node_attributes` function
    to assign the "fake" features to each node in the `networkx` graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the process is repeated for both the training and test graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step will be defining the generator that will be used to feed the
    model. We will be using the `stellargraph` `GraphSAGELinkGenerator` for this,
    which essentially provides the model with pairs of nodes as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that we also need to define `batch_size` (number of inputs per minibatch)
    and the number of first- and second-hop neighbor samples that GraphSAGE should
    consider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are ready to create the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we are creating a GraphSAGE model with two hidden
    layers of size 20, each with a bias term and a dropout layer for reducing overfitting.
    Then, the output of the GraphSAGE part of the module is concatenated with a `link_classification`
    layer that takes pairs of node embeddings (output of GraphSAGE), uses binary operators
    (inner product; `ip` in our case) to produce edge embeddings, and finally passes
    them through a fully connected neural network for classification.
  prefs: []
  type: TYPE_NORMAL
- en: The model is optimized via the Adam optimizer (learning rate = `1e-3`) using
    the mean squared error as a loss function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s train the model for 10 epochs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once trained, let''s compute the performance metrics over the test set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As we can observe, performances are lower than the ones obtained in the node2vec-based
    approach. However, we are not considering real node features yet, which could
    represent a great source of information. Let's do that in the following test.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing node features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The process of extracting node features for the combined ego network is quite
    verbose. This is because, as we have explained in the first part of the chapter,
    each ego network is described using several files, as well as all the feature
    names and values. We have written useful functions for parsing all the ego network
    in order to extract the node features. You can find their implementation in the
    Python notebook provided in the GitHub repository. Here, let''s just briefly summarize
    how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `load_features` function parses each ego network and creates two dictionaries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a. `feature_index`, which maps numeric indices to feature names
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. `inverted_feature_indexes`, which maps names to numeric indices
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `parse_nodes` function receives the combined ego network `G` and the ego
    nodes' IDs. Then, each ego node in the network is assigned with the corresponding
    features previously loaded using the `load_features` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s invoke them in order to load a feature vector for each node in the combined
    ego network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily check the result by printing the information of one node in the
    network (for example, the node with ID `0`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As we can observe, the node has a dictionary containing a key named `features`.
    The corresponding value is the feature vector assigned to this node.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to repeat the same steps used before for training the GraphSAGE
    model, this time using `features` as the key when converting the `networkx` graph
    to the `StellarGraph` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, as we have done before, we create the generators, compile the model,
    and train it for 10 epochs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are using the same hyperparameters (including the number of layers,
    batch size, and learning rate) as well as the random seed, to ensure a fair comparison
    between the models.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s evaluate the model performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the introduction of real node features has brought a good improvement,
    even if the best performances are still the ones achieved using the node2vec approach.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will evaluate a shallow embedding approach where hand-crafted features
    will be used for training a supervised classifier.
  prefs: []
  type: TYPE_NORMAL
- en: Hand-crafted features for link prediction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have already seen in [*Chapter 4*](B16069_04_Final_JM_ePub.xhtml#_idTextAnchor064),
    *Supervised Graph Learning*, shallow embedding methods represent a simple yet
    powerful approach for dealing with supervised tasks. Basically, for each input
    edge, we will compute a set of metrics that will be given as input to a classifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, for each input edge represented as a pair of nodes (*u*,*v*),
    four metrics will be considered, namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0` will be used if *u* is not reachable from *v*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Jaccard coefficient**: Given a pair of nodes (*u*,*v*), it is defined
    as the intersection over a union of the set of neighbors of *u* and *v*. Formally,
    let ![](img/B16069_06_001.png) be the set of neighbors of the node *u* and ![](img/B16069_06_002.png)
    be the set of neighbors of the node *v*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B16069_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**The u centrality**: The degree centrality computed for node *v*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The v centrality**: The degree centrality computed for node *u*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The u community**: The community ID assigned to node *u* using the Louvain
    heuristic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The v community**: The community ID assigned to node *v* using the Louvain
    heuristic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have written a useful function for computing these metrics using Python and
    `networkx`. You can find the implementation in the Python notebook provided in
    the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compute the features for each edge in the training and the test set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the proposed shallow approach, these features will be directly used as input
    for a `Random Forest` classifier. We will use its `scikit-learn` implementation
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding lines automatically instantiate and train a RandomForest classifier
    using the edge features we have computed before. We are now ready to compute the
    performance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Surprisingly, the shallow method based on hand-crafted features performs better
    than the others.
  prefs: []
  type: TYPE_NORMAL
- en: Summary of results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding examples, we have trained three algorithms on learning, with
    and without supervision, useful embeddings for link prediction. In the following
    table, we summarize the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.1 – Summary of the results achieved for the link prediction task'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_06_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.1 – Summary of the results achieved for the link prediction task
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Table 6.1*, the node2vec-based method is already able to achieve
    a high level of performance without supervision and per-node information. Such
    high results might be related to the particular structure of the combined ego
    network. Due to the high sub-modularity of the network (since it is composed of
    several ego networks), predicting whether two users will be connected or not might
    be highly related to the way the two candidate nodes are connected inside the
    network. For example, there might be a systematic situation in which two users,
    both connected to several users in the same ego network, have a high chance of
    being connected as well. On the other hand, two users belonging to different ego
    networks, or *very far* from each other, are likely to not be connected, making
    the prediction task easier. This is also confirmed by the high results achieved
    using the shallow method.
  prefs: []
  type: TYPE_NORMAL
- en: Such a situation might be confusing, instead, for more complicated algorithms
    like GraphSAGE, especially when node features are involved. For example, two users
    might share similar interests, making them very similar. However, they might belong
    to different ego networks, where the corresponding ego users live in two very
    different parts of the world. So, similar users, which in principle should be
    connected, are not. However, it is also possible that such algorithms are predicting
    something further in the future. Recall that the combined ego network is a timestamp
    of a particular situation in a given period of time. Who knows how it might have
    evolved right now!
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting machine learning algorithms is probably the most interesting challenge
    of machine learning itself. For this reason, we should always interpret results
    with care. Our suggestion is always to dig into the dataset and try to give an
    explanation of your results.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is important to remark that each of the algorithms was not tuned
    for the purpose of this demonstration. Different results can be obtained by properly
    tuning each hyperparameter and we highly suggest you try to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how machine learning can be useful for solving
    practical machine learning tasks on social network graphs. Furthermore, we have
    seen how future connections can be predicted on the SNAP Facebook combined ego
    network.
  prefs: []
  type: TYPE_NORMAL
- en: We reviewed graph analysis concepts and used graph-derived metrics to collect
    insight on the social graph. Then, we benchmarked several machine learning algorithms
    on the link prediction task, evaluating their performance and trying to give them
    interpretations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on how similar approaches can be used to
    analyze a corpus of documents using text analytics and natural language processing.
  prefs: []
  type: TYPE_NORMAL
