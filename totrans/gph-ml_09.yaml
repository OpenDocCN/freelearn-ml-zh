- en: 'Chapter 6: Social Network Graphs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：社交网络图
- en: The growth of social networking sites has been one of the most active trends
    in digital media over the years. Since the late 1990s, when the first social applications
    were published, they have attracted billions of active users worldwide, many of
    whom have integrated digital social interactions into their daily lives. New ways
    of communication are being driven by social networks such as Facebook, Twitter,
    and Instagram, among others. Users can share ideas, post updates and feedback,
    or engage in activities and events while sharing their broader interests on social
    networking sites.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 社交网络网站的增长一直是数字媒体中最活跃的趋势之一。自20世纪90年代末第一批社交应用发布以来，它们吸引了数十亿活跃用户，其中许多人已经将数字社交互动融入他们的日常生活中。Facebook、Twitter、Instagram等社交网络正在推动新的沟通方式。用户可以在社交网络上分享想法、发布更新和反馈，或在活动中参与并分享他们的更广泛兴趣。
- en: Besides, social networks constitute a huge source of information for studying
    user behaviors, interpreting interaction among people, and predicting their interests.
    Structuring them as graphs, where a vertex corresponds to a person and an edge
    represents the connection between them, enables a powerful tool to extract useful
    knowledge.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，社交网络构成了研究用户行为、解释人与人之间的互动以及预测他们兴趣的巨大信息来源。将它们结构化为图，其中顶点对应于一个人，边代表他们之间的连接，这使得一个强大的工具来提取有用的知识。
- en: However, understanding the dynamics that drive the evolution of a social network
    is a complex problem due to a large number of variable parameters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于变量参数众多，理解驱动社交网络演变的动态是一个复杂的问题。
- en: In this chapter, we will talk about how we can analyze the Facebook social network
    using graph theory and how we can solve useful problems such as link prediction
    and community detection using machine learning.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何使用图论分析Facebook社交网络，以及如何使用机器学习解决诸如链接预测和社区检测等有用的问题。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Overview of the dataset
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据集概述
- en: Network topology and community detection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络拓扑和社区检测
- en: Embedding for supervised and unsupervised tasks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于监督和无监督任务的嵌入
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will be using *Jupyter* notebooks with *Python* 3.8 for all of our exercises.
    The following is a list of the Python libraries that need to be installed for
    this chapter using `pip`. For example, run `pip install networkx==2.5` on the
    command line:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用带有*Python* 3.8的*Jupyter*笔记本进行所有练习。以下是需要使用`pip`安装的Python库列表，以便本章使用：例如，在命令行中运行`pip
    install networkx==2.5`：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the rest of this chapter, if not clearly stated, we will refer to `nx`,
    `pd`, and `np` as results of the following Python commands: `import networkx`
    as `nx`, `import pandas` as `pd`, and `import numpy` as `np`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，除非明确说明，否则我们将使用以下Python命令的结果来指代`nx`、`pd`和`np`：`import networkx` as `nx`、`import
    pandas` as `pd`和`import numpy` as `np`。
- en: All code files relevant to this chapter are available at [https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter06](https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter06).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与本章相关的代码文件均可在[https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter06](https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter06)找到。
- en: Overview of the dataset
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据集概述
- en: We will be using the **Social circles SNAP Facebook public dataset**, from Stanford
    University ([https://snap.stanford.edu/data/ego-Facebook.html](https://snap.stanford.edu/data/ego-Facebook.html)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**社交圈子SNAP Facebook公共数据集**，来自斯坦福大学([https://snap.stanford.edu/data/ego-Facebook.html](https://snap.stanford.edu/data/ego-Facebook.html))。
- en: The dataset was created by collecting Facebook user information from survey
    participants. Ego networks were created from 10 users. Each user was asked to
    identify all the **circles** (list of friends) to which their friends belong.
    On average, each user identified 19 circles in their **ego networks**, where each
    circle has on average 22 friends.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集是通过从调查参与者收集Facebook用户信息创建的。从10个用户中创建了自我网络。每个用户被要求识别所有他们朋友所属的**圈子**（朋友列表）。平均而言，每个用户在他们的**自我网络**中识别了19个圈子，其中每个圈子平均有22个朋友。
- en: 'For each user, the following information was collected:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个用户，收集了以下信息：
- en: '**Edges**: An edge exists if two users are friends on Facebook.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边**：如果两个用户在Facebook上是朋友，则存在边。'
- en: '`1` if the user has this property in their profile and `0` otherwise. Features
    have been anonymized since the names of the features would reveal private data.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户在其个人资料中具有此属性则为`1`，否则为`0`。由于特征名称会泄露私人数据，因此已对特征进行匿名化。
- en: The 10 ego networks were then unified in a single graph that we are going to
    study.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将10个ego网络统一到一个我们将要研究的单个图中。
- en: Dataset download
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据集下载
- en: 'The dataset can be retrieved using the following URL: [https://snap.stanford.edu/data/ego-Facebook.html](https://snap.stanford.edu/data/ego-Facebook.html).
    In particular, three files can be downloaded: `facebook.tar.gz`, `facebook_combined.txt.gz`,
    and `readme-Ego.txt`. Let''s inspect each file separately:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下URL检索数据集：[https://snap.stanford.edu/data/ego-Facebook.html](https://snap.stanford.edu/data/ego-Facebook.html)。特别是，可以下载三个文件：`facebook.tar.gz`、`facebook_combined.txt.gz`和`readme-Ego.txt`。让我们分别检查每个文件：
- en: '`facebook.tar.gz`: This is an archive containing four files for each `nodeId.extension`
    where `nodeId` is the node ID of the ego user and `extension` is either `edges`,
    `circles`, `feat`, `egofeat`, or `featnames`. The following provides more details:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`facebook.tar.gz`：这是一个包含四个文件的存档，每个`nodeId.extension`对应一个文件，其中`nodeId`是ego用户的节点ID，`extension`可以是`edges`、`circles`、`feat`、`egofeat`或`featnames`。以下提供更多详细信息：'
- en: 'a. `nodeId.edges`: This contains a list of edges for the network of the `nodeId`
    node.'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. `nodeId.edges`：这包含`nodeId`节点网络的边列表。
- en: 'b. `nodeId.circles`: This contains several lines (one for each circle). Each
    line consists of a name (the circle name) followed by a series of node IDs.'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. `nodeId.circles`：这包含多个行（每个圈一行）。每行包含一个名称（圈名称）后跟一系列节点ID。
- en: 'c. `nodeId.feat`: This contains the features (`0` if `nodeId` has the feature,
    `1` otherwise) for each node in the ego network.'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. `nodeId.feat`：这包含ego网络中每个节点的特征（如果`nodeId`具有该特征则为`0`，否则为`1`）。
- en: 'd. `nodeId.egofeat`: This contains the features for the ego user.'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. `nodeId.egofeat`：这包含ego用户的特征。
- en: 'e. `nodeId.featname`: This contains the names of the features.'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e. `nodeId.featname`：这包含特征名称。
- en: '`facebook_combined.txt.gz`: This is an archive containing a single file, `facebook_combined.txt`,
    which is a list of edges from all the ego networks combined.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`facebook_combined.txt.gz`：这是一个包含单个文件`facebook_combined.txt`的存档，它是所有ego网络合并后的边列表。'
- en: '`readme-Ego.txt`: This contains a description for the previously mentioned
    files.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readme-Ego.txt`：这包含之前提到的文件的描述。'
- en: Take a look at those files by yourself. It is strongly suggested to explore
    and become as comfortable as possible with the dataset before starting any machine
    learning task.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请自行查看这些文件。强烈建议在开始任何机器学习任务之前探索并尽可能熟悉数据集。
- en: Loading the dataset using networkx
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用networkx加载数据集
- en: The first step of our analysis will be loading the aggregated ego networks using
    `networkx`. As we have seen in previous chapters, `networkx` is powerful for graph
    analysis and, given the size of the datasets, will be the perfect tool for the
    analysis that we will be doing in this chapter. However, for larger social network
    graphs with billions of nodes and edges, more specific tools might be required
    for loading and processing them. We will cover the tools and technologies used
    for scaling out the analysis in[*Chapter 9*](B16069_09_Final_JM_ePub.xhtml#_idTextAnchor141),
    *Building a Data-Driven Graph-Powered Application*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析的第一步将是使用`networkx`加载聚合ego网络。正如我们在前面的章节中所见，`networkx`在图分析方面非常强大，并且鉴于数据集的大小，它将是我们在本章中进行分析的完美工具。然而，对于具有数十亿节点和边的更大社交网络图，可能需要更具体的工具来加载和处理它们。我们将在[*第9章*](B16069_09_Final_JM_ePub.xhtml#_idTextAnchor141)中介绍用于扩展分析的工具和技术，*构建数据驱动的图应用*。
- en: 'As we have seen, the combined ego network is represented as a list of edges.
    We can create an undirected graph from a list of edges using `networkx` as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，组合ego网络表示为边列表。我们可以使用`networkx`从边列表创建一个无向图，如下所示：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s print some basic information about the graph:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印一些关于图的基本信息：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output should be as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, the aggregated network contains `4039` nodes and `88234` edges.
    This is a fairly connected network with a number of edges more than 20 times the
    number of nodes. Indeed, several clusters should be present in the aggregated
    networks (likely the small worlds of each ego user).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，聚合网络包含`4039`个节点和`88234`条边。这是一个相当紧密连接的网络，边的数量比节点多20多倍。实际上，聚合网络中应该存在多个簇（可能是每个ego用户的小世界）。
- en: 'Drawing the network will also help in better understanding what we are going
    to analyze. We can draw the graph using `networkx` as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制网络也将帮助我们更好地理解我们将要分析的内容。我们可以使用 `networkx` 如下绘制图：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output should be as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果应如下所示：
- en: '![Figure 6.1 – The aggregated Facebook ego network'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – Facebook 自我网络聚合'
- en: '](img/B16069_06_01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16069_06_01.jpg](img/B16069_06_01.jpg)'
- en: Figure 6.1 – The aggregated Facebook ego network
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – Facebook 自我网络聚合
- en: We can observe the presence of highly interconnected hubs. This is interesting
    from a social network analysis point of view since they might be the result of
    underlying social mechanisms that can be further investigated for better understanding
    the structure of an individual's relationships with respect to their world.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到高度互联的中心节点。从社会网络分析的角度来看，这很有趣，因为它们可能是可以进一步研究以更好地理解个人与其世界关系结构的潜在社会机制的结果。
- en: Before continuing our analysis, let's save the IDs of the ego user nodes inside
    the network. We can retrieve them from the files contained in the `facebook.tar.gz`
    archive.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续我们的分析之前，让我们保存网络中自我用户节点的 ID。我们可以从包含在 `facebook.tar.gz` 存档中的文件中检索它们。
- en: 'First, unpack the archive. The extracted folder will be named `facebook`. Let''s
    run the following Python code for retrieving the IDs by taking the first part
    of each filename:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，解压存档。提取的文件夹将被命名为 `facebook`。让我们运行以下 Python 代码，通过取每个文件名的第一部分来检索 ID：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are now ready for analyzing the graph. In particular, in the next section,
    we will better understand the structure of the graph by inspecting its properties.
    This will help us to have a clearer idea of its topology and its relevant characteristics.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好分析图。特别是，在下一节中，我们将通过检查其属性来更好地理解图的结构。这将帮助我们更清晰地了解其拓扑及其相关特征。
- en: Network topology and community detection
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络拓扑和社区检测
- en: Understanding the topology of the network as well as the role of its nodes is
    a crucial step in the analysis of a social network. It is important to keep in
    mind that, in this context, nodes are actually users, each with their own interests,
    habits, and behaviors. Such knowledge will be extremely useful when performing
    predictions and/or finding insights.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 理解网络的拓扑以及其节点的角色是分析社交网络的关键步骤。重要的是要记住，在这种情况下，节点实际上是用户，每个用户都有自己的兴趣、习惯和行为。这种知识在执行预测和/或寻找洞察时将非常有用。
- en: 'We will be using `networkx` to compute most of the useful metrics we have seen
    in [*Chapter 1*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014), *Getting Started
    with Graphs*. We will try to give them an interpretation to collect insight into
    the graph. Let''s begin as usual, by importing the required libraries and defining
    some variables that we will use throughout the code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `networkx` 来计算我们在 [*第 1 章*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014)，*图形入门*
    中看到的大部分有用度量。我们将尝试对它们进行解释，以收集关于图的信息。让我们像往常一样开始，导入所需的库并定义一些我们将贯穿整个代码的变量：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can now proceed to the analysis.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续分析。
- en: Topology overview
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拓扑概述
- en: 'As we have already seen before, our combined network has 4,039 nodes and more
    than 80,000 edges. The next metric we will compute is assortativity. It will reveal
    information about the tendency of users to be connected with users with a similar
    degree. We can do that as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，我们的组合网络有 4,039 个节点和超过 80,000 条边。我们将计算的下一个度量是配对性。它将揭示用户倾向于与具有相似度数用户连接的趋势。我们可以这样做：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output should be as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果应如下所示：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we can observe a positive assortativity, likely showing that well-connected
    individuals associate with other well-connected individuals (as we have seen in
    [*Chapter 1*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014), *Getting Started
    with Graphs*). This is expected since inside each circle users might tend to be
    highly connected to each other.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以观察到正配对性，这很可能表明联系紧密的个人会与其他联系紧密的个人联系（正如我们在 [*第 1 章*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014)，*图形入门*
    中所见）。这是预期的，因为每个圈内的用户可能倾向于彼此高度连接。
- en: 'Transitivity could also help at better understanding how individuals are connected.
    Recall transitivity indicates the mean probability that two people with a common
    friend are themselves friends:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 传递性也有助于更好地理解个人是如何连接的。回想一下，传递性表示两个有共同朋友的人成为朋友的平均概率：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output should be as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果应如下所示：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we have the probability of around 50% that two friends can or cannot have
    common friends.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有大约50%的概率，两个朋友可以或不可以有共同的朋友。
- en: 'The observation is also confirmed by computing the average clustering coefficient.
    Indeed, it can be considered as an alternative definition of transitivity:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计算平均聚类系数，这一观察也得到了证实。确实，它可以被认为是传递性的另一种定义：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output should be as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that the clustering coefficient tends to be higher than transitivity.
    Indeed, by definition, it puts more weight on vertices with a low degree, since
    they have a limited number of possible pairs of neighbors (the denominator of
    the local clustering coefficient).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到聚类系数往往高于传递性。实际上，根据定义，它对度数低的顶点赋予更多的权重，因为它们有有限的可能邻居对（局部聚类系数的分母）。
- en: Node centrality
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点中心性
- en: 'Once we have a clearer idea of what the overall topology looks like, we can
    proceed by investigating the importance of each individual inside the network.
    As we have seen in [*Chapter 1*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014),
    *Getting Started with Graphs*, the first definition of importance can be given
    by means of the betweenness centrality metric. It measures how many shortest paths
    pass through a given node, giving an idea of how *central* that node is for the
    spreading of information inside the network. We can compute it using the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对整体拓扑有了更清晰的认识，我们就可以通过调查网络中每个个体的重要性来继续。正如我们在[*第一章*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014)，“开始使用图”中看到的，重要性的第一个定义可以通过介数中心性指标给出。它衡量有多少最短路径穿过一个给定的节点，从而给出一个关于该节点在信息在网络中传播中的*中心性*的印象。我们可以使用以下方法来计算它：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output should be as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The average betweenness centrality is pretty low, which is understandable given
    the large amount of non-bridging nodes inside the network. However, we could collect
    better insight by visual inspection of the graph. In particular, we will draw
    the combined ego network by enhancing nodes with the highest betweenness centrality.
    Let''s define a proper function for this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 平均介数中心性相当低，考虑到网络中大量非桥接节点，这是可以理解的。然而，通过图形的视觉检查，我们可以收集更好的见解。特别是，我们将通过增强具有最高介数中心性的节点来绘制组合自我网络。让我们为此定义一个适当的函数：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now let''s invoke it as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们按照以下方式调用它：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output should be as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '![Figure 6.2 – Betweenness centrality'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – 介数中心性'
- en: '](img/B16069_06_02.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_06_02.jpg](img/B16069_06_02.jpg)'
- en: Figure 6.2 – Betweenness centrality
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 介数中心性
- en: 'Let''s also inspect the degree centrality of each node. Since this metric is
    related to the number of neighbors of a node, we will have a clearer idea of how
    well the nodes are connected to each other:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也检查每个节点的度中心性。由于这个指标与节点的邻居数量相关，我们将更清楚地了解节点之间是如何相互连接的：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output should be as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is a representation of the degree centrality:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是度中心性的表示：
- en: '![Figure 6.3 – Degree centrality'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – 度中心性'
- en: '](img/B16069_06_03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_06_03.jpg](img/B16069_06_03.jpg)'
- en: Figure 6.3 – Degree centrality
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 度中心性
- en: 'Finally, let''s also have a look at the closeness centrality. This will help
    us understand how close nodes are to each other in terms of the shortest path:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们也看看亲近中心性。这将帮助我们理解节点之间在最短路径意义上的接近程度：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output should be as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is a representation of the closeness centrality:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是亲近中心性的表示：
- en: '![Figure 6.4 – Closeness centrality'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – 亲近中心性'
- en: '](img/B16069_06_04.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_06_04.jpg](img/B16069_06_04.jpg)'
- en: Figure 6.4 – Closeness centrality
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 亲近中心性
- en: From the centrality analysis, it is interesting to observe that each central
    node seems to be part of a sort of community (this is reasonable, since the central
    nodes might correspond to the ego nodes of the network). It is also interesting
    to notice the presence of a bunch of highly interconnected nodes (especially from
    the closeness centrality analysis). Let's thus identify these communities in the
    next part of our analysis.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从中心性分析中，有趣的是观察到每个中心节点似乎都是某种社区的一部分（这是合理的，因为中心节点可能对应于网络的自我节点）。同样有趣的是注意到存在大量高度相互连接的节点（特别是从亲近中心性分析中）。因此，让我们在分析的下个部分中识别这些社区。
- en: Community detection
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社区检测
- en: 'Since we are performing social network analysis, it is worth exploring one
    of the most interesting graph structures for social networks: communities. If
    you use Facebook, it is very likely that your friends reflect different aspects
    of your life: friends from an educational environment (high school, college, and
    so on), friends from your weekly football match, friends you have met at parties,
    and so on.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在进行社会网络分析，探索社交网络中最有趣的图结构之一：社区，是值得的。如果你使用Facebook，你的朋友很可能反映了你生活的不同方面：来自教育环境的朋友（高中、大学等），来自你每周足球比赛的朋友，你在派对上遇到的朋友等等。
- en: An interesting aspect of social network analysis is to automatically identify
    such groups. This can be done automatically, inferring them from topological properties,
    or semi-automatically, exploiting some prior insight.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 社会网络分析的一个有趣方面是自动识别这样的群体。这可以通过自动推断其拓扑属性或半自动地利用一些先验洞察来完成。
- en: One good criterion is to try to minimize intra-community edges (edges connecting
    members of different communities) while maximizing inter-community edges (connecting
    members within the same community).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的标准是尽量减少社区内边缘（连接不同社区成员的边缘）的数量，同时最大化社区间边缘（连接同一社区成员的边缘）的数量。
- en: 'We can do that in `networkx` as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`networkx`中这样做：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output should be as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '![Figure 6.5 – Detected communities using networkx'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 – 使用networkx检测到的社区'
- en: '](img/B16069_06_05.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16069_06_05.jpg)'
- en: Figure 6.5 – Detected communities using networkx
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 使用networkx检测到的社区
- en: 'In this context, it is also interesting to investigate whether the ego users
    occupy some roles inside the detected communities. Let''s enhance the size and
    color of the ego user nodes as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，研究ego用户是否在检测到的社区中占据某些角色也是有趣的。让我们按照以下方式增强ego用户节点的大小和颜色：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output should be as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '![Figure 6.6 – Detected communities using networkx with the ego users node
    size enhanced'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6 – 使用networkx检测到的社区，增强ego用户节点大小'
- en: '](img/B16069_06_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16069_06_06.jpg)'
- en: Figure 6.6 – Detected communities using networkx with the ego users node size
    enhanced
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 使用networkx检测到的社区，增强ego用户节点大小
- en: It is interesting to notice that some ego users belong to the same community.
    It is possible that ego users are actual friends on Facebook, and therefore their
    ego networks are partially shared.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是注意到一些ego用户属于同一个社区。可能的情况是ego用户是Facebook上的实际朋友，因此他们的ego网络部分是共享的。
- en: We have now completed our basic understanding of the graph structure. We now
    know that some important nodes can be identified inside the network. We have also
    seen the presence of well-defined communities to which those nodes belong. Keep
    in mind these observations while performing the next part of the analysis, which
    is applying machine learning methods for supervised and unsupervised tasks.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了对图结构的基本理解。我们知道网络中可以识别出一些重要的节点。我们也看到了这些节点所属的明确社区的存在。在进行下一部分分析时，即应用机器学习方法进行监督和非监督任务时，请记住这些观察结果。
- en: Embedding for supervised and unsupervised tasks
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监督和非监督任务的嵌入
- en: Social media represents, nowadays, one of the most interesting and rich sources
    of information. Every day, thousands of new connections arise, new users join
    communities, and billions of posts are shared. Graphs mathematically represent
    all those interactions, helping to make order of all such spontaneous and unstructured
    traffic.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，社交媒体是信息来源中最有趣和最丰富的之一。每天都有成千上万的新连接出现，新用户加入社区，数十亿条帖子被分享。图从数学上表示了所有这些互动，有助于对这种自发和无结构的流量进行排序。
- en: When dealing with social graphs, there are many interesting problems that can
    be addressed using machine learning. Under the correct settings, it is possible
    to extract useful insights from this huge amount of data, for improving your marketing
    strategy, identifying users with dangerous behaviors (for example, terrorist networks),
    and predicting the likelihood that a user will read your new post.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理社交图时，有许多有趣的问题可以使用机器学习来解决。在正确的设置下，可以从这些大量数据中提取有用的见解，以改进您的营销策略，识别具有危险行为的用户（例如，恐怖分子网络），以及预测用户阅读您的新帖子的可能性。
- en: Specifically, link prediction is one of the most interesting and important research
    topics in this field. Depending on what a *connection* in your social graph represents,
    by predicting future edges, you will be able to predict your next suggested friend,
    the next suggested movie, and which product you are likely to buy.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，链接预测是这个领域中最有趣和最重要的研究课题之一。根据你在社交图中的“连接”代表什么，通过预测未来的边，你将能够预测你的下一个建议的朋友、下一个建议的电影以及你可能会购买的产品。
- en: As we have already seen in [*Chapter 5*](B16069_05_Final_JM_ePub.xhtml#_idTextAnchor079),
    *Problems with Machine Learning on Graphs*, the link prediction task aims at forecasting
    the likelihood of a future connection between two nodes and it can be solved using
    several machine learning algorithms.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们已在[*第五章*](B16069_05_Final_JM_ePub.xhtml#_idTextAnchor079)中看到的，“图上机器学习的问题”，链接预测任务旨在预测两个节点之间未来连接的可能性，并且可以使用多种机器学习算法来解决。
- en: In the next examples, we will be applying supervised and unsupervised machine
    learning graph embedding algorithms for predicting future connections on the SNAP
    Facebook social graph. Furthermore, we will evaluate the contribution of node
    features in the prediction task.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将应用监督和无监督的机器学习图嵌入算法来预测SNAP Facebook社交图上的未来连接。此外，我们还将评估节点特征在预测任务中的贡献。
- en: Task preparation
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务准备
- en: In order to perform the link prediction task, it is necessary to prepare our
    dataset. The problem will be treated as a supervised task. Pairs of nodes will
    be provided to each algorithm as input, while the target will be binary, that
    is, *connected* if the two nodes are actually connected in the network, and *not
    connected* otherwise.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行链接预测任务，有必要准备我们的数据集。这个问题将被视为一个监督任务。节点对将被提供给每个算法作为输入，而目标将是二进制，即如果两个节点在网络中实际上连接，则为*连接*，否则为*不连接*。
- en: Since we aim to cast this problem as a supervised learning task, we need to
    create a training and testing dataset. We will therefore create two new subgraphs
    with the same numbers of nodes but different numbers of edges (as some edges will
    be removed and treated as positive samples for training/testing the algorithm).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们旨在将此问题作为监督学习任务，我们需要创建一个训练和测试数据集。因此，我们将创建两个具有相同节点数但边数不同的新子图（因为一些边将被移除并作为训练/测试算法的正样本处理）。
- en: 'The `stellargraph` library provides a useful tool for splitting the data and
    creating training and test reduced subgraphs. This process is similar to the one
    we have already seen in [*Chapter 5*](B16069_05_Final_JM_ePub.xhtml#_idTextAnchor079),
    *Problems with Machine Learning on Graphs*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`stellargraph`库提供了一个有用的工具来分割数据并创建训练和测试简化的子图。这个过程与我们已在[*第五章*](B16069_05_Final_JM_ePub.xhtml#_idTextAnchor079)中看到的类似，“图上机器学习的问题”：'
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We are using the `EdgeSplitter` class to extract a fraction (`p`=10%) of all
    the edges in `G`, as well as the same number of negative edges, in order to obtain
    a reduced graph, `graph_test`. The `train_test_split` method also returns a list
    of node pairs, `samples_test` (where each pair corresponds to an existing or not
    existing edge in the graph), and a list of binary targets (`labels_test`) of the
    same length of the `samples_test` list. Then, from such a reduced graph, we are
    repeating the operation to obtain another reduced graph, `graph_train`, as well
    as the corresponding `samples_train` and `labels_train` lists.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`EdgeSplitter`类从`G`中提取所有边的部分（`p`=10%），以及相同数量的负边，以获得一个简化的图`graph_test`。`train_test_split`方法还会返回一个节点对列表`samples_test`（其中每个对对应于图中存在或不存在的边），以及与`samples_test`列表长度相同的二进制目标列表`labels_test`。然后，从这样一个简化的图中，我们重复操作以获得另一个简化的图`graph_train`，以及相应的`samples_train`和`labels_train`列表。
- en: 'We will be comparing three different methods for predicting missing edges:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将比较三种预测缺失边的不同方法：
- en: '**Method 1**: node2vec will be used to learn a node embedding without supervision.
    The learned embedding will be used as input for a supervised classification algorithm
    to determine whether the input pair is actually connected.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法1**：将使用node2vec来学习一个无监督的节点嵌入。学到的嵌入将被用作监督分类算法的输入，以确定输入对是否实际上连接。'
- en: '**Method 2**: The graph neural network-based algorithm GraphSAGE will be used
    to jointly learn the embedding and perform the classification task.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法2**：将使用基于图神经网络的算法GraphSAGE来联合学习嵌入并执行分类任务。'
- en: '**Method 3**: Hand-crafted features will be extracted from the graph and used
    as inputs for a supervised classifier, together with the nodes'' IDs.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法3**：将从图中提取手工特征，并将其与节点ID一起用作监督分类器的输入。'
- en: Let's analyze them in more detail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地分析它们。
- en: node2vec-based link prediction
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于node2vec的链接预测
- en: 'The herein proposed method is carried out in several steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提出的方法分为几个步骤：
- en: 'We use node2vec to generate node embeddings without supervision from the training
    graph. This can be done using the `node2vec` Python implementation, as we have
    already seen in [*Chapter 5*](B16069_05_Final_JM_ePub.xhtml#_idTextAnchor079)*,*
    *Problems with Machine Learning on Graphs*:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用node2vec从训练图中生成节点嵌入，而不需要监督。这可以通过`node2vec` Python实现来完成，正如我们在[*第5章*](B16069_05_Final_JM_ePub.xhtml#_idTextAnchor079)*,*
    *图上机器学习的问题*中已经看到的：
- en: '[PRE24]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we use `HadamardEmbedder` for generating an embedding for each pair of
    embedded nodes. Such feature vectors will be used as input to train the classifier:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`HadamardEmbedder`为每个嵌入节点的对生成嵌入。这些特征向量将被用作训练分类器的输入：
- en: '[PRE25]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It''s time for training our supervised classifier. We will be using the RandomForest
    classifier, a powerful decision tree-based ensemble algorithm:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候训练我们的监督分类器了。我们将使用RandomForest分类器，这是一种基于决策树的强大集成算法：
- en: '[PRE26]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, let''s apply the trained model for creating the embedding of the test
    set:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们应用训练好的模型来创建测试集的嵌入：
- en: '[PRE27]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we are ready to perform the prediction on the test set using our trained
    model:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用训练好的模型在测试集上进行预测：
- en: '[PRE28]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output should be as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE29]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Not bad at all! We can observe that the node2vec-based embedding already provides
    a powerful representation for actually predicting links on the combined Facebook
    ego network.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不错！我们可以观察到，基于node2vec的嵌入已经为在结合的Facebook ego网络上预测链接提供了一个强大的表示。
- en: GraphSAGE-based link prediction
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于GraphSAGE的链接预测
- en: Next, we will use GraphSAGE for learning node embeddings and classifying edges.
    We will build a two-layer GraphSAGE architecture that, given labeled pairs of
    nodes, outputs a pair of node embeddings. Then, a fully connected neural network
    will be used to process these embeddings and produce link predictions. Notice
    that the GraphSAGE model and the fully connected network will be concatenated
    and trained end to end so that the embeddings learning stage is influenced by
    the predictions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用GraphSAGE来学习节点嵌入并分类边。我们将构建一个两层GraphSAGE架构，它给定标记的节点对，输出一对节点嵌入。然后，将使用全连接神经网络来处理这些嵌入并产生链接预测。请注意，GraphSAGE模型和全连接网络将连接并端到端训练，以便嵌入学习阶段受到预测的影响。
- en: Featureless approach
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无特征方法
- en: Before starting, we may recall from *Chapters 4, Supervised Graph Learning*,
    and [*Chapter 5*](B16069_05_Final_JM_ePub.xhtml#_idTextAnchor079), *Problems with
    Machine Learning on Graphs*, that GraphSAGE needs node descriptors (features).
    Such features may or may not be available in your dataset. Let's begin our analysis
    by not considering available node features. In this case, a common approach is
    to assign to each node a one-hot feature vector of length |*V*| (the number of
    nodes in the graph), where only the cell corresponding to the given node is 1,
    while the remaining cells are 0.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们可以回顾一下*第4章，监督图学习*和[*第5章*](B16069_05_Final_JM_ePub.xhtml#_idTextAnchor079)，*图上机器学习的问题*，其中GraphSAGE需要节点描述符（特征）。这些特征可能在你的数据集中可用，也可能不可用。让我们从不考虑可用的节点特征开始我们的分析。在这种情况下，一个常见的方法是为图中的每个节点分配一个长度为|*V*|（图中节点的数量）的one-hot特征向量，其中只有对应给定节点的单元格为1，而其余单元格为0。
- en: 'This can be done in Python and `networkx` as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在Python和`networkx`中完成如下：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding code snippet, we did the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们做了以下操作：
- en: We created an identity matrix of size |*V*|. Each row of the matrix is the one-hot
    vector we need for each node in the graph.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个大小为|*V*|的标识矩阵。矩阵的每一行是我们为图中每个节点所需的one-hot向量。
- en: Then, we created a Python dictionary where, for each `nodeID` (used as the key),
    we assign the corresponding row of the previously created identity matrix.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个Python字典，其中对于每个`nodeID`（用作键），我们分配之前创建的标识矩阵的对应行。
- en: Finally, the dictionary was passed to the `networkx` `set_node_attributes` function
    to assign the "fake" features to each node in the `networkx` graph.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将字典传递给`networkx`的`set_node_attributes`函数，以将“假”特征分配给`networkx`图中的每个节点。
- en: Notice that the process is repeated for both the training and test graph.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个过程在训练图和测试图上都会重复。
- en: 'The next step will be defining the generator that will be used to feed the
    model. We will be using the `stellargraph` `GraphSAGELinkGenerator` for this,
    which essentially provides the model with pairs of nodes as input:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是定义用于向模型提供数据的生成器。我们将使用 `stellargraph` 的 `GraphSAGELinkGenerator` 来完成这项工作，它本质上向模型提供节点对作为输入：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that we also need to define `batch_size` (number of inputs per minibatch)
    and the number of first- and second-hop neighbor samples that GraphSAGE should
    consider.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还需要定义 `batch_size`（每个minibatch的输入数量）以及GraphSAGE应考虑的第一跳和第二跳邻居样本的数量。
- en: 'Finally, we are ready to create the model:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备好创建模型：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding snippet, we are creating a GraphSAGE model with two hidden
    layers of size 20, each with a bias term and a dropout layer for reducing overfitting.
    Then, the output of the GraphSAGE part of the module is concatenated with a `link_classification`
    layer that takes pairs of node embeddings (output of GraphSAGE), uses binary operators
    (inner product; `ip` in our case) to produce edge embeddings, and finally passes
    them through a fully connected neural network for classification.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个具有两个大小为20的隐藏层（每个层都有一个偏置项和用于减少过拟合的dropout层）的GraphSAGE模型。然后，模块中GraphSAGE部分的输出与一个
    `link_classification` 层连接，该层使用节点嵌入对（GraphSAGE的输出）使用二元运算符（内积；在我们的例子中是 `ip`）来产生边嵌入，并最终通过一个全连接神经网络进行分类。
- en: The model is optimized via the Adam optimizer (learning rate = `1e-3`) using
    the mean squared error as a loss function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型通过Adam优化器（学习率 = `1e-3`）使用均方误差作为损失函数进行优化。
- en: 'Let''s train the model for 10 epochs:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们训练模型10个epoch：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output should be as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once trained, let''s compute the performance metrics over the test set:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 训练完成后，让我们在测试集上计算性能指标：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output should be as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we can observe, performances are lower than the ones obtained in the node2vec-based
    approach. However, we are not considering real node features yet, which could
    represent a great source of information. Let's do that in the following test.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所观察到的，性能低于基于node2vec的方法。然而，我们还没有考虑真实的节点特征，这可能会是一个巨大的信息来源。让我们在接下来的测试中这样做。
- en: Introducing node features
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入节点特征
- en: 'The process of extracting node features for the combined ego network is quite
    verbose. This is because, as we have explained in the first part of the chapter,
    each ego network is described using several files, as well as all the feature
    names and values. We have written useful functions for parsing all the ego network
    in order to extract the node features. You can find their implementation in the
    Python notebook provided in the GitHub repository. Here, let''s just briefly summarize
    how they work:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 提取组合自我网络的节点特征的过程相当冗长。这是因为，正如我们在本章的第一部分所解释的，每个自我网络都是使用几个文件以及所有特征名称和值来描述的。我们已经编写了有用的函数来解析所有自我网络以提取节点特征。你可以在GitHub仓库提供的Python笔记本中找到它们的实现。在这里，我们只需简要总结一下它们是如何工作的：
- en: 'The `load_features` function parses each ego network and creates two dictionaries:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load_features` 函数解析每个自我网络并创建两个字典：'
- en: a. `feature_index`, which maps numeric indices to feature names
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. `feature_index`，将数值索引映射到特征名称
- en: b. `inverted_feature_indexes`, which maps names to numeric indices
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. `inverted_feature_indexes`，将名称映射到数值索引
- en: The `parse_nodes` function receives the combined ego network `G` and the ego
    nodes' IDs. Then, each ego node in the network is assigned with the corresponding
    features previously loaded using the `load_features` function.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parse_nodes` 函数接收组合自我网络 `G` 和自我节点ID。然后，网络中的每个自我节点都被分配了之前使用 `load_features`
    函数加载的相应特征。'
- en: 'Let''s invoke them in order to load a feature vector for each node in the combined
    ego network:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按顺序调用它们来加载组合自我网络中每个节点的特征向量：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can easily check the result by printing the information of one node in the
    network (for example, the node with ID `0`):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打印网络中一个节点的信息（例如，ID为`0`的节点）来轻松检查结果：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output should be as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we can observe, the node has a dictionary containing a key named `features`.
    The corresponding value is the feature vector assigned to this node.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所观察到的，节点包含一个包含名为 `features` 的键的字典。相应的值是分配给该节点的特征向量。
- en: 'We are now ready to repeat the same steps used before for training the GraphSAGE
    model, this time using `features` as the key when converting the `networkx` graph
    to the `StellarGraph` format:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备重复之前用于训练GraphSAGE模型的相同步骤，这次在将`networkx`图转换为`StellarGraph`格式时使用`features`作为键：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, as we have done before, we create the generators, compile the model,
    and train it for 10 epochs:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像我们之前做的那样，我们创建生成器，编译模型，并对其进行10个epoch的训练：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice that we are using the same hyperparameters (including the number of layers,
    batch size, and learning rate) as well as the random seed, to ensure a fair comparison
    between the models.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用相同的超参数（包括层数、批量大小和学习率）以及随机种子，以确保模型之间公平的比较。
- en: 'The output should be as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s evaluate the model performance:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们评估模型性能：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can check the output:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查输出：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As we can see, the introduction of real node features has brought a good improvement,
    even if the best performances are still the ones achieved using the node2vec approach.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，引入真实节点特征带来了良好的改进，即使最佳性能仍然是使用node2vec方法实现的。
- en: Finally, we will evaluate a shallow embedding approach where hand-crafted features
    will be used for training a supervised classifier.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将评估一个浅层嵌入方法，其中将使用手工特征来训练一个监督分类器。
- en: Hand-crafted features for link prediction
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于链接预测的手工特征
- en: As we have already seen in [*Chapter 4*](B16069_04_Final_JM_ePub.xhtml#_idTextAnchor064),
    *Supervised Graph Learning*, shallow embedding methods represent a simple yet
    powerful approach for dealing with supervised tasks. Basically, for each input
    edge, we will compute a set of metrics that will be given as input to a classifier.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第4章*](B16069_04_Final_JM_ePub.xhtml#_idTextAnchor064)，“监督图学习”中已经看到的，浅层嵌入方法代表了一种简单而强大的处理监督任务的方法。基本上，对于每个输入边，我们将计算一组指标，这些指标将被作为输入提供给分类器。
- en: 'In this example, for each input edge represented as a pair of nodes (*u*,*v*),
    four metrics will be considered, namely the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，对于每个表示为节点对 (*u*,*v*) 的输入边，将考虑四个指标，即以下指标：
- en: '`0` will be used if *u* is not reachable from *v*.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *u* 无法从 *v* 达到，则使用`0`。
- en: '**The Jaccard coefficient**: Given a pair of nodes (*u*,*v*), it is defined
    as the intersection over a union of the set of neighbors of *u* and *v*. Formally,
    let ![](img/B16069_06_001.png) be the set of neighbors of the node *u* and ![](img/B16069_06_002.png)
    be the set of neighbors of the node *v*:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jaccard系数**：给定一对节点 (*u*,*v*)，定义为节点 *u* 和 *v* 的邻居集合的交集与并集的比值。形式上，设 ![](img/B16069_06_001.png)
    为节点 *u* 的邻居集合，![](img/B16069_06_002.png) 为节点 *v* 的邻居集合：'
- en: '![](img/B16069_06_003.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16069_06_003.jpg)'
- en: '**The u centrality**: The degree centrality computed for node *v*.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**u中心性**：为节点 *v* 计算的度中心性。'
- en: '**The v centrality**: The degree centrality computed for node *u*.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**v中心性**：为节点 *u* 计算的度中心性。'
- en: '**The u community**: The community ID assigned to node *u* using the Louvain
    heuristic.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**u社区**：使用Louvain启发式算法分配给节点 *u* 的社区ID。'
- en: '**The v community**: The community ID assigned to node *v* using the Louvain
    heuristic.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**v社区**：使用Louvain启发式算法分配给节点 *v* 的社区ID。'
- en: We have written a useful function for computing these metrics using Python and
    `networkx`. You can find the implementation in the Python notebook provided in
    the GitHub repository.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了一个有用的函数，使用Python和`networkx`来计算这些指标。你可以在GitHub仓库提供的Python笔记本中找到实现。
- en: 'Let''s compute the features for each edge in the training and the test set:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算训练集和测试集中每个边的特征：
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the proposed shallow approach, these features will be directly used as input
    for a `Random Forest` classifier. We will use its `scikit-learn` implementation
    as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在提出的浅层方法中，这些特征将直接用作`Random Forest`分类器的输入。我们将使用其`scikit-learn`实现如下：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding lines automatically instantiate and train a RandomForest classifier
    using the edge features we have computed before. We are now ready to compute the
    performance as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行自动实例化和训练了一个使用我们之前计算过的边缘特征的RandomForest分类器。我们现在可以按照以下方式计算性能：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output will be as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Surprisingly, the shallow method based on hand-crafted features performs better
    than the others.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 意想不到的是，基于手工特征的浅层方法比其他方法表现更好。
- en: Summary of results
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果总结
- en: 'In the preceding examples, we have trained three algorithms on learning, with
    and without supervision, useful embeddings for link prediction. In the following
    table, we summarize the results:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在有监督和无监督的情况下，对学习算法进行了训练，用于链接预测的有用嵌入。在下表中，我们总结了结果：
- en: '![Table 6.1 – Summary of the results achieved for the link prediction task'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![表6.1 – 链接预测任务所取得的结果总结'
- en: '](img/B16069_06_011.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16069_06_011.jpg)'
- en: Table 6.1 – Summary of the results achieved for the link prediction task
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 – 链接预测任务所取得的结果总结
- en: As shown in *Table 6.1*, the node2vec-based method is already able to achieve
    a high level of performance without supervision and per-node information. Such
    high results might be related to the particular structure of the combined ego
    network. Due to the high sub-modularity of the network (since it is composed of
    several ego networks), predicting whether two users will be connected or not might
    be highly related to the way the two candidate nodes are connected inside the
    network. For example, there might be a systematic situation in which two users,
    both connected to several users in the same ego network, have a high chance of
    being connected as well. On the other hand, two users belonging to different ego
    networks, or *very far* from each other, are likely to not be connected, making
    the prediction task easier. This is also confirmed by the high results achieved
    using the shallow method.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如*表6.1*所示，基于node2vec的方法已经能够在没有监督和每个节点信息的情况下实现高水平的表现。这样的高结果可能与组合自我网络的特定结构有关。由于网络的高次模量（因为它由多个自我网络组成），预测两个用户是否会连接可能高度相关于两个候选节点在网络上连接的方式。例如，可能存在一种系统性的情况，其中两个用户，都连接到同一自我网络中的几个用户，有很高的可能性也会连接。另一方面，属于不同自我网络或*非常遥远*的用户不太可能连接，这使得预测任务变得更容易。这也得到了使用浅层方法获得的高结果的支持。
- en: Such a situation might be confusing, instead, for more complicated algorithms
    like GraphSAGE, especially when node features are involved. For example, two users
    might share similar interests, making them very similar. However, they might belong
    to different ego networks, where the corresponding ego users live in two very
    different parts of the world. So, similar users, which in principle should be
    connected, are not. However, it is also possible that such algorithms are predicting
    something further in the future. Recall that the combined ego network is a timestamp
    of a particular situation in a given period of time. Who knows how it might have
    evolved right now!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可能会令人困惑，相反，对于像GraphSAGE这样的更复杂算法，尤其是当涉及到节点特征时。例如，两个用户可能拥有相似的兴趣，使他们非常相似。然而，他们可能属于不同的自我网络，其中相应的自我用户生活在世界上的两个非常不同的部分。因此，在原则上应该连接的相似用户并没有连接。然而，也有可能这样的算法正在预测未来的某些东西。回想一下，组合自我网络是特定时间段内特定情况的标记。谁知道它现在可能如何演变呢！
- en: Interpreting machine learning algorithms is probably the most interesting challenge
    of machine learning itself. For this reason, we should always interpret results
    with care. Our suggestion is always to dig into the dataset and try to give an
    explanation of your results.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 解释机器学习算法可能是机器学习本身最有趣的挑战。因此，我们应该始终谨慎地解释结果。我们的建议是始终深入数据集，并尝试解释你的结果。
- en: Finally, it is important to remark that each of the algorithms was not tuned
    for the purpose of this demonstration. Different results can be obtained by properly
    tuning each hyperparameter and we highly suggest you try to do this.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是要指出，每个算法都不是为了这次演示而调整的。通过适当调整每个超参数，可以获得不同的结果，我们强烈建议你尝试这样做。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how machine learning can be useful for solving
    practical machine learning tasks on social network graphs. Furthermore, we have
    seen how future connections can be predicted on the SNAP Facebook combined ego
    network.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了机器学习如何有助于解决社交网络图上的实际机器学习任务。此外，我们还看到了如何在SNAP Facebook组合自我网络上预测未来的连接。
- en: We reviewed graph analysis concepts and used graph-derived metrics to collect
    insight on the social graph. Then, we benchmarked several machine learning algorithms
    on the link prediction task, evaluating their performance and trying to give them
    interpretations.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了图分析概念，并使用图衍生指标来收集关于社交图的洞察。然后，我们在链接预测任务上对几个机器学习算法进行了基准测试，评估了它们的性能，并试图对它们进行解释。
- en: In the next chapter, we will focus on how similar approaches can be used to
    analyze a corpus of documents using text analytics and natural language processing.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注如何使用类似的方法通过文本分析和自然语言处理来分析文档集合。
