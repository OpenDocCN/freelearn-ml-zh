<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Assessments</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Assessments</h1>
                </header>
            
            <article>
                


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 1,&#160;Getting Started with the Robot Operating System</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">Here are the three main features of ROS:
<ul>
<li>Message passing interface to communicate with different programs</li>
<li>Off-the-shelf robotics algorithm to make the robot prototyping faster</li>
<li>Software tools to visualize robot data and debugging</li>
</ul>
</li>
<li><span>The different levels of concepts in ROS are the&#160;</span>ROS Filesystem level,&#160;ROS Computation Graph Level, and&#160;ROS Community Level.</li>
<li class="mce-root">The Catkin build system is built using CMake and Python scripts. This tool helps us build the ROS packages.</li>
<li class="mce-root">The ROS topic is a named bus in which one node can communicate to another node. The kind of message type used in the topics are ROS messages.</li>
<li class="mce-root">The different concepts of the ROS computation graph are&#160;ROS Nodes, ROS Topics, ROS Messages, ROS Master, ROS Services, and<br/>
ROS Bags.</li>
<li class="mce-root">The ROS Master act as a mediator program to connect two ROS nodes to start communicating with each other.</li>
<li class="mce-root">The important features of Gazebo are:
<ul>
<li class="mce-root">Dynamic simulation: It includes physics engine like ODE, Bullet, Simbody and Dart</li>
<li class="mce-root">Advanced 3D graphics: It uses OGRE framework to create high-quality lighting, shadows, and textures</li>
<li class="mce-root">Plugin support: This will allow developers to add new robot, sensors, and environmental control</li>
<li class="mce-root">TCP/IP Transport: Controlling Gazebo using socket-based message passing interface</li>
</ul>
</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 2,&#160;Understanding the Basics of Differential Robots</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">Holonomic robots can freely move in any direction and the controllable degrees of freedom is equal to the total degrees of freedom. Omni wheel-based robots are an example of holonomic robots. Nonholonomic robots have constraints on its motion, so controllable degrees of freedom will not be equal to the total degrees of freedom. Differential driver configuration is an example of nonholonomic configuration.</li>
<li class="mce-root">Robot kinematics deals with the motion of the robot without considering the mass and inertia, whereas robot dynamics is the relationship between mass and inertia properties, motion, and associated torques.</li>
<li class="mce-root">ICC stands for Instantaneous Center of Curvature, which is an imaginary point on the robot wheel axis around which the robot is rotated.</li>
<li class="mce-root">It is the process of finding the robot's current position from the wheel velocity.</li>
<li class="mce-root">Finding the wheel velocity to reach a goal position.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 3,&#160;Modeling the Differential Drive Robot</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">Robot modeling is the process of creating the 2D and 3D representation of robot having all the parameters of the robot, which includes kinematic and dynamic parameters of the robot.</li>
<li class="mce-root">The 2D model mainly includes the exact dimension of robot parts, which helps us compute the kinematics of the robot as well as helps&#160; manufacture robot parts.</li>
<li class="mce-root">The 3D model of the robot is an exact replica of robot hardware having all parameters of the physical robot designed using a CAD software. This is used for creating robot simulation and 3D printing parts of the robot.</li>
<li class="mce-root">Creating a 3D model using Python scripting is much easier and accurate than manual modeling if you know the Blender scripting APIs.</li>
<li class="mce-root">URDF is the 3D robot model representation of robot in ROS. It is having kinematic and dynamic parameters of the robot.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 4,&#160;Simulating a Differential Drive Robot Using ROS</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">Sensor modeling in Gazebo can be done using Gazebo plugins. The sensor model can be written using C++, which can be plugged in to the Gazebo simulator.</li>
<li class="mce-root">ROS is interfaced to Gazebo using Gazebo ROS plugin. When we load this plugin into Gazebo, we can able to control Gazebo through ROS interface.</li>
<li class="mce-root">The important tags are&#160;<kbd>&lt;inertia&gt;</kbd>, <kbd>&lt;collision&gt;</kbd>, and <kbd>&lt;gazebo&gt;</kbd>.</li>
<li class="mce-root">The Gmapping package in ROS is an implementation of Fast SLAM algorithm, which can be used in robot to map the environment and localizing on it. Using Gmapping in ROS is a straightforward process, including the gmapping node with necessary parameters and topics such as odometry and laser scan.</li>
<li class="mce-root">The <kbd>Move_base</kbd> node has a provision to handle various navigation subsystem in a robot. It is having a provision to handle global and local planner, also the map of the robot. Once the node receives the goal position, which feed to the navigation subsystem in order to reach to that goal position.</li>
<li class="mce-root">AMCL stands for Adaptive Monte Carlo Localization, which is an algorithm to localize a robot on a given map. There is a ROS package in ROS for deploying AMCL in our robot. We can launch the amcl node with proper input and necessary parameters.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 5,&#160;Designing ChefBot Hardware and Circuits</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">It is the process for finding proper robot hardware components for the robot that is meeting the robot desired specification. It also involves circuit designing and computing the current flow of each components in order to ensure the stability of the robot components.</li>
<li class="mce-root">It’s a switching circuit to control the direction and speed of an electric motor.</li>
<li class="mce-root">The main components are wheel encoder to compute wheel velocity and laser range finder or depth sensor to detect the obstacle around the robot.</li>
<li class="mce-root">We need to check whether it meets the specification of the robot.</li>
<li class="mce-root">Mapping, obstacle detection, object detection, and tracking.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 6,&#160;Interfacing Actuators and Sensors to the Robot Controller</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">Switching circuit in order to control the speed of motors in a robot.</li>
<li class="mce-root">A sensor that can detect the speed and direction of wheel rotation.</li>
<li class="mce-root">In the 4X encoding scheme, we are extracting the maximum transition between the encoder pulses in order to get more counts from a single rotation.</li>
<li class="mce-root">Using encoder count and distance per count, we can easily compute the displacement of the wheel.</li>
<li class="mce-root">It is a smart actuator having a motor and a microcontroller that can be directly interfaced to a PC and used to customize different settings of the actuator. It can be connected as daisy chain manner, which is appropriate for robotic arm.</li>
<li class="mce-root">It is the sensor for <span>finding&#160;</span>range and has one transmitter and one receiver. The transmitter transmits ultrasonic sound, and the receiver receives it. The delay between these process is used for distance measurement.</li>
<li class="mce-root">Range = high level time of echo pin output * velocity (340 M/S) / 2.</li>
<li class="mce-root">It is sending IR pulses and receive by an IR receiver. According to the distance, the voltage in the IR receiver changes, and we can compute the distance using the following equation:</li>
</ol>
<p style="padding-left: 90px" class="mce-root">Range = (6787 / (Volt - 3)) – 4</p>
<p>&#160;</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 7,&#160;Interfacing Vision Sensors with ROS</h1>
                </header>
            
            <article>
                
<ol>
<li>Most of the 3D depth sensors have additional vision sensors to detect the depth. It may be using IR projection method or using stereo vision.</li>
<li>The message passing interface, tools to visualize and debug robots, off-the-shelf robot algorithms.</li>
<li>OpenCV is mainly having computer vision algorithm, OpenNI is having algorithm implementation for implementing NI applications, and PCL is having algorithm to process point cloud data.</li>
</ol>
<ol start="4">
<li>It stands for Simultaneous Localization and Mapping. It is an algorithm commonly used to map the robot environment and localize on it at the same time.</li>
<li>It is an algorithm to map the robot environment in 3D.</li>
</ol>
<p>&#160;</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 8,&#160;Building ChefBot Hardware and Integration of Software</h1>
                </header>
            
            <article>
                
<ol>
<li>It is a mediator program between robot low-level controller and high-level controller such as PC. It converts the low-level data into ROS equivalent data.</li>
<li>PID is a control loop feedback mechanism to reach a robot goal position by taking feedback of robot position.</li>
<li>Using encoder data, we can compute the distance traversed by the robot using robot kinematic equations. Those values are odometry data.</li>
<li>It is mainly using for mapping the environment.</li>
<li>It is mainly using for localizing the robot in a static map.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 9,&#160;Designing a GUI for a Robot Using Qt and Python</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">Qt and GTK.</li>
<li class="mce-root">Both bindings are almost the same, only difference is in the name. The PyQt license is GPL and PySide comes with LGPL. Also, PySide is having much documentation about its APIs.</li>
<li class="mce-root">We can use Py UI compiler named pyuic.</li>
<li class="mce-root">Qt slots are functions in a program that can be triggered by Qt signal. For example, clicked is a signal that can invoke a function named <kbd>hello()</kbd>.</li>
<li class="mce-root">Rqt is one of the useful GUI tool in ROS. We can create rqt plugins and can insert in the rqt gui. There are existing plugins to do visualization, debugging, and so on in rqt.</li>
</ol>


            </article>

            
        </section>
    </div>
</body>
</html>