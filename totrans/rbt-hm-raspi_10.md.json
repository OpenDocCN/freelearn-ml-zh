["```py\nimport time\nimport board\nimport busio\nimport robot\nuart = busio.UART(board.GP12, board.GP13, baudrate=9600)\n```", "```py\nclass PController:\n    def __init__(self, kp):\n        self.kp = kp\n   def calculate(self, error):\n        return self.kp * error\n```", "```py\nrobot.right_distance.distance_mode = 1\nrobot.right_distance.start_ranging()\ndistance_set_point = 10\ndistance_controller = PController(-0.1)\n```", "```py\nwhile True:\n  if robot.right_distance.data_ready:\n    distance = robot.right_distance.distance\n```", "```py\n    error = distance_set_point – distance\n    speed = distance_controller.calculate(error)\n    uart.write(f\"{error},{speed}\\n\".encode())\n```", "```py\n    robot.set_left(speed)\n    robot.set_right(speed)\n```", "```py\n    robot.right_distance.clear_interrupt()\n    time.sleep(0.05)\n```", "```py\n    if abs(speed) < 0.3:\n      speed = 0\n```", "```py\nclass PIController:\n    def __init__(self, kp, ki):\n        self.kp = kp\n        self.ki = ki\n        self.integral = 0\n```", "```py\n    def calculate(self, error, dt):\n        self.integral += error * dt\n        return self.kp * error + self.ki * self.integral\n```", "```py\ndistance_controller = PIController(-0.19, -0.005) \n```", "```py\nprev_time = time.monotonic()\nwhile True:\n  if robot.right_distance.data_ready:\n    distance = robot.right_distance.distance\n    error = distance_set_point – distance\n    current_time = time.monotonic()\n    speed = distance_controller.calculate(error, current_time - prev_time)\n    prev_time = current_time\n    if abs(speed) < 0.3:\n      speed = 0\n    uart.write(f\"{error},{speed},\"\n      f\"{distance_controller.integral}\\n\".encode())\n    robot.set_left(speed)\n    robot.set_right(speed)\n    robot.right_distance.clear_interrupt()\n    time.sleep(0.05)\n```", "```py\nclass PIDController:\n    def __init__(self, kp, ki, kd, d_filter_gain=0.1):\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n        self.d_filter_gain = d_filter_gain\n        self.integral = 0\n        self.error_prev = 0\n```", "```py\n    def calculate(self, error, dt):\n        self.integral += error * dt\n        difference = (error - self.error_prev) * self.d_filter_gain\n        self.error_prev += difference\n        self.derivative = difference / dt\n        return self.kp * error + self.ki * self.integral + self.kd * self.derivative\n```", "```py\nimport time\nimport board\nimport busio\nimport robot\nfrom pid_controller import PIDController\nuart = busio.UART(board.GP12, board.GP13, baudrate=9600)\nrobot.right_distance.distance_mode = 1\nrobot.right_distance.start_ranging()\ndistance_set_point = 10\ndistance_controller = PIDController(-0.19, -0.008, -0.2)\nprev_time = time.monotonic()\nwhile True:\n  if robot.right_distance.data_ready:\n    distance = robot.right_distance.distance\n    error = distance_set_point – distance\n    current_time = time.monotonic()\n    speed = distance_controller.calculate(error, current_time - prev_time)\n    prev_time = current_time\n    if abs(speed) < 0.35:\n      speed = 0\n    uart.write(f\"{error},{speed}, {distance_controller.integral}, {distance_controller.derivative}\\n\".encode())\n    robot.set_left(speed)\n    robot.set_right(speed)\n    robot.right_distance.clear_interrupt()\n    time.sleep(0.05)\n```", "```py\nimport time\nimport board\nimport busio\nimport robot\nfrom pid_controller import PIDController\nuart = busio.UART(board.GP12, board.GP13, baudrate=9600)\nrobot.right_distance.distance_mode = 1\nrobot.right_distance.start_ranging()\n```", "```py\nspeed = 0.7\ndistance_set_point = 15\ndistance_controller = PIDController(0.05, 0.0, 0.0)\n```", "```py\nprev_time = time.monotonic()\nwhile True:\n  if robot.right_distance.data_ready:\n    distance = robot.right_distance.distance\n    error = distance_set_point - distance\n```", "```py\n    current_time = time.monotonic()\n    deflection = distance_controller.calculate(error, current_time - prev_time)\n    prev_time = current_time\n```", "```py\n    uart.write(f\"{error},{deflection}\\n\".encode())\n```", "```py\n    robot.set_left(speed - deflection)\n    robot.set_right(speed + deflection)\n```", "```py\n    robot.right_distance.clear_interrupt()\n    time.sleep(0.05)\n```", "```py\nmotor_A1 = pwmio.PWMOut(board.GP17, frequency=100)\nmotor_A2 = pwmio.PWMOut(board.GP16, frequency=100)\nmotor_B1 = pwmio.PWMOut(board.GP18, frequency=100)\nmotor_B2 = pwmio.PWMOut(board.GP19, frequency=100)\n```", "```py\nprev_time = time.monotonic()\nmotors_active = False\nwhile True:\n  if robot.right_distance.data_ready:\n    distance = robot.right_distance.distance\n    error = distance_set_point - distance\n    current_time = time.monotonic()\n    deflection = distance_controller.calculate(error, current_time - prev_time)\n    prev_time = current_time\n    uart.write(f\"{error},{deflection}\\n\".encode())\n    if motors_active:\n      robot.set_left(speed - deflection)\n      robot.set_right(speed + deflection)\n    robot.right_distance.clear_interrupt()\n    time.sleep(0.05)\n```", "```py\n  if uart.in_waiting:\n    command = uart.readline().decode().strip() \n```", "```py\n    if command.startswith(\"M\"):\n      speed = float(command[1:])\n```", "```py\n    elif command == \"G\":\n      motors_active = not motors_active\n      robot.set_left(0)\n      robot.set_right(0)\n      distance_controller.integral = 0\n```", "```py\n    elif command.startswith(\"P\"):\n      distance_controller.kp = float(command[1:])\n```", "```py\n    elif command.startswith(\"?\"):\n      uart.write(f\"P{distance_controller.kp:.3f}\\n\".encode())\n      uart.write(f\"I{distance_controller.ki:.3f}\\n\".encode())\n      uart.write(f\"D{distance_controller.kd:.3f}\\n\".encode())\n      uart.write(f\"M{speed:.1f}\\n\".encode())\n      time.sleep(3)\n```", "```py\nP0.045\nI0.000\nD0.000\nM0.7\n```", "```py\n    deflection = distance_controller.calculate(error, current_time - prev_time)\n    prev_time = current_time\n    uart.write(f\"{error},{deflection},\"\n      f\"{distance_controller.derivative}\\n\".encode())\n```", "```py\n    elif command.startswith(\"D\"):\n      distance_controller.kd = float(command[1:])\n```", "```py\n    elif command.startswith(\"I\"):\n      distance_controller.ki = float(command[1:])\n```"]