- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: LightGBM Models with PostgresML
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PostgresML的LightGBM模型
- en: In this chapter, we’ll look at a unique MLOps platform called **PostgresML**.
    PostgresML is a Postgres database extension that allows you to train and deploy
    ML models using SQL.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一个独特的MLOps平台，称为**PostgresML**。PostgresML是一个Postgres数据库扩展，允许您使用SQL训练和部署机器学习模型。
- en: PostgresML and SQL are a significant departure from the scikit-learn style of
    programming we’ve used throughout this book. However, as we’ll see in this chapter,
    performing ML model development and deployment at the database level has significant
    advantages regarding data movement requirements and inferencing latency.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: PostgresML和SQL与我们在本书中使用的scikit-learn编程风格有显著的不同。然而，正如我们在本章中将要看到的，在数据库级别进行机器学习模型开发和部署，在数据移动需求和推理延迟方面具有显著优势。
- en: 'The main topics in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要内容包括以下几方面：
- en: An overview of PostgresML
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgresML概述
- en: Getting started with PostgresML
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用PostgresML
- en: A customer churn case study with PostgresML and LightGBM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PostgresML和LightGBM的客户流失案例研究
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter includes practical examples of working with PostgresML. Docker
    will be used to set up a PostgresML environment and is recommended to run the
    examples. The code for this chapter is available at [https://github.com/PacktPublishing/Practical-Machine-Learning-with-LightGBM-and-Python/tree/main/chapter-10](https://github.com/PacktPublishing/Practical-Machine-Learning-with-LightGBM-and-Python/tree/main/chapter-10).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括使用PostgresML的实际示例。我们将使用Docker来设置PostgresML环境，并建议运行示例。本章的代码可在[https://github.com/PacktPublishing/Practical-Machine-Learning-with-LightGBM-and-Python/tree/main/chapter-10](https://github.com/PacktPublishing/Practical-Machine-Learning-with-LightGBM-and-Python/tree/main/chapter-10)找到。
- en: Introducing PostgresML
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍PostgresML
- en: PostgresML ([https://postgresml.org/](https://postgresml.org/)) is an extension
    for Postgres that allows practitioners to implement the entire ML life cycle on
    top of a Postgres database for text and tabular data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: PostgresML([https://postgresml.org/](https://postgresml.org/))是Postgres的一个扩展，允许从业者在一个Postgres数据库上实现整个机器学习生命周期，用于文本和表格数据。
- en: PostgresML utilizes SQL as the interface to train models, create deployments,
    and make predictions. The use of SQL means model and data operations can be combined
    seamlessly and fit naturally into Postgres DB data engineering environments.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: PostgresML利用SQL作为训练模型、创建部署和进行预测的接口。使用SQL意味着模型和数据操作可以无缝结合，并自然地融入Postgres数据库数据工程环境中。
- en: There are many advantages to having a shared data and ML platform. As we saw
    in the previous chapter, with SageMaker, significant effort is spent on moving
    data around. This is a common problem in ML environments where data, especially
    transactional data, lives in production databases, and complex data engineering
    workflows need to be created to extract data from production sources, transform
    the data for ML use, and load the data into a store that’s accessible to the ML
    platform (such as S3 for SageMaker).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个共享的数据和机器学习平台有许多优势。正如我们在上一章中看到的，使用SageMaker，在数据移动方面花费了大量的努力。这在机器学习环境中是一个常见问题，其中数据，尤其是事务数据，存在于生产数据库中，需要创建复杂的数据工程工作流程来从生产源提取数据，将数据转换为机器学习使用，并将数据加载到机器学习平台可访问的存储中（例如SageMaker的S3）。
- en: By combining the data store with the ML platform, PostgresML does away with
    moving data from one platform to another, saving significant time, effort, storage,
    and potentially egress costs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将数据存储与机器学习平台相结合，PostgresML消除了在平台之间移动数据的需求，节省了大量的时间、努力、存储，并可能节省出口成本。
- en: Further, modeling from live transactional data means that training data is always
    up to date (read directly from the system of record) instead of gated behind a
    refresh. This eliminates errors that stem from working with outdated data or data
    being transformed or loaded incorrectly by ETL jobs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从实时交易数据建模意味着训练数据始终是最新的（直接从记录系统中读取），而不是在刷新后受到限制。这消除了由于处理过时数据或ETL作业错误转换或加载数据而产生的错误。
- en: Latency and round trips
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟和往返次数
- en: A typical pattern for model deployment, which we’ve illustrated in earlier chapters,
    is deploying models behind a web API. In microservice terms, the model deployment
    is just another service that can be composed of other services to realize the
    overall system goal.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模型部署的典型模式，我们在前面的章节中已经展示过，是将模型部署在Web API后面。在微服务术语中，模型部署只是另一个服务，可以由其他服务组成以实现整体系统目标。
- en: Deployment as a web service has several advantages. First, interoperability
    with other systems is straightforward via network calls when using web standards
    such as REST. Second, it allows you to independently deploy the model code, isolated
    from the rest of the system, affording resilience and independent scaling.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为网络服务部署具有几个优点。首先，当使用如REST这样的网络标准进行网络调用时，与其他系统的互操作性简单直接。其次，它允许您独立部署模型代码，与系统其他部分隔离，提供弹性和独立扩展。
- en: 'However, deploying models as separate services also has a significant downside:
    latency and network round trips.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将模型作为独立服务部署也有显著的缺点：延迟和网络往返次数。
- en: 'Let’s consider an e-commerce example. A common ML problem in e-commerce settings
    is fraud detection. Here is a system architecture diagram of a simple e-commerce
    system:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个电子商务的例子。在电子商务环境中，一个常见的机器学习问题是欺诈检测。以下是简单电子商务系统的一个系统架构图：
- en: '![Figure 10.1 – Simplified e-commerce system architecture illustrating the
    interaction between functional services (transaction) and an ML-driven service
    (fraud detection)](img/B16690_10_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 简化的电子商务系统架构，说明了功能服务（交易）与机器学习驱动服务（欺诈检测）之间的交互](img/B16690_10_01.jpg)'
- en: Figure 10.1 – Simplified e-commerce system architecture illustrating the interaction
    between functional services (transaction) and an ML-driven service (fraud detection)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 简化的电子商务系统架构，说明了功能服务（交易）与机器学习驱动服务（欺诈检测）之间的交互
- en: 'Considering the architecture in *Figure 10**.1*, the flow for a new transaction
    proceeds as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到*图10.1*中的架构，新交易的流程如下：
- en: The transaction is sent to the transaction service.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交易被发送到交易服务。
- en: The transaction service calls the fraud detection service with the details of
    the new transaction.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交易服务使用新交易的详细信息调用欺诈检测服务。
- en: The fraud detection service receives the new transaction, loads the relevant
    model from model storage (if needed), loads historical data from the transaction
    storage, and responds to the transaction service with the prediction.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 欺诈检测服务接收新交易，从模型存储中加载相关模型（如果需要），从交易存储中加载历史数据，并将预测结果发送给交易服务。
- en: The transaction service receives the fraud prediction and stores the transaction
    with the relevant classification.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交易服务接收欺诈预测，并存储带有相关分类的交易。
- en: A few variations on this workflow might exist. However, due to the separation
    of the transaction and fraud detection services, many network round trips have
    to be made to process a new transaction. Making the fraud prediction also requires
    fetching historical data from the transaction storage to feed to the model.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在此工作流程上可能存在一些变体。然而，由于交易和欺诈检测服务的分离，处理一笔新交易需要多次网络往返。进行欺诈预测还需要从交易存储中获取历史数据以供模型使用。
- en: The networking call latency and round trips add significant overhead to the
    transaction. If the goal is to achieve a low-latency or real-time system, significantly
    more complex architectural components are required – for example, caching for
    the model and transactional data and higher throughput web services.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 网络调用延迟和往返次数给交易增加了显著的开销。如果目标是实现低延迟或实时系统，则需要更复杂的架构组件——例如，为模型和交易数据提供缓存以及更高吞吐量的网络服务。
- en: 'With PostgresML, the architecture may be simplified as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PostgresML，架构可以简化如下：
- en: '![Figure 10.2 – Combining the ML services with data storage using PostgresML
    allows for a more straightforward system design](img/B16690_10_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 使用PostgresML将机器学习服务与数据存储相结合，允许更简单的系统设计](img/B16690_10_02.jpg)'
- en: Figure 10.2 – Combining the ML services with data storage using PostgresML allows
    for a more straightforward system design
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 使用PostgresML将机器学习服务与数据存储相结合，允许更简单的系统设计
- en: Although this example is an oversimplification, the point is that significant
    overhead is added to the overall process of leveraging ML models in a service-oriented
    architecture with separate model services.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子过于简化，但重点是，在服务导向架构中使用独立模型服务利用机器学习模型的整体过程中，会添加显著的开销。
- en: Through PostgresML, we can eliminate the need for separate model storage and
    overheads of loading models and, importantly, combine data storage calls and predictions
    into a single call on the data storage layer with no network overhead in between.
    PostgresML’s benchmarks found that the simplified architecture improved performance
    by a factor of 40 within a cloud environment [1].
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过PostgresML，我们可以消除单独模型存储的需求，以及加载模型的额外开销，并且更重要的是，将数据存储调用和预测合并为数据存储层上的单个调用，中间没有网络开销。PostgresML的基准测试发现，在云环境中，简化的架构将性能提高了40倍[1]。
- en: However, there are also downsides to this architecture. First, the database
    is now a single point of failure. If the database is unavailable, all models and
    predictive capabilities are also unavailable. Second, the architecture mixes the
    concerns of data storage and ML modeling and inference. Depending on the use case,
    training and deploying ML models has different server infrastructure needs compared
    to serving SQL queries and storing data. The mixture of concerns might force you
    to compromise on one or the other responsibilities or significantly increase database
    infrastructure costs to support all use cases.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种架构也有缺点。首先，数据库现在是一个单点故障。如果数据库不可用，所有模型和预测能力也将不可用。其次，该架构将数据存储和机器学习建模与推理的关注点混合在一起。根据用例，训练和部署机器学习模型与提供SQL查询和存储数据相比，有不同的服务器基础设施需求。关注点的混合可能迫使你在一项或另一项责任上做出妥协，或者显著增加数据库基础设施成本以支持所有用例。
- en: In this section, we introduced PostgresML and explained, at a conceptual level,
    the advantages of combining our data store and ML service. Now, we’ll look at
    practically setting up and getting started with PostgresML, alongside some basic
    functionality.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了PostgresML，并在概念层面上解释了将我们的数据存储和机器学习服务结合起来的优势。现在，我们将探讨实际设置和开始使用PostgresML，以及一些基本功能。
- en: Getting started with PostgresML
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用PostgresML
- en: PostgresML, of course, relies on PostgreSQL being installed. PostgresML requires
    PostgreSQL 11, with newer versions also supported. PostgresML also requires Python
    3.7+ to be installed on your system. Both ARM and Intel/AMD architectures are
    supported.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，PostgresML依赖于已安装的PostgreSQL。PostgresML需要PostgreSQL 11，同时也支持更新的版本。PostgresML还需要在您的系统上安装Python
    3.7+。支持ARM和Intel/AMD架构。
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This section provides an overview of the steps and dependencies required to
    start working with PostgresML and the features at the time of writing. For up-to-date
    information, check out the official [website: https://postg](https://postgresml.org/)resml.org/.
    The simplest way to run PostgresML is to use Docker. For more information, check
    out the *Quick Start with Docker* documentation: [https://postgresml.org/docs/guides/setup/quick_start_with_docker](https://postgresml.org/docs/guides/setup/quick_start_with_docker).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了开始使用PostgresML及其在撰写时的功能所需的步骤和依赖项。对于最新信息，请查看官方[网站：https://postg](https://postgresml.org/)resml.org/。运行PostgresML最简单的方法是使用Docker。更多信息，请参阅*使用Docker快速入门*文档：[https://postgresml.org/docs/guides/setup/quick_start_with_docker](https://postgresml.org/docs/guides/setup/quick_start_with_docker)。
- en: 'The extension can be installed with official package tools (such as APT) or
    compiled from sources. Once all the dependencies and the extension have been installed,
    `postgresql.conf` must be updated to load the PostgresML library, and the database
    server must be restarted:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该扩展可以使用官方包工具（如APT）安装，或者从源代码编译。一旦所有依赖项和扩展都已安装，必须更新`postgresql.conf`以加载PostgresML库，并且必须重新启动数据库服务器：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With PostgresML installed, the extension must be created within the database
    you plan to use. This can be done in the regular PostgreSQL way from a SQL console:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 安装PostgresML后，必须在您计划使用的数据库中创建扩展。这可以通过常规的PostgreSQL方式在SQL控制台中完成：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Verify the installation, like so:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 检查安装，如下所示：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Training models
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 训练模型
- en: Now, let’s look at the features provided by PostgresML. As stated in the introduction,
    PostgresML has a SQL API. The following code examples should be run in a SQL console.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看PostgresML提供的功能。如介绍中所述，PostgresML有一个SQL API。以下代码示例应在SQL控制台中运行。
- en: 'The extension function for training a model is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 训练模型的扩展函数如下：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We need to supply `project_name` as the first parameter. PostgresML organizes
    models and deployments into projects, and projects are uniquely identified by
    their names.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供`project_name`作为第一个参数。PostgresML将模型和部署组织到项目中，项目通过其名称唯一标识。
- en: 'Next, we specify the model’s `task`: either classification or regression. `relation_name`
    and `y_column_name` set up the data for the training run. The relation is the
    table or view where the data is defined, and the Y column’s name specifies the
    target column within the relation.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指定模型的`任务`：分类或回归。`relation_name`和`y_column_name`设置训练运行所需的数据。关系是定义数据的数据表或视图，Y列的名称指定关系中的目标列。
- en: 'These are the only required parameters for training. Training a linear model
    (the default) can be done as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是训练所需的唯一参数。训练线性模型（默认）可以如下进行：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When `pgml.train` is called, PostgresML copies the data into the `pgml` schema:
    this ensures all training runs are reproducible and enables training to be rerun
    using different algorithms or parameters but the same data. `relation_name` and
    `task` are also only required the very first time training is done for a project.
    To train a second model for a project, we can simplify the training call like
    so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`pgml.train`时，PostgresML将数据复制到`pgml`模式中：这确保所有训练运行都是可重复的，并允许使用不同的算法或参数但相同的数据重新运行训练。`relation_name`和`task`也仅在项目第一次进行训练时需要。要为项目训练第二个模型，我们可以简化训练调用如下：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When calling this code, a LightGBM regression model is trained on the same data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此代码时，将在相同的数据上训练一个LightGBM回归模型。
- en: The algorithm parameter sets the learning algorithm to use. PostgresML supports
    various algorithms, including LightGBM, XGBoost, scikit-learn’s random forests
    and extra trees, **support vector machines** (**SVMs**), linear models, and unsupervised
    algorithms such as K-means clustering.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 算法参数设置要使用的学习算法。PostgresML支持各种算法，包括LightGBM、XGBoost、scikit-learn的随机森林和额外树，**支持向量机**（**SVMs**）、线性模型以及如K-means聚类的无监督算法。
- en: By default, 25% of the data is used as a test set, and the test data is selected
    at random. This can be controlled with the `test_size` and `test_sampling` parameters.
    Alternative test sampling methods select data from the first or last rows.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，25%的数据用作测试集，测试数据是随机选择的。这可以通过`test_size`和`test_sampling`参数进行控制。替代测试采样方法从第一行或最后一行选择数据。
- en: Hyperparameter optimization
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超参数优化
- en: 'PostgresML supports performing `search`: grid search and random search. To
    set the hyperparameter ranges for the HPO, a JSON object is used with the `search_params`
    parameter. HPO parameters are specified using `search_args`. Here’s an example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: PostgresML支持执行`搜索`：网格搜索和随机搜索。要设置HPO的超参数范围，使用带有`search_params`参数的JSON对象。使用`search_args`指定HPO参数。以下是一个示例：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Preprocessing
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预处理
- en: PostgresML also supports performing certain types of preprocessing when training
    a model. As with the training data and configuration, the preprocessing is also
    stored with the project, so the same preprocessing can be applied when using a
    model for predictions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: PostgresML还支持在训练模型时执行某些类型的预处理。与训练数据和配置一样，预处理也存储在项目中，因此可以在使用模型进行预测时应用相同的预处理。
- en: 'Regarding pre-processing, PostgresML supports encoding categorical variables,
    imputing missing values, and scaling numerical values. Preprocessing rules are
    set using a JSON object via the `preprocess` parameter, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于预处理，PostgresML支持对分类变量进行编码、填充缺失值和对数值进行缩放。预处理规则使用JSON对象通过`preprocess`参数设置，如下所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we applied ordinal encoding for the model feature. Alternatively, PostgresML
    also supports one-hot encoding and target encoding. We also imported missing values
    (as indicated by `NULL` in the column) using the mean of the price and applied
    standard (normal) scaling to the price and the fuel economy features.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对模型特征应用了序数编码。或者，PostgresML还支持独热编码和目标编码。我们还使用价格的平均值导入缺失值（如列中的`NULL`所示），并对价格和燃油经济性特征应用了标准（正态）缩放。
- en: Deploying and prediction
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署和预测
- en: PostgresML automatically calculates appropriate metrics on the test set after
    training, including R 2, the F1 score, precision, recall, `ROC_AUC`, accuracy
    and log loss. PostgresML will then automatically deploy the model after training
    if the key metric for the model (R 2 for regression and F1 for classification)
    improves over the currently deployed model.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 训练后，PostgresML会自动在测试集上计算适当的指标，包括R²、F1分数、精确度、召回率、`ROC_AUC`、准确率和对数损失。如果模型的键指标（回归的R²和分类的F1）比当前部署的模型有所提高，PostgresML将在训练后自动部署模型。
- en: 'However, deployments can also be managed manually for a project with the `pgml.deploy`
    function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也可以使用`pgml.deploy`函数手动管理项目的部署：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The deployment strategies supported by PostgresML are `best_score`, which immediately
    deploys the model with the best key metrics; `most_recent`, which deploys the
    most recently trained model; and `rollback`, which rolls back the current deployment
    to the previously deployed model.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: PostgresML支持的部署策略有`best_score`，它立即部署具有最佳关键指标的模型；`most_recent`，它部署最近训练的模型；以及`rollback`，它将当前部署回滚到之前部署的模型。
- en: 'With a model deployed, predictions can be made with the `pgml.predict` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 部署模型后，可以使用`pgml.predict`函数进行预测：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `pgml.predict` function accepts the project name and the features for prediction.
    Features may be either arrays or composite types.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`pgml.predict`函数接受项目名称和预测特征。特征可以是数组或复合类型。'
- en: PostgresML dashboard
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PostgresML仪表板
- en: PostgresML provides a web-based dashboard for a more accessible interface to
    PostgresML features. The dashboard is deployed separately from PostgreSQL and
    is not required for administration or fully utilizing PostgresML features as all
    functionality is also accessible via SQL queries.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: PostgresML提供了一个基于Web的仪表板，以便更方便地访问PostgresML的功能。仪表板是独立于PostgreSQL部署的，不是管理或充分利用PostgresML功能所必需的，因为所有功能也可以通过SQL查询访问。
- en: 'The dashboard provides access to a list of projects, models, deployments, and
    data snapshots. More details can also be found on trained models via the dashboard,
    including hyperparameter settings and training metrics:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板提供了访问项目、模型、部署和数据快照的列表。有关训练模型的更多详细信息也可以在仪表板中找到，包括超参数设置和训练指标：
- en: '![Figure 10.3 – PostgresML dashboard showing a list of trained models](img/B16690_10_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 显示已训练模型列表的PostgresML仪表板](img/B16690_10_03.jpg)'
- en: Figure 10.3 – PostgresML dashboard showing a list of trained models
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 显示已训练模型列表的PostgresML仪表板
- en: Besides offering a view of projects, models, and deployments, the dashboard
    also allows the creation of SQL notebooks, similar to Jupyter Notebooks. These
    SQL notebooks provide a simple interface to interact with PostgresML if another
    SQL console is not readily available.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供项目、模型和部署的视图外，仪表板还允许创建SQL笔记本，类似于Jupyter笔记本。这些SQL笔记本提供了一个简单的界面，用于与PostgresML交互，如果另一个SQL控制台不可用的话。
- en: This concludes our section on getting started with PostgresML. Next, we’ll look
    at an end-to-end case study of training and deploying a PostgresML model.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们关于开始使用PostgresML的部分。接下来，我们将查看一个从头到尾的案例研究，即训练和部署PostgresML模型。
- en: Case study – customer churn with PostgresML
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究 – 使用PostgresML进行客户流失分析
- en: Let’s revisit the customer churn problem for a telecommunications provider.
    As a reminder, the dataset consists of customers and their account and cost information
    associated with the telecommunication provider.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下电信提供商的客户流失问题。提醒一下，数据集包括客户及其与电信提供商相关的账户和成本信息。
- en: Data loading and preprocessing
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据加载和预处理
- en: 'Our data will typically already be available within the PostgreSQL database
    in a real-world setting. However, for our example, we will start by loading the
    data. First, we must create the table the data is loaded into:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的设置中，我们的数据通常已经存在于PostgreSQL数据库中。然而，在我们的示例中，我们将从加载数据开始。首先，我们必须创建数据加载到的表：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that in our table structure, for a few of our columns, the types do not
    match what we may expect: for example, monthly and total charges should be real
    values. We’ll address this during our preprocessing.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们的表结构中，对于一些列，类型可能不符合我们的预期：例如，月度和总费用应该是实数值。我们将在预处理阶段解决这个问题。
- en: 'Next, we can load our CSV data into the table. PostgreSQL provides a `COPY`
    statement for this purpose:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以将我们的CSV数据加载到表中。PostgreSQL提供了一个`COPY`语句来完成此目的：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Running this statement reads the CSV file and adds the data to our table.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此语句将读取CSV文件并将数据添加到我们的表中。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you run PostgresML in a Docker container (which is recommended to get started),
    the CSV file must first be copied to the container runtime. This can be done with
    the following command (substituting your own container name):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个Docker容器中运行PostgresML（推荐以开始使用），必须首先将CSV文件复制到容器运行时。可以使用以下命令完成此操作（替换为你自己的容器名称）：
- en: '`docker cp` `telco/telco-churn.csv postgresml-postgres-1:/tmp/telco-churn.csv`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker cp` `telco/telco-churn.csv postgresml-postgres-1:/tmp/telco-churn.csv`。'
- en: 'With the data loaded, we can perform our preprocessing. We perform this in
    three steps: cleaning data directly in the table, creating a table view that coerces
    the data to appropriate types, and using PostgresML’s preprocessing functionality:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加载后，我们可以进行预处理。我们分三步进行：在表中直接清理数据，创建一个将数据强制转换为适当类型的表视图，并使用PostgresML的预处理功能：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We must replace the empty text values in total charges with `NULL`, allowing
    PostgresML to impute the values later:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将总费用中的空文本值替换为`NULL`，以便PostgresML稍后填充这些值：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We then create a view to prepare the data for training. Notably, two type transformations
    are performed: features with `Yes`/`No` values are mapped to booleans, and we
    cast our monthly and total charges to `REAL` values (after mapping the text values
    to `NULL`). We also exclude `CustomerId` from the view as this can’t be used for
    training.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个视图来准备训练数据。值得注意的是，执行了两种类型转换：具有`Yes`/`No`值的特征被映射到布尔类型，我们将月度和总费用转换为`REAL`类型（在将文本值映射到`NULL`之后）。我们还从视图中排除了`CustomerId`，因为这不能用于训练。
- en: Training and hyperparameter optimization
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 训练和超参数优化
- en: 'We can train our LightGBM model as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式训练我们的LightGBM模型：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We set the view as our relation, with the churn column being our target feature.
    For preprocessing, we use the mean to ask PostgresML to impute missing values
    for the `totalcharges` feature.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将视图设置为我们的关系，其中churn列是我们的目标特征。对于预处理，我们使用平均值来请求PostgresML为`totalcharges`特征填充缺失值。
- en: We also set up hyperparameter optimization using 500 iterations of a random
    search with the specified search parameter ranges.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用随机搜索的500次迭代和指定的搜索参数范围来设置超参数优化。
- en: 'After completing training, we will be able to see our trained and deployed
    model in the dashboard:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 完成训练后，我们将在仪表板中看到我们的训练和部署好的模型：
- en: '![Figure 10.4 – Trained LightGBM model, as seen in the PostgresML dashboard](img/B16690_10_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 在PostgresML仪表板中看到的训练好的LightGBM模型](img/B16690_10_04.jpg)'
- en: Figure 10.4 – Trained LightGBM model, as seen in the PostgresML dashboard
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 在PostgresML仪表板中看到的训练好的LightGBM模型
- en: The dashboard shows the metrics for our model and the best-performing hyperparameters.
    Our model achieved an F1 score of 0.6367 and an accuracy of 0.8239.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板显示了我们的模型指标和最佳性能的超参数。我们的模型实现了F1分数为0.6367和准确度为0.8239。
- en: 'The same information can also be retrieved with the following SQL query should
    the dashboard be unavailable:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仪表板不可用，可以使用以下SQL查询检索相同的信息：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our model is automatically deployed when trained and is ready to make predictions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 训练完成后，我们的模型将自动部署并准备好进行预测。
- en: Predictions
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预测
- en: 'We can make predictions manually using a composite type as the feature data.
    This can be done as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用复合类型作为特征数据手动进行预测。这可以按照以下方式完成：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We use the PostgreSQL `ROW` expression to set up the data, casting literals
    to the correct types for our model.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用PostgreSQL的`ROW`表达式来设置数据，将字面量转换为模型正确的类型。
- en: 'However, the more common way to leverage a PostgresML model is to incorporate
    predictions into regular business queries. For example, here, we’ve selected all
    the data from the original customer data table and added the prediction for each
    row using the `pgml.predict` function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，利用PostgresML模型更常见的方式是将预测纳入常规业务查询中。例如，在这里，我们已从原始客户数据表中选择了所有数据，并使用`pgml.predict`函数为每一行添加了预测：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Similar to calling the predict function manually, we use the `ROW` expression
    to pass data to the `pgml.predict` function but select the data from the table.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与手动调用预测函数类似，我们使用`ROW`表达式将数据传递给`pgml.predict`函数，但选择数据来自表。
- en: 'This also clearly illustrates the advantage of using PostgresML: a consumer
    of the ML model could query new customer data alongside the predictions with minimal
    overhead and in the same business transaction with a single network call.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这也清楚地说明了使用PostgresML的优势：ML模型的消费者可以在单个网络调用中，以最小的开销，在同一个业务事务中查询新的客户数据并获取预测。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided an overview of PostgresML, a unique MLOps platform that
    allows training and calling models from SQL queries on top of an existing PostgreSQL
    database.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了PostgresML的概述，这是一个独特的MLOps平台，允许在现有的PostgreSQL数据库上通过SQL查询训练和调用模型。
- en: We discussed the platform’s advantages in simplifying an ML-enabled landscape
    and reducing overhead and network latency in a service-oriented architecture.
    An overview of the core features and the API was provided.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了该平台在简化支持机器学习的景观以及降低面向服务架构中的开销和网络延迟方面的优势。提供了核心功能和API的概述。
- en: This chapter concluded with a practical example of leveraging PostgresML for
    a classification problem, illustrating how to train a LightGBM model, perform
    hyperparameter optimization, deploy it, and leverage it for predictions in a handful
    of SQL queries.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以一个利用PostgresML解决分类问题的实际例子结束，展示了如何训练LightGBM模型，执行超参数优化，部署它，并在几个SQL查询中利用它进行预测。
- en: In the next chapter, we will look at distributed and GPU-based learning with
    LightGBM.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用LightGBM的分布式和基于GPU的学习。
- en: References
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '| *[**1]* | *PostgresML is 8-40x faster than Python HTTP microservices, [Online].
    Available* *at* [*https://postgresml.org/blog/postgresml-is-8x-faster-than-python-http-microservices*](https://postgresml.org/blog/postgresml-is-8x-faster-than-python-http-microservices)*.*
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| *[**1]* | *PostgresML比Python HTTP微服务快8-40倍，[在线]. 可在* [*https://postgresml.org/blog/postgresml-is-8x-faster-than-python-http-microservices*](https://postgresml.org/blog/postgresml-is-8x-faster-than-python-http-microservices)*找到。*
    |'
