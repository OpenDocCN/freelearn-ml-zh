["```py\nGMM gmm(num_clusters, /*dimensionality*/ 2);\nKMeans<> kmeans;\nsize_t max_iterations = 250;\ndouble tolerance = 1e-10;\nEMFit<KMeans<>, NoConstraint> em(max_iterations, tolerance, kmeans);\ngmm.Train(inputs, /*trials*/ 3, /*use_existing_model*/ false, em);\n```", "```py\narma::Row<size_t> assignments;\ngmm.Classify(inputs, assignments);\nClusters plot_clusters;\nfor (size_t i = 0; i != inputs.n_cols; ++i) {\n  auto cluser_idx = assignments[i];\n  plot_clusters[cluser_idx].first.push_back(inputs.at(0, i));\n  plot_clusters[cluser_idx].second.push_back(inputs.at(1, i));\n  }\nPlotClusters(plot_clusters, \"GMM\", name + \"-gmm.png\");\n```", "```py\narma::Row<size_t> assignments;\nKMeans<> kmeans;\nkmeans.Cluster(inputs, num_clusters, assignments);\n```", "```py\nClusters plot_clusters;\nfor (size_t i = 0; i != inputs.n_cols; ++i) {\n  auto cluser_idx = assignments[i];\n  plot_clusters[cluser_idx].first.push_back(inputs.at(0, i));\n  plot_clusters[cluser_idx].second.push_back(inputs.at(1, i));\n}\nPlotClusters(plot_clusters, \"K-Means\", name + \"-kmeans.png\");\n```", "```py\nDBSCAN<> dbscan(/*epsilon*/ 0.1, /*min_points*/ 15);\n```", "```py\ndbscan.Cluster(inputs, assignments);\n```", "```py\nMeanShift<> mean_shift;\nauto radius = mean_shift.EstimateRadius(inputs);\nmean_shift.Radius(radius);\n```", "```py\narma::Row<size_t> assignments;\narma::mat centroids;\nmean_shift.Cluster(inputs, assignments, centroids);\n```", "```py\n typedef matrix<double, 2, 1> sample_type;\n typedef radial_basis_kernel<sample_type> kernel_type;\n```", "```py\nkcentroid<kernel_type> kc(kernel_type(0.1), 0.01, 8);\nkkmeans<kernel_type> kmeans(kc);\n```", "```py\nstd::vector<sample_type> samples; //training dataset\n...\nsize_t num_clusters = 2;\nstd::vector<sample_type> initial_centers;\npick_initial_centers(num_clusters,\n                     initial_centers,\n                     samples,\n                     kmeans.get_kernel());\n```", "```py\nkmeans.set_number_of_centers(num_clusters);\nkmeans.train(samples, initial_centers);\nfor (size_t i = 0; i != samples.size(); i++) {\n  auto cluster_idx = kmeans(samples[i]);\n  ...\n}\n```", "```py\ntypedef matrix<double, 2, 1> sample_type;\ntypedef knn_kernel<sample_type> kernel_type;\n...\nstd::vector<sample_type> samples;\n...\nstd::vector<unsigned long> clusters =\nspectral_cluster(kernel_type(samples, 15),\n                 samples,\n                 num_clusters);\n```", "```py\nmatrix<double> dists(inputs.nr(), inputs.nr());\nfor (long r = 0; r < dists.nr(); ++r) {\n  for (long c = 0; c < dists.nc(); ++c) {\n    dists(r, c) = length(subm(inputs, r, 0, 1, 2) -\n                         subm(inputs, c, 0, 1, 2));\n  }\n}\nstd::vector<unsigned long> clusters;\nbottom_up_cluster(dists, clusters, num_clusters);\n```", "```py\nfor (long i = 0; i < inputs.nr(); ++i) {\n  for (long j = 0; j < inputs.nr(); ++j) {\n    auto dist = length(subm(inputs, i, 0, 1, 2) -\n                       subm(inputs, j, 0, 1, 2));\n    if (dist < 0.5)\n      edges.push_back(sample_pair(i, j, dist));\n  }\n}\nremove_duplicate_edges(edges);\nstd::vector<unsigned long> clusters;\nconst auto num_clusters = newman_cluster(edges, clusters);\n```", "```py\nstd::vector<sample_pair> edges;\nfor (long i = 0; i < inputs.nr(); ++i) {\n  for (long j = 0; j < inputs.nr(); ++j) {\n    auto dist = length(subm(inputs, i, 0, 1, 2) -\n                       subm(inputs, j, 0, 1, 2));\n    if (dist < 1)\n      edges.push_back(sample_pair(i, j, dist));\n  }\n}\nstd::vector<unsigned long> clusters;\nconst auto num_clusters = chinese_whispers(edges,clusters);\n```", "```py\n// Define helper data types for point clusters coordinates\n// Container type for single coordinate values\nusing Coords = std::vector<DataType>;\n// Paired x, y coordinate containers\nusing PointCoords = std::pair<Coords, Coords>;\n// Clusters mapping container\nusing Clusters = std::unordered_map<index_t, PointCoords>;\n// define color values container\nconst std::vector<std::string> colors{\n    \"black\", \"red\",    \"blue\",  \"green\",\n    \"cyan\",  \"yellow\", \"brown\", \"magenta\"};\n...\n    // Function for clusters visualization\n    void\n    PlotClusters(const Clusters& clusters,\n                 const std::string& name,\n                 const std::string& file_name) {\n  // Instantiate plotting object\n  plotcpp::Plot plt;\n  // Configure plotting object\n  plt.SetTerminal(\"png\");\n  plt.SetOutput(file_name);\n  plt.SetTitle(name);\n  plt.SetXLabel(\"x\");\n  plt.SetYLabel(\"y\");\n  plt.SetAutoscale();\n  plt.gnuplotCommand(\"set grid\");\n  // Start 2D scatter plot drawing\n  auto draw_state =\n      plt.StartDraw2D<Coords::const_iterator>();\n  for (auto& cluster : clusters) {\n    std::stringstream params;\n    // Configure cluster visualization color string\n    params << \"lc rgb '\" << colors[cluster.first]\n           << \"' pt 7\";\n    // Create cluster name string\n    auto cluster_name =\n        std::to_string(cluster.first) + \" cls\";\n    // Create points visualization object using \"cluster\"\n    // points\n    plotcpp::Points points(cluster.second.first.begin(),\n                           cluster.second.first.end(),\n                           cluster.second.second.begin(),\n                           cluster_name, params.str());\n       // Add current cluster visualization to the 2D scatter\n    // plot\n    plt.AddDrawing(draw_state, points);\n  }\n  // Finalize 2D scatter plot\n  plt.EndDraw2D(draw_state);\n  // Render the plot\n  plt.Flush();\n}\n```"]