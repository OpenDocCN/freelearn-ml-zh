- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Evaluating Performance Metrics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估性能指标
- en: No model of a real-world phenomenon is perfect. There are countless statistical
    assumptions made about the underlying data, there is noise in the measurements,
    and there are unknown and unmodeled factors that contribute to the output. But
    even though it is not perfect, a good model is still informative and valuable.
    So, how do you know whether you have such a good model? How can you be sure your
    predictions for the future can be trusted? **Cross-validation** got us part of
    the way there, by providing a technique to compare unbiased predictions to actual
    values. This chapter is all about how to compare different models.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 任何真实世界现象的模型都不是完美的。关于基础数据做出了无数统计假设，测量中存在噪声，还有未知和未建模的因素会影响输出。尽管如此，一个好的模型仍然是信息丰富且宝贵的。那么，您如何知道您是否拥有这样一个好的模型？您如何确保您的未来预测是可信的？**交叉验证**通过提供一种比较无偏预测与实际值的技术，使我们前进了一步。本章全部关于如何比较不同的模型。
- en: Prophet features several different metrics that are used for comparing your
    actual values with your predicted values, so you can quantify the performance
    of your model. This tells you how good your model actually is and whether you
    can trust the predictions, and helps you compare the performance of different
    models so you can choose which one is best.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet提供了几个不同的指标，用于比较您的实际值与预测值，因此您可以量化模型的性能。这告诉您模型实际上有多好，您是否可以信任预测，并帮助您比较不同模型的性能，以便您选择最好的一个。
- en: 'This chapter will teach you about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教授您以下内容：
- en: Understanding Prophet’s metrics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Prophet的指标
- en: Creating a Prophet performance metrics DataFrame
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Prophet性能指标DataFrame
- en: Handling irregular cut-offs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理不规则截止点
- en: Tuning hyperparameters with grid search
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网格搜索调整超参数
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The data files and code for examples in this chapter can be found at [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章示例的数据文件和代码可以在[https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition)找到。
- en: Understanding Prophet’s metrics
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Prophet的指标
- en: Prophet’s `diagnostics` package provides six different metrics you can use to
    evaluate your model. Those metrics are mean squared error, root mean squared error,
    mean absolute error, mean absolute percent error, median absolute percent error,
    and coverage. We’ll discuss each of these in turn.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet的`diagnostics`包提供了六个不同的指标，您可以使用这些指标来评估您的模型。这些指标包括均方误差、均方根误差、平均绝对误差、平均绝对百分比误差、中位数绝对百分比误差和覆盖率。我们将依次讨论这些指标。
- en: Mean squared error
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 均方根误差
- en: '**Mean squared error** (**MSE**) is the sum of the squared difference between
    each predicted value and the actual value, as can be seen in the following equation:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**均方误差**（**MSE**）是每个预测值与实际值之间平方差的和，如下公式所示：'
- en: '|  | ![](img/B19630_13_F01.jpg) | (1) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  | ![图片](img/B19630_13_F01.jpg) | (1) |'
- en: The number of samples is represented in the preceding equation by ![](img/B19630_13_F02.png),
    where ![](img/B19630_13_F03.png) is an actual value and ![](img/B19630_13_F14.png)
    is a forecasted value.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方程式中，样本数量由![](img/B19630_13_F02.png)表示，其中![](img/B19630_13_F03.png)是实际值，![](img/B19630_13_F14.png)是预测值。
- en: MSE may be the most used performance metric, but it does have its downside.
    Because it is not scaled to the data, its value is not easy to interpret – the
    unit of MSE is the square of your `y` unit. It is also sensitive to outliers,
    although this may be either desirable or undesirable, depending upon your data
    and interpretation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: MSE可能是最常用的性能指标，但它确实有其缺点。因为它没有缩放到数据，其值不易解释——MSE的单位是`y`单位的平方。它也容易受到异常值的影响，尽管这可能是所希望的也可能是所不希望的，这取决于您的数据和解释。
- en: However, it remains popular because it can be proven that MSE is equal to the
    bias squared plus the variance, so minimizing this metric can reduce both bias
    and variance. MSE is never negative and the closer it is to zero, the better the
    model.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它仍然很受欢迎，因为它可以证明均方误差等于偏差平方加方差，因此最小化这个指标可以减少偏差和方差。均方误差永远不会是负数，它越接近零，模型就越好。
- en: Root mean squared error
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 均方根误差
- en: 'If you scale MSE to the same units as that of your data by taking the square
    root, you arrive at the **root mean squared** **error** (**RMSE**):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过取平方根将MSE缩放到与数据相同的单位，您将得到**均方根****误差**（**RMSE**）：
- en: '|  | ![](img/B19630_13_F05.png) | (2) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|  | ![](img/B19630_13_F05.png) | (2) |'
- en: RMSE shares the same advantages and disadvantages as MSE, although its units
    are more interpretable. As with MSE, it places more importance on points with
    large errors than those with small errors.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: RMSE与MSE具有相同的优缺点，尽管其单位更具可解释性。与MSE一样，它对误差大的点的重视程度高于误差小的点。
- en: Mean absolute error
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 均值绝对误差
- en: '**Mean absolute error** (**MAE**) is similar to MSE except that it takes the
    absolute value of the error, not the square:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**均值绝对误差**（**MAE**）与MSE相似，但它取误差的绝对值而不是平方：'
- en: '|  | ![](img/B19630_13_F06.png) | (3) |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  | ![](img/B19630_13_F06.png) | (3) |'
- en: MAE, in contrast with MSE and RMSE, weighs each error equally; it does not place
    more importance on outliers or points with uncommonly high errors. Like MSE though,
    MAE is not scaled to the data. So, if you find that your model reports an MAE
    of, say, 10, is this good or bad? If the average value in your dataset is 1,000,
    then an error of 10 would be just 1%. If the average of your data is 1, though,
    then an MAE of 10 would mean your predictions are off by 1,000%!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与MSE和RMSE不同，MAE对每个误差的权重相同；它不对异常值或误差异常高的点给予更多重视。尽管如此，MAE与MSE一样，并没有根据数据来缩放。因此，如果你发现你的模型报告的MAE为10，那么这是好是坏？如果你的数据集的平均值为1,000，那么10的误差仅占1%。然而，如果你的数据平均值为1，那么10的MAE意味着你的预测误差为1,000%！
- en: 'In order to scale MAE to the data, it will often be divided by the data’s mean
    value, to arrive at a percentage:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将MAE缩放到数据，它通常会被除以数据的平均值，从而得到一个百分比：
- en: '|  | ![](img/B19630_13_F07.png) | (4) |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|  | ![](img/B19630_13_F07.png) | (4) |'
- en: This format for MAE is not supported in Prophet, although you can create it
    yourself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式的MAE在Prophet中不受支持，尽管你可以自己创建它。
- en: Mean absolute percent error
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 均值绝对百分比误差
- en: '**Mean absolute percent error** (**MAPE**) is another very common metric despite
    its poor ability to represent the performance of a model. Not to be confused with
    the total MAE divided by the mean value, MAPE divides each error by the value
    of the data point at that error:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**均值绝对百分比误差**（**MAPE**）尽管其表示模型性能的能力较差，但仍然是一个非常常见的指标。不要与将总MAE除以平均值混淆，MAPE将每个误差除以该误差处的数据点值：'
- en: '|  | ![](img/B19630_13_F08.png) | (5) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|  | ![](img/B19630_13_F08.png) | (5) |'
- en: This makes the metric skewed to overly represent errors that occur when the
    data values are low. For this reason, MAPE is considered asymmetric—it puts a
    heavier penalty on negative errors (when the forecast is higher than the actual
    result) than on positive errors. Optimizing for MAPE will often leave your model
    undershooting the values it is targeting. Furthermore, because you are dividing
    by each ![](img/B19630_13_F09.png) value, if any of them are zero, then the calculation
    will produce a division-by-zero error. Very small values of ![](img/B19630_13_F10.png)
    will also cause floating-point calculation problems. Prophet will detect whether
    any ![](img/B19630_13_F11.png) values are at or near zero and if found, it will
    simply skip MAPE calculations and proceed to the other metrics called for. The
    upside to MAPE, though, is that it has natural interpretability – it is easy to
    intuitively understand.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得该指标偏向于过度表示数据值较低时发生的误差。因此，MAPE被认为是不对称的——它对负误差（预测值高于实际结果）的惩罚比对正误差的惩罚更重。优化MAPE通常会使得你的模型未能达到目标值。此外，由于你正在除以每个![](img/B19630_13_F09.png)值，如果其中任何一个为零，则计算将产生除以零的错误。非常小的![](img/B19630_13_F10.png)值也会导致浮点计算问题。Prophet将检测是否有任何![](img/B19630_13_F11.png)值在或接近零，如果发现，它将简单地跳过MAPE计算并继续进行其他指标。然而，MAPE的优点是它具有自然的可解释性——它很容易直观理解。
- en: Median absolute percent error
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中值绝对百分比误差
- en: '**Median absolute percent error** (**MdAPE**) is the same as MAPE, except it
    uses the median instead of the mean. It can be useful with noisy data when MAPE
    may be the preferred metric but too many outliers are swaying it. For example,
    significant holidays can create large spikes in data and the median is able to
    smooth out predictions if MAPE experiences issues.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**中值绝对百分比误差**（**MdAPE**）与MAPE相同，只是它使用中位数而不是平均值。当MAPE可能是首选指标但存在太多异常值时，它可能很有用。例如，重要的节假日可能会在数据中产生大的峰值，而中位数能够平滑出MAPE可能遇到的问题。'
- en: Symmetric mean absolute percent error
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对称均值绝对百分比误差
- en: The **symmetric mean absolute percent error** (**SMAPE**) attempts to overcome
    the asymmetric deficiency of MAPE described previously.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**对称均值绝对百分比误差**（**SMAPE**）试图克服之前描述的MAPE的不对称缺陷。'
- en: '|  | ![](img/B19630_13_F12.png) | (6) |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|  | ![](img/B19630_13_F12.png) | (6) |'
- en: SMAPE is expressed as a percentage, which allows it to compare performance between
    datasets of varying magnitude. A shortcoming of SMAPE, though, is that it becomes
    unstable when both the actual value and forecast value are close to zero. The
    upper limit of the equation is 200%, which can feel a bit bizarre intuitively.
    For this reason, some formulations of the equation leave out the division by 2
    in the denominator.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SMAPE以百分比的形式表示，这使得它可以比较不同规模数据集之间的性能。然而，SMAPE的一个缺点是，当实际值和预测值都接近零时，它会变得不稳定。方程式的上限是200%，这在直观上可能感觉有点奇怪。因此，一些方程式的公式在分母中省略了除以2的操作。
- en: Coverage
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖率
- en: The final Prophet metric is **coverage**. Coverage is simply the percentage
    of actual values that lie between the predicted upper and lower uncertainty bounds.
    By default, the uncertainty limits cover 80% of the data, so your coverage value
    should be 0.8.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的Prophet指标是**覆盖率**。覆盖率简单地表示实际值位于预测的上限和下限不确定性界限之间的百分比。默认情况下，不确定性界限覆盖80%的数据，因此您的覆盖率值应该是0.8。
- en: If you find a coverage value that does not equal the `interval_width` set during
    model instantiation, it means your model is not well calibrated to the uncertainty.
    In practice, this simply means that you probably cannot trust the stated uncertainty
    intervals in the future portions of your forecast and may want to adjust them
    based on the coverage value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现覆盖率值不等于在模型实例化期间设置的`interval_width`，这意味着您的模型没有很好地校准到不确定性。在实践中，这仅仅意味着您可能无法信任未来预测部分中声明的不确定性区间，并可能希望根据覆盖率值进行调整。
- en: And of course, the cross-validation DataFrame contains all of your actual ![](img/B19630_13_F13.png)
    values and your model’s predicted ![](img/B19630_13_F14.png) values, so any other
    metric you can come up with to compare those values, you can calculate and use
    yourself.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，交叉验证DataFrame包含您所有的实际![img/B19630_13_F13.png](img/B19630_13_F13.png)值和您模型的预测![img/B19630_13_F14.png](img/B19630_13_F14.png)值，因此您可以计算出任何其他指标来比较这些值，并自行计算和使用。
- en: Choosing the best metric
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择最佳指标
- en: Deciding which performance metric to optimize your model with is not a trivial
    choice. It can have a significant impact on your final model, depending on the
    characteristics of the data. When worked out mathematically, it can be shown that
    optimizing your model for MSE will create a model predicting values close to the
    mean of your data, and optimizing for MAE will create predictions close to the
    median value. Optimizing for MAPE will tend to produce abnormally low forecasts
    because it applies such a high weight to errors occurring at low points in the
    data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 决定使用哪个性能指标来优化您的模型不是一个简单的选择。它会对您的最终模型产生重大影响，具体取决于数据的特征。从数学上分析，可以证明优化您的模型以MSE为目标将创建一个预测值接近数据平均值的模型，而优化以MAE为目标将创建预测值接近中值。优化以MAPE为目标往往会产生异常低的预测，因为它在数据低点发生的错误上施加了如此高的权重。
- en: So, between MSE (or RMSE) and MAE, which is better? RMSE aims to be correct
    to the average data point and MAE aims to overshoot the actual value as often
    as it undershoots. This difference will only materialize when the mean and median
    of your data are different – in highly skewed data. As the median will be further
    from the tail in skewed data than the mean will be, the MAE will introduce bias
    toward the bulk of data and away from the tail. A biased model is the greatest
    disadvantage of MAE.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在MSE（或RMSE）和MAE之间，哪个更好？RMSE旨在对平均数据点正确，而MAE旨在尽可能多地超过实际值，同时也尽可能少地低于实际值。这种差异只有在您的数据平均值和中位数不同时才会显现出来——在高度偏斜的数据中。由于中位数在偏斜数据中比平均值更远离尾部，MAE将倾向于对数据的大部分产生偏差，而远离尾部。偏差模型是MAE的最大缺点。
- en: MSE’s disadvantage is its sensitivity to outliers. Imagine a time series that
    is generally flat except for a couple of extreme outliers. MSE will really focus
    on the forecast errors of those outliers, so it will tend to miss the mark more
    often than MAE will. In general, the median is more robust to outliers than the
    mean.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: MSE的缺点是对异常值敏感。想象一下，一个时间序列总体上很平坦，除了几个极端的异常值。MSE将真正关注这些异常值的预测误差，因此它往往会比MAE更频繁地偏离目标。一般来说，中位数比平均值更能抵抗异常值。
- en: So, should we consider robustness to outliers a good thing? Not necessarily.
    If your time series is intermittent – that is, if most dates have a ![](img/B19630_03_F02.png)
    value of 0 – you don’t want to target the median value but the mean. The median
    will be 0! In this case, you would desire MSE precisely because it is sensitive
    to outliers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该将异常值的鲁棒性视为好事吗？不一定。如果你的时间序列是间歇性的——也就是说，如果大多数日期的 ![](img/B19630_03_F02.png)
    值为 0 ——你不想针对中位数值，而是均值。中位数将是 0！在这种情况下，你将希望 MSE（均方误差）精确地因为它是敏感于异常值的。
- en: Unfortunately, there is no easy answer to which is the best metric to use. The
    analyst must pay attention to bias, skewness, and outliers to determine which
    metric will work best. And there is no reason you can’t try multiple metrics and
    see which forecast seems the most reasonable to you!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，没有简单的答案来确定哪个指标是最好的。分析师必须注意偏差、偏斜度和异常值，以确定哪个指标将工作得最好。而且，你完全可以用多个指标尝试，看看哪个预测对你来说看起来最合理！
- en: Creating a Prophet performance metrics DataFrame
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Prophet 性能指标 DataFrame
- en: 'Now that you’ve learned what the different options are for performance metrics
    in Prophet, let’s start coding and see how to access them. We’ll use the same
    online retail sales data we used in [*Chapter 12*](B19630_12.xhtml#_idTextAnchor794),
    *Performing Cross-Validation*. Along with our usual imports, we are going to add
    the `performance_metrics` function from Prophet’s `diagnostics` package and the
    `plot_cross_validation_metric` function from the `plot` package:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 Prophet 中性能指标的不同选项，让我们开始编码，看看如何访问它们。我们将使用与我们在 [*第 12 章*](B19630_12.xhtml#_idTextAnchor794)
    中使用的相同的在线零售销售数据，*执行交叉验证*。除了我们通常的导入之外，我们还将添加来自 Prophet 的 `diagnostics` 包中的 `performance_metrics`
    函数和来自 `plot` 包的 `plot_cross_validation_metric` 函数：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, let’s load the data, create our forecast, and plot the results:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们加载数据，创建我们的预测，并绘制结果：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Because we’re not interested in any future predictions, we don’t need to create
    the `future` DataFrame. We’ll just focus on the 3 years of data we’ve got:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们对任何未来的预测不感兴趣，所以我们不需要创建 `future` DataFrame。我们只需关注我们拥有的 3 年数据：
- en: '![Figure 13.1 – Online retail sales forecast](img/Fig_13.1.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 在线零售销售预测](img/Fig_13.1.jpg)'
- en: Figure 13.1 – Online retail sales forecast
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 在线零售销售预测
- en: 'The `performance_metrics` function requires a cross-validation DataFrame as
    input, so we’ll create one in the same manner as you learned in [*Chapter 12*](B19630_12.xhtml#_idTextAnchor794),
    *Performing Cross-Validation*. We’ll set `horizon` to `90 days`, so each fold
    in the cross-validation will be `90 days`. The `period` of `30 days` is how often
    to begin a new fold and `initial` being set to `730 days` is our first 2-year
    training period, untouched by validation:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`performance_metrics` 函数需要一个交叉验证 DataFrame 作为输入，所以我们将以你学习在 [*第 12 章*](B19630_12.xhtml#_idTextAnchor794)
    中相同的方式创建一个。我们将 `horizon` 设置为 `90 天`，因此交叉验证中的每个折叠将是 `90 天`。`period` 的 `30 天` 是开始一个新折叠的频率，而
    `initial` 被设置为 `730 天`是我们的第一个两年训练期，未受到验证的影响：'
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we’ll send `df_cv` to the `performance_metrics` function. By default,
    this function will calculate each of the five available metrics. You can specify
    a subset of these by passing a list of metric names to the `metrics` argument.
    Let’s include all five and display the first few rows of the resulting DataFrame:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 `df_cv` 发送到 `performance_metrics` 函数。默认情况下，此函数将计算五个可用的指标中的每一个。你可以通过传递一个指标名称列表到
    `metrics` 参数来指定这些指标的一个子集。让我们包括所有五个，并显示结果 DataFrame 的前几行：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output DataFrame is indexed by days in the `horizon`, so each row represents
    the values of those metrics when the model is asked to forecast that many days
    out. This is just the first five rows (your results may vary slightly due to randomness
    in the optimization algorithm):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的 DataFrame 以 `horizon` 中的天数为索引，因此每一行代表当模型被要求预测这么多天时的这些指标值。这只是前五行（由于优化算法中的随机性，你的结果可能会有所不同）：
- en: '![Figure 13.2 – Performance metrics DataFrame](img/Fig_13.2.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 性能指标 DataFrame](img/Fig_13.2.jpg)'
- en: Figure 13.2 – Performance metrics DataFrame
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 性能指标 DataFrame
- en: You may be wondering why the first row in the `horizon` column is `9 days`.
    Each metric value in the DataFrame is the rolling average of its calculation up
    to the day specified. The `performance_metrics` function takes a `rolling_window`
    argument where you can change the window size, but the default is `0.1`. This
    number is the fraction of `horizon` to include in the window. With 10% of our
    90-day `horizon` being 9 days, this is the first row of the DataFrame.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么`horizon`列的第一行是`9 days`。DataFrame中的每个指标值都是其计算到指定日期的滚动平均值。`performance_metrics`函数接受一个`rolling_window`参数，你可以更改窗口大小，但默认值是`0.1`。这个数字是窗口中包含`horizon`的分数。在我们的90天`horizon`中，10%是9天，这是DataFrame的第一行。
- en: 'You can use this DataFrame on its own or you can visualize it with Prophet’s
    `plot_cross_validation_metric` function. This function actually calls the `performance_metrics`
    function itself, so you do not need to create a `df_p` first, just a `df_cv`.
    Here, we’ll plot the MAE by passing `''mae''` to the `metric` argument:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个DataFrame单独使用，或者使用Prophet的`plot_cross_validation_metric`函数来可视化它。这个函数实际上会调用`performance_metrics`函数本身，所以你不需要首先创建一个`df_p`，只需要一个`df_cv`。在这里，我们将通过将`'mae'`传递给`metric`参数来绘制MAE：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The resulting plot shows each MAE measurement along the horizon and the rolling
    average value of those measurements:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图显示了沿预测范围的每个MAE测量值及其滚动平均值：
- en: '![Figure 13.3 – Cross-validation plot](img/Fig_13.3.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 交叉验证图](img/Fig_13.3.jpg)'
- en: Figure 13.3 – Cross-validation plot
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 交叉验证图
- en: Our cross-validation settings were `horizon='90 days', period='30 days', initial='730
    days'`, which, for the 1 year of data remaining after the initial training period,
    resulted in a total of ten 90-day forecasts. So, for each day in our horizon,
    the preceding plot will have 10 MAE measurements. If you counted up all the dots
    on that plot, it should be 900\. The solid line is the rolling average value,
    with the window size being the same default, `0.1`, as the `performance_metrics`
    DataFrame.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的交叉验证设置是 `horizon='90 days', period='30 days', initial='730 days'`，这对于初始训练期后剩余的1年数据，总共产生了十个90天的预测。因此，对于我们预测范围中的每一天，前一个图将会有10个MAE测量值。如果你数一下那个图上的所有点，应该是900个。实线是滚动平均值，窗口大小与`performance_metrics`
    DataFrame中的默认值相同，即`0.1`。
- en: 'You can specify this by using the same `rolling_window` argument in the `plot_cross_validation_metric`
    function. Just to make it very clear how this window size affects the plot, let’s
    compare two RMSE plots, one with a 1% window size and one with a 10% size:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`plot_cross_validation_metric`函数中使用相同的`rolling_window`参数来指定这一点。为了非常清楚地说明这个窗口大小如何影响图，让我们比较两个RMSE图，一个窗口大小为1%，另一个为10%：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We use the `ax` argument to plot both lines on the same chart:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ax`参数在同一张图上绘制两条线：
- en: '![Figure 13.4 – Comparing different window sizes](img/Fig_13.4.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 比较不同的窗口大小](img/Fig_13.4.jpg)'
- en: Figure 13.4 – Comparing different window sizes
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 比较不同的窗口大小
- en: The smoother line is the one with a wider window size, the default window size.
    Because the window is not centered but set to the right edge, the first 8 days
    do not show the rolling average line when using 10% of the horizon. Setting the
    window to 1% will include all data at the cost of being noisier.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 线条更平滑的是窗口大小更宽的那个，即默认窗口大小。因为窗口不是居中的，而是设置在右边，所以在使用10%的预测范围时，前8天不会显示滚动平均值线。将窗口设置为1%将包括所有数据，但代价是噪声更大。
- en: Now that you’ve learned how to use the cross-validation plot, let’s use it to
    see a problem that can arise when letting Prophet automatically select the cut-off
    dates to begin each cross-validation fold.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用交叉验证图，让我们用它来看看当让Prophet自动选择每个交叉验证折的截止日期时可能出现的问题。
- en: Handling irregular cut-offs
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理不规则截止点
- en: We’ll be using a new dataset for this example. The **World Food Programme**
    (**WFP**) is the branch of the United Nations focused on hunger and food security.
    One of the greatest contributing factors to food security issues in developing
    countries that the WFP tracks is rainfall because it can affect agricultural production.
    Thus, predicting rainfall is of critical importance in planning aid delivery.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用一个新的数据集。**世界粮食计划署**（**WFP**）是联合国专注于饥饿和粮食安全的部门。WFP跟踪的发展中国家粮食安全问题的一个最大的影响因素是降雨，因为它会影响农业生产。因此，预测降雨对于规划援助的分配至关重要。
- en: This data represents the rainfall received over 30 years in one of the regions
    the WFP monitors. What makes this dataset unique is that the WFP recorded the
    amount of rain that accumulated three times per month, on the 1st, the 11th, and
    the 21st. The accumulation from the 1st to the 11th is a 10-day period. It’s the
    same from the 11th to the 21st. But the period from the 21st of one month to the
    1st of the next varies depending upon the month. In a normal February, it will
    be 8 days. In a leap year, 9 days. Months of 30 and 31 days will see a period
    of 10 and 11 days respectively.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这份数据代表 WFP 监测的一个地区 30 年内接收到的降雨量。这个数据集的独特之处在于 WFP 每月记录了三次累积降雨量，分别在 1 日、11 日和
    21 日。从 1 日到 11 日的累积是一个 10 天的周期。从 11 日到 21 日也是如此。但一个月的 21 日到下一个月的 1 日的周期会根据月份的不同而变化。在正常的二月，将是
    8 天。在闰年，是 9 天。30 天和 31 天的月份将分别有 10 天和 11 天的周期。
- en: 'Let’s perform cross-validation as you’ve learned so far and see what effect
    this will have. First, we need to train a Prophet model on the data. You should
    have everything already imported if you’re continuing from the previous example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照你之前学到的进行交叉验证，看看这会有什么效果。首先，我们需要在数据上训练一个 Prophet 模型。如果你是从上一个例子继续的，你应该已经导入了所有内容：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you remember, cross-validation is not concerned with any future, unknown
    periods. Therefore, it’s unnecessary to build a `future` DataFrame and predict
    on it. I did so in this example merely to remind you of the first potential pitfall
    you learned about in [*Chapter 4*](B19630_04.xhtml#_idTextAnchor197), *Handling
    Non-Daily Data*, when we used data with regular gaps. We needed to adjust our
    `future` DataFrame to avoid unconstrained predictions, and we’ve done that again
    here by restricting future dates only to those on the 1st, 11th, and 21st of each
    month. Here’s what the forecast looks like:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，交叉验证并不关心任何未来的、未知的时间段。因此，构建一个 `future` DataFrame 并对其预测是不必要的。我在这个例子中这样做只是为了提醒你，在
    [*第 4 章*](B19630_04.xhtml#_idTextAnchor197) *处理非每日数据* 中我们使用有规律间隔的数据时学到的第一个潜在陷阱。我们需要调整我们的
    `future` DataFrame 以避免无约束的预测，我们在这里再次通过仅将未来日期限制在每月的 1 日、11 日和 21 日来做到这一点。以下是预测的结果：
- en: '![Figure 13.5 – Rainfall forecast](img/Fig_13.5.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – 降雨量预测](img/Fig_13.5.jpg)'
- en: Figure 13.5 – Rainfall forecast
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 降雨量预测
- en: It has a nearly flat trend, rising slightly until 2010 and then turning downward.
    As you may have expected, the model is dominated by yearly seasonality, with rainfall
    in December (summer in the Southern Hemisphere) at almost zero and rainfall at
    its maximum in June.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个几乎平坦的趋势，略微上升直到 2010 年，然后转向下降。正如你可能预料的那样，模型主要由年度季节性主导，12 月（南半球的夏季）降雨量几乎为零，而在
    6 月降雨量达到最大。
- en: 'Now let’s build a cross-validation plot. We’ll forecast `90 days` (the horizon)
    and create a new fold every `30 days` (the period). Our initial training period
    will be `1826 days`, or 5 years. Finally, let’s plot the RMSE:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来构建一个交叉验证图。我们将预测 `90 天`（horizon），并且每 `30 天`（period）创建一个新的折叠。我们的初始训练周期将是
    `1826 天`，即 5 年。最后，让我们绘制 RMSE 图：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Prophet uses `horizon`, `period`, and `initial` to calculate a set of evenly
    spaced cut-offs. `horizon` is then used again to set the length of each fold’s
    forecast but `period` and `initial` are not needed after choosing the cut-offs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 使用 `horizon`、`period` 和 `initial` 来计算一组均匀分布的截止点。然后 `horizon` 再次用来设置每个折叠预测的长度，但
    `period` 和 `initial` 在选择截止点后不再需要。
- en: 'The effect of letting Prophet automatically set the cut-offs is that they are
    inconveniently located compared to our data. We only have data for 3 days per
    month, and those 3 days are not consistently spaced. This means that each fold
    in our cross-validation starts effectively randomly somewhere in the data, producing
    a plot that seems to suggest each day in the horizon has data:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让 Prophet 自动设置截止点的影响是，它们与我们的数据相比位置不太方便。我们每月只有 3 天的数据，而且这 3 天并不是均匀分布的。这意味着在我们的交叉验证中，每个折叠实际上是从数据中的某个随机位置开始的，产生了一个似乎表明每个天都有数据的图：
- en: '![Figure 13.6 – Cross-validation with automatic cut-offs](img/Fig_13.6.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6 – 带自动截止点的交叉验证](img/Fig_13.6.jpg)'
- en: Figure 13.6 – Cross-validation with automatic cut-offs
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – 带自动截止点的交叉验证
- en: 'The `cross_validation` function will accept a `cutoffs` argument that takes
    a list of user-specified cut-off dates to use. This also means that `initial`
    and `period` are no longer necessary. This code block will use a list comprehension
    to iterate over each year, then each month, then each day of either the 1st, 11th,
    or 21st, and create a list of pandas `Timestamp`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`cross_validation` 函数将接受一个 `cutoffs` 参数，它接受一个用户指定的截止日期列表来使用。这也意味着 `initial`
    和 `period` 不再是必要的。此代码块将使用列表推导式遍历每年的每个月，然后是每个月的 1 日、11 日或 21 日，并创建一个包含 pandas `Timestamp`
    的列表：'
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if we replot our cross-validation but send this list of cut-off dates,
    we’ll see something dramatically different:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们重新绘制交叉验证，但发送这个截止日期列表，我们会看到一些显著不同的结果：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, each fold is begun on a day for which we have data. The next day for which
    data exists will be either 8, 9, 10, or 11 days later. Hence, the plot shows 4
    discrete days in `horizon` where a forecast took place:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个折叠都是从我们有数据的那一天开始的。接下来有数据的那一天将在 8、9、10 或 11 天后。因此，图表显示了 `horizon` 中发生预测的
    4 个离散天数：
- en: '![Figure 13.7 – Cross-validation with custom cut-offs](img/Fig_13.7.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – 使用自定义截止点的交叉验证](img/Fig_13.7.jpg)'
- en: Figure 13.7 – Cross-validation with custom cut-offs
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – 使用自定义截止点的交叉验证
- en: Both *Figure 13**.6* and *Figure 13**.7* show an average RMSE of just above
    20, so the results are very similar. The difference is simply the ease of interpretation
    and consistency. You may encounter this situation often if your data is recorded
    monthly or in any increment of months because they have inconsistent durations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13.6* 和 *图 13.7* 都显示了略高于 20 的平均 RMSE，所以结果非常相似。区别仅仅是解释的简便性和一致性。如果你的数据是按月或任何月份增量记录的，你可能会经常遇到这种情况，因为它们的持续时间不一致。'
- en: Tuning hyperparameters with grid search
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格搜索调整超参数
- en: 'For the final section of this chapter, we’ll look at grid search and work through
    an example, continuing with this rainfall data. If you’re not familiar with the
    concept of grid search, it’s a way to exhaustively check all reasonable combinations
    of hyperparameters against a performance indicator and choose the best combination
    to train your final model. With Prophet, you might decide to select the following
    hyperparameters and values:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将探讨网格搜索并通过一个例子来操作，继续使用这些降雨数据。如果你不熟悉网格搜索的概念，它是一种彻底检查所有合理的超参数组合与性能指标的方法，并选择最佳的组合来训练你的最终模型。使用
    Prophet，你可能会决定选择以下超参数和值：
- en: '![Figure 13.8 – Prophet grid search parameters](img/Fig_13.8.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – Prophet 网格搜索参数](img/Fig_13.8.jpg)'
- en: Figure 13.8 – Prophet grid search parameters
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – Prophet 网格搜索参数
- en: With these parameters, a grid search will iterate through each unique combination,
    use cross-validation to calculate and save a performance metric, and then output
    the set of parameter values that resulted in the best performance.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些参数，网格搜索将遍历每个唯一组合，使用交叉验证来计算和保存性能指标，然后输出导致最佳性能的参数值集。
- en: 'Prophet does not have a grid search method the way, for example, `sklearn`
    does. One is easy enough to build yourself in Python though, so let’s see how
    to set it up. The first step is to define our parameter grid. We’ll use the grid
    shown in *Figure 13**.8*, but we’re not including holidays in our model (the weather
    doesn’t regularly check its calendar and adjust rainfall if it finds a holiday!),
    so we’ll leave that out:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 没有像 `sklearn` 那样的网格搜索方法。不过，在 Python 中自己构建一个也很容易，所以让我们看看如何设置它。第一步是定义我们的参数网格。我们将使用
    *图 13.8* 中显示的网格，但我们不包括假日在我们的模型中（天气不会定期查看日历并在发现假日时调整降雨量！），所以我们将省略这一点：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we’ll use Python’s `itertools` package to iterate over that grid and
    create a list of each unique combination. We’ll need to import `itertools` first;
    and while we’re at it, let’s import `numpy` as well, because we’ll be using it
    later. We’ll also create an empty list to hold all of the RMSE values, assuming
    that’s our chosen performance metric:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 Python 的 `itertools` 包来遍历该网格并创建每个唯一组合的列表。我们首先需要导入 `itertools`；同时，让我们也导入
    `numpy`，因为我们稍后会用到它。我们还将创建一个空列表来保存所有的 RMSE 值，假设这是我们选择的性能指标：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We could allow Prophet to define our cut-off periods, but because we’re using
    this rainfall data, let’s set `cutoffs` ourselves:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以允许 Prophet 定义我们的截止期，但由于我们使用的是这些降雨数据，让我们自己设置 `cutoffs`：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The final step in running our grid search, before we evaluate the results, is
    to iterate over each combination we saved in the `all_params` list, and build
    a model, a cross-validation DataFrame, and a performance metrics DataFrame.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估结果之前，运行我们的网格搜索的最终一步是遍历我们在`all_params`列表中保存的每个组合，并构建一个模型、一个交叉验证数据框和一个性能指标数据框。
- en: 'Let’s say that we know we want `yearly_seasonality=4` to keep the curve smooth,
    and we’ll complete model instantiation with the parameter combination for that
    iteration. In the `performance_metrics` function, we are using `rolling_window=1`.
    This means that we are averaging 100% of the data in that fold to calculate the
    metric, so instead of a series of values, we only get one:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们知道我们想要`yearly_seasonality=4`以保持曲线平滑，我们将使用该迭代的参数组合来完成模型实例化。在`performance_metrics`函数中，我们使用`rolling_window=1`。这意味着我们正在计算该折叠中100%的数据的平均值来计算指标，因此我们只得到一个值，而不是一系列值：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That code is going to take a long time to run. The length of our `all_params`
    list, after all, is 32, which means you’ll be training and cross-validating 32
    total models. I did say grid search was exhaustive! (On a typical laptop, you
    can expect it will take around 8-12 hours to complete; to speed up the example,
    you may consider reducing the number of parameters in the `param_grid` dictionary,
    such as, for example, `param_grid = {''changepoint_prior_scale'': [0.1, 0.01]`,
    `''seasonality_prior_scale'': [1.0, 0.1]}`, which will train and cross-validate
    only four total models. Be sure to recreate your `all_params` dictionary after
    changing `param_grid`.) To inspect the results, we’ll build a DataFrame with the
    parameter combinations and their associated RMSEs, and then display a portion
    of it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '那段代码将需要很长时间才能运行。毕竟，我们的`all_params`列表的长度是32，这意味着你将训练和交叉验证32个总模型。我确实说过网格搜索是详尽的！（在典型的笔记本电脑上，你完成它可能需要大约8-12小时；为了加快示例，你可能考虑减少`param_grid`字典中的参数数量，例如，例如，`param_grid
    = {''changepoint_prior_scale'': [0.1, 0.01]`, `''seasonality_prior_scale'': [1.0,
    0.1]}`，这将只训练和交叉验证四个总模型。确保在更改`param_grid`后重新创建你的`all_params`字典。）为了检查结果，我们将构建一个包含参数组合及其相关RMSE的数据框，然后显示其中的一部分：'
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The full DataFrame has 32 rows, one for each combination of parameters, but
    here we see the first five rows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的数据框有32行，每行对应一组参数，但在这里我们看到前五行：
- en: '![Figure 13.9 – Grid search DataFrame](img/Fig_13.9.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图13.9 – 网格搜索数据框](img/Fig_13.9.jpg)'
- en: Figure 13.9 – Grid search DataFrame
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 – 网格搜索数据框
- en: 'Finally, let’s use NumPy to find the parameters with the lowest RMSE value
    and then print them:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用NumPy找到具有最低RMSE值的参数，然后打印它们：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Printing `best_params` should display this output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`best_params`应该显示以下输出：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The biggest difference between the best parameters found with grid search and
    those we’ve used so far is that the changepoint regularization would be better
    set to a much stronger level. With a lower prior scale, the magnitudes of changepoints
    would be less, and the trend curve would be even flatter. Intuitively, this seems
    appropriate; especially for longer forecasts, where allowing larger trend changes
    would create unrealistic rainfall forecasts far into the future.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过网格搜索找到的最佳参数和之前我们使用的参数之间最大的区别是，变化点正则化应该设置得更加严格。使用较低的先验尺度，变化点的幅度会更小，趋势曲线会更平坦。直观上看，这似乎是合适的；尤其是对于更长期的预测，允许更大的趋势变化将会导致对未来远期的不切实际的降雨量预测。
- en: Probably the most critical parameter to tune is `changepoint_prior_scale`. If
    this value is too small, the trend will underfit the variance. Variance that should
    be modeled with the trend will instead be modeled in the noise term. If the prior
    scale is too large, the trend will exhibit too much flexibility and may start
    to capture some of the yearly seasonality. A range between `0.5` and `0.001` will
    work in most cases.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最关键的参数调整是`changepoint_prior_scale`。如果这个值太小，趋势将无法很好地拟合方差。本应与趋势一起建模的方差将转而由噪声项建模。如果先验尺度太大，趋势将表现出过多的灵活性，并可能开始捕捉到一些年度季节性。在大多数情况下，`0.5`到`0.001`的范围将适用。
- en: The `seasonality_prior_scale` parameter is probably the second most impactful
    parameter. A typical range is usually `10`, with essentially no regularization,
    down to `0.01`. Anything smaller and the seasonality is likely to be regularized
    to a negligible effect. You also have the option of setting each seasonality to
    `False` and using `add_seasonality` to choose prior scales individually, but this
    causes your grid search to increase in computing time exponentially.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`seasonality_prior_scale`参数可能是影响第二大的参数。典型的范围通常是`10`，基本上没有正则化，直到`0.01`。任何更小的值，季节性可能被正则化到可以忽略不计的效果。你也可以选择将每个季节性设置为`False`，并使用`add_seasonality`来单独选择先验尺度，但这会导致你的网格搜索计算时间呈指数级增加。'
- en: You may also want to add `fourier_order` to your grid search, but I’ve found
    it works great to build a quick model with defaults, inspect the components, and
    choose Fourier orders myself that fit my intuition. In a fully automated setup,
    keeping Fourier orders at their defaults will probably be fine.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可能想将`fourier_order`添加到你的网格搜索中，但我发现使用默认值构建快速模型、检查组件并选择符合直觉的四阶傅里叶顺序效果很好。在完全自动化的设置中，保持傅里叶阶数在默认值可能就足够了。
- en: '`holidays_prior_scale` is also a tunable parameter, with many of the same characteristics
    as `seasonality_prior_scale`. Just keep in mind that many models won’t have holidays
    and so there will be no need to include this parameter.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`holidays_prior_scale`也是一个可调整的参数，具有与`seasonality_prior_scale`许多相同的特性。只需记住，许多模型可能没有节假日，因此不需要包含此参数。'
- en: The last of the critical parameters that should always be considered is `seasonality_mode`.
    In this book, you have learned a few rules of thumb to help decide which mode
    to use, but more often than not, it isn’t clear. The best thing to do is simply
    inspect a plot of your time series and see whether the magnitude of seasonal fluctuations
    grows with the trend or stays constant. If you can’t tell, go ahead and add `seasonality_mode`
    to the grid.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应该始终考虑的关键参数之一是`seasonality_mode`。在这本书中，你已经学到了一些经验法则来帮助决定使用哪种模式，但往往并不清楚。最好的做法是简单地检查你的时间序列图，看看季节性波动的幅度是否随着趋势增长或保持不变。如果你无法判断，就继续将`seasonality_mode`添加到网格中。
- en: Usually, the default value of 80% for `changepoint_range` will be good. It provides
    a nice balance of allowing the trend to change where appropriate but not allowing
    it to overfit in the last 20% of data where errors cannot be corrected. If you’re
    the analyst and paying close attention, it’s easy to see if the default range
    is not appropriate. But in a fully automated setting, it’s probably better to
    be conservative and leave it at 80%.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`changepoint_range`的默认值80%将很好。它提供了一个很好的平衡，允许趋势在适当的地方改变，但不会允许它在最后20%的数据中过度拟合，因为错误无法纠正。如果你是分析师并且密切关注，很容易看出默认范围是否不合适。但在完全自动化的设置中，可能最好是保守一些，将其保持在80%。
- en: 'The remaining parameters are best left out of your grid search. For `''growth''`,
    it is either `''linear''`, `''logistic''`, or `''flat''`, and you as the analyst
    should choose. Setting it to `''logistic''` will require setting `''cap''` and
    `''floor''` as well. Many of the remaining parameters, such as `n_changepoints`
    and the yearly, weekly, and daily seasonalities, are better controlled with parameters
    already included in the search: `changepoint_prior_scale` in the case of changepoints
    and `seasonality_prior_scale` with seasonalities.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的参数最好不包含在网格搜索中。对于`'growth'`，可以是`'linear'`、`'logistic'`或`'flat'`，你应该作为分析师来选择。将其设置为`'logistic'`将需要设置`'cap'`和`'floor'`。许多剩余的参数，如`n_changepoints`和年度、周度和日季节性，最好通过搜索中已包含的参数来控制：对于变化点，是`changepoint_prior_scale`，对于季节性，是`seasonality_prior_scale`。
- en: The final parameters, `mcmc_samples`, `interval_width`, and `uncertainty_samples`,
    don’t affect your `yhat` in any way and therefore have no effect on your performance
    metric. They only control the uncertainty intervals.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的参数，`mcmc_samples`、`interval_width`和`uncertainty_samples`，不会以任何方式影响你的`yhat`，因此不会影响你的性能指标。它们只控制不确定性区间。
- en: Use common sense with grid search – it is a very long process, so don’t include
    every parameter and every possible value in your hyperparameter grid. Often the
    best approach an analyst can take is to provide intuition and human touch to the
    process and let the computer do the number-crunching.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在网格搜索中使用常识——这是一个非常漫长的过程，所以不要将每个参数和每个可能的值都包含在你的超参数网格中。通常，分析师可以采取的最佳方法是为这个过程提供直觉和人性化的触感，并让计算机进行数值计算。
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use Prophet’s performance metrics to extend
    the usefulness of cross-validation. You learned about the six metrics Prophet
    has out of the box, namely, MSE, RMSE, MAE, MAPE, MdAPE, and coverage. You learned
    about many of the advantages and disadvantages of these metrics, and situations
    where you may want to use or avoid any one of them.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用Prophet的性能指标来扩展交叉验证的有用性。你了解了Prophet自带六个指标，即MSE、RMSE、MAE、MAPE、MdAPE和覆盖率。你还了解了这些指标的优势和劣势，以及你可能想要使用或避免其中任何一个指标的情况。
- en: Next, you learned how to create Prophet’s performance metrics DataFrame and
    use it to create a plot of your preferred cross-validation metric so as to be
    able to evaluate the performance of your model on unseen data across a range of
    forecast horizons. You then used this plot with the WFP’s rainfall data to see
    a situation where Prophet’s automatic cut-off date selection is not ideal, and
    how to create custom cut-off dates.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你学习了如何创建Prophet的性能指标DataFrame，并使用它来创建你偏好的交叉验证指标的图表，以便能够评估你的模型在一系列预测时间范围内的未见数据上的性能。然后，你使用这个图表和WFP的降雨数据来观察Prophet自动选择截止日期的情况并不理想，以及如何创建自定义截止日期。
- en: Finally, you brought all of this together in an exhaustive grid search of Prophet
    hyperparameters. This process enabled you to use a data-driven technique to fine-tune
    your model and optimize it for a metric of your choice.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你通过全面搜索Prophet的超参数来整合所有这些内容。这个过程使你能够使用数据驱动技术来微调你的模型，并优化它以适应你选择的指标。
- en: In the next chapter, the final chapter of this book, you will learn about a
    few more tricks in Prophet’s bag to help put your models into a production environment.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，这本书的最后一章，你将了解Prophet中的一些更多技巧，以帮助将你的模型投入生产环境。
