["```py\n$ sudo mv 71-ti-permissions.rules /etc/udev/rules.d/\n```", "```py\n$ sudo service udev restart\n```", "```py\n    $./energia  \n```", "```py\n///Left Motor  Pins \n#define INA_1 12 \n#define INB_1 13 \n#define PWM_1 PC_6 \n\n///Right Motor Pins \n#define INA_2 5 \n#define INB_2 6 \n#define PWM_2 PC_5 \n```", "```py\nvoid move_forward() \n{ \n    //Setting CW rotation to and Left Motor  and CCW to Right Motor  \n    //Left Motor  \n    digitalWrite(INA_1,HIGH); \n    digitalWrite(INB_1,LOW); \n    analogWrite(PWM_1,255); \n    //Right Motor  \n    digitalWrite(INA_2,LOW); \n    digitalWrite(INB_2,HIGH); \n    analogWrite(PWM_2,255);   \n} \n\n/////////////////////////////////////////////////////// \n\nvoid move_left() \n{ \n    //Left Motor  \n    digitalWrite(INA_1,HIGH); \n    digitalWrite(INB_1,HIGH); \n    analogWrite(PWM_1,0); \n    //Right Motor  \n    digitalWrite(INA_2,LOW); \n    digitalWrite(INB_2,HIGH); \n    analogWrite(PWM_2,255);   \n} \n\n////////////////////////////////////////////////////// \n\nvoid move_right() \n{ \n      //Left Motor  \n      digitalWrite(INA_1,HIGH); \n      digitalWrite(INB_1,LOW); \n      analogWrite(PWM_1,255); \n      //Right Motor  \n      digitalWrite(INA_2,HIGH); \n      digitalWrite(INB_2,HIGH); \n      analogWrite(PWM_2,0);   \n} \n\n//////////////////////////////////////////////////////// \n\nvoid stop() \n{ \n    //Left Motor  \n    digitalWrite(INA_1,HIGH); \n    digitalWrite(INB_1,HIGH); \n    analogWrite(PWM_1,0); \n    //Right Motor  \n    digitalWrite(INA_2,HIGH); \n    digitalWrite(INB_2,HIGH); \n    analogWrite(PWM_2,0);   \n} \n\n///////////////////////////////////////////////// \n\nvoid move_backward() \n\n{ \n    //Left Motor  \n    digitalWrite(INA_1,LOW); \n    digitalWrite(INB_1,HIGH); \n    analogWrite(PWM_1,255); \n    //Right Motor  \n    digitalWrite(INA_2,HIGH); \n    digitalWrite(INB_2,LOW); \n    analogWrite(PWM_2,255);   \n} \n```", "```py\nvoid setup() \n{ \n   //Setting Left Motor pin as OUTPUT \n    pinMode(INA_1,OUTPUT);  \n    pinMode(INB_1,OUTPUT); \n    pinMode(PWM_1,OUTPUT); \n\n   //Setting Right Motor pin as OUTPUT \n    pinMode(INA_2,OUTPUT); \n    pinMode(INB_2,OUTPUT); \n    pinMode(PWM_2,OUTPUT);   \n} \n```", "```py\nvoid loop() \n{ \n  //Move forward for 5 sec \nmove_forward(); \ndelay(5000); \n  //Stop for 1 sec \nstop(); \ndelay(1000); \n\n  //Move backward for 5 sec \nmove_backward(); \ndelay(5000); \n  //Stop for 1 sec \nstop(); \ndelay(1000); \n\n  //Move left for 5 sec \nmove_left(); \ndelay(5000); \n  //Stop for 1 sec \nstop(); \ndelay(1000); \n\n  //Move right for 5 sec \nmove_right(); \ndelay(5000);   \n  //Stop for 1 sec \nstop(); \ndelay(1000); \n} \n```", "```py\n//Encoder pins definition \n\n// Left encoder \n\n#define Left_Encoder_PinA 31 \n#define Left_Encoder_PinB 32 \n\nvolatile long Left_Encoder_Ticks = 0; \n\n//Variable to read current state of left encoder pin \nvolatile bool LeftEncoderBSet; \n\n//Right Encoder \n\n#define Right_Encoder_PinA 33 \n#define Right_Encoder_PinB 34 \nvolatile long Right_Encoder_Ticks = 0; \n//Variable to read current state of right encoder pin \nvolatile bool RightEncoderBSet; \n```", "```py\nvoid setup() \n{ \n    //Init Serial port with 115200 buad rate \n  Serial.begin(115200);   \n  SetupEncoders(); \n} \n```", "```py\nvoid SetupEncoders() \n{ \n  // Quadrature encoders \n  // Left encoder \n  pinMode(Left_Encoder_PinA, INPUT_PULLUP); \n  // sets pin A as input   \n  pinMode(Left_Encoder_PinB, INPUT_PULLUP); \n  // sets pin B as input \n  attachInterrupt(Left_Encoder_PinA, do_Left_Encoder, RISING); \n\n  // Right encoder \n  pinMode(Right_Encoder_PinA, INPUT_PULLUP); \n  // sets pin A as input \n  pinMode(Right_Encoder_PinB, INPUT_PULLUP); \n  // sets pin B as input \n\n  attachInterrupt(Right_Encoder_PinA, do_Right_Encoder, RISING); \n} \n```", "```py\nvoid loop() \n{ \n  Update_Encoders();                        \n} \n```", "```py\nvoid Update_Encoders() \n{ \n  Serial.print(\"e\"); \n  Serial.print(\"t\"); \n  Serial.print(Left_Encoder_Ticks); \n  Serial.print(\"t\"); \n  Serial.print(Right_Encoder_Ticks); \n  Serial.print(\"n\"); \n } \n```", "```py\nvoid do_Left_Encoder() \n{ \n  LeftEncoderBSet = digitalRead(Left_Encoder_PinB); \n  // read the input pin \n  Left_Encoder_Ticks -= LeftEncoderBSet ? -1 : +1; \n} \n\nvoid do_Right_Encoder() \n{ \n  RightEncoderBSet = digitalRead(Right_Encoder_PinB); \n  // read the input pin \n  Right_Encoder_Ticks += RightEncoderBSet ? -1 : +1; \n} \n```", "```py\n    sudo python setup.py install   \n```", "```py\n#!/usr/bin/env python \n```", "```py\nimport os \nimport dynamixel \nimport time \nimport random \n```", "```py\n# The number of Dynamixels on our bus. \nnServos = 1 \n\n# Set your serial port accordingly. \nif os.name == \"posix\": \n    portName = \"/dev/ttyUSB0\" \nelse: \n    portName = \"COM6\" \n\n# Default baud rate of the USB2Dynamixel device. \nbaudRate = 1000000 \n```", "```py\n# Connect to the serial port \nprint \"Connecting to serial port\", portName, '...', \nserial = dynamixel.serial_stream.SerialStream( port=portName, baudrate=baudRate, timeout=1) \nprint \"Connected!\" \nnet = dynamixel.dynamixel_network.DynamixelNetwork( serial ) \nnet.scan( 1, nServos ) \n```", "```py\n# A list to hold the dynamixels \nmyActuators = list() \nprint myActuators \n\nThis will create a list for storing  dynamixel actuators details. \n\nprint \"Scanning for Dynamixels...\", \nfor dyn in net.get_dynamixels(): \n    print dyn.id, \n    myActuators.append(net[dyn.id]) \nprint \"...Done\" \n```", "```py\n# Set the default speed and torque \nfor actuator in myActuators: \n    actuator.moving_speed = 50 \n    actuator.synchronized = True \n    actuator.torque_enable = True \n    actuator.torque_limit = 800 \n    actuator.max_torque = 800 \n```", "```py\n# Move the servos randomly and print out their current positions \nwhile True: \n    for actuator in myActuators: \n        actuator.goal_position = random.randrange(450, 600) \n    net.synchronize() \n```", "```py\n    for actuator in myActuators: \n        actuator.read_all() \n        time.sleep(0.01) \n\n    for actuator in myActuators: \n        print actuator.cache[dynamixel.defs.REGISTER['Id']], actuator.cache[dynamixel.defs.REGISTER['CurrentPosition']] \n\n    time.sleep(2) \n```", "```py\nconst int echo = 9, Trig = 10; \nlong duration, cm; \n```", "```py\nvoid setup() \n{ \n\n  //Init Serial port with 115200 baud rate \n  Serial.begin(115200);   \n  SetupUltrasonic();   \n} \n```", "```py\nvoid SetupUltrasonic() \n{ \n pinMode(Trig, OUTPUT); \n pinMode(echo, INPUT);  \n\n} \n```", "```py\nvoid loop() \n{ \n    Update_Ultra_Sonic(); \n    delay(200); \n} \n```", "```py\nvoid Update_Ultra_Sonic() \n{ \n  digitalWrite(Trig, LOW); \n  delayMicroseconds(2); \n  digitalWrite(Trig, HIGH); \n  delayMicroseconds(10); \n  digitalWrite(Trig, LOW); \n\n  duration = pulseIn(echo, HIGH); \n  // convert the time into a distance \n  cm = microsecondsToCentimeters(duration); \n\n  //Sending through serial port \n  Serial.print(\"distance=\"); \n  Serial.print(\"t\"); \n  Serial.print(cm); \n  Serial.print(\"n\"); \n\n} \n```", "```py\nlong microsecondsToCentimeters(long microseconds) \n{ \nreturn microseconds / 29 / 2; \n} \n```", "```py\n    $ sudo apt-get install python-serial  \n```", "```py\n#!/usr/bin/env python \nimport serial \nimport sys \n```", "```py\ntry: \n    ser = serial.Serial('/dev/ttyACM0',115200) \nexcept: \n    print \"Unable to open serial port\" \n```", "```py\nwhile True: \n    try: \n        line = ser.readline() \n        print line \n    except: \n        print \"Unable to read from device\" \n        sys.exit(0) \n```", "```py\n    $ sudo chmod +X script_name\n    $ ./ script_name  \n```", "```py\nint IR_SENSOR = 18; // Sensor is connected to the analog A3 \nint intSensorResult = 0; //Sensor result \nfloat fltSensorCalc = 0; //Calculated value \n\nvoid setup() \n{ \nSerial.begin(115200); // Setup communication with computer \n   to present results serial monitor \n} \n```", "```py\nvoid loop() \n{ \n\n// read the value from the ir sensor \nintSensorResult = analogRead(IR_SENSOR); //Get sensor value \n\n//Calculate distance in cm according to the range equation \nfltSensorCalc = (6787.0 / (intSensorResult - 3.0)) - 4.0;  \n\nSerial.print(fltSensorCalc); //Send distance to computer \nSerial.println(\" cm\"); //Add cm to result \ndelay(200); //Wait \n} \n```", "```py\n#include \"Wire.h\" \n\n#include \"I2Cdev.h\" \n#include \"MPU6050.h\" \n\nMPU6050 accelgyro; \n```", "```py\nvoid setup() \n{ \n\n  //Init Serial port with 115200 buad rate \n  Serial.begin(115200);   \n  Setup_MPU6050(); \n} \n```", "```py\nvoid Setup_MPU6050() \n{ \n   Wire.begin(); \n\n      // initialize device \n    Serial.println(\"Initializing I2C devices...\"); \n    accelgyro.initialize(); \n\n    // verify connection \n    Serial.println(\"Testing device connections...\"); \n    Serial.println(accelgyro.testConnection() ? \"MPU6050 connection successful\" : \"MPU6050 connection failed\"); \n} \n```", "```py\nvoid loop() \n{ \n\n   //Update MPU 6050 \n    Update_MPU6050(); \n\n} \n```", "```py\nvoid Update_MPU6050() \n{ \n\n   int16_t ax, ay, az; \n  int16_t gx, gy, gz; \n\n      // read raw accel/gyro measurements from device \n    accelgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz); \n\n    // display tab-separated accel/gyro x/y/z values \n    Serial.print(\"i\");Serial.print(\"t\"); \n    Serial.print(ax); Serial.print(\"t\"); \n    Serial.print(ay); Serial.print(\"t\"); \n    Serial.print(az); Serial.print(\"t\"); \n    Serial.print(gx); Serial.print(\"t\"); \n    Serial.print(gy); Serial.print(\"t\"); \n    Serial.println(gz); \n    Serial.print(\"n\"); \n} \n```"]