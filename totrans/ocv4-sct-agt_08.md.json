["```py\nShader \"Draw/Solid Color\" {\n  Properties {\n    _Color (\"Main Color\", Color) = (1.0, 1.0, 1.0, 1.0)\n  }\n  SubShader {\n    Pass { Color [_Color] }\n  }\n}\n```", "```py\nusing UnityEngine;\n\nnamespace com.nummist.rollingball {\n\n    public sealed class QuitOnAndroidBack : MonoBehaviour {\n\n        void Start() {\n            // Show the standard Android navigation bar.\n            Screen.fullScreen = false;\n        }\n\n        void Update() {\n            if (Input.GetKeyUp(KeyCode.Escape)) {\n                Application.Quit();\n            }\n        }\n    }\n}\n```", "```py\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\n\nusing OpenCVForUnity.CoreModule;\nusing OpenCVForUnity.ImgprocModule;\nusing OpenCVForUnity.UnityUtils;\n```", "```py\nnamespace com.nummist.rollingball {\n\n    [RequireComponent (typeof(Camera))]\n    public sealed class DetectAndSimulate : MonoBehaviour {\n```", "```py\n        struct Circle {\n\n            public Vector2 screenPosition;\n            public float screenDiameter;\n            public Vector3 worldPosition;\n\n            public Circle(Vector2 screenPosition,\n                          float screenDiameter,\n                          Vector3 worldPosition) {\n                this.screenPosition = screenPosition;\n                this.screenDiameter = screenDiameter;\n                this.worldPosition = worldPosition;\n            }\n        }\n```", "```py\n        struct Line {\n\n            public Vector2 screenPoint0;\n            public Vector2 screenPoint1;\n            public Vector3 worldPoint0;\n            public Vector3 worldPoint1;\n\n            public Line(Vector2 screenPoint0,\n                        Vector2 screenPoint1,\n                        Vector3 worldPoint0,\n                        Vector3 worldPoint1) {\n                this.screenPoint0 = screenPoint0;\n                this.screenPoint1 = screenPoint1;\n                this.worldPoint0 = worldPoint0;\n                this.worldPoint1 = worldPoint1;\n            }\n        }\n```", "```py\n        [SerializeField] bool useFrontFacingCamera = false;\n        [SerializeField] int preferredCaptureWidth = 640;\n        [SerializeField] int preferredCaptureHeight = 480;\n        [SerializeField] int preferredFPS = 15;\n```", "```py\n        [SerializeField] Renderer videoRenderer;\n\n        [SerializeField] Material drawPreviewMaterial;\n\n        [SerializeField] float gravityScale = 8f;\n\n        [SerializeField] GameObject simulatedCirclePrefab;\n        [SerializeField] GameObject simulatedLinePrefab;\n\n        [SerializeField] int buttonFontSize = 24;\n```", "```py\n        Camera _camera;\n\n        WebCamTexture webCamTexture;\n        Color32[] colors;\n        Mat rgbaMat;\n        Mat grayMat;\n        Mat cannyMat;\n\n        float screenWidth;\n        float screenHeight;\n        float screenPixelsPerImagePixel;\n        float screenPixelsYOffset;\n\n        float raycastDistance;\n        float lineThickness;\n        UnityEngine.Rect buttonRect;\n```", "```py\n        Mat houghCircles;\n        List<Circle> circles = new List<Circle>();\n```", "```py\n        Mat houghLines;\n        List<Line> lines = new List<Line>();\n```", "```py\n        Gyroscope gyro;\n        float gravityMagnitude;\n```", "```py\n        List<GameObject> simulatedObjects =\n                new List<GameObject>();\n        bool simulating {\n            get {\n                return simulatedObjects.Count > 0;\n            }\n        }\n```", "```py\n        void Start() {\n\n            // Cache the reference to the game world's\n            // camera.\n            _camera = GetComponent<Camera>();\n\n            houghCircles = new Mat();\n            houghLines = new Mat();\n\n            gyro = Input.gyro;\n            gravityMagnitude = Physics.gravity.magnitude *\n                               gravityScale;\n```", "```py\n#if UNITY_EDITOR\n            useFrontFacingCamera = true;\n#endif\n\n            // Try to find a (physical) camera that faces\n            // the required direction.\n            WebCamDevice[] devices = WebCamTexture.devices;\n            int numDevices = devices.Length;\n            for (int i = 0; i < numDevices; i++) {\n                WebCamDevice device = devices[i];\n                if (device.isFrontFacing ==\n                            useFrontFacingCamera) {\n                    string name = device.name;\n                    Debug.Log(\"Selecting camera with \" +\n                              \"index \" + i + \" and name \" +\n                              name);\n                    webCamTexture = new WebCamTexture(\n                            name, preferredCaptureWidth,\n                            preferredCaptureHeight,\n                            preferredFPS);\n                    break;\n                }\n            }\n\n            if (webCamTexture == null) {\n                // No camera faces the required direction.\n                // Give up.\n                Debug.LogError(\"No suitable camera found\");\n                Destroy(this);\n                return;\n            }\n```", "```py\n            // Ask the camera to start capturing.\n            webCamTexture.Play();\n\n            if (gyro != null) {\n                gyro.enabled = true;\n            }\n\n            // Wait for the camera to start capturing.\n            // Then, initialize everything else.\n            StartCoroutine(Init());\n        }\n```", "```py\n        IEnumerator Init() {\n\n            // Wait for the camera to start capturing.\n            while (!webCamTexture.didUpdateThisFrame) {\n                yield return null;\n            }\n\n            int captureWidth = webCamTexture.width;\n            int captureHeight = webCamTexture.height;\n            float captureDiagonal = Mathf.Sqrt(\n                    captureWidth * captureWidth +\n                    captureHeight * captureHeight);\n            Debug.Log(\"Started capturing frames at \" +\n                      captureWidth + \"x\" + captureHeight);\n\n            colors = new Color32[\n                    captureWidth * captureHeight];\n\n            rgbaMat = new Mat(captureHeight, captureWidth,\n                              CvType.CV_8UC4);\n            grayMat = new Mat(captureHeight, captureWidth,\n                              CvType.CV_8UC1);\n            cannyMat = new Mat(captureHeight, captureWidth,\n                               CvType.CV_8UC1);\n```", "```py\n            transform.localPosition =\n                    new Vector3(0f, 0f, -captureWidth);\n            _camera.nearClipPlane = 1;\n            _camera.farClipPlane = captureWidth + 1;\n            _camera.orthographicSize =\n                    0.5f * captureDiagonal;\n            raycastDistance = 0.5f * captureWidth;\n\n            Transform videoRendererTransform =\n                    videoRenderer.transform;\n            videoRendererTransform.localPosition =\n                    new Vector3(captureWidth / 2,\n                                -captureHeight / 2, 0f);\n            videoRendererTransform.localScale =\n                    new Vector3(captureWidth,\n                                captureHeight, 1f);\n\n            videoRenderer.material.mainTexture =\n                    webCamTexture;\n```", "```py\n            // Calculate the conversion factors between\n            // image and screen coordinates.\n            // Note that the image is landscape but the\n            // screen is portrait.\n            screenWidth = (float)Screen.width;\n            screenHeight = (float)Screen.height;\n            screenPixelsPerImagePixel =\n                    screenWidth / captureHeight;\n            screenPixelsYOffset =\n                    0.5f * (screenHeight - (screenWidth *\n                    captureWidth / captureHeight));\n```", "```py\n            lineThickness = 0.01f * screenWidth;\n\n            buttonRect = new UnityEngine.Rect(\n                    0.4f * screenWidth,\n                    0.75f * screenHeight,\n                    0.2f * screenWidth,\n                    0.1f * screenHeight);\n        }\n```", "```py\n        void Update() {\n\n            if (rgbaMat == null) {\n                // Initialization is not yet complete.\n                return;\n            }\n\n            if (gyro != null) {\n                // Align the game-world gravity to real-world\n                // gravity.\n                Vector3 gravity = gyro.gravity;\n                gravity.z = 0f;\n                gravity = gravityMagnitude *\n                          gravity.normalized;\n                Physics.gravity = gravity;\n            }\n```", "```py\n            if (!webCamTexture.didUpdateThisFrame) {\n                // No new frame is ready.\n                return;\n            }\n\n            if (simulating) {\n                // No new detection results are needed.\n                return;\n            }\n\n            // Convert the RGBA image to OpenCV's format using\n            // a utility function from OpenCV for Unity.\n            Utils.webCamTextureToMat(webCamTexture,\n                                     rgbaMat, colors);\n\n            // Convert the OpenCV image to gray and\n            // equalize it.\n            Imgproc.cvtColor(rgbaMat, grayMat,\n                             Imgproc.COLOR_RGBA2GRAY);\n            Imgproc.Canny(grayMat, cannyMat, 50.0, 200.0);\n\n            UpdateCircles();\n            UpdateLines();\n        }\n```", "```py\n        void UpdateCircles() {\n\n            // Detect blobs.\n            Imgproc.HoughCircles(grayMat, houghCircles,\n                                 Imgproc.HOUGH_GRADIENT, 2.0,\n                                 10.0, 200.0, 150.0, 5, 60);\n\n            //\n            // Calculate the circles' screen coordinates\n            // and world coordinates.\n            //\n\n            // Clear the previous coordinates.\n            circles.Clear();\n\n            // Count the elements in the matrix of Hough circles.\n            // Each circle should have 3 elements:\n            // { x, y, radius }\n            int numHoughCircleElems = houghCircles.cols() *\n                                      houghCircles.rows() *\n                                      houghCircles.channels();\n\n            if (numHoughCircleElems == 0) {\n                return;\n            }\n\n            // Convert the matrix of Hough circles to a 1D array:\n            // { x_0, y_0, radius_0, ..., x_n, y_n, radius_n }\n            float[] houghCirclesArray = new float[numHoughCircleElems];\n            houghCircles.get(0, 0, houghCirclesArray);\n\n            // Iterate over the circles.\n            for (int i = 0; i < numHoughCircleElems; i += 3) {\n```", "```py\n                // Convert circles' image coordinates to\n                // screen coordinates.\n                Vector2 screenPosition =\n                        ConvertToScreenPosition(\n                                houghCirclesArray[i],\n                                houghCirclesArray[i + 1]);\n                float screenDiameter =\n                        houghCirclesArray[i + 2] *\n                        screenPixelsPerImagePixel;\n```", "```py\n                // Convert screen coordinates to world\n                // coordinates based on raycasting.\n                Vector3 worldPosition =\n                        ConvertToWorldPosition(\n                                screenPosition);\n\n                Circle circle = new Circle(\n                        screenPosition, screenDiameter,\n                        worldPosition);\n                circles.Add(circle);\n            }\n        }\n```", "```py\n        void UpdateLines() {\n\n            // Detect lines.\n            Imgproc.HoughLinesP(cannyMat, houghLines, 1.0,\n                                Mathf.PI / 180.0, 50,\n                                50.0, 10.0);\n\n            //\n            // Calculate the lines' screen coordinates and\n            // world coordinates.\n            //\n\n            // Clear the previous coordinates.\n            lines.Clear();\n\n            // Count the elements in the matrix of Hough lines.\n            // Each line should have 4 elements:\n            // { x_start, y_start, x_end, y_end }\n            int numHoughLineElems = houghLines.cols() *\n                                    houghLines.rows() *\n                                    houghLines.channels();\n\n            if (numHoughLineElems == 0) {\n                return;\n            }\n\n            // Convert the matrix of Hough circles to a 1D array:\n            // { x_start_0, y_start_0, x_end_0, y_end_0, ...,\n            //   x_start_n, y_start_n, x_end_n, y_end_n }\n            int[] houghLinesArray = new int[numHoughLineElems];\n            houghLines.get(0, 0, houghLinesArray);\n\n            // Iterate over the lines.\n            for (int i = 0; i < numHoughLineElems; i += 4) {\n```", "```py\n                // Convert lines' image coordinates to\n                // screen coordinates.\n                Vector2 screenPoint0 =\n                        ConvertToScreenPosition(\n                                houghLinesArray[i],\n                                houghLinesArray[i + 1]);\n                Vector2 screenPoint1 =\n                        ConvertToScreenPosition(\n                                houghLinesArray[i + 2],\n                                houghLinesArray[i + 3]);\n```", "```py\n                // Convert screen coordinates to world\n                // coordinates based on raycasting.\n                Vector3 worldPoint0 =\n                        ConvertToWorldPosition(\n                                screenPoint0);\n                Vector3 worldPoint1 =\n                        ConvertToWorldPosition(\n                                screenPoint1);\n\n                Line line = new Line(\n                        screenPoint0, screenPoint1,\n                        worldPoint0, worldPoint1);\n                lines.Add(line);\n            }\n        }\n```", "```py\n        Vector2 ConvertToScreenPosition(float imageX,\n                                        float imageY) {\n            float screenX = screenWidth - imageY *\n                            screenPixelsPerImagePixel;\n            float screenY = screenHeight - imageX *\n                            screenPixelsPerImagePixel -\n                            screenPixelsYOffset;\n            return new Vector2(screenX, screenY);\n        }\n```", "```py\n        Vector3 ConvertToWorldPosition(\n                Vector2 screenPosition) {\n            Ray ray = _camera.ScreenPointToRay(\n                    screenPosition);\n            return ray.GetPoint(raycastDistance);\n        }\n```", "```py\n        void OnPostRender() {\n            if (!simulating) {\n                DrawPreview();\n            }\n        }\n```", "```py\n        void DrawPreview() {\n\n            // Draw 2D representations of the detected\n            // circles and lines, if any.\n\n            int numCircles = circles.Count;\n            int numLines = lines.Count;\n            if (numCircles < 1 && numLines < 1) {\n                return;\n            }\n```", "```py\n            GL.PushMatrix();\n            if (drawPreviewMaterial != null) {\n                drawPreviewMaterial.SetPass(0);\n            }\n            GL.LoadPixelMatrix();\n```", "```py\n            if (numCircles > 0) {\n                // Draw the circles.\n                GL.Begin(GL.QUADS);\n                for (int i = 0; i < numCircles; i++) {\n                    Circle circle = circles[i];\n                    float centerX =\n                            circle.screenPosition.x;\n                    float centerY =\n                            circle.screenPosition.y;\n                    float radius =\n                            0.5f * circle.screenDiameter;\n                    float minX = centerX - radius;\n                    float maxX = centerX + radius;\n                    float minY = centerY - radius;\n                    float maxY = centerY + radius;\n                    GL.Vertex3(minX, minY, 0f);\n                    GL.Vertex3(minX, maxY, 0f);\n                    GL.Vertex3(maxX, maxY, 0f);\n                    GL.Vertex3(maxX, minY, 0f);\n                }\n                GL.End();\n            }\n```", "```py\n            if (numLines > 0) {\n                // Draw the lines.\n                GL.Begin(GL.LINES);\n                for (int i = 0; i < numLines; i++) {\n                    Line line = lines[i];\n                    GL.Vertex(line.screenPoint0);\n                    GL.Vertex(line.screenPoint1);\n                }\n                GL.End();\n            }\n\n            GL.PopMatrix();\n        }\n```", "```py\n        void OnGUI() {\n            GUI.skin.button.fontSize = buttonFontSize;\n            if (simulating) {\n                if (GUI.Button(buttonRect,\n                               \"Stop Simulation\")) {\n                    StopSimulation();\n                }\n            } else if (circles.Count > 0 || lines.Count > 0) {\n                if (GUI.Button(buttonRect,\n                               \"Start Simulation\")) {\n                    StartSimulation();\n                }\n            }\n        }\n```", "```py\n        void StartSimulation() {\n\n            // Freeze the video background\n            webCamTexture.Pause();\n\n            // Create the circles' representation in the\n            // physics simulation.\n            int numCircles = circles.Count;\n            for (int i = 0; i < numCircles; i++) {\n                Circle circle = circles[i];\n                GameObject simulatedCircle =\n                        (GameObject)Instantiate(\n                                simulatedCirclePrefab);\n                Transform simulatedCircleTransform =\n                        simulatedCircle.transform;\n                simulatedCircleTransform.position =\n                        circle.worldPosition;\n                simulatedCircleTransform.localScale =\n                        circle.screenDiameter *\n                        Vector3.one;\n                simulatedObjects.Add(simulatedCircle);\n            }\n```", "```py\n            // Create the lines' representation in the\n            // physics simulation.\n            int numLines = lines.Count;\n            for (int i = 0; i < numLines; i++) {\n                Line line = lines[i];\n                GameObject simulatedLine =\n                        (GameObject)Instantiate(\n                                simulatedLinePrefab);\n                Transform simulatedLineTransform =\n                        simulatedLine.transform;\n                float angle = -Vector2.Angle(\n                        Vector2.right, line.screenPoint1 -\n                                line.screenPoint0);\n                Vector3 worldPoint0 = line.worldPoint0;\n                Vector3 worldPoint1 = line.worldPoint1;\n                simulatedLineTransform.position =\n                        0.5f * (worldPoint0 + worldPoint1);\n                simulatedLineTransform.eulerAngles =\n                        new Vector3(0f, 0f, angle);\n                simulatedLineTransform.localScale =\n                        new Vector3(\n                                Vector3.Distance(\n                                        worldPoint0,\n                                        worldPoint1),\n                                lineThickness,\n                                lineThickness);\n                simulatedObjects.Add(simulatedLine);\n            }\n        }\n```", "```py\n        void StopSimulation() {\n\n            // Unfreeze the video background.\n            webCamTexture.Play();\n\n            // Destroy all objects in the physics simulation.\n            int numSimulatedObjects =\n                    simulatedObjects.Count;\n            for (int i = 0; i < numSimulatedObjects; i++) {\n                GameObject simulatedObject =\n                        simulatedObjects[i];\n                Destroy(simulatedObject);\n            }\n            simulatedObjects.Clear();\n        }\n```", "```py\n        void OnDestroy() {\n            if (webCamTexture != null) {\n                webCamTexture.Stop();\n            }\n            if (gyro != null) {\n                gyro.enabled = false;\n            }\n        }\n    }\n}\n```", "```py\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\n\n#if PLATFORM_ANDROID\nusing UnityEngine.Android;\n#endif\n\nnamespace com.nummist.rollingball {\n\n    public class Launcher : MonoBehaviour {\n\n        void Start() {\n\n#if PLATFORM_ANDROID\n            if (!Permission.HasUserAuthorizedPermission(\n                    Permission.Camera))\n            {\n                // Ask the user's permission for camera access.\n                Permission.RequestUserPermission(Permission.Camera);\n            }\n#endif\n\n            SceneManager.LoadScene(\"Rollingball\");\n        }\n    }\n}\n```"]