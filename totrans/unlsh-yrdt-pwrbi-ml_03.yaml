- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Data Using Power BI and Creating a Semantic Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Chapter 2*](B19500_02.xhtml#_idTextAnchor030) was a tedious process of combing
    through the FAA Wildlife Strike raw data, identifying the columns of data that
    you want to carry forward for analysis, and then setting up queries that will
    transform the data and metadata for the purpose of analysis and ML with Power
    BI. However, it was important work.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you are ready to create a `columnname` or `column_name` might be displayed
    to users as **Column Name** via the semantic layer. Also, the logic for runtime
    calculations such as **Year to Date Cumulative Sales** often exists in the semantic
    layer. In the Microsoft Power BI ecosystem, the semantic layer exists within the
    Power BI dataset.
  prefs: []
  type: TYPE_NORMAL
- en: The Power BI dataset will consist of all of the data created by the queries
    in [*Chapter 2*](B19500_02.xhtml#_idTextAnchor030) but with the addition of custom
    columns, relationships between tables, and calculated measures that will help
    you aggregate columns for the purpose of doing mathematical operations for your
    analytics. Going back to the *Reviewing the requirements for the solution* section
    of [*Chapter 1*](B19500_01.xhtml#_idTextAnchor015), this will be the basis for
    the **Analytical Report** that you have been tasked to deliver.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve built out your Power BI dataset with some basic calculated measures,
    you will start building the basis for the data that will be used for ML in Power
    BI. This will be the basis for the **Predict Damage**, **Predict Size**, and **Predict
    Height** ML models that are requirements from the *Reviewing the requirements
    for the solution* section of [*Chapter 1*](B19500_01.xhtml#_idTextAnchor015).
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Power BI Desktop April 2023 or later (no licenses required)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FAA Wildlife Strike data files from either the FAA website or the Packt GitHub
    site at this link: [https://github.com/PacktPublishing/Unleashing-Your-Data-with-Power-BI-Machine-Learning-and-OpenAI/](https://github.com/PacktPublishing/Unleashing-Your-Data-with-Power-BI-Machine-Learning-and-OpenAI/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing relationships between tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a Power BI dataset, relationships between tables determine how queries that
    involve data from both tables are generated. If you’ve taken an introductory class
    on Power BI, such as *Dashboard in a Day*, learning about relationships is a foundational
    skill for Power BI development. Back in [*Chapter 2*](B19500_02.xhtml#_idTextAnchor030),
    you determined that the tables have the following key values to establish relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Date` column matches up to the `Incident Date` column on the `Strike` `Reports`
    table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Aircraft Code` matches up with `Aircraft Class Code` on the `Strike` `Reports`
    table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Manufacturer Code` and `Model Code` are compound keys matching up with `AMA`
    and `AMO` from the `Strike` `Reports` table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Engine Code` maps to four columns on the `Strike Reports` table – `Engine
    1 Position Code`, `Engine 2 Position Code`, `Engine 3 Position Code`, and `Engine
    4` `Position Code`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go ahead and make sure that proper key values exist for all of these tables!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pick up where you left off with your PBIX file from [*Chapter 2*](B19500_02.xhtml#_idTextAnchor030),
    or you can follow along using the finished version of the content from this chapter.
    You can download the PBIT version of the file from the Packt GitHub site folder
    for [*Chapter* *3*](B19500_03.xhtml#_idTextAnchor047): [https://github.com/PacktPublishing/Unleashing-Your-Data-with-Power-BI-Machine-Learning-and-OpenAI/tree/main/Chapter-03](https://github.com/PacktPublishing/Unleashing-Your-Data-with-Power-BI-Machine-Learning-and-OpenAI/tree/main/Chapter-03).'
  prefs: []
  type: TYPE_NORMAL
- en: Date table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve already created a **Date** table named **Date Info**, which has a field
    named **Date** containing every unique **Date** value between 1990-2024\. Within
    Power Query, you’ll see within **Column Statistics** that there are no blank values
    and every value is unique and does not repeat. **Date** is the primary key of
    the **Date** table.
  prefs: []
  type: TYPE_NORMAL
- en: For the **Strike Reports** table, **Incident Date** is the foreign key value
    that will map to the **Date** table. The column represents the date that a wildlife
    strike was reported to have happened. The column is also fully populated with
    valid data.
  prefs: []
  type: TYPE_NORMAL
- en: Since the **Date** table contains a valid primary key, and **Incident Date**
    on the **Strike** **Reports** table is a valid **Date** field, you do not need
    to do any additional transformations. The columns are ready for a relationship
    in the dataset!
  prefs: []
  type: TYPE_NORMAL
- en: Aircraft Type Info
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the **Aircraft** **Type** **Info** table, you see a text column named **Aircraft**
    **Code**. Each row contains a unique letter that identifies the row. **Aircraft**
    **Classification** is another column that provides a description of the type of
    aircraft. If working with extremely large data volumes, integer key values are
    a best practice. However, since the total data volume is a manageable size, you’re
    fine using the character text values as a primary key for the **Aircraft** **Type**
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Strike** **Reports** table contains a corresponding column named **Aircraft**
    **Class** **Code**. You left-click the caret next to the column name and select
    **Load** **More** to see all the possible unique values in the table. You notice
    that there are values registering as both **(null)**, which is actually blank,
    and the four-letter value **NULL**, which is a text entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – A screenshot showing (null) and NULL text values](img/Figure_3.01_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – A screenshot showing (null) and NULL text values
  prefs: []
  type: TYPE_NORMAL
- en: The **NULL** text value does not exist in the Aircraft Type Info query. It differs
    from **(null)** because **NULL** contains actual text while **(null)** is an empty
    value. If you filter the column for either **(null)** or the **NULL** text value,
    you notice that the rows containing those values appear to have differences. Most
    of the blank **(null)** values are on rows where wildlife was struck by unknown
    flights and many columns are blank, while some of the **NULL** text values contain
    **Flight** numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you build out data for use with Power BI ML, you will want to remove or
    replace all blank values since ML models usually need a design that does not have
    null values. Power BI datasets still work with null foreign key values, but that
    approach is not ideal. You decide to add two new rows to the Aircraft Type Info
    query, one for the **NULL** text value and one for blank values that show up as
    **(null)**. You will also need to replace the blank values in the Strike Reports
    query. Here are the steps you need to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `null` for `blank` for `blank`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Home** ribbon of Power Query, select **Enter Data**. Name the new table
    **Aircraft Type Added Data**. Create two columns, **Aircraft Code** and **Aircraft
    Classification**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `blank` for both columns in row 1 and `NULL` for both columns in row
    2\. Your table should look like this before hitting **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.2 – New data for Aircraft Type to account for blanks and the text\
    \ valu\uFEFFe NULL](img/Figure_3.02_B19500.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – New data for Aircraft Type to account for blanks and the text value
    NULL
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click the new query in the **Queries** pane, and move it to the **Raw
    Data** group. Right-click it again, and uncheck **Enable Load**. Power Query should
    now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.3 – New data added to the Raw Data group that will not be loaded
    to the dataset](img/Figure_3.03_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – New data added to the Raw Data group that will not be loaded to
    the dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'Left-click on the **Aircraft Type Info** query. On the Power Query ribbon,
    under **Home** | **Combine**, select **Append Queries** | **Append Queries**.
    Append the **Aircraft Type Added Data** query. Your **Aircraft Type Info** query
    should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – New rows added to Aircraft Type Info query](img/Figure_3.04_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – New rows added to Aircraft Type Info query
  prefs: []
  type: TYPE_NORMAL
- en: Now, both the **Strike Reports** query and the **Aircraft Type Info** query
    will have referential integrity, meaning that when you populate the dataset, every
    key value on the **Strike Reports** table will be a value that finds a match on
    the **Aircraft Type Info** table. The **Aircraft Type Info** query is ready to
    go!
  prefs: []
  type: TYPE_NORMAL
- en: Engine Codes Info
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As noted previously, you’ve already determined that **Manufacturer Code** and
    **Model Code** are compound keys matching up with **AMA** and **AMO** from the
    **Strike Reports** query. For the **Engine Codes Info** query, you observe that
    a combination of **Manufacturer Code** and **Model Code** results in a unique
    row definition. On the **Strike Reports** query, you browse the values in the
    **AMA** and **AMO** columns to find that there are blank **(null)** values in
    both columns and some invalid values that will not match up with the **Engine
    Codes Info** query. You evaluate a few options for handling these discrepancies:'
  prefs: []
  type: TYPE_NORMAL
- en: Account for all of the incomplete and non-matching values by adding new rows
    to the **Engine Codes** **Info** query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Break off the **Engine Manufacturing** data into a separate query, which will
    be a new dimension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new row to the `Incomplete or Missing`. A new foreign key will be added
    to the **Engine Codes Info** query for incomplete or missing compound key values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the first and second options would follow best practices, you decide to
    move ahead with option three (put all of the incomplete entries and mismatched
    values into a single bucket) for your first round of development. If you determine
    later that better matches will improve your results in a meaningful way, you can
    always circle back in future rounds of development. Options one and two would
    require significant effort, and right now, you doubt that the benefits would justify
    the investment of time. You have a deadline to meet! Changing the architecture
    in the future will still be a valid option due to the flexibility of Power Query
    and Power BI.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, begin by adding a new row to the **Engine Codes Info** query. Create
    a new query in the **Raw Data** group called **Engine Codes Added Data**, just
    as you did with **Aircraft Type** **Added Data**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the ribbon of Power Query, select **Enter Data**. Name the new table **Engine
    Codes Added Data**. Create four columns: **Manufacturer Code**, **Model Code**,
    **Engine Manufacturer**, and **Engine Model**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `Incomplete or Missing` for all four columns in row 1\. Your table should
    look like this before hitting **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Incomplete or missing key values can be bucketed in the report
    for Engine Codes](img/Figure_3.05_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Incomplete or missing key values can be bucketed in the report
    for Engine Codes
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the new query in the **Queries** pane, and move it to the **Raw
    Data** group. Right-click it again, and uncheck **Enable Load**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Left-click on the **Engine Codes Info** query. On the Power Query ribbon, under
    **Home** | **Combine**, select **Append Queries** | **Append Queries**. Append
    the **Engine Codes Added Data** query. Your **Engine Codes Info** query now contains
    the additional row of data. Power Query should now look like this (notice that
    **Incomplete or Missing** is now in the table):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – The Engine Codes Info query now has a bucket for missing and
    incomplete key values](img/Figure_3.06_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – The Engine Codes Info query now has a bucket for missing and incomplete
    key values
  prefs: []
  type: TYPE_NORMAL
- en: 'Power BI datasets require a single key column, and do not support compound
    keys. You’ll need to add a single primary key to the **Engine Codes Info** query.
    On the Power Query ribbon, select **Add Column** | **General** | **Index Column**
    | **From 1**. Rename the new **Index** column to **Engine Codes Info Key**. The
    **Engine Codes Info** query now looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Integer primary key value added to the Engine Codes Info query](img/Figure_3.07_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Integer primary key value added to the Engine Codes Info query
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you will add a corresponding foreign key to the **Strike Reports** query.
    While on the **Strike** **Reports** query in Power Query, select **Home** | **Combine**
    | **Merge Queries** | **Merge Queries**. Select **Engine Codes Info** as the second
    table. Click on **EMA** on the **Strike Reports** table and **Manufacturer Code**
    on the **Engine Codes Info** table. You’ll see that greater than 50% of the rows
    found a match:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Not all of the EMA values from Strike Reports found a match
    on the Engine Codes Info query](img/Figure_3.08_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Not all of the EMA values from Strike Reports found a match on
    the Engine Codes Info query
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the table matches up via a compound key, **EMA** and **EMO** to **Manufacturer
    Code** and **Model Code**, you press Ctrl and click **EMO** on the **Strike Reports**
    table and **Model Code** for the **Engine Codes Info** table. You lose a few matches
    versus the **Manufacturer** keys alone, which would justify breaking off the **Manufacturer**
    information into a separate dimension table. However, since the difference is
    small, you decide to add breaking out **Manufacturer** as a separate dimension
    to the backlog for future rounds of development. If you don’t get any matches,
    check to ensure that the **EMA** and **EMO** columns in both tables are text values
    since data types need to be the same. Proceeding with the current plan will still
    give you a fairly similar match rate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.9 – A compound key can tie together Strike Reports and Engine Codes
    Info but not every row finds a match](img/Figure_3.09_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – A compound key can tie together Strike Reports and Engine Codes
    Info but not every row finds a match
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **OK**. You’ll see a new column was added to **Strike Reports** named
    **Engine Codes Info**. Click the caret and select only **Engine Codes** **Info
    Key**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.10 – A foreign key for Engine Codes Info was added to Strike Reports](img/Figure_3.10_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – A foreign key for Engine Codes Info was added to Strike Reports
  prefs: []
  type: TYPE_NORMAL
- en: Click **OK**. You now have a single foreign key value, **Engine Codes Info Key**,
    for the **Engine Codes Info** table in your dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's move on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Engine Position Info
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You previously determined that **Engine Code** on the **Engine Position Info**
    table was a primary key for the table, and all four of the columns (**Engine 1
    Position Code**, **Engine 2 Position Code**, **Engine 3 Position Code**, and **Engine
    4 Position Code**) from the **Wildlife Strikes** query were foreign keys referencing
    the engine position. You revisit the preliminary data model, which includes **Engine
    Position Info** as a dimension table referencing **Strike Reports** as a fact
    table. Since there is not a single foreign key on the **Engine Position Info**
    table referencing a single primary key on the **Strike Reports** table, a dimensional
    design can be handled in a few different ways, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A separate fact table having a separate row for each engine position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the granularity of the existing fact table to have a separate row for
    each engine position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a separate copy of **Engine Position Info** for each of the four foreign
    key columns on the **Strike** **Reports** table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add inactive relationships between the **Engine Position Info** and **Strike
    Reports** table that can be switched out interactively using the DAX expression
    language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option might be a valid choice if significant analytics were to be
    performed on the engine positions and you were building a complex star schema
    design. The second and third options would work from a logical perspective but
    would add unnecessary complexity and bloat to your design. Remember, you will
    be performing analytics for the purpose of building predictive models using ML
    in Power BI. Keeping the columns on the **Strike Reports** table in the current
    format will work well for building queries to be used for ML purposes. You know
    that Power BI ML works best with simple flattened tables of data, with each of
    those four columns as a potential feature of the data. You decide to proceed with
    the fourth option since it works best for your ML use case and will not add bloat
    or unnecessary complexity to your design.
  prefs: []
  type: TYPE_NORMAL
- en: 'You take a look at the data within the **Engine 1 Position Code**, **Engine
    2 Position Code**, **Engine 3 Position Code**, and **Engine 4 Position Code**
    columns of the **Strike Reports** table. All four columns are similar to the **Aircraft
    Class Code** column that you previously reviewed in having both **(null)** entries,
    which are actually blank, and the four-letter **NULL** value, which is a text
    entry. You handle this scenario in a similar manner by adding two new rows to
    the **Engine Position Info** query for **blank** and **NULL** entries:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click each of the `null` for `blank` for **Replace With**. Now, all of
    the empty values will contain the word **blank**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the ribbon of Power Query, select **Enter Data**. Name the new table **Engine
    Position Added Data**. Create two columns, **Engine Code** and **Location** **of
    Engine**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `blank` for both columns in row 1 and `NULL` for both columns in row 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click the new query in the **Queries** pane, and move it to the **Raw
    Data** group. Right-click it again, and uncheck **Enable Load**. Power Query should
    now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.11 – New data to account for blank and NULL text values in Engine
    Position](img/Figure_3.11_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – New data to account for blank and NULL text values in Engine Position
  prefs: []
  type: TYPE_NORMAL
- en: 'Left-click on the **Engine Position Info** query. On the Power Query ribbon,
    under **Home** | **Combine select Append Queries** | **Append Queries**, append
    the **Engine Position Added Data** query. Your **Engine Position Info** query
    should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Engine Position Info can now match for blank rows and the NULL
    text value](img/Figure_3.12_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Engine Position Info can now match for blank rows and the NULL
    text value
  prefs: []
  type: TYPE_NORMAL
- en: You are sure to note that although it is a best practice to use integer values
    for primary and foreign keys, Power BI has the flexibility and performance to
    handle text values as key columns in this solution. Replacing all of the key values
    on these tables with integer values would introduce unnecessary complexity at
    this point in your efforts.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you are ready to start building your Power BI dataset!
  prefs: []
  type: TYPE_NORMAL
- en: Building a Power BI dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You review the preliminary data model design from your earlier efforts, and
    note that you have approached a fork for which the relational analytic data that
    will populate the Power BI dataset will likely have differences from the flattened
    data used for ML in Power BI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – You will now populate Power Query queries for the Power BI
    dataset](img/Figure_3.13_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – You will now populate Power Query queries for the Power BI dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to keep your work both organized and optimized for future changes,
    you decide to create a new group in Power Query that will contain the tables for
    the Power BI dataset. You take note that when working with extremely large data
    volumes or a complex data model, avoiding complexity within Power Query is often
    a best practice. However, with your data volumes, complexity, and overall use
    case, it makes sense to have separate groups for different segments of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new group within **Queries** called **Curated** **Dataset Tables**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click each of the **Strike Reports**, **Aircraft Type Info**, **Engine
    Codes Info**, **Engine Position Info**, and **Date** queries, and select **Reference**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move each of those new queries into the **Curated Dataset** **Tables** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the queries for readability to **Strike reports Fact**, **Aircraft Type
    Dim**, **Engine Codes Dim**, **Engine Position Dim**, and **Date Dim**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the **Curated Reporting Queries** group, right-click each query and uncheck
    **Enable Load**. These queries do not need to be imported and cached within Power
    BI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Power Query should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Queries that will be populated as tables in the Power BI dataset](img/Figure_3.14_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Queries that will be populated as tables in the Power BI dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time for your dataset to blast off! First, you will go through the
    following steps to build your Power BI dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: Import and process the **Wildlife Strike** data queries from Power Query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create relationships between fact and dimension tables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clean up the metadata and adjust the settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Importing and processing the Wildlife Strike data queries from Power Query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You run the full queries and import the **Wildlife Strike** data for your dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Power Query ribbon, select **Home** | **Close** | **Close & Apply** |
    **Close & Apply**. Your dataset will populate with data imported using the Power
    Query transformations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After importing the data, Power Query is closed and you are in the primary interface
    of Power BI Desktop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the left side of the application, click the **Model** view and arrange the
    tables in a manner that is easy to read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Arrange the dataset tables in the Model view](img/Figure_3.15_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Arrange the dataset tables in the Model view
  prefs: []
  type: TYPE_NORMAL
- en: Creating relationships between fact and dimension tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, you’ll create relationships between the tables of data. On the **Date
    Dim** table, drag the **Date** column and drop it on the **Incident Date** column
    of the **Strike Reports Fact** table. Power BI will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – A relationship has been created between Strike Reports Fact
    and Date Dim](img/Figure_3.16_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – A relationship has been created between Strike Reports Fact and
    Date Dim
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click on the relationship line to reveal that the relationship was determined
    to be a many-to-one with a cross-filter direction of **Single**. The arrow on
    the relationship line indicates that the **Date Dim** table can filter the **Strike
    Reports Fact** table, but not the other way around. The **Make this relationship
    active** box is also checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – The cardinality and filter direction are set to Many to one
    and Single](img/Figure_3.17_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – The cardinality and filter direction are set to Many to one and
    Single
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat the process by dragging and dropping the remaining columns to the **Strike
    Reports** **Fact** table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Source Table (Column)** | **Destination** **Table (Column)** | **Cardinality**
    | **Cross** **–** **filter direction** | **Make this relationship active** |'
  prefs: []
  type: TYPE_TB
- en: '| Strike Reports Fact (Aircraft Class Code) | Aircraft Type Dim (Aircraft Code)
    | Many to one (fact to dimension) | Single (dimension to fact) | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Strike Reports Fact (Engine Codes Info Key) | Engine Codes Dim (Engine Codes
    Info Key) | Many to one (fact to dimension) | Single (dimension to fact) | Yes
    |'
  prefs: []
  type: TYPE_TB
- en: '| Strike Reports Fact (Engine 1 Position Code) | Engine Position Dim (Engine
    Code) | Many to one (fact to dimension) | Single (dimension to fact) | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Strike Reports Fact (Engine 2 Position Code) | Engine Position Dim (Engine
    Code) | Many to one (fact to dimension) | Single (dimension to fact) | No |'
  prefs: []
  type: TYPE_TB
- en: '| Strike Reports Fact (Engine 2 Position Code) | Engine Position Dim (Engine
    Code) | Many to one (fact to dimension) | Single (dimension to fact) | No |'
  prefs: []
  type: TYPE_TB
- en: '| Strike Report Fact (Engine 2 Position Code) | Engine Position Dim (Engine
    Code) | Many to one (fact to dimension) | Single (dimension to fact) | No |'
  prefs: []
  type: TYPE_TB
- en: Figure 3.18 – Relationship settings between the Strike Reports Fact table and
    dimension tables
  prefs: []
  type: TYPE_NORMAL
- en: 'Your Power BI model view should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Completed relational design for the Power BI dataset](img/Figure_3.19_B19500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – Completed relational design for the Power BI dataset
  prefs: []
  type: TYPE_NORMAL
- en: The relationships between tables are now defined and complete.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up the metadata and adjusting settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, you move on to clean up the metadata so that the end users of the analytic
    reports can easily understand the content of the dataset. This process will involve
    the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Hiding unnecessary columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting **Summarization** and **Data** **Category** settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting settings for the **Date** **Dim** table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding unnecessary columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Columns that serve as a foreign key or surrogate primary key remain part of
    the browsable solution for report developers and viewers by default. You hide
    the visibility of these columns since they are part of the dataset for relationships
    but do not have a practical use in reporting. In the **Fields** panel on the right-hand
    side of the screen, right-click on these columns and select **Hide in** **report
    view**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table (Column)** **to Hide** |'
  prefs: []
  type: TYPE_TB
- en: '| Engine Codes Dim (Engine Codes Info Key) |'
  prefs: []
  type: TYPE_TB
- en: '| Strike Reports Fact (Engine Codes Info Key) |'
  prefs: []
  type: TYPE_TB
- en: '| Strike Reports Fact (Incident Date) |'
  prefs: []
  type: TYPE_TB
- en: '| Strike Reports Fact (Aircraft Class Code) |'
  prefs: []
  type: TYPE_TB
- en: Figure 3.20 – Columns that aren’t needed in the reports are hidden
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting Summarization, Data Category, Format, and Sort by settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Power BI provides settings for columns of data that impact how the data is
    displayed and aggregated in reports. The **Summarization** setting determines
    whether numeric values will add/average/min/max or whether they are not intended
    to be used for math. The **Don’t Summarize** setting will ensure that numeric
    values do not get summarized by default. **Data Category** settings will determine
    how data is displayed within the context of maps, URLs, and so on when added to
    reports. When you highlight a column, **Summarization** and **Data Category**
    are on the Power BI data view ribbon at **Column Tools** | **Properties**. **Format**
    is also configured on the ribbon, and determines the display characteristics on
    the page such as decimal points. **Sort by** determines a column to sort another
    column, such as using numeric values 1-12 to sort the months January through February
    on a data visualization. You use the following settings for columns in this solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table (Column)** | **Summarization** | **Data Category** | **Format** |
    **Sort by** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Strike Reports` `Fact (Latitude)` | Don’t Summarize | Latitude | Decimal
    number with 7 places |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Strike Reports` `Fact (Longitude)` | Don’t Summarize | Longitude | Decimal
    number with 7 places |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Strike Reports` `Fact (State)` | Don’t Summarize | State or Province | Text
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Strike Reports Fact (``Enroute State)` | Don’t Summarize | State or Province
    | Text |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Date (``Quarter Year)` | Don’t Summarize |  | Text | **Date (****Quarter
    Num)** |'
  prefs: []
  type: TYPE_TB
- en: '| `Date (``Month Name)` | Don’t Summarize |  | Text | **Date (****Month Num)**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Date (Month` `Name Short)` | Don’t Summarize |  | Text | **Date (****Month
    Num)** |'
  prefs: []
  type: TYPE_TB
- en: '| `Date (``Month Year)` | Don’t Summarize |  | Text | **Date (Month** **Year
    Order)** |'
  prefs: []
  type: TYPE_TB
- en: '| `Date (``Week Year)` | Don’t Summarize |  | Text | **Date (Week** **Year
    Order)** |'
  prefs: []
  type: TYPE_TB
- en: '| `Date (``Day Name)` | Don’t Summarize |  | Text | **Date (Day** **Num Week)**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Date (Day` `Name Short)` | Don’t Summarize |  | Text | **Date (Day** **Num
    Week)** |'
  prefs: []
  type: TYPE_TB
- en: Figure 3.21 – Categories, summarization, format, and sort settings for columns
  prefs: []
  type: TYPE_NORMAL
- en: As you build out your analytical report and determine suitable features for
    ML in Power BI, you may modify more settings and add to this list.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting settings for the Date Dim table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Specifying the **Date Dim** table as an official date table will unlock capabilities
    in Power BI such as **Time Intelligence**. Marking the **Date Dim** table as an
    official date table can be accomplished by navigating to **Table Tools** | **Calendars**
    | **Mark as date table** in the **Data** view and selecting **Date** as the official
    date column for the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Having built out the foundation of the relational model in the Power BI dataset,
    you can move on to build runtime calculations. You’ve got the data model set up
    the way you need it, but adding some logic to the semantic layer for mathematical
    operations will empower you to dive deeper with analytics.
  prefs: []
  type: TYPE_NORMAL
- en: Adding measures to your Power BI dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a final activity for this chapter, you will add a few basic measures to the
    Power BI dataset. Measures are not stored on the tables of data but rather during
    runtime on reports. These measures will be used to do mathematics such as total
    number of reports, average damage cost amounts, average height of contact calculations,
    and more. For now, you choose a few basic measures that will give you a starting
    point for analysis. In future chapters, you can add more measures as you discover
    new perspectives within the data.
  prefs: []
  type: TYPE_NORMAL
- en: Measures can be added using the DAX expression language, which is a key skill
    for Power BI. Most of the formulas will be fairly simple for anyone who is familiar
    with writing formulas in Excel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following measures in the **Data** view of Power BI while the **Strike
    Reports Fact** table is highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **DAX formula** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Incidents | `Incidents = COUNTROWS(''Strike` `Reports Fact'')` | This formula
    will calculate a count of the total incidents that were reported |'
  prefs: []
  type: TYPE_TB
- en: '| Average Speed | `Average Speed =` `AVERAGE([Speed])` | An average speed for
    incidents at the time of impact |'
  prefs: []
  type: TYPE_TB
- en: '| Average Height | `Average Height =` `AVERAGE([Height])` | An average height
    for incidents at the time of impact |'
  prefs: []
  type: TYPE_TB
- en: '| Total Cost of Repairs | `Total Cost of Repairs = SUM([Cost` `of Repairs])`
    | A sum of all repair costs |'
  prefs: []
  type: TYPE_TB
- en: '| Average Cost of Repairs | `Average Cost of Repairs = SUM([Cost` `of Repairs])`
    | An average of all repair costs |'
  prefs: []
  type: TYPE_TB
- en: '| Incidents with Costs | `Incidents with Costs = CALCULATE([Incidents],FILTER(''Strike
    Reports Fact'',[Cost of Repairs] >` `0)` | A count of incidents that resulted
    in costs incurred |'
  prefs: []
  type: TYPE_TB
- en: '| Percentage Incidents with Costs | `Percentage Incidents with Costs = DIVIDE([Incidents`
    `with Costs],[Incidents])` | A percentage of incidents that resulted in costs
    incurred |'
  prefs: []
  type: TYPE_TB
- en: Figure 3.22 – Calculated measures and the corresponding DAX expressions
  prefs: []
  type: TYPE_NORMAL
- en: As you progress in your exploration of the data, you will probably add more
    measures to your list. The measures listed in the preceding table are a good start
    before moving to your next phase of analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you designed key values for tables in a Power BI dataset, created
    a Power BI dataset, and added measures to the Power BI dataset. You have progressed
    from exploring and understanding raw data to working with a multidimensional dataset
    in Power BI that contains runtime measures. You now have the basic foundation
    for analytics and building an analytics report.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will build an analytical report that dives into the
    data and uncovers features that you will earmark for machine learning in Power
    BI. As you enrich the analytical report and discover new features, you will also
    begin to build out the datasets in Power Query that will be used to train and
    test using Power BI ML.
  prefs: []
  type: TYPE_NORMAL
