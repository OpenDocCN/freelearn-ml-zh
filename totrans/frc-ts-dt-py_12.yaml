- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performing Cross-Validation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of keeping training data and testing data separate is sacrosanct
    in machine learning and statistics. You should never train a model and test its
    performance on the same data. Setting data aside for testing purposes has a downside,
    though: that data has valuable information that you would want to include in training.
    **Cross-validation** is a technique that’s used to circumvent this problem.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: You may be familiar with **k-fold cross-validation**, but if you are not, we
    will briefly cover it in this chapter. K-fold cross-validation, however, will
    not work on time series data. It requires that the data be independent, an assumption
    that time series data does not hold. An understanding of k-fold cross-validation
    will help you learn how forward-chaining cross-validation works and why it is
    necessary for time series data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'After learning how to perform cross-validation in Prophet, you will learn how
    to speed up the computing of cross-validation through Prophet’s ability to parallelize
    several processes. All in all, this chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Performing k-fold cross-validation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing forward-chaining cross-validation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Prophet cross-validation DataFrame
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallelizing cross-validation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data files and code for examples in this chapter can be found at [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Performing k-fold cross-validation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll be using a new dataset in this chapter – the sales of an online retailer
    in the United Kingdom. This data has been anonymized, but it represents 3 years
    of daily sales amounts, as displayed in the following graph:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Daily sales of an anonymous online retailer](img/Fig_12.1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Daily sales of an anonymous online retailer
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: This retailer has not seen dramatic growth over the 3 years of data, but it
    has seen a massive boost in sales at the end of each year. The main customers
    of this retailer are wholesalers, who typically make their purchases during the
    work week. This is why when we plot the components of Prophet’s forecast, you’ll
    see that Saturday and Sunday’s sales are the lowest. We’ll use this data to perform
    cross-validation in Prophet.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get to modeling, though, let’s first review traditional validation
    techniques used to tune a model’s hyperparameters and report performance. The
    most basic method is to take your full dataset and split it into three subsets:
    a **training set**, **validation set**, and **test set**, after randomly shuffling
    it around. This is sometimes called **hold-out** validation. Usually, the training
    set is the largest and the validation and testing sets are smaller. For example,
    a 60/20/20 split would look like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Traditional train/validation/test sets](img/Fig_12.2.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Traditional train/validation/test sets
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 传统的训练/验证/测试集
- en: After the full data has been split, your model is trained on the train set,
    and performance is evaluated on the validation set. A new set of hyperparameters
    is chosen for the given algorithm and the model is retrained on the train set
    and re-evaluated on the validation set. This process is repeated for however many
    combinations of hyperparameters you want to try.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在完整数据被分割后，你的模型在训练集上训练，并在验证集上评估性能。为给定的算法选择一组新的超参数，并在训练集上重新训练模型，并在验证集上重新评估。这个过程会重复进行，直到尝试多少种超参数组合。
- en: The set of hyperparameters with the highest performance on the validation set
    is chosen for the model; the train and validation sets are combined to train a
    final model, and this final model is evaluated on the test set. This evaluation
    is then reported as the model’s performance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证集上性能最高的超参数集被选为模型；训练和验证集合并以训练最终模型，并在测试集上评估这个最终模型。这个评估结果随后报告为模型的性能。
- en: With this technique, though, only 60% of your full data is available to use
    to tune the model. It would be advantageous to use more data for tuning but using
    smaller validation and testing sets could introduce bias into your model.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这种技术，你只有60%的完整数据可用于调整模型。使用更多数据进行调整可能会有所帮助，但使用较小的验证和测试集可能会引入模型偏差。
- en: 'To solve this problem, k-fold cross-validation was developed. In k-fold cross-validation,
    the data is still randomly shuffled and has a test set split out, maybe 20% again.
    The remaining 80% of the data is all used for training. This 80% of data is split
    into *k* sections, with each section called a *fold*. This is what the process
    looks like with five folds:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，开发了k折交叉验证。在k折交叉验证中，数据仍然随机洗牌，并分割出一个测试集，可能是20%的数据。剩余的80%数据全部用于训练。这80%的数据被分成*k*个部分，每个部分称为一个*折*。以下是五个折的过程：
- en: '![Figure 12.3 – k-fold cross-validation with five folds](img/Fig_12.3.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 五折交叉验证](img/Fig_12.3.jpg)'
- en: Figure 12.3 – k-fold cross-validation with five folds
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 五折交叉验证
- en: For each set of hyperparameters you want to evaluate, you train your model five
    times. The first time, you set aside the first fold and train on the remaining
    four. You evaluate on that first fold. You repeat this process for each fold and
    take the average of your performance metric across the five folds. Then, you move
    on to the next set of hyperparameters and repeat.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你想要评估的每一组超参数，你将模型训练五次。第一次，你预留第一个折，并在剩余的四个折上训练。你在第一个折上进行评估。你重复这个过程，对每个折进行操作，并取五个折的性能指标的平均值。然后，你继续到下一组超参数，并重复。
- en: The process of tuning your hyperparameters takes much longer in this case because
    of the training for each fold. The advantage, though, is that you can use more
    data for training without introducing bias into your model.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个折的训练，调整超参数的过程在这种情况下会花费更长的时间。然而，优势在于你可以在不引入模型偏差的情况下使用更多数据进行训练。
- en: As you know, time series data is sequential and dependent. You cannot shuffle
    it. You cannot train on future data to predict previous data. This is why both
    of the methods just demonstrated will not work. We need a way to maintain the
    order of our data while still setting some aside for testing and validation. That’s
    why forward chaining was developed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，时间序列数据是顺序和相关的。你不能对其进行洗牌。你不能在未来的数据上训练以预测以前的数据。这就是为什么刚刚展示的两种方法都不适用的原因。我们需要一种方法来保持我们数据的顺序，同时仍然留出一部分用于测试和验证。这就是为什么开发了正向链。
- en: Performing forward-chaining cross-validation
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行正向链交叉验证
- en: '**Forward-chaining cross-validation**, also called **rolling-origin cross-validation**,
    is similar to k-fold cross-validation but is better suited to sequential data
    such as time series. There is no random shuffling of data to begin with, but a
    test set may be set aside. The test set must be the final portion of data, so
    if each fold is going to be 10% of your data (as it would be in 10-fold cross-validation),
    then your test set will be the final 10% of your date range.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**正向链交叉验证**，也称为**滚动起点交叉验证**，与k折交叉验证类似，但更适合序列数据，如时间序列。一开始没有对数据进行随机洗牌，但可以预留一个测试集。测试集必须是数据的最后部分，所以如果每个折将占你数据的10%（就像在10折交叉验证中那样），那么你的测试集将是数据范围的最后10%。'
- en: 'With the remaining data, you choose an initial amount of data to train on,
    let’s say five folds in this example, and then you evaluate on the sixth fold
    and save that performance metric. You retrain now on the first six folds and evaluate
    on the seventh. You repeat this until all folds are exhausted and again take the
    average of your performance metric. The folds using this technique would look
    like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在剩余的数据中，你选择一个初始数据量用于训练，例如，在这个例子中是五个折，然后你在第六个折上评估并保存那个性能指标。现在你在前六个折上重新训练，并在第七个折上评估。你重复此过程，直到所有折都耗尽，然后再次取性能指标的平均值。使用这种技术的方法将如下所示：
- en: '![Figure 12.4 – Forward-chaining cross-validation with five folds](img/Fig_12.4.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – 前向链式交叉验证的五折](img/Fig_12.4.jpg)'
- en: Figure 12.4 – Forward-chaining cross-validation with five folds
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 前向链式交叉验证的五折
- en: In this way, you are able to train your data on sequential data points and evaluate
    unseen data, and you are also able to minimize bias by training and testing on
    a variety of samples.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，你能够在序列数据点上训练你的数据，并评估未见过的数据，同时也能够通过在多种样本上训练和测试来最小化偏差。
- en: Prophet has a built-in diagnostics tool for performing forward-chaining cross-validation.
    Let’s now see how to use it with our retail sales dataset.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet有一个内置的诊断工具用于执行前向链式交叉验证。现在让我们看看如何使用我们的零售销售数据集来使用它。
- en: Creating the Prophet cross-validation DataFrame
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Prophet交叉验证DataFrame
- en: 'To perform cross-validation in Prophet, first, you need a fitted model. So,
    we’ll begin with the same procedure we’ve completed throughout this book. This
    dataset is very cooperative, so we’ll be able to use plenty of Prophet’s default
    parameters. We will plot the changepoints, so be sure to include that function
    with your other imports before loading the data:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Prophet中执行交叉验证之前，首先你需要一个拟合好的模型。因此，我们将从本书中完成过的相同程序开始。这个数据集非常合作，因此我们将能够使用Prophet的大量默认参数。我们将绘制变化点，所以请确保在加载数据之前将此功能与其他导入项一起包含：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This dataset does not have very complicated seasonality, so we’ll reduce the
    Fourier order of yearly seasonality when instantiating our model, but keep everything
    else default, before fitting, predicting, and plotting. We’ll use a 1-year future
    forecast:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据集的季节性并不复杂，因此在我们实例化模型时，我们将降低年季节性的傅里叶阶数，但保持其他所有设置默认，在拟合、预测和绘图之前。我们将使用1年的未来预测：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As expected, this plot shows the same data as *Figure 12**.1* where the data
    was introduced. There were no significant trend changepoints identified and a
    very gently sloping upward trend. There appears to be a mild increase in sales
    during the summer but a dramatic increase over the winter holiday season, as can
    be seen in the following plot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，此图显示了与*图12.1*中引入数据相同的相同数据。没有识别出显著的趋势变化点，并且有一个非常平缓的上升趋势。夏季似乎有轻微的销售增长，但在冬季假日季节有显著增长，如以下图所示：
- en: '![Figure 12.5 – Online retail sales forecast](img/Fig_12.5.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 在线零售销售额预测](img/Fig_12.5.jpg)'
- en: Figure 12.5 – Online retail sales forecast
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 在线零售销售额预测
- en: 'Let’s plot the components now to better understand our seasonalities:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制组成部分，以更好地理解我们的季节性：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`trend`, `weekly` seasonality, and `yearly` seasonality show clear patterns:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`trend`、`weekly`季节性和`yearly`季节性显示出明显的模式：'
- en: "![Figure 12.6 – Online retail sales components plot\uFEFF](img/Fig_12.6.jpg)"
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 在线零售销售额组成部分图](img/Fig_12.6.jpg)'
- en: Figure 12.6 – Online retail sales components plot
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 在线零售销售额组成部分图
- en: As we predicted, the `yearly` seasonality reflects that winter spike. As I mentioned
    when introducing this data, the retailer largely caters to wholesalers, not consumers.
    So, their purchasing occurs during the business week far more than on the weekends.
    `Friday` sales are even down compared with the rest of the week.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预测的，`yearly`季节性反映了冬季的峰值。正如我在介绍此数据时提到的，零售商主要服务于批发商，而不是消费者。因此，他们的购买行为在商业周中远多于周末。与一周中的其他日子相比，`周五`的销售甚至有所下降。
- en: 'Now, let’s perform the actual cross-validation. To do that, we first need to
    import the function from Prophet’s `diagnostics` package:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行实际的交叉验证。为此，我们首先需要从Prophet的`diagnostics`包中导入函数：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Before we see how to use that function, there are some terms we need to discuss:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解如何使用该函数之前，有一些术语我们需要讨论：
- en: '`initial` is the first training period. In *Figure 12**.5*, it would be the
    first five blocks of data in the first fold. It is the minimum amount of data
    needed to begin your training.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial` 是第一个训练周期。在 *图12*.5 中，它将是第一个折叠中的前五个数据块。这是开始训练所需的最小数据量。'
- en: '`horizon` is the length of time you want to evaluate your forecast over. Let’s
    say that this retail outlet is building its model so that it can predict sales
    over the next month. A horizon set to 30 days would make sense here so that they
    evaluate their model on the same parameter setting that they wish to use it on.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`horizon` 是你想要评估预测的时间长度。比如说，这个零售店正在构建一个模型，以便它可以预测下一个月的销售。将预测范围设置为30天在这里是有意义的，这样他们就可以在希望使用的相同参数设置上评估他们的模型。'
- en: '`period` is the amount of time between each fold. It can be either greater
    than the horizon or less than it, or even equal to it.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`period` 是每个折叠之间的时间量。它可以大于或小于预测范围，甚至等于它。'
- en: '`cutoffs` are the dates when each horizon will begin.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cutoffs` 是每个 `horizon` 开始的日期。'
- en: 'This vocabulary is illustrated here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个词汇表在这里得到了说明：
- en: '![Figure 12.7 – Cross-validation terminology](img/Fig_12.7.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7 – 交叉验证术语](img/Fig_12.7.jpg)'
- en: Figure 12.7 – Cross-validation terminology
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 交叉验证术语
- en: For each `cutoff`, the model will be trained on all data up to that `cutoff`,
    and then a prediction will be made for the `horizon` period. That prediction will
    be compared to the known values and evaluated. Then, the model will be retrained
    on all data up to the second `cutoff` and the process will be repeated. The final
    performance evaluation will be the average of the performance at each cutoff.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个 `cutoff`，模型将在截止日期之前的所有数据上进行训练，然后对 `horizon` 期间进行预测。这个预测将与已知值进行比较和评估。然后，模型将在截止日期之前的所有数据上进行重新训练，这个过程将重复进行。最终的性能评估将是每个截止点的性能的平均值。
- en: Let’s imagine that this retail outlet wants a model that is able to predict
    the next month of daily sales, and they plan on running the model at the beginning
    of each quarter. They have 3 years of data and want (as is recommended for Prophet)
    at least 2 full cycles of seasonality, which because they are modeling yearly
    seasonality will be 2 years.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象这个零售店希望有一个能够预测下一个月每日销售的模型，并且他们计划在每个季度的开始运行这个模型。他们有3年的数据，并且希望（正如Prophet所推荐的那样）至少有2个完整的季节周期，由于他们正在模拟年度季节性，这将需要2年。
- en: They would set their initial training data to be 2 years then. They want to
    predict the next month of sales, and so would set `horizon` to 30 days. They plan
    to run the model each business quarter, and so would set the period to be 90 days.
    That’s what was shown previously in *Figure 12**.7*. Now, let’s apply this to
    Prophet.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 他们将初始训练数据设置为2年。他们想要预测下一个月的销售，因此将 `horizon` 设置为30天。他们计划每个业务季度运行模型，因此将周期设置为90天。这就是之前在
    *图12*.7 中所示的内容。现在，让我们将此应用于Prophet。
- en: 'The `cross_validation` function takes two required arguments, the fitted model
    and `horizon`. Also, `period` and `initial` can be stated, but they are not required.
    If left as their defaults, `period` is half of `horizon` and `initial` will be
    three times `horizon`. The output of the function is the cross-validation DataFrame.
    Let’s create this DataFrame and call it `df_cv`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`cross_validation` 函数接受两个必需的参数，即拟合的模型和 `horizon`。`period` 和 `initial` 也可以指定，但不是必需的。如果保留为默认值，`period`
    是 `horizon` 的一半，而 `initial` 将是 `horizon` 的三倍。该函数的输出是交叉验证的DataFrame。让我们创建这个DataFrame，并将其命名为
    `df_cv`：'
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each of the `horizon`, `period`, and `initial` arguments takes a string with
    a style compatible with pandas’ `Timedelta` format, for example, `'5 days'`, `'3
    hours'`, or `'10 seconds'`. In this example, we’re switching the `horizon` and
    `period` values from those shown in *Figure 12**.7*. The retail outlet wants to
    predict 3 months of daily sales and update their predictions every month (this
    is probably a more realistic use of the forecast; these parameters are reversed
    in the image merely to avoid overlapping the horizons to keep the image clear).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `horizon`、`period` 和 `initial` 参数都接受一个与pandas的 `Timedelta` 格式兼容的字符串，例如，`'5
    days'`、`'3 hours'` 或 `'10 seconds'`。在这个例子中，我们将 `horizon` 和 `period` 的值从 *图12*.7
    中所示的内容切换过来。零售店希望预测3个月的每日销售，并且每月更新他们的预测（这可能是对预测的更现实的使用；这些参数在图像中仅被反转，以避免重叠预测范围，使图像更清晰）。
- en: We begin our training with an initial period of 2 years, which is `'730 days'`.
    We set `horizon='90 days'` to evaluate our forecast over a 90-day prediction interval.
    And finally, we set `period='30 days'`, so we retrain and re-evaluate our model
    every 30 days. This results in a total of 10 forecasts to compare with the final
    year of data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: You may also specify the `cutoff` values, but this is usually unnecessary. However,
    we’ll cover a specific instance in [*Chapter 13*](B19630_13.xhtml#_idTextAnchor839),
    *Evaluating Performance Metrics*, where you will want to set them yourself. Prophet’s
    default behavior is to set them automatically by working backward from the end
    of the time series.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at this DataFrame by displaying the first five rows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you run that code in a Jupyter notebook, you’ll see the following formatted
    output (your values for `yhat_lower` and `yhat_upper` may slightly differ due
    to randomness in the optimization algorithms):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – The cross-validation DataFrame](img/Fig_12.8.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – The cross-validation DataFrame
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: For each unique `cutoff` in the DataFrame, you will find 90 days in the `ds`
    column, corresponding to the 90-day horizon. Each date in `ds` has a true value,
    `y`, which is the same value from your training data, `df['y']`, and the value
    forecast in that fold for that date in the `yhat` column.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is a different `yhat` from that in the `forecast` DataFrame,
    as those values were calculated with the full dataset, not with a cross-validated
    fold. The cross-validation DataFrame also contains uncertainty intervals for these
    forecasts, in `yhat_upper` and `yhat_lower`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: This DataFrame allows you to compare forecasted values with actual values across
    the range of date-time values in your data. In the `forecast` DataFrame, all `yhat`
    values for dates in the future obviously have no true `y` value for comparison.
    For dates in the past, there is a corresponding `df['y']` value to compare your
    `forecast['yhat']` value with, but the forecast was trained on this value. The
    `forecast['yhat']` values are biased, whereas the `df_cv['yhat']` values are unbiased
    and therefore will provide a more accurate representation of what you can expect
    your model to predict on new, unseen data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Parallelizing cross-validation
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a lot of iteration going on during cross-validation and these are
    tasks that can be parallelized to speed things up. All you need to do to take
    advantage of this is use the `parallel` keyword. There are four options you may
    choose: `None`, `''processes''`, `''threads''`, or `''dask''`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Setting `parallel='processes'` uses Python’s `concurrent.futures.ProcessPoolExecutor`
    class, whereas `parallel='threads'` uses `concurrent.futures.ThreadPoolExecutor`.
    If you’re unsure which of these to use, go with `'processes'`. It will give the
    best performance on a single machine.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '`None` will perform no parallelism, which can be good if you plan to do other
    work on your machine while Prophet calculates and you don’t want Prophet to take
    up all of your machine’s resources. If using `''dask''`, you will need to install
    Dask separately and use the `Client` from `dask.distributed` to connect to the
    cluster (the following code will result in an error if Dask has not been separately
    installed and set up):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`将不会执行并行处理，如果你计划在Prophet计算时在机器上做其他工作，且不希望Prophet占用你机器的所有资源，这可能是好的。如果你使用`''dask''`，你需要单独安装Dask并使用`dask.distributed`中的`Client`来连接到集群（如果Dask没有单独安装和设置，以下代码将导致错误）：'
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Although you can use Dask on your laptop, its power really comes into effect
    when using multiple computing clusters across many machines. If you don’t have
    access to this type of computing power, `parallel='processes'` will usually be
    the faster option.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在你的笔记本电脑上使用Dask，但它的威力真正体现在使用多台机器上的多个计算集群时。如果你无法访问这种类型的计算能力，`parallel='processes'`通常会是更快的选项。
- en: Summary
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We began this chapter with a discussion of why k-fold cross-validation was developed
    in traditional machine learning applications, and we then learned why it will
    not work with time series. You then learned about forward-chaining, also called
    rolling-origin cross-validation, for use with time series data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章开始时讨论了为什么k折交叉验证在传统的机器学习应用中被开发出来，然后我们学习了为什么它不适用于时间序列。然后你学习了前向链，也称为滚动起点交叉验证，用于时间序列数据。
- en: You learned the keywords of `initial`, `horizon`, `period`, and `cutoff`, which
    are used to define your cross-validation parameters, and you learned how to implement
    them in Prophet. Finally, you learned the different options Prophet has for parallelization
    in order to speed up model evaluation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了`initial`、`horizon`、`period`和`cutoff`这些关键字，它们用于定义你的交叉验证参数，并且你学习了如何在Prophet中实现它们。最后，你学习了Prophet在并行化方面提供的不同选项，以便加快模型评估。
- en: These techniques provide you with a statistically robust way to evaluate and
    compare models. By isolating the data used in training and testing, you remove
    any bias in the process and can be more certain that your model will perform well
    when making new predictions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术为你提供了一种统计上稳健的方式来评估和比较模型。通过隔离用于训练和测试的数据，你消除了过程中的任何偏差，并且可以更有信心地认为你的模型在做出新预测时将表现良好。
- en: In the next chapter, you’ll apply what you learned here to measure your model’s
    performance and tune it for optimal results.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将应用在这里学到的知识来衡量你模型的性能，并对其进行调整以获得最佳结果。
