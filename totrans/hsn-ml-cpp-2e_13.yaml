- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Tracking and Visualizing ML Experiments
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪和可视化机器学习实验
- en: In the world of **machine learning** (**ML**), **visualization** and **experiment
    tracking systems** play a crucial role. These tools provide a way to understand
    complex data, track experiments, and make informed decisions about model development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在**机器学习**（**ML**）的世界里，**可视化**和**实验跟踪系统**扮演着至关重要的角色。这些工具提供了一种理解复杂数据、跟踪实验并就模型开发做出明智决策的方法。
- en: In ML, visualizing data is essential for understanding patterns, relationships,
    and trends. Data visualization tools allow engineers to create charts, graphs,
    and plots that help them explore and analyze their data. With the right visualization
    tool, engineers can quickly identify patterns and anomalies, which can be used
    to improve model performance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，可视化数据对于理解模式、关系和趋势至关重要。数据可视化工具允许工程师创建图表、图形和图表，帮助他们探索和分析数据。有了合适的可视化工具，工程师可以快速识别模式和异常，这些可以用来提高模型性能。
- en: Experiment tracking systems are designed to keep track of the progress of multiple
    experiments. They allow engineers to compare results, identify best practices,
    and avoid repeating mistakes. Experiment tracking tools also help with reproducibility,
    ensuring that experiments can be repeated accurately and efficiently.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 实验跟踪系统旨在跟踪多个实验的进度。它们允许工程师比较结果、识别最佳实践并避免重复错误。实验跟踪工具还有助于可重复性，确保实验可以准确且高效地重复。
- en: Choosing the right tools for visualization and experiment tracking is critical.
    There are many open source and commercial options available, each with its strengths
    and weaknesses. It’s important to consider factors such as ease of use, integration
    with other tools, and the specific needs of your project when selecting a tool.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的可视化与实验跟踪工具至关重要。有许多开源和商业选项可供选择，每个选项都有其优点和缺点。在选择工具时，重要的是要考虑诸如易用性、与其他工具的集成以及项目具体需求等因素。
- en: In this chapter, we’ll briefly discuss **TensorBoard**, one of the most widespread
    experiment visualization systems available. We’ll also learn what type of visualizations
    it can provide and the challenges of using it with C++. As for the tracking system,
    we’ll discuss the **MLflow framework** and provide a hands-on example of how to
    use it with C++. This example covers setting up a project, defining experiments,
    logging metrics, and visualizing the training process and showcases the power
    of experiment tracking tools in enhancing the ML development process.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要讨论**TensorBoard**，这是最广泛使用的实验可视化系统之一。我们还将了解它能够提供哪些类型的可视化以及使用C++时面临的挑战。至于跟踪系统，我们将讨论**MLflow框架**，并提供一个使用C++的实战示例。此示例涵盖了项目设置、定义实验、记录指标以及可视化训练过程，展示了实验跟踪工具在增强机器学习开发过程中的强大功能。
- en: By the end of this chapter, you should have a clear understanding of why these
    tools are essential for ML engineers and how they can help you achieve better
    results.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该清楚地了解为什么这些工具对机器学习工程师至关重要，以及它们如何帮助你取得更好的成果。
- en: 'This chapter covers the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Understanding visualization and experiment tracking systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解可视化与实验跟踪系统
- en: Experiment tracking with MLflow’s REST API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MLflow的REST API进行实验跟踪
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: Flashlight library 0.4.0
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flashlight库 0.4.0
- en: MLflow 2.5.0
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MLflow 2.5.0
- en: '`cpp-httplib` v0.16.0'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpp-httplib` v0.16.0'
- en: '`nlohmann` `json` v3.11.2'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nlohmann` `json` v3.11.2'
- en: A modern C++ compiler with C++20 support
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持C++20的现代C++编译器
- en: CMake build system version >= 3.22
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake构建系统版本 >= 3.22
- en: 'The code files for this chapter can be found in this book’s GitHub repository:
    [https://github.com/PacktPublishing/Hands-On-Machine-Learning-with-C-second-edition/tree/master/Chapter13/flashlight](https://github.com/PacktPublishing/Hands-On-Machine-Learning-with-C-second-edition/tree/master/Chapter13/flashlight)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Hands-On-Machine-Learning-with-C-second-edition/tree/master/Chapter13/flashlight](https://github.com/PacktPublishing/Hands-On-Machine-Learning-with-C-second-edition/tree/master/Chapter13/flashlight)
- en: Understanding visualization and tracking systems for experiments
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解实验的可视化和跟踪系统
- en: Visualization and tracking systems for ML experiments are essential components
    of the ML development process. Together, these systems enable engineers to build
    more robust and effective ML models. They also help ensure reproducibility and
    transparency in the development process, which is crucial for scientific rigor
    and collaboration.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ML实验的视觉化和跟踪系统是ML开发过程中的关键组件。这些系统共同使工程师能够构建更稳健和有效的ML模型。它们还有助于确保开发过程中的可重复性和透明度，这对于科学严谨性和协作至关重要。
- en: Visualization tools provide a graphical representation of data, allowing engineers
    to see patterns, trends, and relationships that might be difficult to detect in
    raw data. This can help engineers gain insights into the behavior of their models,
    identify areas for improvement, and make informed decisions about model design
    and hyperparameter tuning.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化工具提供了数据的图形表示，使工程师能够看到在原始数据中可能难以检测到的模式、趋势和关系。这可以帮助工程师深入了解其模型的行为，识别改进领域，并在模型设计和超参数调整方面做出明智的决定。
- en: Experiment tracking systems allow engineers to log and organize experiments,
    including model architectures, hyperparameters, and training data. These systems
    provide an overview of the entire experimentation process, making it easier to
    compare different models and determine which ones perform best.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实验跟踪系统允许工程师记录和组织实验，包括模型架构、超参数和训练数据。这些系统提供了整个实验过程的概述，使得比较不同的模型并确定哪些模型表现最佳变得更加容易。
- en: Next, we’ll look at some of the key features of TensorBoard, a powerful visualization
    tool, and understand the essential components of MLflow, an effective experiment
    tracking system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨TensorBoard的一些关键特性，这是一个强大的可视化工具，并了解MLflow这一有效实验跟踪系统的基本组件。
- en: TensorBoard
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TensorBoard
- en: TensorBoard is a visualization tool for ML models that provides insights into
    model performance and training progress. It also provides an interactive dashboard
    where users can explore graphs, histograms, scatter plots, and other visualizations
    related to their experiments.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: TensorBoard是一个用于ML模型的可视化工具，它提供了对模型性能和训练进度的洞察。它还提供了一个交互式仪表板，用户可以在其中探索图表、直方图、散点图以及其他与实验相关的可视化。
- en: 'Here are some key features of TensorBoard:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是TensorBoard的一些关键特性：
- en: '`loss`, `accuracy`, `precision`, `recall`, and `F1 score`.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`损失`、`准确率`、`精确率`、`召回率`和`F1分数`。'
- en: '**Histogram plots**: TensorBoard also provides histogram plots for a better
    understanding of model performance. These plots can help users understand the
    distribution of layer weight and gradient values.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直方图图**：TensorBoard还提供了直方图图，以更好地理解模型性能。这些图表可以帮助用户了解层权重和梯度值的分布。'
- en: '**Graphs**: Graphs in TensorBoard provide a visual representation of model
    architecture. Users can create graphs to analyze the correlation between inputs
    and outputs or to compare different models.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形**：TensorBoard中的图形提供了模型架构的视觉表示。用户可以创建图形来分析输入和输出之间的相关性，或比较不同的模型。'
- en: '**Images**: TensorBoard allows you to display image data and connect such a
    visualization to a training timeline. This can help users analyze input data,
    intermediate outputs, or convolutional filter result visualizations.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像**：TensorBoard允许您显示图像数据，并将此类可视化连接到训练时间线。这可以帮助用户分析输入数据、中间输出或卷积滤波器结果的可视化。'
- en: '**Embedding projector**: The embedding projector in TensorBoard allows users
    to explore high-dimensional data in lower dimensions using techniques such as
    **principal component analysis** (**PCA**). This feature helps in visualizing
    complex datasets.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌入投影仪**：TensorBoard中的嵌入投影仪允许用户使用如**主成分分析**（PCA）等技术，在较低维度中探索高维数据。此功能有助于可视化复杂的数据集。'
- en: '**Comparison**: In TensorBoard, comparison enables users to compare the performance
    of multiple models side by side, making it easy to identify the best-performing
    model.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较**：在TensorBoard中，比较功能使用户能够并排比较多个模型的性能，从而轻松地识别出表现最佳的模型。'
- en: Unfortunately, TensorBoard doesn’t integrate easily with C++ ML frameworks.
    The native C++ support only exists in the TensorFlow framework. Also, there’s
    only one third-party open source library that allows us to use TensorBoard, and
    it isn’t actively maintained.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，TensorBoard与C++ ML框架的集成并不容易。原生C++支持仅存在于TensorFlow框架中。此外，只有一个第三方开源库允许我们使用TensorBoard，而且它并没有得到积极维护。
- en: TensorBoard can be integrated with various Python-based deep learning frameworks,
    including TensorFlow, PyTorch, and others. So, if you train your models in Python,
    it makes sense to consider it as an instrument that can help you understand how
    models are performing, identify potential issues, and make informed decisions
    about hyperparameters, data preprocessing, and model design.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: TensorBoard 可以与各种基于 Python 的深度学习框架集成，包括 TensorFlow、PyTorch 等。因此，如果你在 Python
    中训练模型，将其视为一个可以帮助你了解模型性能、识别潜在问题并就超参数、数据预处理和模型设计做出明智决策的工具是有意义的。
- en: Otherwise, to visualize training data, you can use `gnuplot`-based libraries
    such as `CppPlot`, as we did in the previous chapters. See [*Chapter 3*](B19849_03.xhtml#_idTextAnchor152)
    for the 2D scatter and line plot visualization examples.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，为了可视化训练数据，你可以使用基于 `gnuplot` 的库，如 `CppPlot`，正如我们在前几章中所做的那样。参见 [*第 3 章*](B19849_03.xhtml#_idTextAnchor152)
    中的 2D 散点图和线图可视化示例。
- en: MLflow
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MLflow
- en: MLflow is an open source framework that’s designed for **machine learning operations**
    (**MLOps**) and helps teams manage, track, and scale their ML projects. It provides
    a set of tools and features for building, training, and deploying models, as well
    as for monitoring their performance and experimentation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: MLflow 是一个为 **机器学习操作**（**MLOps**）设计的开源框架，帮助团队管理、跟踪和扩展他们的机器学习项目。它提供了一套用于构建、训练和部署模型以及监控其性能和实验的工具和功能。
- en: 'The main components of MLflow are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: MLflow 的主要组件如下：
- en: '**Experiment tracking**: MLflow allows users to track their experiments, including
    hyperparameters, code versions, and metrics. This helps in understanding the impact
    of different configurations on model performance.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实验跟踪**：MLflow 允许用户跟踪他们的实验，包括超参数、代码版本和指标。这有助于理解不同配置对模型性能的影响。'
- en: '**Code reproducibility**: With MLflow, users can easily reproduce their experiments
    by tracking code versions and dependencies. This ensures consistency across experiments
    and makes it easier to identify issues.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码可重现性**：使用 MLflow，用户可以通过跟踪代码版本和依赖关系轻松重现他们的实验。这确保了实验之间的一致性，并使得识别问题更加容易。'
- en: '**Model Registry**: MLflow provides a Model Registry component where users
    can store, version, and manage their models. This allows for easy collaboration
    and model sharing within teams.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型注册**：MLflow 提供了一个模型注册组件，用户可以在其中存储、版本控制和管理工作模型。这允许团队内部轻松协作和共享模型。'
- en: '**Integration with other tools**: MLflow integrates with popular data science
    and ML tools, such as Jupyter Notebook, TensorFlow, PyTorch, and more. This enables
    seamless integration with existing workflows. For non-Python environments, MLflow
    provides the REST API.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与其他工具的集成**：MLflow 与流行的数据科学和机器学习工具集成，如 Jupyter Notebook、TensorFlow、PyTorch
    等。这实现了与现有工作流程的无缝集成。对于非 Python 环境，MLflow 提供了 REST API。'
- en: '**Deployment options**: MLflow offers various options for deploying models,
    including Docker containers, Kubernetes, and cloud platforms. This flexibility
    allows users to choose the best deployment strategy based on their needs.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署选项**：MLflow 提供了各种部署模型的选择，包括 Docker 容器、Kubernetes 和云平台。这种灵活性使用户能够根据他们的需求选择最佳的部署策略。'
- en: Internally, MLflow uses a database to store metadata about experiments, models,
    and parameters. By default, it uses SQLite, but other databases such as PostgreSQL
    and MySQL are also supported. This allows for scalability and flexibility in terms
    of storage requirements. MLflow uses unique identifiers to track objects and operations
    within the platform. These identifiers are used to link different components of
    an experiment together, such as a run and its associated parameters. This makes
    it easy to reproduce experiments and understand the relationships between different
    parts of a workflow. It also provides a REST API for programmatic access to features
    such as model registration, tracking, and model life cycle management. It uses
    YAML configuration files for customizing and configuring MLflow behavior, and
    Python APIs for easy integration with MLflow components and workflows.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，MLflow 使用数据库来存储关于实验、模型和参数的元数据。默认情况下，它使用 SQLite，但也支持其他数据库，如 PostgreSQL 和 MySQL。这为存储需求提供了可扩展性和灵活性。MLflow
    使用唯一的标识符来跟踪平台内的对象和操作。这些标识符用于将实验的不同组件链接在一起，例如运行及其关联的参数。这使得重现实验和理解工作流程不同部分之间的关系变得容易。它还提供了一个
    REST API，用于以编程方式访问模型注册、跟踪和模型生命周期管理等功能。它使用 YAML 配置文件来自定义和配置 MLflow 的行为，并使用 Python
    API 以便于与 MLflow 组件和工作流程集成。
- en: So, we can summarize that visualization and experiment tracking systems are
    essential tools for data scientists and engineers to understand, analyze, and
    optimize their ML models. These systems allow users to track the performance of
    different models, compare results, identify patterns, and make informed decisions
    about model development and deployment.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以总结说，可视化和实验跟踪系统是数据科学家和工程师理解、分析和优化其机器学习模型的重要工具。这些系统允许用户跟踪不同模型的性能，比较结果，识别模式，并在模型开发和部署方面做出明智的决定。
- en: To illustrate how experiment tracking tools can be integrated into ML workflows,
    we’ll provide a concrete example in the following section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何将实验跟踪工具集成到机器学习工作流程中，我们将在下一节提供一个具体的示例。
- en: Experiment tracking with MLflow’s REST API
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MLflow 的 REST API 进行实验跟踪
- en: Let’s consider an example of an experiment involving a regression model. We’ll
    use MLflow to log performance metrics and the parameters of a model for several
    experiments. While training the model, we’ll visualize the results using a plot
    to show the accuracy and loss curves over time. Finally, we’ll compare the results
    of different experiments using the tracking system so that we can select the best-performing
    model and optimize it further.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个涉及回归模型的实验示例。我们将使用 MLflow 记录多个实验的性能指标和模型参数。在训练模型时，我们将使用图表可视化结果，以显示准确性和损失曲线随时间的变化。最后，我们将使用跟踪系统比较不同实验的结果，以便我们可以选择性能最佳的模型并进一步优化它。
- en: This example will demonstrate how experiment tracking can be seamlessly integrated
    into a C++ ML workflow, providing valuable insights and improving the overall
    quality of research.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将演示如何无缝地将实验跟踪集成到 C++ 机器学习工作流程中，提供有价值的见解并提高研究的整体质量。
- en: 'Before you can use MLflow, you need to install it. You can install MLflow using
    `pip`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以使用 MLflow 之前，您需要安装它。您可以使用 `pip` 安装 MLflow：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, you’ll need to start a server, like so:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要启动一个服务器，如下所示：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command starts the local tracking server at `http://localhost:5000`, which
    saves tracking data to the `/samples/Chapter13/mlruns` directory. If you need
    to access the MLflow server from remote machines, you can start the command with
    the `--host` and `--``port` arguments.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在 `http://localhost:5000` 启动本地跟踪服务器，并将跟踪数据保存到 `/samples/Chapter13/mlruns`
    目录。如果您需要从远程机器访问 MLflow 服务器，可以使用 `--host` 和 `--port` 参数启动命令。
- en: Having started tracking the server, we can communicate with it using the REST
    API. The access point to this API is hosted at `http://localhost:5000/api/2.0/mlflow/`.
    MLflow uses JSON as its data representation for the REST API.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 启动跟踪服务器后，我们可以使用 REST API 与之通信。此 API 的访问点托管在 `http://localhost:5000/api/2.0/mlflow/`。MLflow
    使用 JSON 作为其 REST API 的数据表示。
- en: 'To implement a `REST` client for communicating with the tracking server, we’ll
    use two additional libraries:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现与跟踪服务器通信的 `REST` 客户端，我们将使用两个额外的库：
- en: '`cpp-httplib`: For implementing HTTP communication'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpp-httplib`：用于实现 HTTP 通信'
- en: '`nlohmann json`: For implementing REST requests and responses'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nlohmann json`：用于实现 REST 请求和响应'
- en: Note that the basic linear regression model will be implemented using the `Flashlight`
    library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，基本的线性回归模型将使用 `Flashlight` 库实现。
- en: Next, we’ll learn how to connect all these pieces. The first part we’ll cover
    is implementing the REST client.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何连接所有这些部分。我们将首先介绍实现 REST 客户端。
- en: Implementing MLflow’s REST C++ client
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现MLflow的REST C++客户端
- en: 'There are two main concepts in MLflow: **experiments** and **runs**. Together,
    they provide a structured approach to managing and tracking ML workflows. They
    help us organize our projects, ensure reproducibility, and facilitate collaboration
    among team members.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: MLflow 有两个主要概念：**实验**和**运行**。它们共同提供了一个结构化的方法来管理和跟踪机器学习工作流程。它们帮助我们组织项目，确保可重复性，并促进团队成员之间的协作。
- en: In MLflow, we can organize and track our ML experiments. An experiment can be
    thought of as a container for all the runs related to a specific project or goal.
    It allows you to keep track of different versions of your models, compare their
    performance, and identify the best one.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MLflow 中，我们可以组织和跟踪我们的机器学习实验。一个实验可以被视为与特定项目或目标相关的所有运行的一个容器。它允许您跟踪您模型的多个版本，比较它们的性能，并确定最佳版本。
- en: 'The following are the key features of an experiment:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个实验的关键特性：
- en: '**Name**: Each experiment has a unique name that identifies it.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：每个实验都有一个独特的名称来标识它。'
- en: '**Tags**: You can add tags to an experiment to categorize it based on different
    criteria.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：您可以为实验添加标签，根据不同的标准对其进行分类。'
- en: '**Artifacts location**: Artifacts are files that are generated throughout the
    experiment, such as images, logs, and more. MLflow allows you to store and version
    these artifacts.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工件位置**：工件是在实验过程中生成的文件，例如图像、日志等。MLflow允许您存储和版本化这些工件。'
- en: A run represents a single execution of an experiment or a specific task within
    an experiment. Runs are used to record the details of each execution, such as
    its start time, end time, parameters, and metrics.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代表实验的单次执行或实验内的特定任务。运行用于记录每次执行的详细信息，例如其开始时间、结束时间、参数和指标。
- en: 'The key features of a run are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 运行的关键特性如下：
- en: '**Start time**: The time when the run started'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始时间**：运行开始的时间'
- en: '**End time**: The time when the run finished'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结束时间**：运行完成的时间'
- en: '**Parameters**: Model parameters such as batch size, learning rate, and more'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：模型参数，如批量大小、学习率等'
- en: '**Model**: The model code that was executed during the run'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：运行期间执行的模型代码'
- en: '**Output**: The results that were produced by the run, including metrics, artifacts,
    and more'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出**：运行产生的结果，包括指标、工件等'
- en: Within a run, users can log parameters, metrics, and model representation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行过程中，用户可以记录参数、指标和模型表示。
- en: 'Now that we understand the main concepts of MLflow’s tracking structure, let’s
    implement the MLflow REST client:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了MLflow跟踪结构的主要概念，让我们来实现MLflow REST客户端：
- en: 'First, we’re going to put all the implementation details for the `REST` client
    in a single `MLFlow` class. The header file should look as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将`REST`客户端的所有实现细节放在一个单独的`MLFlow`类中。头文件应如下所示：
- en: '[PRE2]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We made the constructor take a host and the port of the tracking server to communicate
    with. Then, we defined methods to start a named experiment and run inside it,
    as well as methods to log named metrics and parameters. After, we declared an
    instance of the `httplib::Client` class, which will be used for HTTP communication
    with the tracking server. Finally, we provided member variables, which are the
    IDs of the current experiment and run.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们让构造函数接受主机和跟踪服务器的端口以进行通信。然后，我们定义了启动命名实验并在其中运行的方法，以及记录命名指标和参数的方法。之后，我们声明了一个`httplib::Client`类的实例，该实例将用于与跟踪服务器进行HTTP通信。最后，我们提供了成员变量，即当前实验和运行的ID。
- en: 'Now, let’s learn how to implement these methods. The constructor implementation
    is as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何实现这些方法。构造函数的实现如下：
- en: '[PRE3]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we initialized the `httplib::Client` instance with the host and port values
    to initialize a connection with a tracking server.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用主机和端口值初始化`httplib::Client`实例，以初始化与跟踪服务器的连接。
- en: 'The following code shows the `set_experiment` method’s implementation:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码显示了`set_experiment`方法的实现：
- en: '[PRE4]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This method initializes an experiment for the following runs. There are two
    parts to this method—one for a new experiment and another for the existing one:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法为以下运行初始化实验。此方法有两个部分——一个用于新实验，另一个用于现有实验：
- en: 'First, we checked whether the experiment with the given name existed on the
    server using the following code:'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用以下代码检查服务器上是否存在具有给定名称的实验：
- en: '[PRE5]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By comparing the results with the `404` and `202` codes, we identified that
    there’s no such experiment or that it already exists.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过比较结果与`404`和`202`代码，我们确定不存在这样的实验或它已经存在。
- en: 'Because there’s no existing experiment, we created a JSON-based request to
    create a new experiment, as follows:'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于没有现有实验，我们创建了一个基于JSON的请求来创建新实验，如下所示：
- en: '[PRE6]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we passed it as the body of the HTTP request to the server, as follows:'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将它作为HTTP请求的正文传递给服务器，如下所示：
- en: '[PRE7]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `dump` method of the `nlohmann::json` object was used to convert the JSON
    into a string representation. After we got the result, we used the `handle_result`
    function to check for errors (this function will be discussed in more detail later).
    With the answer in the `res` variable, we took the `experiment_id` value, as follows:'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用了`nlohmann::json`对象的`dump`方法将JSON转换为字符串表示。在得到结果后，我们使用`handle_result`函数检查错误（此函数将在稍后详细讨论）。在`res`变量中，我们取了`experiment_id`值，如下所示：
- en: '[PRE8]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we parsed the string that was returned by the server with the `nlohmann::json::parse`
    function and read the `experiment_id` value from the JSON object into our class
    member variable.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用`nlohmann::json::parse`函数解析服务器返回的字符串，并将`experiment_id`值从JSON对象读取到我们的类成员变量中。
- en: In the second part of the method, which works when an experiment exists on the
    server, we parsed the response in a JSON object and took the `experiment_id` value.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法的第二部分，当服务器上存在实验时，我们在JSON对象中解析响应并获取`experiment_id`值。
- en: 'There are two functions named `handle_result` that are used to check response
    codes and report errors if needed. The first one is used to check whether a response
    has some particular code and is implemented as follows:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有两个名为`handle_result`的函数用于检查响应代码，并在需要时报告错误。第一个函数用于检查响应是否包含某些特定代码，其实现如下：
- en: '[PRE9]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we checked whether the `httplib::Result` object has a valid response by
    using its Boolean cast operator. If there was a communication error, we threw
    the runtime exception. Otherwise, we returned the response code’s comparison result.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用布尔转换运算符检查`httplib::Result`对象是否有有效的响应。如果有通信错误，我们抛出运行时异常。否则，我们返回响应代码的比较结果。
- en: 'The second `handle_result` function is used to check that we got the successful
    answer from the server. The following code snippet shows how it’s implemented:'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个`handle_result`函数用于检查我们是否从服务器获得了成功的答案。以下代码片段显示了其实现方式：
- en: '[PRE10]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We used the previous `handle_result` function to check whether the response
    was valid and we got a `200` response code. If it’s true, we’re OK. However, in
    the case of a failure, we must make a detailed report and throw a runtime exception.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用之前的`handle_result`函数来检查响应是否有效，并获得了`200`响应代码。如果是真的，我们就没问题。然而，在失败的情况下，我们必须做出详细的报告并抛出运行时异常。
- en: These functions help to simplify response error handling code and make it easier
    to debug communications.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些函数有助于简化响应错误处理代码，并使其更容易调试通信。
- en: The next two methods we’re going to discuss are `start_run` and `end_run`. These
    methods mark a single run’s bounds, within which we can log metrics, parameters,
    and artifacts. In production code, it makes sense to wrap such functionality into
    some RAII abstraction, but we made two methods for simplicity.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的两个方法是`start_run`和`end_run`。这些方法标记了一个单独运行的界限，在此范围内我们可以记录指标、参数和工件。在生产代码中，将此类功能封装到某种RAII抽象中是有意义的，但我们为了简单起见创建了两个方法。
- en: 'The `start_run` method can be implemented as follows:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`start_run`方法可以如下实现：'
- en: '[PRE11]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we made a JSON-based request to create a run. This request was filled
    with the current `experiment_id` value and the run’s start time. Then, we sent
    a request to the server and got a response that we checked with the `handle_result`
    function. If we receive an answer, we parse it in the `nlohmann::json` object
    and take the `run_id` value. The `run_id` value is stored in the object member
    and will be used in the following requests. After we call this method, the tracking
    server will write all metrics and parameters into this new run.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们发送了一个基于JSON的请求来创建一个运行。此请求填充了当前的`experiment_id`值和运行的开始时间。然后，我们向服务器发送请求并获得了响应，我们使用`handle_result`函数检查了它。如果我们收到答案，我们将其解析到`nlohmann::json`对象中，并获取`run_id`值。`run_id`值存储在对象成员中，将在后续请求中使用。在调用此方法后，跟踪服务器将所有指标和参数写入这个新的运行。
- en: 'To complete the run, we have to tell the server about it. The `end_run` method
    does just this:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成运行，我们必须通知服务器。`end_run`方法正是如此：
- en: '[PRE12]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we made a JSON-based request that includes the `run_id` value, the finished
    status, and the end time. Then, we sent this request to the tracking server and
    checked the response. Notice that we sent the start and end times for a run, at
    which point the server used them to calculate the run duration. Due to this, you’ll
    be able to see how the run duration time depends on its parameters.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们发送了一个基于JSON的请求，该请求包含`run_id`值、完成状态和结束时间。然后，我们将此请求发送到跟踪服务器并检查响应。请注意，我们发送了运行的开始和结束时间，此时服务器使用这些时间来计算运行持续时间。因此，您将能够看到运行持续时间如何取决于其参数。
- en: Now that we have methods for setting an experiment and defining a run, we need
    methods so that we can log metrics values and run parameters.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了设置实验和定义运行的方法，我们需要方法来记录指标值和运行参数。
- en: Logging metric values and running parameters
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录指标值和运行参数
- en: The difference between metrics and parameters is that metrics are sequences
    of values within a run. You can log as many values of a single metric as you need.
    Usually, this number equals epochs or batches and MLflow will show live plots
    for these metrics. However, a single parameter can only be logged once per run,
    and it’s typically a training characteristic such as the learning rate.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 指标和参数之间的区别在于，指标是在运行期间的一系列值。您可以记录所需数量的单个指标值。通常，这个数字等于纪元或批次，MLflow将为这些指标显示实时图表。然而，单个参数在每次运行中只能记录一次，通常是一个训练特征，如学习率。
- en: 'A metric is usually a numeric value, so we’ve made our `log_metric` method
    take a float and an argument for a value. Note that this method takes the metric
    name and the epoch index to make several distinct values for the same metric.
    The method’s implementation is shown in the following code snippet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 指标通常是一个数值，因此我们使`log_metric`方法接受一个浮点数和一个值参数。请注意，此方法接受指标名称和纪元索引以生成同一指标的多个不同值。方法实现如下代码片段：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we made a JSON-based request that includes the `run_id` value, the metric’s
    name as the `key` field, the metric’s value, the epoch index as the `step` field,
    and the timestamp value. Then, we sent the request to the tracking server and
    checked the response.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个基于JSON的请求，该请求包含`run_id`值，将指标名称作为`key`字段，指标值，将纪元索引作为`step`字段，以及时间戳值。然后，我们将请求发送到跟踪服务器并检查响应。
- en: 'A parameter value can have an arbitrary value type, so we used C++ templates
    to write a single method to process different value types. There are two `log_param`
    functions here—the first is a template function that converts any suitable parameter
    value into a string, whereas the second only takes a parameter name and a string
    value as arguments. The template can be implemented like so:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 参数值可以具有任意值类型，因此我们使用了C++模板来编写一个处理不同值类型的方法。这里有两个`log_param`函数——第一个是一个模板函数，它将任何合适的参数值转换为字符串，而第二个只接受参数名称和字符串值作为参数。模板可以像这样实现：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This template simply redirects a call to the second function after the value
    is converted into a string with the `std::to_string` function. So, if the value’s
    type can’t be converted into a string, a compilation error will occur.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板简单地将调用重定向到第二个函数，在将值转换为字符串后使用`std::to_string`函数。因此，如果值的类型无法转换为字符串，将发生编译错误。
- en: 'The second `log_param` function’s implementation can be seen in the following
    code snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`log_param`函数的实现可以在以下代码片段中看到：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we made a JSON-based request that includes the current `run_id` value,
    the parameter name as the `key` field, and the value. Then, we just sent the request
    and checked the response.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个基于JSON的请求，该请求包含当前的`run_id`值，参数名称作为`key`字段，以及值。然后，我们仅发送请求并检查响应。
- en: The REST API in MLflow is much richer than this; we only covered the basic functions
    here. For example, it’s also capable of accepting model architectures in JSON
    format, logging input datasets, managing experiments and models, and much more.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: MLflow中的REST API比这更丰富；我们在这里只介绍了基本功能。例如，它还可以接受JSON格式的模型架构，记录输入数据集，管理实验和模型，等等。
- en: Now that we understand the basic functionality for communicating with the MLflow
    server, let’s learn how to implement an experiments tracking session for a regression
    task.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了与MLflow服务器通信的基本功能，让我们学习如何实现回归任务的实验跟踪会话。
- en: Integrating experiment tracking into linear regression training
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将实验跟踪集成到线性回归训练中
- en: 'In this section, we’ll be using the `Flashlight` library to implement a linear
    regression model and train it. Our code starts with initializing Flashlight and
    connecting to an MLflow server, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`Flashlight`库来实现一个线性回归模型并进行训练。我们的代码从初始化Flashlight并连接到MLflow服务器开始，如下所示：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we assumed that the tracking server has already been started on localhost.
    After, we set the experiment’s name to `Linear regression`. Now, we can define
    the necessary parameters and start the run:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设跟踪服务器已经在本地主机上启动。之后，我们将实验名称设置为`线性回归`。现在，我们可以定义必要的参数并开始运行：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Having configured the run, we can load datasets for training and testing, define
    a model, and create an optimizer and loss function according to the parameters
    we defined previously:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 配置运行后，我们可以加载用于训练和测试的数据集，定义一个模型，并根据我们之前定义的参数创建一个优化器和损失函数：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice that we used all the previously defined parameters except for the epoch
    number. Now, we’re ready to define the training cycle, like so:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了之前定义的所有参数，除了epoch编号。现在，我们准备好定义训练周期，如下所示：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The main part of the training cycle looks normal as we implemented this in
    the previous chapters. Note that we have two nested cycles—one for epochs and
    another for batches. At the beginning of the training epoch, we cleared the meter
    that’s used for averaging the training loss metric and put the model into the
    training mode. Then, we cleared the gradients, made a forward pass, calculated
    the loss value, made a backward pass, updated the model weights with the optimizer
    step, and added the loss value to the averaging meter object. After the internal
    cycle, training was completed. At this point, we can log the average training
    loss metric value to the tracking server, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 训练周期的主体看起来很正常，因为我们已经在之前章节中实现了它。请注意，我们有两个嵌套周期——一个用于epochs，另一个用于batches。在训练epoch的开始，我们清除了用于平均训练损失指标的平均仪表，并将模型置于训练模式。然后，我们清除了梯度，进行了前向传递，计算了损失值，进行了反向传递，使用优化器步骤更新了模型权重，并将损失值添加到平均值仪表对象中。在内部周期之后，训练完成。在此阶段，我们可以将平均训练损失指标值记录到跟踪服务器，如下所示：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we logged the train loss value for the epoch with the `epoch_i` index
    and used `train loss` as its name. For every epoch, this logging will add a new
    value for the metric and we’ll be able to see the live plot of how the training
    loss changes over epochs in the MLflow UI. This plot will be shown in the following
    subsection.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们记录了具有`epoch_i`索引的epoch的训练损失值，并将其命名为`train loss`。对于每个epoch，这种记录将为指标添加一个新值，我们将在MLflow
    UI中看到训练损失随epoch变化的实时图表。此图表将在以下小节中展示。
- en: 'After the training cycle, for every 10th epoch, we calculate the test loss
    metric, as shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在训练周期之后，对于每个第10个epoch，我们计算测试损失指标，如下所示：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once we’ve checked that the current epoch is the 10th one, we defined an additional
    averaging meter object for the test loss metric and implemented evaluation mode.
    Then, we calculated the loss value for every batch and added these values to the
    averaging meter. At this point, we can implement a loss calculation for the test
    dataset and log the test metric to the tracking server:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确认当前epoch是第10个，我们为测试损失指标定义了一个额外的平均值仪表对象，并实现了评估模式。然后，我们计算每个批次的损失值，并将这些值添加到平均值仪表中。在此阶段，我们可以实现测试数据集的损失计算，并将测试指标记录到跟踪服务器：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we logged the test loss value for the epoch with the `epoch_i` index and
    used `test loss` as its name. MLflow will provide a plot for this metric too.
    We’ll be able to overlap this plot with the train metric plot to check whether
    there are issues such as overfitting.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们记录了具有`epoch_i`索引的每个epoch的测试损失值，并将其命名为`test loss`。MLflow也将为此指标提供图表。我们将能够将此图表与训练指标图表重叠，以检查是否存在诸如过拟合等问题。
- en: 'Now that we’ve finished using the training cycle, we can end the run and log
    its parameters, like so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了训练周期，我们可以结束运行并记录其参数，如下所示：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we logged the run parameters with the `end_run` call. This is a requirement
    when using the MLflow API. Note that parameter values can have different types
    and that they were only logged once.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`end_run`调用记录了运行参数。这是使用MLflow API时的一个要求。请注意，参数值可以有不同的类型，并且它们只记录了一次。
- en: Now, let’s see how MLflow will display the program runs with different training
    parameters.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看MLflow将如何显示具有不同训练参数的程序运行。
- en: Experiments tracking process
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验跟踪过程
- en: 'The following figure shows the MLflow UI after the tracking server has been
    started:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了跟踪服务器启动后的MLflow UI：
- en: '![Figure 13.1 – Overview of the MLflow UI without experiments and runs](img/B19849_13_01.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – 无实验和运行的MLflow UI概览](img/B19849_13_01.jpg)'
- en: Figure 13.1 – Overview of the MLflow UI without experiments and runs
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 无实验和运行的MLflow UI概览
- en: 'As we can see there are no experiments and there’s run information. After executing
    a program run with a set of parameters, the UI will look as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，没有实验和运行信息。在执行一组参数的程序运行后，UI将如下所示：
- en: '![Figure 13.2 – Overview of the MLflow UI with a single experiment and one
    run](img/B19849_13_02.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 单个实验和一个运行下的MLflow UI概览](img/B19849_13_02.jpg)'
- en: Figure 13.2 – Overview of the MLflow UI with a single experiment and one run
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 单个实验和一个运行下的MLflow UI概览
- en: 'As you can see, **Linear regression** appeared in the left panel. Also, there’s
    a new record for the run in the right-hand side table. Notice that the run name
    of **peaceful-ray-50** was automatically generated. Here, we can see the start
    time and how much time the run takes. Clicking on the run’s name will open the
    run details page, which looks like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Overview of the run details in the MLflow UI](img/B19849_13_03.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Overview of the run details in the MLflow UI
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see the start time and date, the experiment ID that this run is
    associated with, the run ID, and its duration. Note that additional information
    might be provided here, such as a username, what datasets were used, tags, and
    the model source. These additional attributes can be also configured with the
    REST API.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom, we can see the **Parameters** table, where we can find the parameters
    we logged from our code. There’s also the **Metrics** table, which shows the final
    values for our train and test loss value metrics.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click on the **Model metrics** tab, the following page will be displayed:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – The Model metrics page in the MLflow UI](img/B19849_13_04.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – The Model metrics page in the MLflow UI
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see the train and test loss metrics plots. These plots show how
    the loss values changed over epochs. Usually, it’s useful to overlap the train
    and test loss plots to see some dependencies. We can do this by clicking on the
    metric’s name on the page displayed in *Figure 13**.3*. The following page will
    be displayed upon clicking **train loss**:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – The train loss metric plot](img/B19849_13_05.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – The train loss metric plot
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see the plot for the single metric. On this page, we can configure
    some visualization parameters for the plot, such as the smoothness and the step.
    However, in this case, we’re interested in the **Y-axis** field, which allows
    us to add additional metrics to the same plot. If we add the **test loss** metric,
    we’ll see the following page:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Overlapping the metric plots](img/B19849_13_06.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Overlapping the metric plots
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have two overlapped plots for the train and test metrics. In this visualization,
    we can see that for the first few epochs, the test loss was greater than the train
    loss, but after the 15th epoch, the loss values were pretty similar. This means
    that there’s no model overfitting.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: In this instance, we looked at the main regimes of the MLflow UI for the single
    train run. For more advanced cases, there will be pages that consist of artifacts
    and model sources, but we’ve skipped them here.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s learn how to work with several runs for an experiment. We ran our
    application again but with a different value for momentum. MLflow shows us that
    we have two runs for the same experiment, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – The experiment with two runs](img/B19849_13_07.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – The experiment with two runs
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, there are two runs for the experiment. Also, there are only
    two minor differences between them—the names and their duration. To compare the
    runs, we must click on both checkboxes that precede the run names, as shown here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Selecting both runs](img/B19849_13_08.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – Selecting both runs
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'After selecting both runs, the **Compare** button appears at the top of the
    **Runs** table. Clicking this button opens the following page:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19849_13_09.jpg)![](img/B19849_13_10.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – Overview of the runs comparison page
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: This page shows two runs side by side and shows different visualizations of
    the difference between various metrics and parameters. Note that the run parameter
    differences will also be highlighted. From the left top panel, you can select
    the parameters and metrics you wish to compare. By doing this, we can see that
    the new run with a lower momentum value performs worse. This is indicated by the
    top plot, where lines connect parameters with metrics and there are scales with
    values. This can also be seen at the bottom in the metrics rows, where you can
    compare final metric values.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to use the MLflow UI to explore experiment run
    behavior, as well as how to view metrics visualizations and how to compare different
    runs. All tracked information is saved by the tracking server and can be used
    later, after a server restart, so it’s quite a useful tool for ML practitioners.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualization and experiment tracking systems are essential tools for ML engineers.
    They allow us to understand the performance of models, analyze results, and improve
    the overall process.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: TensorBoard is a popular visualization system that provides detailed information
    about model training, including metrics, loss curves, histograms, and more. It
    supports multiple frameworks, including TensorFlow, and allows us to easily compare
    different runs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: MLflow is an open source framework that offers end-to-end solutions for model
    life cycle management. It includes features such as experiment tracking, Model
    Registry, artifact management, and deployment. MLflow helps teams collaborate,
    reproduce experiments, and ensure reproducibility.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Both TensorBoard and MLflow are powerful tools that can be used together or
    separately, depending on your needs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: After understanding both TensorBoard and MLflow, we implemented a linear regression
    training example with experiment tracking. By doing so, we learned how to implement
    the REST API client for the MLflow server and how to use it to log metrics and
    parameters for an experiment. Then, we explored the MLflow UI, where we learned
    how to view an experiment and its run details, as well as metrics plots, and learned
    how to compare different runs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll learn how to use ML models for computer vision on
    the Android mobile platform using C++.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**MLflow REST** **API**: [https://mlflow.org/docs/latest/rest-api.html](https://mlflow.org/docs/latest/rest-api.html)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MLflow** **documentation**: [https://mlflow.org/docs/latest/index.html](https://mlflow.org/docs/latest/index.html)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TensorBoard** **documentation**: [https://www.tensorflow.org/tensorboard/get_started](https://www.tensorflow.org/tensorboard/get_started)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to use TensorBoard with* *PyTorch*: [https://pytorch.org/tutorials/recipes/recipes/tensorboard_with_pytorch.html](https://pytorch.org/tutorials/recipes/recipes/tensorboard_with_pytorch.html)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
