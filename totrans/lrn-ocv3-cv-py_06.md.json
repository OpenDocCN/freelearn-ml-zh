["```py\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('images/chess_board.png')\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\ngray = np.float32(gray)\ndst = cv2.cornerHarris(gray, 2, 23, 0.04)\nimg[dst>0.01 * dst.max()] = [0, 0, 255] \nwhile (True):\n  cv2.imshow('corners', img)\n  if cv2.waitKey(1000 / 12) & 0xff == ord(\"q\"):\n    break\ncv2.destroyAllWindows()\n```", "```py\ndst = cv2.cornerHarris(gray, 2, 23, 0.04)\n```", "```py\nimg[dst>0.01 * dst.max()] = [0, 0, 255] \n```", "```py\nimport cv2\nimport sys\nimport numpy as np\n\nimgpath = sys.argv[1]\nimg = cv2.imread(imgpath)\n\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\nsift = cv2.xfeatures2d.SIFT_create()\nkeypoints, descriptor = sift.detectAndCompute(gray,None)\n\nimg = cv2.drawKeypoints(image=img, outImage=img, keypoints = keypoints, flags = cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINT, color = (51, 163, 236))\n\ncv2.imshow('sift_keypoints', img)\nwhile (True):\n  if cv2.waitKey(1000 / 12) & 0xff == ord(\"q\"):\n    break\ncv2.destroyAllWindows()\n```", "```py\nimgpath = sys.argv[1]\nimg = cv2.imread(imgpath)\n\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n```", "```py\nsift = cv2.xfeatures2d.SIFT_create()\nkeypoints, descriptor = sift.detectAndCompute(gray,None)\n```", "```py\ncv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINT\n```", "```py\npt\nsize\nangle\nresponse\noctave \nclass_id\n```", "```py\nimport cv2\nimport sys\nimport numpy as np\n\nimgpath = sys.argv[1]\nimg = cv2.imread(imgpath)\nalg = sys.argv[2]\n\ndef fd(algorithm):\n  if algorithm == \"SIFT\":\n    return cv2.xfeatures2d.SIFT_create()\n  if algorithm == \"SURF\":\n    return cv2.xfeatures2d.SURF_create(float(sys.argv[3]) if len(sys.argv) == 4 else 4000)\n\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\nfd_alg = fd(alg)\nkeypoints, descriptor = fd_alg.detectAndCompute(gray,None)\n\nimg = cv2.drawKeypoints(image=img, outImage=img, keypoints = keypoints, flags = 4, color = (51, 163, 236))\n\ncv2.imshow('keypoints', img)\nwhile (True):\n  if cv2.waitKey(1000 / 12) & 0xff == ord(\"q\"):\n    break\ncv2.destroyAllWindows()\n```", "```py\n> python feat_det.py images/varese.jpg SURF 8000\n\n```", "```py\nimport numpy as np\nimport cv2\nfrom matplotlib import pyplot as plt\n\nimg1 = cv2.imread('images/manowar_logo.png',cv2.IMREAD_GRAYSCALE)\nimg2 = cv2.imread('images/manowar_single.jpg', cv2.IMREAD_GRAYSCALE)\n\norb = cv2.ORB_create()\nkp1, des1 = orb.detectAndCompute(img1,None)\nkp2, des2 = orb.detectAndCompute(img2,None)\nbf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)\nmatches = bf.match(des1,des2)\nmatches = sorted(matches, key = lambda x:x.distance)\nimg3 = cv2.drawMatches(img1,kp1,img2,kp2, matches[:40], img2,flags=2)\nplt.imshow(img3),plt.show()\n```", "```py\n    IMREAD_ANYCOLOR = 4\n    IMREAD_ANYDEPTH = 2\n    IMREAD_COLOR = 1\n    IMREAD_GRAYSCALE = 0\n    IMREAD_LOAD_GDAL = 8\n    IMREAD_UNCHANGED = -1\n```", "```py\norb = cv2.ORB_create()\nkp1, des1 = orb.detectAndCompute(img1,None)\nkp2, des2 = orb.detectAndCompute(img2,None)\n```", "```py\nbf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)\nmatches = bf.match(des1,des2)\nmatches = sorted(matches, key = lambda x:x.distance)\n```", "```py\nimg3 = cv2.drawMatches(img1,kp1,img2,kp2, matches[:40], img2,flags=2)\nplt.imshow(img3),plt.show()\n```", "```py\nimport numpy as np\nimport cv2\nfrom matplotlib import pyplot as plt\n\nimg1 = cv2.imread('images/manowar_logo.png',0)\nimg2 = cv2.imread('images/manowar_single.jpg',0)\n\norb = cv2.ORB_create()\nkp1, des1 = orb.detectAndCompute(img1,None)\nkp2, des2 = orb.detectAndCompute(img2,None)\nbf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)\nmatches = bf.knnMatch(des1,des2, k=2)\nimg3 = cv2.drawMatchesKnn(img1,kp1,img2,kp2, matches, img2,flags=2)\nplt.imshow(img3),plt.show()\n```", "```py\nimport numpy as np\nimport cv2\nfrom matplotlib import pyplot as plt\n\nqueryImage = cv2.imread('images/bathory_album.jpg',0)\ntrainingImage = cv2.imread('images/vinyls.jpg',0)\n\n# create SIFT and detect/compute\nsift = cv2.xfeatures2d.SIFT_create()\nkp1, des1 = sift.detectAndCompute(queryImage,None)\nkp2, des2 = sift.detectAndCompute(trainingImage,None)\n\n# FLANN matcher parameters\nFLANN_INDEX_KDTREE = 0\nindexParams = dict(algorithm = FLANN_INDEX_KDTREE, trees = 5)\nsearchParams = dict(checks=50)   # or pass empty dictionary\n\nflann = cv2.FlannBasedMatcher(indexParams,searchParams)\n\nmatches = flann.knnMatch(des1,des2,k=2)\n\n# prepare an empty mask to draw good matches\nmatchesMask = [[0,0] for i in xrange(len(matches))]\n\n# David G. Lowe's ratio test, populate the mask\nfor i,(m,n) in enumerate(matches):\n    if m.distance < 0.7*n.distance:\n        matchesMask[i]=[1,0]\n\ndrawParams = dict(matchColor = (0,255,0),\n                   singlePointColor = (255,0,0),\n                   matchesMask = matchesMask,\n                   flags = 0)\n\nresultImage = cv2.drawMatchesKnn(queryImage,kp1,trainingImage,kp2,matches,None,**drawParams)\n\nplt.imshow(resultImage,), plt.show()\n```", "```py\nimport numpy as np\nimport cv2\nfrom matplotlib import pyplot as plt\n\nMIN_MATCH_COUNT = 10\n\nimg1 = cv2.imread('images/bb.jpg',0)\nimg2 = cv2.imread('images/color2_small.jpg',0)\n\nsift = cv2.xfeatures2d.SIFT_create()\nkp1, des1 = sift.detectAndCompute(img1,None)\nkp2, des2 = sift.detectAndCompute(img2,None)\n\nFLANN_INDEX_KDTREE = 0\nindex_params = dict(algorithm = FLANN_INDEX_KDTREE, trees = 5)\nsearch_params = dict(checks = 50)\n\nflann = cv2.FlannBasedMatcher(index_params, search_params)\n\nmatches = flann.knnMatch(des1,des2,k=2)\n\n# store all the good matches as per Lowe's ratio test.\ngood = []\nfor m,n in matches:\n    if m.distance < 0.7*n.distance:\n        good.append(m)\n\nif len(good)>MIN_MATCH_COUNT:\n    src_pts = np.float32([ kp1[m.queryIdx].pt for m in good ]).reshape(-1,1,2)\n    dst_pts = np.float32([ kp2[m.trainIdx].pt for m in good ]).reshape(-1,1,2)\n\n    M, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC,5.0)\n    matchesMask = mask.ravel().tolist()\n\n    h,w = img1.shape\n    pts = np.float32([ [0,0],[0,h-1],[w-1,h-1],[w-1,0] ]).reshape(-1,1,2)\n    dst = cv2.perspectiveTransform(pts,M)\n\n    img2 = cv2.polylines(img2,[np.int32(dst)],True,255,3, cv2.LINE_AA)\n\nelse:\n    print \"Not enough matches are found - %d/%d\" % (len(good),MIN_MATCH_COUNT)\n    matchesMask = None\n\ndraw_params = dict(matchColor = (0,255,0), # draw matches in green color\n                   singlePointColor = None,\n                   matchesMask = matchesMask, # draw only inliers\n                   flags = 2)\n\nimg3 = cv2.drawMatches(img1,kp1,img2,kp2,good,None,**draw_params)\n\nplt.imshow(img3, 'gray'),plt.show()\n```", "```py\nif len(good)>MIN_MATCH_COUNT:\n```", "```py\nsrc_pts = np.float32([ kp1[m.queryIdx].pt for m in good ]).reshape(-1,1,2)\ndst_pts = np.float32([ kp2[m.trainIdx].pt for m in good ]).reshape(-1,1,2)\n```", "```py\nM, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC,5.0)\nmatchesMask = mask.ravel().tolist()\n```", "```py\nh,w = img1.shape\npts = np.float32([ [0,0],[0,h-1],[w-1,h-1],[w-1,0] ]).reshape(-1,1,2)\ndst = cv2.perspectiveTransform(pts,M)\nimg2 = cv2.polylines(img2,[np.int32(dst)],True,255,3, cv2.LINE_AA)\n```", "```py\n# generate_descriptors.py\nimport cv2\nimport numpy as np\nfrom os import walk\nfrom os.path import join\nimport sys\n\ndef create_descriptors(folder):\n  files = []\n  for (dirpath, dirnames, filenames) in walk(folder):\n    files.extend(filenames)\n  for f in files:\n    save_descriptor(folder, f, cv2.xfeatures2d.SIFT_create())\n\ndef save_descriptor(folder, image_path, feature_detector):\n  img = cv2.imread(join(folder, image_path), 0)\n  keypoints, descriptors = feature_detector.detectAndCompute(img, None)\n  descriptor_file = image_path.replace(\"jpg\", \"npy\")\n  np.save(join(folder, descriptor_file), descriptors)\n\ndir = sys.argv[1]\n\ncreate_descriptors(dir)\n```", "```py\n> python generate_descriptors.py <folder containing images>\n\n```", "```py\nfrom os.path import join\nfrom os import walk\nimport numpy as np\nimport cv2\nfrom sys import argv\n\n# create an array of filenames\nfolder = argv[1]\nquery = cv2.imread(join(folder, \"tattoo_seed.jpg\"), 0)\n\n# create files, images, descriptors globals\nfiles = []\nimages = []\ndescriptors = []\nfor (dirpath, dirnames, filenames) in walk(folder):\n  files.extend(filenames)\n  for f in files:\n    if f.endswith(\"npy\") and f != \"tattoo_seed.npy\":\n      descriptors.append(f)\n  print descriptors\n\n# create the sift detector\nsift = cv2.xfeatures2d.SIFT_create()\nquery_kp, query_ds = sift.detectAndCompute(query, None)\n\n# create FLANN matcher\nFLANN_INDEX_KDTREE = 0\nindex_params = dict(algorithm = FLANN_INDEX_KDTREE, trees = 5)\nsearch_params = dict(checks = 50)\nflann = cv2.FlannBasedMatcher(index_params, search_params)\n\n# minimum number of matches\nMIN_MATCH_COUNT = 10\n\npotential_culprits = {}\n\nprint \">> Initiating picture scan...\"\nfor d in descriptors:\n  print \"--------- analyzing %s for matches ------------\" % d\n  matches = flann.knnMatch(query_ds, np.load(join(folder, d)), k =2)\n  good = []\n  for m,n in matches:\n      if m.distance < 0.7*n.distance:\n          good.append(m)\n  if len(good) > MIN_MATCH_COUNT:\n    print \"%s is a match! (%d)\" % (d, len(good))\n  else:\n    print \"%s is not a match\" % d\n  potential_culprits[d] = len(good)\n\nmax_matches = None\npotential_suspect = None\nfor culprit, matches in potential_culprits.iteritems():\n  if max_matches == None or matches > max_matches:\n    max_matches = matches\n    potential_suspect = culprit\n\nprint \"potential suspect is %s\" % potential_suspect.replace(\"npy\", \"\").upper()\n```", "```py\n>> Initiating picture scan...\n--------- analyzing posion-ivy.npy for matches ------------\nposion-ivy.npy is not a match\n--------- analyzing bane.npy for matches ------------\nbane.npy is not a match\n--------- analyzing two-face.npy for matches ------------\ntwo-face.npy is not a match\n--------- analyzing riddler.npy for matches ------------\nriddler.npy is not a match\n--------- analyzing penguin.npy for matches ------------\npenguin.npy is not a match\n--------- analyzing dr-hurt.npy for matches ------------\ndr-hurt.npy is a match! (298)\n--------- analyzing hush.npy for matches ------------\nhush.npy is a match! (301)\npotential suspect is HUSH.\n```"]