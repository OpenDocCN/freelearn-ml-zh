["```py\n#Get started with needed libraries/settings/directory\n%pylab inline\n%cd C:\\Users\\mrever\\Documents\\packt_CV\\tensclass\n```", "```py\nimport tensorflow as tf\nimport numpy as np\n```", "```py\n#Arithmetic with TensorFlow\n\na = tf.constant(2)\nb = tf.constant(3)\n```", "```py\nwith tf.Session() as sess:\n    print(\"a=2, b=3\")\n    print(\"a+b=\" + str(sess.run(a+b)))\n    print(\"a*b=\" + str(sess.run(a*b)))\n```", "```py\na = tf.placeholder(tf.int16)\nb = tf.placeholder(tf.int16)\n```", "```py\nadd = tf.add(a, b)\nmul = tf.multiply(a, b)\n```", "```py\nwith tf.Session() as sess:\n    print(\"a+b=\" + str(sess.run(add, feed_dict={a: 2, b: 3})))\n    print(\"a*b=\" + str(sess.run(mul, feed_dict={a: 2, b: 3}))) \n```", "```py\n#Matrix multiplication\nmatrix1 = tf.constant([[1., 2.],[9.0,3.14159]])\nmatrix2 = tf.constant([[3.],[4.]])\n```", "```py\nproduct = tf.matmul(matrix1, matrix2)\n```", "```py\nwith tf.Session() as sess:\n    result = sess.run(product)\n    print(result)\n```", "```py\n#creating a convolutional neural network (skeleton--not complete code!)\n\n# create a convolutional (not fully connected) layer...\nconv1 = tf.layers.conv2d(x, 32, 5, activation=tf.nn.relu)\n# and down-sample\nconv1 = tf.layers.max_pooling2d(conv1, 2, 2)\n\n# create second layer\nconv2 = tf.layers.conv2d(conv1, 64, 3, activation=tf.nn.relu)\nconv2 = tf.layers.max_pooling2d(conv2, 2, 2)\n\n# flatten to 1D\nfc1 = tf.contrib.layers.flatten(conv2)\n\n# create fully-connected layer\nfc1 = tf.layers.dense(fc1, 1024)\n\n# final (output/prediction) layer\nout = tf.layers.dense(fc1, n_classes)\n\n#...training code etc.\n```", "```py\n#The main code:\n#\"image\" is a filename for the image we want to classify\n\n#load our inception-id to English description dictionary\nfrom inceptiondict import inceptiondict\n```", "```py\ndef run_inference_on_image(image):\n\n    #load image (making sure it exists)\n    if not tf.gfile.Exists(image):\n        tf.logging.fatal('File does not exist %s', image)\n    image_data = tf.gfile.FastGFile(image, 'rb').read()\n```", "```py\n    # Load our \"graph\" file--\n    # This graph is a pretrained model that maps an input image\n    # to one (or more) of a thousand classes.\n    # Note: generating such a model from scratch is VERY computationally\n    # expensive\n    with tf.gfile.FastGFile('classify_image_graph_def.pb', 'rb') as f:\n        graph_def = tf.GraphDef()\n        graph_def.ParseFromString(f.read())\n        _ = tf.import_graph_def(graph_def, name='')\n```", "```py\n   #create a TF session to actually apply our model\n    with tf.Session() as sess:\n        # Some useful tensors:\n        # 'softmax:0': A tensor containing the normalized prediction across\n        # 1000 labels.\n        # 'pool_3:0': A tensor containing the next-to-last layer containing 2048\n        # float description of the image.\n        # 'DecodeJpeg/contents:0': A tensor containing a string providing JPEG\n        # encoding of the image.\n        # Runs the softmax tensor by feeding the image_data as input to the graph.\n        softmax_tensor = sess.graph.get_tensor_by_name('softmax:0')\n        predictions = sess.run(softmax_tensor,\n                           {'DecodeJpeg/contents:0': image_data})\n        predictions = np.squeeze(predictions)\n\n        #The output here is a 1000 length vector, each element between 0 and 1, \n        #that sums to 1\\. Each element may be thought of as a probability\n        #that the image corresponds to a given class (object type, e.g. bird, \n        #plane, and so on).\n```", "```py\n        #We only care about the top 5 (at most) predictions, and ones that have\n        #at least a 10% probability of a match\n        num_top_predictions= 5\n        top_k = predictions.argsort()[-num_top_predictions:][::-1]\n        for node_id in top_k:\n            human_string = inceptiondict[node_id]\n            score = predictions[node_id]\n            if score > 0.1:\n                print('%s (score = %.5f)' % (human_string, score))\n```", "```py\n#uncomment out one of these lines to test\n\nimage='sample_imgs/cropped_panda.jpg'\n# image='sample_imgs/dog.jpg'\n# image='sample_imgs/bicycle2.jpg'\n# image='sample_imgs/garbagecan.jpg'\n# image='sample_imgs/bunny.jpg'\n# image='sample_imgs/trombone.jpg'\n# image='sample_imgs/treasurechest.jpg'\n# image='sample_imgs/hotdog.jpg'\nfigure()\nimshow(imread(image))\nrun_inference_on_image(image)\n```", "```py\n#pull the function from our custom retrain.py file\nfrom retrain import retrain\n\n#Now we'll train our model and generate our model/graph file 'output_graph.pb'\nretrain('toy_images')\n```", "```py\n#Confirm that it worked\n!ls *.pb\n\n#should see file \"output_graph.pb\"\n```", "```py\n#Let's load some code that will run our model on a specified image\n\ndef load_graph(model_file):\n    graph = tf.Graph()\n    graph_def = tf.GraphDef()\n\n    with open(model_file, \"rb\") as f:\n        graph_def.ParseFromString(f.read())\n    with graph.as_default():\n        tf.import_graph_def(graph_def)\n\n    return graph\n```", "```py\ndef read_tensor_from_image_file(file_name,\n                                input_height=299,\n                                input_width=299,\n                                input_mean=0,\n                                input_std=255):\n    input_name = \"file_reader\"\n    output_name = \"normalized\"\n    file_reader = tf.read_file(file_name, input_name)\n    if file_name.endswith(\".png\"):\n        image_reader = tf.image.decode_png(\n                file_reader, channels=3, name=\"png_reader\")\n    elif file_name.endswith(\".gif\"):\n        image_reader = tf.squeeze(\n                tf.image.decode_gif(file_reader, name=\"gif_reader\"))\n    elif file_name.endswith(\".bmp\"):\n        image_reader = tf.image.decode_bmp(file_reader, name=\"bmp_reader\")\n    else:\n        image_reader = tf.image.decode_jpeg(\n                file_reader, channels=3, name=\"jpeg_reader\")\n    float_caster = tf.cast(image_reader, tf.float32)\n    dims_expander = tf.expand_dims(float_caster, 0)\n    resized = tf.image.resize_bilinear(dims_expander, [input_height, input_width])\n    normalized = tf.divide(tf.subtract(resized, [input_mean]), [input_std])\n    sess = tf.Session()\n    result = sess.run(normalized)\n\n    return result\n```", "```py\ndef load_labels(label_file):\n    label = []\n    proto_as_ascii_lines = tf.gfile.GFile(label_file).readlines()\n    for l in proto_as_ascii_lines:\n        label.append(l.rstrip())\n    return label\n```", "```py\ndef label_image(file_name=None):\n    if not file_name:\n        file_name = \"test/mylittlepony2.jpg\"\n    model_file = \"./output_graph.pb\"\n    label_file = \"./output_labels.txt\"\n    input_height = 299\n    input_width = 299\n    input_mean = 0\n    input_std = 255\n    input_layer = \"Placeholder\"\n    output_layer = \"final_result\"\n```", "```py\n    graph = load_graph(model_file)\n    t = read_tensor_from_image_file(\n            file_name,\n            input_height=input_height,\n            input_width=input_width,\n            input_mean=input_mean,\n            input_std=input_std)\n\n    input_name = \"import/\" + input_layer\n    output_name = \"import/\" + output_layer\n    input_operation = graph.get_operation_by_name(input_name)\n    output_operation = graph.get_operation_by_name(output_name)\n```", "```py\n    with tf.Session(graph=graph) as sess:\n        results = sess.run(output_operation.outputs[0], {\n                input_operation.outputs[0]: t\n        })\n    results = np.squeeze(results)\n\n    top_k = results.argsort()[-5:][::-1]\n    labels = load_labels(label_file)\n    for i in top_k:\n        print(labels[i], results[i])\n```", "```py\n#label_image will load our test image and tell us what class/type it is\n\n#uncomment one of these lines to test\n#\ntest_image='test/transformers1.jpg'\n# test_image='test/transformers2.jpg'\n# test_image='test/transformers3.jpg'\n\n# test_image='test/mylittlepony1.jpg'\n# test_image='test/mylittlepony2.jpg'\n# test_image='test/mylittlepony3.jpg'\n\n# test_image='test/gijoe1.jpg'\n# test_image='test/gijoe2.jpg'\n# test_image='test/gijoe3.jpg'\n\n# test_image='test/barbie1.jpg'\n# test_image='test/barbie2.jpg'\n# test_image='test/barbie3.jpg'\n\n#display the image\nfigure()\nimshow(imread(test_image))\n\n#and tell us what the classification result is\nlabel_image(test_image)\n```", "```py\nimport tensorflow\n```", "```py\nprint(tensorflow.Session())\n```"]