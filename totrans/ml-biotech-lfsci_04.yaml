- en: 'Chapter 3: Getting Started with SQL and Relational Databases'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：SQL和关系型数据库入门
- en: 'According to a recent article published in the *Journal of Big Data Analytics
    and Its Applications*, every 60 seconds on the internet, the following happens:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 根据《大数据分析与应用杂志》最近发表的一篇文章，互联网上的每一秒，都会发生以下情况：
- en: 700,000 status updates are made.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作了70万条状态更新。
- en: 11 million messages are sent.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送了1,100万条消息。
- en: 170 million emails are received.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收了1.7亿封电子邮件。
- en: 1,820 **terabytes** (**TB**) of new data is created.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新增了1,820 **太字节** (**TB**) 的数据。
- en: It would be an understatement to claim that data within the business landscape
    is growing rapidly at an unprecedented rate. With this major explosion of information,
    companies around the globe are investing a great deal of capital in an effort
    to effectively capture, analyze, and deliver benefits from this data for the company.
    One of the main methods by which data can be managed and subsequently retrieved
    to provide actionable insights is through **Structured Query Language** (**SQL**).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 断言商业环境中数据以史无前例的速度快速增长是一种低估。随着这一主要信息爆炸，全球各地的公司都在投入大量资本，努力有效地捕捉、分析和从这些数据中为公司带来收益。数据可以管理和随后检索以提供可操作见解的主要方法之一是通过**结构化查询语言**
    (**SQL**)。
- en: 'Similar to how we used the **Terminal command line** to create **directories**,
    or Python to run calculations, you can use **SQL** to create and manage databases
    either locally on your computer or remotely in the cloud. SQL comes in many forms
    and flavors depending on the platform you choose to use, each of which contains
    a slightly different syntax. However, SQL generally consists of four main types
    of language statements, and these are outlined here:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们使用**终端命令行**创建**目录**，或者Python进行计算，你可以使用**SQL**在本地计算机上或远程云中创建和管理数据库。SQL的形式和风味取决于你选择的平台，每种形式都包含略微不同的语法。然而，SQL通常由四种主要类型的语言语句组成，这些将在下面概述：
- en: '**Data Manipulation Language** (**DML**): Querying and editing data'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据操纵语言** (**DML**)：查询和编辑数据'
- en: '**Data Definition Language** (**DDL**): Querying and editing database tables'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据定义语言** (**DDL**)：查询和编辑数据库表'
- en: '**Data Control Language** (**DCL**): Creating roles and adding permissions'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据控制语言** (**DCL**)：创建角色和添加权限'
- en: '**Transaction Control Language** (**TCL**): Managing database transactions'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务控制语言** (**TCL**)：管理数据库事务'
- en: Most companies around the globe have their own separate *best practices* when
    it comes to DDL, DCL, and TCL and how databases are integrated into their enterprise
    systems. However, DML is generally the same and is often the main focus of any
    given data scientist. For these purposes, we will focus this chapter on applications
    relating to DML. By the end of this chapter, you will have gained a strong introduction
    to some of the most important database concepts, fully installed MySQL Workbench
    on your local machine, and deployed a full **Amazon Web Services Relational Database
    Service** (**AWS RDS**) server to host and serve your data. Note that all of these
    capabilities can later be recycled for your own endeavors. Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 全球大多数公司都有自己的**最佳实践**，当涉及到DDL、DCL和TCL以及数据库如何集成到他们的企业系统中。然而，DML通常是相同的，并且通常是任何给定数据科学家的主要关注点。为此，我们将本章重点放在与DML相关的应用上。到本章结束时，你将获得一些最重要的数据库概念的强烈介绍，完全安装MySQL
    Workbench到你的本地机器上，并部署了一个完整的**亚马逊网络服务关系数据库服务** (**AWS RDS**)服务器来托管和提供你的数据。请注意，所有这些功能都可以后来用于你自己的事业。让我们开始吧！
- en: 'We will cover the following topics in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Exploring relational databases
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索关系型数据库
- en: 'Tutorial: Getting started with MySQL'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教程：MySQL入门
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will explore some of the main concepts behind relational
    databases, their benefits, and their applications. We will focus on one specific
    *flavor* of a relational database known as MySQL. We will use **MySQL** through
    its common **User Interface** (**UI**), known as **MySQL Workbench**. Whether
    you are using a Mac or a PC, the installation process for MySQL Workbench will
    be very similar, and we will walk through this together later in this chapter.
    This interface will allow you to interact with a database that can either be hosted
    on your local machine or far away in the cloud. Within this chapter, we will deploy
    and host our database server in the AWS cloud, and you will therefore need to
    have an AWS account. You can create an account by visiting the AWS website ([https://aws.amazon.com/](https://aws.amazon.com/))
    and signing up as a new user.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨关系数据库背后的主要概念、其优势和应用。我们将重点关注一种特定的关系数据库“风味”，即MySQL。我们将通过其常见的**用户界面**（**UI**），称为**MySQL
    Workbench**来使用MySQL。无论您使用的是Mac还是PC，MySQL Workbench的安装过程都将非常相似，我们将在本章后面一起进行操作。此界面将允许您与本地机器或云端远程托管的数据库进行交互。在本章中，我们将部署和托管我们的数据库服务器在AWS云中，因此您需要有一个AWS账户。您可以通过访问AWS网站([https://aws.amazon.com/](https://aws.amazon.com/))并注册为新用户来创建账户。
- en: Exploring relational databases
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索关系数据库
- en: There are numerous types of databases—such as **Object-Oriented** (**OO**) databases,
    graph databases, and relational databases—each of which offers a particular capability.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库类型繁多——例如**面向对象**（**OO**）数据库、图数据库和关系数据库——每种数据库都提供特定的功能。
- en: '**OO databases** are best used in conjunction with OO data. Data within these
    databases tends to consist of objects that contain members such as fields, functions,
    and properties; however, relations between objects are not well captured.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象数据库**最适合与面向对象数据一起使用。这些数据库中的数据通常由包含字段、函数和属性等成员的对象组成；然而，对象之间的关系并没有得到很好的捕捉。'
- en: On the other hand, **graph databases**, as the name suggests, are best used
    with data consisting of nodes and edges. One of the most common applications for
    graph databases in the biotechnology sector is in small-molecule drug design.
    Molecules consist of nodes and edges that connect together in one form or another—these
    relations are best captured in graph databases. However, the relationships between
    molecules are not well captured here either.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，正如其名所示，**图数据库**最适合用于由节点和边组成的数据。生物技术领域图数据库最常见的应用之一是小分子药物设计。分子由节点和边以某种形式连接在一起——这些关系最好在图数据库中捕捉。然而，分子之间的关系在这里也没有得到很好的捕捉。
- en: Finally, **relational databases**, as the name suggests, are best used for databases
    in which relations are of major importance. One of the most important applications
    of relational databases in the biotechnology and healthcare sectors surrounds
    patient data. Relational databases are used with patient data due to its complex
    nature. Patients will have many different fields, such as name, address, location,
    age, and gender. A patient will be prescribed a number of medications, each medication
    containing its own sub-fields, such as a lot of numbers, quantities, and expiration
    dates. Each lot will have a manufacturing location, manufacturing date, and its
    associated ingredients, and each ingredient will have its own respective parameters,
    and so on. The complex nature of this data and its associated relations is best
    captured in a relational database.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如其名所示，**关系数据库**最适合用于关系至关重要的数据库。关系数据库在生物技术和医疗保健领域的最重要应用之一是围绕患者数据。由于患者数据的复杂性，关系数据库常用于存储患者数据。患者将有许多不同的字段，如姓名、地址、位置、年龄和性别。患者将被开具多种药物，每种药物都包含其自身的子字段，如大量的数字、数量和过期日期。每个批次将有一个生产地点、生产日期及其相关成分，每个成分也将有其各自的参数，等等。这种数据的复杂性和其相关关系最好在关系数据库中捕捉。
- en: Relational databases are standard digital databases that host tables in the
    form of columns and rows containing relations to one another. The relationship
    between two tables exists in the form of a **Unique Identifier** (**UID**) or
    **Primary Key** (**PK**). This key acts as a unique value for each of the rows
    within a single table, allowing users to match rows of one table to their respective
    rows in another table. The tables are not technically connected in any way; they
    are simply referenced or related to one another. Let's take a look at a simple
    example when it comes to patient data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库是标准的数字数据库，以列和行的形式存储表格，这些列和行相互关联。两个表格之间的关系以**唯一标识符**（**UID**）或**主键**（**PK**）的形式存在。这个键作为单个表格中每行的唯一值，使用户能够将一个表格的行与另一个表格中相应的行匹配。这些表格在技术上并没有任何连接方式；它们只是相互引用或关联。让我们来看一个简单的例子，关于患者数据。
- en: 'If we were to create a table of patient data containing patients'' names, contact
    information, their pharmacies, and prescribing physicians, we would likely come
    up with a table similar to this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个包含患者姓名、联系信息、药店和开具处方的医生的患者数据表，我们可能会得到一个类似的表格：
- en: '![Figure 3.1 – Table showing an example patient dataset ](img/012.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 显示示例患者数据集的表格](img/012.jpg)'
- en: Figure 3.1 – Table showing an example patient dataset
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 显示示例患者数据集的表格
- en: From an initial perspective, this table makes perfect sense. We have the patient's
    information listed nicely on the left, showing their name, address, and phone
    number. We also have the patient's respective **Primary Care Physician** (**PCP**),
    showing their associated names, addresses, and phone numbers. Finally, we also
    have the patient's respective pharmacy and their associated contact information.
    If we were trying to generate a dataset on all of our patients and their respective
    PCPs and pharmacies, this would be the perfect table to use. However, storing
    this data in a database would be a different story.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从最初的角度来看，这个表格是完美的。我们左边的列表中清晰地列出了患者的信息，包括他们的姓名、地址和电话号码。我们还列出了患者的相应**初级保健医生**（**PCP**），包括他们的相关姓名、地址和电话号码。最后，我们还列出了患者的相应药店及其相关的联系信息。如果我们试图生成一个包含所有患者及其相应PCPs和药店的数据库，这将是一个完美的表格。然而，将这些数据存储在数据库中则是一个不同的故事。
- en: Notice that some of the PCP names and their contact information are repeated.
    Similarly, one of the pharmacies appears more than once in the sense that we have
    listed the name, address, and phone number twice in the same table. From the perspective
    of a three-row table, the repetition is negligible. However, as we scale this
    table from 3 patients to 30,000 patients, the repetition can be very costly from
    both a database perspective (to host the data) and a computational perspective
    (to retrieve the data).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到一些初级保健医生（PCP）的姓名和他们的联系信息是重复的。同样，一家药店在我们的列表中出现多次，因为我们已经在同一表格中两次列出了名称、地址和电话号码。从三行表格的角度来看，这种重复是可以忽略不计的。然而，当我们把这个表格从3个患者扩展到30,000个患者时，重复可能会从数据库的角度（存储数据）和计算的角度（检索数据）变得非常昂贵。
- en: Instead of having one single table host all our data, we can have multiple tables
    that when joined together temporarily for a particular purpose (such as generating
    a dataset) would be significantly less costly in the long run. This idea of splitting
    or **normalizing** data into smaller tables is the essence of relational databases.
    The main purpose of a **relational database** is to provide a convenient and efficient
    process to store and retrieve information while minimizing duplication as much
    as possible. To make this database more "relational", we can split the data into
    three tables—pharmacies, patients, and PCPs—so that we only store each entry once
    but use a system of keys to reference them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择不使用单一表格来存储所有数据，而是拥有多个表格，当它们为了特定目的（例如生成数据集）临时联合时，从长远来看会显著降低成本。将数据拆分或**规范化**到更小的表格中的这种想法是关系型数据库的核心。关系型数据库的主要目的是提供一个方便且高效的流程来存储和检索信息，同时尽可能减少重复。为了使这个数据库更加“关系型”，我们可以将数据拆分为三个表格——药店、患者和初级保健医生（PCPs）——这样我们只存储每个条目一次，但使用键系统来引用它们。
- en: 'Here, you can see a **Unified Modeling Language** (**UML**) diagram commonly
    used to describe relational databases. The connection between the tables indicated
    by the single line splitting into three others is a way to show a *one-to-many*
    relationship. In the following case, one pharmacy can have many patients and one
    PCP can have many patients, but a patient can have only one PCP and only one pharmacy.
    The ability to quickly understand a database design and translate that to a UML
    diagram (or vice versa) is an excellent skill to have when working with databases
    and is often regarded as an excellent interview topic—I actually received a question
    on this a few years ago:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到常用的**统一建模语言**（**UML**）图，通常用于描述关系型数据库。由单线分成三条线的连接表示一种**一对多**的关系。在以下情况下，一家药店可以有多个患者，一个PCP也可以有多个患者，但一个患者只能有一个PCP，也只能有一个药店。能够快速理解数据库设计并将其转换为UML图（或反之亦然）是处理数据库时的一项优秀技能，通常被视为一个优秀的面试话题——我实际上几年前就收到了这个问题：
- en: '![Figure 3.2 – The process of normalizing a larger table into smaller relational
    tables ](img/B17761_03_002.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 将更大的表规范化为较小的关系表的过程](img/B17761_03_002.jpg)'
- en: Figure 3.2 – The process of normalizing a larger table into smaller relational
    tables
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 将更大的表规范化为较小的关系表的过程
- en: The previous diagram provides a representation of how the original table can
    be split up. Notice that each of the tables has an ID; this ID is its UID or PK.
    Tables that are connected to others are referenced using a **Foreign Key** (**FK**).
    For example, a PCP can have multiple patients, but each patient will only have
    one PCP; therefore, each patient entry will need to have the FK of its associated
    PCP. Pretty interesting, huh?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图展示了原始表可以如何拆分。注意，每个表都有一个ID；这个ID是其UID或PK。与其他表相连的表使用**外键**（**FK**）进行引用。例如，一个PCP可以有多个患者，但每个患者只有一个PCP；因此，每个患者条目都需要有与其关联的PCP的外键。很有趣，对吧？
- en: The process of separating data in this fashion is known as database **normalization**,
    and there are a number of rules most relational databases must adhere to in order
    to be normalized properly. Data scientists do not often design major enterprise
    databases (we leave these tasks to database administrators). However, we often
    design smaller **proof-of-concept** databases that adhere to very similar standards.
    More often, we interact with significantly larger enterprise databases that are
    generally in a relational state or in the form of a data lake. In either case,
    a strong foundational knowledge of the structure and general idea behind relational
    databases is invaluable to any data scientist.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式分离数据的过程被称为数据库**规范化**，大多数关系型数据库都必须遵循一系列规则才能正确地进行规范化。数据科学家通常不会设计大型企业数据库（我们将这些任务留给数据库管理员）。然而，我们经常设计较小的**概念验证**数据库，这些数据库遵循非常相似的标准。更常见的是，我们与规模显著更大的企业数据库进行交互，这些数据库通常处于关系状态或以数据湖的形式存在。在两种情况下，对关系型数据库的结构和基本概念有扎实的知识对于任何数据科学家来说都非常有价值。
- en: Database normalization
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库规范化
- en: 'There are a number of rules we must consider when preparing a database that
    is **normalized**, often referred to as **normal forms**. There are three normal
    forms that we will briefly discuss within the context of relational databases,
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备一个**规范化**的数据库时，我们必须考虑许多规则，通常被称为**范式**。在关系型数据库的背景下，我们将简要讨论三个范式，如下所示：
- en: First normal form
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一范式
- en: 'In order to satisfy the **First Normal Form** (**1NF**) of database normalization,
    the values in each of the cells must be **atomic** in the sense that each cell
    contains only one type of data. For example, a column containing addresses such
    as **5 First Street, Boston MA 02215** contains non-atomic data and violates this
    rule as it contains street numbers, street names, cities, states, and zip codes
    in one cell. We can normalize this data by splitting it into five columns, as
    follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足数据库规范化的**第一范式**（**1NF**），每个单元格中的值在意义上必须是**原子的**，即每个单元格只包含一种类型的数据。例如，包含地址如**5
    First Street, Boston MA 02215**的列包含非原子数据，违反了此规则，因为它在一个单元格中包含了街道号码、街道名称、城市、州和邮政编码。我们可以通过将其拆分为五个列来规范化这些数据，如下所示：
- en: '![Figure 3.3 – Table showing how addresses can be split into individual atomic
    cells ](img/02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 表格显示如何将地址拆分为单个原子单元](img/02.jpg)'
- en: Figure 3.3 – Table showing how addresses can be split into individual atomic
    cells
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 表格显示如何将地址拆分为单个原子单元
- en: Now that we have gained a better understanding of the first form of data normalization,
    let's go ahead and explore the second form.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对第一种数据规范化形式有了更好的理解，让我们继续探索第二种形式。
- en: Second normal form
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二范式
- en: In order to satisfy the conditions of the **Second Normal Form** (**2NF**),
    the table must have a **PK** acting as a UID, and that all the fields excluding
    the PK must be functionally dependent on the entire key. For example, we can have
    a table with a list of all patients in the sense that the first name, last name,
    and phone number of the patients are dependent on the PK. This key represents
    the patient and nothing else. We can also have another table representing the
    PCPs, their locations, associated hospitals, and so on. However, it would not
    be appropriate from the perspective of database normalization to add this information
    to a table representing a patient.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足**第二范式**（**2NF**）的条件，表必须有一个**PK**作为UID，并且除了PK之外的所有字段必须完全依赖于整个键。例如，我们可以有一个包含所有患者的表，在这个表中，患者的名字、姓氏和电话号码依赖于PK。这个键代表患者，不代表其他任何东西。我们还可以有一个代表PCPs、他们的位置、相关医院等的另一个表。然而，从数据库规范化的角度来看，将此类信息添加到代表患者的表中是不合适的。
- en: To satisfy this condition with the patient database, we would need to split
    the table such that the patient data is in one table and the associated PCP is
    in a second table, connected via an FK, as we saw in the earlier example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足患者数据库的此条件，我们需要将表拆分，使得患者数据在一个表中，而相关的PCP在第二个表中，通过FK连接，正如我们在前面的例子中看到的。
- en: Third normal form
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三范式
- en: In order to satisfy the conditions for the **Third Normal Form** (**3NF**),
    we must satisfy the conditions of the 1NF and 2NF, in addition to ensuring that
    all the fields within the table are functionally independent of each other—in
    other words, no fields can be calculated fields. For example, a field titled *Age*
    with values of 27 years, 32 years, and 65 years of age would not be appropriate
    here as these are calculated quantities. Instead, a field titled *Date of Birth*
    with the associated dates could be used to satisfy this condition.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足**第三范式**（**3NF**）的条件，我们必须满足1NF和2NF的条件，并且确保表中的所有字段在功能上相互独立——换句话说，没有字段可以是计算字段。例如，一个标题为*年龄*的字段，其值为27岁、32岁和65岁，在这里是不合适的，因为这些是计算出来的量。相反，可以使用一个标题为*出生日期*的字段，并关联相应的日期来满足这个条件。
- en: Most data scientists spend little time structuring major databases and normalizing
    them; however, a great deal of time is spent understanding database structures
    and forming queries to retrieve data correctly and efficiently. Therefore, a strong
    foundational understanding of databases will always be useful.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据科学家在结构化主要数据库和规范化它们方面花费的时间很少；然而，他们花费大量时间理解数据库结构，并形成查询以正确和高效地检索数据。因此，对数据库的坚实基础理解始终是有用的。
- en: Although database administrators and data engineers tend to spend more time
    on structuring and normalizing databases, a great deal of time is spent at a data
    scientist's end when it comes to understanding these structures and developing
    effective queries to retrieve data correctly and efficiently. Therefore, a strong
    foundational understanding of databases will always be useful regardless of the
    type of database being used.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数据库管理员和数据工程师倾向于在结构化和规范化数据库上花费更多时间，但在理解这些结构并开发有效查询以正确和高效地检索数据时，数据科学家端花费的时间也很多。因此，无论使用哪种类型的数据库，对数据库的坚实基础理解始终是有用的。
- en: Types of relational databases
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库的类型
- en: 'There are several different *flavors* of **SQL** that you will likely encounter
    depending on the commercial database provider. Many of these databases can be
    split into two general categories: **open source** or **enterprise**. Open source
    databases are generally free, allowing students, educators, and independent users
    to use their software without restrictions, depending on their specific terms
    and conditions. Enterprise databases, on the other hand, are commonly seen in
    large companies. We''ll now look at some of the most common databases found in
    most industries, including tech, biotech, and healthcare.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 根据商业数据库提供商的不同，你可能会遇到几种不同的**SQL**版本。许多这些数据库可以分为两大类：**开源**或**企业级**。开源数据库通常是免费的，允许学生、教育者和独立用户根据他们的具体条款和条件无限制地使用他们的软件。另一方面，企业数据库通常在大公司中很常见。现在，我们将探讨大多数行业中常见的几种数据库，包括技术、生物技术和医疗保健行业。
- en: Open source
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开源
- en: 'The following list shows some common open source databases:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一些常见的开源数据库：
- en: '**SQLite**: An **Atomicity, Consistency, Isolation, Durability** (**ACID**)-compliant
    **relational database management system** (**RDBMS**) commonly used in smaller
    locally hosted projects. SQLite can be used within the Python language to store
    data.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLite**：一个符合**原子性、一致性、隔离性、持久性**（**ACID**）标准的**关系数据库管理系统**（**RDBMS**），常用于较小的本地托管项目。SQLite可以在Python语言中使用来存储数据。'
- en: '**MySQL**: Although not ACID-compliant, MySQL provides similar functionality
    to SQLite but at a larger scale, allowing for greater amounts of data to be stored,
    and providing multiuser access.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MySQL**：虽然不符合ACID标准，但MySQL提供了与SQLite相似的功能，但规模更大，可以存储更多的数据，并提供多用户访问。'
- en: '**PostgreSQL**: An ACID-compliant database system that provides faster data
    processing and is better suited for databases with larger user bases.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PostgreSQL**：一个符合ACID标准的数据库系统，提供更快的数据处理速度，更适合拥有更大用户群体的数据库。'
- en: Let's now explore some enterprise options instead.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来探索一些企业选项。
- en: Enterprise
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 企业
- en: 'The following list shows some common enterprise databases:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一些常见的企业数据库：
- en: '**AWS RDS**: A cloud-based relational database service that provides scalable
    and cost-efficient services to store, manage, and retrieve data.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS RDS**：一个基于云的关系数据库服务，提供可扩展且成本效益高的服务来存储、管理和检索数据。'
- en: '**Microsoft SQL Server**: An enterprise RDMS similar to that of MySQL Workbench
    with cloud-hosted services to store and retrieve data.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft SQL Server**：一个类似于MySQL Workbench的企业级关系数据库管理系统，提供云托管服务以存储和检索数据。'
- en: '**Systems Applications and Products in data processing** (**SAP**): An RDBS
    solution for storing and retrieving services, commonly used for inventory and
    manufacturing data.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统应用和产品在数据处理中**（**SAP**）：一个用于存储和检索服务的RDBS解决方案，常用于库存和制造数据。'
- en: Now, let's get hands-on with MySQL.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们动手操作MySQL。
- en: Tutorial – getting started with MySQL
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 教程 – MySQL入门
- en: In the following tutorial, we will explore one of the most common processes
    to launch a cloud-based server to host a private relational database. First, we
    will install an **instance** of MySQL—one of the most popular database management
    platforms. We will then create a full free-tier **AWS RDS server** and connect
    it to the MySQL instance. Finally, we will upload a local **Comma-Separated Values**
    (**CSV**) file pertaining to small-molecule toxicity and their associated properties
    and begin exploring and learning to query our data from our dataset.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的教程中，我们将探讨启动基于云的服务器以托管私有关系型数据库的最常见过程之一。首先，我们将安装一个**实例**的MySQL——这是最受欢迎的数据库管理平台之一。然后，我们将创建一个完整的免费层**AWS
    RDS服务器**并将其连接到MySQL实例。最后，我们将上传一个关于小分子毒性和其相关属性的本地**逗号分隔值**（**CSV**）文件，并开始探索和学习如何从我们的数据集中查询数据。
- en: 'You can see a representation of AWS RDS being connected to the MySQL instance
    here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到AWS RDS连接到MySQL实例的表示：
- en: '![Figure 3.4 – Diagram showing that MySQL will connect to AWS RDS ](img/B17761_03_004.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 显示MySQL将连接到AWS RDS的示意图](img/B17761_03_004.jpg)'
- en: Figure 3.4 – Diagram showing that MySQL will connect to AWS RDS
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 显示MySQL将连接到AWS RDS的示意图
- en: Important note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that while this tutorial involves the creation of a database within this
    AWS RDS instance for the toxicity dataset, you will be able to recycle all the
    components for future projects and create multiple new databases without having
    to repeat the tutorial. Let's get started!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然这个教程涉及到在这个AWS RDS实例中创建数据库以存储毒性数据集，但你将能够回收所有组件用于未来的项目，并创建多个新的数据库，而无需重复教程。让我们开始吧！
- en: Installing MySQL Workbench
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装MySQL Workbench
- en: 'Of the many database design tools available, MySQL Workbench tends to be the
    easiest to design, implement, and use. MySQL Workbench is simply a **Graphical
    UI** (**GUI**) virtual database design tool developed by Oracle and allows users
    to create, design, manage, and interact with databases for various projects. Alternatively,
    MySQL can be used in the form of MySQL Shell, allowing users to interact with
    databases using the terminal command line. For those interested in working from
    the terminal command line, MySQL Shell can be downloaded by navigating to [https://dev.mysql.com/downloads/shell/](https://dev.mysql.com/downloads/shell/)
    and using the **Microsoft Installer** (**MSI**). However, for the purposes of
    this tutorial, we will be using MySQL Workbench instead for its user-friendly
    interface. Let''s get started! Proceed as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多数据库设计工具中，MySQL Workbench通常是最容易设计、实施和使用的。MySQL Workbench简单来说是一个由Oracle开发的**图形用户界面**（**GUI**）虚拟数据库设计工具，它允许用户为各种项目创建、设计、管理和交互数据库。或者，MySQL也可以以MySQL
    Shell的形式使用，允许用户通过终端命令行与数据库交互。对于那些对使用终端命令行工作感兴趣的人，可以通过访问[https://dev.mysql.com/downloads/shell/](https://dev.mysql.com/downloads/shell/)并使用**微软安装程序**（**MSI**）来下载MySQL
    Shell。然而，为了本教程的目的，我们将使用MySQL Workbench，因为它具有用户友好的界面。让我们开始吧！按照以下步骤进行：
- en: Getting MySQL Workbench installed on your local computer is fairly simple and
    easy to complete. Go ahead and navigate to [https://dev.mysql.com/downloads/workbench/](https://dev.mysql.com/downloads/workbench/),
    select your respective operating system, and click **Download**, as illustrated
    in the following screenshot:![Figure 3.5 – MySQL Installer page ](img/B17761_03_005.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的本地计算机上安装MySQL Workbench相对简单且易于完成。请前往[https://dev.mysql.com/downloads/workbench/](https://dev.mysql.com/downloads/workbench/)，选择您的操作系统，然后点击**下载**，如图所示：![图3.5
    – MySQL安装程序页面](img/B17761_03_005.jpg)
- en: Figure 3.5 – MySQL Installer page
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.5 – MySQL安装程序页面
- en: 'Upon downloading the file, click **Install**. Follow through the installation
    steps if you have specific criteria that need to be met; otherwise, select all
    the default options. Be sure to allow MySQL to select the standard destination
    folder followed by the **Complete** setup type, as illustrated in the following
    screenshot:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载文件后，点击**安装**。如果您有特定的标准需要满足，请按照安装步骤进行；否则，选择所有默认选项。确保允许MySQL选择标准目标文件夹，然后选择**完整**设置类型，如图所示：
- en: '![Figure 3.6 – MySQL Installer page (continued) ](img/B17761_03_006.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – MySQL安装程序页面（继续）](img/B17761_03_006.jpg)'
- en: Figure 3.6 – MySQL Installer page (continued)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – MySQL安装程序页面（继续）
- en: With that, MySQL Workbench has now been successfully installed on your local
    machine. We will now head to the AWS website to create a remote instance of a
    database for us to use. Please note that we will assume that you have already
    created an AWS account.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，MySQL Workbench现在已成功安装在您的本地机器上。我们将前往AWS网站创建一个远程数据库实例供我们使用。请注意，我们假设您已经创建了一个AWS账户。
- en: Creating a MySQL instance on AWS
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在AWS上创建MySQL实例
- en: 'Let''s create a MySQL instance, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个MySQL实例，如下所示：
- en: Navigate to [https://www.aws.amazon.com](https://www.aws.amazon.com) and log
    in to your AWS account. Once logged in, head to the AWS Management Console, and
    select **RDS** from the **Database** section, as illustrated in the following
    screenshot:![Figure 3.7 – AWS Management Console page ](img/B17761_03_007.jpg)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到[https://www.aws.amazon.com](https://www.aws.amazon.com)，并登录您的AWS账户。登录后，前往AWS管理控制台，并在**数据库**部分选择**RDS**，如图所示：![图3.7
    – AWS管理控制台页面](img/B17761_03_007.jpg)
- en: Figure 3.7 – AWS Management Console page
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.7 – AWS管理控制台页面
- en: From the top of the page, click the **Create Database** button. Select the **Standard
    create** option for the database creation method, and then select **MySQL** as
    the engine type, as illustrated in the following screenshot:![Figure 3.8 – RDS
    engine options ](img/B17761_03_008.jpg)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从页面顶部点击**创建数据库**按钮。选择数据库创建方法的**标准创建**选项，然后选择**MySQL**作为引擎类型，如图所示：![图3.8 – RDS引擎选项](img/B17761_03_008.jpg)
- en: Figure 3.8 – RDS engine options
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.8 – RDS引擎选项
- en: 'In the **Templates** section, you will have three different options: **Production**,
    **Dev/Test**, and **Free tier**. While you can certainly select the first two
    options if you are planning to use a production-level server, I would recommend
    selecting the third option, **Free tier**, in order to take advantage of it being
    free. The following screenshot shows this option being selected:![Figure 3.9 –
    RDS template options ](img/B17761_03_009.jpg)'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**模板**部分，您将拥有三个不同的选项：**生产环境**、**开发/测试**和**免费层**。如果您打算使用生产级服务器，当然可以选择前两个选项，但我建议您选择第三个选项，**免费层**，以便充分利用其免费的优势。以下截图显示了选择此选项的情况：![图3.9
    – RDS模板选项](img/B17761_03_009.jpg)
- en: Figure 3.9 – RDS template options
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.9 – RDS模板选项
- en: Under the `toxicitydatabase` for the `admin`, followed by a password of your
    choice. You may also take advantage of the **Auto generate a password** feature
    that AWS provides. If you select this option, the password will be made available
    to you after the instance is created. The process is illustrated in the following
    screenshot:![Figure 3.10 – RDS settings options ](img/B17761_03_010.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`toxicitydatabase`的`admin`用户下，接着输入您选择的密码。您还可以利用AWS提供的**自动生成密码**功能。如果您选择此选项，密码将在实例创建后对您可用。该过程在以下截图中展示：![图3.10
    – RDS设置选项](img/B17761_03_010.jpg)
- en: Figure 3.10 – RDS settings options
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.10 – RDS设置选项
- en: Under the `db.t2.micro` instance type. For storage, select the default parameters
    in which the **Storage Type is General Purpose (SSD)** option is selected, and
    allocate a size of 20 **gigabytes** (**GB**) for the server. Be sure to disable
    the autoscaling capability as we will not require this feature.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`db.t2.micro`实例类型下。对于存储，选择默认参数，其中**存储类型为通用型(SSD)**选项被选中，并为服务器分配20**千兆字节**（**GB**）的大小。请确保禁用自动扩展功能，因为我们不需要此功能。
- en: Finally, when it comes to connectivity, select your default **Virtual Private
    Cloud** (**VPC**), followed by the default subnet. Be sure to change the **Public
    Access** setting to **Yes** as this will allow us to connect to the instance from
    our local MySQL installation. Next, ensure that the **Password and IAM database
    authentication** option in the **Database authentication** section is selected,
    as illustrated in the following screenshot. Next, click **Create Database**:![Figure
    3.11 – RDS password-generation options ](img/B17761_03_011.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当涉及到连接性时，选择您的默认**虚拟私有云**（**VPC**），然后选择默认子网。请确保将**公共访问**设置更改为**是**，因为这将允许我们从本地的MySQL安装连接到实例。接下来，确保在**数据库身份验证**部分的**密码和IAM数据库身份验证**选项被选中，如图所示。然后，点击**创建数据库**：![图3.11
    – RDS密码生成选项](img/B17761_03_011.jpg)
- en: Figure 3.11 – RDS password-generation options
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.11 – RDS密码生成选项
- en: 'Once the database creation process is started, you will be redirected to your
    RDS console consisting of a list of databases where you will see a `toxicitydataset`
    database being created, as illustrated in the following screenshot. Note that
    the **Status** column of the database will show as **Pending** for a few moments.
    In the meantime, if you requested that AWS automatically generate a password for
    your database, you will find that in the **View connection details** button at
    the top of the page. Note that for security reasons, *these credentials will never
    be revealed to you again*. Be sure to open these details and copy all of the contents
    to a safe location. Connecting to this remote database via the local MySQL interface
    will require the master **Username**, the master **Password**, and the specified
    **Endpoint** values. With that, we have now created an AWS RDS server and we can
    now leave AWS in its current state and divert our full attention to MySQL Workbench:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦开始数据库创建过程，您将被重定向到您的RDS控制台，其中包含数据库列表，您将看到正在创建的`toxicitydataset`数据库，如图所示。请注意，数据库的**状态**列将显示为**挂起**一段时间。在此期间，如果您请求AWS为您自动生成数据库密码，您将在页面顶部的**查看连接详情**按钮中找到它。请注意，出于安全原因，*这些凭据将永远不会再次向您展示*。请确保打开这些详情并将所有内容复制到安全位置。通过本地MySQL界面连接到这个远程数据库需要主**用户名**、主**密码**和指定的**端点**值。这样，我们现在已经创建了一个AWS
    RDS服务器，我们可以现在离开AWS保持当前状态，并将全部注意力转向MySQL Workbench：
- en: '![Figure 3.12 – RDS menu ](img/B17761_03_012.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – RDS菜单](img/B17761_03_012.jpg)'
- en: Figure 3.12 – RDS menu
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – RDS菜单
- en: With our AWS infrastructure prepared, let's go ahead and start working with
    our newly created database.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的AWS基础设施准备就绪后，让我们开始使用我们新创建的数据库。
- en: Working with MySQL
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MySQL
- en: 'Once the setup on AWS is complete, go ahead and open MySQL Workbench. Note
    that you may be prompted to restart your computer. Follow these next steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦AWS上的设置完成，请继续打开MySQL Workbench。请注意，您可能会被提示重新启动计算机。按照以下步骤操作：
- en: You should be greeted with a welcome message, followed by various options. To
    the right of the **MySQL Connections** section, click the **+** sign to add a
    new connection, as illustrated in the following screenshot:![Figure 3.13 – MySQL
    Connections button ](img/B17761_03_013.jpg)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该会看到一个欢迎信息，然后是各种选项。在**MySQL连接**部分的右侧，点击**+**号以添加新的连接，如图所示：![图3.13 – MySQL连接按钮](img/B17761_03_013.jpg)
- en: Figure 3.13 – MySQL Connections button
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.13 – MySQL连接按钮
- en: In this menu, we will create a new database connection called `toxicity_db_tutorial`.
    We will select the `Standard (TCP/IP)` connection method. Change the **Hostname**
    field to the endpoint that was provided to you in the connection details page
    in AWS. Next, add the username and password that was either specified or generated
    for you in AWS. Be sure to store your password in the vault to access it at a
    later time. Finally, click on the **Test Connection** button. The process is illustrated
    in the following screenshot. If all steps were correctly followed, you should
    receive a **Successful connection** response:![Figure 3.14 – MySQL Setup New Connection
    menu ](img/B17761_03_014.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此菜单中，我们将创建一个名为`toxicity_db_tutorial`的新数据库连接。我们将选择`标准（TCP/IP）`连接方法。将**主机名**字段更改为在AWS连接详情页面中提供的端点。接下来，添加在AWS中指定或为您生成的用户名和密码。务必将您的密码保存在保险库中，以便稍后访问。最后，点击**测试连接**按钮。过程如图所示。如果所有步骤都正确执行，您应该收到**成功连接**的响应：![图3.14
    – MySQL设置新连接菜单](img/B17761_03_014.jpg)
- en: Figure 3.14 – MySQL Setup New Connection menu
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.14 – MySQL设置新连接菜单
- en: In the main menu, you should see the new connection listed under the **MySQL
    Connections** section. Double-click the newly created connection, enter your root
    computer password (if not saved in the vault), and click **OK**. With that, we
    have created a new database connection and connected to it using MySQL Workbench.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主菜单中，您应该在**MySQL连接**部分下看到新连接。双击新创建的连接，输入您的root计算机密码（如果未保存在保险库中），然后点击**确定**。这样，我们就已创建了一个新的数据库连接，并使用MySQL
    Workbench连接到了它。
- en: 'The documentation for MySQL is quite extensive, as it contains a great deal
    of functionality that almost requires its very own book to fully cover. For the
    purposes of this tutorial, we will focus our efforts on a subset of functionality
    that is most commonly used in the data science field. There are three main sections
    within the **MySQL Workbench** window a user should be aware of—the **schema navigator**,
    the **query editor**, and the **output window**, as illustrated in the following
    screenshot:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MySQL的文档非常全面，因为它包含了许多几乎需要一本自己的书来完全涵盖的功能。为了本教程的目的，我们将专注于数据科学领域中常用功能的一个子集。在**MySQL
    Workbench**窗口中，用户应该注意三个主要部分——**模式导航器**、**查询编辑器**和**输出窗口**，如图所示：
- en: '![Figure 3.15 – MySQL Workbench preview ](img/B17761_03_015.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图3.15 – MySQL Workbench预览](img/B17761_03_015.jpg)'
- en: Figure 3.15 – MySQL Workbench preview
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – MySQL Workbench预览
- en: The **schema navigator** is the section of the window that allows users to navigate
    between databases. Depending on who you ask and in what context, the words *schema*
    and *database* are sometimes synonymous and used interchangeably. Within the context
    of this book, we will define *schema* as the blueprint of a database, and *database*
    as the database itself.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式导航器**是窗口中允许用户在数据库之间导航的部分。根据您询问的人和上下文，单词“模式”和“数据库”有时是同义的，可以互换使用。在本书的上下文中，我们将“模式”定义为数据库的蓝图，“数据库”本身即为数据库。'
- en: The **query editor** is the section of the page where you, as the user, will
    execute your SQL scripts. Within this section, data can be created, updated, queried,
    or deleted. You can use the **output window**, as the name suggests, for displaying
    the output of your executed queries. If a query goes wrong or if something unexpected
    happens, you will likely find an important message about it listed here.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询编辑器**是页面中您作为用户将执行SQL脚本的部分。在此部分中，可以创建、更新、查询或删除数据。您可以使用**输出窗口**（正如其名所示），用于显示执行查询的输出。如果查询出错或发生意外情况，您可能会在这里找到关于它的一个重要信息。'
- en: Creating databases
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库
- en: 'Before we can begin making any queries, we will need some data to work with.
    Let''s take a look at the currently existing databases in our new server. In the
    query editor, type in `SHOW DATABASES;`, and click on the **Execute** (![](img/Image87661.png))
    button. You will be provided a list of databases available on your system. Most
    of these databases were either created from previous projects or by your system
    to manage data. Either way, let''s avoid using those. Now, follow these next steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始进行任何查询之前，我们需要一些数据来工作。让我们看看我们新服务器上当前存在的数据库。在查询编辑器中输入 `SHOW DATABASES;`，然后点击
    **执行** (![](img/Image87661.png)) 按钮。你将得到一个系统上可用的数据库列表。大多数这些数据库要么是从以前的项目创建的，要么是系统用来管理数据的。无论如何，让我们避免使用那些。现在，按照以下步骤操作：
- en: 'We can create a new database using the following SQL statement:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下 SQL 语句创建一个新的数据库：
- en: '[PRE0]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the output window, you should see a message confirming the successful execution
    of this statement. Let's now go ahead and populate our database with a previously
    existing CSV file. Select the **Schemas** tab from the schema navigator and refresh
    the list using the icon with two circular arrows. You will see the newly created
    database appear in the list, as illustrated here:![Figure 3.16 – MySQL schema
    list ](img/B17761_03_016.jpg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出窗口中，你应该看到一条消息确认此语句的执行成功。现在，让我们继续用之前存在的 CSV 文件填充我们的数据库。从模式导航器中选择 **模式** 选项卡，并使用带有两个圆形箭头的图标刷新列表。你将看到新创建的数据库出现在列表中，如图所示：![图
    3.16 – MySQL 模式列表](img/B17761_03_016.jpg)
- en: Figure 3.16 – MySQL schema list
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.16 – MySQL 模式列表
- en: Next, right-click on the database, and click on `dataset_toxicity_sd.csv`. CSV
    file. When prompted to select a destination, select the default parameters, allowing
    MySQL to create a new table called `dataset_toxicity_sd` within the `toxicity_db_tutorial`
    database. In the **Import Configuration** settings, allow MySQL to select the
    default datatypes for the dataset. Continue through the wizard until the import
    process is complete. Given the remote nature of our server, it may take a few
    moments to transfer the file.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在数据库上右键单击，然后点击 `dataset_toxicity_sd.csv` CSV 文件。当提示选择目的地时，选择默认参数，允许 MySQL
    在 `toxicity_db_tutorial` 数据库中创建一个名为 `dataset_toxicity_sd` 的新表。在 **导入配置** 设置中，允许
    MySQL 为数据集选择默认数据类型。继续通过向导直到导入过程完成。鉴于我们的服务器是远程的，文件传输可能需要一些时间。
- en: 'Once the file is fully imported into AWS RDS, we are now ready to examine our
    data and start running a few SQL statements. If you click on the table within
    the schema navigator, you will see a list of all columns that were imported from
    the CSV file, as illustrated in the following screenshot:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦文件完全导入到 AWS RDS，我们现在就可以检查我们的数据并开始运行一些 SQL 语句。如果你在模式导航器中点击表，你会看到从 CSV 文件中导入的所有列的列表，如下面的截图所示：
- en: '![Figure 3.17 – List of columns in the toxicity dataset ](img/B17761_03_017.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.17 – 毒性数据集的列列表](img/B17761_03_017.jpg)'
- en: Figure 3.17 – List of columns in the toxicity dataset
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – 毒性数据集的列列表
- en: Taking a closer look at these columns, we notice that we begin with an `ID`
    column that is operating as our PK or UID, with the datatype `int`, for integer.
    We then notice a column called `smiles`, which is a text or string representing
    the actual chemical structure of the molecule. Next, we have a column called `toxic`,
    which is the *toxicity* of the compound represented as *1* for toxic, or *0* for
    non-toxic. We will call the `toxic` column our `FormalCharge` to `LogP` are the
    molecules' **attributes** or **features**. One of the main objectives that we
    will embark upon in a later chapter is developing a predictive model to use these
    features as input data and attempt to predict the toxicity. For now, we will be
    using this dataset to explore SQL and its most common **clauses** and **statements**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看这些列，我们注意到我们开始于一个 `ID` 列，它作为我们的 PK 或 UID，数据类型为 `int`，即整数。然后我们注意到一个名为 `smiles`
    的列，它是一个文本或字符串，代表分子的实际化学结构。接下来，我们有一个名为 `toxic` 的列，它表示化合物的 *毒性*，用 *1* 表示有毒，或用 *0*
    表示无毒。我们将 `toxic` 列称为我们的 `FormalCharge` 到 `LogP` 是分子的 **属性** 或 **特征**。我们在下一章将要着手的主要目标之一是开发一个预测模型，使用这些特征作为输入数据并尝试预测毒性。现在，我们将使用这个数据集来探索
    SQL 及其最常用的 **子句** 和 **语句**。
- en: Querying data
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询数据
- en: With the file fully imported into AWS RDS, we are now ready to run a few commands.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 文件已完全导入到 AWS RDS，我们现在可以运行一些命令了。
- en: 'We will begin with a simple `SELECT` statement in which we will retrieve all
    of our data from the newly created table. We can use the `*` argument after the
    `SELECT` command to denote *all data* within a particular table. The table itself
    can be specified at the end using the following syntax: `<database_name>.<table_name>:`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的`SELECT`语句开始，我们将从新创建的表中检索所有数据。我们可以在`SELECT`命令之后使用`*`参数来表示特定表中的所有数据。表本身可以使用以下语法在末尾指定：`<database_name>.<table_name>:`
- en: 'In the actual command, it looks like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际命令中，它看起来是这样的：
- en: '[PRE1]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This gives us the following output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '![Figure 3.18 – MySQL Workbench query preview  ](img/B17761_03_018.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图3.18 – MySQL Workbench查询预览](img/B17761_03_018.jpg)'
- en: Figure 3.18 – MySQL Workbench query preview
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – MySQL Workbench查询预览
- en: 'We will rarely query *all* columns and *all* rows of our data in any given
    query. More often than not, we will limit the columns to those of interest. We
    can accomplish this by substituting the `*` argument with a list of columns of
    interest, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何给定的查询中，我们很少会查询所有列和所有行。通常情况下，我们会将列限制在我们感兴趣的列上。我们可以通过将`*`参数替换为感兴趣列的列表来实现这一点，如下所示：
- en: '[PRE2]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice that the columns are separated by a comma, whereas the other arguments
    within the statement are not. In addition to limiting the number of columns, we
    can also limit the number of rows using a `LIMIT` clause followed by the number
    of rows we want to retrieve, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，列之间用逗号分隔，而语句中的其他参数则不是。除了限制列数外，我们还可以使用`LIMIT`子句来限制行数，后面跟我们要检索的行数，如下所示：
- en: '[PRE3]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In addition to specifying our columns and rows, we can also apply operations
    to column values such as addition, subtraction, multiplication, and division.
    We can also filter our data based on a specific set of conditions. For example,
    we could run a simple query for the `ID` and `smiles` columns for all toxic compounds
    (`toxic=1`) in the database, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定我们的列和行之外，我们还可以对列值应用操作，如加法、减法、乘法和除法。我们还可以根据特定的条件集过滤我们的数据。例如，我们可以运行一个简单的查询，查询数据库中所有有毒化合物（`toxic=1`）的`ID`和`smiles`列，如下所示：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Similarly, we could also find all non-toxic compounds by changing the final
    line of our statement to `WHERE toxic = 0` or to `WHERE toxic != 1`. We can extend
    this query with the addition of more conditionals within a `WHERE` clause.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以通过将语句的最后一行更改为`WHERE toxic = 0`或`WHERE toxic != 1`来找到所有非有毒化合物。我们可以在`WHERE`子句中添加更多的条件来扩展此查询。
- en: Conditional querying
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件查询
- en: 'Conditional queries can be used to filter data more effectively, depending
    on the use case at hand. We can use the `AND` operator to query data relating
    to a specific toxicity and `AND` operator would ensure that both conditions would
    need to be met, as illustrated in the following code snippet:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 条件查询可以根据具体的使用场景更有效地过滤数据。我们可以使用`AND`运算符来查询与特定毒性相关的数据，`AND`运算符将确保需要满足两个条件，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternatively, we can also use the `OR` operator in which either one of the
    conditions needs to be met—for example, the preceding query would require that
    the data has a toxic value of `1`, and a mol wt of `500`, thus returning 26 rows
    of data. The use of an `OR` operator here instead would require that *either*
    one of the conditions is met, thus returning 318 rows instead. Operators can also
    be used in combination with one another. For example, what if we wanted to query
    the IDs, smiles representations, and toxicities of all molecules that have `1`
    hydrogen acceptor, and either `1`, `2`, or `3` hydrogen donors? We can fulfill
    this query with the following statement:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用`OR`运算符，其中只需要满足一个条件——例如，前面的查询需要数据具有毒性值为`1`和摩尔质量为`500`，因此返回26行数据。在这里使用`OR`运算符将需要满足*任一*条件，因此返回318行。运算符也可以组合使用。例如，如果我们想查询具有`1`个氢受体和`1`、`2`或`3`个氢供体的所有分子的ID、smiles表示和毒性，我们可以使用以下语句来完成此查询：
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is important to note that when specifying multiple `OR` operators for values
    in consecutive order such as with the three `HDonors` values, the `BETWEEN` operator
    can be used instead to avoid unnecessary repetition.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，当指定连续顺序中的多个`OR`运算符，例如三个`HDonors`值时，可以使用`BETWEEN`运算符来避免不必要的重复。
- en: Grouping data
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据分组
- en: 'Another common practice when running queries against a database is grouping
    data by a certain column. Let''s take as an example a situation in which we must
    retrieve the total number of instances of toxic versus non-toxic compounds within
    our dataset. We could easily query the instances in which the values of `1` or
    `0` are present using a `WHERE` statement. However, what if the number of outcomes
    was `100` instead of `2`? It would not be feasible to run this query 100 times,
    substituting the value in each iteration. For this type of operation, or any operation
    in which the grouping of values is of importance, we can use a `GROUP BY` statement
    in combination with a `COUNT` function, as illustrated in the following code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在对数据库进行查询时，一个常见的做法是按某一列对数据进行分组。让我们以一个必须检索数据集中有毒与无毒化合物实例总数的情况为例。我们可以通过使用`WHERE`语句轻松查询值为`1`或`0`的实例。然而，如果结果的数量是`100`而不是`2`呢？运行这个查询100次，每次迭代替换值，将不可行。对于这种类型的操作，或者任何分组值重要的操作，我们可以使用`GROUP
    BY`语句与`COUNT`函数的组合，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is shown in the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下面的屏幕截图中有显示：
- en: '![Figure 3.19 – MySQL Workbench GROUPBY preview  ](img/B17761_03_019.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图3.19 – MySQL Workbench GROUPBY预览](img/B17761_03_019.jpg)'
- en: Figure 3.19 – MySQL Workbench GROUPBY preview
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 – MySQL Workbench GROUPBY预览
- en: Now that we have explored how to group our data, let's go ahead and learn how
    to order it as well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何分组我们的数据，接下来让我们学习如何对数据进行排序。
- en: Ordering data
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据排序
- en: 'There will be some instances in which your data will need to be ordered in
    some fashion, either in an ascending or descending manner. For this, you can use
    an `ORDER BY` clause in which the sorting column is listed directly after, followed
    by `ASC` for ascending or `DESC` for descending. This is illustrated in the following
    code snippet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你的数据可能需要以某种方式排序，无论是升序还是降序。为此，你可以使用`ORDER BY`子句，其中排序列直接列出，后跟`ASC`表示升序或`DESC`表示降序。这在下面的代码片段中有说明：
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Joining tables
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表的连接
- en: Often when querying records, tables will have been normalized, as previously
    discussed, to ensure that their data was properly stored in a relational manner.
    It will often be the case that you will need to merge or join two tables together
    to prepare your dataset of interest prior to beginning any type of meaningful
    `JOIN` clause to join two tables together.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 经常在查询记录时，表已经被规范化，如前所述，以确保它们的数据以关系方式正确存储。通常情况下，你将需要合并或连接两个表，以便在开始任何类型的有意义`JOIN`子句之前准备你感兴趣的数据集。
- en: 'Using the same `dataset_orderQuantities_sd.csv` dataset into the same database.
    Recall that you can specify the same database name but a different table name
    within the import wizard. Once loaded, we will now have a database consisting
    of two tables: `dataset_toxicity_sd` and `dataset_orderQuantities_sd`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的`dataset_orderQuantities_sd.csv`数据集导入到同一个数据库中。回想一下，你可以在导入向导中指定相同的数据库名称，但不同的表名称。一旦加载，我们现在将有一个包含两个表的数据库：`dataset_toxicity_sd`和`dataset_orderQuantities_sd`。
- en: If we run a `SELECT *` statement on each of the tables, we notice that the only
    column the two datasets have in common is the `ID` column. This will act as the
    UID to connect the two datasets. However, we also notice that the toxicity dataset
    consists of `1461` rows, whereas the `orderQuantities` dataset consists of 728
    rows. This means that one dataset is missing quite a few rows. This is where different
    types of `JOIN` clauses come in.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对每个表运行`SELECT *`语句，我们会注意到这两个数据集唯一共有的列是`ID`列。这将成为连接两个数据集的UID。然而，我们也注意到毒性数据集有`1461`行，而`orderQuantities`数据集有728行。这意味着一个数据集缺失了很多行。这就是不同类型的`JOIN`子句发挥作用的地方。
- en: 'Imagine the two datasets as circles to be represented as Venn diagrams with
    one circle (*A*) consisting of `1461` rows of data, and one circle (*B*) consisting
    of 728 rows of data. We could join the tables such that we would discard any rows
    that do not match using an `INNER JOIN` function. Notice that this is represented
    in the following screenshot as the intersection, or *A ![](img/03.png) B*, of
    the two circles. Alternatively, we could run a `LEFT JOIN` or `RIGHT JOIN` statement
    to our data, neglecting the differing contents of one of the datasets represented
    by *A'' ![](img/03.png) B* or *A ![](img/03.png) B''*. Finally, we can use an
    `OUTER JOIN` statement to join the data, merging the two tables regardless of
    missing rows, known as a union, or *A ![](img/04.png) B*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个数据集想象成需要用维恩图表示的圆圈，其中一个圆圈（*A*）包含 `1461` 行数据，另一个圆圈（*B*）包含 728 行数据。我们可以使用 `INNER
    JOIN` 函数将表连接起来，从而丢弃任何不匹配的行。注意，这在以下屏幕截图中被表示为两个圆圈的交集，即 *A ![img/03.png](img/03.png)
    B*。或者，我们可以在数据上运行 `LEFT JOIN` 或 `RIGHT JOIN` 语句，忽略由 *A' ![img/03.png](img/03.png)
    B* 或 *A ![img/03.png](img/03.png) B'* 表示的其中一个数据集的不同内容。最后，我们可以使用 `OUTER JOIN` 语句将数据连接起来，无论缺失哪些行，这被称为并集，或
    *A ![img/04.png](img/04.png) B*：
- en: '![Figure 3.20 – Representation of the four main join methods  ](img/B17761_03_020.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.20 – 四种主要连接方法的表示 ![img/B17761_03_020.jpg](img/B17761_03_020.jpg)]'
- en: Figure 3.20 – Representation of the four main join methods
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20 – 四种主要连接方法的表示
- en: 'As you begin to explore datasets and join tables, you will find the most common
    `JOIN` clause is in fact the `INNER JOIN` statement, which is what we will need
    for our particular application. We will structure the statement as follows: we
    will select columns of interest, specify the source table, and then run an inner
    join in which we match the two `ID` columns together. The code is illustrated
    in the following snippet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始探索数据集并连接表时，你会发现最常用的 `JOIN` 子句实际上是 `INNER JOIN` 语句，这正是我们特定应用所需要的。我们将按照以下结构构建语句：我们将选择感兴趣的列，指定源表，然后运行一个内部连接，将两个
    `ID` 列匹配在一起。代码在以下代码片段中展示：
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With that, we have successfully managed to take our first dataset (consisting
    of only the individual research and development molecules and their associated
    properties) and join it with another table (consisting of the order quantities
    of those molecules), allowing us to determine which substances we currently have
    in stock. Now, if we needed to find all compounds with a specific **lipophilicity**
    (**logP**), we can identify which ones we have in stock and in which quantities.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们成功地管理了我们的第一个数据集（仅包含个别研究和开发分子及其相关属性）并将其与另一个表（包含这些分子的订购数量）连接起来，使我们能够确定我们目前库存中的物质。现在，如果我们需要找到具有特定
    **亲脂性**（**logP**）的所有化合物，我们可以确定我们库存中有哪些以及它们的数量。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: SQL is a powerful language when it comes to querying vast amounts of data from
    relational databases—a skill that will serve you well in all areas of technology
    and most areas of biotechnology. As most companies begin to grow their database
    capabilities, you will likely encounter databases of many kinds, especially relational
    databases.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到查询关系数据库中的大量数据时，SQL 是一种强大的语言——这项技能将在所有技术领域以及大多数生物技术领域为你提供良好的服务。随着大多数公司开始扩大其数据库能力，你可能会遇到许多不同类型的数据库，尤其是关系数据库。
- en: When it comes to theory, we discussed some of the most important characteristics
    of relational databases and how data is generally normalized. We looked over an
    example of patient data and how a table could be normalized to reduce repetition
    when being stored. We also looked over some of the most common open source and
    enterprise databases available and readily used on the market today.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在理论方面，我们讨论了关系数据库的一些最重要的特征以及数据通常是如何进行规范化的。我们查看了一个患者数据的例子以及如何将表规范化以减少存储时的重复。我们还查看了一些市场上今天可用和广泛使用的开源和商业数据库。
- en: When it comes to applications, we put together a robust AWS RDS database server
    and deployed it to the cloud. We then connected our local instance of MySQL to
    that server and populated it with a new database using a CSV file. We then went
    over some of the most common SQL statements and clauses used in the industry today.
    We looked at ways to select, filter, group, and order data. We then looked at
    an example of joining two tables together and understood the different join methods
    available to us.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到应用时，我们组装了一个健壮的 AWS RDS 数据库服务器并将其部署到云端。然后，我们将本地 MySQL 实例连接到该服务器，并使用 CSV 文件填充了一个新数据库。接着，我们回顾了目前在业界使用的最常见
    SQL 语句和子句。我们探讨了选择、过滤、分组和排序数据的方法。然后，我们查看了一个将两个表连接起来的示例，并了解了我们可用的不同连接方法。
- en: Although this book was designed to introduce you to some of the most important
    core concepts every data scientist should know, there were many other topics within
    SQL that we did not cover. I would urge you to review the MySQL documentation
    to learn about the many other exciting statements available, allowing you to query
    data in many different shapes and sizes. SQL will always be used specifically
    to retrieve and review data in a tabular form but will never be the proper tool
    to visualize data—this task is best left to Python and its many visualization
    libraries, which will be the focus of the next chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书旨在向您介绍每位数据科学家都应该了解的一些最重要的核心概念，但在 SQL 中还有许多其他主题我们没有涉及。我敦促您查阅 MySQL 文档，以了解许多其他令人兴奋的语句，这些语句允许您以许多不同的形状和大小查询数据。SQL
    总是专门用于检索和审查表格形式的数据，但永远不会是可视化数据的适当工具——这项任务最好留给 Python 及其众多的可视化库，这些内容将是下一章的重点。
