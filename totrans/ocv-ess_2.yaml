- en: Chapter 2. Something We Look At – Graphical User Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 我们关注的对象 – 图形用户界面
- en: In this chapter, we will cover the main user interface capabilities included
    with the OpenCV library. We will start with the user interface functions included
    in the `highgui` module. Then, we will deal with the insertion of objects (such
    as text and geometrical shapes) on the displayed windows to point out some specific
    characteristics on images. Finally, the chapter addresses the new Qt functions
    included in OpenCV to enrich the user experience.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 OpenCV 库中包含的主要用户界面功能。我们将从 `highgui` 模块中包含的用户界面函数开始。然后，我们将处理在显示的窗口上插入对象（如文本和几何形状）以指出图像上的某些特定特征。最后，本章将介绍
    OpenCV 中包含的新 Qt 函数，以丰富用户体验。
- en: Using OpenCV's highgui module
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenCV 的 `highgui` 模块
- en: 'The `highgui` module has been designed to provide an easy way to visualize
    the results and try the functionality of developed applications with OpenCV. As
    we saw in the previous chapter, this module supplies functions to perform the
    following operations:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`highgui` 模块已被设计用来提供一个简单的方式来可视化结果并尝试使用 OpenCV 开发的应用的功能。正如我们在上一章中看到的，该模块提供了执行以下操作的功能：'
- en: Reading images and videos from files and live cameras (`imread`) through a `VideoCapture`
    object.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `VideoCapture` 对象从文件和实时摄像头读取图像和视频（`imread`）。
- en: Writing images and videos from memory to disk (`imwrite`) through a `VideoWriter`
    object.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `VideoWriter` 对象将图像和视频从内存写入磁盘（`imwrite`）。
- en: Creating a window that can display images and video frames (`namedWindow` and
    `imshow`).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可以显示图像和视频帧的窗口（`namedWindow` 和 `imshow`）。
- en: Fetching and handling events when a key is pressed (`waitKey`).
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当按键时获取和处理事件（`waitKey`）。
- en: 'Of course, the module contains more functions to enhance the user interaction
    with the software applications. Some of them will be explained in this chapter.
    In the following `tbContrast` code example, we can read an image file and two
    windows are created: the first one shows the original image and the other is the
    resulting image after increasing or decreasing the contrast to the original image
    applying a quite simple scaling operation. The following example shows how to
    create a trackbar in the window to easily change the contrast factor (scale) in
    the image. Let''s see the code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，该模块包含更多功能以增强用户与软件应用的交互。其中一些将在本章中解释。在下面的 `tbContrast` 代码示例中，我们可以读取一个图像文件，并创建了两个窗口：第一个显示原始图像，另一个显示在原始图像上应用了简单的缩放操作后增加或减少对比度的结果图像。下面的示例展示了如何在窗口中创建一个滑动条以轻松地更改图像的对比度因子（缩放）。让我们看看代码：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The following screenshot shows the original image (`fruits.jpg`) and the same
    image with increased contrast obtained with the `tbContrast` application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了原始图像（`fruits.jpg`）和通过 `tbContrast` 应用程序获得的对比度增加后的相同图像。
- en: '![Using OpenCV''s highgui module](img/00008.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![使用 OpenCV 的 `highgui` 模块](img/00008.jpeg)'
- en: Original image and the image with increased contrast
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 原始图像和对比度增加后的图像
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To avoid repetition in the examples, only the remarkable new portions of code
    are explained.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在示例中重复，只解释了代码中显著的新部分。
- en: 'The code explanation is given as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解释如下：
- en: '`void moveWindow(const string& winname, int x, int y)`: This function moves
    the window to the specified screen (x, y) position being the origin point (0,
    0) at the upper-left corner. When a window is created and displayed, its default
    position is at the center of the screen. That behavior is quite convenient if
    only one window is displayed. However, if several windows have to be shown, they
    are overlapped and should be moved in order to see their content. In the example,
    this function is used as follows:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void moveWindow(const string& winname, int x, int y)`: 此函数将窗口移动到指定的屏幕（x, y）位置，其中（0,
    0）是屏幕左上角的起始点。当创建并显示窗口时，其默认位置在屏幕中心。如果只显示一个窗口，这种行为相当方便。然而，如果需要显示多个窗口，它们将重叠，并且应该移动以查看其内容。在示例中，此函数的使用如下：'
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, the window that shows the original image is moved, after its creation,
    to the upper-left corner (origin) of the screen while the converted imaged is
    located at its default position (center of the screen).
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '现在，显示原始图像的窗口在创建后移动到屏幕的左上角（原点），而转换后的图像位于其默认位置（屏幕中心）。 '
- en: '`intcreateTrackbar(const string&trackbarname, const string&winname, int*value,
    intrange, TrackbarCallbackonChange=0, void*userdata=0)`: This function creates
    a **trackbar** (a slider) attached to the window with the specified name and range.
    The position of the slider is synchronized with the `value` variable. Moreover,
    it is possible to implement a **callback** function for being called after the
    slider moves. In this call, a pointer to the user data is passed as argument.
    In our code, this function is used as follows:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int createTrackbar(const string& trackbarname, const string& winname, int*
    value, int range, TrackbarCallbackonChange=0, void* userdata=0)`: 此函数创建一个与指定名称和范围关联的
    **滑块**（滑块）。滑块的位置与 `value` 变量同步。此外，可以实现一个在滑块移动后调用的 **回调** 函数。在此调用中，将用户数据指针作为参数传递。在我们的代码中，此函数的使用方式如下：'
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A callback is a function passed as an argument to another function. The callback
    function is passed as a pointer to the code, which is executed when an expected
    event occurs.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回调函数是将一个函数作为参数传递给另一个函数的函数。回调函数作为代码指针传递，当发生预期事件时执行。
- en: In this code, the trackbar is called `"Contrast"` without a callback function
    linked to it. Initially, the slider is located at the middle (50) of the full
    range (100). This range allows a maximum scale factor of 2.0 (100/50).
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码中，滑块被命名为 `"Contrast"`，但没有与它链接的回调函数。最初，滑块位于整个范围（100）的中间（50）。此范围允许最大缩放因子为
    2.0（100/50）。
- en: '`void Mat::convertTo(OutputArray m, int rtype, double alpha=1, double beta=0
    ) const`: This function converts an array to another data type with an optional
    scaling. If `rtype` is negative, the output matrix will have the same type as
    the input. The applied scaling applied formula is as follows:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void Mat::convertTo(OutputArray m, int rtype, double alpha=1, double beta=0
    ) const`: 此函数将数组转换为另一种数据类型，并可选地进行缩放。如果 `rtype` 为负，输出矩阵将与输入具有相同的类型。应用的缩放公式如下：'
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this code, a final implicit cast (`saturate_cast<>`) is applied to avoid
    possible overflows. In the `tbContrast` example, this function is used inside
    an infinite loop:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码中，应用了最终的隐式转换 (`saturate_cast<>`) 以避免可能的溢出。在 `tbContrast` 示例中，此函数在无限循环中使用：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous chapter, we saw code examples that can create an implicit infinite
    loop waiting for a pressed key with the function call `waitKey` (without arguments).
    The events on the application main window (for example, trackbars, mouse, and
    so on) are caught and handled inside of that loop. On the contrary, in this example,
    we create an infinite loop with a `while` statement applying the contrast change
    with the `convertTo` function with a scale factor from `0.0` (slider at `0`) to
    `2.0` (slider at `100`). The infinite loop breaks when the *Esc* key (ASCII code
    27) is pressed. The implemented contrast method is quite simple because the new
    values for the pixels are calculated by multiplying the original value by a factor
    greater than `1.0` to increase contrast and a factor smaller than `1.0` to decrease
    contrast. In this method, when a pixel value exceeds `255` (in any channel), a
    rounding (saturate cast) has to be done.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了使用 `waitKey` 函数（不带参数）创建隐式无限循环等待按键的代码示例。应用程序主窗口上的事件（例如，滑块、鼠标等）在该循环内部被捕获和处理。相反，在本例中，我们使用
    `while` 语句创建一个无限循环，通过 `convertTo` 函数应用对比度变化，缩放因子从 `0.0`（滑块在 `0` 位置）到 `2.0`（滑块在
    `100` 位置）。当按下 *Esc* 键（ASCII 码 27）时，无限循环终止。实现的对比度方法相当简单，因为像素的新值是通过将原始值乘以大于 `1.0`
    的因子来增加对比度，以及乘以小于 `1.0` 的因子来降低对比度。在此方法中，当像素值超过 `255`（任何通道）时，必须进行舍入（饱和转换）。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the next chapter, we will explain a more sophisticated algorithm to improve
    the image contrast using the image histogram equalization.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将解释一个更复杂的算法，用于通过图像直方图均衡化来提高图像对比度。
- en: 'Then, in the `tbContrastCallB` example, we show the same functionality, but
    using a `trackbarcallback` function that is called every time the slider is moved.
    Note that the events are handled when the `waitKey` function is called. The application
    ends if you press any key. The code is as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `tbContrastCallB` 示例中，我们展示了相同的功能，但使用了一个每次滑块移动时都会调用的 `trackbarcallback`
    函数。注意，当调用 `waitKey` 函数时处理事件。如果按下任何键，应用程序将结束。代码如下：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, a `void` pointer to the `updatedContrast` function is passed
    as argument to the `createTrackbar` function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，将 `updatedContrast` 函数的 `void` 指针作为参数传递给 `createTrackbar` 函数：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The callback function gets as its first argument the value of the slider in
    the trackbar and a `void` pointer to other user data. The new pixels values for
    the image will be calculated in this function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数接收的第一个参数是轨迹条中滑块的值以及指向其他用户数据的`void`指针。图像的新像素值将在该函数中计算。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example (and subsequent ones), some portions of code are not shown for
    brevity because the omitted code is the same as that in previous examples.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例（以及随后的示例）中，为了简洁，省略了一些代码，因为省略的代码与之前的示例中的代码相同。
- en: 'Using a callback function cause a few changes in this new code because the
    accessible data inside this function has to be defined with global scope. Then,
    more complexity is avoided on the datatypes passed to the callback function as
    follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调函数导致在这段新代码中产生了一些变化，因为此函数内部可访问的数据必须使用全局作用域来定义。然后，为了避免向回调函数传递的数据类型更加复杂，如下所示：
- en: Windows names are defined symbols (for example, `#define IN_WIN`). In the previous
    example (`tbContrast`), the window names are stored in local variables (strings).
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口名称是定义的符号（例如，`#define IN_WIN`）。在之前的示例（`tbContrast`）中，窗口名称存储在局部变量（字符串）中。
- en: In this case, the `Mat` variables for the original (`in_img`) and converted
    (`out_img`) images are declared as global variables.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，原始图像（`in_img`）和转换图像（`out_img`）的`Mat`变量被声明为全局变量。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Sometimes in this book, the sample code uses global variables for simplicity.
    Be extremely cautious with global variables since they can be changed anywhere
    in the code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在这本书的示例代码中，为了简化，使用了全局变量。由于它们可以在代码的任何地方被更改，因此请务必小心使用全局变量。
- en: The two different implementations shown in the previous example produce the
    same results. However, it should be noted that after using a callback function,
    the resulting application (`tbContrastCallB`) is more efficient because the math
    operations for the image conversion only take place at the change of the trackbar
    slide (when the callback is executed). In the first version (`tbContrast`), the
    `convertTo` function is called inside the `while` loop even if the `TBvalContrast`
    variable doesn't change.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中展示的两个不同实现产生了相同的结果。然而，需要注意的是，在使用回调函数之后，生成的应用程序（`tbContrastCallB`）更加高效，因为图像转换的数学运算仅在轨迹条的滑动变化（当回调被执行时）发生。在第一个版本（`tbContrast`）中，即使`TBvalContrast`变量没有变化，`convertTo`函数也会在`while`循环内部被调用。
- en: Text and drawing
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本和绘图
- en: In the previous section, we used a simple user interface to get input values
    by a trackbar. However, in many applications, the user has to point locations
    and regions on the image and mark them with text labels. For this purpose, the
    `highgui` module provides a set of drawing functions along with mouse event handling.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用一个简单的用户界面通过轨迹条获取输入值。然而，在许多应用中，用户必须指向图像上的位置和区域，并用文本标签进行标记。为此目的，`highgui`模块提供了一套绘图函数以及鼠标事件处理。
- en: The `drawThings` code example shows an easy application to mark positions on
    an input image. The positions are marked with a red circle and a black text label
    next to it. The following screenshot displays the window with the input image
    and the marked positions on it. To mark each position on the image, the user uses
    has to click the left mouse button over it. In other application, the marked position
    could be the obtained points or regions from an algorithm applied to the input
    image.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawThings`代码示例展示了如何轻松地在输入图像上标记位置。位置用红色圆圈和旁边的黑色文本标签标记。以下截图显示了包含输入图像及其上标记位置的窗口。为了标记图像上的每个位置，用户必须在其上点击鼠标左键。在其他应用中，标记的位置可能是从应用于输入图像的算法中获得的点或区域。'
- en: 'Next, we show the example code where some pieces of code have been omitted
    for simplicity, since they are duplicated in other previous examples:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们展示一个示例代码，其中为了简化，省略了一些代码，因为它们在其他之前的示例中是重复的：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code explanation is given as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解释如下：
- en: '`void setMouseCallback(const string& winname, MouseCallback onMouse, void*
    userdata=0)`: This function sets an event mouse handler for the specified window.
    In this function, the second argument is the callback function executed whenever
    a mouse event occurs. The final argument is a `void` pointer to the data passed
    as argument to that function. In our code, this function is used as follows:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void setMouseCallback(const string& winname, MouseCallback onMouse, void*
    userdata=0)`: 此函数为指定的窗口设置事件鼠标处理程序。在此函数中，第二个参数是每当鼠标事件发生时执行的回调函数。最后一个参数是传递给该函数的`void`指针数据。在我们的代码中，此函数的使用方式如下：'
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, rather than use a global variable for the name of the window,
    a defined symbol with global scope has been preferred (`IN_WIN`).
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，而不是使用全局变量来表示窗口名称，更倾向于使用具有全局作用域的已定义符号（`IN_WIN`）。
- en: '![Text and drawing](img/00009.jpeg)'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![文本和绘图](img/00009.jpeg)'
- en: Image with circles and text on it
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 带有圆和文本的图像
- en: 'The mouse handler itself is declared as follows:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 鼠标处理程序本身声明如下：
- en: '[PRE9]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, `event` indicates the mouse event type, `x` and `y` are the coordinates
    for the location of the event at the window, and `flags` is the specific condition
    whenever an event occurs. In this example, the unique captured mouse event is
    the left mouse click (`EVENT_LBUTTONDOWN`).
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`event`表示鼠标事件类型，`x`和`y`是事件在窗口中的位置坐标，而`flags`是事件发生时的特定条件。在这个例子中，唯一捕获的鼠标事件是左键点击（`EVENT_LBUTTONDOWN`）。
- en: 'The following enumerations define the events and flags handled in the mouse
    callback functions:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下枚举定义了鼠标回调函数中处理的事件和标志：
- en: '[PRE10]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`void circle(Mat& img, Point center, int radius, const Scalar& color, int thickness=1,
    int lineType=8, int shift=0)`: This function draws a circle over the image with
    the specified `radius` (in pixels) and `color` at the position marked by its `center`.
    Moreover, a `thickness` value for the line and other additional parameters can
    be set. The usage of this function in the example is as follows:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void circle(Mat& img, Point center, int radius, const Scalar& color, int thickness=1,
    int lineType=8, int shift=0)`: 这个函数在图像上以指定的`radius`（以像素为单位）和`color`在由其`center`标记的位置绘制一个圆。此外，还可以设置线的`thickness`值和其他一些附加参数。该函数在示例中的使用方法如下：'
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The center of the circle is the point where the mouse is clicked. The radius
    has `4` pixels and the color is pure red (`Scalar(0, 0, 255)`) with a line thickness
    of `2` pixels.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 圆的中心是鼠标点击的点。半径为`4`像素，颜色为纯红色（`Scalar(0, 0, 255)`），线粗细为`2`像素。
- en: Note
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that OpenCV uses a BGR color scheme and the `Scalar` class is used
    to represent the three (or four if opacity channel is considered) channels of
    each pixel with greater values for a brighter one (or more opaque).
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，OpenCV使用BGR颜色方案，`Scalar`类用于表示每个像素的三个（或四个，如果考虑不透明通道）通道，亮度更高的值（或不透明度更高）。
- en: Other drawing functions included in the `highgui` module allow us to draw ellipses,
    lines, rectangles, and polygons.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包含在`highgui`模块中的其他绘图函数允许我们绘制椭圆、线条、矩形和多边形。
- en: '`void putText(Mat& image, const string& text, Point org, int fontFace, double
    fontScale, Scalar color, int thickness=1, int lineType=8, bool bottomLeftOrigin=false)`:
    This function draws a `text` string in the `image` at the specified position (`org`)
    with the properties set by the arguments `fontFace`, `fontScale`, `color`, `thickness`,
    and `lineType`. It is possible to set the coordinates origin at the bottom-left
    corner with the last argument (`bottomLeftOrigin`). In the example, this function
    is used as follows:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void putText(Mat& image, const string& text, Point org, int fontFace, double
    fontScale, Scalar color, int thickness=1, int lineType=8, bool bottomLeftOrigin=false)`:
    这个函数在`image`中指定位置（`org`）绘制一个`text`字符串，其属性由参数`fontFace`、`fontScale`、`color`、`thickness`和`lineType`设置。可以通过最后一个参数（`bottomLeftOrigin`）设置坐标原点在左下角。在示例中，此函数的使用方法如下：'
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `drawThings` example, we draw a text `"mark"` followed by an increasing
    number that points out the mark order. To store the mark order, we used a `static`
    variable (`imark`) that maintains its value between the calls. The `putText` function
    draws the text at the location where the mouse click occurs with a 6-pixels shift
    on *x* axis. The font face is specified by the flag `FONT_HERSHEY_PLAIN` and is
    drawn without scale (`1.0`), black color (`Scalar(0, 0, 0)`), and `2` pixels thickness.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`drawThings`示例中，我们绘制了一个文本`"mark"`，后面跟着一个递增的数字，指出了标记的顺序。为了存储标记顺序，我们使用了一个`static`变量（`imark`），它在调用之间保持其值。`putText`函数在鼠标点击的位置绘制文本，在*x*轴上有6像素的偏移。字体样式由标志`FONT_HERSHEY_PLAIN`指定，并且没有缩放（`1.0`），黑色（`Scalar(0,
    0, 0)`）和`2`像素的粗细。
- en: 'The available flags for the font face are defined by the enumeration:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 字体样式的可用标志由枚举定义：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Selecting regions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择区域
- en: Many computer vision applications require to focus interest inside local regions
    of the images. In that case, it is a very useful user tool to select the desired
    **regions of interest** (**ROI**). In the `drawRs` example, we show how to select,
    with the mouse, rectangular regions in the image to locally increase the contrast
    inside these regions (as shown in the following screenshot). For better control
    over region selection, we implement a click-and-drag behavior to reshape the rectangular
    boundary of each region.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机视觉应用需要在图像的局部区域内聚焦兴趣。在这种情况下，选择所需**感兴趣区域**（**ROI**）是一个非常有用的用户工具。在`drawRs`示例中，我们展示了如何使用鼠标选择图像中的矩形区域，以在这些区域内局部增加对比度（如下面的截图所示）。为了更好地控制区域选择，我们实现了一个点击并拖拽的行为来调整每个区域的矩形边界。
- en: '![Selecting regions](img/00010.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![选择区域](img/00010.jpeg)'
- en: Output image with increased contrast in some rectangular regions
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些矩形区域内对比度增加的输出图像
- en: 'For the sake of simplicity, only the code corresponding to the function callback
    for mouse events is shown, since the rest is quite similar in the previous examples.
    The code is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，只显示了对应于鼠标事件函数回调的代码，因为其余部分与前面的示例非常相似。代码如下：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The callback function declares `static` its local variables, so they maintain
    their values between calls. The variables, `p1` and `p2`, store the points for
    defining the rectangular region of interest, and `p2set` holds the Boolean (`bool`)
    value that indicates if point `p2` is set. When `p2set` is `true`, a new selected
    region can be drawn and its new values computed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数声明其局部变量为`static`，因此它们在调用之间保持其值。变量`p1`和`p2`存储定义感兴趣矩形区域的点，而`p2set`保存一个布尔（`bool`）值，表示点`p2`是否已设置。当`p2set`为`true`时，可以绘制一个新的选定区域并计算其新值。
- en: 'The mouse callback function handles the following events:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标回调函数处理以下事件：
- en: '`EVENT_LBUTTONDOWN`: This button is also called left button down. The initial
    position (`p1`) is set to `Point(x, y)` where the event occurs. Also, the `p2set`
    variable is set to `false`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EVENT_LBUTTONDOWN`：此按钮也称为左键按下。初始位置（`p1`）被设置为事件发生的位置`Point(x, y)`。此外，将`p2set`变量设置为`false`。'
- en: '`EVENT_MOUSEMOVE && EVENT_FLAG_LBUTTON`: Move the mouse with the left button
    down. First, the boundaries should be checked so that we can correct coordinates
    and avoid errors just in case the final point is out of the window. Then, the
    temporal `p2` point is set to the final position of the mouse and `p2set` is set
    to `true`. Finally, a temporal image is shown in the window with the rectangle
    drawn on it.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EVENT_MOUSEMOVE && EVENT_FLAG_LBUTTON`：按住左键移动鼠标。首先，应该检查边界，以便我们可以纠正坐标并避免错误，以防最终点超出窗口。然后，临时`p2`点被设置为鼠标的最终位置，并将`p2set`设置为`true`。最后，在窗口中显示一个带有矩形的时间图像。'
- en: '`EVENT_LBUTTONUP`: This button is also called left button up and is valid only
    if `p2set` is `true`.The final region is selected. Then a subarray can be pointed
    in the original image for further computation. After that, a rectangle around
    the final region is drawn in the original image and the result is shown into the
    application window.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EVENT_LBUTTONUP`：此按钮也称为左键释放，并且仅在`p2set`为`true`时有效。最终区域被选定。然后可以在原始图像中指向子数组进行进一步计算。之后，在原始图像中绘制围绕最终区域的矩形，并将结果显示在应用程序窗口中。'
- en: 'Next, we take a closer look at the code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更仔细地查看代码：
- en: '`Size Mat::size() const:` Returns the matrix size `(Size(cols, rows))`: This
    function is used to get the bounds of the image (`orig_img`) as follows:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Size Mat::size() const:` 返回矩阵大小 `(Size(cols, rows))`：此函数用于获取图像（`orig_img`）的边界，如下所示：'
- en: '[PRE15]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since `Mat::size()` returns a `Size` object, we can access its members `width`
    and `height` to obtain the greatest values for `x` and `y` in the image (`orig_img`)
    and compare those with the coordinates where the mouse event take place.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于`Mat::size()`返回一个`Size`对象，我们可以访问其成员`width`和`height`以获取图像（`orig_img`）中`x`和`y`的最大值，并将这些值与鼠标事件发生的坐标进行比较。
- en: '`void Mat::copyTo(OutputArray m) const`: This method copies the matrix to another
    one, reallocating new size and type if it is needed. Before copying, the following
    method invokes:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void Mat::copyTo(OutputArray m) const`：此方法将矩阵复制到另一个矩阵中，如果需要则重新分配新的大小和类型。在复制之前，以下方法被调用：'
- en: '[PRE16]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the example, the following method is employed to make a temporal copy of
    the original image:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在示例中，采用以下方法来创建原始图像的时间副本：
- en: '[PRE17]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The rectangle that defines the selected region is drawn over this temporal image.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义选定区域的矩形被绘制在这个临时图像上。
- en: '`void rectangle(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness=1,
    int lineType=8, int shift=0)`: This function draws a rectangle defined by points
    `pt1` and `pt2` over the image (`img`) with the specified `color`, `thickness`,
    and `lineType`. In the code example, this function is used twice. First, to draw
    a red (`Scalar(0, 0, 255)`) rectangle on the temporal image (`tmp_img`) around
    the selected area, and then to draw the boundaries of the final selected region
    in the original image (`orig_img`):'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void rectangle(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness=1,
    int lineType=8, int shift=0)`: 此函数使用指定的 `color`、`thickness` 和 `lineType` 在图像 (`img`)
    上绘制由点 `pt1` 和 `pt2` 定义的矩形。在代码示例中，此函数被调用了两次。首先，在临时图像 (`tmp_img`) 中绘制一个红色（`Scalar(0,
    0, 255)`）的矩形，围绕选定的区域，然后绘制原始图像 (`orig_img`) 中最终选定区域的边界：'
- en: '[PRE18]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`Mat::Mat(const Mat& m, const Rect& roi)`: The constructor takes a submatrix
    of `m` limited by the rectangle (`roi`) that represents a region of interest in
    the image stored in `m`. This constructor is applied, in the code example, to
    get the rectangular region whose contrast has to be converted:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mat::Mat(const Mat& m, const Rect& roi)`: 构造函数接受由矩形 (`roi`) 限定的 `m` 的子矩阵，该矩形代表存储在
    `m` 中的图像中的感兴趣区域。在代码示例中，此构造函数用于获取需要转换对比度的矩形区域：'
- en: '[PRE19]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using Qt-based functions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于 Qt 的函数
- en: While `highgui` will be sufficient for most purposes, the Qt UI framework (available
    at [http://qt-project.org/](http://qt-project.org/)) can be leveraged in OpenCV
    to develop richer user interfaces. A number of OpenCV's user interface functions
    use the Qt library behind the scenes. In order to use these functions, OpenCV
    must have been compiled with the `WITH_QT` option.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `highgui` 对于大多数用途来说已经足够，但 Qt UI 框架（可在 [http://qt-project.org/](http://qt-project.org/)
    找到）可以用于 OpenCV 中开发更丰富的用户界面。OpenCV 的许多用户界面函数在幕后使用 Qt 库。为了使用这些函数，OpenCV 必须使用 `WITH_QT`
    选项编译。
- en: Note that Qt is a class and **widget** library that allows the creation of full-fledged
    applications with rich, event-driven user interfaces. In this section, however,
    we will mainly focus on specific Qt-based functions within OpenCV. Programming
    with Qt is out of the scope of this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Qt 是一个类和 **小部件** 库，它允许创建具有丰富、事件驱动用户界面的完整应用程序。然而，在本节中，我们将主要关注 OpenCV 中的特定
    Qt 基于函数。使用 Qt 进行编程超出了本书的范围。
- en: With Qt support on, windows created with the `namedWindow` function will automatically
    look like what is shown in the following screenshot. There is a toolbar with useful
    functions such as pan, zoom, and save image. Windows also display a status bar
    at the bottom with the current mouse location and RGB value under that pixel.
    Right-clicking on the image will display a pop-up menu with the same toolbar options.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用 Qt 支持的情况下，使用 `namedWindow` 函数创建的窗口将自动看起来像以下截图所示。有一个带有平移、缩放和保存图像等有用功能的工具栏。窗口还显示底部状态栏，显示当前鼠标位置和该像素下的
    RGB 值。在图像上右键单击将显示一个弹出菜单，其中包含与工具栏相同的选项。
- en: '![Using Qt-based functions](img/00011.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![使用基于 Qt 的函数](img/00011.jpeg)'
- en: Window displayed with Qt support enabled
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 Qt 支持显示的窗口
- en: Text overlays and status bar
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本叠加和状态栏
- en: Text can be displayed on a line across the top of the image. This is very useful
    to show frames per second, number of detections, filenames, and so on. The main
    function is `displayOverlay(const string& winname, const string& text, int delayms=0)`.
    The function expects a window identifier and the text to display. Multiple lines
    are allowed by using the `\n` character in the text string. The text will be displayed
    in the center and has a fixed size. The `delayms` parameter allows to display
    the text only for a specified amount of milliseconds (`0=forever`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 文本可以显示在图像顶部的行上。这非常有用，可以显示每秒帧数、检测数量、文件名等。主要函数是 `displayOverlay(const string&
    winname, const string& text, int delayms=0)`。该函数期望一个窗口标识符和要显示的文本。通过在文本字符串中使用 `\n`
    字符允许多行。文本将在中心显示，并且具有固定大小。`delayms` 参数允许文本仅显示指定数量的毫秒（`0=永远`）。
- en: We can also display user text in the status bar. This text will replace the
    default *x* and *y* coordinates and RGB value under the current pixel. The `displayStatusBar(const
    string& winname, const string& text, int delayms=0)` function has the same parameters
    as the previous `displayOverlay` function. When the delay has passed, the default
    status bar text will be displayed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在状态栏中显示用户文本。此文本将替换当前像素下的默认 *x* 和 *y* 坐标以及 RGB 值。`displayStatusBar(const
    string& winname, const string& text, int delayms=0)` 函数与之前的 `displayOverlay` 函数具有相同的参数。当延迟时间过去后，将显示默认的状态栏文本。
- en: The properties dialog
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性对话框
- en: One of the most useful features of OpenCV's Qt-based functions is the properties
    dialog window. This window can be used to place trackbars and buttons. Again,
    this comes in handy while tuning parameters for our application. The properties
    dialog window can be accessed by pressing the last button in the toolbar (as shown
    in the preceding screenshot) or by pressing *Ctrl* + *P*. The window will only
    be accessible if trackbars or button have been assigned to it. To create a trackbar
    for the properties dialog, simply use the `createTrackbar` function passing an
    empty string (not `NULL`) as the window name.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV基于Qt的功能中最有用的特性之一是属性对话框窗口。此窗口可以用来放置滑块条和按钮。同样，这在调整我们应用程序的参数时非常有用。可以通过按工具栏中的最后一个按钮（如图所示）或按*Ctrl*
    + *P*来访问属性对话框窗口。窗口只有在分配了滑块条或按钮后才会可用。要为属性对话框创建滑块条，只需使用`createTrackbar`函数，并将空字符串（不是`NULL`）作为窗口名称传递。
- en: 'Buttons can also be added to the properties dialog. Since both the original
    window and the dialog windows can be visible at the same time, this can be useful
    to activate/deactivate features in our application and see the results immediately.
    To add buttons to the dialog, use the `createButton(const string& button_name,
    ButtonCallback on_change, void* userdata=NULL,inttype=CV_PUSH_BUTTON, bool initial_button_state=0)`
    function. The first parameter is the button label (that is, the text to be displayed
    in the button). Every time the button changes its state, the `on_change` callback
    function will be called. This should be in the form `void on_change(intstate,
    void *userdata)`. The userdata pointer passed to `createButton` will be passed
    to this callback function every time it is called. The state parameter signals
    the button change and it will have a different value for each type of button,
    given by parameter types:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以将按钮添加到属性对话框中。由于原始窗口和对话框窗口可以同时可见，这可以用来激活/停用我们应用程序中的功能并立即看到结果。要向对话框添加按钮，请使用`createButton(const
    string& button_name, ButtonCallback on_change, void* userdata=NULL,inttype=CV_PUSH_BUTTON,
    bool initial_button_state=0)`函数。第一个参数是按钮标签（即按钮中要显示的文本）。每次按钮改变其状态时，`on_change`回调函数都会被调用。这应该采用`void
    on_change(int state, void *userdata)`的形式。传递给`createButton`的用户数据指针将在每次调用时传递给此回调函数。状态参数表示按钮变化，并且对于每种类型的按钮，它将具有由参数类型给出的不同值：
- en: '`CV_PUSH_BUTTON`: Push button'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_PUSH_BUTTON`: 推压按钮'
- en: '`CV_CHECKBOX`: Checkbox button; the state will be either 1 or 0'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_CHECKBOX`: 复选框按钮；状态将为1或0'
- en: '`CV_RADIOBOX`: Radiobox button; the state will be either 1 or 0'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_RADIOBOX`: 单选框按钮；状态将为1或0'
- en: For the first two types, the callback is called once on each press. For the
    radiobox button, it is called both for the button just clicked and for the button
    that goes unclicked.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前两种类型，每次按下都会调用一次回调。对于单选框按钮，它既会调用刚刚点击的按钮，也会调用未取消的按钮。
- en: 'Buttons are organized into button bars. Button bars occupy one row in the dialog
    window. Each new button is added to the right of the last one. Trackbars take
    up an entire row, so button bars are terminated when a trackbar is added. The
    following `propertyDlgButtons` example shows how buttons and trackbars are laid
    out in the properties dialog:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮被组织到按钮栏中。按钮栏占据对话框窗口中的一行。每个新的按钮都添加到上一个按钮的右侧。滑块条占据整整一行，因此当添加滑块条时，按钮栏会结束。以下`propertyDlgButtons`示例显示了按钮和滑块条在属性对话框中的布局：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code is similar to the `flipImage` example in the previous chapter. In
    this example, an image filename is passed as an argument. A properties window
    is created with two buttons for vertical and horizontal flipping, a dummy trackbar,
    and a checkbox button to invert color intensities. The callback functions `on_flipV`
    and `on_flipH` simply flip the current image and show the result (we use a global
    image variable for this), while the callback function `on_negative` logically
    inverts color intensities and shows the result. Note that the trackbar is not
    really being used; it is used to show the **line feed** effect. The following
    screenshot shows the result:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码与上一章中的`flipImage`示例类似。在此示例中，将图像文件名作为参数传递。创建一个属性窗口，包含两个按钮用于垂直和水平翻转，一个模拟的滑块条，以及一个复选框按钮用于反转颜色强度。回调函数`on_flipV`和`on_flipH`简单地翻转当前图像并显示结果（我们使用一个全局图像变量来完成此操作），而回调函数`on_negative`逻辑上反转颜色强度并显示结果。请注意，滑块条实际上并没有真正被使用；它被用来显示**换行符**效果。以下截图显示了结果：
- en: '![The properties dialog](img/00012.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![属性对话框](img/00012.jpeg)'
- en: The propertyDlgButtons example
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`propertyDlgButtons`示例'
- en: Windows properties
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窗口属性
- en: 'As mentioned previously, by default, all new windows will look like what''s
    shown in the screenshot in the *Using Qt-based functions* section. Still, we can
    display windows in the non-Qt format by passing the `CV_GUI_NORMAL` option to
    `namedWindow`. On the other hand, window size parameters can be retrieved and
    set using the `double getWindowProperty(const string& winname, int prop_id)` and
    `setWindowProperty (const string& winname, int prop_id,double prop_value)` functions.
    The following table shows the properties that can be changed:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，默认情况下，所有新窗口将类似于*使用基于Qt的函数*部分中的截图所示。然而，我们可以通过将`CV_GUI_NORMAL`选项传递给`namedWindow`来以非Qt格式显示窗口。另一方面，可以使用`double
    getWindowProperty(const string& winname, int prop_id)`和`setWindowProperty(const
    string& winname, int prop_id, double prop_value)`函数检索和设置窗口大小参数。以下表格显示了可以更改的属性：
- en: '| Property (`prop_id`) | Description | Possible values |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 属性（`prop_id`） | 描述 | 可能的值 |'
- en: '| --- | --- | --- |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `CV_WND_PROP_FULLSCREEN` | Displays a fullscreen or regular window | `CV_WINDOW_NORMAL`
    or `CV_WINDOW_FULLSCREEN` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `CV_WND_PROP_FULLSCREEN` | 显示全屏或常规窗口 | `CV_WINDOW_NORMAL`或`CV_WINDOW_FULLSCREEN`
    |'
- en: '| `CV_WND_PROP_AUTOSIZE` | Window automatically resizes to fit the displayed
    image | `CV_WINDOW_NORMAL` or `CV_WINDOW_AUTOSIZE` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `CV_WND_PROP_AUTOSIZE` | 窗口自动调整大小以适应显示的图像 | `CV_WINDOW_NORMAL`或`CV_WINDOW_AUTOSIZE`
    |'
- en: '| `CV_WND_PROP_ASPECTRATIO` | Allows resized windows to have any ratio or fixed
    original ratio | `CV_WINDOW_FREERATIO` or `CV_WINDOW_KEEPRATIO` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `CV_WND_PROP_ASPECTRATIO` | 允许调整大小的窗口具有任何比例或固定原始比例 | `CV_WINDOW_FREERATIO`或`CV_WINDOW_KEEPRATIO`
    |'
- en: More importantly, window properties can be saved. This includes not only size
    and location, but also flags, trackbar values, zoom, and panning location. To
    save and load window properties, use the `saveWindowParameters(const string& windowName)`
    and `loadWindowParameters(const string& windowName)` functions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，可以保存窗口属性。这包括不仅大小和位置，还包括标志、滑块值、缩放和滚动位置。要保存和加载窗口属性，请使用`saveWindowParameters(const
    string& windowName)`和`loadWindowParameters(const string& windowName)`函数。
- en: Qt images
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt图像
- en: 'If we want to use the Qt libraries extensively in our project (that is, beyond
    OpenCV''s Qt-based functions), we have to find a way to convert OpenCV''s images
    to the format used by Qt (`QImage`). This can be done by using the following function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在项目中广泛使用Qt库（即，超出OpenCV的基于Qt的函数），我们必须找到一种方法将OpenCV的图像转换为Qt使用的格式（`QImage`）。这可以通过以下函数完成：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This function creates a Qt image using OpenCV's image data. Note that a conversion
    is first necessary, since Qt uses RGB images while OpenCV uses BGR order.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用OpenCV的图像数据创建Qt图像。请注意，首先需要进行转换，因为Qt使用RGB图像，而OpenCV使用BGR顺序。
- en: 'Finally, to display the image with Qt, we have at least two options:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使用Qt显示图像，我们至少有两种选择：
- en: Create a class that extends the `QWidget` class and implements paint events.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个扩展`QWidget`类并实现绘制事件的类。
- en: Create a label and set it to draw an image (using the `setPixMap` method).
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个标签并设置它来绘制一个图像（使用`setPixMap`方法）。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we provided a deeper view of the `highgui` module functionality
    to enrich the user experience. The main elements supplied by OpenCV to build graphical
    user interfaces are shown in some code samples. Moreover, we reviewed the new
    Qt functionality inside OpenCV.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提供了对`highgui`模块功能的更深入的了解，以丰富用户体验。OpenCV用于构建图形用户界面的主要元素在以下代码示例中展示。此外，我们还回顾了OpenCV内部的新Qt功能。
- en: The chapter's examples cover topics such as `tbarContrast`, `tbarContrastCallB`,
    `drawThings`, `drawRs`, and `propertyDlgButtons`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例涵盖了诸如`tbarContrast`、`tbarContrastCallB`、`drawThings`、`drawRs`和`propertyDlgButtons`等主题。
- en: The next chapter will cover the implementation of the most usual methods used
    for image processing, such as brightness control, contrast and color conversion,
    retina filtering, and geometrical transformations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍用于图像处理的常用方法的实现，例如亮度控制、对比度和颜色转换、视网膜过滤和几何变换。
