- en: Chapter 2. Something We Look At – Graphical User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover the main user interface capabilities included
    with the OpenCV library. We will start with the user interface functions included
    in the `highgui` module. Then, we will deal with the insertion of objects (such
    as text and geometrical shapes) on the displayed windows to point out some specific
    characteristics on images. Finally, the chapter addresses the new Qt functions
    included in OpenCV to enrich the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Using OpenCV's highgui module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `highgui` module has been designed to provide an easy way to visualize
    the results and try the functionality of developed applications with OpenCV. As
    we saw in the previous chapter, this module supplies functions to perform the
    following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading images and videos from files and live cameras (`imread`) through a `VideoCapture`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing images and videos from memory to disk (`imwrite`) through a `VideoWriter`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a window that can display images and video frames (`namedWindow` and
    `imshow`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching and handling events when a key is pressed (`waitKey`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, the module contains more functions to enhance the user interaction
    with the software applications. Some of them will be explained in this chapter.
    In the following `tbContrast` code example, we can read an image file and two
    windows are created: the first one shows the original image and the other is the
    resulting image after increasing or decreasing the contrast to the original image
    applying a quite simple scaling operation. The following example shows how to
    create a trackbar in the window to easily change the contrast factor (scale) in
    the image. Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshot shows the original image (`fruits.jpg`) and the same
    image with increased contrast obtained with the `tbContrast` application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using OpenCV''s highgui module](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Original image and the image with increased contrast
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid repetition in the examples, only the remarkable new portions of code
    are explained.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code explanation is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void moveWindow(const string& winname, int x, int y)`: This function moves
    the window to the specified screen (x, y) position being the origin point (0,
    0) at the upper-left corner. When a window is created and displayed, its default
    position is at the center of the screen. That behavior is quite convenient if
    only one window is displayed. However, if several windows have to be shown, they
    are overlapped and should be moved in order to see their content. In the example,
    this function is used as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the window that shows the original image is moved, after its creation,
    to the upper-left corner (origin) of the screen while the converted imaged is
    located at its default position (center of the screen).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`intcreateTrackbar(const string&trackbarname, const string&winname, int*value,
    intrange, TrackbarCallbackonChange=0, void*userdata=0)`: This function creates
    a **trackbar** (a slider) attached to the window with the specified name and range.
    The position of the slider is synchronized with the `value` variable. Moreover,
    it is possible to implement a **callback** function for being called after the
    slider moves. In this call, a pointer to the user data is passed as argument.
    In our code, this function is used as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: A callback is a function passed as an argument to another function. The callback
    function is passed as a pointer to the code, which is executed when an expected
    event occurs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this code, the trackbar is called `"Contrast"` without a callback function
    linked to it. Initially, the slider is located at the middle (50) of the full
    range (100). This range allows a maximum scale factor of 2.0 (100/50).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`void Mat::convertTo(OutputArray m, int rtype, double alpha=1, double beta=0
    ) const`: This function converts an array to another data type with an optional
    scaling. If `rtype` is negative, the output matrix will have the same type as
    the input. The applied scaling applied formula is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this code, a final implicit cast (`saturate_cast<>`) is applied to avoid
    possible overflows. In the `tbContrast` example, this function is used inside
    an infinite loop:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the previous chapter, we saw code examples that can create an implicit infinite
    loop waiting for a pressed key with the function call `waitKey` (without arguments).
    The events on the application main window (for example, trackbars, mouse, and
    so on) are caught and handled inside of that loop. On the contrary, in this example,
    we create an infinite loop with a `while` statement applying the contrast change
    with the `convertTo` function with a scale factor from `0.0` (slider at `0`) to
    `2.0` (slider at `100`). The infinite loop breaks when the *Esc* key (ASCII code
    27) is pressed. The implemented contrast method is quite simple because the new
    values for the pixels are calculated by multiplying the original value by a factor
    greater than `1.0` to increase contrast and a factor smaller than `1.0` to decrease
    contrast. In this method, when a pixel value exceeds `255` (in any channel), a
    rounding (saturate cast) has to be done.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next chapter, we will explain a more sophisticated algorithm to improve
    the image contrast using the image histogram equalization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `tbContrastCallB` example, we show the same functionality, but
    using a `trackbarcallback` function that is called every time the slider is moved.
    Note that the events are handled when the `waitKey` function is called. The application
    ends if you press any key. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, a `void` pointer to the `updatedContrast` function is passed
    as argument to the `createTrackbar` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The callback function gets as its first argument the value of the slider in
    the trackbar and a `void` pointer to other user data. The new pixels values for
    the image will be calculated in this function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example (and subsequent ones), some portions of code are not shown for
    brevity because the omitted code is the same as that in previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a callback function cause a few changes in this new code because the
    accessible data inside this function has to be defined with global scope. Then,
    more complexity is avoided on the datatypes passed to the callback function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows names are defined symbols (for example, `#define IN_WIN`). In the previous
    example (`tbContrast`), the window names are stored in local variables (strings).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, the `Mat` variables for the original (`in_img`) and converted
    (`out_img`) images are declared as global variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes in this book, the sample code uses global variables for simplicity.
    Be extremely cautious with global variables since they can be changed anywhere
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: The two different implementations shown in the previous example produce the
    same results. However, it should be noted that after using a callback function,
    the resulting application (`tbContrastCallB`) is more efficient because the math
    operations for the image conversion only take place at the change of the trackbar
    slide (when the callback is executed). In the first version (`tbContrast`), the
    `convertTo` function is called inside the `while` loop even if the `TBvalContrast`
    variable doesn't change.
  prefs: []
  type: TYPE_NORMAL
- en: Text and drawing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we used a simple user interface to get input values
    by a trackbar. However, in many applications, the user has to point locations
    and regions on the image and mark them with text labels. For this purpose, the
    `highgui` module provides a set of drawing functions along with mouse event handling.
  prefs: []
  type: TYPE_NORMAL
- en: The `drawThings` code example shows an easy application to mark positions on
    an input image. The positions are marked with a red circle and a black text label
    next to it. The following screenshot displays the window with the input image
    and the marked positions on it. To mark each position on the image, the user uses
    has to click the left mouse button over it. In other application, the marked position
    could be the obtained points or regions from an algorithm applied to the input
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we show the example code where some pieces of code have been omitted
    for simplicity, since they are duplicated in other previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code explanation is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void setMouseCallback(const string& winname, MouseCallback onMouse, void*
    userdata=0)`: This function sets an event mouse handler for the specified window.
    In this function, the second argument is the callback function executed whenever
    a mouse event occurs. The final argument is a `void` pointer to the data passed
    as argument to that function. In our code, this function is used as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, rather than use a global variable for the name of the window,
    a defined symbol with global scope has been preferred (`IN_WIN`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Text and drawing](img/00009.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Image with circles and text on it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The mouse handler itself is declared as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `event` indicates the mouse event type, `x` and `y` are the coordinates
    for the location of the event at the window, and `flags` is the specific condition
    whenever an event occurs. In this example, the unique captured mouse event is
    the left mouse click (`EVENT_LBUTTONDOWN`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following enumerations define the events and flags handled in the mouse
    callback functions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`void circle(Mat& img, Point center, int radius, const Scalar& color, int thickness=1,
    int lineType=8, int shift=0)`: This function draws a circle over the image with
    the specified `radius` (in pixels) and `color` at the position marked by its `center`.
    Moreover, a `thickness` value for the line and other additional parameters can
    be set. The usage of this function in the example is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The center of the circle is the point where the mouse is clicked. The radius
    has `4` pixels and the color is pure red (`Scalar(0, 0, 255)`) with a line thickness
    of `2` pixels.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that OpenCV uses a BGR color scheme and the `Scalar` class is used
    to represent the three (or four if opacity channel is considered) channels of
    each pixel with greater values for a brighter one (or more opaque).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Other drawing functions included in the `highgui` module allow us to draw ellipses,
    lines, rectangles, and polygons.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`void putText(Mat& image, const string& text, Point org, int fontFace, double
    fontScale, Scalar color, int thickness=1, int lineType=8, bool bottomLeftOrigin=false)`:
    This function draws a `text` string in the `image` at the specified position (`org`)
    with the properties set by the arguments `fontFace`, `fontScale`, `color`, `thickness`,
    and `lineType`. It is possible to set the coordinates origin at the bottom-left
    corner with the last argument (`bottomLeftOrigin`). In the example, this function
    is used as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `drawThings` example, we draw a text `"mark"` followed by an increasing
    number that points out the mark order. To store the mark order, we used a `static`
    variable (`imark`) that maintains its value between the calls. The `putText` function
    draws the text at the location where the mouse click occurs with a 6-pixels shift
    on *x* axis. The font face is specified by the flag `FONT_HERSHEY_PLAIN` and is
    drawn without scale (`1.0`), black color (`Scalar(0, 0, 0)`), and `2` pixels thickness.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The available flags for the font face are defined by the enumeration:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Selecting regions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many computer vision applications require to focus interest inside local regions
    of the images. In that case, it is a very useful user tool to select the desired
    **regions of interest** (**ROI**). In the `drawRs` example, we show how to select,
    with the mouse, rectangular regions in the image to locally increase the contrast
    inside these regions (as shown in the following screenshot). For better control
    over region selection, we implement a click-and-drag behavior to reshape the rectangular
    boundary of each region.
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting regions](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Output image with increased contrast in some rectangular regions
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, only the code corresponding to the function callback
    for mouse events is shown, since the rest is quite similar in the previous examples.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The callback function declares `static` its local variables, so they maintain
    their values between calls. The variables, `p1` and `p2`, store the points for
    defining the rectangular region of interest, and `p2set` holds the Boolean (`bool`)
    value that indicates if point `p2` is set. When `p2set` is `true`, a new selected
    region can be drawn and its new values computed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mouse callback function handles the following events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EVENT_LBUTTONDOWN`: This button is also called left button down. The initial
    position (`p1`) is set to `Point(x, y)` where the event occurs. Also, the `p2set`
    variable is set to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EVENT_MOUSEMOVE && EVENT_FLAG_LBUTTON`: Move the mouse with the left button
    down. First, the boundaries should be checked so that we can correct coordinates
    and avoid errors just in case the final point is out of the window. Then, the
    temporal `p2` point is set to the final position of the mouse and `p2set` is set
    to `true`. Finally, a temporal image is shown in the window with the rectangle
    drawn on it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EVENT_LBUTTONUP`: This button is also called left button up and is valid only
    if `p2set` is `true`.The final region is selected. Then a subarray can be pointed
    in the original image for further computation. After that, a rectangle around
    the final region is drawn in the original image and the result is shown into the
    application window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we take a closer look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Size Mat::size() const:` Returns the matrix size `(Size(cols, rows))`: This
    function is used to get the bounds of the image (`orig_img`) as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since `Mat::size()` returns a `Size` object, we can access its members `width`
    and `height` to obtain the greatest values for `x` and `y` in the image (`orig_img`)
    and compare those with the coordinates where the mouse event take place.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`void Mat::copyTo(OutputArray m) const`: This method copies the matrix to another
    one, reallocating new size and type if it is needed. Before copying, the following
    method invokes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the example, the following method is employed to make a temporal copy of
    the original image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The rectangle that defines the selected region is drawn over this temporal image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`void rectangle(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness=1,
    int lineType=8, int shift=0)`: This function draws a rectangle defined by points
    `pt1` and `pt2` over the image (`img`) with the specified `color`, `thickness`,
    and `lineType`. In the code example, this function is used twice. First, to draw
    a red (`Scalar(0, 0, 255)`) rectangle on the temporal image (`tmp_img`) around
    the selected area, and then to draw the boundaries of the final selected region
    in the original image (`orig_img`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Mat::Mat(const Mat& m, const Rect& roi)`: The constructor takes a submatrix
    of `m` limited by the rectangle (`roi`) that represents a region of interest in
    the image stored in `m`. This constructor is applied, in the code example, to
    get the rectangular region whose contrast has to be converted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using Qt-based functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `highgui` will be sufficient for most purposes, the Qt UI framework (available
    at [http://qt-project.org/](http://qt-project.org/)) can be leveraged in OpenCV
    to develop richer user interfaces. A number of OpenCV's user interface functions
    use the Qt library behind the scenes. In order to use these functions, OpenCV
    must have been compiled with the `WITH_QT` option.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Qt is a class and **widget** library that allows the creation of full-fledged
    applications with rich, event-driven user interfaces. In this section, however,
    we will mainly focus on specific Qt-based functions within OpenCV. Programming
    with Qt is out of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: With Qt support on, windows created with the `namedWindow` function will automatically
    look like what is shown in the following screenshot. There is a toolbar with useful
    functions such as pan, zoom, and save image. Windows also display a status bar
    at the bottom with the current mouse location and RGB value under that pixel.
    Right-clicking on the image will display a pop-up menu with the same toolbar options.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Qt-based functions](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Window displayed with Qt support enabled
  prefs: []
  type: TYPE_NORMAL
- en: Text overlays and status bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Text can be displayed on a line across the top of the image. This is very useful
    to show frames per second, number of detections, filenames, and so on. The main
    function is `displayOverlay(const string& winname, const string& text, int delayms=0)`.
    The function expects a window identifier and the text to display. Multiple lines
    are allowed by using the `\n` character in the text string. The text will be displayed
    in the center and has a fixed size. The `delayms` parameter allows to display
    the text only for a specified amount of milliseconds (`0=forever`).
  prefs: []
  type: TYPE_NORMAL
- en: We can also display user text in the status bar. This text will replace the
    default *x* and *y* coordinates and RGB value under the current pixel. The `displayStatusBar(const
    string& winname, const string& text, int delayms=0)` function has the same parameters
    as the previous `displayOverlay` function. When the delay has passed, the default
    status bar text will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The properties dialog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most useful features of OpenCV's Qt-based functions is the properties
    dialog window. This window can be used to place trackbars and buttons. Again,
    this comes in handy while tuning parameters for our application. The properties
    dialog window can be accessed by pressing the last button in the toolbar (as shown
    in the preceding screenshot) or by pressing *Ctrl* + *P*. The window will only
    be accessible if trackbars or button have been assigned to it. To create a trackbar
    for the properties dialog, simply use the `createTrackbar` function passing an
    empty string (not `NULL`) as the window name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Buttons can also be added to the properties dialog. Since both the original
    window and the dialog windows can be visible at the same time, this can be useful
    to activate/deactivate features in our application and see the results immediately.
    To add buttons to the dialog, use the `createButton(const string& button_name,
    ButtonCallback on_change, void* userdata=NULL,inttype=CV_PUSH_BUTTON, bool initial_button_state=0)`
    function. The first parameter is the button label (that is, the text to be displayed
    in the button). Every time the button changes its state, the `on_change` callback
    function will be called. This should be in the form `void on_change(intstate,
    void *userdata)`. The userdata pointer passed to `createButton` will be passed
    to this callback function every time it is called. The state parameter signals
    the button change and it will have a different value for each type of button,
    given by parameter types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CV_PUSH_BUTTON`: Push button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CV_CHECKBOX`: Checkbox button; the state will be either 1 or 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CV_RADIOBOX`: Radiobox button; the state will be either 1 or 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the first two types, the callback is called once on each press. For the
    radiobox button, it is called both for the button just clicked and for the button
    that goes unclicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Buttons are organized into button bars. Button bars occupy one row in the dialog
    window. Each new button is added to the right of the last one. Trackbars take
    up an entire row, so button bars are terminated when a trackbar is added. The
    following `propertyDlgButtons` example shows how buttons and trackbars are laid
    out in the properties dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is similar to the `flipImage` example in the previous chapter. In
    this example, an image filename is passed as an argument. A properties window
    is created with two buttons for vertical and horizontal flipping, a dummy trackbar,
    and a checkbox button to invert color intensities. The callback functions `on_flipV`
    and `on_flipH` simply flip the current image and show the result (we use a global
    image variable for this), while the callback function `on_negative` logically
    inverts color intensities and shows the result. Note that the trackbar is not
    really being used; it is used to show the **line feed** effect. The following
    screenshot shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The properties dialog](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The propertyDlgButtons example
  prefs: []
  type: TYPE_NORMAL
- en: Windows properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously, by default, all new windows will look like what''s
    shown in the screenshot in the *Using Qt-based functions* section. Still, we can
    display windows in the non-Qt format by passing the `CV_GUI_NORMAL` option to
    `namedWindow`. On the other hand, window size parameters can be retrieved and
    set using the `double getWindowProperty(const string& winname, int prop_id)` and
    `setWindowProperty (const string& winname, int prop_id,double prop_value)` functions.
    The following table shows the properties that can be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property (`prop_id`) | Description | Possible values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CV_WND_PROP_FULLSCREEN` | Displays a fullscreen or regular window | `CV_WINDOW_NORMAL`
    or `CV_WINDOW_FULLSCREEN` |'
  prefs: []
  type: TYPE_TB
- en: '| `CV_WND_PROP_AUTOSIZE` | Window automatically resizes to fit the displayed
    image | `CV_WINDOW_NORMAL` or `CV_WINDOW_AUTOSIZE` |'
  prefs: []
  type: TYPE_TB
- en: '| `CV_WND_PROP_ASPECTRATIO` | Allows resized windows to have any ratio or fixed
    original ratio | `CV_WINDOW_FREERATIO` or `CV_WINDOW_KEEPRATIO` |'
  prefs: []
  type: TYPE_TB
- en: More importantly, window properties can be saved. This includes not only size
    and location, but also flags, trackbar values, zoom, and panning location. To
    save and load window properties, use the `saveWindowParameters(const string& windowName)`
    and `loadWindowParameters(const string& windowName)` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Qt images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to use the Qt libraries extensively in our project (that is, beyond
    OpenCV''s Qt-based functions), we have to find a way to convert OpenCV''s images
    to the format used by Qt (`QImage`). This can be done by using the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This function creates a Qt image using OpenCV's image data. Note that a conversion
    is first necessary, since Qt uses RGB images while OpenCV uses BGR order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to display the image with Qt, we have at least two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class that extends the `QWidget` class and implements paint events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a label and set it to draw an image (using the `setPixMap` method).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provided a deeper view of the `highgui` module functionality
    to enrich the user experience. The main elements supplied by OpenCV to build graphical
    user interfaces are shown in some code samples. Moreover, we reviewed the new
    Qt functionality inside OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter's examples cover topics such as `tbarContrast`, `tbarContrastCallB`,
    `drawThings`, `drawRs`, and `propertyDlgButtons`.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover the implementation of the most usual methods used
    for image processing, such as brightness control, contrast and color conversion,
    retina filtering, and geometrical transformations.
  prefs: []
  type: TYPE_NORMAL
