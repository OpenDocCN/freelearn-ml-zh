["```py\n#include \"opencv2/core/core.hpp\"\n#include \"opencv2/highgui/highgui.hpp\"\n#include <iostream>\n\nusing namespace std;\nusing namespace cv;\n\nint main(int argc, char* argv[]) {\n    const char in_win[]=\"Orig. image\";\n    const char out_win[]=\"Image converted...(no saved)\";\n    int TBvalContrast=50; // Initial value of the TrackBar\n    Mat out_img;\n\n    if (argc != 2) {\n        cout << \"Usage: <cmd><input image_file>\" << endl;\n        return -1;\n    }\n    Mat in_img = imread(argv[1]); // Open and read the image\n    if (in_img.empty()) {\n        cout << \"Error!!! Image cannot be loaded...\" << endl;\n        return -1;\n    }\n    namedWindow(in_win); // Creates window for orig. image\n moveWindow(in_win, 0, 0); // Move window to pos. (0, 0)\n    imshow(in_win, in_img); // Shows original image\n    namedWindow(out_win);\n createTrackbar(\"Contrast\", out_win, &TBvalContrast, 100);\n    cout << \"Press Esc key to exit...\" << endl;\n    while (true) {\n in_img.convertTo(out_img, -1, TBvalContrast/50.0);\n        imshow(out_win, out_img);\n        if (waitKey(50) == 27) // If Esc key pressed breaks\n            break;\n    }\n    return 0;\n}\n```", "```py\n    moveWindow(in_win,0,0);\n    ```", "```py\n    createTrackbar(\"Contrast\", out_win, &TBvalContrast, 100);\n    ```", "```py\n    m(x, y) = alfa(*this)(x, y) + beta,\n\n    ```", "```py\n    while (true) {\n        in_img.convertTo(out_img, -1, TBvalContrast/50.0);\n        imshow(out_win, out_img);\n        if (waitKey(50) == 27) // If Esc key pressed breaks\n            break;\n    }\n    ```", "```py\n//… (omitted for brevity)\n#define IN_WIN \"Orig. image\"\n#define OUT_WIN \"Image converted...(no saved)\"\nMat in_img, out_img;\n\n// CallBack function for contrast TrackBar\nvoid updateContrast(int TBvalContrast, void *userData=0) {\n\n in_img.convertTo(out_img, -1, TBvalContrast/50.0);\n imshow(OUT_WIN, out_img);\n return;\n}\n\nint main(int argc, char* argv[]) {\n\n    int TBvalContrast=50; // Value of the TrackBar\n\n    // (omitted for simplicity)\n    in_img = imread(argv[1]); // Open and read the image\n    // (omitted for simplicity)\n    in_img.copyTo(out_img); // Copy orig. image to final img\n    namedWindow(IN_WIN); // Creates window for orig. image\n    moveWindow(IN_WIN, 0, 0); // Move window to pos. (0, 0)\n    imshow(IN_WIN, in_img); // Shows original image\n    namedWindow(OUT_WIN); // Creates window for converted image\n createTrackbar(\"Contrast\", OUT_WIN, &TBvalContrast, 100,\n                   updateContrast);\n    imshow(OUT_WIN, out_img); // Shows converted image\n    cout << \"Press any key to exit...\" << endl;\n    waitKey();\n    return 0;\n}\n```", "```py\ncreateTrackbar(\"Contrast\", OUT_WIN, &TBvalContrast, 100,\nupdateContrast);\n```", "```py\n    // (omitted for simplicity)\n#define IN_WIN \"Drawing...\"\n\nMat img;\n\n// CallBack Function for mouse events\nvoid cbMouse(int event, int x, int y, int flags, void* userdata) {\n\nstatic int imark=0;\n    char textm[] = \"mark999\";\n\n    if (event == EVENT_LBUTTONDOWN) { // Left mouse button pressed\ncircle(img, Point(x, y), 4, Scalar(0,0,255), 2);\nimark++;// Increment the number of marks\nsprintf(textm, \"mark %d\", imark);// Set the mark text\nputText(img, textm, Point(x+6, y), FONT_HERSHEY_PLAIN,\n 1, Scalar(0,0,0),2);\nimshow(IN_WIN, img); // Show final image\n    }\n    return;\n}\n\nint main(int argc, char* argv[]) {\n\n    // (omitted for brevity)\t\n    img = imread(argv[1]); //open and read the image\n    // (omitted for brevity)\n    namedWindow(IN_WIN);\n setMouseCallback(IN_WIN, cbMouse, NULL);\n    imshow(IN_WIN, img);\n    cout << \"Pres any key to exit...\" << endl;\n    waitKey();\n    return 0;\n}\n```", "```py\n    setMouseCallback(IN_WIN, cbMouse, NULL);\n    ```", "```py\n    void cbMouse(int event, int x, int y, int flags, void* userdata)\n    ```", "```py\n    enum{\n      EVENT_MOUSEMOVE      =0,\n        EVENT_LBUTTONDOWN    =1,\n        EVENT_RBUTTONDOWN    =2,\n        EVENT_MBUTTONDOWN    =3,\n        EVENT_LBUTTONUP      =4,\n        EVENT_RBUTTONUP      =5,\n        EVENT_MBUTTONUP      =6,\n        EVENT_LBUTTONDBLCLK  =7,\n        EVENT_RBUTTONDBLCLK  =8,\n        EVENT_MBUTTONDBLCLK  =9};\n\n    enum {\n        EVENT_FLAG_LBUTTON   =1,\n        EVENT_FLAG_RBUTTON   =2,\n        EVENT_FLAG_MBUTTON   =4,\n        EVENT_FLAG_CTRLKEY   =8,\n        EVENT_FLAG_SHIFTKEY  =16,\n        EVENT_FLAG_ALTKEY    =32};\n    ```", "```py\n    circle(img, Point(x, y), 4, Scalar(0,0,255), 2);\n    ```", "```py\n    imark++; // Increment the number of marks\n    sprintf(textm, \"mark %d\", imark); // Set the mark text\n    putText(img, textm, Point(x+6, y), FONT_HERSHEY_PLAIN,\n    1.0, Scalar(0,0,0),2);\n    ```", "```py\n    enum{\n        FONT_HERSHEY_SIMPLEX = 0,\n        FONT_HERSHEY_PLAIN = 1,\n        FONT_HERSHEY_DUPLEX = 2,\n        FONT_HERSHEY_COMPLEX = 3,\n        FONT_HERSHEY_TRIPLEX = 4,\n        FONT_HERSHEY_COMPLEX_SMALL = 5,\n        FONT_HERSHEY_SCRIPT_SIMPLEX = 6,\n        FONT_HERSHEY_SCRIPT_COMPLEX = 7,\n        FONT_ITALIC = 16};\n    ```", "```py\nvoid cbMouse(int event, int x, int y, int flags, void* userdata) {\n\n  static Point p1, p2; // Static vars hold values between calls\n  static bool p2set = false;\n\n  if (event == EVENT_LBUTTONDOWN) { // Left mouse button pressed\n      p1 = Point(x, y); // Set orig. point\n      p2set = false;\n  } else if (event == EVENT_MOUSEMOVE &&\nflags == EVENT_FLAG_LBUTTON) {\n      if (x >orig_img.size().width) // Check out of bounds\n          x = orig_img.size().width;\n      else if (x < 0)\n          x = 0;\n      if (y >orig_img.size().height) // Check out of bounds\n          y = orig_img.size().height;\n      else if (y < 0)\n          y = 0;\n      p2 = Point(x, y); // Set final point\n      p2set = true;\norig_img.copyTo(tmp_img); // Copy orig. to temp. image\nrectangle(tmp_img, p1, p2, Scalar(0, 0, 255));\n      imshow(IN_WIN, tmp_img); // Draw temporal image with rect.\n  } else if (event == EVENT_LBUTTONUP && p2set) {\nMat submat = orig_img(Rect(p1, p2)); // Set region\n      submat.convertTo(submat, -1, 2.0); // Compute contrast\n   rectangle(orig_img, p1, p2, Scalar(0, 0, 255));\n      imshow(IN_WIN, orig_img); // Show image\n  }\n  return;\n}\n```", "```py\n    if (x > orig_img.size().width) // Check out bounds\n                x = orig_img.size().width;\n            else if (x < 0)\n                x = 0;\n            if (y > orig_img.size().height) // Check out bounds\n                y = orig_img.size().height;\n    ```", "```py\n    m.create(this->size(), this->type());\n\n    ```", "```py\n    orig_img.copyTo(tmp_img); // Copy orig. to temp. image\n    ```", "```py\n    rectangle(tmp_img, p1, p2, Scalar(0, 0 ,255));\n    //…\n    rectangle(orig_img, p1, p2, Scalar(0, 0, 255));\n    ```", "```py\n    Mat submat = orig_img(Rect(p1, p2));// Set subarray on orig. image\n    ```", "```py\n#include \"opencv2/core/core.hpp\"\n#include \"opencv2/highgui/highgui.hpp\"\n#include <iostream>\n\nusing namespace std;\nusing namespace cv;\n\nMat image;\nconst char win[]=\"Flip image\";\n\nvoid on_flipV(int state, void *p)\n{\n    flip(image, image, 0);  // flip vertical\n    imshow(win, image);\n}\n\nvoid on_flipH(int state, void *p)\n{\n    flip(image, image, 1);  // flip horizontal\n    imshow(win, image);\n}\n\nvoid on_negative(int state, void *p)\n{\n    bitwise_not(image, image);  // invert all channels\n    imshow(win, image);\n}\n\nint main(int argc, char *argv[])\n{\n    if (argc != 2) {//Check args.\n        cout << \"Usage: <cmd><file_in>\\n\";\n        return -1;\n    }\n    image = imread(argv[1]);\n    if (image.empty()) {\n        cout << \"Error! Input image cannot be read...\\n\";\n        return -1;\n    }\n\n    namedWindow(win);\n    imshow(win, image);\n    displayOverlay(win, argv[1], 0);\n    createButton(\"Flip Vertical\", on_flipV, NULL, CV_PUSH_BUTTON);\n    createButton(\"Flip Horizontal\", on_flipH, NULL, CV_PUSH_BUTTON);\n    int v=0;\n    createTrackbar(\"trackbar1\", \"\", &v, 255);\n    createButton(\"Negative\", on_negative, NULL, CV_CHECKBOX);\n\n    cout << \"Press any key to exit...\\n\";\n    waitKey();\n    return 0;\n}\n```", "```py\nQImage* Mat2Qt(const Mat &image)\n{\nMat temp=image.clone();\ncvtColor(image, temp, CV_BGR2RGB);\nQImage *imgQt= new QImage((const unsigned char*)(temp.data),temp.cols,temp.rows,QImage::Format_RGB888);\nreturn imgQt;\n}\n```"]