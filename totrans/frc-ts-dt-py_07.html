<html><head></head><body>
<div id="_idContainer180">
<h1 class="chapter-number" id="_idParaDest-81"><a id="_idTextAnchor453"/><a id="_idTextAnchor454"/><a id="_idTextAnchor455"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-82"><a id="_idTextAnchor456"/><span class="koboSpan" id="kobo.2.1">Controlling Growth Modes</span></h1>
<p><span class="koboSpan" id="kobo.3.1">So far in this book, every forecast we’ve built has followed only one growth mode: </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">linear</span></strong><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">The trend sometimes had some small bends where the slope either increased or decreased, but fundamentally, the trend consisted of linear segments. </span><span class="koboSpan" id="kobo.5.3">However, Prophet features two additional growth modes: </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">logistic</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.7.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.8.1">flat</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">Modeling your time series with a growth mode that is not optimal can often fit the actual data very well. </span><span class="koboSpan" id="kobo.10.2">But, as you’ll see in this chapter, even if the fit is realistic, the future forecast can become wildly unrealistic. </span><span class="koboSpan" id="kobo.10.3">Sometimes, the shape of the data will inform which growth mode to choose, and sometimes you’ll need domain knowledge and a bit of common sense. </span><span class="koboSpan" id="kobo.10.4">This chapter will help guide you to an appropriate selection. </span><span class="koboSpan" id="kobo.10.5">Furthermore, you will learn when and how to apply these different growth modes. </span><span class="koboSpan" id="kobo.10.6">Specifically, this chapter will cover </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">Applying </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">linear growth</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Understanding the </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">logistic function</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Saturating forecasts</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Applying </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">flat growth</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">custom trend</span></span></li>
</ul>
<h1 id="_idParaDest-83"><a id="_idTextAnchor457"/><a id="_idTextAnchor458"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">The data files and code for the examples in this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">at </span></span><a href="https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.25.1">.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor459"/><a id="_idTextAnchor460"/><span class="koboSpan" id="kobo.26.1">Applying linear growth</span></h1>
<p><span class="koboSpan" id="kobo.27.1">All the </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.28.1">models we built in the previous chapters had the default growth mode, linear. </span><span class="koboSpan" id="kobo.28.2">This means that the trend</span><a id="_idTextAnchor461"/><span class="koboSpan" id="kobo.29.1"> consists of a straight, sloped line, or potentially, a few straight, sloped lines connected at changepoints – a case we will explore in </span><a href="B19630_08.xhtml#_idTextAnchor537"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.30.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.31.1">, </span><em class="italic"><span class="koboSpan" id="kobo.32.1">Influencing Trend Changepoints</span></em><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">For now, though, let’s load up our Divvy data again and focus on </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">the growth.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">We’re going to import </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">pandas</span></strong><span class="koboSpan" id="kobo.37.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">matplotlib</span></strong><span class="koboSpan" id="kobo.39.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">Prophet</span></strong><span class="koboSpan" id="kobo.41.1"> again, but this time, we’ll also import a new function from Prophet’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">plot</span></strong><span class="koboSpan" id="kobo.43.1"> package, </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">add_changepoints_to_plot</span></strong><span class="koboSpan" id="kobo.45.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.47.1">
import pandas as pd
import matplotlib.pyplot as plt
from prophet import Prophet
from prophet.plot import add_changepoints_to_plot</span></pre>
<p><span class="koboSpan" id="kobo.48.1">This new function will allow us to easily plot our trend line directly on our </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">forecast plot.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">As we’ve done previously, let’s open the Divvy data and load it into our </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">training DataFrame:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.52.1">
df = pd.read_csv('divvy_daily.csv')
df = df[['date', 'rides']]
df['date'] = pd.to_datetime(df['date'])
df.columns = ['ds', 'y']</span></pre>
<p><span class="koboSpan" id="kobo.53.1">We learned already in </span><a href="B19630_05.xhtml#_idTextAnchor254"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.54.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.55.1">, </span><em class="italic"><span class="koboSpan" id="kobo.56.1">Working with Seasonality</span></em><span class="koboSpan" id="kobo.57.1">, that this dataset should be modeled with multiplicative seasonality and that the yearly seasonality should be constrained a bit by setting the Fourier order to </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">4</span></strong><span class="koboSpan" id="kobo.59.1">. </span><span class="koboSpan" id="kobo.59.2">We’ll set these values when instantiating our model. </span><span class="koboSpan" id="kobo.59.3">We’ll also explicitly set </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">growth='linear'</span></strong><span class="koboSpan" id="kobo.61.1">. </span><span class="koboSpan" id="kobo.61.2">This is the default, and previously, we just implicitly accepted it, but for clarity’s sake, we’ll include </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">it here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.63.1">
model = Prophet(growth='linear',
                seasonality_mode='multiplicative',
                yearly_seasonality=4)</span></pre>
<p><span class="koboSpan" id="kobo.64.1">Just as we did when we modeled the daily Divvy data in </span><a href="B19630_05.xhtml#_idTextAnchor254"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.65.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.66.1">, </span><em class="italic"><span class="koboSpan" id="kobo.67.1">Working with Seasonality</span></em><span class="koboSpan" id="kobo.68.1">, next, we will fit the model, build a </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">future</span></strong><span class="koboSpan" id="kobo.70.1"> DataFrame with one year to forecast, predict future values, and plot the forecast. </span><span class="koboSpan" id="kobo.70.2">This time, however, we will use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">add_changepoints_to_plot</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.72.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">The</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.74.1"> function requires that we specify which plot axes to use, identify the model we created, and identif</span><a id="_idTextAnchor462"/><span class="koboSpan" id="kobo.75.1">y the forecast DataFrame output from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">predict</span></strong><span class="koboSpan" id="kobo.77.1"> method. </span><span class="koboSpan" id="kobo.77.2">For the axes, we use the Matplotlib </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">gca</span></strong><span class="koboSpan" id="kobo.79.1"> method, to </span><em class="italic"><span class="koboSpan" id="kobo.80.1">get current axes</span></em><span class="koboSpan" id="kobo.81.1">, and call it on the figure created when plotting the forecast. </span><span class="koboSpan" id="kobo.81.2">You can see the syntax in the following code. </span><span class="koboSpan" id="kobo.81.3">We are only using the plot changepoints function here to plot the trend so we will remove the changepoint markers, for now, </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">cp_linestyle=''</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.85.1">
model.fit(df)
future = model.make_future_dataframe(periods=365)
forecast = model.predict(future)
fig = model.plot(forecast)
add_changepoints_to_plot(fig.gca(), model, forecast,
                         cp_linestyle='')
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.86.1">As output, you should now see a similar forecast to that in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.87.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.88.1">.8</span></em><span class="koboSpan" id="kobo.89.1">, but this time, the trend line will be overlaid upon </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">the plot:</span></span><a id="_idTextAnchor463"/></p>
<div>
<div class="IMG---Figure" id="_idContainer156">
<span class="koboSpan" id="kobo.91.1"><img alt="Figure 7.1 – Divvy forecast with the trend" src="image/Fig_7.1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.92.1">Figure 7.1 – Divvy forecast with the trend</span></p>
<p><span class="koboSpan" id="kobo.93.1">Remember, Prophet is an</span><a id="_idTextAnchor464"/><span class="koboSpan" id="kobo.94.1"> additive regression model. </span><span class="koboSpan" id="kobo.94.2">So, the trend is the most fundamental building block of our forecast. </span><span class="koboSpan" id="kobo.94.3">We add detail and variation to it by adding seasonalities, holidays, and additional regressors. </span><span class="koboSpan" id="kobo.94.4">The trend you see in the preceding figure (the solid line cutting through the midpoints of each sine period) is the Divvy plot with seasonality removed (we never added holidays in </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">this example).</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">As you can see, the trend is a straight segment from </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">2014</span></strong><span class="koboSpan" id="kobo.98.1"> until late </span><strong class="bold"><span class="koboSpan" id="kobo.99.1">2015</span></strong><span class="koboSpan" id="kobo.100.1">, then a slight bend and another straight segment, with a shallower slope, from </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">2016</span></strong><span class="koboSpan" id="kobo.102.1"> onward. </span><span class="koboSpan" id="kobo.102.2">Despite that bend, it</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.103.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">fundamentally linear.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">Let’s now look at the next growth mode, logistic. </span><span class="koboSpan" id="kobo.105.2">To understand this growth mode, you first need to understand the </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">logistic function</span><a id="_idTextAnchor465"/><a id="_idTextAnchor466"/><span class="koboSpan" id="kobo.107.1">.</span></span></p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor467"/><span class="koboSpan" id="kobo.108.1">Understanding the logistic function</span></h1>
<p><span class="koboSpan" id="kobo.109.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">logistic function</span></strong><span class="koboSpan" id="kobo.111.1"> generates an </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.112.1">S-shaped curve; the equation takes the </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">following form</span><a id="_idTextAnchor468"/><span class="koboSpan" id="kobo.114.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer157">
<span class="koboSpan" id="kobo.115.1"><img alt="" src="image/B19630_07_F01.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.116.1">Here, </span><span class="koboSpan" id="kobo.117.1"><img alt="" src="image/B19630_07_F02.png"/></span><span class="koboSpan" id="kobo.118.1"> is the maximum value of the curve, </span><span class="koboSpan" id="kobo.119.1"><img alt="" src="image/B19630_07_F03.png"/></span><span class="koboSpan" id="kobo.120.1"> is the logistic growth rate, or steepness, of the curve, and </span><span class="koboSpan" id="kobo.121.1"><img alt="" src="image/B19630_07_F04.png"/></span><span class="koboSpan" id="kobo.122.1"> is the </span><em class="italic"><span class="koboSpan" id="kobo.123.1">x</span></em><span class="koboSpan" id="kobo.124.1"> value of the </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">curve’s midpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">Taking </span><span class="koboSpan" id="kobo.127.1"><img alt="" src="image/B19630_07_F05.png"/></span><span class="koboSpan" id="kobo.128.1">, </span><span class="koboSpan" id="kobo.129.1"><img alt="" src="image/B19630_07_F06.png"/></span><span class="koboSpan" id="kobo.130.1">, and </span><span class="koboSpan" id="kobo.131.1"><img alt="" src="image/B19630_07_F07.png"/></span><span class="koboSpan" id="kobo.132.1">, the</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.133.1"> logistic function produces the </span><strong class="bold"><span class="koboSpan" id="kobo.134.1">standard logistic function</span></strong><span class="koboSpan" id="kobo.135.1">, </span><span class="koboSpan" id="kobo.136.1"><img alt="" src="image/B19630_07_F08.png"/></span><span class="koboSpan" id="kobo.137.1">, as seen</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.138.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">following plot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer165">
<span class="koboSpan" id="kobo.140.1"><img alt="Figure 7.﻿2 – The standard logistic function" src="image/Fig_7.2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.141.1">Figure 7.</span><a id="_idTextAnchor469"/><span class="koboSpan" id="kobo.142.1">2 – The standard logistic function</span></p>
<p><span class="koboSpan" id="kobo.143.1">If you have studied logistic regression or neural networks, you may recognize t</span><a id="_idTextAnchor470"/><span class="koboSpan" id="kobo.144.1">his as the </span><strong class="bold"><span class="koboSpan" id="kobo.145.1">sigmoid function</span></strong><span class="koboSpan" id="kobo.146.1">. </span><span class="koboSpan" id="kobo.146.2">Any input </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.147.1">value for </span><em class="italic"><span class="koboSpan" id="kobo.148.1">x</span></em><span class="koboSpan" id="kobo.149.1">, from -∞ to ∞, will be squished into an output value, </span><em class="italic"><span class="koboSpan" id="kobo.150.1">y</span></em><span class="koboSpan" id="kobo.151.1">, between 0 and 1. </span><span class="koboSpan" id="kobo.151.2">This equation is what allows a logistic regression model to accept any input value and output a probability between 0 </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">and 1.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">The equation was developed by </span><a id="_idTextAnchor471"/><span class="koboSpan" id="kobo.154.1">Pierre François Verhulst, a Belgian mathematician, in a series of three papers published between 1838 and 1847. </span><span class="koboSpan" id="kobo.154.2">Verhulst was working to model the population growth </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">of Belgium.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">Population </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.157.1">growth approximately follows an initial exponential growth rate, then a linear (also known as arithmetic) growth rate, until the population hits a saturation point, where growth slows to zero. </span><span class="koboSpan" id="kobo.157.2">This is the shape you see in the preceding plot, starting at the curve’s midpoint and moving right. </span><span class="koboSpan" id="kobo.157.3">Verhulst invented the term </span><em class="italic"><span class="koboSpan" id="kobo.158.1">logistic</span></em><span class="koboSpan" id="kobo.159.1"> to be analogous to </span><em class="italic"><span class="koboSpan" id="kobo.160.1">arithmetic</span></em><span class="koboSpan" id="kobo.161.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.162.1">geometric</span></em><span class="koboSpan" id="kobo.163.1"> but derived from </span><em class="italic"><span class="koboSpan" id="kobo.164.1">logarithmic</span></em><span class="koboSpan" id="kobo.165.1">. </span><span class="koboSpan" id="kobo.165.2">Don’t get the word confused with </span><em class="italic"><span class="koboSpan" id="kobo.166.1">logistics</span></em><span class="koboSpan" id="kobo.167.1">, which refers to the handling of details. </span><span class="koboSpan" id="kobo.167.2">They have completely </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">different origins.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">Prophet’s logistic growth mode follows this general curve. </span><span class="koboSpan" id="kobo.169.2">The curve’s </span><strong class="bold"><span class="koboSpan" id="kobo.170.1">saturation</span></strong><span class="koboSpan" id="kobo.171.1"> levels are the upper and lower bounds, which the curve </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">asymptotically approaches.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">Besides applications in statistics and machine learning where the logistic curve is used in logistic regression and neural networ</span><a id="_idTextAnchor472"/><span class="koboSpan" id="kobo.174.1">ks, the logistic function is also often used to model population growth, either of humans (as in Verhulst’s Belgium) or of animals, as we will do in this chapter. </span><span class="koboSpan" id="kobo.174.2">It is often used in medicine to model the growth of tumors, bacterial or viral loads in an infected person, or infection rates of people during </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">a pandemic.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">In economics and sociology, the curve is used to describe the adoption rate of new innovations. </span><span class="koboSpan" id="kobo.176.2">Linguists use it to model language changes. </span><span class="koboSpan" id="kobo.176.3">It can even be used to model the spread of a rumor or new idea throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">a population.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">Let’s see how to apply this </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">in Prophet.</span></span></p>
<h1 id="_idParaDest-86"><span class="koboSpan" id="kobo.180.1">Saturating fo</span><a id="_idTextAnchor473"/><a id="_idTextAnchor474"/><span class="koboSpan" id="kobo.181.1">recasts</span></h1>
<p><span class="koboSpan" id="kobo.182.1">In the early 1800s, westward</span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.183.1"> expansion in</span><a id="_idTextAnchor475"/><span class="koboSpan" id="kobo.184.1"> the United States brought many settlers and their livestock into contact with the native wolf population. </span><span class="koboSpan" id="kobo.184.2">These wolves began to prey on domestic stock, which resulted in the settlers hunting and killing the wolves in order to protect their own animals. </span><span class="koboSpan" id="kobo.184.3">The gray wolf was still present on the land (which became Yellowstone National Park when it was established in 1872), but over the next few decades, they were hunted nearly to extinction in the region and throughout the lower </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">48 states.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">In the 1960s, the public began to understand the idea of ecosystems and the interconnectedness of species, and in 1975, the decision to restore wolf populations to Yellowstone was taken, with 31 gray wolves finally being relocated to the park from Canada in 1995. </span><span class="koboSpan" id="kobo.186.2">This provided an almost perfect experiment of natural population growth inside </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">the park.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">We’ll look at this population in the next few examples. </span><span class="koboSpan" id="kobo.188.2">However, we’ll be using simulated data because the true data is spotty throughout the historical record. </span><span class="koboSpan" id="kobo.188.3">As wolves tend to avoid human contact, counting their number can never be exact and so accurate data is lacking. </span><span class="koboSpan" id="kobo.188.4">Furthermore, there are numerous compounding factors (such as weather, for example) that we will not model (and are generally unpredictable, </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">as well).</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">To understand these </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.191.1">compounding factors, consider the example of Isle Royale, an island on Michigan’s Lake Superior th</span><a id="_idTextAnchor476"/><span class="koboSpan" id="kobo.192.1">at has had a moose and wolf population under continuous study since 1959. </span><span class="koboSpan" id="kobo.192.2">This is, in fact, the longest continuous study of any predator-prey population system in the world. </span><span class="koboSpan" id="kobo.192.3">As can be seen in the following plot, it has not been a predictable system, to say </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">the least:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer166">
<span class="koboSpan" id="kobo.194.1"><img alt="Figure 7.3﻿ – Population numbers of wolves and moose on Isle Royale" src="image/Fig_7.3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.195.1">Figure 7.3</span><a id="_idTextAnchor477"/><span class="koboSpan" id="kobo.196.1"> – Population numbers of wolves and moose on Isle Royale</span></p>
<p><span class="koboSpan" id="kobo.197.1">In the 1960s and 1970s, rising moose populations provided food, which allowed wolf populations to double. </span><span class="koboSpan" id="kobo.197.2">But in 1980, humans inadvertently introduced canine-parvovirus, a disease that caused the wolf population to collapse. </span><span class="koboSpan" id="kobo.197.3">The moose population in turn rose again with the decline of its only predator, only to collapse itself in 1996 with the double stresses of the most severe winter on record and an unpredictable outbreak of </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">moose ticks.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">Throughout the 1990s, the wolf population was too low for healthy breeding, leading to intense levels of inbreeding, which held their population down, only rebounding when a single wolf reached the island by crossing win</span><a id="_idTextAnchor478"/><span class="koboSpan" id="kobo.200.1">ter ice from Canada in the late 1990s. </span><span class="koboSpan" id="kobo.200.2">Following this, the wolf population increased throughout the early twenty-first century, despite declining moose numbers. </span><span class="koboSpan" id="kobo.200.3">All this is to say that small, isolated populations represent a very</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.201.1"> dynamic system that cannot be accurately predicted when not in isolation from natural </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">external events.</span></span></p>
<h2 id="_idParaDest-87"><span class="koboSpan" id="kobo.203.1">Increasing </span><a id="_idTextAnchor479"/><a id="_idTextAnchor480"/><span class="koboSpan" id="kobo.204.1">logistic growth</span></h2>
<p><span class="koboSpan" id="kobo.205.1">To synthesize a somewhat realistic </span><a id="_idIndexMarker282"/><a id="_idTextAnchor481"/><span class="koboSpan" id="kobo.206.1">population of wolves in Yellowston</span><a id="_idTextAnchor482"/><span class="koboSpan" id="kobo.207.1">e, let’s suppose that 100 wolves were introduced in 1995. </span><span class="koboSpan" id="kobo.207.2">Park ecologists surveyed the area and determined that the land could support a total population of </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">500 wolves.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">In the linear growth example, we imported </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">pandas</span></strong><span class="koboSpan" id="kobo.211.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">matplotlib</span></strong><span class="koboSpan" id="kobo.213.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">Prophet</span></strong><span class="koboSpan" id="kobo.215.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">add_changepoints_to_plot</span></strong><span class="koboSpan" id="kobo.217.1"> function, so to continue, we only need to import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">numpy</span></strong><span class="koboSpan" id="kobo.219.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">random</span></strong><span class="koboSpan" id="kobo.221.1"> libraries in order to create our dataset. </span><span class="koboSpan" id="kobo.221.2">Be sure to set the random seed so that every time we run the code, we get the same </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">pseudo-random results:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.223.1">
import numpy as np
import random
random.seed(42)  # set random seed for repeatability</span></pre>
<p><span class="koboSpan" id="kobo.224.1">We will simulate the wolf population by first creating a series of monthly dates, from 1995 until 2004. </span><span class="koboSpan" id="kobo.224.2">At every date, we’ll calculate the output from our logistic equation. </span><span class="koboSpan" id="kobo.224.3">Then, we’ll add some sinusoidal variation to account for yearly seasonality, and finally, some random noise. </span><span class="koboSpan" id="kobo.224.4">Then, we just need to scale our </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">curve up:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.226.1">
x = pd.to_datetime(pd.date_range('1995-01', '2004-02',
                                 freq='M')\
                   .strftime("%Y-%b").tolist())
y = [1 / (1 + np.e ** (-.03 * (val - 50))) for val in \
     range(len(x))]  # create logistic curve
# add sinusoidal variation
y = [y[idx] + y[idx] * .01 * np.sin((idx - 2) * (360 / 12)\
     * (np.pi / 180)) for idx in range(len(y))]
# add noise
y = [val + random.uniform(-.01, .01) for val in y]
y = [int(500 * val) for val in y]  # scale up</span></pre>
<p><span class="koboSpan" id="kobo.227.1">Let’s plot the </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.228.1">curve to make sure everything worked out </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">as expected:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.230.1">
plt.figure(figsize=(10, 6))
plt.plot(x, y)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.231.1">If everything went corr</span><a id="_idTextAnchor483"/><span class="koboSpan" id="kobo.232.1">ectly, you should se</span><a id="_idTextAnchor484"/><span class="koboSpan" id="kobo.233.1">e </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">this plot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer167">
<span class="koboSpan" id="kobo.235.1"><img alt="Figure 7﻿.4 – Simulated wolf population in Yellowstone" src="image/Fig_7.4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.236.1">Figure 7</span><a id="_idTextAnchor485"/><span class="koboSpan" id="kobo.237.1">.4 – Simulated wolf population in Yellowstone</span></p>
<p><span class="koboSpan" id="kobo.238.1">Let’s begin </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.239.1">our analysis of this data by f</span><a id="_idTextAnchor486"/><span class="koboSpan" id="kobo.240.1">itting a Prophet model with linear growth. </span><span class="koboSpan" id="kobo.240.2">T</span><a id="_idTextAnchor487"/><span class="koboSpan" id="kobo.241.1">his example will demonstrate what can go wrong when choosing an inappropriate </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">growth mode.</span></span></p>
<h3><span class="koboSpan" id="kobo.243.1">Modeling with linear growth</span></h3>
<p><span class="koboSpan" id="kobo.244.1">As we did earlier, we start by</span><a id="_idIndexMarker285"/><a id="_idTextAnchor488"/><span class="koboSpan" id="kobo.245.1"> organizing our data into a DataFrame </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">for </span></span><span class="No-Break"><a id="_idIndexMarker286"/></span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">Prophet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
df = pd.DataFrame({'ds': pd.to_datetime(x), 'y': y})</span></pre>
<p><span class="koboSpan" id="kobo.249.1">In addition to linear growth, let’s set the Fourier order of the yearly seasonality to </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">3</span></strong><span class="koboSpan" id="kobo.251.1"> and the seasonality mode to </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">multiplicative</span></strong><span class="koboSpan" id="kobo.253.1">. </span><span class="koboSpan" id="kobo.253.2">Then, we fit our DataFrame and create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">future</span></strong><span class="koboSpan" id="kobo.255.1"> DataFrame. </span><span class="koboSpan" id="kobo.255.2">We simulated this data at a monthly frequency, so we’ll forecast out </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">10</span></strong><span class="koboSpan" id="kobo.257.1"> years and set </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">freq='M'</span></strong><span class="koboSpan" id="kobo.259.1">. </span><span class="koboSpan" id="kobo.259.2">After predicting on the future, we’ll plot the forecast and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">add_changepoints_to_plot</span></strong><span class="koboSpan" id="kobo.261.1"> function to overlay </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">the trend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
model = Prophet(growth='linear',
                yearly_seasonality=3,
                seasonality_mode='multiplicative')
model.fit(df)
future = model.make_future_dataframe(periods=12 * 10,
                                     freq='M')
forecast = model.predict(future)
fig = model.plot(forecast)
add_changepoints_to_plot(fig.gca(), model, forecast,
                         cp_linestyle='')
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.264.1">Immediately, you</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.265.1"> should see what will go wrong with using a linear trend</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.266.1"> in a situation where the forecast will naturally saturate at some level. </span><span class="koboSpan" id="kobo.266.2">The predicted values will keep rising toward infinity with longer and longer forecast </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">time periods:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer168">
<span class="koboSpan" id="kobo.268.1"><img alt="Figu﻿re 7.5 – Wolf population forecast with linear growth" src="image/Fig_7.5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.269.1">Figu</span><a id="_idTextAnchor489"/><span class="koboSpan" id="kobo.270.1">re 7.5 – Wolf population forecast with linear growth</span></p>
<p><span class="koboSpan" id="kobo.271.1">Obviously, this </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.272.1">cannot be realistic. </span><span class="koboSpan" id="kobo.272.2">There is only so much food for the </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.273.1">wolves to eat; at a certain point, there won’t be enough food, and the wolves will begin to starve. </span><span class="koboSpan" id="kobo.273.2">Let’s now model this with logistic growth and see </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">what happens.</span></span></p>
<h3><span class="koboSpan" id="kobo.275.1">Modeling with logistic growth</span></h3>
<p><span class="koboSpan" id="kobo.276.1">With </span><strong class="bold"><span class="koboSpan" id="kobo.277.1">logistic</span></strong><span class="koboSpan" id="kobo.278.1"> growth, Prophet</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.279.1"> alw</span><a id="_idTextAnchor490"/><span class="koboSpan" id="kobo.280.1">ays requires that a </span><strong class="bold"><span class="koboSpan" id="kobo.281.1">ceiling</span></strong><span class="koboSpan" id="kobo.282.1"> be stated—a value</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.283.1"> that your forecast will never</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.284.1"> surpass. </span><span class="koboSpan" id="kobo.284.2">In cases where growth is declining, a </span><strong class="bold"><span class="koboSpan" id="kobo.285.1">floor</span></strong><span class="koboSpan" id="kobo.286.1"> must be stated as well. </span><span class="koboSpan" id="kobo.286.2">In</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.287.1"> this example, though, we have increasing growth, so we’ll only set the ceiling. </span><span class="koboSpan" id="kobo.287.2">Prophet refers to it as</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.288.1"> a </span><strong class="bold"><span class="koboSpan" id="kobo.289.1">cap</span></strong><span class="koboSpan" id="kobo.290.1">. </span><span class="koboSpan" id="kobo.290.2">To add this to Prophet, we need to create a new column in our training DataFrame called </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">cap</span></strong><span class="koboSpan" id="kobo.292.1"> and also mimic it in our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">future</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.294.1"> DataFrame.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">In general, determining a cap may pose some difficulties. </span><span class="koboSpan" id="kobo.295.2">If your curve is near the saturation level already, you can see better what value it is approaching and choose it. </span><span class="koboSpan" id="kobo.295.3">If not, however, then a little domain knowledge will really be your best solution. </span><span class="koboSpan" id="kobo.295.4">Before you can model logistic growth rates, you must have some idea of where the saturation level will eventually be. </span><span class="koboSpan" id="kobo.295.5">Usually, this cap is set using data or with special expertise about market size. </span><span class="koboSpan" id="kobo.295.6">For our example, we’ll set the cap to </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">500</span></strong><span class="koboSpan" id="kobo.297.1">, as that was the value estimated by </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">the ecologists:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
df['cap'] = 500</span></pre>
<p><span class="koboSpan" id="kobo.300.1">Next, we continue just as we did in the previous example, but this time, let’s set the growth mode to</span><a id="_idTextAnchor491"/> <strong class="source-inline"><span class="koboSpan" id="kobo.301.1">logistic</span></strong><span class="koboSpan" id="kobo.302.1">, before fitting and creating the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">future</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.304.1"> DataFrame:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.305.1">
model = Prophet(growth='logistic',
                yearly_seasonality=3,
                seasonality_mode='multiplicative')
model.fit(df)
future = model.make_future_dataframe(periods=12 * 10,
                                     freq='M')</span></pre>
<p><span class="koboSpan" id="kobo.306.1">We need to add the cap to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">future</span></strong><span class="koboSpan" id="kobo.308.1"> DataFrame </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.310.1">
future['cap'] = 500</span></pre>
<p><span class="koboSpan" id="kobo.311.1">Now, when we predict and plot the forecast, you’ll see quite a differently </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">shaped curve:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.313.1">
forecast = model.predict(future)
fig = model.plot(forecast)
add_changepoints_to_plot(fig.gca(), model, forecast,
                         cp_linestyle='')
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.314.1">By default, Prophet displays the cap (and floor if present) as horizontal dashed lines in </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">your plot:</span></span></p>
<p class="IMG---Figure"><a id="_idTextAnchor492"/></p>
<div>
<div class="IMG---Figure" id="_idContainer169">
<span class="koboSpan" id="kobo.316.1"><img alt="Figure 7.6 – Wolf population forecast with logistic growth" src="image/Fig_7.6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.317.1">Figure 7.6 – Wolf population forecast with logistic growth</span></p>
<p><span class="koboSpan" id="kobo.318.1">With </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.319.1">logistic growth, the</span><a id="_idTextAnchor493"/><span class="koboSpan" id="kobo.320.1"> wolf population is allowed to grow at</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.321.1"> roughly the same rate for several years. </span><span class="koboSpan" id="kobo.321.2">The growth rate slows as it approaches its saturation point, the greatest population that the natural resources available can support. </span><span class="koboSpan" id="kobo.321.3">After this point, the growth rate stays flat with just a bit of seasonal variation as old wolves die in the winter and spring </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">pups arrive</span><a id="_idTextAnchor494"/><a id="_idTextAnchor495"/><span class="koboSpan" id="kobo.323.1">.</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor496"/><span class="koboSpan" id="kobo.324.1">Non-constant cap</span></h2>
<p><span class="koboSpan" id="kobo.325.1">It is important to note that th</span><a id="_idTextAnchor497"/><span class="koboSpan" id="kobo.326.1">e cap</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.327.1"> does not necessarily need to be constant. </span><span class="koboSpan" id="kobo.327.2">If y</span><a id="_idTextAnchor498"/><span class="koboSpan" id="kobo.328.1">ou are forecasting sales, for example, your saturation limit will be the market size. </span><span class="koboSpan" id="kobo.328.2">But this market size may be growing as various factors cause more consumers to consider purchasing your product. </span><span class="koboSpan" id="kobo.328.3">Let’s look at a quick example of how to model this. </span><span class="koboSpan" id="kobo.328.4">We assumed that the wolf population in Yellowstone was constrained by the size of the park. </span><span class="koboSpan" id="kobo.328.5">Let’s now create a hypothetical situation where the park size is gradually increased starting in 2007, creating conditions that allow for two additional wolves </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">per month.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">Let’s create a function to set the cap. </span><span class="koboSpan" id="kobo.330.2">For dates prior to 2007, we will keep the park’s saturation limit of </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">500</span></strong><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">For all dates starting in 2007, though, we will increase the cap by two </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">per month:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.334.1">
def set_cap(row, df):
    if row.year &lt; 2007:
        return 500
    else:
        pop_2007 = 500
        idx_2007 = df[df['ds'].dt.year == 2007].index[0]
        idx_date = df[df['ds'] == row].index[0]
        return pop_2007 + 2 * (idx_date - idx_2007)</span></pre>
<p><span class="koboSpan" id="kobo.335.1">Now, let’s set t</span><a id="_idTextAnchor499"/><span class="koboSpan" id="kobo.336.1">he cap for our traini</span><a id="_idTextAnchor500"/><span class="koboSpan" id="kobo.337.1">ng </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">DataFrame, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">df</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.341.1">
df['cap'] = df['ds'].apply(set_cap, args=(df,))</span></pre>
<p><span class="koboSpan" id="kobo.342.1">The cap should remain </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">500</span></strong><span class="koboSpan" id="kobo.344.1"> throughout, as our training data ends in 2004. </span><span class="koboSpan" id="kobo.344.2">Now, let’s create our model the same as before, but set our </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">future</span></strong><span class="koboSpan" id="kobo.346.1"> DataFrame using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">set_cap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.348.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.349.1">
model = Prophet(growth='logistic',
                yearly_seasonality=3,
                seasonality_mode='multiplicative')
model.fit(df)
future = model.make_future_dataframe(periods=12 * 10,
                                     freq='M')
future['cap'] = future['ds'].apply(set_cap, args=(future,))
forecast = model.predict(future)
fig = model.plot(forecast)
add_changepoints_to_plot(fig.gca(), model, forecast,
                          cp_linestyle='')
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.350.1">Now, you can see that t</span><a id="_idTextAnchor501"/><span class="koboSpan" id="kobo.351.1">he wolf </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.352.1">population is asymptotically approach</span><a id="_idTextAnchor502"/><span class="koboSpan" id="kobo.353.1">ing our </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">increasing ca</span><a id="_idTextAnchor503"/><span class="koboSpan" id="kobo.355.1">p:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer170">
<span class="koboSpan" id="kobo.356.1"><img alt="Figure 7.7 – Wolf population forecast with non-constant cap" src="image/Fig_7.7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.357.1">Figure 7.7 – Wolf population forecast with non-constant cap</span></p>
<p><span class="koboSpan" id="kobo.358.1">The cap is simply a value set for each row in the DataFrame; for every date, you can set whichever value makes sense. </span><span class="koboSpan" id="kobo.358.2">The cap may be constant, as in our first example, it may vary linearly, as</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.359.1"> we have j</span><a id="_idTextAnchor504"/><span class="koboSpan" id="kobo.360.1">ust done here, or it may follow any arbitrary curve</span><a id="_idTextAnchor505"/><span class="koboSpan" id="kobo.361.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">your choosing.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">Now, let’s look at the reverse situation, a hypothetical situation where the wolf population is sadly declining and </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">approaching extincti</span><a id="_idTextAnchor506"/><a id="_idTextAnchor507"/><span class="koboSpan" id="kobo.365.1">on.</span></span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor508"/><span class="koboSpan" id="kobo.366.1">Decreasing logistic growth</span></h2>
<p><span class="koboSpan" id="kobo.367.1">The only difference in t</span><a id="_idTextAnchor509"/><span class="koboSpan" id="kobo.368.1">his example is </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.369.1">that we must also state a </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">floor</span></strong><span class="koboSpan" id="kobo.371.1"> v</span><a id="_idTextAnchor510"/><span class="koboSpan" id="kobo.372.1">alue in addition to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">cap</span></strong><span class="koboSpan" id="kobo.374.1"> value. </span><span class="koboSpan" id="kobo.374.2">Let’s build another pseudo-random dataset but with </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">negative growth:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.376.1">
x = pd.to_datetime(pd.date_range('1995-01','2035-02',
                                 freq='M')\
                   .strftime("%Y-%b").tolist())
y = [1 - 1 / (1 + np.e ** (-.03 * (val - 50))) for val in \
     range(len(x))]  # create logistic curve
# add sinusoidal variation
y = [y[idx] + y[idx] * .05 * np.sin((idx - 2) * (360 / 12)\
     * (np.pi / 180)) for idx in range(len(y))]
# add noise
y = [val + 5 * val * random.uniform(-.01, .01) for val \
     in y]
y = [int(500 * val) for val in y]  # scale up
plt.figure(figsize=(10, 6))
plt.plot(x, y)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.377.1">The growth curve should look </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer171">
<span class="koboSpan" id="kobo.379.1"><img alt="Figure 7.8 – Simulated declining wolf population in Yellowstone" src="image/Fig_7.8.jpg"/></span>
</div>
</div>
<p class="IMG---Figure"><a id="_idTextAnchor511"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.380.1">Figure 7.8 – Simulated declining wolf population in Yellowstone</span></p>
<p><span class="koboSpan" id="kobo.381.1">For our</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.382.1"> forecast in this case, we’ll </span><a id="_idTextAnchor512"/><span class="koboSpan" id="kobo.383.1">cut off the data at </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">2006</span></strong><span class="koboSpan" id="kobo.385.1"> and attempt to </span><a id="_idTextAnchor513"/><span class="koboSpan" id="kobo.386.1">predict when there will be no more wolves in the population. </span><span class="koboSpan" id="kobo.386.2">When creating our DataFrame, we specify both a </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">cap</span></strong><span class="koboSpan" id="kobo.388.1"> value, as we did previously, and a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">floor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.390.1"> value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.391.1">
df2 = pd.DataFrame({'ds': pd.to_datetime(x), 'y': y})
df2 = df2[df2['ds'].dt.year &lt; 2006]
df2['cap'] = 500
df2['floor'] = 0</span></pre>
<p><span class="koboSpan" id="kobo.392.1">We’ll complete the model all in one step. </span><span class="koboSpan" id="kobo.392.2">Everything is the same as the previous examples, except this time, we also set </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">floor</span></strong><span class="koboSpan" id="kobo.394.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">future</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.396.1"> DataFrame:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.397.1">
model = Prophet(growth='logistic',
                yearly_seasonality=3,
                seasonality_mode='multiplicative')
model.fit(df2)
future = model.make_future_dataframe(periods=12 * 10,
                                     freq='M')
future['cap'] = 500
future['floor'] = 0
forecast = model.predict(future)
fig = model.plot(forecast)
add_changepoints_to_plot(fig.gca(), model, forecast,
                         cp_linestyle='')
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.398.1">It should </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.399.1">come as no surprise that Prophet handles this case </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">with ease:</span></span></p>
<p class="IMG---Figure"><a id="_idTextAnchor514"/></p>
<div>
<div class="IMG---Figure" id="_idContainer172">
<span class="koboSpan" id="kobo.401.1"><img alt="Figure 7.9 – Wolf population forecast with decreasing logistic growth" src="image/Fig_7.9.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.402.1">Figure 7.9 – Wolf population forecast with decreasing logistic growth</span></p>
<p><span class="koboSpan" id="kobo.403.1">Prophet will predict precise </span><a id="_idTextAnchor515"/><span class="koboSpan" id="kobo.404.1">decimal values and, of course, wolves </span><a id="_idTextAnchor516"/><span class="koboSpan" id="kobo.405.1">exist in integer values, but this plot shows that somewhere between 2010 and 2014, the wolf population will die off. </span><span class="koboSpan" id="kobo.405.2">In a real scenario, it also matters greatly whether the last few remaining wolves are part of a breeding pair, and we have ignored that </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">factor here.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">Notice that because we have specified both a cap and a floor, Prophet has plotted both as horizontal dashed lines. </span><span class="koboSpan" id="kobo.407.2">When logistic growth is declining, even if there is no relevant cap, as is the case here, one must be included in your model. </span><span class="koboSpan" id="kobo.407.3">You may choose one that is arbitrarily high with no effect on your model, although be aware that it will be included in your plot and may make it appear as if Prophet’s forecast is </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">very low.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">You can, however, exclude it from your plots by including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">plot_cap</span></strong><span class="koboSpan" id="kobo.411.1"> argument as done here: </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">fig = model.plot(forecast, plot_cap=False)</span></strong><span class="koboSpan" id="kobo.413.1">, which modifies both the cap and the floor. </span><span class="koboSpan" id="kobo.413.2">Prophet does not currently support the exclusion of only one of these from </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">your plot.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">Prophet currently supports </span><a id="_idTextAnchor517"/><span class="koboSpan" id="kobo.416.1">one more growth mode: </span><strong class="bold"><span class="koboSpan" id="kobo.417.1">no growth (or flat)</span></strong><span class="koboSpan" id="kobo.418.1">. </span><span class="koboSpan" id="kobo.418.2">However, the Prophet team is at work on some other modes at the time of writing, and those may become available soon, so keep an eye on the documentation. </span><span class="koboSpan" id="kobo.418.3">Let’s take a look at this final </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">growth mode.</span></span></p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor518"/><a id="_idTextAnchor519"/><span class="koboSpan" id="kobo.420.1">Applying flat growth</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.421.1">Flat growth</span></strong><span class="koboSpan" id="kobo.422.1"> is when the trend </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.423.1">line</span><a id="_idTextAnchor520"/><span class="koboSpan" id="kobo.424.1"> is perfectly constant throughout the data. </span><span class="koboSpan" id="kobo.424.2">The data’s values only differ due to seasonality, holidays, extra regressors, or noise. </span><span class="koboSpan" id="kobo.424.3">To see how to</span><a id="_idTextAnchor521"/><span class="koboSpan" id="kobo.425.1"> model flat growth, let’s continue on with our wolf population but this time, consider far into the future when the population has </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">fully stabilized.</span></span></p>
<p><span class="koboSpan" id="kobo.427.1">Let’s begin by creating a</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.428.1"> new dataset – essentially, the same as our logistic growth dataset but with a much </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">longer timeframe:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.430.1">
x = pd.to_datetime(pd.date_range('1995-01','2096-02',
                                 freq='M')\
                   .strftime("%Y-%b").tolist())
# create logistic curve
y = [1 / (1 + np.e ** (-.03 * (val - 50))) for val in \
     range(len(x))]
 # add sinusoidal variation
y = [y[idx] + y[idx] * .01 * np.sin((idx - 2) * (360 / 12)\
     * (np.pi / 180)) for idx in range(len(y))]
# add noise
y = [val + 1 * val * random.uniform(-.01, .01) for val \
     in y]
y = [int(500 * val) for val in y]  # scale up
plt.figure(figsize=(10, 6))
plt.plot(x, y)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.431.1">We are now looking </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.432.1">forward a century from when the wolves were re-introduced into </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">the park</span><a id="_idTextAnchor522"/><span class="koboSpan" id="kobo.434.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer173">
<span class="koboSpan" id="kobo.435.1"><img alt="Figure 7.10 – Simulated wolf population over a century" src="image/Fig_7.10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.436.1">Figure 7.10 – Simulated wolf population over a century</span></p>
<p><span class="koboSpan" id="kobo.437.1">After this length of </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.438.1">time, the wo</span><a id="_idTextAnchor523"/><span class="koboSpan" id="kobo.439.1">lf population has reached the saturation point and is fully stabilized. </span><span class="koboSpan" id="kobo.439.2">We will now create our training DataFrame, but then only limit our data to the last decade of the range, where the overall trend is already </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">well saturated:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.441.1">
df = pd.DataFrame({'ds': pd.to_datetime(x), 'y': y})
df = df[df['ds'].dt.year &gt; 2085]
plt.figure(figsize=(10, 6))
plt.plot(df['ds'], df['y'])
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.442.1">Plotting that da</span><a id="_idTextAnchor524"/><span class="koboSpan" id="kobo.443.1">ta should show no overall growth, just very </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">noisy seasonality</span><a id="_idTextAnchor525"/><span class="koboSpan" id="kobo.445.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer174">
<span class="koboSpan" id="kobo.446.1"><img alt="Figure 7.11 – Simulated stable wolf population" src="image/Fig_7.11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.447.1">Figure 7.11 – Simulated stable wolf population</span></p>
<p><span class="koboSpan" id="kobo.448.1">Let’s first use the </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.449.1">default linear growth to see what could </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">go wrong:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.451.1">
model = Prophet(growth='linear',
                yearly_seasonality=3,
                seasonality_mode='multiplicative')
model.fit(df)
future = model.make_future_dataframe(periods=12 * 10,
                                     freq='M')
forecast = model.predict(future)
fig = model.plot(forecast)
add_changepoints_to_plot(fig.gca(), model, forecast,
                         cp_linestyle='')
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.452.1">Due to random </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.453.1">noise in the data, Prophet will find brief areas where there seems to be a trend, either positive or negative. </span><span class="koboSpan" id="kobo.453.2">If one of these periods occurs at the end of the training data, then that curve will continue for the entire output of forecasted </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">future dat</span><a id="_idTextAnchor526"/><span class="koboSpan" id="kobo.455.1">a:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer175">
<span class="koboSpan" id="kobo.456.1"><img alt="Figure 7.12 – Stable wolf population forecast with linear growth" src="image/Fig_7.12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.457.1">Figure 7.12 – Stable wolf population forecast with linear growth</span></p>
<p><span class="koboSpan" id="kobo.458.1">As you can see, Proph</span><a id="_idTextAnchor527"/><span class="koboSpan" id="kobo.459.1">et predicts that the wolf population is decreasing, even though it is quite stable. </span><span class="koboSpan" id="kobo.459.2">Furthermore, the uncertainty intervals are growing; Prophet is smart enough to know this isn’t quite right. </span><span class="koboSpan" id="kobo.459.3">Now let’s model this correctly—with flat growth. </span><span class="koboSpan" id="kobo.459.4">Because the trend will be constant, setting a seasonality mode is irrelevant. </span><span class="koboSpan" id="kobo.459.5">It will still be calculated as either additive or multiplicative, but the end result will be the same in either case. </span><span class="koboSpan" id="kobo.459.6">We will ignore </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">it here.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Creating a</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.462.1"> model with flat growth is as simple as setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">growth='flat'</span></strong><span class="koboSpan" id="kobo.464.1"> during </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">model instantiation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.466.1">
model = Prophet(growth='flat',
                yearly_seasonality=3)
model.fit(df)
future = model.make_future_dataframe(periods=12 * 10,
                                     freq='M')
forecast = model.predict(future)
fig = model.plot(forecast)
add_changepoints_to_plot(fig.gca(), model, forecast,
                         cp_linestyle='')
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.467.1">Now, Prophe</span><a id="_idTextAnchor528"/><span class="koboSpan" id="kobo.468.1">t’s trend line is </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">perfectly fla</span><a id="_idTextAnchor529"/><span class="koboSpan" id="kobo.470.1">t:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer176">
<span class="koboSpan" id="kobo.471.1"><img alt="Figure 7.13 – Stable wolf population forecast with flat growth" src="image/Fig_7.13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.472.1">Figure 7.13 – Stable wolf population forecast with flat growth</span></p>
<p><span class="koboSpan" id="kobo.473.1">No matter </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.474.1">how far out</span><a id="_idTextAnchor530"/><span class="koboSpan" id="kobo.475.1"> we forecast, the trend will be stable. </span><span class="koboSpan" id="kobo.475.2">The only variation in Prophet’s model in this example comes from the yearly seasonality, as we added no holidays and neither daily nor weekly seasonalities </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">were included.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">These three growth modes—linear, logistic, and flat—are by far the most commonly used in the industry and can cover nearly every forecasting task that most analysts will see. </span><span class="koboSpan" id="kobo.477.2">However, cases do sometimes arise where the analyst needs a custom growth mode. </span><span class="koboSpan" id="kobo.477.3">Although it is not the simplest task, Prophet does have the capability to accept any growth mode you can </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">mathematically define.</span></span></p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor531"/><span class="koboSpan" id="kobo.479.1">Creating a custom trend</span></h1>
<p><span class="koboSpan" id="kobo.480.1">A key advantage of </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.481.1">open source software is that any user can download the source code and make their own modifications to better suit the software to their own use case. </span><span class="koboSpan" id="kobo.481.2">Although nearly all common time series can be appropriately modeled with the three trend modes implemented in Prophet (piecewise linear, piecewise logistic, and flat), there may be cases when you need a different trend model than provided; as Prophet is open source, it is relatively easy to create whatever you need. </span><span class="koboSpan" id="kobo.481.3">A quick caveat though: it is </span><em class="italic"><span class="koboSpan" id="kobo.482.1">relatively easy</span></em><span class="koboSpan" id="kobo.483.1"> only conceptually. </span><span class="koboSpan" id="kobo.483.2">Mathematically, it can be quite complex, and you must have solid software engineering skills to understand how to modify the </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">code successfully.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">Let’s look at an example of what is possible. </span><span class="koboSpan" id="kobo.485.2">Consider a small clothing retailer, which updates its collection for </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">each season:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.487.1">
df = pd.read_csv('../data/clothing_retailer.csv')
df['ds'] = pd.to_datetime(df['ds'])</span></pre>
<p><span class="koboSpan" id="kobo.488.1">Daily sales are </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.489.1">highly dependent upon the popularity of the collection currently available, so the trend is mostly flat but sees dramatic step changes every three months when a new collection </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">is released:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer177">
<span class="koboSpan" id="kobo.491.1"><img alt="Figure 7.14 – Daily sales (in thousands) at a clothing retailer" src="image/Fig_7.14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.492.1">Figure 7.14 – Daily sales (in thousands) at a clothing retailer</span></p>
<p><span class="koboSpan" id="kobo.493.1">We have two weeks of data for the new season, and we want to forecast sales for the rest of this season. </span><span class="koboSpan" id="kobo.493.2">None of Prophet’s available trend models would capture this very well. </span><span class="koboSpan" id="kobo.493.3">Our best option would be to use the default growth model, linear. </span><span class="koboSpan" id="kobo.493.4">Let’s see what happens though when we </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">try this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.495.1">
model = Prophet()
model.fit(df)
future = model.make_future_dataframe(76)
forecast = model.predict(future)
fig = model.plot(forecast)
add_changepoints_to_plot(fig.gca(), model, forecast)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.496.1">The resulting </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.497.1">forecast has too many </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">dramatic changepoints:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer178">
<span class="koboSpan" id="kobo.499.1"><img alt="Figure 7.15 – Unsuitable linear forecast" src="image/Fig_7.15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.500.1">Figure 7.15 – Unsuitable linear forecast</span></p>
<p><span class="koboSpan" id="kobo.501.1">The confidence interval explodes in the forecast period because the model is expecting more potential changepoints; and it also ignores the fact that the data has been flat for the previous three months, predicting an absurd ongoing hockey-stick growth rate. </span><span class="koboSpan" id="kobo.501.2">A flat growth model would be better, but as implemented in Prophet, it cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">handle changepoints.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">This is where the process becomes complex and very heavy on software engineering skills. </span><span class="koboSpan" id="kobo.503.2">We need to create a custom trend model. </span><span class="koboSpan" id="kobo.503.3">In a nutshell, the necessary code needs to copy the Prophet class from Prophet’s source code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">forecaster.py</span></strong><span class="koboSpan" id="kobo.505.1"> file at </span><a href="https://github.com/facebook/prophet/blob/main/python/prophet/forecaster.py"><span class="koboSpan" id="kobo.506.1">https://github.com/facebook/prophet/blob/main/python/prophet/forecaster.py</span></a><span class="koboSpan" id="kobo.507.1">, and make some modifications. </span><span class="koboSpan" id="kobo.507.2">In particular, this new class (in the example in our GitHub repository at </span><a href="https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition"><span class="koboSpan" id="kobo.508.1">https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition</span></a><span class="koboSpan" id="kobo.509.1">, we’re calling it </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">ProphetStepWise</span></strong><span class="koboSpan" id="kobo.511.1">) inherits all methods and properties from the base </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">Prophet</span></strong><span class="koboSpan" id="kobo.513.1"> class and modifies it in a </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">few ways:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.515.1">It modifies</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.516.1"> the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">Prophet</span></strong><span class="koboSpan" id="kobo.518.1"> class’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">fit</span></strong><span class="koboSpan" id="kobo.520.1"> function to initialize the new stepwise </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">growth mode.</span></span></li>
<li><span class="koboSpan" id="kobo.522.1">It creates a new function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">stepwise_growth_init</span></strong><span class="koboSpan" id="kobo.524.1">, similar to the current </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">flat_growth_init</span></strong><span class="koboSpan" id="kobo.526.1"> function, which initializes the trend with flat growth. </span><span class="koboSpan" id="kobo.526.2">The current </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">flat_growth_init</span></strong><span class="koboSpan" id="kobo.528.1"> function sets an offset parameter equal to the mean of historic values, but this new </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">stepwise_growth_init</span></strong><span class="koboSpan" id="kobo.530.1"> function considers changepoint locations and applies varying offset parameters between </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">each changepoint.</span></span></li>
<li><span class="koboSpan" id="kobo.532.1">It creates a new function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">stepwise_trend</span></strong><span class="koboSpan" id="kobo.534.1">, analogous to the existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">flat_trend</span></strong><span class="koboSpan" id="kobo.536.1"> function, which evaluates the new </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">stepwise trend.</span></span></li>
<li><span class="koboSpan" id="kobo.538.1">It modifies the existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">sample_predictive_trend</span></strong><span class="koboSpan" id="kobo.540.1"> function to redefine the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">'flat'</span></strong><span class="koboSpan" id="kobo.542.1"> growth mode to use the new </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">stepwise_trend</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.544.1"> function.</span></span></li>
<li><span class="koboSpan" id="kobo.545.1">And lastly, it modifies the existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">predict_trend</span></strong><span class="koboSpan" id="kobo.547.1"> function to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">stepwise_trend</span></strong><span class="koboSpan" id="kobo.549.1"> instead of the existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">flat_trend</span></strong><span class="koboSpan" id="kobo.551.1"> function when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">'flat'</span></strong><span class="koboSpan" id="kobo.553.1"> growth </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">is set.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.555.1">The full code for all of these steps is too long and bespoke to reproduce fully here, but all code is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">Chapter07</span></strong><span class="koboSpan" id="kobo.557.1"> folder located in our GitHub repo linked </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">to previously.</span></span></p>
<p><span class="koboSpan" id="kobo.559.1">Once this new </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">ProphetStepWise</span></strong><span class="koboSpan" id="kobo.561.1"> class is created, we can use it just like the standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">Prophet</span></strong><span class="koboSpan" id="kobo.563.1"> class to make forecasts. </span><span class="koboSpan" id="kobo.563.2">Here, we will declare the growth as </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">'flat'</span></strong><span class="koboSpan" id="kobo.565.1"> and manually provide the location of each changepoint (the changepoints all coincide with the first date of each new clothing season—but don’t concern yourself with these details for now; changepoints will be discussed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">next chapter!):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.567.1">
model = ProphetStepWise(growth='flat',
                        changepoints= ['2021-04-01',
                                       '2021-07-01',
                                       '2021-10-01',
                                       '2022-01-01',
                                       '2022-04-01',
                                       '2022-07-01',
                                       '2022-10-01'])
model.fit(df)
future = model.make_future_dataframe(76)
forecast = model.predict(future)
fig = model.plot(forecast)
add_changepoints_to_plot(fig.gca(), model, forecast, threshold=0.00);</span></pre>
<p><span class="koboSpan" id="kobo.568.1">The resulting</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.569.1"> forecast looks much </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">more reasonable!</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer179">
<span class="koboSpan" id="kobo.571.1"><img alt="Figure 7.16 – Our new stepwise trend" src="image/Fig_7.16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.572.1">Figure 7.16 – Our new stepwise trend</span></p>
<p><span class="koboSpan" id="kobo.573.1">You’ll note, however, that although the forecast for the rest of the season is pretty much spot-on, the confidence </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.574.1">intervals are unfortunately extremely wide. </span><span class="koboSpan" id="kobo.574.2">In order to fix this issue, you’ll need to also modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">prophet.stan</span></strong><span class="koboSpan" id="kobo.576.1"> file. </span><span class="koboSpan" id="kobo.576.2">As this book is only working with Python code, these changes in the Stan model are out of scope. </span><span class="koboSpan" id="kobo.576.3">However, for those interested, there is an excellent example of this stepwise trend model with the correctly implemented Stan changes available as a pull request in the official Prophet GitHub repo: </span><a href="https://github.com/facebook/prophet/pull/1466/files"><span class="koboSpan" id="kobo.577.1">https://github.com/facebook/prophet/pull/1466/files</span></a><span class="koboSpan" id="kobo.578.1">. </span><span class="koboSpan" id="kobo.578.2">In fact, much of the code in this section came from </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">that ex</span><a id="_idTextAnchor532"/><a id="_idTextAnchor533"/><span class="koboSpan" id="kobo.580.1">ample.</span></span></p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor534"/><span class="koboSpan" id="kobo.581.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.582.1">In this chapter, you learned that the models we built in the first few chapters of this book all featured linear growth. </span><span class="koboSpan" id="kobo.582.2">You learned that the logistic function was developed to model population growth and then learned how to implement this in Prophet by modeling the growth of the wolf population in Yellowstone after their reintroduction </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">in 1995.</span></span></p>
<p><span class="koboSpan" id="kobo.584.1">Logistic growth in Prophet can be modeled as either increasing up to a saturation limit called the </span><a id="_idTextAnchor535"/><em class="italic"><span class="koboSpan" id="kobo.585.1">cap</span></em><span class="koboSpan" id="kobo.586.1"> or decreasing to a saturation</span><a id="_idTextAnchor536"/><span class="koboSpan" id="kobo.587.1"> limit called the </span><em class="italic"><span class="koboSpan" id="kobo.588.1">floor</span></em><span class="koboSpan" id="kobo.589.1">. </span><span class="koboSpan" id="kobo.589.2">Finally, you learned how to model flat (or no growth) trends, where the trend is fixed to one value for the entire data period but seasonality is still allowed to vary. </span><span class="koboSpan" id="kobo.589.3">Throughout this chapter, you used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">add_changepoints_to_plot</span></strong><span class="koboSpan" id="kobo.591.1"> function in order to overlay the trend line on your </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">forecast plots.</span></span></p>
<p><span class="koboSpan" id="kobo.593.1">Choosing the correct growth mode is important, particularly so when forecasting further into the future. </span><span class="koboSpan" id="kobo.593.2">We looked at a couple of examples in this chapter where the incorrect growth mode fitted the actual data well, but the future forecasts became quite unrealistic. </span><span class="koboSpan" id="kobo.593.3">Finally, we saw an example of creating a custom trend model. </span><span class="koboSpan" id="kobo.593.4">This process is the most advanced technique covered in this book but is also the most powerful, as it demonstrates how to take advantage of Prophet’s open source code to fully customize the package for your specific needs. </span><span class="koboSpan" id="kobo.593.5">In the next chapter, you’ll learn all about changepoints and how to use them to gain even more control over your </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">trend lines.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer181">
</div>
</div>
</body></html>