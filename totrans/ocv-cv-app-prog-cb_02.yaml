- en: Chapter 2. Manipulating Pixels
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 操作像素
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Accessing pixel values
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问像素值
- en: Scanning an image with pointers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指针扫描图像
- en: Scanning an image with iterators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器扫描图像
- en: Writing efficient image-scanning loops
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写高效的图像扫描循环
- en: Scanning an image with neighbor access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用邻接访问扫描图像
- en: Performing simple image arithmetic
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行简单的图像算术
- en: Remapping an image
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重映射图像
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In order to build computer vision applications, you need to be able to access
    the image content and eventually modify or create images. This chapter will teach
    you how to manipulate the picture elements (also known as **pixels**). You will
    learn how to scan an image and process each of its pixels. You will also learn
    how to do this efficiently, since even images of modest dimensions can contain
    hundreds of thousands of pixels.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建计算机视觉应用，你需要能够访问图像内容，并最终修改或创建图像。本章将教你如何操作图像元素（也称为**像素**）。你将学习如何扫描图像并处理其每个像素。你还将学习如何高效地完成这项工作，因为即使是尺寸适中的图像也可能包含数十万个像素。
- en: Fundamentally, an image is a matrix of numerical values. This is why, as we
    learned in [Chapter 1](part0014_split_000.html#page "Chapter 1. Playing with Images"),
    *Playing with Images*, OpenCV 2 manipulates them using the `cv::Mat` data structure.
    Each element of the matrix represents one pixel. For a gray-level image (a black-and-white
    image), pixels are unsigned 8-bit values where `0` corresponds to black and `255`
    corresponds to white. In the case of color images, three primary color values
    are required in order to reproduce the different visible colors. This is a consequence
    of the fact that our human visual system is **trichromatic**; three types of cone
    cells on our retinae convey the color information to our brain. This means that
    for a color image, three values must be associated to each pixel. In photography
    and digital imaging, the commonly used primary color channels are red, green,
    and blue. A matrix element is, therefore, made of a triplet of 8-bit values in
    this case.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，图像是一个数值矩阵。这就是为什么，正如我们在[第1章](part0014_split_000.html#page "第1章. 玩转图像")中学习的，“玩转图像”，OpenCV
    2使用`cv::Mat`数据结构来操作它们。矩阵中的每个元素代表一个像素。对于灰度图像（黑白图像），像素是无符号8位值，其中`0`对应黑色，`255`对应白色。在彩色图像的情况下，需要三个主要颜色值来重现不同的可见颜色。这是由于我们的视觉系统是**三原色**的；视网膜上的三种锥状细胞将颜色信息传递给大脑。这意味着对于彩色图像，每个像素必须关联三个值。在摄影和数字成像中，常用的主要颜色通道是红色、绿色和蓝色。在这种情况下，矩阵元素由三个8位值的组合组成。
- en: Note that even if 8-bit channels are generally sufficient, there are specialized
    applications where 16-bit channels are required (medical imaging, for example).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管8位通道通常足够，但在某些特殊应用中（例如医学成像）需要16位通道。
- en: As we saw in the previous chapter, OpenCV also allows you to create matrices
    (or images) with pixel values of other types, for example, integer (`CV_32U` or
    `CV_32S`) and floating point (`CV_32F`) numbers. These are very useful to store,
    for example, intermediate values in some image-processing tasks. Most operations
    can be applied on matrices of any type; others require a specific type or work
    only with a given number of channels. Therefore, a good understanding of a function's
    or method's preconditions is essential in order to avoid common programming errors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，OpenCV还允许你创建具有其他类型像素值（例如，整数`CV_32U`或`CV_32S`）和浮点数（`CV_32F`）的矩阵（或图像）。这些对于存储某些图像处理任务中的中间值非常有用。大多数操作可以应用于任何类型的矩阵；其他操作需要特定的类型或仅与特定数量的通道一起工作。因此，为了避免常见的编程错误，理解函数或方法的先决条件至关重要。
- en: 'Throughout this chapter, we use the following color image as the input (refer
    to the book''s graphics PDF to view this image in color):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用以下彩色图像作为输入（请参阅书籍的图形PDF以查看此图像的颜色）：
- en: '![Introduction](img/00012.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/00012.jpeg)'
- en: Accessing pixel values
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问像素值
- en: In order to access each individual element of a matrix, you just need to specify
    its row and column numbers. The corresponding element, which can be a single numerical
    value or a vector of values in the case of a multi-channel image, will be returned.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问矩阵的每个单独元素，你只需指定其行和列号。相应的元素，在多通道图像的情况下可以是单个数值或值的向量，将被返回。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To illustrate the direct access to pixel values, we will create a simple function
    that adds **salt-and-pepper noise** to an image. As the name suggests, salt-and-pepper
    noise is a particular type of noise in which some randomly selected pixels are
    replaced by a white or a black pixel. This type of noise can occur in faulty communications
    when the value of some pixels is lost during the transmission. In our case, we
    will simply randomly select a few pixels and assign them a white color.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明对像素值的直接访问，我们将创建一个简单的函数，该函数向图像添加**盐和胡椒噪声**。正如其名所示，盐和胡椒噪声是一种特定的噪声，其中一些随机选择的像素被白色或黑色像素所替代。这种类型的噪声可能在通信故障中发生，当某些像素值在传输过程中丢失时。在我们的例子中，我们将简单地随机选择一些像素并将它们指定为白色。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We create a function that receives an input image. This is the image that will
    be modified by our function. The second parameter is the number of pixels on which
    we want to overwrite white values:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个函数，该函数接收一个输入图像。这是我们函数将要修改的图像。第二个参数是我们想要覆盖白色值的像素数：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding function is made of a single loop that assigns `n` times the value
    `255` to randomly selected pixels. Here, the pixel column `i` and row `j` are
    selected using a random number generator. Note that using the `type` method, we
    distinguish the two cases of gray-level and color images. In the case of a gray-level
    image, the number `255` is assigned to the single 8-bit value. For a color image,
    you need to assign `255` to the three primary color channels in order to obtain
    a white pixel.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数由一个循环组成，该循环将 `255` 的值赋给随机选择的像素 `n` 次。在这里，使用随机数生成器选择像素列 `i` 和行 `j`。请注意，使用
    `type` 方法，我们区分了灰度图像和彩色图像的两种情况。在灰度图像的情况下，将 `255` 赋给单个 8 位值。对于彩色图像，您需要将 `255` 赋给三个主颜色通道，以获得白色像素。
- en: 'You can call this function by passing it an image you have previously opened.
    Refer to the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过传递之前已打开的图像来调用此函数。请参考以下代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The resulting image will look as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图像将如下所示：
- en: '![How to do it...](img/00013.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00013.jpeg)'
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `cv::Mat` class includes several methods to access the different attributes
    of an image. The public member variables, `cols` and `rows`, give you the number
    of columns and rows in the image. For element access, `cv::Mat` has the `at` (`int
    y`, `int x`) method. However, the type returned by a method must be known at compile
    time, and since `cv::Mat` can hold elements of any type, the programmer needs
    to specify the return type that is expected. This is why the `at` method has been
    implemented as a template method. So, when you call it, you must specify the image
    element type as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::Mat` 类包括几个方法来访问图像的不同属性。公共成员变量 `cols` 和 `rows` 给出了图像中的列数和行数。对于元素访问，`cv::Mat`
    有 `at` (`int y`, `int x`) 方法。然而，方法的返回类型必须在编译时已知，并且由于 `cv::Mat` 可以持有任何类型的元素，程序员需要指定预期的返回类型。这就是为什么
    `at` 方法被实现为一个模板方法。因此，当您调用它时，您必须指定图像元素类型，如下所示：'
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is important to note that it is the programmer's responsibility to make sure
    that the type specified matches the type contained in the matrix. The `at` method
    does not perform any type conversion.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，确保指定的类型与矩阵中包含的类型相匹配是程序员的职责。`at` 方法不执行任何类型转换。
- en: 'In color images, each pixel is associated with three components: the red, green,
    and blue channels. Therefore, a `cv::Mat` class that contains a color image will
    return a vector of three 8-bit values. OpenCV has defined a type for such short
    vectors, and it is called `cv::Vec3b`. This is a vector of three **unsigned characters**.
    This explains why the element access to the pixels of a color pixel is written
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在彩色图像中，每个像素都与三个组件相关联：红色、绿色和蓝色通道。因此，包含彩色图像的 `cv::Mat` 类将返回一个包含三个 8 位值的向量。OpenCV
    为此类短向量定义了一个类型，称为 `cv::Vec3b`。这是一个包含三个**无符号字符**的向量。这解释了为什么对彩色像素的元素访问被写成如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `channel` index designates one of the three color channels. OpenCV stores
    the channel values in the order blue, green, and red (blue is, therefore, channel
    `0`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`channel` 索引指定了三个颜色通道中的一个。OpenCV 按顺序存储通道值：蓝色、绿色和红色（因此，蓝色是通道 `0`）。'
- en: Similar vector types also exist for 2-element and 4-element vectors (`cv::Vec2b`
    and `cv::Vec4b`) as well as for other element types. For example, for a 2-element
    float vector, the last letter of the type name would be replaced by an f, that
    is, `cv::Vec2f`. In the case of a short integer, the last letter is replaced with
    `s`, with `i` for an integer, and with `d` for a double precision floating point
    vector. All of these types are defined using the `cv::Vec<T,N>` template class,
    where `T` is the type and `N` is the number of vector elements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 类似向量类型也存在用于 2 元素和 4 元素向量（`cv::Vec2b` 和 `cv::Vec4b`）以及其他元素类型。例如，对于 2 元素浮点向量，类型名称的最后一个字母会被替换为
    f，即 `cv::Vec2f`。对于短整数，最后一个字母被替换为 s，对于整数是 i，对于双精度浮点向量是 d。所有这些类型都是使用 `cv::Vec<T,N>`
    模板类定义的，其中 `T` 是类型，`N` 是向量元素的数量。
- en: As a last note, you might have been surprised by the fact that our image-modifying
    function uses a pass-by-value image parameter. This works because when images
    are copied, they still share the same image data. So, you do not have to necessarily
    transmit images by references when you want to modify their content. Incidentally,
    pass-by-value parameters often make code optimization easier for the compiler.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点，你可能对我们的图像修改函数使用按值传递的图像参数的事实感到惊讶。这是因为当图像被复制时，它们仍然共享相同的图像数据。因此，当你想要修改它们的内容时，并不一定需要通过引用传递图像。顺便提一下，按值传递的参数通常使编译器更容易进行代码优化。
- en: There's more...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `cv::Mat` class has been made generic by defining it using C++ templates.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::Mat` 类是通过使用 C++ 模板定义的，使其成为泛型。'
- en: The cv::Mat_ template class
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`cv::Mat_` 模板类'
- en: 'Using the `at` method of the `cv::Mat` class can sometimes be cumbersome because
    the returned type must be specified as a template argument in each call. In cases
    where the matrix type is known, it is possible to use the `cv::Mat_` class, which
    is a template subclass of `cv::Mat`. This class defines a few extra methods but
    no new data attributes so that pointers or references to one class can be directly
    converted to another class. Among the extra methods, there is `operator()`, which
    allows direct access to matrix elements. Therefore, if `image` is a `cv::Mat`
    variable that corresponds to a `uchar` matrix, then you can write the following
    code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cv::Mat` 类的 `at` 方法有时可能比较繁琐，因为每次调用时必须指定返回类型作为模板参数。在矩阵类型已知的情况下，可以使用 `cv::Mat_`
    类，它是 `cv::Mat` 的模板子类。这个类定义了一些额外的方法但没有新的数据属性，以便一个类的指针或引用可以直接转换为另一个类。在这些额外的方法中，有
    `operator()`，它允许直接访问矩阵元素。因此，如果 `image` 是一个对应于 `uchar` 矩阵的 `cv::Mat` 变量，那么你可以编写以下代码：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since the type of the `cv::Mat_` elements is declared when the variable is created,
    the `operator()` method knows at compile time which type is to be returned. Other
    than the fact that it is shorter to write, using the `operator()` method provides
    exactly the same result as the `at` method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `cv::Mat_` 元素的类型是在变量创建时声明的，`operator()` 方法在编译时就知道要返回哪种类型。除了写起来更短之外，使用 `operator()`
    方法提供的结果与 `at` 方法完全相同。
- en: See also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *There's more…* section of the *Scanning an image with pointers* recipe
    explains how to create a function with input and output parameters
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Scanning an image with pointers* 菜谱的 *There''s more…* 部分解释了如何创建具有输入和输出参数的函数'
- en: The *Writing efficient image-scanning loops* recipe proposes a discussion on
    the efficiency of this method
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高效图像扫描循环编写* 菜谱提出了关于这种方法效率的讨论'
- en: Scanning an image with pointers
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指针扫描图像
- en: In most image-processing tasks, you need to scan all pixels of the image in
    order to perform a computation. Considering the large number of pixels that will
    need to be visited, it is essential that you perform this task in an efficient
    way. This recipe, and the next one, will show you different ways of implementing
    efficient scanning loops. This recipe uses the pointer arithmetic.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数图像处理任务中，你需要扫描图像中的所有像素以执行计算。考虑到需要访问的大量像素，以高效的方式执行此任务至关重要。本菜谱以及下一个菜谱将向您展示实现高效扫描循环的不同方法。本菜谱使用指针算术。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will illustrate the image-scanning process by accomplishing a simple task:
    reducing the number of colors in an image.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过完成一个简单的任务来展示图像扫描过程：减少图像中的颜色数量。
- en: Color images are composed of 3-channel pixels. Each of these channels corresponds
    to the intensity value of one of the three primary colors, red, green, and blue.
    Since each of these values is an 8-bit unsigned character, the total number of
    colors is `256x256x256`, which is more than 16 million colors. Consequently, to
    reduce the complexity of an analysis, it is sometimes useful to reduce the number
    of colors in an image. One way to achieve this goal is to simply subdivide the
    RGB space into cubes of equal sizes. For example, if you reduce the number of
    colors in each dimension by `8`, then you would obtain a total of `32x32x32` colors.
    Each color in the original image is then assigned a new color value in the color-reduced
    image that corresponds to the value in the center of the cube to which it belongs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 彩色图像由3通道像素组成。这些通道中的每一个对应于三种主颜色之一——红色、绿色和蓝色的强度值。由于这些值中的每一个都是8位无符号字符，所以总共有`256x256x256`种颜色，这超过了一千六百万种颜色。因此，为了减少分析复杂性，有时减少图像中的颜色数量是有用的。实现这一目标的一种方法是将RGB空间简单地划分为大小相等的立方体。例如，如果你在每个维度上减少颜色的数量为`8`，那么你将获得总共`32x32x32`种颜色。原始图像中的每种颜色在颜色减少的图像中都被分配了一个新的颜色值，该值对应于它所属的立方体的中心值。
- en: Therefore, the basic color reduction algorithm is simple. If `N` is the reduction
    factor, then divide the value by `N` (the integer division, therefore, the reminder
    is lost) for each pixel in the image and for each channel of this pixel. Then,
    multiply the result by `N`; this will give you the multiple of `N` just below
    the input pixel value. Just add `N/2` and you obtain the central position of the
    interval between two adjacent multiples of `N`. If you repeat this process for
    each 8-bit channel value, then you will obtain a total of `256/N x 256/N x 256/N`
    possible color values.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本的颜色减少算法很简单。如果`N`是减少因子，那么将每个像素的值除以`N`（整数除法，因此，余数被丢失），对于图像中的每个像素以及每个通道。然后，将结果乘以`N`；这将给出刚好低于输入像素值的`N`的倍数。只需加上`N/2`，就可以获得两个相邻的`N`倍数之间的区间的中心位置。如果你为每个8位通道值重复此过程，那么你将获得总共`256/N
    x 256/N x 256/N`种可能的颜色值。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The signature of our color reduction function will be as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的颜色减少函数的签名将如下所示：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The user provides an image and the per-channel reduction factor. Here, the processing
    is done **in-place**, that is, the pixel values of the input image are modified
    by the function. See the *There's more…* section of this recipe for a more general
    function signature with input and output arguments.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 用户提供一张图像和每通道的减少因子。在这里，处理是**就地**进行的，也就是说，输入图像的像素值通过函数被修改。有关更通用的函数签名，包括输入和输出参数的详细信息，请参阅此食谱的*更多内容…*部分。
- en: 'The processing is simply done by creating a double loop that goes over all
    pixel values as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 处理很简单，只需创建一个双重循环，遍历所有像素值，如下所示：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This function can be tested using the following code snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码片段测试此函数：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will give you, for example, the following image (refer to the book''s
    graphics PDF to view this image in color):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下图像（请参考书籍的图形PDF查看此图像的颜色）：
- en: '![How to do it...](img/00014.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00014.jpeg)'
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In a color image, the first three bytes of the image data buffer give values
    of the upper-left pixel to the 3-color channel, the next three bytes are the values
    of the second pixel of the first row, and so on (remember that OpenCV uses, by
    default, the BGR channel order). An image of width `W` and height `H` would then
    require a memory block of `WxHx3` `uchars`. However, for efficiency reasons, the
    length of a row can be padded with a few extra pixels. This is because some multimedia
    processor chips (for example, the Intel MMX architecture) can process images more
    efficiently when their rows are multiples of 4 or 8\. Obviously, these extra pixels
    are not displayed or saved; their exact values are ignored. OpenCV designates
    the length of a padded row as the effective width. Obviously, if the image has
    not been padded with extra pixels, the effective width will be equal to the real
    image width. We have already learned that the `cols` and `rows` attributes give
    you the image's width and height; similarly, the `step` data attribute gives you
    the effective width in number of bytes. Even if your image is of a type other
    than `uchar`, the `step` data will still give you the number of bytes in a row.
    The size of a pixel element is given by the `elemSize` method (for example, for
    a 3-channel short integer matrix (`CV_16SC3`), `elemSize` will return `6`). Recall
    that the number of channels in the image is given by the `nchannels` method (which
    will be `1` for a gray-level image and `3` for a color image). Finally, the `total`
    method returns the total number of pixels (that is, the matrix entries) in the
    matrix.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在彩色图像中，图像数据缓冲区的第一个三个字节给出左上像素的3个颜色通道的值，接下来的三个字节是第一行的第二个像素的值，依此类推（记住，OpenCV默认使用BGR通道顺序）。一个宽度为`W`和高度为`H`的图像将需要一个`WxHx3`个`uchars`的内存块。然而，出于效率的考虑，行的长度可以通过添加一些额外的像素来填充。这是因为某些多媒体处理器芯片（例如，Intel
    MMX架构）在它们的行是4或8的倍数时可以更有效地处理图像。显然，这些额外的像素不会被显示或保存；它们的精确值被忽略。OpenCV将填充行的长度指定为有效宽度。显然，如果图像没有填充额外的像素，有效宽度将与实际图像宽度相等。我们已经了解到`cols`和`rows`属性给出了图像的宽度和高度；同样，`step`数据属性给出了以字节为单位的实际宽度。即使您的图像类型不是`uchar`，`step`数据也会给出每行的字节数。像素元素的大小由`elemSize`方法给出（例如，对于3通道短整数矩阵（`CV_16SC3`），`elemSize`将返回`6`）。回想一下，图像中的通道数由`nchannels`方法给出（对于灰度图像将是`1`，对于彩色图像将是`3`）。最后，`total`方法返回矩阵中的总像素数（即矩阵条目数）。
- en: 'The number of pixel values per row is then given by the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每行像素值的数量由以下代码给出：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To simplify the computation of the pointer arithmetic, the `cv::Mat` class
    offers a method that directly gives you the address of an image row. This is the
    `ptr` method. It is a template method that returns the address of row number `j`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化指针算术的计算，`cv::Mat`类提供了一个直接给出图像行地址的方法。这是`ptr`方法。它是一个模板方法，返回第`j`行的地址：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that in the processing statement, we could have equivalently used the
    pointer arithmetic to move from column to column. So, we could have written the
    following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在处理语句中，我们可以等效地使用指针算术从列到列移动。因此，我们可以编写以下代码：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There's more...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The color reduction function presented in this recipe provides just one way
    of accomplishing this task. You could also use other color reduction formulas.
    A more general version of the function would also allow the specification of distinct
    input and output images. The image scanning can also be made more efficient by
    taking into account the continuity of the image data. Finally, it is also possible
    to use regular low-level pointer arithmetic to scan the image buffer. All of these
    elements are discussed in the following subsections.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中提出的颜色减少函数提供了一种完成此任务的方法。您也可以使用其他颜色减少公式。该函数的更通用版本还可以指定不同的输入和输出图像。通过考虑图像数据的连续性，图像扫描也可以变得更加高效。最后，还可以使用常规的低级指针算术来扫描图像缓冲区。所有这些元素都在以下小节中讨论。
- en: Other color reduction formulas
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他颜色减少公式
- en: 'In our example, color reduction is achieved by taking advantage of an integer
    division that floors the division result to the nearest lower integer as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，颜色减少是通过利用整数除法将除法结果向下取整到最接近的较低整数来实现的，如下所示：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The reduced color could have also been computed using the modulo operator that
    brings us to the nearest multiple of `div` (the per-channel reduction factor)
    as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 减少后的颜色也可以使用取模运算符来计算，这将我们带到 `div`（每通道缩减因子）的最接近的倍数，如下所示：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another option would be to use bitwise operators. Indeed, if we restrict the
    reduction factor to a power of `2`, that is, `div=pow(2,n)`, then masking the
    first `n` bits of the pixel value would give us the nearest lower multiple of
    `div`. This mask would be computed by a simple bit shift as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用位运算符。确实，如果我们将缩减因子限制为 `2` 的幂，即 `div=pow(2,n)`，那么屏蔽像素值的第一个 `n` 位将给我们 `div`
    的最接近的较小倍数。这个掩码可以通过以下简单的位移来计算：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The color reduction would be given by the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色缩减将由以下代码给出：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In general, bitwise operations might lead to very efficient code, so they could
    constitute a powerful alternative when efficiency is a requirement.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，位运算可能会导致非常高效的代码，因此当效率是一个要求时，它们可以构成一个强大的替代方案。
- en: Having input and output arguments
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有输入和输出参数
- en: 'In our color reduction example, the transformation is directly applied to the
    input image, which is called an in-place transformation. This way, no extra image
    is required to hold the output result, which could save on the memory usage when
    it is a concern. However, in some applications, the user might want to keep the
    original image intact. The user would then be forced to create a copy of the image
    before calling the function. Note that the easiest way to create an identical
    deep copy of an image is to call the `clone` method; for example, take a look
    at the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的颜色缩减示例中，转换直接应用于输入图像，这被称为就地转换。这样，不需要额外的图像来保存输出结果，这可以在内存使用成为关注点时节省内存。然而，在某些应用中，用户可能希望保持原始图像不变。在这种情况下，用户将被迫在调用函数之前创建图像的副本。请注意，创建图像的相同深度副本的最简单方法是调用
    `clone` 方法；例如，看看以下代码：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This extra overload can be avoided by defining a function that gives the user
    the option to either use or not use in-place processing. The signature of the
    method would then be as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义一个函数，让用户选择是否使用就地处理，可以避免这个额外的重载。方法的签名将如下所示：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that the input image is now passed as a `const` reference, which means
    that this image will not be modified by the function. The output image is passed
    as a reference such that the calling function will see the output argument modified
    by this call. When in-place processing is preferred, the same image is specified
    as the input and output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输入图像现在作为 `const` 引用传递，这意味着该图像不会被函数修改。输出图像作为引用传递，以便调用函数可以看到输出参数被此调用修改。当首选就地处理时，相同的图像被指定为输入和输出：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If not, another `cv::Mat` instance can be provided; for example, take a look
    at the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是，可以提供一个另一个 `cv::Mat` 实例；例如，看看以下代码：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The key here is to first verify whether the output image has an allocated data
    buffer with a size and pixel type that matches the one of the input image. Very
    conveniently, this check is encapsulated inside the `create` method of `cv::Mat`.
    This is the method that is to be used when a matrix must be reallocated with a
    new size and type. If, by chance, the matrix already has the size and type specified,
    then no operation is performed and the method simply returns without touching
    the instance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于首先验证输出图像是否分配了与输入图像大小和像素类型匹配的数据缓冲区。非常方便的是，这个检查被封装在 `cv::Mat` 的 `create` 方法中。这是当矩阵必须用新的大小和类型重新分配时要使用的方法。如果矩阵已经指定了大小和类型，则不执行任何操作，该方法简单地返回而不修改实例。
- en: 'Therefore, our function should simply start with a call to `create` that builds
    a matrix (if necessary) of the same size and type as the input image:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的函数应该简单地从调用 `create` 开始，构建一个与输入图像大小和类型相同的矩阵（如果需要）：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The allocated memory block has a size of `total()*elemSize()`. The looping
    is then done with two pointers:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 分配的内存块大小为 `total()*elemSize()`。然后使用两个指针进行循环：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the case where the same image is provided as the input and output, this function
    becomes completely equivalent to the first version presented in this recipe. If
    another image is provided as the output, the function will work correctly irrespective
    of whether the image has or has not been allocated prior to the function call.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入和输出提供相同图像的情况下，此函数与本章中介绍的第一个版本完全等价。如果提供另一个图像作为输出，则无论在函数调用之前是否已分配图像，该函数都将正确工作。
- en: Efficient scanning of continuous images
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连续图像的高效扫描
- en: 'We previously explained that, for efficiency reasons, an image can be padded
    with extra pixels at the end of each row. However, it is interesting to note that
    when the image is unpadded, it can also be seen as a long one-dimensional array
    of `WxH` pixels. A convenient `cv::Mat` method can tell us whether the image has
    been padded or not. This is the `isContinuous` method that returns `true` if the
    image does not include padded pixels. Note that we could also check the continuity
    of the matrix by writing the following test:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前解释过，出于效率考虑，图像可以在每行的末尾填充额外的像素。然而，值得注意的是，当图像未填充时，它也可以被视为一个`WxH`像素的长一维数组。一个方便的`cv::Mat`方法可以告诉我们图像是否已填充。这是`isContinuous`方法，如果图像不包含填充像素则返回`true`。请注意，我们也可以通过以下测试来检查矩阵的连续性：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To be complete, this test should also check whether the matrix has only one
    line; in which case, it is continuous by definition. Nevertheless, always use
    the `isContinuous` method to test the continuity condition. In some specific processing
    algorithms, you can take advantage of the continuity of the image by processing
    it in one single (longer) loop. Our processing function would then be written
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整，此测试还应检查矩阵是否只有一行；如果是这样，则根据定义它是连续的。尽管如此，始终使用`isContinuous`方法来测试连续性条件。在某些特定的处理算法中，您可以通过在一个单一（更长）的循环中处理图像来利用图像的连续性。我们的处理函数将如下编写：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, when the continuity test tells us that the image does not contain padded
    pixels, we eliminate the outer loop by setting the width to `1` and the height
    to `WxH`. Note that there is also a `reshape` method that could have been used
    here. You would write the following in this case:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当连续性测试告诉我们图像不包含填充像素时，我们通过将宽度设置为`1`和高度设置为`WxH`来消除外循环。请注意，这里也可以使用`reshape`方法。在这种情况下，您将编写以下代码：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `reshape` method changes the matrix dimensions without requiring any memory
    copying or reallocation. The first parameter is the new number of channels and
    the second one is the new number of rows. The number of columns is readjusted
    accordingly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`reshape`方法在不要求任何内存复制或重新分配的情况下更改矩阵维度。第一个参数是新的通道数，第二个参数是新的行数。列数相应调整。'
- en: In these implementations, the inner loop processes all image pixels in a sequence.
    This approach is mainly advantageous when several small images are scanned simultaneously
    into the same loop.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些实现中，内循环按顺序处理所有图像像素。这种方法在同时将多个小图像扫描到同一循环中时主要具有优势。
- en: Low-level pointer arithmetics
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 低级指针算术
- en: 'In the `cv::Mat` class, the image data is contained in a memory block of unsigned
    chars. The address of the first element of this memory block is given by the data
    attribute that returns an unsigned char pointer. So, to start your loop at the
    beginning of the image, you could have written the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cv::Mat`类中，图像数据包含在一个无符号字符的内存块中。该内存块第一个元素地址由返回无符号字符指针的数据属性给出。因此，为了从图像的开始处开始循环，您可以编写以下代码：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Moving from one row to the next could have been done by moving your row pointer
    using the effective width as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从一行移动到下一行可以通过使用有效宽度移动行指针来完成：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `step` method gives you the total number of bytes (including the padded
    pixels) in a line. In general, you can obtain the address of the pixel at row
    `j` and column `i` as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`step`方法给出了每行中字节数的总数（包括填充像素）。通常，您可以按以下方式获取行`j`和列`i`的像素地址：'
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: However, even if this would work in our example, it is not recommended that
    you proceed this way.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使这种方法在我们的例子中可行，也不建议您这样操作。
- en: See also
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Writing efficient image-scanning loops* recipe in this chapter proposes
    a discussion on the efficiency of the scanning methods presented here
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*高效图像扫描循环*的配方提出了对这里提出扫描方法效率的讨论
- en: Scanning an image with iterators
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器扫描图像
- en: In object-oriented programming, looping over a data collection is usually done
    using iterators. Iterators are specialized classes that are built to go over each
    element of a collection, hiding how the iteration over each element is specifically
    done for a given collection. This application of the information-hiding principle
    makes scanning a collection easier and safer. In addition, it makes it similar
    in form no matter what type of collection is used. The **Standard Template Library**
    (**STL**) has an iterator class associated with each of its collection classes.
    OpenCV then offers a `cv::Mat` iterator class that is compatible with the standard
    iterators found in the C++ STL.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，遍历数据集合通常使用迭代器。迭代器是专门构建的类，用于遍历集合中的每个元素，隐藏了针对特定集合的迭代方式。这种信息隐藏原则的应用使得扫描集合变得更加容易和安全。此外，它使得无论使用何种类型的集合，形式都相似。**标准模板库**（**STL**）与每个集合类关联一个迭代器类。OpenCV
    提供了一个与 C++ STL 中找到的标准迭代器兼容的 `cv::Mat` 迭代器类。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we again use the color reduction example described in the previous
    recipe.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们再次使用前一个菜谱中描述的颜色减少示例。
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'An iterator object for a `cv::Mat` instance can be obtained by first creating
    a `cv::MatIterator_` object. As is the case with `cv::Mat_`, the underscore indicates
    that this is a template subclass. Indeed, since image iterators are used to access
    the image elements, the return type must be known at the time of compilation.
    The iterator is then declared as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 `cv::Mat` 实例的迭代器对象首先创建一个 `cv::MatIterator_` 对象。与 `cv::Mat_` 一样，下划线表示这是一个模板子类。确实，由于图像迭代器用于访问图像元素，返回类型必须在编译时已知。然后，迭代器声明如下：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, you can also use the `iterator` type defined inside the `Mat_`
    template class as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以使用 `Mat_` 模板类内部定义的 `iterator` 类型，如下所示：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You then loop over the pixels using the usual `begin` and `end` iterator methods,
    except that these ones are, again, template methods. Consequently, our color reduction
    function is now written as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您使用通常的 `begin` 和 `end` 迭代器方法遍历像素，但要注意，这些方法同样是模板方法。因此，我们的颜色减少函数现在编写如下：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Remember that the iterator here returns a `cv::Vec3b` instance because we are
    processing a color image. Each color channel element is accessed using the dereferencing
    operator `[]`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这里的迭代器返回一个 `cv::Vec3b` 实例，因为我们正在处理彩色图像。每个颜色通道元素都是通过解引用运算符 `[]` 访问的。
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Working with iterators always follows the same pattern no matter what kind of
    collection is scanned.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 无论扫描哪种类型的集合，使用迭代器进行操作总是遵循相同的模式。
- en: First, you create your iterator object using the appropriate specialized class,
    which in our example is `cv::Mat_<cv::Vec3b>::iterator` (or `cv::MatIterator_<cv::Vec3b>`).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您使用适当的专用类创建迭代器对象，在我们的例子中是 `cv::Mat_<cv::Vec3b>::iterator`（或 `cv::MatIterator_<cv::Vec3b>`）。
- en: You then obtain an iterator initialized at the starting position (in our example,
    the upper-left corner of the image). This is done using a `begin` method. With
    a `cv::Mat` instance, you obtain it as `image.begin<cv::Vec3b>()`. You can also
    use arithmetic on the iterator. For example, if you wish to start at the second
    row of an image, you can initialize your `cv::Mat` iterator at `image.begin<cv::Vec3b>()+image.cols`.
    The end position of your collection is obtained similarly but using the `end`
    method. However, the iterator thus obtained is just outside your collection. This
    is why your iterative process must stop when it reaches the end position. You
    can also use arithmetic on this iterator; for example, if you wish to stop before
    the last row, your final iteration would stop when the iterator reaches `image.end<cv::Vec3b>()-image.cols`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您获得一个初始化在起始位置（在我们的例子中，是图像的左上角）的迭代器。这是通过 `begin` 方法完成的。对于 `cv::Mat` 实例，您可以通过
    `image.begin<cv::Vec3b>()` 获取它。您也可以对迭代器进行算术运算。例如，如果您希望从图像的第二行开始，您可以将 `cv::Mat`
    迭代器初始化为 `image.begin<cv::Vec3b>()+image.cols`。通过类似的方式，使用 `end` 方法获得集合的结束位置。然而，由此获得的迭代器仅位于集合外部。这就是为什么迭代过程必须在达到结束位置时停止。您也可以对迭代器进行算术运算；例如，如果您希望在最后一行之前停止，您的最终迭代将在迭代器达到
    `image.end<cv::Vec3b>()-image.cols` 时停止。
- en: 'Once your iterator is initialized, you create a loop that goes over all elements
    until the end is reached. A typical `while` loop will look like the following
    code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化了迭代器，您就创建一个循环，遍历所有元素直到达到末尾。一个典型的 `while` 循环如下所示：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `++` operator is the one that is to be used to move to the next element.
    You can also specify the larger step size. For example, `it+=10` would process
    the image every `10` pixels.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`++` 操作符是用来移动到下一个元素的。你也可以指定更大的步长。例如，`it+=10` 将每处理 `10` 像素一次。'
- en: 'Finally, inside the processing loop, you use the dereferencing operator `*`
    in order to access the current element, using which, you can read (for example,
    `element= *it;`) or write (for example, `*it= element;`). Note that it is also
    possible to create constant iterators that you use if you receive a reference
    to `const` `cv::Mat` or if you wish to signify that the current loop does not
    modify the `cv::Mat` instance. These are declared as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在处理循环内部，你使用解引用操作符 `*` 来访问当前元素，利用它可以读取（例如，`element= *it;`）或写入（例如，`*it= element;`）。请注意，也可以创建常量迭代器，如果你收到对
    `const` `cv::Mat` 的引用，或者如果你希望表明当前循环不会修改 `cv::Mat` 实例。这些声明如下：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Or, they are declared as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们可以这样声明：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There's more...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: In this recipe, the start and end positions of the iterator were obtained using
    the `begin` and `end` template methods. As we did in the first recipe of this
    chapter, we could have also obtained them using a reference to a `cv::Mat_` instance.
    This would avoid the need to specify the iterator type in the `begin` and `end`
    methods since this one is specified when the `cv::Mat_` reference is created.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，迭代器的起始和结束位置是通过使用 `begin` 和 `end` 模板方法获得的。正如我们在本章的第一个部分中所做的那样，我们也可以使用对 `cv::Mat_`
    实例的引用来获得它们。这将避免在 `begin` 和 `end` 方法中指定迭代器类型，因为当创建 `cv::Mat_` 引用时已经指定了该类型。
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: See also
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Writing efficient image-scanning loops* recipe proposes a discussion on
    the efficiency of iterators when scanning an image.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “编写高效的图像扫描循环”这一部分提出了关于迭代器在扫描图像时的效率的讨论。
- en: Also, if you are not familiar with the concept of iterators in object-oriented
    programming and how they are implemented in ANSI C++, you should read a tutorial
    on STL iterators. Simply search the Web with the keywords "STL Iterator" and you
    will find numerous references on the subject.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，如果你不熟悉面向对象编程中迭代器的概念以及它们如何在 ANSI C++ 中实现，你应该阅读有关 STL 迭代器的教程。只需用关键词“STL Iterator”在网络上搜索，你将找到关于该主题的许多参考资料。
- en: Writing efficient image-scanning loops
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写高效的图像扫描循环
- en: In the previous recipes of this chapter, we presented different ways of scanning
    an image in order to process its pixels. In this recipe, we will compare the efficiency
    of these different approaches.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之前的部分中，我们介绍了不同的图像扫描方法，以便处理其像素。在本节中，我们将比较这些不同方法的效率。
- en: When you write an image-processing function, efficiency is often a concern.
    When you design your function, you will frequently need to check the computational
    efficiency of your code in order to detect any bottleneck in your processing that
    might slow down your program.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写图像处理函数时，效率通常是关注的焦点。当你设计你的函数时，你将经常需要检查你代码的计算效率，以检测任何可能减慢程序的处理瓶颈。
- en: However, it is important to note that unless necessary, optimization should
    not be done at the price of reducing the program clarity. Simple code is indeed
    always easier to debug and maintain. Only code portions that are critical to a
    program's efficiency should be heavily optimized.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要注意，除非必要，优化不应以牺牲程序清晰度为代价。简单的代码确实总是更容易调试和维护。只有对程序效率至关重要的代码片段才应该进行大量优化。
- en: How to do it...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to measure the execution time of a function or a portion of code,
    there exists a very convenient OpenCV function called `cv::getTickCount()`. This
    function gives you the number of clock cycles that have occurred since the last
    time you started your computer. Since we want the execution time of a code portion
    given in seconds, we use another method, `cv::getTickFrequency()`. This gives
    us the number of cycles per second. The usual pattern to be used in order to obtain
    the computational time of a given function (or portion of code) would then be
    as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测量函数或代码片段的执行时间，存在一个非常方便的 OpenCV 函数，称为 `cv::getTickCount()`。此函数给出自上次你启动计算机以来发生的时钟周期数。由于我们想要以秒为单位的代码片段的执行时间，我们使用另一种方法，`cv::getTickFrequency()`。这给我们每秒的周期数。为了获得给定函数（或代码片段）的计算时间，通常要使用的模式如下：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The execution times of the different implementations of the `colorReduce` function
    from this chapter are reported here. The absolute runtime numbers would differ
    from one machine to another (here, we used a 2.40 GHz machine equipped with a
    64-bit Intel Core i7). It is rather interesting to look at their relative difference.
    These results are also dependent on the specific compiler that is used to produce
    the executable file. Our tests report the average time to reduce the colors of
    an image that has a resolution of 4288 x 2848 pixels.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中`colorReduce`函数的不同实现方式的执行时间在此处报告。绝对运行时间数字会因机器而异（在这里，我们使用了一个配备64位Intel Core
    i7的2.40 GHz机器）。观察它们的相对差异相当有趣。这些结果还取决于用于生成可执行文件的特定编译器。我们的测试报告了将分辨率为4288 x 2848像素的图像颜色减少的平均时间。
- en: First, we compare the three ways of computing the color reduction as presented
    in the *There's more...* section of the *Scanning an image with pointers* recipe.
    It is interesting to observe that the formula that uses the bitwise operator is
    much faster than the others at 9.5ms. The one using the integer division is at
    26ms. The version based on the modulo operator is, however, at 33 ms. This represents
    a factor of more than 3 between the fastest and the slowest! It is therefore important
    to take the time to identify the most efficient way of computing a result in an
    image loop, as the net impact can be very significant.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们比较了在“使用指针扫描图像”配方中的“更多...”部分中提出的计算颜色减少的三个方法。有趣的是观察到，使用位运算符的公式在9.5毫秒时比其他方法快得多。使用整数除法的版本为26毫秒。然而，基于取模运算符的版本却为33毫秒。这代表了最快和最慢之间的超过3倍差距！因此，在图像循环中识别计算结果的最有效方式非常重要，因为其净影响可能非常显著。
- en: When an output image that needs to be reallocated is specified instead of in-place
    processing, the execution time becomes 29 ms. The extra duration represents the
    overhead for memory allocation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定需要重新分配的输出图像而不是就地处理时，执行时间变为29毫秒。额外的时间代表了内存分配的开销。
- en: 'In a loop, you should avoid repetitive computations of values that could be
    precomputed instead. This consumes time, obviously. For example, you take the
    following inner loop of the color reduction function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，你应该避免重复计算那些可以预先计算的值。这显然会消耗时间。例如，你取以下颜色减少函数的内循环：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, you replace it with the following one:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将其替换为以下版本：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding code is a loop where you need to compute the total number of elements
    in a line and the `div>>1` result again and again; you will obtain a runtime of
    52 ms, which is significantly slower than the original version at 26 ms. Note,
    however, that some compilers might be able to optimize these kinds of loops and
    still obtain efficient code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码是一个需要反复计算一行中元素总数和`div>>1`结果的循环；你将获得52毫秒的运行时间，这比原始版本的26毫秒慢得多。然而，请注意，一些编译器可能能够优化这类循环，并仍然获得高效的代码。
- en: The version of the color reduction function that uses iterators, as shown in
    the *Scanning an image with iterators* recipe, gives slower results at 52 ms.
    The main objective of iterators is to simplify the image-scanning process and
    make it less prone to errors.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如“使用迭代器扫描图像”配方中所示，使用迭代器的颜色减少函数版本在52毫秒时给出了较慢的结果。迭代器的主要目标是简化图像扫描过程，并使其更不容易出错。
- en: 'For completeness, we also implemented a version of the function that uses the
    `at` method for pixel access. The main loop of this implementation would then
    simply read as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们还实现了一个使用`at`方法进行像素访问的函数版本。这个实现的主循环将简单地如下所示：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This implementation is much slower when a runtime of 53 ms is obtained. This
    method should then be used only for the random access of image pixels but never
    when scanning an image.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当获得53毫秒的运行时间时，这种实现方式会慢得多。因此，这种方法仅应用于图像像素的随机访问，而绝不应在扫描图像时使用。
- en: A shorter loop with few statements is generally more efficiently executed than
    a longer loop over a single statement even if the total number of elements processed
    is the same. Similarly, if you have `N` different computations to apply to a pixel,
    apply all of them in one loop rather than writing `N` successive loops, one for
    each computation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，较短的循环，即使处理的元素总数相同，也比较长的单语句循环执行得更有效。同样，如果你需要对像素应用`N`种不同的计算，请在单个循环中应用所有这些计算，而不是编写`N`个连续的循环，每个循环对应一种计算。
- en: We also performed the continuity test that produces one loop in the case of
    continuous images instead of the regular double loop over lines and columns. For
    a very large image, like the one we used in our tests, this optimization is not
    significant (25 ms instead of 26 ms), but in general, it is always a good practice
    to use this strategy, since it can lead to a significant gain in speed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还进行了连续性测试，对于连续图像，它产生一个循环，而不是常规的行和列的双循环。对于非常大的图像，如我们在测试中使用的图像，这种优化并不显著（25毫秒而不是26毫秒），但总的来说，始终使用这种策略是一个好习惯，因为它可以带来速度的显著提升。
- en: There's more…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Multithreading is another way to increase the efficiency of your algorithms,
    especially since the advent of multicore processors. **OpenMP** and the **Intel
    Threading Building Blocks** (**TBB**) are two popular APIs that are used in concurrent
    programming to create and manage your threads. In addition, C++11 now offers built-in
    support for threads.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程是提高算法效率的另一种方式，尤其是在多核处理器的出现之后。**OpenMP**和**Intel Threading Building Blocks**（**TBB**）是两个在并发编程中用于创建和管理线程的流行API。此外，C++11现在提供了对线程的内置支持。
- en: See also
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Performing simple image arithmetic* recipe presents an implementation of
    the color-reduction function (described in the *There's more...* section) that
    uses the OpenCV 2 arithmetic image operators and has a runtime of 25 ms.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*执行简单的图像算术*菜谱展示了使用OpenCV 2算术图像运算符的颜色减少函数（在*还有更多...*部分描述）的实现，其运行时间为25毫秒。'
- en: The *Applying look-up tables to modify image appearance* recipe of [Chapter
    4](part0032_split_000.html#page "Chapter 4. Counting the Pixels with Histograms"),
    *Counting the Pixels with Histograms* describes an implementation of the color-reduction
    function based on a look-up table. The idea is to precompute all intensity reduction
    values that lead to a runtime of 22 ms.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将查找表应用于修改图像外观*菜谱（[第4章](part0032_split_000.html#page "第4章. 使用直方图计数像素")，*使用直方图计数像素*）描述了一个基于查找表的颜色减少函数的实现。想法是预先计算所有强度减少值，从而将运行时间缩短到22毫秒。'
- en: Scanning an image with neighbor access
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用邻居访问扫描图像
- en: In image processing, it is common to have a processing function that computes
    a value at each pixel location based on the value of the neighboring pixels. When
    this neighborhood includes pixels of the previous and next lines, you then need
    to simultaneously scan several lines of the image. This recipe shows you how to
    do it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像处理中，通常有一个处理函数，它根据相邻像素的值在每个像素位置计算一个值。当这个邻域包括上一行和下一行的像素时，您就需要同时扫描图像的几行。这个菜谱向您展示了如何实现。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To illustrate this recipe, we will apply a processing function that sharpens
    an image. It is based on the Laplacian operator (which will be discussed in [Chapter
    6](part0047_split_000.html#page "Chapter 6. Filtering the Images"), *Filtering
    the Images*). It is indeed a well-known result in image processing that if you
    subtract the Laplacian from an image, the image edges are amplified, thereby giving
    a sharper image.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个菜谱，我们将应用一个锐化图像的处理函数。它基于拉普拉斯算子（将在[第6章](part0047_split_000.html#page "第6章.
    过滤图像")，*过滤图像*中讨论）。在图像处理中，确实有一个众所周知的结果，即如果你从图像中减去拉普拉斯算子，图像边缘会被增强，从而得到一个更清晰的图像。
- en: 'This sharpened value is computed as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个锐化值是这样计算的：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, `left` is the pixel that is immediately on the left-hand side of the current
    one, `up` is the corresponding one on the previous line, and so on.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`left`是位于当前像素左侧的像素，`up`是上一行的对应像素，依此类推。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'This time, the processing cannot be accomplished in-place. Users need to provide
    an output image. The image scanning is done using three pointers, one for the
    current line, one for the line above, and another one for the line below. Also,
    since each pixel computation requires access to the neighbors, it is not possible
    to compute a value for the pixels of the first and last row of the image as well
    as the pixels of the first and last column. The loop can then be written as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，处理不能就地完成。用户需要提供一个输出图像。图像扫描使用三个指针完成，一个用于当前行，一个用于上一行，另一个用于下一行。此外，由于每个像素的计算都需要访问邻居，因此无法计算图像第一行和最后一行的像素以及第一列和最后一列的像素的值。循环可以写成如下：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Note how we wrote the function such that it would work on both gray-level and
    color images. If we apply this function on a gray-level version of our test image,
    the following result is obtained:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何编写这个函数，使其能够在灰度图像和彩色图像上都能工作。如果我们将这个函数应用于测试图像的灰度版本，将得到以下结果：
- en: '![How to do it...](img/00015.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00015.jpeg)'
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to access the neighboring pixels of the previous and next row, you
    must simply define additional pointers that are jointly incremented. You then
    access the pixels of these lines inside the scanning loop.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问前一行和下一行的相邻像素，你只需定义额外的指针，并将它们共同递增。然后你在扫描循环中访问这些行的像素。
- en: In the computation of the output pixel value, the `cv::saturate_cast` template
    function is called on the result of the operation. This is because it often happens
    that a mathematical expression applied on pixels leads to a result that goes outside
    the range of the permitted pixel values (that is, below 0 or over 255). The solution
    is then to bring the values back inside this 8-bit range. This is done by changing
    negative values to `0` and values over `255` to `255`. This is exactly what the
    `cv::saturate_cast<uchar>` function is doing. In addition, if the input argument
    is a floating point number, then the result is rounded to the nearest integer.
    You can obviously use this function with other types in order to guarantee that
    the result will remain within the limits defined by this type.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算输出像素值的过程中，调用了`cv::saturate_cast`模板函数。这是因为经常发生这样的情况，即应用于像素的数学表达式会导致结果超出允许的像素值范围（即低于0或超过255）。解决方案是将这些值重新调整到这个8位范围内。这是通过将负值改为`0`和将值超过`255`改为`255`来实现的。这正是`cv::saturate_cast<uchar>`函数所做的事情。此外，如果输入参数是浮点数，则结果会被四舍五入到最接近的整数。显然，你可以使用这个函数与其他类型一起使用，以确保结果将保持在由该类型定义的限制内。
- en: 'Border pixels that cannot be processed because their neighborhood is not completely
    defined need to be handled separately. Here, we simply set them to `0`. In other
    cases, it could be possible to perform a special computation for these pixels,
    but most of the time, there is no point in spending time to process these very
    few pixels. In our function, these border pixels are set to `0` using two special
    methods. The first one is `row` and its dual is `col`. They return a special `cv::Mat`
    instance composed of a single-line ROI (or a single-column ROI) as specified in
    a parameter (remember, we discussed region of interest in the previous chapter).
    No copy is made here because if the elements of this 1D matrix are modified, they
    will also be modified in the original image. This is what we do when the `setTo`
    method is called. This method assigns a value to all elements of a matrix. Take
    a look at the following statement:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的邻域没有完全定义，无法处理的边界像素需要单独处理。在这里，我们只是将它们设置为`0`。在其他情况下，可能为这些像素执行特殊的计算，但大多数情况下，没有必要花费时间去处理这么少的像素。在我们的函数中，这些边界像素通过两种特殊方法设置为`0`。第一种是`row`，其对应的是`col`。它们返回一个特殊的`cv::Mat`实例，该实例由参数中指定的单行ROI（或单列ROI）组成（记住，我们在上一章中讨论了感兴趣区域）。这里没有进行复制，因为如果这个一维矩阵的元素被修改，原始图像中的元素也会被修改。这就是当调用`setTo`方法时我们所做的。这个方法将值赋给矩阵的所有元素。看看以下语句：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding statement assigns the value of `0` to all pixels of the first
    line of the result image. In the case of a 3-channel color image, you would use
    `cv::Scalar(a,b,c)` to specify the three values to be assigned to each channel
    of the pixel.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句将结果图像的第一行的所有像素的值赋为`0`。在3通道彩色图像的情况下，你会使用`cv::Scalar(a,b,c)`来指定要分配给每个像素通道的三个值。
- en: There's more...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When a computation is done over a pixel neighborhood, it is common to represent
    this with a kernel matrix. This kernel describes how the pixels involved in the
    computation are combined in order to obtain the desired result. For the sharpening
    filter used in this recipe, the kernel would be as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当在像素邻域内进行计算时，通常用核矩阵来表示这一点。这个核描述了参与计算的像素是如何组合以获得所需结果的。对于本食谱中使用的锐化滤波器，核将如下所示：
- en: '| 0 | -1 | 0 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 0 | -1 | 0 |'
- en: '| -1 | 5 | -1 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| -1 | 5 | -1 |'
- en: '| 0 | -1 | 0 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 0 | -1 | 0 |'
- en: Unless stated otherwise, the current pixel corresponds to the center of the
    kernel. The value in each cell of the kernels represents a factor that multiplies
    the corresponding pixel. The result of the application of the kernel on a pixel
    is then given by the sum of all these multiplications. The size of the kernel
    corresponds to the size of the neighborhood (here, 3 x 3). Using this representation,
    it can be seen that, as required by the sharpening filter, the four horizontal
    and vertical neighbors of the current pixel are multiplied by -1, while the current
    one is multiplied by 5\. Applying a kernel to an image is more than a convenient
    representation; it is the basis for the concept of convolution in signal processing.
    The kernel defines a filter that is applied to the image.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有说明，当前像素对应于核的中心。核中每个单元格的值代表一个乘以相应像素的因子。核应用于像素的结果是所有这些乘积的总和。核的大小对应于邻域的大小（在这里，3
    x 3）。使用这种表示法，可以看出，正如锐化滤波器所要求的，当前像素的四个水平和垂直邻居乘以-1，而当前像素乘以5。将核应用于图像不仅是一种方便的表示；它是信号处理中卷积概念的基础。核定义了一个应用于图像的过滤器。
- en: 'Since filtering is a common operation in image processing, OpenCV has defined
    a special function that performs this task: the `cv::filter2D` function. To use
    this, you just need to define a kernel (in the form of a matrix). The function
    is then called with the image and the kernel, and it returns the filtered image.
    Using this function, it is therefore, easy to redefine our sharpening function
    as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于滤波是图像处理中的常见操作，OpenCV定义了一个特殊函数来执行此任务：`cv::filter2D`函数。要使用它，你只需要定义一个核（以矩阵的形式）。然后，使用图像和核调用该函数，并返回滤波后的图像。因此，可以很容易地重新定义我们的锐化函数如下：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This implementation produces exactly the same result as the previous one (and
    with the same efficiency). If you input a color image, then the same kernel will
    be applied to all three channels. Note that it is particularly advantageous to
    use the `filter2D` function with a large kernel, as it uses, in this case, a more
    efficient algorithm.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现产生的结果与上一个完全相同（并且具有相同的效率）。如果你输入一个彩色图像，那么相同的核将应用于所有三个通道。请注意，使用`filter2D`函数与大型核特别有利，因为它在这种情况下使用了一个更有效的算法。
- en: See also
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 6](part0047_split_000.html#page "Chapter 6. Filtering the Images"),
    *Filtering the Images*, provides more explanations on the concept of image filtering'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](part0047_split_000.html#page "第6章。图像滤波")，*图像滤波*，提供了更多关于图像滤波概念的说明'
- en: Performing simple image arithmetic
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行简单的图像算术
- en: Images can be combined in different ways. Since they are regular matrices, they
    can be added, subtracted, multiplied, or divided. OpenCV offers various image
    arithmetic operators, and their use is discussed in this recipe.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图像可以以不同的方式组合。由于它们是规则矩阵，它们可以相加、相减、相乘或相除。OpenCV提供了各种图像算术运算符，它们的使用在本食谱中讨论。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Let''s work with a second image that we will combine to our input image using
    an arithmetic operator. The following represents this second image:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用第二个图像，我们将使用算术运算符将其组合到输入图像中。以下表示这个第二个图像：
- en: '![Getting ready](img/00016.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/00016.jpeg)'
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here, we add two images. This is useful when we want to create some special
    effects or to overlay information over an image. We do this by calling the `cv::add`
    function, or more precisely here, the `cv::addWeighted` function, since we want
    a weighted sum as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了两个图像。当我们想要创建一些特殊效果或在一个图像上叠加信息时，这很有用。我们通过调用`cv::add`函数，或者更准确地说，在这里调用`cv::addWeighted`函数来实现，因为我们想要一个加权求和，如下所示：
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The operation results in a new image, as seen in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 操作结果产生了一个新的图像，如下面的截图所示：
- en: '![How to do it...](img/00017.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00017.jpeg)'
- en: How it works...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'All binary arithmetic functions work the same way. Two inputs are provided
    and a third parameter specifies the output. In some cases, weights that are used
    as scalar multipliers in the operation can be specified. Each of these functions
    comes in several flavors; `cv::add` is a good example of a function that is available
    in many forms:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所有二进制算术函数的工作方式相同。提供两个输入，第三个参数指定输出。在某些情况下，可以用作操作中的标量乘数的权重可以指定。这些函数中的每一个都有几种不同的形式；`cv::add`是许多形式中可用函数的一个好例子：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For some functions, you can also specify a mask:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些函数，你也可以指定一个掩码：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you apply a mask, the operation is performed only on pixels for which the
    mask value is not null (the mask must be 1-channel). Have a look at the different
    forms of `cv::subtract`, `cv::absdiff`, `cv::multiply`, and `cv::divide` functions.
    Bit-wise operators (operators applied to each individual bit of the pixels'' binary
    representation) are also available: `cv::bitwise_and`, `cv::bitwise_or`, `cv::bitwise_xor`,
    and `cv::bitwise_not`. The `cv::min` and `cv::max` operators, which find the per-element
    maximum or minimum pixel value, are also very useful.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用掩码，则仅对掩码值为非空的像素执行操作（掩码必须是单通道）。查看`cv::subtract`、`cv::absdiff`、`cv::multiply`和`cv::divide`函数的不同形式。位运算符（应用于像素二进制表示中每个单独位的运算符）也是可用的：`cv::bitwise_and`、`cv::bitwise_or`、`cv::bitwise_xor`和`cv::bitwise_not`。`cv::min`和`cv::max`运算符，它们找到每个元素的最大或最小像素值，也非常有用。
- en: In all cases, the `cv::saturate_cast` function (see the preceding recipe) is
    always used to make sure that the results stay within the defined pixel value
    domain (that is, to avoid overflow or underflow).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，始终使用`cv::saturate_cast`函数（参见前面的菜谱）来确保结果保持在定义的像素值域内（即避免溢出或下溢）。
- en: The images must have the same size and type (the output image will be reallocated
    if it does not match the input size). Also, since the operation is performed per-element,
    one of the input images can be used as the output.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图像必须具有相同的大小和类型（如果输出图像的大小不匹配输入大小，则将重新分配）。此外，由于操作是按元素进行的，可以使用其中一个输入图像作为输出。
- en: 'Several operators that take a single image as the input are also available:
    `cv::sqrt`, `cv::pow`, `cv::abs`, `cv::cuberoot`, `cv::exp`, and `cv::log`. In
    fact, there exists an OpenCV function for almost any operation you have to apply
    on image pixels.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些仅接受单个图像作为输入的运算符：`cv::sqrt`、`cv::pow`、`cv::abs`、`cv::cuberoot`、`cv::exp`和`cv::log`。实际上，对于您必须应用于图像像素的几乎任何操作，都存在OpenCV函数。
- en: There's more...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is also possible to use the usual C++ arithmetic operator on the `cv::Mat`
    instances or on the individual channels of `cv::Mat` instances. The two following
    subsections explain how to do this.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在`cv::Mat`实例或`cv::Mat`实例的各个通道上使用常规的C++算术运算符。以下两个小节将解释如何做到这一点。
- en: Overloaded image operators
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重载图像运算符
- en: 'Very conveniently, most arithmetic functions have their corresponding operator
    overloaded in OpenCV 2\. Consequently, the call to `cv::addWeighted` can be written
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 非常方便的是，大多数算术函数在OpenCV 2中都有相应的运算符重载。因此，`cv::addWeighted`的调用可以写成以下形式：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding code is a more compact form that is also easier to read. These
    two ways of writing the weighted sum are equivalent. In particular, the `cv::saturate_cast`
    function will still be called in both cases.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一种更紧凑的格式，也更易于阅读。这两种编写加权总和的方式是等效的。特别是，在两种情况下都会调用`cv::saturate_cast`函数。
- en: Most C++ operators have been overloaded. Among them are the bitwise operators
    `&`, `|`, `^`, and `~`; the `min`, `max`, and `abs` functions. The comparison
    operators `<`, `<=`, `==`,`!=`, `>`, and `>=` have also been overloaded, and they
    return an 8-bit binary image. You will also find the `m1*m2` matrix multiplication
    (where `m1` and `m2` are both `cv::Mat` instances), the `m1.inv()` matrix inversion,
    the `m1.t()` transpose, the `m1.determinant()` determinant, the `v1.norm()` vector
    norm, the `v1.cross(v2)` cross-product, the `v1.dot(v2)` dot product, and so on.
    When this makes sense, you also have the corresponding compound assignment operator
    defined (the `+=` operator, as an example).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数C++运算符都已被重载。其中包含位运算符`&`、`|`、`^`和`~`；`min`、`max`和`abs`函数。比较运算符`<`、`<=`、`==`、`!=`、`>`和`>=`也已重载，并返回一个8位二进制图像。您还将找到矩阵乘法`m1*m2`（其中`m1`和`m2`都是`cv::Mat`实例），矩阵求逆`m1.inv()`，矩阵转置`m1.t()`，行列式`m1.determinant()`，向量范数`v1.norm()`，向量叉积`v1.cross(v2)`，点积`v1.dot(v2)`等等。当这有意义时，您还有相应的复合赋值运算符定义（例如`+=`运算符）。
- en: 'In the *Writing efficient image-scanning loops* recipe, we presented a color-reduction
    function that was written using loops that scan the image pixels to perform some
    arithmetic operations on them. From what we learned here, this function could
    be rewritten simply using arithmetic operators on the input image as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在*编写高效的图像扫描循环*菜谱中，我们介绍了一个使用循环扫描图像像素并对其执行一些算术运算编写的颜色减少函数。根据我们在这里学到的知识，这个函数可以简单地使用输入图像上的算术运算符重写，如下所示：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The use of `cv::Scalar` is due to the fact that we are manipulating a color
    image. Performing the same test as we did in the *Writing efficient image-scanning
    loops* recipe, we obtain an execution time of 53 ms. Using the image operators
    makes the code so simple, and the programmer so productive, that you should consider
    their use in most situations.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cv::Scalar` 是因为我们正在操作彩色图像。执行与我们在 *编写高效的图像扫描循环* 菜谱中所做的相同测试，我们获得 53 毫秒的执行时间。使用图像运算符使得代码如此简单，程序员如此高效，以至于你应该考虑在大多数情况下使用它们。
- en: Splitting the image channels
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分割图像通道
- en: 'You''ll sometimes want to process the different channels of an image independently.
    For example, you might want to perform an operation only on one channel of the
    image. You can, of course, achieve this in an image-scanning loop. However, you
    can also use the `cv::split` function that will copy the three channels of a color
    image into three distinct `cv::Mat` instances. Suppose we want to add our rain
    image to the blue channel only. The following is how we would proceed:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能想独立处理图像的不同通道。例如，你可能只想对图像的一个通道执行操作。当然，你可以在图像扫描循环中实现这一点。然而，你也可以使用 `cv::split`
    函数，该函数将彩色图像的三个通道复制到三个不同的 `cv::Mat` 实例中。假设我们只想将我们的雨图像添加到蓝色通道。以下是我们的操作步骤：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `cv::merge` function performs the inverse operation, that is, it creates
    a color image from three 1-channel images.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::merge` 函数执行逆操作，即从三个单通道图像创建一个彩色图像。'
- en: Remapping an image
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新映射图像
- en: In the recipes of this chapter, you learned how to read and modify the pixel
    values of an image. The last recipe will teach you how to modify the appearance
    of an image by moving its pixels. The pixel values are not changed by this process;
    it is rather the position of each pixel that is remapped to a new location. This
    is useful in order to create special effects on an image or to correct image distortions
    caused, for example, by a lens.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的菜谱中，你学习了如何读取和修改图像的像素值。最后一个菜谱将教你如何通过移动像素来修改图像的外观。在这个过程中，像素值不会改变；而是每个像素的位置被重新映射到新的位置。这在创建图像的特殊效果或纠正由镜头引起的图像畸变等方面非常有用。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In order to use the OpenCV `remap` function, you simply have to first define
    the map to be used in the remapping process. Second, you have to apply this map
    on an input image. Obviously, it is the way you define your map that will determine
    the effect that will be produced. In our example, we define a transformation function
    that will create a wavy effect on the image:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 OpenCV 的 `remap` 函数，你只需首先定义在重新映射过程中要使用的映射。其次，你必须将此映射应用于输入图像。显然，你定义映射的方式将决定产生的效果。在我们的例子中，我们定义了一个变换函数，该函数将在图像上创建波浪效果：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The result is as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![How to do it...](img/00018.jpeg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00018.jpeg)'
- en: How it works...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The objective of remapping is to produce a new version of an image in which
    pixels have changed in position. To construct this new image, we need to know
    what the original position for each pixel in the destination image in the source
    image is. The mapping function that is needed is therefore the one that will give
    us the original pixel positions as a function of the new pixel positions. This
    is called **backward** **mapping** because the transformation describes how the
    pixels of the new images are mapped back to the original image. In OpenCV, backward
    mapping is described using two maps: one for the x-coordinates and one for the
    y-coordinates. They are both represented by floating point `cv::Mat` instances:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 重新映射的目标是生成一个新版本的图像，其中像素的位置已经改变。为了构建这个新图像，我们需要知道源图像中每个像素在目标图像中的原始位置。因此，所需的映射函数是能够将原始像素位置作为新像素位置的函数。这被称为
    **反向** 映射，因为这种变换描述了新图像的像素如何映射回原始图像。在 OpenCV 中，反向映射使用两个映射来描述：一个用于 x 坐标，一个用于 y 坐标。它们都由浮点
    `cv::Mat` 实例表示：
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The size of these matrices will define the size of the destination image. The
    value of the `(i,j)` pixel of the destination image can then be read in the source
    image using the following line of code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这些矩阵的大小将定义目标图像的大小。然后，可以使用以下代码行在源图像中读取目标图像的 `(i,j)` 像素值：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For example, a simple image flip effect like the one we demonstrated in [Chapter
    1](part0014_split_000.html#page "Chapter 1. Playing with Images"), *Playing with
    Images*, can be created by the following maps:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像我们在 [第 1 章](part0014_split_000.html#page "第 1 章。玩转图像")，*玩转图像* 中演示的那样，一个简单的图像翻转效果可以通过以下映射创建：
- en: '[PRE51]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To generate the resulting image, you simply call the OpenCV `remap` function:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成结果图像，你只需调用 OpenCV 的 `remap` 函数：
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: It is interesting to note that the two maps contain floating-point values. Consequently,
    a pixel in the destination can map back to a non-integral value (that is, a location
    between pixels). This is very convenient because this allows us to define the
    mapping function of our choice. For instance, in our remapping example, we used
    a `sinusoidal` function to define our transformation. However, this also means
    that we have to interpolate the value of virtual pixels in between real pixels.
    There exist different ways of performing pixel interpolation, and the last parameter
    of the `remap` function allows us to select the method that will be used. Pixel
    interpolation is an important concept in image processing; this subject will be
    discussed in [Chapter 6](part0047_split_000.html#page "Chapter 6. Filtering the
    Images"), *Filtering the Images*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这两个图包含浮点值。因此，目标中的一个像素可以映射回非整数值（即像素之间的位置）。这非常方便，因为这允许我们定义我们选择的映射函数。例如，在我们的重映射示例中，我们使用正弦函数来定义我们的变换。然而，这也意味着我们必须在真实像素之间插值虚拟像素的值。存在不同的像素插值方法，`remap`
    函数的最后一个参数允许我们选择将使用的方法。像素插值是图像处理中的一个重要概念；这个主题将在 [第 6 章](part0047_split_000.html#page
    "第 6 章。滤波图像")，*滤波图像* 中讨论。
- en: See also
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *There's more...* section of the *Filtering images using low-pass filters*
    recipe of [Chapter 6](part0047_split_000.html#page "Chapter 6. Filtering the Images"),
    *Filtering the Images*, explains the concept of pixel interpolation
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 6 章](part0047_split_000.html#page "第 6 章。滤波图像") 中 *使用低通滤波器滤波图像* 的配方中的 *更多内容...*
    部分，*滤波图像*，解释了像素插值的概念'
- en: The *Calibrating a camera* recipe of [Chapter 10](part0067_split_000.html#page
    "Chapter 10. Estimating Projective Relations in Images"), *Estimating Projective
    Relations in Images*, uses remapping to correct lens distortions in an image
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 10 章](part0067_split_000.html#page "第 10 章。在图像中估计投影关系") 中 *校准相机* 的配方，*在图像中估计投影关系*，使用重映射来校正图像中的镜头畸变'
- en: The *Computing a homography between two images* recipe of [Chapter 10](part0067_split_000.html#page
    "Chapter 10. Estimating Projective Relations in Images"), *Estimating Projective
    Relations in Images*, uses perspective image warping to build an image panorama
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 10 章](part0067_split_000.html#page "第 10 章。在图像中估计投影关系") 中 *计算两张图像之间的单应性*
    的配方，*在图像中估计投影关系*，使用透视图像扭曲来构建图像全景'
