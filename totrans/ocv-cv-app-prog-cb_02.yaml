- en: Chapter 2. Manipulating Pixels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing pixel values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning an image with pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning an image with iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing efficient image-scanning loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning an image with neighbor access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing simple image arithmetic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remapping an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to build computer vision applications, you need to be able to access
    the image content and eventually modify or create images. This chapter will teach
    you how to manipulate the picture elements (also known as **pixels**). You will
    learn how to scan an image and process each of its pixels. You will also learn
    how to do this efficiently, since even images of modest dimensions can contain
    hundreds of thousands of pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, an image is a matrix of numerical values. This is why, as we
    learned in [Chapter 1](part0014_split_000.html#page "Chapter 1. Playing with Images"),
    *Playing with Images*, OpenCV 2 manipulates them using the `cv::Mat` data structure.
    Each element of the matrix represents one pixel. For a gray-level image (a black-and-white
    image), pixels are unsigned 8-bit values where `0` corresponds to black and `255`
    corresponds to white. In the case of color images, three primary color values
    are required in order to reproduce the different visible colors. This is a consequence
    of the fact that our human visual system is **trichromatic**; three types of cone
    cells on our retinae convey the color information to our brain. This means that
    for a color image, three values must be associated to each pixel. In photography
    and digital imaging, the commonly used primary color channels are red, green,
    and blue. A matrix element is, therefore, made of a triplet of 8-bit values in
    this case.
  prefs: []
  type: TYPE_NORMAL
- en: Note that even if 8-bit channels are generally sufficient, there are specialized
    applications where 16-bit channels are required (medical imaging, for example).
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the previous chapter, OpenCV also allows you to create matrices
    (or images) with pixel values of other types, for example, integer (`CV_32U` or
    `CV_32S`) and floating point (`CV_32F`) numbers. These are very useful to store,
    for example, intermediate values in some image-processing tasks. Most operations
    can be applied on matrices of any type; others require a specific type or work
    only with a given number of channels. Therefore, a good understanding of a function's
    or method's preconditions is essential in order to avoid common programming errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we use the following color image as the input (refer
    to the book''s graphics PDF to view this image in color):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing pixel values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to access each individual element of a matrix, you just need to specify
    its row and column numbers. The corresponding element, which can be a single numerical
    value or a vector of values in the case of a multi-channel image, will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To illustrate the direct access to pixel values, we will create a simple function
    that adds **salt-and-pepper noise** to an image. As the name suggests, salt-and-pepper
    noise is a particular type of noise in which some randomly selected pixels are
    replaced by a white or a black pixel. This type of noise can occur in faulty communications
    when the value of some pixels is lost during the transmission. In our case, we
    will simply randomly select a few pixels and assign them a white color.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We create a function that receives an input image. This is the image that will
    be modified by our function. The second parameter is the number of pixels on which
    we want to overwrite white values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function is made of a single loop that assigns `n` times the value
    `255` to randomly selected pixels. Here, the pixel column `i` and row `j` are
    selected using a random number generator. Note that using the `type` method, we
    distinguish the two cases of gray-level and color images. In the case of a gray-level
    image, the number `255` is assigned to the single 8-bit value. For a color image,
    you need to assign `255` to the three primary color channels in order to obtain
    a white pixel.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can call this function by passing it an image you have previously opened.
    Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting image will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `cv::Mat` class includes several methods to access the different attributes
    of an image. The public member variables, `cols` and `rows`, give you the number
    of columns and rows in the image. For element access, `cv::Mat` has the `at` (`int
    y`, `int x`) method. However, the type returned by a method must be known at compile
    time, and since `cv::Mat` can hold elements of any type, the programmer needs
    to specify the return type that is expected. This is why the `at` method has been
    implemented as a template method. So, when you call it, you must specify the image
    element type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that it is the programmer's responsibility to make sure
    that the type specified matches the type contained in the matrix. The `at` method
    does not perform any type conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In color images, each pixel is associated with three components: the red, green,
    and blue channels. Therefore, a `cv::Mat` class that contains a color image will
    return a vector of three 8-bit values. OpenCV has defined a type for such short
    vectors, and it is called `cv::Vec3b`. This is a vector of three **unsigned characters**.
    This explains why the element access to the pixels of a color pixel is written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `channel` index designates one of the three color channels. OpenCV stores
    the channel values in the order blue, green, and red (blue is, therefore, channel
    `0`).
  prefs: []
  type: TYPE_NORMAL
- en: Similar vector types also exist for 2-element and 4-element vectors (`cv::Vec2b`
    and `cv::Vec4b`) as well as for other element types. For example, for a 2-element
    float vector, the last letter of the type name would be replaced by an f, that
    is, `cv::Vec2f`. In the case of a short integer, the last letter is replaced with
    `s`, with `i` for an integer, and with `d` for a double precision floating point
    vector. All of these types are defined using the `cv::Vec<T,N>` template class,
    where `T` is the type and `N` is the number of vector elements.
  prefs: []
  type: TYPE_NORMAL
- en: As a last note, you might have been surprised by the fact that our image-modifying
    function uses a pass-by-value image parameter. This works because when images
    are copied, they still share the same image data. So, you do not have to necessarily
    transmit images by references when you want to modify their content. Incidentally,
    pass-by-value parameters often make code optimization easier for the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `cv::Mat` class has been made generic by defining it using C++ templates.
  prefs: []
  type: TYPE_NORMAL
- en: The cv::Mat_ template class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the `at` method of the `cv::Mat` class can sometimes be cumbersome because
    the returned type must be specified as a template argument in each call. In cases
    where the matrix type is known, it is possible to use the `cv::Mat_` class, which
    is a template subclass of `cv::Mat`. This class defines a few extra methods but
    no new data attributes so that pointers or references to one class can be directly
    converted to another class. Among the extra methods, there is `operator()`, which
    allows direct access to matrix elements. Therefore, if `image` is a `cv::Mat`
    variable that corresponds to a `uchar` matrix, then you can write the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since the type of the `cv::Mat_` elements is declared when the variable is created,
    the `operator()` method knows at compile time which type is to be returned. Other
    than the fact that it is shorter to write, using the `operator()` method provides
    exactly the same result as the `at` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *There's more…* section of the *Scanning an image with pointers* recipe
    explains how to create a function with input and output parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing efficient image-scanning loops* recipe proposes a discussion on
    the efficiency of this method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning an image with pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most image-processing tasks, you need to scan all pixels of the image in
    order to perform a computation. Considering the large number of pixels that will
    need to be visited, it is essential that you perform this task in an efficient
    way. This recipe, and the next one, will show you different ways of implementing
    efficient scanning loops. This recipe uses the pointer arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will illustrate the image-scanning process by accomplishing a simple task:
    reducing the number of colors in an image.'
  prefs: []
  type: TYPE_NORMAL
- en: Color images are composed of 3-channel pixels. Each of these channels corresponds
    to the intensity value of one of the three primary colors, red, green, and blue.
    Since each of these values is an 8-bit unsigned character, the total number of
    colors is `256x256x256`, which is more than 16 million colors. Consequently, to
    reduce the complexity of an analysis, it is sometimes useful to reduce the number
    of colors in an image. One way to achieve this goal is to simply subdivide the
    RGB space into cubes of equal sizes. For example, if you reduce the number of
    colors in each dimension by `8`, then you would obtain a total of `32x32x32` colors.
    Each color in the original image is then assigned a new color value in the color-reduced
    image that corresponds to the value in the center of the cube to which it belongs.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the basic color reduction algorithm is simple. If `N` is the reduction
    factor, then divide the value by `N` (the integer division, therefore, the reminder
    is lost) for each pixel in the image and for each channel of this pixel. Then,
    multiply the result by `N`; this will give you the multiple of `N` just below
    the input pixel value. Just add `N/2` and you obtain the central position of the
    interval between two adjacent multiples of `N`. If you repeat this process for
    each 8-bit channel value, then you will obtain a total of `256/N x 256/N x 256/N`
    possible color values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The signature of our color reduction function will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The user provides an image and the per-channel reduction factor. Here, the processing
    is done **in-place**, that is, the pixel values of the input image are modified
    by the function. See the *There's more…* section of this recipe for a more general
    function signature with input and output arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The processing is simply done by creating a double loop that goes over all
    pixel values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can be tested using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you, for example, the following image (refer to the book''s
    graphics PDF to view this image in color):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a color image, the first three bytes of the image data buffer give values
    of the upper-left pixel to the 3-color channel, the next three bytes are the values
    of the second pixel of the first row, and so on (remember that OpenCV uses, by
    default, the BGR channel order). An image of width `W` and height `H` would then
    require a memory block of `WxHx3` `uchars`. However, for efficiency reasons, the
    length of a row can be padded with a few extra pixels. This is because some multimedia
    processor chips (for example, the Intel MMX architecture) can process images more
    efficiently when their rows are multiples of 4 or 8\. Obviously, these extra pixels
    are not displayed or saved; their exact values are ignored. OpenCV designates
    the length of a padded row as the effective width. Obviously, if the image has
    not been padded with extra pixels, the effective width will be equal to the real
    image width. We have already learned that the `cols` and `rows` attributes give
    you the image's width and height; similarly, the `step` data attribute gives you
    the effective width in number of bytes. Even if your image is of a type other
    than `uchar`, the `step` data will still give you the number of bytes in a row.
    The size of a pixel element is given by the `elemSize` method (for example, for
    a 3-channel short integer matrix (`CV_16SC3`), `elemSize` will return `6`). Recall
    that the number of channels in the image is given by the `nchannels` method (which
    will be `1` for a gray-level image and `3` for a color image). Finally, the `total`
    method returns the total number of pixels (that is, the matrix entries) in the
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of pixel values per row is then given by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify the computation of the pointer arithmetic, the `cv::Mat` class
    offers a method that directly gives you the address of an image row. This is the
    `ptr` method. It is a template method that returns the address of row number `j`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the processing statement, we could have equivalently used the
    pointer arithmetic to move from column to column. So, we could have written the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The color reduction function presented in this recipe provides just one way
    of accomplishing this task. You could also use other color reduction formulas.
    A more general version of the function would also allow the specification of distinct
    input and output images. The image scanning can also be made more efficient by
    taking into account the continuity of the image data. Finally, it is also possible
    to use regular low-level pointer arithmetic to scan the image buffer. All of these
    elements are discussed in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Other color reduction formulas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our example, color reduction is achieved by taking advantage of an integer
    division that floors the division result to the nearest lower integer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The reduced color could have also been computed using the modulo operator that
    brings us to the nearest multiple of `div` (the per-channel reduction factor)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option would be to use bitwise operators. Indeed, if we restrict the
    reduction factor to a power of `2`, that is, `div=pow(2,n)`, then masking the
    first `n` bits of the pixel value would give us the nearest lower multiple of
    `div`. This mask would be computed by a simple bit shift as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The color reduction would be given by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In general, bitwise operations might lead to very efficient code, so they could
    constitute a powerful alternative when efficiency is a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Having input and output arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our color reduction example, the transformation is directly applied to the
    input image, which is called an in-place transformation. This way, no extra image
    is required to hold the output result, which could save on the memory usage when
    it is a concern. However, in some applications, the user might want to keep the
    original image intact. The user would then be forced to create a copy of the image
    before calling the function. Note that the easiest way to create an identical
    deep copy of an image is to call the `clone` method; for example, take a look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This extra overload can be avoided by defining a function that gives the user
    the option to either use or not use in-place processing. The signature of the
    method would then be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the input image is now passed as a `const` reference, which means
    that this image will not be modified by the function. The output image is passed
    as a reference such that the calling function will see the output argument modified
    by this call. When in-place processing is preferred, the same image is specified
    as the input and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, another `cv::Mat` instance can be provided; for example, take a look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The key here is to first verify whether the output image has an allocated data
    buffer with a size and pixel type that matches the one of the input image. Very
    conveniently, this check is encapsulated inside the `create` method of `cv::Mat`.
    This is the method that is to be used when a matrix must be reallocated with a
    new size and type. If, by chance, the matrix already has the size and type specified,
    then no operation is performed and the method simply returns without touching
    the instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, our function should simply start with a call to `create` that builds
    a matrix (if necessary) of the same size and type as the input image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The allocated memory block has a size of `total()*elemSize()`. The looping
    is then done with two pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the case where the same image is provided as the input and output, this function
    becomes completely equivalent to the first version presented in this recipe. If
    another image is provided as the output, the function will work correctly irrespective
    of whether the image has or has not been allocated prior to the function call.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient scanning of continuous images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We previously explained that, for efficiency reasons, an image can be padded
    with extra pixels at the end of each row. However, it is interesting to note that
    when the image is unpadded, it can also be seen as a long one-dimensional array
    of `WxH` pixels. A convenient `cv::Mat` method can tell us whether the image has
    been padded or not. This is the `isContinuous` method that returns `true` if the
    image does not include padded pixels. Note that we could also check the continuity
    of the matrix by writing the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To be complete, this test should also check whether the matrix has only one
    line; in which case, it is continuous by definition. Nevertheless, always use
    the `isContinuous` method to test the continuity condition. In some specific processing
    algorithms, you can take advantage of the continuity of the image by processing
    it in one single (longer) loop. Our processing function would then be written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when the continuity test tells us that the image does not contain padded
    pixels, we eliminate the outer loop by setting the width to `1` and the height
    to `WxH`. Note that there is also a `reshape` method that could have been used
    here. You would write the following in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `reshape` method changes the matrix dimensions without requiring any memory
    copying or reallocation. The first parameter is the new number of channels and
    the second one is the new number of rows. The number of columns is readjusted
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In these implementations, the inner loop processes all image pixels in a sequence.
    This approach is mainly advantageous when several small images are scanned simultaneously
    into the same loop.
  prefs: []
  type: TYPE_NORMAL
- en: Low-level pointer arithmetics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `cv::Mat` class, the image data is contained in a memory block of unsigned
    chars. The address of the first element of this memory block is given by the data
    attribute that returns an unsigned char pointer. So, to start your loop at the
    beginning of the image, you could have written the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving from one row to the next could have been done by moving your row pointer
    using the effective width as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `step` method gives you the total number of bytes (including the padded
    pixels) in a line. In general, you can obtain the address of the pixel at row
    `j` and column `i` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: However, even if this would work in our example, it is not recommended that
    you proceed this way.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Writing efficient image-scanning loops* recipe in this chapter proposes
    a discussion on the efficiency of the scanning methods presented here
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning an image with iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In object-oriented programming, looping over a data collection is usually done
    using iterators. Iterators are specialized classes that are built to go over each
    element of a collection, hiding how the iteration over each element is specifically
    done for a given collection. This application of the information-hiding principle
    makes scanning a collection easier and safer. In addition, it makes it similar
    in form no matter what type of collection is used. The **Standard Template Library**
    (**STL**) has an iterator class associated with each of its collection classes.
    OpenCV then offers a `cv::Mat` iterator class that is compatible with the standard
    iterators found in the C++ STL.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we again use the color reduction example described in the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An iterator object for a `cv::Mat` instance can be obtained by first creating
    a `cv::MatIterator_` object. As is the case with `cv::Mat_`, the underscore indicates
    that this is a template subclass. Indeed, since image iterators are used to access
    the image elements, the return type must be known at the time of compilation.
    The iterator is then declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can also use the `iterator` type defined inside the `Mat_`
    template class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You then loop over the pixels using the usual `begin` and `end` iterator methods,
    except that these ones are, again, template methods. Consequently, our color reduction
    function is now written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the iterator here returns a `cv::Vec3b` instance because we are
    processing a color image. Each color channel element is accessed using the dereferencing
    operator `[]`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with iterators always follows the same pattern no matter what kind of
    collection is scanned.
  prefs: []
  type: TYPE_NORMAL
- en: First, you create your iterator object using the appropriate specialized class,
    which in our example is `cv::Mat_<cv::Vec3b>::iterator` (or `cv::MatIterator_<cv::Vec3b>`).
  prefs: []
  type: TYPE_NORMAL
- en: You then obtain an iterator initialized at the starting position (in our example,
    the upper-left corner of the image). This is done using a `begin` method. With
    a `cv::Mat` instance, you obtain it as `image.begin<cv::Vec3b>()`. You can also
    use arithmetic on the iterator. For example, if you wish to start at the second
    row of an image, you can initialize your `cv::Mat` iterator at `image.begin<cv::Vec3b>()+image.cols`.
    The end position of your collection is obtained similarly but using the `end`
    method. However, the iterator thus obtained is just outside your collection. This
    is why your iterative process must stop when it reaches the end position. You
    can also use arithmetic on this iterator; for example, if you wish to stop before
    the last row, your final iteration would stop when the iterator reaches `image.end<cv::Vec3b>()-image.cols`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your iterator is initialized, you create a loop that goes over all elements
    until the end is reached. A typical `while` loop will look like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `++` operator is the one that is to be used to move to the next element.
    You can also specify the larger step size. For example, `it+=10` would process
    the image every `10` pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, inside the processing loop, you use the dereferencing operator `*`
    in order to access the current element, using which, you can read (for example,
    `element= *it;`) or write (for example, `*it= element;`). Note that it is also
    possible to create constant iterators that you use if you receive a reference
    to `const` `cv::Mat` or if you wish to signify that the current loop does not
    modify the `cv::Mat` instance. These are declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, they are declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, the start and end positions of the iterator were obtained using
    the `begin` and `end` template methods. As we did in the first recipe of this
    chapter, we could have also obtained them using a reference to a `cv::Mat_` instance.
    This would avoid the need to specify the iterator type in the `begin` and `end`
    methods since this one is specified when the `cv::Mat_` reference is created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Writing efficient image-scanning loops* recipe proposes a discussion on
    the efficiency of iterators when scanning an image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, if you are not familiar with the concept of iterators in object-oriented
    programming and how they are implemented in ANSI C++, you should read a tutorial
    on STL iterators. Simply search the Web with the keywords "STL Iterator" and you
    will find numerous references on the subject.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing efficient image-scanning loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes of this chapter, we presented different ways of scanning
    an image in order to process its pixels. In this recipe, we will compare the efficiency
    of these different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: When you write an image-processing function, efficiency is often a concern.
    When you design your function, you will frequently need to check the computational
    efficiency of your code in order to detect any bottleneck in your processing that
    might slow down your program.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to note that unless necessary, optimization should
    not be done at the price of reducing the program clarity. Simple code is indeed
    always easier to debug and maintain. Only code portions that are critical to a
    program's efficiency should be heavily optimized.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to measure the execution time of a function or a portion of code,
    there exists a very convenient OpenCV function called `cv::getTickCount()`. This
    function gives you the number of clock cycles that have occurred since the last
    time you started your computer. Since we want the execution time of a code portion
    given in seconds, we use another method, `cv::getTickFrequency()`. This gives
    us the number of cycles per second. The usual pattern to be used in order to obtain
    the computational time of a given function (or portion of code) would then be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The execution times of the different implementations of the `colorReduce` function
    from this chapter are reported here. The absolute runtime numbers would differ
    from one machine to another (here, we used a 2.40 GHz machine equipped with a
    64-bit Intel Core i7). It is rather interesting to look at their relative difference.
    These results are also dependent on the specific compiler that is used to produce
    the executable file. Our tests report the average time to reduce the colors of
    an image that has a resolution of 4288 x 2848 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: First, we compare the three ways of computing the color reduction as presented
    in the *There's more...* section of the *Scanning an image with pointers* recipe.
    It is interesting to observe that the formula that uses the bitwise operator is
    much faster than the others at 9.5ms. The one using the integer division is at
    26ms. The version based on the modulo operator is, however, at 33 ms. This represents
    a factor of more than 3 between the fastest and the slowest! It is therefore important
    to take the time to identify the most efficient way of computing a result in an
    image loop, as the net impact can be very significant.
  prefs: []
  type: TYPE_NORMAL
- en: When an output image that needs to be reallocated is specified instead of in-place
    processing, the execution time becomes 29 ms. The extra duration represents the
    overhead for memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a loop, you should avoid repetitive computations of values that could be
    precomputed instead. This consumes time, obviously. For example, you take the
    following inner loop of the color reduction function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you replace it with the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a loop where you need to compute the total number of elements
    in a line and the `div>>1` result again and again; you will obtain a runtime of
    52 ms, which is significantly slower than the original version at 26 ms. Note,
    however, that some compilers might be able to optimize these kinds of loops and
    still obtain efficient code.
  prefs: []
  type: TYPE_NORMAL
- en: The version of the color reduction function that uses iterators, as shown in
    the *Scanning an image with iterators* recipe, gives slower results at 52 ms.
    The main objective of iterators is to simplify the image-scanning process and
    make it less prone to errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'For completeness, we also implemented a version of the function that uses the
    `at` method for pixel access. The main loop of this implementation would then
    simply read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This implementation is much slower when a runtime of 53 ms is obtained. This
    method should then be used only for the random access of image pixels but never
    when scanning an image.
  prefs: []
  type: TYPE_NORMAL
- en: A shorter loop with few statements is generally more efficiently executed than
    a longer loop over a single statement even if the total number of elements processed
    is the same. Similarly, if you have `N` different computations to apply to a pixel,
    apply all of them in one loop rather than writing `N` successive loops, one for
    each computation.
  prefs: []
  type: TYPE_NORMAL
- en: We also performed the continuity test that produces one loop in the case of
    continuous images instead of the regular double loop over lines and columns. For
    a very large image, like the one we used in our tests, this optimization is not
    significant (25 ms instead of 26 ms), but in general, it is always a good practice
    to use this strategy, since it can lead to a significant gain in speed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multithreading is another way to increase the efficiency of your algorithms,
    especially since the advent of multicore processors. **OpenMP** and the **Intel
    Threading Building Blocks** (**TBB**) are two popular APIs that are used in concurrent
    programming to create and manage your threads. In addition, C++11 now offers built-in
    support for threads.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Performing simple image arithmetic* recipe presents an implementation of
    the color-reduction function (described in the *There's more...* section) that
    uses the OpenCV 2 arithmetic image operators and has a runtime of 25 ms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Applying look-up tables to modify image appearance* recipe of [Chapter
    4](part0032_split_000.html#page "Chapter 4. Counting the Pixels with Histograms"),
    *Counting the Pixels with Histograms* describes an implementation of the color-reduction
    function based on a look-up table. The idea is to precompute all intensity reduction
    values that lead to a runtime of 22 ms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning an image with neighbor access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In image processing, it is common to have a processing function that computes
    a value at each pixel location based on the value of the neighboring pixels. When
    this neighborhood includes pixels of the previous and next lines, you then need
    to simultaneously scan several lines of the image. This recipe shows you how to
    do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To illustrate this recipe, we will apply a processing function that sharpens
    an image. It is based on the Laplacian operator (which will be discussed in [Chapter
    6](part0047_split_000.html#page "Chapter 6. Filtering the Images"), *Filtering
    the Images*). It is indeed a well-known result in image processing that if you
    subtract the Laplacian from an image, the image edges are amplified, thereby giving
    a sharper image.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sharpened value is computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, `left` is the pixel that is immediately on the left-hand side of the current
    one, `up` is the corresponding one on the previous line, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This time, the processing cannot be accomplished in-place. Users need to provide
    an output image. The image scanning is done using three pointers, one for the
    current line, one for the line above, and another one for the line below. Also,
    since each pixel computation requires access to the neighbors, it is not possible
    to compute a value for the pixels of the first and last row of the image as well
    as the pixels of the first and last column. The loop can then be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we wrote the function such that it would work on both gray-level and
    color images. If we apply this function on a gray-level version of our test image,
    the following result is obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to access the neighboring pixels of the previous and next row, you
    must simply define additional pointers that are jointly incremented. You then
    access the pixels of these lines inside the scanning loop.
  prefs: []
  type: TYPE_NORMAL
- en: In the computation of the output pixel value, the `cv::saturate_cast` template
    function is called on the result of the operation. This is because it often happens
    that a mathematical expression applied on pixels leads to a result that goes outside
    the range of the permitted pixel values (that is, below 0 or over 255). The solution
    is then to bring the values back inside this 8-bit range. This is done by changing
    negative values to `0` and values over `255` to `255`. This is exactly what the
    `cv::saturate_cast<uchar>` function is doing. In addition, if the input argument
    is a floating point number, then the result is rounded to the nearest integer.
    You can obviously use this function with other types in order to guarantee that
    the result will remain within the limits defined by this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Border pixels that cannot be processed because their neighborhood is not completely
    defined need to be handled separately. Here, we simply set them to `0`. In other
    cases, it could be possible to perform a special computation for these pixels,
    but most of the time, there is no point in spending time to process these very
    few pixels. In our function, these border pixels are set to `0` using two special
    methods. The first one is `row` and its dual is `col`. They return a special `cv::Mat`
    instance composed of a single-line ROI (or a single-column ROI) as specified in
    a parameter (remember, we discussed region of interest in the previous chapter).
    No copy is made here because if the elements of this 1D matrix are modified, they
    will also be modified in the original image. This is what we do when the `setTo`
    method is called. This method assigns a value to all elements of a matrix. Take
    a look at the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statement assigns the value of `0` to all pixels of the first
    line of the result image. In the case of a 3-channel color image, you would use
    `cv::Scalar(a,b,c)` to specify the three values to be assigned to each channel
    of the pixel.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a computation is done over a pixel neighborhood, it is common to represent
    this with a kernel matrix. This kernel describes how the pixels involved in the
    computation are combined in order to obtain the desired result. For the sharpening
    filter used in this recipe, the kernel would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 | -1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| -1 | 5 | -1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | -1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: Unless stated otherwise, the current pixel corresponds to the center of the
    kernel. The value in each cell of the kernels represents a factor that multiplies
    the corresponding pixel. The result of the application of the kernel on a pixel
    is then given by the sum of all these multiplications. The size of the kernel
    corresponds to the size of the neighborhood (here, 3 x 3). Using this representation,
    it can be seen that, as required by the sharpening filter, the four horizontal
    and vertical neighbors of the current pixel are multiplied by -1, while the current
    one is multiplied by 5\. Applying a kernel to an image is more than a convenient
    representation; it is the basis for the concept of convolution in signal processing.
    The kernel defines a filter that is applied to the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since filtering is a common operation in image processing, OpenCV has defined
    a special function that performs this task: the `cv::filter2D` function. To use
    this, you just need to define a kernel (in the form of a matrix). The function
    is then called with the image and the kernel, and it returns the filtered image.
    Using this function, it is therefore, easy to redefine our sharpening function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This implementation produces exactly the same result as the previous one (and
    with the same efficiency). If you input a color image, then the same kernel will
    be applied to all three channels. Note that it is particularly advantageous to
    use the `filter2D` function with a large kernel, as it uses, in this case, a more
    efficient algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 6](part0047_split_000.html#page "Chapter 6. Filtering the Images"),
    *Filtering the Images*, provides more explanations on the concept of image filtering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing simple image arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images can be combined in different ways. Since they are regular matrices, they
    can be added, subtracted, multiplied, or divided. OpenCV offers various image
    arithmetic operators, and their use is discussed in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s work with a second image that we will combine to our input image using
    an arithmetic operator. The following represents this second image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we add two images. This is useful when we want to create some special
    effects or to overlay information over an image. We do this by calling the `cv::add`
    function, or more precisely here, the `cv::addWeighted` function, since we want
    a weighted sum as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The operation results in a new image, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All binary arithmetic functions work the same way. Two inputs are provided
    and a third parameter specifies the output. In some cases, weights that are used
    as scalar multipliers in the operation can be specified. Each of these functions
    comes in several flavors; `cv::add` is a good example of a function that is available
    in many forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'For some functions, you can also specify a mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you apply a mask, the operation is performed only on pixels for which the
    mask value is not null (the mask must be 1-channel). Have a look at the different
    forms of `cv::subtract`, `cv::absdiff`, `cv::multiply`, and `cv::divide` functions.
    Bit-wise operators (operators applied to each individual bit of the pixels'' binary
    representation) are also available: `cv::bitwise_and`, `cv::bitwise_or`, `cv::bitwise_xor`,
    and `cv::bitwise_not`. The `cv::min` and `cv::max` operators, which find the per-element
    maximum or minimum pixel value, are also very useful.'
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, the `cv::saturate_cast` function (see the preceding recipe) is
    always used to make sure that the results stay within the defined pixel value
    domain (that is, to avoid overflow or underflow).
  prefs: []
  type: TYPE_NORMAL
- en: The images must have the same size and type (the output image will be reallocated
    if it does not match the input size). Also, since the operation is performed per-element,
    one of the input images can be used as the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several operators that take a single image as the input are also available:
    `cv::sqrt`, `cv::pow`, `cv::abs`, `cv::cuberoot`, `cv::exp`, and `cv::log`. In
    fact, there exists an OpenCV function for almost any operation you have to apply
    on image pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also possible to use the usual C++ arithmetic operator on the `cv::Mat`
    instances or on the individual channels of `cv::Mat` instances. The two following
    subsections explain how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Overloaded image operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Very conveniently, most arithmetic functions have their corresponding operator
    overloaded in OpenCV 2\. Consequently, the call to `cv::addWeighted` can be written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a more compact form that is also easier to read. These
    two ways of writing the weighted sum are equivalent. In particular, the `cv::saturate_cast`
    function will still be called in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: Most C++ operators have been overloaded. Among them are the bitwise operators
    `&`, `|`, `^`, and `~`; the `min`, `max`, and `abs` functions. The comparison
    operators `<`, `<=`, `==`,`!=`, `>`, and `>=` have also been overloaded, and they
    return an 8-bit binary image. You will also find the `m1*m2` matrix multiplication
    (where `m1` and `m2` are both `cv::Mat` instances), the `m1.inv()` matrix inversion,
    the `m1.t()` transpose, the `m1.determinant()` determinant, the `v1.norm()` vector
    norm, the `v1.cross(v2)` cross-product, the `v1.dot(v2)` dot product, and so on.
    When this makes sense, you also have the corresponding compound assignment operator
    defined (the `+=` operator, as an example).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *Writing efficient image-scanning loops* recipe, we presented a color-reduction
    function that was written using loops that scan the image pixels to perform some
    arithmetic operations on them. From what we learned here, this function could
    be rewritten simply using arithmetic operators on the input image as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The use of `cv::Scalar` is due to the fact that we are manipulating a color
    image. Performing the same test as we did in the *Writing efficient image-scanning
    loops* recipe, we obtain an execution time of 53 ms. Using the image operators
    makes the code so simple, and the programmer so productive, that you should consider
    their use in most situations.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the image channels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You''ll sometimes want to process the different channels of an image independently.
    For example, you might want to perform an operation only on one channel of the
    image. You can, of course, achieve this in an image-scanning loop. However, you
    can also use the `cv::split` function that will copy the three channels of a color
    image into three distinct `cv::Mat` instances. Suppose we want to add our rain
    image to the blue channel only. The following is how we would proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `cv::merge` function performs the inverse operation, that is, it creates
    a color image from three 1-channel images.
  prefs: []
  type: TYPE_NORMAL
- en: Remapping an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the recipes of this chapter, you learned how to read and modify the pixel
    values of an image. The last recipe will teach you how to modify the appearance
    of an image by moving its pixels. The pixel values are not changed by this process;
    it is rather the position of each pixel that is remapped to a new location. This
    is useful in order to create special effects on an image or to correct image distortions
    caused, for example, by a lens.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use the OpenCV `remap` function, you simply have to first define
    the map to be used in the remapping process. Second, you have to apply this map
    on an input image. Obviously, it is the way you define your map that will determine
    the effect that will be produced. In our example, we define a transformation function
    that will create a wavy effect on the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The objective of remapping is to produce a new version of an image in which
    pixels have changed in position. To construct this new image, we need to know
    what the original position for each pixel in the destination image in the source
    image is. The mapping function that is needed is therefore the one that will give
    us the original pixel positions as a function of the new pixel positions. This
    is called **backward** **mapping** because the transformation describes how the
    pixels of the new images are mapped back to the original image. In OpenCV, backward
    mapping is described using two maps: one for the x-coordinates and one for the
    y-coordinates. They are both represented by floating point `cv::Mat` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The size of these matrices will define the size of the destination image. The
    value of the `(i,j)` pixel of the destination image can then be read in the source
    image using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, a simple image flip effect like the one we demonstrated in [Chapter
    1](part0014_split_000.html#page "Chapter 1. Playing with Images"), *Playing with
    Images*, can be created by the following maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate the resulting image, you simply call the OpenCV `remap` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: It is interesting to note that the two maps contain floating-point values. Consequently,
    a pixel in the destination can map back to a non-integral value (that is, a location
    between pixels). This is very convenient because this allows us to define the
    mapping function of our choice. For instance, in our remapping example, we used
    a `sinusoidal` function to define our transformation. However, this also means
    that we have to interpolate the value of virtual pixels in between real pixels.
    There exist different ways of performing pixel interpolation, and the last parameter
    of the `remap` function allows us to select the method that will be used. Pixel
    interpolation is an important concept in image processing; this subject will be
    discussed in [Chapter 6](part0047_split_000.html#page "Chapter 6. Filtering the
    Images"), *Filtering the Images*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *There's more...* section of the *Filtering images using low-pass filters*
    recipe of [Chapter 6](part0047_split_000.html#page "Chapter 6. Filtering the Images"),
    *Filtering the Images*, explains the concept of pixel interpolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Calibrating a camera* recipe of [Chapter 10](part0067_split_000.html#page
    "Chapter 10. Estimating Projective Relations in Images"), *Estimating Projective
    Relations in Images*, uses remapping to correct lens distortions in an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Computing a homography between two images* recipe of [Chapter 10](part0067_split_000.html#page
    "Chapter 10. Estimating Projective Relations in Images"), *Estimating Projective
    Relations in Images*, uses perspective image warping to build an image panorama
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
