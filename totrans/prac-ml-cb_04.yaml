- en: Chapter 4. Model Selection and Regularization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Shrinkage methods - calories burned per day
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dimension reduction methods - Delta's Aircraft Fleet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Principal component analysis - understanding world cuisine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Subset selection**: The use of labeled examples to induce a model that classifies
    objects into a finite set of known classes is one of the main challenges of supervised
    classification in machine learning. Vectors of numeric or nominal features are
    used to describe the various examples. In the feature subset selection problem,
    a learning algorithm is faced with the problem of selecting some subset of features
    upon which to focus its attention, while ignoring the rest.'
  prefs: []
  type: TYPE_NORMAL
- en: When fitting a linear regression model, a subset of variables that best describe
    the data are of interest. There are a number of different ways the best subset,
    applying a number of different strategies, can be adopted when searching for a
    variables set. If there are *m* variables and the best regression model consists
    of *p* variables, *p≤m*, then a more general approach to pick the best subset
    might be to try all possible combinations of *p* variables and select the model
    that fits the data the best.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are *m! p!(m−p)! *possible combinations, which increases with
    the increase in the value of *m*, for example, *m = 20* and *p = 4* gives 4,845
    possible combinations. In addition, through the usage of fewer features, we may
    reduce the cost of acquiring the data and improve the comprehensibility of the
    classification model.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shrinkage methods:** Shrinkage regression refers to shrinkage methods of
    estimation or prediction in regression situations; useful when there is multi
    co-linearity among the regressors. In cases where the dataset is small compared
    to the number of co-variables studied, shrinkage techniques may improve predictions.
    The common shrinkage methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Linear shrinkage factor--shrinks all coefficients with the same factor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ridge regression--penalized maximum likelihood, penalty factor is added to the
    likelihood function such that coefficients are shrunk individually according to
    the variance of each co-variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lasso--shrinks some coefficients to zero by setting a constraint on the sum
    of the absolute values of the coefficients of standardized co-variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shrinkage methods retain a subset of the predictors, while discarding the rest.
    The subset selection produces a model that is interpretable and produces possibly
    lower prediction-errors than the full model, while not reducing the prediction
    error of the full model. Shrinkage methods more continuous and don't suffer as
    much from high variability. When there are many correlated variables in a linear
    regression model, their coefficients are poorly determined and exhibit high variance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dimension reduction methods:** One of the significant challenges across a
    wide variety of information-processing fields, including pattern recognition,
    data compression, machine learning, and database navigation, is manifold learning.
    The measured data vectors are high-dimensional and, in many cases, the data lies
    near a lower-dimensional manifold. The main challenges of high-dimensional data
    are that it is multiple; it indirectly measures the underlying source, which typically
    cannot be directly measured. Dimensionality reduction may also be seen as the
    process of deriving a set of degrees of freedom, which can be used to reproduce
    most of the variability of a dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: Shrinkage methods - calories burned per day
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to compare the metabolic rate of humans, the concept of **basal metabolic
    rate** (**BMR**) is critical, in a clinical context, as a means of determining
    thyroid status in humans. The BMR of mammals varies with body mass, with the same
    allometric exponent as field metabolic rate, and with many physiological and biochemical
    rates. Fitbit, as a device, uses BMR and activities performed during the day to
    estimate calories burned throughout the day.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform shrinkage methods, we shall be using a dataset collected
    from Fitbit and a calories-burned dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dataset titled `fitbit_export_20160806.csv` which is in CSV format shall
    be used. The dataset is in standard format. There are 30 rows of data and 10 variables.
    The numeric variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Calories Burned`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Steps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Distance`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Floors`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Minutes Sedentary`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Minutes Lightly Active`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Minutes Fairly Active`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExAng`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Minutes Very Active`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Activity Calories`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The non-numeric variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the first step, the following packages need to be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.3.0 (2016-05-03)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the data and understand the relationships among the variables.
    We''ll begin by importing the csv data file named `fitbit_export_20160806.csv`.
    We will be saving the data to the `fitbit_details` frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Storing the `fitbit_details` data frame to the `fitbit` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing data frame `fitbit`. The `head()` function returns the first part
    of the `fitbit` data frame. The `fitbit` data frame is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Setting `Activity.Calories` and `Date` values as NULL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Scaling coefficients to calories per thousand steps. The result is then set
    to the `fitbit$Steps` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `fitbit$Steps` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_04_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring all the candidate variables. Function for calculating correlation
    coefficients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Producing a matrix of scatterplots. The `pairs()`function produces the scatter
    plots in matrix form. `fitbit` is the dataset for scatter plots. Distance can
    be calculated almost exactly directly from `Steps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_04_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing `fitbit data frame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_04_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - building the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Building ordinary least squares estimation with Steps as the sole explanatory
    variable and `Calories.Burned` as the response variable. `lm()` as a function
    is used to fit linear models. `Calories.Burned ~ Steps` is the formula, while
    `fitbit` is the data frame. The result is then stored in the moderate data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `moderate` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - building the model](img/image_04_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Rounding off the values of the `moderate` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - building the model](img/image_04_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting the predicted calories with the residuals from the model used. The `plot()` function
    is a generic function for plotting R objects. The `moderate` data frame is passed
    as a function value. The `bty` parameter determines the type of box drawn about
    plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - building the model](img/image_04_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Checking the partial autocorrelation function of residuals. `pacf()` is used
    for partial autocorrelations. `resid()` as a function computes the difference
    between the observed data of the dependent variable. `moderate` is passed as a
    data frame to the `resid()` function, to compute the difference between the observed
    data of the dependent variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `grid()` function adds the grids to the plotted data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - building the model](img/image_04_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - improving the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Predicting daily calories based on all seven explanatory variables. Fitting
    the model to multiple samples at different values of alpha, using the fit model
    to predict the out of bag points from the original sample that weren't in the
    re-sample. It is about creating the balance between the extremes of ridge regression
    and lasso estimation by choosing an appropriate value of alpha.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating the matrix X by standardizing. The `as.matrix()` function turns `fitbit[
    , -1]` that is, apart from date column into matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `X` data frame. The `head()` function returns the first part of
    the `X` data frame. The `X` data frame is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_04_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating the vector `Y` by standardizing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `Y` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_04_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating regular sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating five repeats of each CV run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating the dataset to be used. The `data.frame()` function is used to create
    data frames based on a tightly coupled set of variables. These variables share
    the properties of matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `res` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_04_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating a vector of `average_rmse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `res$average_rmse` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_04_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Arranging the `res$average_rmse` in ascending order. The result is then stored
    in the `res` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `res` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_04_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_04_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the  `bestalpha` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![Step 4 - improving the model](img/image_04_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Comparing ordinary least squares equivalents with the estimated values of the
    eight coefficients (seven explanatory variables plus an intercept) by using elastic
    net.
  prefs: []
  type: TYPE_NORMAL
- en: 'Determining lambda at best value of alpha. Computing k-fold cross-validation
    for `glmnet` by calling the `cv.glmnet()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating the model. `glmnet()` fits a generalized linear model via penalized
    maximum likelihood. The regularization path is computed for the lasso or `elasticnet`
    penalty at a grid of values for the regularization parameter lambda. `X` is the
    input matrix, while `Y` is the response variable. `alpha` is the `elasticnet`
    mixing parameter, with 0 ≤ α ≤ 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Building an ordinary least squares estimation, with `fitbit` as the sole explanatory
    variable and `Calories.Burned` as the response variable. `lm()` as a function
    is used to fit linear models. `Calories.Burned ~ Steps` is the formula, while
    `fitbit` is the data frame. The result is then stored in the `OLSmodel` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `OLSmodel` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_04_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Comparing ordinary least squares equivalents with the estimated values of the
    eight coefficients (seven explanatory variables plus an intercept). The result
    is then stored in the `coeffs` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `coeffs` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_04_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Rounding off the values of the `moderate` data frame to three significant digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_04_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating the model. `glmnet()` fits a generalized linear model via a penalized
    maximum likelihood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `moderate2` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_04_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Rounding off the values to three significant digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_04_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating the model. `glmnet()`fits a generalized linear model via a penalized
    maximum likelihood after eliminating the distance column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `moderate3` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_04_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Building ordinary least squares estimation `Y ~ X[ , -2]` is the formula. The
    result is then stored in the `moderate4` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `moderate4` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_04_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Rounding off the values to three significant digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_04_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 - comparing the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comparing the predictive strength of different models by using bootstrapping,
    where the modeling approach is applied to bootstrap re-samples of the data. The
    estimate model is then used to predict the full, original dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Function to feed to boot that does elastic modeling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating an R bootstrap replica of a statistic applied to data. `fitbit`
    is the dataset, `statistic = modellingfucn1` is the function, which, when applied
    to `fitbit`, returns a vector containing the statistics of interest. `R = 99`  indicates
    the number of bootstrap replicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `elastic_boot` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - comparing the model](img/image_04_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Function to feed to boot that does OLS modeling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating an R bootstrap replica of a statistic applied to data. `fitbit`
    is the dataset, `statistic = modellingOLS` is the function, which, when applied
    to `fitbit`, returns a vector containing the statistics of interest. `R = 99`  indicates
    the number of bootstrap replicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `lmOLS_boot` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - comparing the model](img/image_04_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Generating an R bootstrap replica of a statistic applied to data. `fitbit`
    is the dataset, `statistic = modellingfucn2` is the function, which, when applied
    to `fitbit`, returns a vector containing the statistics of interest. `R = 99`  indicates
    the number of bootstrap replicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `lm_boot` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - comparing the model](img/image_04_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - comparing the model](img/image_04_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Refitting the model with scaled variables.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the model. `glmnet()` fits a generalized linear model via a penalized
    maximum likelihood.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - comparing the model](img/image_04_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dimension reduction methods - Delta's Aircraft Fleet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fleet planning is a part of the strategic planning process for any airline company.
    Fleet is the total number of aircraft that an airline operates, as well as the
    specific aircraft types that comprise the total fleet. Airline selection criteria
    for aircraft acquisition are based on technical/performance characteristics, economic
    and financial impact, environmental regulations and constraints, marketing considerations,
    and political realities. Fleet composition is a critical long-term strategic decision
    for an airline company. Each aircraft type has different technical performance
    characteristics, for example, the capacity to carry the payload over a maximum
    flight distance or range. It affects financial position, operating costs, and
    especially the ability to serve specific routes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform dimension reduction we shall be using a dataset collected
    on Delta Airlines Aircraft Fleet.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dataset titled `delta.csv` shall be used. The dataset is in standard format.
    There are 44 rows of data and 34 variables.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to load the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.3.2 (2016-10-31)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the data and understand the relationships among the variables.
    We''ll begin by importing the csv data file named `delta.csv`. We will be saving
    the data to the delta frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the internal structure of the `delta` data frame. The `str()` function
    displays the internal structure of the data frame. The details passed as an R
    object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_04_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the intermediary quantitative variables related to the aircraft''s
    physical characteristics: Accommodation, Cruising Speed, Range, Engines, Wing
    Span, Tail Height, and `Length.Scatter` plot matrix. The `plot()` function is
    a generic function for plotting Robjects. The `delta[,16:22]` data frame is passed
    as a function value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_04_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a positive correlation between all these variables as all of them are
    related to the aircraft's overall size.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 - applying principal components analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Visualizing a high-dimensional dataset, such as the number of engines. Applying
    principle components analysis to data. The `princomp()` function performs principal
    components analysis on the `delta` datamatrix. The result is `principal_comp_analysis`,
    which is an object of class `princomp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `principal_comp_analysis` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - applying principal components analysis](img/image_04_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting `principal_comp_analysis` data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - applying principal components analysis](img/image_04_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is demonstrable that the first principal component has a standard deviation,
    which accounts for over 99.8% of the variance in the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Printing loadings of principal components analysis. The `loadings()` function
    uses the `principal_comp_analysis` principal components-analysis data object as
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - applying principal components analysis](img/image_04_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Looking at the first column of loadings, it is clear that the first principle
    component is just the range, in miles. The scale of each variable in the dataset
    is different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plotting variance on regular scaling. `barplot()` plots both vertical and horizontal
    bars. `sapply()` is a wrapper function that returns a list of the same length
    as `delta.horiz=T` signifies a logical value that the bars are to be drawn horizontally,
    with the first at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - applying principal components analysis](img/image_04_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting variance on a logarithmic scale. `barplot()` plots both vertical and
    horizontal bars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - applying principal components analysis](img/image_04_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 - scaling the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The scaling of `delta` data is useful under certain circumstances, since the
    variables span different ranges. `scale()`as a function centers and/or scales
    the columns of the `delta` matrix. The result is then stored in the `delta2` data
    frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Verifying whether the variance is uniform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - scaling the data](img/image_04_036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The variance is now constant across variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying principal components to the scaled data `delta2`. The `princomp()` function
    performs principal components analysis on the `delta2` datamatrix. The result
    is `principal_comp_analysis`, which is an object of class `princomp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting the `principal_comp_analysis` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - scaling the data](img/image_04_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - scaling the data](img/image_04_038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `summary()` function is used to produce summaries of the results of various
    model-fitting functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - scaling the data](img/image_04_039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Applying principal components to the scaled data `delta2`. The `prcomp()` function
    performs principal components analysis on the `delta2` datamatrix. The result
    is `principal_comp_analysis`, which is an object of class `prcomp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a data frame of `principal_comp_vectors`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying k means with `k = 4`. The `kmeans()`function performs k-means clustering
    on comp. `nstart=25` signifies the number of random sets to be chosen. `iter.max=1000` is
    the maximum number of iterations allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a vector of nine contiguous colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting comp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - scaling the data](img/image_04_040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 - visualizing in 3D plot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Plotting in 3D `comp$PC1`, `comp$PC2`, `comp$PC3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - visualizing in 3D plot](img/image_04_041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting in 3D `comp$PC1`, `comp$PC3`, `comp$PC4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - visualizing in 3D plot](img/image_04_042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Examining the clusters in order of increasing size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - visualizing in 3D plot](img/image_04_043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Names as displayed in the first cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - visualizing in 3D plot](img/image_04_044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Names as displayed in the second cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - visualizing in 3D plot](img/image_04_045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Names as displayed in the third cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - visualizing in 3D plot](img/image_04_046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Names as displayed in the fourth cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - visualizing in 3D plot](img/image_04_047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Principal component analysis - understanding world cuisine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Food is a powerful symbol of who we are. There are many types of food identification,
    such as ethnic, religious, and class identifications. Ethnic food preferences
    become identity markers in the presence of gustatory foreigners, such as when
    one goes abroad, or when those foreigners visit the home shores.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform principal component analysis, we shall be using a dataset
    collected on the Epicurious recipe dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dataset titled `epic_recipes.txt` shall be used. The dataset is in standard
    format.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to load the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.3.2 (2016-10-31)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the data and understand the relationships among the variables.
    We''ll begin by importing the TXT data file named `epic_recipes.txt`. We will
    be saving the data to the `datafile` frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading a file in table format and creating a data frame from it. `datafile`
    is the file name, which is passed as an input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Step 3 - preparing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Splitting the data into subsets. `aggregate()` splits `recipes_data[,-1]` and
    computes summary statistics. `recipes_data[,-1]`list of grouping elements, each
    as long as the variables in the data frame. The result is then stored in the `agg`
    data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a vector, array, or list of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Replacing all occurrence of patterns. `gsub()` as a function replaces each
    `,NA` with `""` after searching `agg$combined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Extracting the names of all cuisines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the cuisines data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing data](img/image_04_048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Extracting the frequency of ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Normalizing the frequency of ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'List of 26 elements, one for each cuisine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The `scale()` function centers and/or scales the columns of the `prop_matrix` matrix.
    The result is then stored in the `final_impdata` frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating heatmap. `final_imp` is the data frame passed as an input. `trace="none"` signifies
    the character string, indicating whether a solid `"trace"` line should be drawn
    across rows or down columns, `"both"` or `"none"`. The `key=TRUE` value represents
    that a color-key should be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing data](img/image_04_049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - applying principal components analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Applying principle components analysis to data. `princomp()` performs principal
    components analysis on the `final_imp` datamatrix. The result is `pca_computation`,
    which is an object of class `princomp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `pca_computation` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - applying principal components analysis](img/image_04_050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Producing a biplot. `pca_computation` is an object of class `princomp`. `pc.biplot=TRUE` means
    it is a principal component biplot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - applying principal components analysis](img/image_04_051.jpg)'
  prefs: []
  type: TYPE_IMG
