- en: Building ChefBot Hardware and the Integration of Software
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 ChefBot 硬件和软件集成
- en: In [Chapter 3](lrn-rbt-py-2e_ch03.html), *Modeling a Differential Robot Using
    ROS and URDF*, we looked at the ChefBot chassis design. In this chapter, we will
    learn how to assemble this robot using those parts. We will also look at the final
    interfacing of the sensors and other electronic components of this robot with
    Tiva-C LaunchPad. After the interfacing, we will learn how to interface the robot
    with the PC and implement autonomous navigation using SLAM and AMCL in the real
    robot.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](lrn-rbt-py-2e_ch03.html) 中，*使用 ROS 和 URDF 建模差速机器人*，我们研究了 ChefBot 底盘设计。在本章中，我们将学习如何使用这些部件组装这个机器人。我们还将研究将此机器人的传感器和其他电子组件与
    Tiva-C LaunchPad 最终连接的方法。连接后，我们将学习如何将机器人与 PC 连接，并使用 SLAM 和 AMCL 在真实机器人上实现自主导航。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Building ChefBot hardware
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 ChefBot 硬件
- en: Configuring the ChefBot PC and packages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 ChefBot PC 和软件包
- en: Interfacing the ChefBot sensors with Tiva-C Launchpad
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 ChefBot 传感器与 Tiva-C Launchpad 连接
- en: Embedded code for ChefBot
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChefBot 的嵌入式代码
- en: Understanding ChefBot ROS packages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 ChefBot ROS 软件包
- en: Implementing SLAM on ChefBot
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ChefBot 上实现 SLAM
- en: Autonomous navigation in ChefBot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChefBot 的自主导航
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To test the application and codes in this chapter, you will need an Ubuntu 16.04
    LTS PC/laptop with ROS Kinetic installed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试本章中的应用程序和代码，您需要一个安装了 ROS Kinetic 的 Ubuntu 16.04 LTS PC/笔记本电脑。
- en: You will also need fabricated robot chassis parts for assembling the robot.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要为组装机器人而制造的机器人底盘部件。
- en: You should have all the sensors and other hardware components that can be integrated
    in the robot.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该拥有所有可以集成到机器人中的传感器和其他硬件组件。
- en: We have already discussed interfacing individual robot components and sensors
    with Launchpad. In this chapter, we will try to interface the necessary robotic
    components and sensors of ChefBot and program it in such a way that it will receive
    the values from all sensors and control the information from the PC. Launchpad
    will send all sensor values to the PC via a serial port and also receive control
    information (such as reset commands, speed data, and so on) from the PC.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何将单个机器人组件和传感器与 Launchpad 连接。在本章中，我们将尝试连接 ChefBot 所需的机器人组件和传感器，并编程使其能够接收所有传感器的值并控制来自
    PC 的信息。Launchpad 将通过串行端口将所有传感器值发送到 PC，并从 PC 接收控制信息（如重置命令、速度数据等）。
- en: After receiving Serial port data from the Tiva C Launchpad, a ROS Python node
    will receive the serial values and convert them to ROS topics. There are other
    ROS  nodes present in the PC that subscribe to these sensor topics and compute
    robot odometry. The data from the wheel encoders and IMU values combine to calculate
    the odometry of the robot. The robot detects obstacles by subscribing to the ultrasonic
    sensor topic and laser scan and controls the speed of the wheel motors using the
    PID node. This node converts the linear velocity command to a differential wheel
    velocity command. After running these nodes, we can run SLAM to map the area,
    and after running SLAM, we can run the AMCL nodes for localization and autonomous
    navigation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在从 Tiva C Launchpad 接收到串行端口数据后，一个 ROS Python 节点将接收串行值并将它们转换为 ROS 主题。PC 上还有其他
    ROS 节点订阅这些传感器主题并计算机器人里程计。轮编码器和 IMU 值的数据结合计算机器人的里程计。机器人通过订阅超声波传感器主题和激光扫描来检测障碍物，并使用
    PID 节点控制电机速度。此节点将线性速度命令转换为差速轮速度命令。运行这些节点后，我们可以运行 SLAM 来绘制区域地图，运行 SLAM 后，我们可以运行
    AMCL 节点进行定位和自主导航。
- en: In the first section of this chapter, *Building ChefBot hardware*, we will learn
    how to assemble the ChefBot hardware using the body parts and electronic components
    of the robot.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分 *构建 ChefBot 硬件* 中，我们将学习如何使用机器人的身体部件和电子组件组装 ChefBot 硬件。
- en: Building ChefBot hardware
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 ChefBot 硬件
- en: 'The first section of the robot that needs to be configured is the base plate.
    The base plate consists of two motors and their attached wheels, the caster wheels,
    and the base plate supports. The following image shows the top and bottom view
    of the base plate:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 需要配置的第一个机器人部分是底板。底板由两个电机及其连接的轮子、万向轮和底板支架组成。以下图像显示了底板的上视图和下视图：
- en: '![](img/7c2f37b0-96b3-4745-806a-0f0ff4d719f2.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c2f37b0-96b3-4745-806a-0f0ff4d719f2.png)'
- en: Base plate with motors, wheels, and caster wheels
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 带有电机、轮子和万向轮的底板
- en: The base plate has a radius of 15 cm, and the motors and their attached wheels
    are mounted on the opposite sides of the plate by cutting two sections from the
    base plate. Two rubber caster wheels are mounted on opposite sides of the base
    plate to achieve a good balance and support for the robot. We can either choose
    ball caster wheels or rubber caster wheels for this robot. The wires of the two
    motors are taken to the top of the base plate through a hole in the center of
    the base plate. To extend the layers of the robot, we will put base plate supports
    to connect the following layers. Now, let's look at the next layer with the middle
    plate and connecting tubes. There are hollow tubes to connect the base plate and
    the middle plate. The hollow tubes can be connected to the base plate support.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 底板半径为15厘米，电机及其连接的轮子通过从底板切割两个部分安装到板的对面。在底板的对面安装了两个橡胶万向轮，以实现良好的平衡和对机器人的支撑。对于这个机器人，我们可以选择球型万向轮或橡胶万向轮。两个电机的线通过底板中心的孔拉到顶部的底板上。为了扩展机器人的层，我们将放置底板支架以连接以下层。现在，让我们看看带有中板和连接管的下一层。有空心管连接底板和中板。空心管可以连接到底板支架。
- en: 'The following image shows the middle plate and connecting tubes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了中板和连接管：
- en: '![](img/6a94335c-c911-4d6a-a941-7afb5e878bf3.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a94335c-c911-4d6a-a941-7afb5e878bf3.png)'
- en: Middle plate with connecting tubes
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 带有连接管的中板
- en: 'The connecting tube will connect the base plate and the middle plate. There
    are four hollow tubes to connect the base plate to the middle plate. One end of
    these tubes is hollow, which can fit the base plate support, and the other end
    has a hard plastic fitting with a hole for a screw. The middle plate has no support,
    except for four holes for the connecting tubes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 连接管将连接底板和中板。有四个空心管将底板连接到中板。这些管子的一端是空心的，可以与底板支架相匹配，另一端有一个带有螺丝孔的硬塑料接头。中板没有支架，除了四个用于连接管的孔：
- en: '![](img/7d21f5c1-0a85-4bc9-94e5-76991cc24ab2.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d21f5c1-0a85-4bc9-94e5-76991cc24ab2.png)'
- en: Fully assembled robot body
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 完全组装好的机器人本体
- en: The middle plate male connector helps to connect the middle plate and the top
    of the base plate tubes. We can fit the top plate at the top of the middle plate
    tubes using the four supports on the back of the top plate. We can insert the
    top plate's female connector into the top plate support. Now we have the fully
    assembled body of the robot.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 中板公接头有助于连接中板和底板顶部的管子。我们可以使用顶板背面的四个支架将顶板安装在中板管子的顶部。我们可以将顶板的女接头插入顶板支架。现在我们有了完全组装好的机器人本体。
- en: 'The bottom layer of the robot can be used to put the **printed circuit board**
    (**PCB**) and battery. In the middle layer, we can put the Kinect/Orbecc and Intel
    NUC. We can put a speaker and mic if needed. We can use the top plate to carry
    food. The following image shows the PCB prototype of the robot; it consists of
    Tiva-C LaunchPad, a motor driver, level shifters, and provisions to connect two
    motors, ultrasonic sensors, and IMU:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人的底层可以用来放置**印刷电路板**（**PCB**）和电池。在中层，我们可以放置Kinect/Orbecc和Intel NUC。如果需要，我们可以放置一个扬声器和麦克风。我们可以使用顶板来携带食物。以下图像显示了机器人的PCB原型；它由Tiva-C
    LaunchPad、电机驱动器、电平转换器和连接两个电机、超声波传感器和IMU的接口组成：
- en: '![](img/8b46a5d7-63c6-4f6d-a747-f5838d0d76dd.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b46a5d7-63c6-4f6d-a747-f5838d0d76dd.png)'
- en: ChefBot PCB prototype
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ChefBot PCB原型
- en: 'The board is powered by a 12 V battery placed on the base plate. The two motors
    can be directly connected to the M1 and M2 male connectors. The NUC PC and Kinect
    are placed on the middle plate. The LaunchPad board and Kinect should be connected
    to the NUC PC via USB. The PC and Kinect are powered using the same 12 V battery
    itself. We can use a lead-acid or lithium-polymer battery. Here, we are using
    a lead-acid cell for testing purposes. Later, we will migrate to a lithium-polymer
    battery for better performance and better backup. The following image shows a
    diagram of the complete, assembled ChefBot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 板子由放置在底板上的12伏电池供电。两个电机可以直接连接到M1和M2公接头。NUC PC和Kinect放置在中板上。LaunchPad板和Kinect应通过USB连接到NUC
    PC。PC和Kinect使用相同的12伏电池供电。我们可以使用铅酸电池或锂聚合物电池。在这里，我们使用铅酸电池进行测试。稍后，我们将迁移到锂聚合物电池，以获得更好的性能和更长的备用时间。以下图像显示了完全组装好的ChefBot的示意图：
- en: '![](img/6c4a26a5-22c1-422a-85f4-e2887838113b.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c4a26a5-22c1-422a-85f4-e2887838113b.png)'
- en: Fully assembled robot body
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 完全组装好的机器人本体
- en: After assembling all the parts of the robot, we will start working with the
    robot software. ChefBot's embedded code and ROS packages are available in the
    codes under `chapter_8`. Let's get that code and start working with the software.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在组装好机器人的所有部件后，我们将开始与机器人软件一起工作。ChefBot 的嵌入式代码和 ROS 软件包可以在 `chapter_8` 下的代码中找到。让我们获取这些代码并开始与软件一起工作。
- en: Configuring ChefBot PC and setting ChefBot ROS packages
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 ChefBot PC 和设置 ChefBot ROS 软件包
- en: In ChefBot, we are using Intel's NUC PC to handle the robot sensor data and
    the processing of the data. After procuring the NUC PC, we have to install Ubuntu
    16.04 LTS. After the installation of Ubuntu, install the complete ROS and its
    packages that we mentioned in the previous chapters. We can configure this PC
    separately, and after the configuration of all the settings, we can put this into
    the robot. The following are the procedures to install the ChefBot packages on
    the NUC PC.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ChefBot 中，我们使用英特尔 NUC PC 来处理机器人传感器数据以及数据处理。在采购 NUC PC 后，我们必须安装 Ubuntu 16.04
    LTS。在安装 Ubuntu 之后，安装我们在前几章中提到的完整 ROS 及其软件包。我们可以单独配置这台 PC，并在所有设置配置完成后，将其放入机器人中。以下是在
    NUC PC 上安装 ChefBot 软件包的步骤。
- en: 'Clone ChefBot''s software packages from GitHub using the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令从 GitHub 克隆 ChefBot 的软件包：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can clone this code in our laptop and copy the `ChefBot` folder to Intel's
    NUC PC. The `ChefBot` folder consists of the ROS packages of the ChefBot hardware.
    In the NUC PC, create a ROS catkin workspace, copy the `ChefBot` folder, and move
    it inside the `src` directory of the catkin workspace.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的笔记本电脑上克隆此代码，并将 `ChefBot` 文件夹复制到英特尔 NUC PC 上。`ChefBot` 文件夹包含 ChefBot
    硬件的 ROS 软件包。在 NUC PC 上创建 ROS catkin 工作空间，复制 `ChefBot` 文件夹，并将其移动到 catkin 工作空间的
    `src` 目录中。
- en: 'Build and install the source code of ChefBot by simply using the following
    command. This should be executed inside the `catkin` workspace we created:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下简单命令构建和安装 ChefBot 的源代码。这应该在创建的 `catkin` 工作空间内执行：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If all dependencies are properly installed in the NUC, then the ChefBot packages
    will build and install in this system. After setting the ChefBot packages on the
    NUC PC, we can switch to the embedded code for ChefBot. Now, we can connect all
    the sensors in LaunchPad. After uploading the code in LaunchPad, we can again
    look at the ROS packages and how to run them. The cloned code from GitHub contains
    the Tiva-C LaunchPad code, which is going to be explained in the next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 NUC 中正确安装了所有依赖项，那么 ChefBot 软件包将在这个系统中构建和安装。在 NUC PC 上设置 ChefBot 软件包后，我们可以切换到
    ChefBot 的嵌入式代码。现在，我们可以连接 LaunchPad 上的所有传感器。在 LaunchPad 上上传代码后，我们再次查看 ROS 软件包以及如何运行它们。从
    GitHub 克隆的代码包含 Tiva-C LaunchPad 代码，将在下一节中解释。
- en: Interfacing ChefBot sensors to the Tiva-C LaunchPad
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 ChefBot 传感器连接到 Tiva-C LaunchPad
- en: 'We have looked at the interfacing of the individual sensors that we are going
    to use in ChefBot. In this section, we will learn how to integrate sensors into
    the LaunchPad board. The Energia code to program Tiva-C LaunchPad is available
    in the cloned files at GitHub. The connection diagram showing the connection of
    the Tiva-C LaunchPad with the sensors is as follows. From this diagram, we learn
    how the sensors are interconnected with LaunchPad:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看了我们将在 ChefBot 中使用的单个传感器的接口。在本节中，我们将学习如何将传感器集成到 LaunchPad 板上。用于编程 Tiva-C
    LaunchPad 的 Energia 代码可在 GitHub 克隆的文件中找到。显示 Tiva-C LaunchPad 与传感器连接的连接图如下。从这张图中，我们了解传感器是如何与
    LaunchPad 相互连接的：
- en: '![](img/7f7029c2-a70a-4eee-bc8d-7562c0e74bc9.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f7029c2-a70a-4eee-bc8d-7562c0e74bc9.png)'
- en: Sensor-interfacing diagram of ChefBot
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ChefBot 传感器接口图
- en: M1 and M2 are two differential-drive motors that we are using in this robot.
    The kind of motor we are going to use here is a DC geared motor with an encoder
    from Pololu. The motor terminals are connected to the dual **VNH2SP30** motor
    driver from Pololu. One of the motors is connected with reverse polarity because
    in differential steering, one motor rotates in the opposite direction to the other.
    If we send the same control signal to both the motors, each motor will rotate
    in the opposite direction. To avoid this condition, we will swap the cables of
    one motor. The motor driver is connected to Tiva-C LaunchPad through a 3.3 V-5
    V bidirectional level shifter. One of the level shifters we will use here is available
    at [https://www.sparkfun.com/products/12009](https://www.sparkfun.com/products/12009).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: M1 和 M2 是我们在该机器人中使用的两个差动驱动电机。我们在这里将要使用的是一款来自 Pololu 的直流齿轮电机，并配备编码器。电机端子连接到 Pololu
    的双通道 **VNH2SP30** 电机驱动器。其中一个电机连接时极性相反，因为在差动转向中，一个电机旋转的方向与另一个相反。如果我们向两个电机发送相同的控制信号，每个电机都会向相反方向旋转。为了避免这种情况，我们将交换一个电机的电缆。电机驱动器通过一个
    3.3 V-5 V 双向电平转换器连接到 Tiva-C LaunchPad。我们在这里将要使用的一个电平转换器可在 [https://www.sparkfun.com/products/12009](https://www.sparkfun.com/products/12009)
    购得。
- en: The two channels of each encoder are connected to LaunchPad using a level shifter.
    At the moment, we are using one ultrasonic distance sensor for obstacle detection.
    In future, we could increase the number of sensors if required. To get a good
    odometry estimate, we will put the IMU sensor MPU 6050 through an I2C interface.
    The pins are directly connected to LaunchPad because MPU6050 is 3.3 V compatible.
    To reset LaunchPad from the ROS nodes, we are allocating one pin as the output
    and connecting it to the reset pin of LaunchPad. When a specific character is
    sent to LaunchPad, it will set the output pin to high and reset the device. In
    some situations, the error from the calculation may accumulate and affect the
    navigation of the robot. We are resetting LaunchPad to clear this error. To monitor
    the battery level, we are allocating another pin to read the battery value. This
    feature is not currently implemented in the Energia code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个编码器的两个通道通过电平转换器连接到 LaunchPad。目前，我们使用一个超声波距离传感器进行障碍物检测。在将来，如果需要，我们可以增加传感器的数量。为了获得良好的里程计估计，我们将通过
    I2C 接口将 IMU 传感器 MPU 6050 连接起来。引脚直接连接到 LaunchPad，因为 MPU6050 与 3.3 V 兼容。为了从 ROS
    节点重置 LaunchPad，我们分配一个引脚作为输出，并将其连接到 LaunchPad 的复位引脚。当向 LaunchPad 发送特定字符时，它将输出引脚设置为高电平并重置设备。在某些情况下，计算错误可能会累积并影响机器人的导航。我们将重置
    LaunchPad 以清除此错误。为了监控电池电量，我们分配另一个引脚来读取电池值。此功能目前在 Energia 代码中尚未实现。
- en: The code you downloaded from GitHub consists of the embedded code and the dependent
    libraries needed to compile this code. We can see the main section of the code
    here, and there is no need to explain all of the sections because we have already
    looked at them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您从 GitHub 下载的代码包括嵌入式代码和编译此代码所需的依赖库。我们在这里可以看到代码的主要部分，没有必要解释所有部分，因为我们已经查看过了。
- en: Embedded code for ChefBot
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ChefBot 的嵌入式代码
- en: 'The main sections of the LaunchPad code are discussed in this section. The
    following are the header files used in the code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了 LaunchPad 代码的主要部分。以下是在代码中使用的头文件：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The main libraries used in this code are for the purposes of communicating with
    MPU 6050 and processing the incoming serial data to LaunchPad. MPU 6050 can provide
    the orientation in quaternion or Euler values using the inbuilt **digital motion
    processor** (**DMP**). The functions to access DMP are written in `MPU6050_6Axis_MotionApps20.h`.
    This library has dependencies such as `I2Cdev.h` and `Wire.h`; that's why we are
    including this header as well. These two libraries are used for I2C communication.
    The `Messenger.h` library allows you to handle a stream of text data from any
    source and will help you to extract the data from it. The `limits.h` header contains
    the definitions of the maximum limits of various data types.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中使用的库主要用于与 MPU 6050 通信以及处理传入的串行数据到 LaunchPad。MPU 6050 可以使用内置的 **数字运动处理器**（**DMP**）提供四元数或欧拉值来表示方向。访问
    DMP 的函数在 `MPU6050_6Axis_MotionApps20.h` 中编写。这个库有依赖项，如 `I2Cdev.h` 和 `Wire.h`；这就是为什么我们也要包含这个头文件。这两个库用于
    I2C 通信。`Messenger.h` 库允许您处理来自任何来源的文本数据流，并有助于从其中提取数据。`limits.h` 头文件包含了各种数据类型最大限制的定义。
- en: 'After we include the header files, we need to create an object to handle MPU6050
    and process the incoming serial data using the `Messenger` class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含头文件之后，我们需要创建一个对象来处理 MPU6050 并使用 `Messenger` 类处理传入的串行数据：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After declaring the messenger object, the main section deals with assigning
    pins for the motor driver, encoder, ultrasonic sensor, MPU 6050, reset, and battery
    pins. Once we have assigned the pins, we can look at the `setup()` function of
    the code. The definition of the `setup()` function is given in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了信使对象之后，主部分处理为电机驱动器、编码器、超声波传感器、MPU 6050、复位和电池引脚分配引脚。一旦我们分配了引脚，我们就可以查看代码的
    `setup()` 函数。`setup()` 函数的定义如下代码所示：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding function contains a custom routine to configure and allocate pins
    for all of the sensors. This function will initialize serial communication with
    a 115,200 baud rate and set pins for the encoder, motor driver, ultrasonic sensors,
    and MPU6050\. The `SetupReset()` function will assign a pin to reset the device,
    as shown in the preceding connection diagram. We have already seen the setup routines
    of each of the sensors in the previous chapters, so there is no need to explain
    the definition of each of these functions. The `Messenger` class handler is attached
    to a function called `OnMssageCompleted()`, which will be called when data is
    input to the `Messenger_Handler`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数包含一个自定义例程来配置和分配所有传感器的引脚。此函数将以 115,200 波特率初始化串行通信，并为编码器、电机驱动器、超声波传感器和 MPU6050
    设置引脚。`SetupReset()` 函数将为设备分配一个引脚以进行复位，如前面的连接图所示。我们已经在前面章节中看到了每个传感器的设置例程，因此没有必要解释这些函数的定义。`Messenger`
    类处理器连接到名为 `OnMssageCompleted()` 的函数，当数据输入到 `Messenger_Handler` 时将调用此函数。
- en: 'The following is the main `loop()` function of the code. The main purpose of
    this function is to read and process serial data, as well as send available sensor
    values:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该代码的主要 `loop()` 函数。此函数的主要目的是读取和处理串行数据，以及发送可用的传感器值：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Read_From_Serial()` function will read serial data from the PC and feed
    data to the `Messenger_Handler` handler for processing purposes. The `Update_Time()`
    function will update the time after each operation in the embedded board. We can
    take this time value to be processed in the PC or use the PC's time instead.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Read_From_Serial()` 函数将从 PC 读取串行数据，并将数据提供给 `Messenger_Handler` 处理器进行处理。`Update_Time()`
    函数将在嵌入式板上的每次操作后更新时间。我们可以使用这个时间值在 PC 上进行处理，或者使用 PC 的时间。'
- en: We can compile the code in Energia's IDE and burn the code in LaunchPad. After
    uploading the code, we can look at the ROS nodes for handling the LaunchPad sensor
    values.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Energia 的 IDE 中编译代码，并在 LaunchPad 上烧录代码。上传代码后，我们可以查看处理 LaunchPad 传感器值的
    ROS 节点。
- en: Writing a ROS Python driver for ChefBot
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 ChefBot 编写 ROS Python 驱动程序
- en: 'After uploading the embedded code to LaunchPad, the next step is to handle
    the serial data from LaunchPad and convert it to ROS topics for further processing.
    The `launchpad_node.py` ROS Python driver node interfaces Tiva-C LaunchPad with
    ROS. The `launchpad_node.py` file is in the `script` folder, which is inside the
    `ChefBot_bringup` package. The following is an explanation of the important code
    sections of `launchpad_node.py`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在将嵌入式代码上传到 LaunchPad 之后，下一步是处理来自 LaunchPad 的串行数据，并将其转换为 ROS 主题以进行进一步处理。`launchpad_node.py`
    ROS Python 驱动节点将 Tiva-C LaunchPad 与 ROS 进行接口连接。`launchpad_node.py` 文件位于 `script`
    文件夹中，该文件夹位于 `ChefBot_bringup` 包内。以下是 `launchpad_node.py` 中的重要代码段解释：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `launchpad_node.py` file imports the preceding modules. The main module
    we can see is `SerialDataGateway`. This is a custom module written to receive
    serial data from the LaunchPad board in a thread. We also need some data types
    of ROS to handle the sensor data. The main function of the node is given in the
    following code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`launchpad_node.py` 文件导入了前面的模块。我们可以看到的主要模块是 `SerialDataGateway`。这是一个自定义模块，用于在线程中接收来自
    LaunchPad 板的串行数据。我们还需要一些 ROS 的数据类型来处理传感器数据。节点的主体功能如下代码片段所示：'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The main class of this node is called `Launchpad_Class()`. This class contains
    all the methods to start, stop, and convert serial data to ROS topics. In the
    main function, we will create an object of the `Launchpad_Class()`. After creating
    the object, we will call the `Start()` method, which will start the serial communication
    between Tiva-C LaunchPad and the PC. If we interrupt the driver node by typing
    *Ctrl* + *C*, it will reset LaunchPad and stop the serial communication between
    the PC and LaunchPad.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该节点的主体类被命名为 `Launchpad_Class()`。这个类包含了启动、停止以及将串行数据转换为 ROS 主题的所有方法。在主函数中，我们将创建一个
    `Launchpad_Class()` 的对象。创建对象后，我们将调用 `Start()` 方法，这将启动 Tiva-C LaunchPad 和 PC 之间的串行通信。如果我们通过输入
    *Ctrl* + *C* 中断驱动节点，它将重置 LaunchPad 并停止 PC 和 LaunchPad 之间的串行通信。
- en: 'The following code snippet is from the constructor function of `Launchpad_Class()`.
    In the following snippet, we will retrieve the port and baud rate of the LaunchPad
    board from the ROS parameters and initialize the `SerialDateGateway` object using
    these parameters. The `SerialDataGateway` object calls the `_HandleReceivedLine()`
    function inside this class when any incoming serial data arrives at the serial
    port. This function will process each line of serial data and extract, convert,
    and insert it in the appropriate headers of each ROS topic data type:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段来自 `Launchpad_Class()` 构造函数。在以下片段中，我们将从 ROS 参数中检索 LaunchPad 板的端口和波特率，并使用这些参数初始化
    `SerialDataGateway` 对象。当任何串行数据到达串行端口时，`SerialDataGateway` 对象将在这个类内部调用 `_HandleReceivedLine()`
    函数。这个函数将处理每一行串行数据，并从中提取、转换并插入到每个 ROS 主题数据类型的适当头部：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will create the ROS publisher object for sensors such as the encoder, IMU,
    and ultrasonic sensor, as well as for the entirety of the serial data for debugging
    purposes. We will also subscribe the speed commands to the left-hand side and
    right-hand side wheel of the robot. When a speed command arrives on the topic,
    it calls the respective callbacks to send speed commands to the robot''s LaunchPad:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为编码器、IMU 和超声波传感器等传感器创建 ROS 发布者对象，以及为调试目的的串行数据的全部。我们还将订阅机器人左侧和右侧车轮的速度命令。当速度命令到达主题时，它将调用相应的回调函数，向机器人的
    LaunchPad 发送速度命令：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After setting the ChefBot driver node, we need to interface the robot with a
    ROS navigation stack in order to perform autonomous navigation. The basic requirement
    for doing autonomous navigation is that the robot driver nodes receive velocity
    commands from the ROS navigational stack. The robot can be controlled using teleoperation.
    In addition to these features, the robot must be able to compute its positional
    or odometry data and generate the tf data to be sent into the navigational stack.
    There must be a PID controller to control the robot's motor velocity. The following
    ROS package helps us to perform these functions. The `differential_drive` package
    contains nodes to perform the preceding operation. We are reusing these nodes
    in our package to implement these functionalities. You can find the `differential_drive`
    package in ROS at [http://wiki.ros.org/differential_drive](http://wiki.ros.org/differential_drive).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 ChefBot 驱动节点后，我们需要将机器人与 ROS 导航堆栈接口，以便执行自主导航。进行自主导航的基本要求是机器人驱动节点从 ROS 导航堆栈接收速度命令。机器人可以通过遥操作进行控制。除了这些功能外，机器人必须能够计算其位置或里程数据，并生成要发送到导航堆栈的
    tf 数据。必须有一个 PID 控制器来控制机器人的电机速度。以下 ROS 软件包帮助我们执行这些功能。`differential_drive` 软件包包含执行上述操作的节点。我们在我们的软件包中重用这些节点来实现这些功能。您可以在
    ROS 中找到 `differential_drive` 软件包，网址为 [http://wiki.ros.org/differential_drive](http://wiki.ros.org/differential_drive)。
- en: 'The following diagram shows how these nodes communicate with each other:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了这些节点之间的通信方式：
- en: '![](img/95cb50af-83f4-41cc-9742-0a43880b8852.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95cb50af-83f4-41cc-9742-0a43880b8852.png)'
- en: Block diagram of the robot showing the ROS nodes
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人方块图，展示了 ROS 节点
- en: 'The purpose of each node in the `ChefBot_bringup` package is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChefBot_bringup` 软件包中每个节点的目的是如下：'
- en: '`twist_to_motors.py`: This node will convert a ROS `Twist` command or linear
    and angular velocity to an individual motor velocity target. The target velocities
    are published at a rate of the `~rate` (measured in Hertz) and the publish `timeout_ticks`
    time''s velocity after the `Twist` message stops. The following are the topics
    and parameters that will be published and subscribed to by this node:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`twist_to_motors.py`: 此节点将ROS `Twist`命令或线性速度和角速度转换为单个电机速度目标。目标速度以`~rate`（赫兹为单位）的速度发布，并在`Twist`消息停止后发布`timeout_ticks`时间的速度。以下是由此节点发布和订阅的主题和参数：'
- en: '**Publishing topics:**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布主题：**'
- en: '`lwheel_vtarget(std_msgs/Float32)`: This is the target velocity of the left
    wheel (measured in m/s).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`lwheel_vtarget(std_msgs/Float32)`: 这是左轮的目标速度（以m/s为单位）。'
- en: '`rwheel_vtarget` (`std_msgs`/`Float32`): This is the target velocity of the
    right wheel (measured in m/s).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`rwheel_vtarget` (`std_msgs`/`Float32`): 这是右轮的目标速度（以m/s为单位）。'
- en: '**Subscribing topics:**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**订阅主题：**'
- en: '`Twist` (`geometry_msgs`/`Twist`): This is the target `Twist` command for the
    robot. The linear velocity in the x-direction and the angular velocity theta of
    the Twist messages are used in this robot.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Twist` (`geometry_msgs`/`Twist`): 这是机器人的目标`Twist`命令。在此机器人中，使用Twist消息中的x方向线性速度和角速度theta。'
- en: '**Important ROS parameters:**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要的ROS参数：**'
- en: '`~base_width` (`float, default: 0.1`): This is the distance between the robot''s
    two wheels in meters.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`~base_width` (`float, default: 0.1`): 这是机器人两个轮子之间的距离，单位为米。'
- en: '`~rate` (`int, default: 50`): This is the rate at which the velocity target
    is published (Hertz).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`~rate` (`int, default: 50`): 这是发布速度目标的速度（赫兹）。'
- en: '`~timeout_ticks` (`int, default:2`): This is the number of the velocity target
    message published after stopping the Twist messages.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`~timeout_ticks` (`int, default:2`): 这是停止Twist消息后发布的速度目标消息的数量。'
- en: '`pid_velocity.py`: This is a simple PID controller to control the speed of
    each motor by taking feedback from the wheel encoders. In a differential drive
    system, we need one PID controller for each wheel. It will read the encoder data
    from each wheel and control the speed of each wheel.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`pid_velocity.py`: 这是一个简单的PID控制器，通过从轮编码器获取反馈来控制每个电机的速度。在差速驱动系统中，我们需要为每个轮子配置一个PID控制器。它将读取每个轮子的编码器数据并控制每个轮子的速度。'
- en: '**Publishing topics:**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布主题：**'
- en: '`motor_cmd` (`Float32`): This is the final output of the PID controller that
    goes to the motor. We can change the range of the PID output using the `out_min`
    and `out_max` ROS parameter.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`motor_cmd` (`Float32`): 这是PID控制器的最终输出，用于电机。我们可以通过`out_min`和`out_max` ROS参数来改变PID输出的范围。'
- en: '`wheel_vel` (`Float32`): This is the current velocity of the robot wheel in
    m/s.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`wheel_vel` (`Float32`): 这是机器人轮子的当前速度（以m/s为单位）。'
- en: '**Subscribing topics:**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**订阅主题：**'
- en: '`wheel` (`Int16`): This topic is the output of a rotary encoder. There are
    individual topics for each encoder of the robot.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`wheel` (`Int16`): 这个主题是旋转编码器的输出。每个编码器都有自己的主题。'
- en: '`wheel_vtarget` (`Float32`): This is the target velocity in m/s.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`wheel_vtarget` (`Float32`): 这是目标速度，单位为m/s。'
- en: '**Important parameters:**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要参数：**'
- en: '`~Kp` (`float``,default: 10`): This parameter is the proportional gain of the
    PID controller.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`~Kp` (`float`, default: 10`): 这个参数是PID控制器的比例增益。'
- en: '`~Ki` (`float, default: 10`): This parameter is the integral gain of the PID
    controller.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`~Ki` (`float, default: 10`): 这个参数是PID控制器的积分增益。'
- en: '`~Kd` (`float, default: 0.001`): This parameter is the derivative gain of the
    PID controller.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`~Kd` (`float, default: 0.001`): 这个参数是PID控制器的微分增益。'
- en: '`~out_min` (`float, default: 255`): This is the minimum limit of the velocity
    value to the motor. This parameter limits the velocity''s value to the motor called
    the `wheel_vel` topic.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`~out_min` (`float, default: 255`): 这是速度值到电机的最小限制。此参数限制了速度值到名为`wheel_vel`主题的电机。'
- en: '`~out_max` (`float, default: 255`): This is the maximum limit of the `wheel_vel`
    topic (measured in Hertz).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`~out_max` (`float, default: 255`): 这是`wheel_vel`主题的最大限制（以赫兹为单位）。'
- en: '`~rate` (`float, default: 20`): This is the rate of publishing the `wheel_vel`
    topic.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`~rate` (`float, default: 20`): 这是发布`wheel_vel`主题的速度。'
- en: '`ticks_meter` (`float, default: 20`): This is the number of wheel encoder ticks
    per meter. This is a global parameter because it''s used in other nodes too.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`ticks_meter` (`float, default: 20`): 这是每米轮子编码器脉冲数。这是一个全局参数，因为它也在其他节点中使用。'
- en: '`vel_threshold` (`float, default: 0.001`): If the robot velocity drops below
    this parameter, we consider the wheel as stationary. If the velocity of the wheel
    is less than `vel_threshold`, we consider it as zero.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`vel_threshold` (`float, default: 0.001`): 如果机器人速度低于此参数，我们考虑车轮为静止。如果车轮速度小于
    `vel_threshold`，我们将其视为零。'
- en: '`encoder_min` (`int, default: 32768`): This is the minimum value of encoder
    reading.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`encoder_min` (`int, default: 32768`): 这是编码器读取的最小值。'
- en: '`encoder_max` (`int, default: 32768`): This is the maximum value of encoder
    reading.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`encoder_max` (`int, default: 32768`): 这是编码器读取的最大值。'
- en: '`wheel_low_wrap` (`int, default: 0.3 * (encoder_max - encoder_min) + encoder_min`):
    These values decide whether the odometry is in a negative or positive direction.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`wheel_low_wrap` (`int, default: 0.3 * (encoder_max - encoder_min) + encoder_min`):
    这些值决定里程计是在负方向还是正方向。'
- en: '`wheel_high_wrap` (`int, default: 0.7 * (encoder_max - encoder_min) + encoder_min`):
    These values decide whether the odometry is in a negative or positive direction.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`wheel_high_wrap` (`int, default: 0.7 * (encoder_max - encoder_min) + encoder_min`):
    这些值决定里程计是在负方向还是正方向。'
- en: '`diff_tf.py`: This node computes the transformation of odometry and broadcasts
    between the odometry frame and the robot''s base frame.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`diff_tf.py`: 此节点计算里程计的转换并在里程计框架和机器人基座框架之间广播。'
- en: '**Publishing topics:**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布主题：**'
- en: '`odom` (`nav_msgs`/`odometry`): This publishes the odometry (the current pose
    and twist of the robot).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`odom` (`nav_msgs`/`odometry`): 该功能发布里程计（机器人的当前姿态和扭转）。'
- en: '`tf`: This provides the transformation between the odometry frame and the robot
    base link.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`tf`: 该功能提供里程计框架和机器人基座框架之间的转换。'
- en: '**Subscribing topics:**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**订阅主题：**'
- en: '`lwheel` (`std_msgs`/`Int16`), `rwheel` (`std_msgs`/`Int16`): These are the
    output values from the left and right encoders of the robot.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`lwheel` (`std_msgs`/`Int16`), `rwheel` (`std_msgs`/`Int16`): 这些是机器人左右编码器的输出值。'
- en: '`ChefBot_keyboard_teleop.py`: This node sends the `Twist` command using controls
    from the keyboard.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChefBot_keyboard_teleop.py`: 此节点使用键盘控制发送 `Twist` 命令。'
- en: '**Publishing topics:**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布主题：**'
- en: '`cmd_vel_mux`/`input`/`teleop` (`geometry_msgs`/`Twist`): This publishes the
    Twist messages using keyboard commands.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmd_vel_mux`/`input`/`teleop` (`geometry_msgs`/`Twist`): 该功能使用键盘命令发布 Twist
    消息。'
- en: Now that we have looked at the nodes in the `ChefBot_bringup` package, we will
    look at the functions of the launch files.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了 `ChefBot_bringup` 包中的节点，我们将查看启动文件的功能。
- en: Understanding ChefBot ROS launch files
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 ChefBot ROS 启动文件
- en: 'We will now look at the functions of each of the launch files of the `ChefBot_bringup`
    package:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将查看 `ChefBot_bringup` 包中每个启动文件的功能：
- en: '`robot_standalone.launch`: The main function of this launch file is to start
    nodes such as `launchpad_node`, `pid_velocity`, `diff_tf,` and `twist_to_motor`
    to get sensor values from the robot and to send the command velocity to the robot.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`robot_standalone.launch`: 此启动文件的主要功能是启动 `launchpad_node`、`pid_velocity`、`diff_tf`
    和 `twist_to_motor` 等节点，从机器人获取传感器值并向机器人发送速度命令。'
- en: '`keyboard_teleop.launch`: This launch file will start teleoperation using the
    keyboard. It starts the `ChefBot_keyboard_teleop.py` node to perform the keyboard
    teleoperation.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyboard_teleop.launch`: 此启动文件将启动使用键盘的遥控操作。它启动 `ChefBot_keyboard_teleop.py`
    节点以执行键盘遥控操作。'
- en: '`3dsensor.launch` : This file will launch the Kinect OpenNI drivers and start
    publishing the RGB and depth stream. It will also start the depth-to-laser scanner
    node, which will convert point cloud data to laser scan data.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3dsensor.launch`: 此文件将启动 Kinect OpenNI 驱动程序并开始发布 RGB 和深度流。它还将启动深度到激光扫描器节点，该节点将点云数据转换为激光扫描数据。'
- en: '`gmapping_demo.launch`: This launch file will start the SLAM gmapping nodes
    to map the area surrounding the robot.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gmapping_demo.launch`: 此启动文件将启动 SLAM gmapping 节点以绘制机器人周围区域。'
- en: '`amcl_demo.launch`: Using AMCL, the robot can localize and predict where it
    stands on the map. After localizing the robot on the map, we can command the robot
    to move to a position on the map. Then the robot can move autonomously from its
    current position to the goal position.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`amcl_demo.launch`: 使用 AMCL，机器人可以定位并预测它在地图上的位置。在地图上定位机器人后，我们可以命令机器人移动到地图上的一个位置。然后机器人可以从当前位置自主移动到目标位置。'
- en: '`view_robot.launch`: This launch file displays the robot URDF model in RViz.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view_robot.launch`: 此启动文件在 RViz 中显示机器人 URDF 模型。'
- en: '`view_navigation.launch`: This launch file displays all the sensors necessary
    for the navigation of the robot.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view_navigation.launch`: 此启动文件显示机器人导航所需的全部传感器。'
- en: Working with ChefBot Python nodes and launch files
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 ChefBot Python 节点和启动文件一起工作
- en: We have already set ChefBot ROS packages in Intel's NUC PC and uploaded the
    embedded code to the LaunchPad board. The next step is to put the NUC PC on the
    robot, configure the remote connection from the laptop to the robot, test each
    node, and work with ChefBot's launch files to perform autonomous navigation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Intel的NUC PC上设置了ChefBot ROS包，并将嵌入式代码上传到了LaunchPad板。下一步是将NUC PC放在机器人上，从笔记本电脑配置到机器人的远程连接，测试每个节点，并使用ChefBot的启动文件与ChefBot进行自主导航。
- en: 'The main device we should have before working with ChefBot is a good wireless
    router. The robot and the remote laptop have to connect across the same network.
    If the robot PC and remote laptop are on the same network, the user can connect
    from the remote laptop to the robot PC through SSH using its IP. Before putting
    the robot PC in the robot, we should connect the robot PC to the wireless network
    so that once it''s connected to the wireless network, it will remember the connection
    details. When the robot powers up, the PC should automatically connect to the
    wireless network. Once the robot PC is connected to a wireless network, we can
    put it in the actual robot. The following diagram shows the connection diagram
    of the robot and remote PC:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在与ChefBot一起工作之前，我们应该拥有的主要设备是一个好的无线路由器。机器人和远程笔记本电脑必须连接到同一网络。如果机器人的PC和远程笔记本电脑在同一个网络中，用户可以通过SSH使用其IP从远程笔记本电脑连接到机器人PC。在将机器人PC放入机器人之前，我们应该将其连接到无线网络，以便一旦连接到无线网络，它将记住连接详情。当机器人开机时，PC应该自动连接到无线网络。一旦机器人PC连接到无线网络，我们就可以将其放入实际的机器人中。以下图显示了机器人和远程PC的连接图：
- en: '![](img/a41b1ab5-d147-4580-bd52-200c97833f09.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a41b1ab5-d147-4580-bd52-200c97833f09.png)'
- en: Wireless connection diagram of the robot and remote PC
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人和远程PC的无线连接图
- en: The preceding diagram assumes that the ChefBot's IP is `192.168.1.106` and the
    remote PC's IP is `192.168.1.101`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图假设ChefBot的IP是`192.168.1.106`，远程PC的IP是`192.168.1.101`。
- en: 'We can remotely access the ChefBot terminal using SSH. We can use the following
    command to log in to ChefBot, where `robot` is the username of the ChefBot PC:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令远程访问ChefBot终端，用于登录ChefBot，其中`robot`是ChefBot PC的用户名：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you log in to the ChefBot PC, it will ask for the robot PC password. After
    entering the password of the robot PC, we can access the robot PC terminal. After
    logging in to the robot PC, we can start testing ChefBot's ROS nodes and test
    whether we receive the serial values from the LaunchPad board inside ChefBot.
    Note that you should log in to the ChefBot PC again through SSH if you are using
    a new terminal.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当您登录ChefBot PC时，它会要求输入机器人PC密码。输入机器人PC密码后，我们可以访问机器人PC终端。登录到机器人PC后，我们可以开始测试ChefBot的ROS节点，并测试我们是否从LaunchPad板在ChefBot内部接收串行值。请注意，如果您使用的是新终端，您必须再次通过SSH登录到ChefBot
    PC。
- en: 'If the `ChefBot_bringup` package is properly installed on the PC, and if the
    LaunchPad board is connected, then before running the ROS driver node, we can
    run the `miniterm.py` tool to check whether the serial values come to the PC properly
    via USB. We can find the serial device name using the `dmesg` command. We can
    run `miniterm.py` using the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ChefBot_bringup`包在PC上正确安装，并且如果LaunchPad板已连接，那么在运行ROS驱动节点之前，我们可以运行`miniterm.py`工具来检查串行值是否通过USB正确地到达PC。我们可以使用`dmesg`命令找到串行设备名称。我们可以使用以下命令运行`miniterm.py`：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If it shows the permission denied message, set the permission of the USB device
    by writing rules on the `udev` folder, which we did in [Chapter 6](lrn-rbt-py-2e_ch06.html),
    *Interfacing Actuators and Sensors to the Robot Controller*, or we can temporarily
    change the permission using the following command. Here, we are assuming that
    `ttyACM0` is the device name of LaunchPad. If the device name is different in
    your PC, then you have to use that name instead of `ttyACM0`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果显示权限拒绝的消息，请通过在`udev`文件夹中编写规则来设置USB设备的权限，我们已经在[第6章](lrn-rbt-py-2e_ch06.html)“将执行器和传感器连接到机器人控制器”中这样做过，或者我们可以使用以下命令临时更改权限。这里我们假设`ttyACM0`是LaunchPad的设备名称。如果您的PC上的设备名称不同，那么您必须使用该名称而不是`ttyACM0`：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If everything works fine, we will get values such as those shown in the following
    screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们将得到以下截图所示的值：
- en: '![](img/d3892aa3-1b0d-434f-b562-a548b050cc15.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3892aa3-1b0d-434f-b562-a548b050cc15.png)'
- en: Output of miniterm.py
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: miniterm.py的输出
- en: The letter `b` is used to indicate the battery reading of the robot; currently,
    it's not implemented. The value is set to zero now. These values are coming from
    the Tiva C Launchpad. There are different approaches to sense the voltage using
    a microcontroller board. One of the approaches is given below ([http://www.instructables.com/id/Arduino-Battery-Voltage-Indicator/](http://www.instructables.com/id/Arduino-Battery-Voltage-Indicator/)). The
    letter `t` indicates the total time elapsed (in microseconds) after the robot
    starts running the embedded code. The second value is the time taken to complete
    one entire operation in LaunchPad (measured in seconds). We can use this value
    if we are performing real-time calculations of the parameters of the robot. At
    the moment, we are not using this value, but we may use it in the future. The
    letter `e` indicates the values of the left and right encoder respectively. Both
    the values are zero here because the robot is not moving. The letter `u` indicates
    the values from the ultrasonic distance sensor. The distance value we get is in
    centimeters. The letter `s` indicates the current wheel speed of the robot. This
    value is used for inspection purposes. Actually, speed is a control output from
    the PC itself.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 字母 `b` 用于表示机器人的电池读数；目前尚未实现。该值现在设置为零。这些值来自 Tiva C Launchpad。使用微控制器板感应电压有不同的方法。其中一种方法如下 ([http://www.instructables.com/id/Arduino-Battery-Voltage-Indicator/](http://www.instructables.com/id/Arduino-Battery-Voltage-Indicator/))。字母
    `t` 表示机器人开始运行嵌入式代码后经过的总时间（以微秒为单位）。第二个值是完成整个操作所需的时间（以秒为单位）。如果我们正在执行机器人的参数的实时计算，我们可以使用此值。目前，我们未使用此值，但将来可能会使用。字母
    `e` 表示左右编码器的值。这两个值在这里都是零，因为机器人没有移动。字母 `u` 表示超声波距离传感器的值。我们得到的距离值以厘米为单位。字母 `s` 表示机器人的当前轮速。此值用于检查目的。实际上，速度是来自
    PC 的控制输出。
- en: To convert this serial data to ROS topics, we have to run the drive node called
    `launchpad_node.py`. The following code shows how to execute this node.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此串行数据转换为 ROS 主题，我们必须运行名为 `launchpad_node.py` 的驱动节点。以下代码显示了如何执行此节点。
- en: 'First, we have to run `roscore` before starting any nodes:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在启动任何节点之前，我们必须运行 `roscore`：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run `launchpad_node.py` using the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行 `launchpad_node.py`：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If everything works fine, we will get the following output in node in the running
    terminal:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们将在运行的终端中看到以下输出：
- en: '![](img/33b4d922-bdcb-40e3-825b-47f0a5ac855b.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/33b4d922-bdcb-40e3-825b-47f0a5ac855b.png)'
- en: Output of launchpad_node.py
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: launchpad_node.py 的输出
- en: 'After running `launchpad_node.py`, we will see the following topics generated,
    as shown in the following screenshot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `launchpad_node.py` 后，我们将看到以下主题生成，如下面的截图所示：
- en: '![](img/c6bca7d0-4626-4670-8832-22137656699d.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6bca7d0-4626-4670-8832-22137656699d.png)'
- en: Topics generated by launchpad_node.py
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: launchpad_node.py 生成的主题
- en: 'We can view the serial data received by the driver node by subscribing to the
    `/serial` topic. We can use it for debugging purposes. If the serial topic shows
    the same data that we saw in `miniterm.py`, then we can confirm that the nodes
    are working fine. The following screenshot is the output of the `/serial` topic:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过订阅 `/serial` 主题来查看驱动节点接收到的串行数据。我们可以用它进行调试目的。如果串行主题显示的数据与我们看到的 `miniterm.py`
    中的数据相同，那么我们可以确认节点运行正常。以下截图是 `/serial` 主题的输出：
- en: '![](img/75a326ff-9de1-4dc0-9de6-91e89366dd20.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75a326ff-9de1-4dc0-9de6-91e89366dd20.png)'
- en: Output of the /serial topic published by the LaunchPad node
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由 LaunchPad 节点发布的 /serial 主题的输出
- en: After setting the `ChefBot_bringup` package, we can start working with the autonomous
    navigation of ChefBot. Currently, we are accessing only the ChefBot PC's terminal.
    To visualize the robot's model, sensor data, maps, and so on, we have to use RViz
    in the user's PC. We have to do some configuration in the robot and user PC to
    perform this operation. It should be noted that the user's PC should have the
    same software setup as the ChefBot PC.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 `ChefBot_bringup` 软件包后，我们可以开始使用 ChefBot 的自主导航。目前，我们仅访问 ChefBot PC 的终端。为了可视化机器人的模型、传感器数据、地图等，我们必须在用户的
    PC 上使用 RViz。我们必须在机器人和用户 PC 上进行一些配置才能执行此操作。需要注意的是，用户的 PC 应该与 ChefBot PC 具有相同的软件设置。
- en: The first thing we have to do is to set the ChefBot PC as a ROS master. We can
    set the ChefBot PC as the ROS master by setting the `ROS_MASTER_URI` value. The
    `ROS_MASTER_URI` setting is a required setting; it informs the nodes about the
    **uniform resource identifier** (**URI**) of the ROS master. When you set the
    same `ROS_MASTER_URI` for the ChefBot PC and the remote PC, we can access the
    topics of the ChefBot PC in the remote PC. So, if we run RViz locally, then it
    will visualize the topics generated in the ChefBot PC.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是将ChefBot PC设置为ROS主节点。我们可以通过设置`ROS_MASTER_URI`值来将ChefBot PC设置为ROS主节点。`ROS_MASTER_URI`设置是一个必需的设置；它通知节点关于ROS主节点的**统一资源标识符**（**URI**）。当你为ChefBot
    PC和远程PC设置相同的`ROS_MASTER_URI`时，我们就可以在远程PC上访问ChefBot PC的主题。因此，如果我们在本地上运行RViz，那么它将可视化在ChefBot
    PC上生成的主题。
- en: 'Assume that the ChefBot PC IP is `192.168.1.106` and the remote PC IP is `192.168.1.10`.
    You can set a static IP for Chefbot PC and remote PC so that the IP will always
    be the same all test otherwise if it is automatic, you may get different IP in
    each test. To set `ROS_MASTER_URI` in each system, the following command should
    be included in the `.bashrc` file in the `home` folder. The following diagram
    shows the setup needed to include the `.bashrc` file in each system:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设ChefBot PC的IP地址是`192.168.1.106`，远程PC的IP地址是`192.168.1.10`。你可以为Chefbot PC和远程PC设置静态IP，这样IP地址在所有测试中都将保持不变；否则，如果它是自动的，你可能在每个测试中得到不同的IP地址。要在每个系统中设置`ROS_MASTER_URI`，以下命令应包含在`home`文件夹中的`.bashrc`文件中。以下图表显示了在每个系统中包含`.bashrc`文件所需的设置：
- en: '![](img/e82976a6-208d-4f60-9012-869eb6ee0428.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e82976a6-208d-4f60-9012-869eb6ee0428.png)'
- en: Network configuration for ChefBot
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ChefBot的网络配置
- en: Add these lines at the bottom of `.bashrc` on each PC and change the IP address
    according to your network.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个PC的`.bashrc`文件底部添加这些行，并根据你的网络更改IP地址。
- en: After we establish these settings, we can just start `roscore` on the ChefBot
    PC terminal and execute the `rostopic list` command on the remote PC.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们建立这些设置之后，我们只需在ChefBot PC终端上启动`roscore`，然后在远程PC上执行`rostopic list`命令。
- en: If you see any topics, you are done with the settings. We can first run the
    robot using the keyboard teleoperation to check the robot's functioning and confirm
    whether we get the sensor values.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到任何主题，说明设置已完成。我们可以首先使用键盘遥控运行机器人，以检查机器人的功能并确认我们是否获得了传感器值。
- en: 'We can start the robot driver and other nodes using the following command.
    Note that this should execute in the ChefBot terminal after logging in using SSH:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令启动机器人驱动程序和其他节点。请注意，这应该在通过SSH登录后，在ChefBot终端中执行：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After launching the robot driver and nodes, start the keyboard teleoperation
    using the following command. This also has to be done on the new terminal of the
    ChefBot PC:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动机器人驱动程序和节点后，使用以下命令启动键盘遥控。这也必须在ChefBot PC的新终端中完成：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To activate Kinect, execute the following command. This command is also executed
    on the ChefBot terminal:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活Kinect，请执行以下命令。此命令也应在ChefBot终端中执行：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you are using Orbecc Astra, use the following launch file to start the sensor:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Orbecc Astra，请使用以下启动文件来启动传感器：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To view the sensor data, we can execute the following command. This will view
    the robot model in RViz and should be executed in the remote PC. If we set up
    the `ChefBot_bringup` package in the remote PC, we can access the following command
    and visualize the robot model and sensor data from the ChefBot PC:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看传感器数据，我们可以执行以下命令。这将显示RViz中的机器人模型，并且应该在远程PC上执行。如果我们已经在远程PC上设置了`ChefBot_bringup`包，我们可以访问以下命令并从ChefBot
    PC可视化机器人模型和传感器数据：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following screenshot is the output of RViz. We can see the LaserScan and
    PointCloud mapped data in the screenshots:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是RViz的输出。我们可以看到截图中的激光扫描和点云映射数据：
- en: '![](img/4f16c9b4-6fc2-488d-bcc2-247eb87466cc.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f16c9b4-6fc2-488d-bcc2-247eb87466cc.png)'
- en: ChefBot LaserScan data in RViz
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ChefBot在RViz中的激光扫描数据
- en: 'The preceding screenshot shows LaserScan in RViz. We need to tick the LaserScan
    topic from the left-hand side section of RViz to show the laser scan data. The
    laser scan data is marked on the viewport. If you want to watch the point cloud
    data from Kinect/Astra, click on the Add button on the left-hand side of RViz
    and select PointCloud2 from the pop-up window. Select Topic |`/camera/depth_registered`
    from the list and you will see an image similar to the one shown in the following
    screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了RViz中的激光扫描。我们需要从RViz的左侧部分勾选激光扫描主题，以显示激光扫描数据。激光扫描数据标在视图中。如果您想查看Kinect/Astra的点云数据，请点击RViz左侧的添加按钮，并在弹出的窗口中选择PointCloud2。从列表中选择主题
    | `/camera/depth_registered`，您将看到与以下截图类似的一张图片：
- en: '![](img/1e4d4e54-42a6-420c-ab92-84d50d2a5030.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e4d4e54-42a6-420c-ab92-84d50d2a5030.png)'
- en: ChefBot with PointCloud data
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 带有点云数据的ChefBot
- en: After working with sensors, we can perform SLAM to map the room. The following
    procedure helps us to start SLAM on this robot.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在与传感器一起工作后，我们可以执行SLAM来绘制房间地图。以下程序帮助我们在此机器人上启动SLAM。
- en: Working with SLAM on ROS to build a map of the room
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ROS上使用SLAM构建房间地图
- en: To perform gmapping, we have to execute the following commands.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行gmapping，我们必须执行以下命令。
- en: 'The following command starts the robot driver in the ChefBot terminal:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令在ChefBot终端中启动机器人驱动程序：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following command starts the gmapping process. Note that it should be executed
    on the ChefBot terminal:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令启动gmapping过程。请注意，它应在ChefBot终端上执行：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Gmapping will only work if the odometry value that is received is proper. If
    the odometry value is received from the robot, we will receive the following message
    for the preceding command. If we get this message, we can confirm that gmapping
    will work fine:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收到的里程计值是正确的，Gmapping才会工作。如果从机器人接收到的里程计值，我们将收到以下消息。如果我们收到此消息，我们可以确认gmapping将正常工作：
- en: '![](img/8d3735e1-9c32-4413-925d-3030d845ab55.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d3735e1-9c32-4413-925d-3030d845ab55.png)'
- en: ChefBot with PointCloud data
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 带有点云数据的ChefBot
- en: 'To start the keyboard teleoperation, use the following command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始键盘遥操作，请使用以下命令：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To view the map that is being created, we need to start RViz on the remote
    system using the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看正在创建的地图，我们需要在远程系统上使用以下命令启动RViz：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After viewing the robot in RViz, you can move the robot using the keyboard
    and see the map being created. When it has mapped the entire area, we can save
    the map using the following command on the ChefBot PC terminal:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在RViz中查看机器人后，您可以使用键盘移动机器人并查看正在创建的地图。当它已绘制整个区域时，我们可以在ChefBot PC终端使用以下命令保存地图：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, `test_map` is the name of the map being stored in the
    `home` folder. The following screenshot shows the map of a room created by the
    robot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`test_map`是存储在`home`文件夹中的地图名称。以下截图显示了机器人创建的房间地图：
- en: '![](img/07e93661-11a3-45c2-a87a-c03139613dfe.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07e93661-11a3-45c2-a87a-c03139613dfe.png)'
- en: Mapping a room
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制房间地图
- en: After the map is stored, we can work with the localization and autonomous navigation
    functionalities using ROS.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图存储后，我们可以使用ROS进行定位和自主导航功能。
- en: Working with ROS localization and navigation
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ROS定位和导航
- en: 'After building the map, close all the applications and rerun the robot driver
    using the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建地图后，关闭所有应用程序，并使用以下命令重新运行机器人驱动程序：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Start the localization and navigation on the stored map using the following
    command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在存储的地图上启动定位和导航：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Start viewing the robot using the following command in the remote PC:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程PC上使用以下命令开始查看机器人：
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In RViz, we may need to specify the initial pose of the robot using the 2D
    Pose Estimate button. We can change the robot pose on the map using this button.
    If the robot is able to access the map, then we can use the 2D Nav Goal button
    to command the robot to move to the desired position. When we start the localization,
    we can see the particle cloud around the robot by using the AMCL algorithm:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在RViz中，我们可能需要使用2D位姿估计按钮指定机器人的初始位姿。我们可以使用此按钮在地图上更改机器人位姿。如果机器人能够访问地图，则可以使用2D导航目标按钮命令机器人移动到期望的位置。当我们开始定位时，我们可以通过使用AMCL算法查看机器人周围的粒子云：
- en: '![](img/728e0ecb-ea30-44f4-80f6-ccec521b372a.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/728e0ecb-ea30-44f4-80f6-ccec521b372a.png)'
- en: Localizing the robot using AMCL
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AMCL定位机器人
- en: 'The following is a screenshot of the robot as it navigates autonomously from
    its current position to the goal position. The goal position is marked as a black
    dot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从当前位置自主导航到目标位置的机器人的截图。目标位置用黑色点标记：
- en: '![](img/cdec1d3e-d4c5-419c-bde4-81730c3156dc.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cdec1d3e-d4c5-419c-bde4-81730c3156dc.png)'
- en: Autonomous navigation using a map
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用地图进行自主导航
- en: The black line from the robot to the black dot is the robot's planned path to
    reach the goal position. If the robot is not able to locate the map, we might
    need to fine-tune the parameter files in the `ChefBot_bringup``param` folder.
    For more fine-tuning details, you can go through the AMCL package on ROS at [http://wiki.ros.org/amcl](http://wiki.ros.org/amcl).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从机器人到黑色点的黑色线是机器人计划到达目标位置的路程。如果机器人无法定位地图，我们可能需要微调 `ChefBot_bringup` 文件夹中的参数文件。有关更多微调细节，您可以在
    ROS 上的 AMCL 包中查看 [http://wiki.ros.org/amcl](http://wiki.ros.org/amcl)。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was about assembling the hardware of ChefBot and integrating the
    embedded and ROS code into the robot to perform autonomous navigation. We saw
    the robot hardware parts that were manufactured using the design from [Chapter
    6](lrn-rbt-py-2e_ch06.html), *Interfacing Actuators and Sensors to the Robot Controller*.
    We assembled the individual sections of the robot and connected the prototype
    PCB we designed for the robot. This consisted of the LaunchPad board, motor driver,
    left shifter, ultrasonic sensor, and IMU. The LaunchPad board was flashed with
    the new embedded code, which can interface with all sensors in the robot and can
    send or receive data from the PC.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讲述了 ChefBot 硬件的组装以及将嵌入式和 ROS 代码集成到机器人中以实现自主导航。我们看到了使用 [第 6 章](lrn-rbt-py-2e_ch06.html)
    的设计制造的机器人硬件部件，*将执行器和传感器连接到机器人控制器*。我们组装了机器人的各个部分，并连接了我们为机器人设计的原型 PCB。这包括 LaunchPad
    板、电机驱动器、左移位器、超声波传感器和 IMU。LaunchPad 板被刷入了新的嵌入式代码，该代码可以与机器人中的所有传感器接口，并能从 PC 发送或接收数据。
- en: After looking at the embedded code, we configured the ROS Python driver node
    to interface with the serial data from the LaunchPad board. After interfacing
    with the LaunchPad board, we computed the odometry data and differential drive
    control using nodes from the `differential_drive` package that was in the ROS
    repository. We interfaced the robot with the ROS navigation stack. This enabled
    us to use SLAM and AMCL for autonomous navigation. We also looked at SLAM and
    AMCL, created a map, and commanded the robot to navigate autonomously.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看嵌入式代码后，我们配置了 ROS Python 驱动节点以与 LaunchPad 板的串行数据接口。与 LaunchPad 板接口后，我们使用 ROS
    仓库中 `differential_drive` 包的节点计算了里程计数据和差速驱动控制。我们将机器人与 ROS 导航堆栈接口。这使得我们可以使用 SLAM
    和 AMCL 进行自主导航。我们还研究了 SLAM 和 AMCL，创建了一个地图，并命令机器人自主导航。
- en: Questions
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the use of the robot ROS driver node?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 机器人 ROS 驱动节点有什么用途？
- en: What is the role of the PID controller in navigation?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PID 控制器在导航中扮演什么角色？
- en: How do you convert encoder data to odometry data?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将编码器数据转换为里程计数据？
- en: What is the role of SLAM in robot navigation?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SLAM 在机器人导航中扮演什么角色？
- en: What is the role of AMCL in robot navigation?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AMCL 在机器人导航中扮演什么角色？
- en: Further reading
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can read more about the robotic vision package in ROS from the following
    links:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下链接中了解更多关于 ROS 中机器人视觉包的信息：
- en: '[http://wiki.ros.org/gmapping](http://wiki.ros.org/gmapping)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://wiki.ros.org/gmapping](http://wiki.ros.org/gmapping)'
- en: '[http://wiki.ros.org/amcl](http://wiki.ros.org/amcl)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://wiki.ros.org/amcl](http://wiki.ros.org/amcl)'
