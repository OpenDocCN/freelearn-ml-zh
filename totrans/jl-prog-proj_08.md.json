["```py\nCSV@v.0.4.3\nDataFrames@v0.15.2\nDataValues@v0.4.5\nGadfly@v1.0.1\nIJulia@v1.14.1\nQuery@v0.10.1\n```", "```py\npkg> add PackageName@vX.Y.Z \n```", "```py\npkg> add IJulia@v1.14.1\n```", "```py\njulia> download(\"https://raw.githubusercontent.com/PacktPublishing/Julia-Programming-Projects/master/Chapter08/Project.toml\", \"Project.toml\")\npkg> activate . \npkg> instantiate\n```", "```py\njulia> using CSV, DataFrames  \njulia> df = CSV.read(\"Map_of_Registered_Business_Locations.csv\") \n```", "```py\njulia> size(df, 1) \n222871  \n```", "```py\njulia> df[df[Symbol(\"Parking Tax\")] .== true, :][1:10, [Symbol(\"DBA Name\"), Symbol(\"Parking Tax\")]] \nDBA Name and Parking Tax columns only) where the business pays parking tax:\n```", "```py\njulia> @from i in df begin \n           @where i[Symbol(\"Parking Tax\")] == true \n           @select i \n           @collect DataFrame \n       end\n```", "```py\njulia> rename!(df, [n => replace(string(n), \" \"=>\"_\") |> Symbol for n in names(df)]) \n```", "```py\n@from i in df begin \n    @where i.Parking_Tax == true \n    @select i \n    @collect DataFrame \nend \n```", "```py\n@ prefix represents a macro—which introduces a very powerful programming technique called metaprogramming.\n```", "```py\njulia> x \nERROR: UndefVarError: x not defined \n```", "```py\njulia> :x \n:x \n```", "```py\njulia> typeof(:x) \nSymbol \n```", "```py\njulia> eval(:x) \nERROR: UndefVarError: x not defined \n```", "```py\njulia> assign = :(x = 2) \n:(x = 2) \njulia> eval(assign) \n2 \njulia> x \n2 \nExpr type with the assign variable and then eval it. Evaluation produces side effects, the actual value of the variable x now being 2.\n```", "```py\njulia> fieldnames(typeof(assign)) \n(:head, :args) \n```", "```py\njulia> dump(assign)\nExpr\nhead: Symbol =\nargs: Array{Any}((2,))\n1: Symbol x\n2: Int64 2  \n```", "```py\njulia> assign.args[2] = 3 \n3 \njulia> eval(assign) \n3 \njulia> x \n3 \n```", "```py\njulia> assign4 = Expr(:(=), :x, 4) :(x = 4) \njulia> eval(assign4) 4\n julia> x 4 \n```", "```py\njulia> quote \n           y = 42 \n           x = 10 \n       end\n julia> eval(ans) \n10\n julia> y \n42\n julia> x \n10 \n```", "```py\njulia> name = \"Dan\" \n\"Dan\" \n\njulia> greet = :(\"Hello \" * $name) \n:(\"Hello \" * \"Dan\") \n\njulia> eval(greet) \n\"Hello Dan\" \n```", "```py\njulia> macro greet(name) \n           :(\"Hello \" * $name) \n       end \n@greet (macro with 1 method)\njulia> @greet(\"Adrian\") \n\"Hello Adrian\" \nmacro keyword and are invoked using the @... syntax. The brackets are optional when invoking macros, so we could also use @greet \"Adrian\".\n```", "```py\njulia> macro twostep(arg) \n         println(\"I execute at parse time. The argument is: \", arg) \n         return :(println(\"I execute at runtime. The argument is: \", $arg)) \n       end \n@twostep (macro with 1 method) \n```", "```py\njulia> ex = macroexpand(@__MODULE__, :(@twostep :(1, 2, 3))); \nI execute at parse time. The argument is: $(Expr(:quote, :((1, 2, 3)))) \nmacroexpand, which takes as an argument the module in which to expand the expression (in our case, @__MODULE__ stands for the current module) and an expression that represents a macro invocation. The call to macroexpand converts (expands) the macro into its resulting expressions. The output of the macroexpand call is suppressed by appending ; at the end of the line, but the resulting expression is still safely stored in ex. Then, we can see that the expanding of the macro (its parsing) takes place because the I execute at parse time message is output. Now look what happens when we evaluate the expression, ex:\n```", "```py\njulia> eval(ex) \nI execute at runtime. The argument is: (1, 2, 3) \n```", "```py\njulia> @time rand(1000); \n  0.000007 seconds (5 allocations: 8.094 KiB) \n```", "```py\n@from var in data_source begin \n    # query statements here \nend \n```", "```py\njulia> shopping_list = DataFrame(produce=[\"Apples\", \"Milk\", \"Bread\"], qty=[5, 2, 1]) \n```", "```py\n@from p in shopping_list begin \n    @select p \nend \n```", "```py\njulia> @from p in shopping_list begin \n           @select p.produce \n       end \n3-element query result \n \"Apples\" \n \"Milk\" \n \"Bread\" \n```", "```py\njulia> @from p in shopping_list begin \n           @select uppercase(p.produce), 2p.qty \n       end \n3-element query result \n (\"APPLES\", 10) \n (\"MILK\", 4) \n (\"BREAD\", 2) \nproduce and two times the qty.\n```", "```py\njulia> @from p in shopping_list begin \n           @select { produce = uppercase(p.produce), qty = 2p.qty } \n       end \n```", "```py\njulia> @from p in shopping_list begin \n           @select { uppercase(p.produce), 2p.qty } \n       end \n```", "```py\njulia> @from p in shopping_list begin \n           @select { PRODUCE = uppercase(p.produce), double_qty = 2p.qty } \n           @collect \n       end \n```", "```py\njulia> @from p in shopping_list begin \n           @select {PRODUCE = uppercase(p.produce), double_qty = 2p.qty} \n           @collect DataFrame \n       end \n```", "```py\njulia> @from p in shopping_list begin \n           @where p.qty < 2 \n           @select p \n           @collect DataFrame \n       end \n```", "```py\njulia> @from p in shopping_list begin \n           @let weekly_qty = 7p.qty \n           @where weekly_qty > 10 \n           @select { p.produce, week_qty=weekly_qty } \n           @collect DataFrame \n       end \n```", "```py\njulia> products_info = DataFrame(produce = [\"Apples\", \"Milk\", \"Bread\"], price = [2.20, 0.45, 0.79], allergenic = [false, true, true]) \n```", "```py\nshopping_info = @from p in shopping_list begin \n    @join pinfo in products_info on p.produce equals pinfo.produce \n    @select { p.produce, p.qty, pinfo.price, pinfo.allergenic } \n    @collect DataFrame \nend \nshopping_list as p, adding an inner join, @join, with products_info as pinfo, on the condition that p.produce equals pinfo.produce. We basically put together the produce and qty columns from shopping_list DataFrame with the price and allergenic columns from products_info. The resulting DataFrame can now be referenced as shopping_info:\n```", "```py\n@from var1 in datasource1 begin \n    @join var2 in datasource2 on var1.column equals var2.column  \nend \n```", "```py\njulia> @from p in shopping_info begin \n           @group p.produce by p.allergenic \n           @collect \n       end \n2-element Array{Grouping{Bool,String},1}: \n [\"Apples\"] \n [\"Milk\", \"Bread\"]  \n```", "```py\n@from p in shopping_info begin\n    @group p by p.allergenic into q\n    @select { allergenic = key(q),\n    count = length(q.allergenic),\n    produce = join(q.produce, \", \") }\n    @collect DataFrame\nend  \nq variable and then pass the aggregation function, length, to get a count of the values of the allergenic column. We then use the join function to concatenate the values in the produce column.\n```", "```py\njulia> @from p in products_info begin \n           @orderby descending(p.price), p.produce \n           @select p \n           @collect DataFrame \n        end \n@orderby to sort the values in the source. Unsurprisingly, the resulting DataFrame will be properly sorted with the most expensive products on top:\n```", "```py\npkg> add DataValues \njulia> using DataValues \njulia> clean_df = @from b in df begin \n @where lowercase(b.City) == \"san francisco\" && b.State == \"CA\" &&\n ! isna(b.Street_Address) && ! isna(b.Source_Zipcode) &&\n ! isna(b.NAICS_Code) && ! isna(b.NAICS_Code_Description) &&\n ! isna(b.Business_Location) &&\n occursin(r\"\\((.*), (.*)\\)\", get(b.Business_Location)) &&\n isna(b.Business_End_Date) && isna(b.Location_End_Date)\n @select { b.DBA_Name, b.Source_Zipcode, b.NAICS_Code, \n b.NAICS_Code_Description, b.Business_Location }\n @collect DataFrame\nend \n```", "```py\nclean_df_geo = @from b in clean_df begin\n @let geo = split(match(r\"(\\-?\\d+(\\.\\d+)?),\\s*(\\-?\\d+(\\.\\d+)?)\", \n get(b.Business_Location)).match, \", \")\n @select {b.DBA_Name, b.Source_Zipcode, b.NAICS_Code,\n b.NAICS_Code_Description,\n lat = parse(Float64, geo[1]), long = parse(Float64, geo[2])}\n @collect DataFrame\nend \n```", "```py\njulia> unique(clean_df_geo[:, :Source_Zipcode]) |> length \n79 \n```", "```py\njulia> using CSV \njulia> clean_df_geo = CSV.read(\"clean_df_geo.tsv\", delim = '\\t', nullable = false) \n```", "```py\njulia> model_data = @from b in clean_df_geo begin \n    @group b by b.Source_Zipcode into g \n    @let bcount = Float64(length(g)) \n    @orderby descending(bcount) \n    @select { zipcode = Float64(get(key(g))), businesses_count = bcount } \n    @collect DataFrame \nend \n```", "```py\njulia> last(model_data) \n```", "```py\njulia> using Gadfly \njulia> plot(model_data, x=:businesses_count, Geom.histogram) \n```", "```py\nmodel_data = @from b in clean_df_geo begin \n    @group b by b.Source_Zipcode into g \n    @let bcount = Float64(length(g)) \n    @where bcount > 10 \n    @orderby descending(bcount) \n    @select { zipcode = Float64(get(key(g))), businesses_count = bcount } \n    @collect DataFrame \nend \n```", "```py\njulia> training_data = permutedims(convert(Array, model_data), [2, 1]) \n```", "```py\njulia> using Clustering\njulia> result = kmeans(training_data, 3, init=:kmpp, display=:iter)\n\n Iters               objv        objv-change | affected  \n------------------------------------------------------------- \n      0       6.726516e+06 \n      1       4.730363e+06      -1.996153e+06 |        0 \n      2       4.730363e+06       0.000000e+00 |        0 \nK-means converged with 2 iterations (objv = 4.73036279655838e6) \n```", "```py\njulia> result.assignments \n28-element Array{Int64,1}: \n 3 \n 3 \n 3 \n 1 \n 1 \n # some 1 values omitted from the output for brevity \n 1 \n 1 \n 2 \n 2 \n # some 2 values omitted from the output for brevity \n 2 \n 2 \n```", "```py\njulia> model_data[:cluster_id] = result.assignments \n28-element Array{Int64,1}: \n# output truncated #\n```", "```py\njulia> model_data\n```", "```py\njulia> plot(model_data, y = :zipcode, x = :businesses_count, color = result.assignments, Geom.point, Scale.x_continuous(minvalue=0, maxvalue=5000), Scale.y_continuous(minvalue=94050, maxvalue=94200), Scale.x_continuous(format=:plain)) \n```", "```py\ncompanies_in_top_areas = @from c in clean_df_geo begin \n       @where in(c.Source_Zipcode, [94110, 94103, 94109]) \n       @select c \n       @collect DataFrame \nend \n```", "```py\njulia> plot(companies_in_top_areas, y = :long, x = :lat, Geom.point, Scale.x_continuous(minvalue=36, maxvalue=40), Scale.y_continuous(minvalue=-125, maxvalue=-120), color=:Source_Zipcode) \n```", "```py\njulia> companies_in_top_areas = @from c in companies_in_top_areas begin \n           @where c.lat != minimum(companies_in_top_areas[:lat]) \n           @select c \n           @collect DataFrame \n      end \n```", "```py\njulia> activities = @from c in companies_in_top_areas begin \n           @group c by c.NAICS_Code_Description into g \n           @orderby descending(length(g)) \n           @select { activity = key(g), number_of_companies = length(g) } \n           @collect DataFrame \n       end \n```", "```py\njulia> plot(activities, y=:number_of_companies, Geom.bar, color=:activity, Scale.y_continuous(format=:plain), Guide.XLabel(\"Activities\"), Guide.YLabel(\"Number of companies\")) \n```", "```py\njulia> model_data = @from c in companies_in_top_areas begin \n           @select { latitude = c.lat, longitude = c.long } \n           @collect DataFrame \n       end \n```", "```py\njulia> training_data = permutedims(convert(Array{Float64}, model_data), [2, 1]) \n```", "```py\njulia> result = kmeans(training_data, 12, init=:kmpp, display=:iter) \n  # output truncated \nK-means converged with 24 iterations (objv = 0.28192820139520336) \n```", "```py\njulia> result.counts \n12-element Array{Int64,1}: \n 1076 \n 1247 \n  569 \n 1180 \n 1711 \n 1191 \n  695 \n    1 \n 1188 \n   29 \n 1928 \n 1149 \n```", "```py\njulia> plot(result.counts, Geom.bar, y=result.counts, Guide.YLabel(\"Number of businesses\"), Guide.XLabel(\"Cluster ID\"), color=result.counts) \n```", "```py\njulia> companies_in_top_areas[:cluster_id] = result.assignments \n```", "```py\njulia> plot(companies_in_top_areas, color=:cluster_id, x=:lat, y=:long) \n```", "```py\njulia> export_data = @from c in companies_in_top_areas begin \n                           @select { Name = c.DBA_Name, \n Zip = c.Source_Zipcode, \n                                     Group = string(\"Cluster $(c.cluster_id)\"), \n                                     Latitude = c.lat, Longitude = c.long,  \n                                     City = \"San Francisco\", State = \"CA\" } \n                           @collect DataFrame \n                     end \n```", "```py\njulia> CSV.write(\"businesses.csv\", head(export_data, 250)) \n```"]