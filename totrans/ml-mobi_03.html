<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Random Forest on iOS</h1>
                </header>
            
            <article>
                
<p>This chapter will provide you with an overview of the random forest algorithm. We will first look at the decision tree algorithm and, once we have a handle on it, try to understand the random forest algorithm. Then, we will use Core ML to create a machine learning program that leverages the random forest algorithm and predicts the possibility of a patient being diagnosed with breast cancer based on a given set of breast cancer patient data.</p>
<p>As we already saw in <a href="51fcaf51-eb68-4493-afc2-0b02f1c1d50e.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to Machine Learning on Mobile,</em> any machine learning program has four phases: define the machine learning problem, prepare the data, build/rebuild/test the model, and deploy it for usage. In this chapter, we will try to relate these with random forest and solve the underlying machine learning problem.</p>
<p><strong>Problem definition</strong>: The breast cancer data for certain patients is provided and we want to predict the <span>possibility of diagnosing breast cancer for a new data item.</span></p>
<p>We will be covering the following topics:</p>
<ul>
<li>Understanding decision trees and how to apply them to solve an ML problem</li>
<li>Understanding decision trees through a sample dataset and Excel</li>
<li>Understanding random forests</li>
<li>Solving the problem using a random forest in Core ML:
<ul>
<li>Technical requirements</li>
<li>Creating a model file using the scikit-learn and pandas libraries</li>
<li>Testing the model</li>
<li>Importing the scikit-learn model into the Core ML project</li>
<li>Writing an iOS mobile application and using the scikit-learn model in it to perform the breast cancer prediction</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to algorithms</h1>
                </header>
            
            <article>
                
<p>In this section, we will look at the decision tree algorithm. We will go through an example to understand the algorithm. Once we get some clarity on the algorithm, we will try to understand the random forest algorithm with an example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decision tree </h1>
                </header>
            
            <article>
                
<p>To understand the random forest model, we must first learn about the decision tree, the basic building block of a random forest. We all use decision trees in our daily lives, even if you don't know it by that name. You will be able to relate to the concepts of a decision tree once we start going through the example.</p>
<p>Imagine you approach a bank for a loan. The bank will scan you for a series of eligibility criteria before they approve the loan. For each individual, the loan amount they offer will vary, based on the different eligibility criteria they satisfy. </p>
<p>They may go ahead with various decision points to make the final decision to arrive at the possibility of granting a loan and the amount that can be given, such as the following:</p>
<ul>
<li><strong>Source of income</strong>: Employed or self-employed?</li>
<li><strong>If employed, place of employment</strong>: Private sector or government sector?</li>
<li><strong>If private sector, range of salary</strong>: Low, medium, or high?</li>
<li><strong>If government sector, range of salary</strong>: Low, medium, or high?</li>
</ul>
<p>There may be further questions, such as how long you've been employed with that company, or whether you have any outstanding loans. This process, in its most basic form, is a decision tree:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-923 image-border" src="assets/8ed81da7-31ba-4376-b2ef-ca932251b95e.png" style="width:33.42em;height:25.25em;"/></p>
<p>As you can see in the preceding diagram, a decision tree is a largely used non-parametric effective machine learning modeling technique for classification problems. To find solutions, a decision tree makes sequential, hierarchical decisions about the outcomes based on the predictor data.</p>
<p>For any given data item, a series of questions is asked, which leads to a class label or a value. This model asks a series of predefined questions of the incoming data item and, based on these answers, branches out to that series and proceeds until it arrives at the resulting data value or class label. The model is constructed based on the observed data, and there are no assumptions made about the distribution of the errors or the distribution of data itself.</p>
<p>In the decision tree models where the target variable uses a discrete set of values, this is called a <strong>classification tree</strong>. In these trees, each node, or leaf, represents class labels, while the branches represent features leading to class labels.</p>
<p>A decision tree where the target variable takes a continuous value, usually numbers, is called a <strong>regression tree</strong>. </p>
<p>These decision trees are well represented using <strong>directed acyclic graphs</strong> (<strong>DAGs</strong>). In these graphs, nodes represent decision points and edges are the connections between the nodes. In the preceding loan scenario, the salary range of $30,000-$70,000 would be an edge and the medium are nodes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advantages of the decision tree algorithm</h1>
                </header>
            
            <article>
                
<p>The goal of the decision tree is to arrive at the optimal choice for the given problem. The final leaf node should be the best choice for the problem at hand. The algorithm behaves greedily and tries to come to the optimal choice in each decision it takes.</p>
<p>The whole problem is divided into multiple sub-problems, with each sub-problem branching out to other sub-problems. <span>The subsets arrived are based on a parameter called <strong>purity</strong>.</span> A node is said to be 100% pure when all decisions will lead to data belonging to the same class. It will be 100% impure when there is a possibility of splitting its subsets into categories. The goal of the algorithm is to reach 100% purity for each node in the tree.</p>
<p>The purity of a node is measured using Gini impurity, and Gini impurity is a standard metric that helps in splitting the node of a decision tree.</p>
<p>The other metric that would be used in a decision tree is information gain, which will be used to decide what feature of the dataset should be used to split at each step in the tree. <span>The</span><span> </span>information gain <span>is the decrease</span> <span>in entropy (randomness) after a dataset is split on an attribute. Constructing a </span>decision tree <span>is all about finding attributes that return the highest </span>information gain,<span> that is, the most homogeneous branches, which means all data belonging to the same subset or class.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Disadvantages of decision trees</h1>
                </header>
            
            <article>
                
<p>The model stops only when all data points can fit into a single class/category. So there is a possibility that it may not generalize well for complex problems and the chance of bias is high.</p>
<p>These problems can be solved by defining the maximum depth of the tree or by specifying the minimum number of data points needed to split the node further in the tree.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advantages of decision trees</h1>
                </header>
            
            <article>
                
<p>The following are the advantages listed:</p>
<ul>
<li>Simple to understand and visualize</li>
<li>Very easy to build and can handle both qualitative and quantitative data</li>
<li>Easy to validate</li>
<li>Computationally, it is not very expensive</li>
</ul>
<div class="packt_tip"><span>To summarize the decision tree model, we can conclude that it is basically a </span><span>flowchart of questions leading to a prediction.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Random forests</h1>
                </header>
            
            <article>
                
<p><span>Now, let's move from a single decision tree to a random forest. If you wanted to guess who the next President will be, how would you go about predicting this?  </span>Let's see the different kinds of questions that we would ask to predict this:</p>
<ul>
<li><span>How many candidates are there? Who are they?</span></li>
<li>Who is the current President?</li>
<li>How are they performing?</li>
<li>Which party do they belong to?</li>
<li>Is there any current movement against that party?</li>
<li>In how many states the political party has probability to win</li>
<li>Were they the incumbent President?</li>
<li>What are the major voting issues?</li>
</ul>
<p><span>M</span><span>any questions like this will come to our mind and we will attach </span>different <span>weights/importance to them.</span></p>
<p class="mce-root">Each person's prediction to the preceding questions may be different. There are too many factors to take into account, and the possibility are, each person's guess will be different. Every person comes to these questions with different backgrounds and knowledge levels, and may interpret the question differently.</p>
<p class="mce-root">So there is chance of having a high variance for the answers. If we take all the predictions given by different individuals separately and then average them out, it becomes a random forest. </p>
<p>A random forest combines many decision trees into a single model. Individually, predictions made by decision trees (or humans) may not be accurate, but, when combined, the predictions will be closer to the mark, on average.</p>
<p>The following diagram will help us understand the voting prediction using the random forest algorithm:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-925 image-border" src="assets/5bf737ee-2d42-4d41-b7ce-7ebeb1966472.png" style="width:40.25em;height:22.17em;"/></p>
<p>The following diagram gives a flowchart view of the previous diagram: </p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-924 image-border" src="assets/531ae8f1-7db7-4759-b594-4fc3ce0d9a31.png" style="width:15.50em;height:20.92em;"/></p>
<p>Let's look at why a random forest is better than a decision tree:</p>
<ul>
<li>A random forest is a combination of many decision trees and, hence, there is a greater probability that there would be many viewpoints to arrive at the final prediction.</li>
<li>If only a single decision tree is considered for prediction, there is less information considered for prediction. But, in a random forest, when there are many trees involved, there is more information and it is more diverse. </li>
<li>The random forest may not be biased, as may be the case with the decision tree, since it is not dependent on a single source.</li>
</ul>
<p class="mce-root">Why the name random forest? Well, as much as people might rely on different sources to make a prediction, each decision tree in the forest considers a random subset of features when forming questions and only has access to a <span>random set of the training data points. This increases diversity in the forest, leading to more robust overall predictions and hence, the name random forest. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Solving the problem using random forest in Core ML</h1>
                </header>
            
            <article>
                
<p>In this section, we will try to understand the random forest through a detailed example with a specific dataset. We are going to use the same dataset to work out the iOS Core ML example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dataset</h1>
                </header>
            
            <article>
                
<p>We will use the breast cancer dataset for the random forest problem. <span>Features are computed from a digitized image of a <strong>fine needle aspirate</strong> (<strong>FNA</strong>) of a breast mass. They describe the characteristics of the cell nuclei present in the image. The dataset can be found at <a href="https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)">https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)</a>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Naming the dataset</h1>
                </header>
            
            <article>
                
<p>We will be using the <span>Breast Cancer dataset. </span>The following list contains the various conventions used in the dataset:</p>
<ul>
<li><span>ID number</span><span> </span></li>
<li>Diagnosis (<em>M</em> = malignant, and <em>B</em> = benign)<span> </span></li>
</ul>
<ul>
<li><span>10 real-valued features are computed for each cell nucleus:</span>
<ul>
<li>Radius (mean of the distances from the center to points on the perimeter)<span> </span></li>
<li>Texture (standard deviation of gray scale values)<span> </span></li>
<li>Perimeter<span> </span></li>
<li>Area<span> </span></li>
<li>Smoothness (local variation in radius lengths)<span> </span></li>
<li>Compactness (<em>perimeter^2/area - 1.0</em>)</li>
<li>Concavity (severity of concave portions of the contour)<span> </span></li>
<li>Concave points (number of concave portions of the contour)<span> </span></li>
<li>Symmetry<span> </span></li>
<li>Fractal dimension (coastline approximation-1)</li>
</ul>
</li>
</ul>
<p>We will use random forest through Excel, applying the breast cancer dataset, to understand random forest in detail.  We will consider only data elements from 569 sample pieces of data from the breast cancer dataset for the purposes of analysis.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The following software needs to be installed on the developer machine:</p>
<ul>
<li>Python</li>
<li>Xcode in the macOS environment</li>
</ul>
<p><span>The exercise programs for the chapter can be found on the GitHub repository (<a href="https://github.com/PacktPublishing/Machine-Learning-for-Mobile">https://github.com/PacktPublishing/Machine-Learning-for-Mobile</a>) under the <kbd>Chapter03</kbd> folder. </span>Let's start by entering the command to install the Python package:</p>
<pre>pip install pandas<br/><span class="n">pip</span> <span class="n">install</span> <span class="o">-</span><span class="n">U</span> <span class="n">scikit</span><span class="o">-</span><span class="n">learn<br/></span>pip install -U pandas</pre>
<p>Then, issue the command to install <kbd>coremltools</kbd>:</p>
<pre><span class="">pip install -U coremltools</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the model file using scikit-learn </h1>
                </header>
            
            <article>
                
<p>This section will explain how we are going to create the random forest model file using scikit-learn and convert it into the <kbd>.mlmodel</kbd> file that is compatible with Core ML. We are going to use the Breast Cancer dataset to create the model. The following is a Python program that creates a simple random forest model using scikit-learn and the Breast Cancer dataset. Then, the Core ML tools convert it into the Core ML—compatible model file. Let's go through the program in detail.</p>
<p>First, we need to import the required packages:</p>
<pre># importing required packages<br/> import numpy as np</pre>
<p>NumPy is the fundamental package for scientific computing with Python. It contains <span>a powerful N-dimensional array object. This <kbd>numpy</kbd> array will be used in this program for storing the dataset, which has 14 dimensions:</span></p>
<pre>import pandas as pd<br/> from pandas.core import series</pre>
<p>Here, we are using pandas<span> (</span><a href="https://pandas.pydata.org/pandas-docs/stable/10min.html">https://pandas.pydata.org/pandas-docs/stable/10min.html</a><span>) which is an open source, BSD-licensed library providing high-performing, easy-to-use data structures and data analysis tools for the </span><span>Python</span><span> programming language. </span><span>Using pandas, we can create a data frame. You can assume that a pandas dataframe is an Excel sheet in which every sheet has headings and data.</span></p>
<p>Now, let's move on to understand the program written for solving the machine learning problem at hand:</p>
<pre>from sklearn.ensemble import RandomForestClassifier<br/><br/>from sklearn.metrics import accuracy_score<br/><span>import sklearn.datasets as ds</span><span>import sklearn.datasets as ds</span></pre>
<p>The preceding lines import the <kbd>sklearn</kbd> packages. Now, we will import built-in datasets in the <kbd>sklearn</kbd> package:</p>
<pre><span>dataset = ds.load_breast_cancer()</span></pre>
<p>The preceding line loads the Breast Cancer dataset from the <kbd>sklearn</kbd> dataset package:</p>
<pre> <span>cancerdata = pd.DataFrame(dataset.data)</span></pre>
<p><span>This will create a dataframe from the data present in the dataset. Let's assume that the dataset i</span>s an E<span>xcel sheet with rows and columns with column headings:</span></p>
<pre> <span>cancerdata.columns = dataset.feature_names</span></pre>
<p><span>The following piece of code will add the column headings to the columns in the dataset:</span></p>
<pre>for i in range(0,len(dataset.feature_names)):<br/>if ['mean concave points', 'mean area', 'mean radius', 'mean perimeter', 'mean concavity'].\<br/>__contains__(dataset.feature_names[i]):<br/>continue<br/>else:<br/>cancerdata = cancerdata.drop(dataset.feature_names[i], axis=1)</pre>
<p>The preceding lines will delete all the columns other than the following:</p>
<ul>
<li>Mean concave points</li>
<li>Mean area</li>
<li>Mean radius</li>
<li>Mean perimeter</li>
<li>Mean concavity</li>
</ul>
<p class="mce-root">To reduce the number of feature columns in the dataset, I am deleting some of the columns that have less impact on the model:</p>
<pre><span>cancerdata.to_csv("myfile.csv")</span></pre>
<p><span>This line will save the data to a CSV file; you can open it and see in Excel to find out what is present in the dataset:</span></p>
<pre> <span>cancer_types = dataset.target_names</span></pre>
<p>In the Excel dataset, when you examine it, you will know that the diagnosis will include the value as 0 or 1, where 0 is malignant and 1 is benign. To change these numeric values to the real names, we write the following piece of code:</p>
<pre>cancer_names = []<br/>//getting all the corresponding cancer types with name [string] format.<br/>for i in range(len(dataset.target)):<br/>cancer_names.append(cancer_types[dataset.target[i]])<br/>x_train, x_test, y_train, y_test = sklearn.model_selection.train_test_split(cancerdata,cancer_names,test_size=0.3, random_state=5)</pre>
<p><span>This line of code will split the dataset into two—one for training and one for testing, and will save it in the corresponding variables defined for the purpose:</span></p>
<pre> <span>classifier = RandomForestClassifier()</span></pre>
<p><span>The following will create a classifier:</span></p>
<pre><span>classifier.fit(x_train, y_train)</span></pre>
<p><span>This code will feed the training data and train the model:</span></p>
<pre>//testing the model with test data<br/>print(classifier.predict(x_test))</pre>
<p><span>The preceding line will print the predicted cancer types for the testing data to the console, as shown here:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/db7a7788-e16b-434d-8d39-2c5c91e3eddc.png" style="width:57.58em;height:33.58em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting the scikit model to the Core ML model</h1>
                </header>
            
            <article>
                
<p>Let me explain using an example: let's assume you're from France and you only speak French and English. Imagine you went to India on vacation. And you went to your hotel restaurant, where the waiter offered you a menu that was written in a local language. Now, what would you do? Let me guess, you'd ask the waiter, <span>or another customer/your tour guide,</span><span> to explain the items to you, or you simply scan the images in Google translate.</span></p>
<p>My point is that you need a translator. That's it. Similarly, in order for the scikit model to be understood by the iOS mobile application, a converter that will translate it to the Core ML format is required.</p>
<p>That's all the work of the following code. It will convert the scikit-learn format to the Core ML format:</p>
<pre>//converting the fitted model to a Core ML Model file<br/><br/>model = coremltools.converters.sklearn.convert(classifier, input_features=list(cancerdata.columns.values), output_feature_names='typeofcancer')<br/><br/>model.save("cancermodel.mlmodel")</pre>
<p>For this, to work, you have to install <kbd>coremltools</kbd> using your <kbd>pip</kbd>. Then, write the following code on the top to import it:</p>
<pre>import coremltools</pre>
<p>Once you run this program, you will get a model file in your disk, named  <kbd>cancermodel.mlmodel</kbd>, which you'll use in your iOS project for inference.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an iOS mobile application using the Core ML model</h1>
                </header>
            
            <article>
                
<p>In this section, we will be creating an iOS project to use Core ML, for which you will require <span>Xcode (it must be version 9+). </span></p>
<p><span>Let's get started by opening Xcode and creating an empty swift application with a storyboard. In the main storyboard design, the screen will appear as follows. </span><span>Then, add the generated model file to your project. This should give you the following structure: </span></p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-928 image-border" src="assets/8852eb62-93c8-45a7-b04b-118ab566e3f1.png" style="width:14.83em;height:18.58em;"/></p>
<p>Now, create the UI in your main storyboard file, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/caaef230-54a1-4912-bd7e-9679cae60ff4.png" style="width:17.83em;height:32.00em;"/></p>
<p>Create outlets for each text field. And add event listener to each and every text field. Now, your view controller will look like this:</p>
<pre>import UIKit<br/>import Core ML <br/>class ViewController: UIViewController {<br/>    let model = cancermodel()<br/>    @IBOutlet weak var meanradius: UITextField!<br/>    @IBOutlet weak var cancertype: UILabel!<br/>    @IBOutlet weak var meanperimeter: UITextField!<br/>    @IBOutlet weak var meanarea: UITextField!<br/>    @IBOutlet weak var meanconcavity: UITextField!<br/>    @IBOutlet weak var meanconcavepoints: UITextField!<br/>    override func didReceiveMemoryWarning() {<br/>        super.didReceiveMemoryWarning()<br/>        // Dispose of any resources that can be recreated.<br/>    }<br/>    override func viewDidLoad() {<br/>        super.viewDidLoad();<br/>        updated(meanconcavepoints);<br/>        //This line is to fire the initial update of the cancer type.<br/>    }<br/>    /*<br/>This method will send the input data to your generated model class and display the returned result to the label.<br/>*/<br/><br/>    @IBAction func updated(_ sender: Any) {<br/>        guard let modeloutput = try? model.prediction(mean_radius: <br/>        Double(meanradius.text!)!, mean_perimeter: <br/>        Double(meanperimeter.text!)!, mean_area: Double(meanarea.text!)!, <br/>        mean_concavity: Double(meanconcavity.text!)!, mean_concave_points: <br/>        Double(meanconcavepoints.text!)!) else {<br/>            fatalError("unexpected runtime error")<br/>        }<br/>        cancertype.text = modeloutput.typeofcancer;<br/>    }<br/>}</pre>
<p>You can find the same code in the GitHub repository for this book.</p>
<div class="packt_tip">If you encounter any issue while building. Like signing or certificate, please google it or write to us.</div>
<p>Once you set up the project in Xcode, you can run it in the simulator. The result will look like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5a912732-bce4-4f4c-b19f-b715bbfa735f.png" style="width:19.42em;height:34.58em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about<span> decision trees and random forests, and the differences between them. We also </span><span>explored a decision tree through a sample dataset and Excel using</span><span> a sample dataset and used random forest algorithm to it in order to establish the prediction. </span><span>We used Core ML to write the iOS program, and then we applied the scikit-learn to create the model and converted the scikit model to the Core ML model using</span> <span>Core ML</span> <span>tools.</span></p>
<p>In the next chapter, we will learn more about TensorFlow and its use in Android. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p><span>We can get further insight into Core ML and the services it offers by visiting their official website: </span><a href="https://developer.apple.com/documentation/coreml">https://developer.apple.com/documentation/coreml</a>.</p>


            </article>

            
        </section>
    </body></html>