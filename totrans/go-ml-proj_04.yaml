- en: Decomposing CO2 Trends Using Time Series Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用时间序列分析分解CO2趋势
- en: If you are reading this book in the year 2055—assuming you're still using a
    year system based on the Common Era (a year is the time taken by the planet you're
    on to go around the sun once)—congratulations! You have survived. This book is
    written in the year 2018, and we as humans have much to worry about in terms of
    the survival of our species.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是在2055年阅读这本书——假设你仍然在使用基于公历的年份系统（一年是地球围绕太阳公转一次所需的时间）——恭喜你！你已经存活了下来。这本书是在2018年写的，而我们人类在物种生存方面有许多担忧。
- en: 'By and large, we have managed to work our way into a relatively stable peace,
    but the future of our species as a whole is somewhat at risk from various threats.
    Most of these threats have been caused by our own actions in the past. I''d like
    to emphasize a point here: I''m not assigning blame to anyone in the past for
    causing these threats. Our ancestors were busy optimizing to different goals,
    and the threats are typically an unforeseen/unforeseeable side-effect of the actions
    at that time.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们已经设法进入了一个相对稳定的和平时期，但作为整体，我们物种的未来面临着各种威胁。其中大部分威胁是由我们过去的行为引起的。我想强调一点：我并不是在责怪过去任何人造成这些威胁。我们的祖先正忙于优化不同的目标，而这些威胁通常是当时行动中不可预见/无法预见的外部效应。
- en: A compounding factor is that humans are, biologically speaking, not very well
    suited to thinking about the future. Our brains simply do not see our future selves
    as a continuity of our current selves [0],[1]. As a result, we often think of
    things that may happen to us in the future as things that happen to someone else,
    or that the future is exaggerated. This has led to decisions made today without
    consideration to the effect in the future. This has led to many threats that arise
    from past actions of our species.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个影响因素是，从生物学的角度来看，人类并不擅长思考未来。我们的大脑根本不把我们未来的自己视为当前自我的连续体[0],[1]。因此，我们常常把未来可能发生的事情看作是别人发生的事情，或者认为未来被夸大了。这导致了今天做出的决策没有考虑到未来的影响。这导致了我们物种过去行为引起的许多威胁。
- en: One of those threats is runaway climate change that could ruin our entire way
    of living, and potentially threaten the entire human species with extinction.
    It is very real and very unexaggerated. Human-induced climate change is a very
    wide topic with many niches. The primary gist of the major cause of human-induced
    climate change is the increased rates release of **carbon dioxide** (**CO[2]**)
    into the air.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个威胁是失控的气候变化，这可能会摧毁我们整个的生活方式，并可能威胁到整个人类的灭绝。这是非常真实且不过分的。人为引起的气候变化是一个非常广泛的话题，有许多细分领域。人为引起气候变化的主要原因是在空气中释放二氧化碳（**CO[2]**）的速率增加。
- en: In this chapter, we will perform a time series analysis on CO[2] in the air.
    The main goal of this chapter is to serve as an introduction to time series analysis.
    On the technical end, you will learn the finer side of plotting using **Gonum**.
    Also, we'll learn how to deal with non-conventional data formats.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将对空气中的二氧化碳（CO[2]）进行时间序列分析。本章的主要目标是作为时间序列分析的入门介绍。在技术层面，你将学习使用**Gonum**进行细粒度绘图。此外，我们还将学习如何处理非常规数据格式。
- en: Exploratory data analysis
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索性数据分析
- en: The amount of CO[2] in the air can be measured. The **National Oceanic and Atmospheric
    Administration** (**NOAA**) department has been collecting data on the amount
    of CO[2] in the air since the early 1950s. The data we'll be using can be found
    at [https://www.esrl.noaa.gov/gmd/ccgg/trends/data.html](https://www.esrl.noaa.gov/gmd/ccgg/trends/data.html).
    We'll specifically be using that Mauna Loa monthly mean data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 空气中的二氧化碳含量是可以测量的。**国家海洋和大气管理局**（**NOAA**）部门自20世纪50年代初就开始收集空气中二氧化碳含量的数据。我们将使用的数据可以在[https://www.esrl.noaa.gov/gmd/ccgg/trends/data.html](https://www.esrl.noaa.gov/gmd/ccgg/trends/data.html)找到。我们将特别使用莫纳罗亚的月平均数据。
- en: 'The data, after removing the comments, looks something like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 移除注释后的数据看起来大致如下：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In particular, we are interested in the `interpolated` column.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们对`插值`列感兴趣。
- en: Because this is a particularly interesting dataset, it might be worth looking
    at how to download and preprocess the data directly in Go.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个特别有趣的数据库，可能值得看看如何在Go中直接下载和预处理数据。
- en: Downloading from non-HTTP sources
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从非HTTP源下载
- en: 'We''ll start by writing the function that will download the data, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写一个下载数据的函数，如下所示：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The NOAA data sits on a publicly accessible FTP server: [ftp://aftp.cmdl.noaa.gov/products/trends/co2/co2_mm_mlo.txt](ftp://aftp.cmdl.noaa.gov/products/trends/co2/co2_mm_mlo.txt).
    If you visit the URI via a web browser, you would see the data immediately. To
    access the data programmatically is a little tricky, as this is not a typical
    HTTP URL.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: NOAA 数据位于一个公开可访问的 FTP 服务器上：[ftp://aftp.cmdl.noaa.gov/products/trends/co2/co2_mm_mlo.txt](ftp://aftp.cmdl.noaa.gov/products/trends/co2/co2_mm_mlo.txt)。如果你通过网页浏览器访问
    URI，你会立即看到数据。以编程方式访问数据有点棘手，因为这不是一个典型的 HTTP URL。
- en: 'To handle FTP connections, we will be using the `github.com/jlaffaye/ftp` package.
    The package can be installed using the standard `go get` method: `go get -u github.com/jlaffaye/ftp`.
    The documentation for the package is a little sparse and somewhat requires you
    to understand the FTP standards. But, fear not, using FTP to acquire the file
    is relatively simple.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理 FTP 连接，我们将使用 `github.com/jlaffaye/ftp` 包。可以使用标准的 `go get` 方法安装该包：`go get
    -u github.com/jlaffaye/ftp`。该包的文档相对较少，并且需要你理解 FTP 标准。但不用担心，使用 FTP 获取文件相对简单。
- en: First we need to dial in to the server (you would need to do the same if you
    were working with HTTP endpoints—`net/http` merely abstracts out the dialing in
    so you wouldn't necessarily see what's happening in the background). Because dialing
    in is a fairly low-level procedure, we would need to supply the ports as well.
    Just like the convention for HTTP is for the server to listen on port `80`, the
    convention for an FTP server is to listen to port `21`, so we'd have to connect
    to a server specifying that we want to connect on port `21`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要连接到服务器（如果你正在处理 HTTP 端点——`net/http` 仅抽象出连接过程，所以你不必一定看到后台发生的事情）。因为连接是一个相当低级的过程，我们需要提供端口号。就像
    HTTP 的惯例是服务器监听端口 `80` 一样，FTP 服务器的惯例是监听端口 `21`，所以我们需要连接到一个指定要连接到端口 `21` 的服务器。
- en: An additional oddity to those not used to working with FTP is that FTP requires
    a login to the server. For servers with anonymous read-only access, the convention
    is typically to use "anonymous" as the username and password.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不习惯使用 FTP 的人来说，一个额外的奇怪之处在于 FTP 需要登录到服务器。对于具有匿名只读访问的服务器，通常的做法是使用 "anonymous"
    作为用户名和密码。
- en: After successfully logging in, we retrieve the requested resource (the file
    that we want) and download the file. The `fttp` library at [github.com/jlaffaye/ftp](https://github.com/jlaffaye/ftp) returns
    `io.Reader.` Think of it as a file that contains the data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录后，我们检索请求的资源（我们想要的文件）并下载文件。位于 [github.com/jlaffaye/ftp](https://github.com/jlaffaye/ftp)
    的 `fttp` 库返回 `io.Reader`。可以将其视为包含数据的文件。
- en: Handling non-standard data
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理非标准数据
- en: 'Parsing the data is a piece of cake with only the standard library:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用标准库解析数据是一件轻而易举的事情：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The parsing function takes a `loader`, which when called, returns a `io.Reader`.
    We then wrap the `io.Reader` in a `bufio.Scanner`. Recall that the format is not
    standard. There are some things that we want and some things we don't. The data
    however is in a fairly consistent format—we can use the standard library functions
    to filter the ones we want and the ones we don't.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 解析函数接受一个 `loader`，当调用时返回一个 `io.Reader`。然后我们将 `io.Reader` 包装在 `bufio.Scanner`
    中。回想一下，格式不是标准的。有些是我们想要的，有些我们不想。然而，数据格式相当一致——我们可以使用标准库函数来过滤我们想要的和不想的。
- en: The `s.Scan()` method scans `io.Reader` until it encounters a newline. We can
    retrieve the string using `s.Text()`. If the string starts with `#`, we skip the
    line.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`s.Scan()` 方法扫描 `io.Reader` 直到遇到换行符。我们可以使用 `s.Text()` 获取字符串。如果字符串以 `#` 开头，我们跳过该行。'
- en: Otherwise, we use `strings.Fields` to split the string into fields. The reason
    why we use `strings.Fields` instead of `strings.Split` is because the latter does
    not handle multiple spaces well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们使用 `strings.Fields` 将字符串拆分为字段。我们之所以使用 `strings.Fields` 而不是 `strings.Split`，是因为后者处理多个空格不好。
- en: 'Following the splitting of the row into fields, we parse things that are necessary:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在将行拆分为字段之后，我们解析必要的内容：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Why do we need a `loader` type?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要一个 `loader` 类型？
- en: 'The reason is simple: we want to be good citizens— we should not be repeatedly
    requesting data from the FTP server while we are developing the program. Rather,
    we would cache the file and work with that single file while in development mode.
    This way, we wouldn''t have to download from the internet all the time.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很简单：我们想成为好公民——在开发程序时，我们不应该反复从 FTP 服务器请求数据。相反，我们会缓存文件，并在开发模式下使用该单个文件。这样，我们就不必总是从互联网上下载。
- en: 'The corresponding `loader` type that reads from the file looks something like
    this, and is rather self-explanatory:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取的相应`loader`类型看起来如下，相当直观：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Dealing with decimal dates
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理十进制日期
- en: 'One of the more interesting custom formats used in this data is dates. It''s
    a format known as **decimal dates**. They look like as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些数据中使用的更多有趣的自定义格式之一是日期。它是一种称为**十进制日期**的格式。它们看起来如下所示：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What this means is that this date represents the halfway point of the year
    2018\. There are 365 days in 2018\. The 50% mark would be 183 days into the year:
    July 3 2018.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这个日期代表了2018年的中点。2018年有365天。50%的标记将是183天：2018年7月3日。
- en: 'We can translate this logic into the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个逻辑转换为以下代码：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first step is to split the string into the year and the decimal portion.
    The year is parsed as an `int` datatype, while the decimal part is parsed as a
    floating point number to ensure we can perform math. Here, it''s important to
    note that a bug can happen if you''re not careful about it: after splitting the
    string, `"0."` needs to be prepended to the string.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将字符串拆分为年份和小数部分。年份被解析为`int`数据类型，而小数部分被解析为浮点数以确保我们可以进行数学运算。在这里，需要注意的是，如果不小心处理，可能会发生错误：在拆分字符串后，需要将`"0."`添加到字符串前面。
- en: A cleaner alternative would be to parse the string as `float64`, and then use
    `math.Modf` to split the float into the integer component and the decimal component.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简洁的替代方案是将字符串解析为`float64`，然后使用`math.Modf`将浮点数拆分为整数部分和小数部分。
- en: Either way, once we have the decimal component, we can use it to figure out
    how many days into the year it is. But first we'd have to figure out if the year
    is a leap year.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，一旦我们有了小数部分，我们就可以用它来确定一年中的天数。但首先，我们需要确定这一年是否是闰年。
- en: We can calculate the number of days into the years simply by multiplying the
    decimal number by the number of days in the year. Following from that, we simply
    add the number of dates, and return the date.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将小数乘以一年中的天数来简单地计算年份中的天数。在此基础上，我们只需添加日期数，然后返回日期。
- en: One thing to note is that we pass in a `*time.Location`—in this specific instance,
    we know that the observatory is in Hawaii, and therefore we set it to `"Pacific/Honolulu"`.
    Although in this case, we could set the location to any other location in the
    world, and it wouldn't change the results of the data. But this is unique to this
    project—in other time series data, time zones may be important as the data collection
    method may involve time data from different time zones.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，我们传递了一个`*time.Location`——在这个特定的情况下，我们知道天文台位于夏威夷，因此我们将其设置为`"Pacific/Honolulu"`。尽管在这种情况下，我们可以将位置设置为世界上任何其他地方，这不会改变数据的结果。但这在这个项目中是独特的——在其他时间序列数据中，时区可能很重要，因为数据收集方法可能涉及来自不同时区的时数据。
- en: Plotting
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘图
- en: 'Now that we''ve finished with getting the file and parsing it, let''s plot
    the data. Again, as in [Chapter 2](12c81095-6fcf-4da9-b554-6367d45b34f8.xhtml),
    *Linear Regression-House Price Prediction*,we will be using Gonum''s excellent
    plotting library. This time around, we''re going to be exploring more of it in
    detail. We''ll learn the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了获取文件和解析文件的工作，让我们绘制数据。再次，就像在[第二章](12c81095-6fcf-4da9-b554-6367d45b34f8.xhtml)中，*线性回归-房价预测*，我们将使用Gonum出色的绘图库。这一次，我们将更详细地探索它。我们将学习以下内容：
- en: How to plot a time series
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何绘制时间序列图
- en: How a plot breaks down into its elements and how we can manipulate those elements
    to style a chart
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将图表分解为其元素以及如何操作这些元素来设计图表
- en: How to create plotters for chart types that Gonum does not provide for
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建Gonum不提供的图表类型的绘图器
- en: 'We''ll start by writing a function to plot a time series:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写一个函数来绘制时间序列图：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we use the already familiar `plotter.XYs` (which you would have been acquainted
    with in the first chapter). Instead of using `plotutil.AddLines` as we did the
    last time, we shall do it manually, which allows us to control the styling of
    the lines a bit better.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用已经熟悉的`plotter.XYs`（你会在第一章中熟悉它）。这次，我们不会像上次那样使用`plotutil.AddLines`，而是手动操作，这使我们能够更好地控制线条的样式。
- en: We simply create a new `*Line` object with `plotter.NewLine`. The `*Line` object
    is primarily `plot.Plotter`, which is any type that can draw itself onto a canvas.
    In the later part of this chapter, we shall explore how to create our own `plot.Plotter` interface
    and other associated types to draw a custom type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需使用 `plotter.NewLine` 创建一个新的 `*Line` 对象。`*Line` 对象主要是 `plot.Plotter`，它是任何可以将其自身绘制到画布上的类型。在本章的后续部分，我们将探讨如何创建我们自己的
    `plot.Plotter` 接口和其他相关类型来绘制自定义类型。
- en: Styling
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式
- en: 'But, for now, having access to the `*Line` object allows us to play around
    with the styling a bit more. To set the right mood with the rather gloomy nature
    of this chapter, I have chosen a stark black line (in fact, I have grown rather
    fond of the stark black line charts and have started using them in my daily plots
    as well). A point to note is that I did this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，目前，能够访问 `*Line` 对象使我们能够对样式进行更多操作。为了与本章相当忧郁的性质相匹配，我选择了一条纯黑色线条（实际上，我已经相当喜欢纯黑色线条图表，并开始在日常图表中使用它们）。需要注意的是，我这样做：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`l.LineStyle.Color` takes `color.Color`—`color.RGBA` is a struct found in the
    `color` library in the standard library. It''s a struct that has four fields representing
    a color, such as `Red`, `Green`, `Blue`, and `Alpha`. Here I take advantage of
    Go''s default values—0s. But having an `Alpha` value of `0` would mean that it''s
    invisible. Hence, I only set the `A` field to `255`—the rest of the fields are
    defaulted to `0`, which gives it a stark black color.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`l.LineStyle.Color` 接受 `color.Color`——`color.RGBA` 是标准库中 `color` 库中的一个结构体。它是一个包含四个字段的表示颜色的结构体，例如
    `Red`、`Green`、`Blue` 和 `Alpha`。在这里，我利用了 Go 的默认值——0s。但是，`Alpha` 值为 `0` 意味着它是不可见的。因此，我只将
    `A` 字段设置为 `255`——其余字段默认为 `0`，这使得它呈现为纯黑色。'
- en: After we set the line style, we add the line to the plot with `p.Add(l)`. Because
    we're not using `plotutil.AddLines`, which abstracts away some of the manual work,
    we may find that if we run the function there isn't a legend in the plot. A plot
    without legends is generally useless. So, we also need to add a legend by using
    `p.Legend.Add(seriesName, l)`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置线条样式后，我们使用 `p.Add(l)` 将线条添加到图中。因为我们没有使用 `plotutil.AddLines`，它抽象了一些手动工作，所以我们可能会发现如果我们运行该函数，图中没有图例。没有图例的图通常是没有用的。因此，我们还需要使用
    `p.Legend.Add(seriesName, l)` 添加图例。
- en: Aside from color, width, and the like, I also want to set a more brutal feel
    to the plots I make for this chapter—after all, this chapter is rather doom and
    gloom. I feel that the default font, which is Times New Roman is a little too
    humanist. So, we'd need to change fonts. Luckily, the extended Go standard library
    comes with a font-processing library. While usually I'd choose to go with slab
    serif style fonts for the brutal look, Go itself comes with a font that works
    well—the Go family of fonts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了颜色、宽度和类似之外，我还想为本章制作的图表添加一种更粗犷的感觉——毕竟，本章相当悲观。我觉得默认字体 Times New Roman 稍显人文主义。因此，我们需要更改字体。幸运的是，扩展的
    Go 标准库附带了一个字体处理库。虽然通常我会选择使用粗衬线字体来实现粗犷的外观，但 Go 本身就附带了一个效果很好的字体——Go 字体家族。
- en: How do we change fonts in a `*plot.Plot`? Most components of `*plot.Plot` take
    a `draw.TextStyle`, which is a data structure that configures the styling of text,
    including fonts. So, we can set those fields to indicate we want to use the font
    we chose.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在 `*plot.Plot` 中更改字体？`*plot.Plot` 的大多数组件都接受一个 `draw.TextStyle`，这是一个配置文本样式的数据结构，包括字体。因此，我们可以设置这些字段来表示我们想要使用我们选择的字体。
- en: 'As I mentioned, in the extended standard library, Go comes with fonts and font-processing
    utilities. We''ll be using it here. First, we''d have to install the packages:
    `go get -u golang.org/x/image/font/gofont/gomono` and `go get -u github.com/golang/freetype/truetype`.
    The former is the official **Monospace Type** of the Go family of typefaces. The
    latter is a library to handle TrueType fonts.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，在扩展的标准库中，Go 附带了字体和字体处理工具。我们在这里将使用它。首先，我们必须安装以下包：`go get -u golang.org/x/image/font/gofont/gomono`
    和 `go get -u github.com/golang/freetype/truetype`。前者是 Go 字体家族的官方 **等宽字体**。后者是一个用于处理
    TrueType 字体的库。
- en: Here, a caveat must be mentioned—while `draw.TextStyle` does allow for the configuration
    of fonts, the fonts are in a `vg.Font` type, which wraps a `*truetype.Font` type.
    If we use `truetype.Parse(gomono.TTF)`, we will get `*truetype.Font`. The `vg` package
    provides a function to make those fonts—`vg.MakeFont`. The reason why this is
    necessary instead of just using `*truetype.Font` is because `vg` has plenty of
    backends—some that could render fonts would require information about the font
    size.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里必须提到一个注意事项——虽然`draw.TextStyle`允许配置字体，但字体是`vg.Font`类型，它封装了一个`*truetype.Font`类型。如果我们使用`truetype.Parse(gomono.TTF)`，我们将得到`*truetype.Font`。`vg`包提供了一个创建这些字体的函数——`vg.MakeFont`。之所以需要这样做而不是仅仅使用`*truetype.Font`，是因为`vg`有很多后端——其中一些渲染字体可能需要字体大小信息。
- en: 'So, to avoid having many calls to parse the font and making a `vg.Font` type,
    we can safely put it in a global variable, given we''ve already decided ahead
    that all fonts will be of the same brutal style:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了避免多次调用解析字体并创建`vg.Font`类型，我们可以安全地将它放在一个全局变量中，前提是我们已经提前决定所有字体都将采用相同的粗犷风格：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once that''s done, we can set all `draw.TextStyle.Font` to be `defaultFont`.
    Setting a default font size of 12 does not, however, mean that you''re stuck with
    the size for everything. Because `vg.Font` is a struct, not a pointer to a struct,
    once set in an object, you are free to change the font size of that particular
    field, as I have shown in the following two lines:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以将所有`draw.TextStyle.Font`设置为`defaultFont`。然而，将默认字体大小设置为12并不意味着你将固定使用这个大小。因为`vg.Font`是一个结构体，而不是结构体的指针，一旦在一个对象中设置，你就可以自由地更改该特定字段的字体大小，就像我在以下两行中展示的那样：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With our `main` function we can execute the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`main`函数，我们可以执行以下代码：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result is stark , as shown in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 结果非常明显，如下面的截图所示：
- en: '![](img/18f0f7aa-e074-4ee2-a7d5-df9335a9c668.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18f0f7aa-e074-4ee2-a7d5-df9335a9c668.png)'
- en: Decomposition
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解
- en: 'There are two things to note about the previous screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的截图，有两点需要注意：
- en: CO[2] levels in the air are steadily rising over time.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空气中的二氧化碳水平随着时间的推移稳步上升。
- en: There are dips and then bumps in the levels of CO[2], but the result still ends
    up rising overall. These dips and bumps happen on a regular pattern.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二氧化碳水平有起伏，但结果最终还是上升。这些起伏发生在有规律的图案中。
- en: The first point is what is known to statisticians as a **trend**. You may already
    be familiar with the notion of a Trend Line from Microsoft Excel. A trend is a
    kind of pattern that describes gradual change over time. In our case, it is quite
    clear that the trend is upward.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点是统计学家所熟知的**趋势**。你可能已经熟悉了来自Microsoft Excel的趋势线的概念。趋势是一种描述随时间逐渐变化的模式。在我们的例子中，很明显趋势是向上的。
- en: 'The second point is called **seasonality**—for very apt reasons, as it may
    turn out. Seasonality describes the pattern of variance that happens regularly.
    If you carefully look at the chart, typically at around August to October of each
    year, the CO[2] levels drop to the lowest point of the year. After which, they
    rise steadily again until around May, where they peak. Here''s a good hint as
    to why this happens: plants suck CO[2] from the air through a process called **photosynthesis**.
    Photosynthesis requires a organelle in a plant''s cell called a **chloroplast**,
    which contains a green pigment called **chlorophyll**. If you live in the Northern
    Hemisphere, you would be well aware that trees are greenest from Spring till Autumn.
    This largely coincides with the period from May till October. The changing of
    seasons cause a change in atmospheric carbon dioxide levels. You can certainly
    see why the term "seasonality" is quite apt.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点被称为**季节性**——非常恰当，因为它可能就是这样。季节性描述的是定期发生的方差模式。如果你仔细观察图表，通常在每年的8月到10月，二氧化碳水平降至全年的最低点。之后，它们又稳步上升，直到大约5月达到峰值。以下是一个关于为什么会发生这种情况的好提示：植物通过光合作用从空气中吸收二氧化碳。光合作用需要植物细胞中的一个称为叶绿体的细胞器，其中含有一种名为叶绿素的绿色色素。如果你生活在北半球，你一定会知道树木从春天到秋天都是绿色的。这很大程度上与5月到10月的时期相吻合。季节的变化导致大气二氧化碳水平的变化。你当然可以理解为什么“季节性”这个术语非常恰当。
- en: 'A good question to ask  might be this: Can we separate the trend out from the
    seasonality so that we may be able to work on each component individually? The
    answer is yes, we can. In fact, in the remaining parts of this section, I''ll
    show how to do so.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得提出的问题可能是这样的：我们能否将趋势与季节性分开，以便我们能够单独处理每个组成部分？答案是肯定的。事实上，在本节的剩余部分，我将展示如何做到这一点。
- en: Now, as to why you would want to do that, well, in our project so far, we've
    seen seasonalities that are affected by real-life calendar seasons. Imagine you
    were doing statistical analysis for a toy company in a Western country. You'd
    see a yearly spike around Christmas time. Often seasonality adds noise to our
    analysis—it's hard to tell whether a bump in sales was due to Christmas time or
    an actual increase in sales. Furthermore, there are some cycles that don't necessarily
    follow the calendar year. If you are dealing with sales in a largely Chinese/Vietnamese
    community, you'd see spikes in sales before Chinese New Year/Tet. Those do not
    follow our calendar year. Ditto, if you were in the dates industry—you'd see spikes
    around Ramadan as demand for dates increases sharply during the Muslim fasting
    period.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，至于为什么你想做那件事，嗯，在我们迄今为止的项目中，我们已经看到了受现实生活日历季节影响的季节性。想象一下，如果你在为一家西方国家的玩具公司做统计分析。你会在圣诞节期间看到年销售高峰。通常，季节性会给我们的分析增加噪声——很难判断销售增长是由于圣诞节还是实际的销售增长。此外，还有一些周期并不一定遵循日历年。如果你在主要面向中国/越南社区的销售中处理销售，你会在春节/越南新年之前看到销售高峰。这些并不遵循我们的日历年。同样，如果你在日期行业——你会在斋月期间看到销售高峰，因为穆斯林斋戒期间对日期的需求急剧增加。
- en: While it's true that most time series would have some kind of trend and seasonality
    component, it would be remiss for me to mention that not all trends and seasonalities
    are particularly useful. You might be tempted to take what you learn in this chapter
    and apply it on the stock markets but buyer beware! Analyzing complex market places
    is quite different from analyzing trends of CO[2] in the air or sales from a business.
    The fundamental properties of time series in markets are somewhat different—it's
    a process that has the Markov property, which is best described as **past performance
    does not indicate future performance**. By contrast, we shall see, for this project,
    that the past is quite well correlated with the present and the future.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数时间序列都会有一些趋势和季节性成分，但我提到并非所有趋势和季节性都特别有用。你可能想将本章学到的知识应用到股票市场上，但请注意！分析复杂的市场与分析空气中CO[2]的趋势或企业的销售情况是不同的。市场时间序列的基本属性有所不同——它是一个具有马尔可夫性质的进程，这最好描述为**过去的表现并不预示未来的表现**。相比之下，我们将看到，在这个项目中，过去与现在和未来有很好的相关性。
- en: 'But back to the topic at hand—decomposition. If you read the comments on the
    data file (the lines we skipped from importing), the following is mentioned:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但回到我们的话题——分解。如果你阅读数据文件上的注释（我们跳过的导入行），以下内容被提及：
- en: '"First, we compute for each month the average seasonal cycle in a 7-year window
    around each monthly value. In this way, the seasonal cycle is allowed to change
    slowly over time. We then determine the "trend" value for each month by removing
    the seasonal cycle; this result is shown in the "trend" column."'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '"首先，我们为每个月计算一个围绕每月值的7年窗口内的平均季节周期。这样，季节周期可以随着时间的推移缓慢变化。然后，通过去除季节周期，我们确定每个月的“趋势”值；这个结果在“趋势”列中显示。"'
- en: STL
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL
- en: But how does one calculate a seasonal cycle? In this section, we'll be using
    an algorithm invented in the late 1980s called **Seasonal and Trend Decomposition** (**STL**)
    by LOESS by Cleveland et al. I wrote a library that implements that. You can install
    it by running `go get -u github.com/chewxy/stl`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但如何计算季节周期呢？在本节中，我们将使用1980年代末发明的一种算法，称为由Cleveland等人发明的**季节和趋势分解**（**STL**）算法，它被称为LOESS。我编写了一个实现该算法的库。你可以通过运行`go
    get -u github.com/chewxy/stl`来安装它。
- en: The library is really small—there is only one `main` function to call (`stl.Dcompose`),
    and the library comes with a litany of features to aid with decomposition of data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库实际上非常小巧——只有一个需要调用的`main`函数（`stl.Dcompose`），并且库中包含了一系列辅助数据分解的功能。
- en: Despite that, I think it would be a good idea to have a rough understanding
    of the STL algorithm before using it, as usage requires knowledge.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我认为在使用它之前对STL算法有一个大致的了解是个好主意，因为使用它需要相关知识。
- en: LOESS
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LOESS
- en: The thing that powers STL is the notion of local regression—LOESS itself is
    a terrible acronym formed from **LO**cal regr**ESS**ion—whatever drugs the statisticians
    were on in the 1990s, sign me up for them. We're already familiar with the idea
    of linear regression from [Chapter 1](3d68e167-a44d-4195-a270-f8180ff8f85f.xhtml),
    *How to Solve All Machine Learning*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的动力来源于局部回归的概念——LOESS 本身是一个糟糕的缩写，由 **LO**cal regr**ESS**ion 组成——不管统计学家在20世纪90年代吸了什么药，我愿意加入他们。我们已经从[第1章](3d68e167-a44d-4195-a270-f8180ff8f85f.xhtml)，*如何解决所有机器学习问题*中熟悉了线性回归的概念。
- en: 'Recall that the role of linear regression is that given a straight line function: ![](img/f064c2e5-f70b-4a80-a051-c6cee555629e.png).
    We want to estimate ![](img/44aac8a5-8a88-4adf-8423-9f978c3c58b9.png) and ![](img/7a3e53ed-c83b-448e-8ec3-50662b599ee7.png).
    Instead of trying to fit the whole dataset at once, what if we broke the dataset
    up into many small **local** components, and ran a regression on each small dataset?
    Here''s an example of what I mean:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，线性回归的作用是给定一个直线函数： ![](img/f064c2e5-f70b-4a80-a051-c6cee555629e.png)。我们想要估计 ![](img/44aac8a5-8a88-4adf-8423-9f978c3c58b9.png) 和 ![](img/7a3e53ed-c83b-448e-8ec3-50662b599ee7.png)。与其试图一次性拟合整个数据集，为什么不将数据集分成许多小的**局部**组件，并对每个小数据集进行回归分析呢？以下是我想要表达的一个例子：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding table is a function representing ![](img/dd55f36b-8373-4801-819c-016180524f17.png).
    Instead of pulling in the entire dataset for a regression, what if we did a running
    regression of every three rows? We''d start with row 2 (x = -0.9). And the data
    points under consideration are `1` before it and `1` after it (*x = -1* and *x
    = -0.8*). And for row 3, we''d do a linear regression using row `2`, `3`, `4`
    as data points. At this point, we''re not particularly interested in the errors
    of the local regression. We just want an estimate of the gradient and the crossings.
    Here''s the resulting table:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格是一个表示 ![](img/dd55f36b-8373-4801-819c-016180524f17.png) 的函数。在回归分析中，我们通常需要拉入整个数据集，但如果我们每三行进行一次运行回归分析会怎样呢？我们从第2行（x
    = -0.9）开始。考虑的数据点是它之前的`1`和它之后的`1`（*x = -1* 和 *x = -0.8*）。对于第3行，我们将使用第`2`、`3`、`4`行作为数据点进行线性回归。在这个阶段，我们并不特别关注局部回归的错误。我们只想估计梯度交叉。下面是得到的结果表：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In fact, we can show that if you plot each line individually, you will have
    a somewhat "curved" shape. So, here''s a side program I wrote to plot this out:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以证明，如果你单独绘制每条线，你会得到一个有点“弯曲”的形状。所以，这里有一个我编写的辅助程序来绘制这个图表：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we will see how to plot the original function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到如何绘制原始函数：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code yields a chart, as shown in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成了一个图表，如下面的截图所示：
- en: '![](img/c8f5286c-098a-47da-adde-0df30cd3c54b.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8f5286c-098a-47da-adde-0df30cd3c54b.png)'
- en: Most of the code will be explained in the latter parts of this chapter, but,
    for now, let's focus on the fact that you can indeed run many small linear regressions
    on "local" subsets of the data to plot a curve.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码将在本章的后半部分进行解释，但，现在让我们专注于这样一个事实：你确实可以在数据的“局部”子集上运行许多小的线性回归来绘制曲线。
- en: 'LOESS brings this idea further, by stating that if you have a window of values
    (in the toy example, we used `3`), then the values should be weighted. The logic
    is simple: the closer a value is to the row in consideration, the higher the weight.
    If we had used a window size of `5`, then when considering row `3`, `2`, and `4`
    would be weighted more heavily than rows `1` and `5`. This **width**, it turns
    out, is important to our smoothing.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: LOESS 通过指出，如果你有一个值窗口（在玩具示例中，我们使用了`3`），那么这些值应该被加权。逻辑很简单：一个值离考虑的行越近，其权重就越高。如果我们使用了`5`的窗口大小，那么在考虑第`3`行时，`2`和`4`行会比`1`和`5`行有更高的权重。这个**宽度**，结果证明，对我们平滑处理很重要。
- en: The subpackage, `"github.com/chewxy/stl/loess"`, implements LOESS as a smoothing
    algorithm. Do read through the code if you're interested in knowing more about
    the details.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 子包 `"github.com/chewxy/stl/loess"` 实现了 LOESS 作为平滑算法。如果你对了解更多细节感兴趣，请阅读代码。
- en: The algorithm
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法
- en: Recall that our goal is to split a time series into seasonality and trend. Obviously,
    once we've removed the seasonality and trend, there will be some remaining parts.
    We call those **residuals**. So, how do we do it?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们的目标是把时间序列分解成季节性和趋势。显然，一旦我们移除了季节性和趋势，就会有一些剩余的部分。我们把这些称为**残差**。那么，我们该如何做呢？
- en: The algorithm has a lot of fine tuning for the sake of robustness. I will elide
    on explaining on the various robustness optimizations performed, but I think it
    is important to have a rough idea of how the algorithm works in general.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 算法有很多微调是为了提高鲁棒性。我将省略对各种鲁棒性优化进行的解释，但我认为了解算法在一般情况下是如何工作的有一个大致的概念是很重要的。
- en: 'The following is a rough overview of the algorithm:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对算法的简要概述：
- en: Calculate trend (on the first loop, the trend is all 0s).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算趋势（在第一次循环中，趋势全是0）。
- en: Subtract the trend from the input data. This is called **detrending**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入数据中减去趋势。这被称为**去趋势**。
- en: 'Cycle subseries smoothing: the data is partitioned into `N` subcycles. Each
    subcycle corresponds to a period. The data is then smoothed using LOESS. The result
    is a temporary seasonal dataset.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环子序列平滑：数据被划分为`N`个子周期。每个子周期对应一个周期。然后使用LOESS对数据进行平滑处理。结果是临时的季节性数据集。
- en: For each temporary seasonal dataset (one per period), we perform a low pass
    filter—we keep the values with a low frequency.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个临时的季节性数据集（每个周期一个），我们执行低通滤波——我们保留低频值。
- en: The low pass filtered values are subtracted from temporary seasonal dataset.
    This is the seasonal data.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 低通滤波后的值从临时季节性数据集中减去。这就是季节性数据。
- en: Subtract the seasonal data from the input data. This is the new trend data.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入数据中减去季节性数据。这就是新的趋势数据。
- en: Iterate step 1 to step 6 until the number of iterations is desired. This is
    typically 1 or 2.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代步骤1到步骤6，直到达到所需的迭代次数。这通常是1或2。
- en: As you can see, the algorithm is iterative—each iteration improves on the trend,
    which is then used to find the new seasonal data, which is then used to update
    the trend, and so on and so forth. But there is a very important blink-and-you-miss-it
    "magic" that STL relies on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，算法是迭代的——每次迭代都会改进趋势，然后使用改进后的趋势来找到新的季节性数据，然后使用新的季节性数据来更新趋势，如此循环。但STL依赖于一个非常重要且容易被忽视的“魔法”。
- en: 'And so we come to the second important reason to understand the algorithm:
    **STL is dependent upon the definition of how many periods the dataset has**.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们来到理解算法的第二个重要原因：**STL依赖于数据集周期的定义**。
- en: Using STL
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用STL
- en: 'To recap, there are two important parts that are fundamental to the STL algorithm:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，STL算法有两个基本的重要部分：
- en: The **width** used for smoothing
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于平滑的**宽度**
- en: The **periods** in the dataset
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据集中的**周期数**
- en: When we look at the CO[2] dataset, we can count the periods by counting the
    number of peaks in the chart. I counted 60 peaks. This corresponds to the fact
    that the observatory has been collecting data for the past 60 years.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看CO[2]数据集时，我们可以通过计数图表中的峰值来计算周期数。我数了60个峰值。这对应于观测站过去60年一直在收集数据的事实。
- en: From here, we move from the hard sciences of statistics into the softer realms
    of interpretation. This is often true in data science and machine learning—we
    often have to use our intuition to guide us.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们从统计学的硬科学领域转向了更软的解释领域。这在数据科学和机器学习中通常是正确的——我们经常需要依靠直觉来引导我们。
- en: 'In this case, we have a hard starting point: there has been 60 years so we
    expect at least 60 periods. Another starting point can be found in the notes of
    the dataset itself: the NOAA uses a seven-year window to calculate the seasonal
    component. I don''t see any reason to not use those values. So, let''s decompose
    our time series into the **trend**, **seasonal**, and **residual** components.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个明确的起点：已经过去了60年，所以我们预计至少有60个周期。另一个起点可以在数据集本身的注释中找到：NOAA使用7年窗口来计算季节性成分。我看不出不使用这些值的原因。所以，让我们将我们的时间序列分解为**趋势**、**季节性**和**残差**成分。
- en: 'But before we begin, there is an additional note to make: we want to decompose
    the time series into three components, but how do these three components recompose
    to become whole again? In general, there are two methods: additive or multiplicative.
    Simply put, we can decompose the data as either one of the following equations:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们开始之前，还有一个额外的注意事项：我们希望将时间序列分解为三个组成部分，但这三个组成部分如何重新组合成整体呢？一般来说，有两种方法：加法或乘法。简单来说，我们可以将数据分解为以下方程之一：
- en: '![](img/401f677e-a121-48ed-89e2-b6fb91b10c77.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/401f677e-a121-48ed-89e2-b6fb91b10c77.png)'
- en: 'This can also be stated as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以表述如下：
- en: '![](img/4f5383b7-4228-4077-87d3-c6448772a58a.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f5383b7-4228-4077-87d3-c6448772a58a.png)'
- en: The `github.com/chewxy/stl` package supports both models, and even supports
    custom models that fall "in-between" additive and multiplicative models.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/chewxy/stl`包支持这两种模型，甚至支持介于加性和乘性模型之间的自定义模型。'
- en: '**When to use an additive model**: Use an additive model when the seasonality
    does not vary with the level of the time series. Most standard business case time
    series fall in this category.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用加性模型**：当季节性不随时间序列的水平变化时使用加性模型。大多数标准商业案例时间序列都属于这一类。'
- en: '**When to use a multiplicative model**: Use a multiplicative model when the
    seasonality or trend does vary with the level of the time series. Most econometric
    models fall in this category.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用乘性模型**：当季节性或趋势随时间序列的水平变化时使用乘性模型。大多数计量经济学模型都属于这一类。'
- en: 'For the purpose of this project, we will be using an additive model. Here''s
    the `main` function again:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个项目的目的，我们将使用一个加性模型。再次展示`main`函数：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s break this down; in particular, the parameters:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下；特别是参数：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Take a look at the following terms from the preceding code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面代码中的以下术语：
- en: '`12`: We counted 60 periods. The data is monthly data; therefore, it would
    make sense that a period takes 12 months, or as we know it—a year.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`12`：我们计算了60个周期。数据是月度数据；因此，一个周期为12个月，或者说我们知道的——一年。'
- en: '`84`: We use the smoothing window as specified by the NOAA. Seven years is
    84 months.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`84`：我们使用NOAA指定的平滑窗口。七年是84个月。'
- en: '`stl.Additive()`: We want to use an additive model.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stl.Additive()`: 我们希望使用一个加性模型。'
- en: '`stl.WithIter(1)`: STL is fairly sensitive to the number of iterations run.
    The default is `2`. But if you run it too many times, everything gets iteratively
    "smoothed" out. So, instead, we stick with `1`.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stl.WithIter(1)`: STL对迭代次数相当敏感。默认值是`2`。但是如果你运行次数太多，所有东西都会被迭代地“平滑”掉。所以，我们坚持使用`1`。'
- en: In the following sections, I'll show examples of misuse and why despite everything, 1
    and 2 are still pretty good iteration counts.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我将展示误用的例子以及尽管如此，1和2仍然相当好的迭代次数的原因。
- en: You may note that instead of specifying the number of periods, we specified
    the length of a period. The package expects the data to be evenly spaced—the distance
    between any two rows should be the same.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，我们不是指定周期的数量，而是指定了周期的长度。该包期望数据是均匀分布的——任意两行之间的距离应该是相同的。
- en: 'Running this yields the following plot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个操作会得到以下图表：
- en: '![](img/2d3062fd-419f-4ef8-b71b-3bf621deb3c4.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/2d3062fd-419f-4ef8-b71b-3bf621deb3c4.png)'
- en: The first chart is the original data, followed by the extracted trend and seasonality,
    and, finally, the residuals. There remains some weirdness with regards to the
    beginning of the graph, but that artifact is solely due to the fact that the `github.com/chewxy/stl`
    library does not "backcast". Hence, it's always a good idea to start with at least
    one extra period.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一张图是原始数据，然后是提取的趋势和季节性，最后是残差。关于图表的开始部分还有一些奇怪的地方，但这只是一个事实，即`github.com/chewxy/stl`库不进行“回溯”。因此，始终至少从一个额外的周期开始是一个好主意。
- en: How to interpret the plot? Well, since this is an additive model, interpretation
    is a lot simpler—the `Y` values indicate the ppm of carbon dioxide in the air
    that each component contributes to the actual data, so the first chart is literally
    the result of adding the bottom charts together.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如何解释这个图？嗯，由于这是一个加性模型，解释起来要简单得多——`Y`值表示每个组成部分对实际数据中空气中二氧化碳ppm的贡献，所以第一张图实际上是将底部图表相加的结果。
- en: How to lie with statistics
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何用统计数据撒谎
- en: It is important to note that these parameters essentially control how much to
    attribute the CO[2] in the atmosphere to each component. And these controls are
    rather subjective. The `stl` package offers a lot of control over how a time series
    is decomposed, and I think it's up to the data scientist or statistician reading
    this book (that is you), to do statistics responsibly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这些参数实际上控制了将大气中的CO[2]归因于每个成分的程度。这些控制相当主观。`stl`包提供了大量关于如何分解时间序列的控制，我认为这取决于阅读这本书的数据科学家或统计学家（也就是你），要负责任地进行统计分析。
- en: 'What if we said that a period was five years? Keeping everything the same,
    we can use the following code and find out:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们说一个周期是五年呢？保持一切不变，我们可以使用以下代码来找出：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following chart is produced:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是生成的：
- en: '![](img/5158c053-0d20-4eba-b007-5635417914cb.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/5158c053-0d20-4eba-b007-5635417914cb.png)'
- en: We could then take this chart and parade the top two sections and say "Look!
    Statistics tells us that despite the data looking like it's going up, it's in
    fact trending down. Hashtag science."
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以拿这张图展示前两部分，并说：“看！统计数据告诉我们，尽管数据看起来在上升，但实际上是在下降。#科学。”
- en: You're of course free to do so. But I know you're not a dishonest person. Instead,
    I hope that you are reading this book with good intentions of saving the world.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以这样做。但我知道你不是个不诚实的人。相反，我希望你阅读这本书是出于拯救世界的良好意图。
- en: 'But knowing the correct parameters to use is difficult. One suggestion I have
    is to go to extremes and then come back down. This is what I mean—we have a rough
    idea of how the STL algorithm works. A known controlling factor is the iteration
    count, which defaults to 2\. Here''s the original correct version, with 1, 2,
    5, 10, 20, and 100 iterations:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但知道使用正确的参数是困难的。我有一个建议，那就是走极端，然后再回来。我的意思是——我们有一个大致的想法，STL算法是如何工作的。一个已知的控制因素是迭代次数，默认为2。以下是原始的正确版本，包含1、2、5、10、20和100次迭代：
- en: '![](img/28ab26b1-2529-420e-9616-f6bff601de06.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片6](img/28ab26b1-2529-420e-9616-f6bff601de06.png)'
- en: 'Interations:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代：
- en: '![](img/196427d7-6a3c-4edd-ad52-c7a2480c6d19.png)![](img/3d4a4d29-ea3e-49db-b06d-037c6b16b5f3.png)![](img/119460c2-8b34-4580-86e1-7140ad61bf0a.png)![](img/f7f12afb-c01f-4777-b99d-2213193305b1.png)![](img/c52bcaa6-f1f1-42f8-913a-b3c5b8529520.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/196427d7-6a3c-4edd-ad52-c7a2480c6d19.png)![图片2](img/3d4a4d29-ea3e-49db-b06d-037c6b16b5f3.png)![图片3](img/119460c2-8b34-4580-86e1-7140ad61bf0a.png)![图片4](img/f7f12afb-c01f-4777-b99d-2213193305b1.png)![图片5](img/c52bcaa6-f1f1-42f8-913a-b3c5b8529520.png)'
- en: Over the iterations, having been smoothed iteratively, the seasonality loses
    its jaggedness. Nonetheless, the shape of the trend stays the same. Therefore,
    in this case, increasing the iteration counts merely shifts the seasonal contribution
    to the trend component. This implies that the trend component is the stronger
    "signal" of sorts.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代过程中，经过迭代平滑后，季节性失去了其锯齿状。尽管如此，趋势的形状保持不变。因此，在这种情况下，增加迭代次数只是将季节性贡献转移到趋势成分上。这表明趋势成分是更强的“信号”类型。
- en: By contrast, if we run the "lies" version, we see that at two iterations, the
    shape of the trend changes, and by the 10th iteration onward, the shape of the
    trend stays the same. This gives us a clue as to what the "real" trend is.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果我们运行“谎言”版本，我们会看到在两次迭代后，趋势的形状发生了变化，从第10次迭代开始，趋势的形状保持不变。这给我们提供了一个关于“真实”趋势的线索。
- en: With STL, the thing that we're really controlling is the seasonality. What we're
    saying to the algorithm is that we believe that a period is 12 months; therefore,
    please find a seasonality that fits. If we say to the algorithm that we believe
    that a period is five years (60 months), the algorithm will try its best to find
    a seasonality and trend that fits that pattern.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在STL中，我们真正控制的是季节性。我们告诉算法的是，我们相信周期是12个月；因此，请找到一个符合这个周期的季节性。如果我们告诉算法我们相信周期是五年（60个月），算法将尽力找到一个符合这个模式的季节性和趋势。
- en: I wish to be clear—the notion of a seasonality that happens every five years
    is **not wrong**. In fact, it is common for business-related forecasting to work
    on multiple levels of seasonalities. But knowing how many iterations to run, that
    comes with experience and wisdom.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望明确——每五年发生一次的季节性概念**并不错误**。事实上，在商业相关的预测中，在多个季节性层面上工作是很常见的。但知道运行多少次迭代，这需要经验和智慧。
- en: Check the units! If the units don't make sense, like in the "lies" chart, then
    it probably isn't real.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 检查单位！如果单位没有意义，就像在“谎言”图表中那样，那么它可能不是真实的。
- en: More plotting
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多绘图
- en: A major theme in this chapter other than time series analysis is plotting. You
    may have also noticed a few new functions in the `main` function earlier. Now
    it's time to revisit them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本章除了时间序列分析之外的一个主要主题是绘图。你可能也注意到了`main`函数中的一些新函数。现在是我们回顾它们的时候了。
- en: 'We start with the output of `stl.Decompose`. This is the definition:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`stl.Decompose`的输出开始。这是定义：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is no notion of time in the result. It's assumed that when you pass in
    data into `stl.Decompose`, the data is ordered by the time series. The result
    also follows this notion.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结果中没有时间的概念。假设当你将数据传递给`stl.Decompose`时，数据是按时间序列排序的。结果也遵循这个概念。
- en: We've already defined `newTSPlot` previously, which works fine for the data,
    trend, and seasonal, but not the residuals. The reason why we don't want to plot
    residuals as a line chart is because if done right, the residuals should be more
    or less random. Having a line plot run through random points would be rather messy.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经定义了`newTSPlot`，它对于数据、趋势和季节性来说工作得很好，但对于残差来说则不行。我们不希望将残差作为折线图绘制的原因是，如果做得正确，残差应该基本上是随机的。让一条折线穿过随机点将会相当混乱。
- en: Typical residual plots are simply scatter plots of the residuals. However, that
    too is relatively uninterpretable when squashed into a multiplot image.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的残差图仅仅是残差的散点图。然而，当挤压到多图图像中时，这也相对难以解释。
- en: Instead, we want to draw a straight vertical line for each residual value.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们想要为每个残差值绘制一条垂直的直线。
- en: 'To recap, this is what we want to do:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，这是我们想要做的事情：
- en: Plot a time series chart for each of `Data`, `Trend`, and `Seasonal`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Data`、`Trend`和`Seasonal`中的每一个绘制时间序列图表。
- en: Plot a residuals chart for `Resid`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Resid`绘制残差图表。
- en: Combine all the preceding plots into one image.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有前面的图表合并到一个图像中。
- en: Step 1 is easy, as we simply call `newTSPlot` with the parsed dates from earlier
    for each of the components. Step 2 is a little trickier. Gonum doesn't have the
    residuals plots that we want by default.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步很简单，因为我们只需使用之前解析的日期为每个组件调用`newTSPlot`。第二步稍微有些棘手。Gonum默认并没有我们想要的残差图。
- en: 'To plot it, we''d need to create a new `plot.Plotter` interface. Here''s the
    definition:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制它，我们需要创建一个新的`plot.Plotter`接口。以下是定义：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Despite the fact that Gonum doesn't have the chart type that we want, as you
    can see it doesn't take very many lines of code for us to define our own chart
    type. This is part of the power of Gonum's `plot` library—it's abstract enough
    to enable you to write your own chart type, and at the same time, it provides
    all the helper functions necessary to make it work without much code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Gonum没有我们想要的图表类型，但正如你所见，我们定义自己的图表类型并不需要很多代码。这是Gonum的`plot`库的一部分力量——它足够抽象，允许你编写自己的图表类型，同时它还提供了所有必要的辅助函数，以便用很少的代码使其工作。
- en: A primer on Gonum plots
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gonum绘图入门
- en: Before we go further, I think it might be worth it to have an understanding
    of Gonum's plotting library in general. We've so far been using Gonum's `plot` library
    in rather ad hoc ways. This was to familiarize you with how to use the library.
    Now that you're somewhat familiar, it's time to learn more about the internals
    in order to plot better in the future.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步深入之前，我认为了解Gonum的绘图库总体情况可能是有益的。到目前为止，我们一直在以相当随意的的方式使用Gonum的`plot`库。这是为了让你熟悉如何使用这个库。现在你已经有些熟悉了，是时候学习更多关于其内部结构的知识，以便未来能更好地进行绘图。
- en: 'A `*plot.Plot` object holds the metadata of a plot. A plot consists of the
    following features:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`*plot.Plot`对象包含图表的元数据。一个图表由以下特性组成：
- en: A title
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标题
- en: '`X` and `Y` axes'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X`和`Y`轴'
- en: A legend
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个图例
- en: A list of `plot.Plotter`
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plot.Plotter`列表'
- en: 'A `plot.Plotter` interface is simply anything that can take a `*plot.Plot` object
    and draw it on to `draw.Canvas`, defined as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot.Plotter`接口简单地说就是任何可以接受一个`*plot.Plot`对象并将其绘制到`draw.Canvas`（如下定义）上的东西：'
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By separating the notions of a `plot` object and the canvas upon which the plot
    will be drawn, this opens Gonum's plots to a variety of different plotting backend
    options. To see what I mean about backend options, we need to take a closer look
    at `draw.Canvas`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`plot`对象和绘图将要在其上绘制的画布的概念分开，这为Gonum的图表打开了各种不同的绘图后端选项。为了了解我所说的后端选项，我们需要更仔细地看看`draw.Canvas`。
- en: 'The `draw.Canvas` is a tuple of `vg.Canvas` and `vg.Rectangle`. So what exactly
    is `vg`? `vg`, it turns out, stands for **vector graphics**. In it, the `Canvas` type
    is defined as an interface with a bunch of methods. This allows for the rich variety
    of backends that `vg` has:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw.Canvas`是一个`vg.Canvas`和`vg.Rectangle`的元组。那么`vg`究竟是什么呢？`vg`实际上代表**矢量图形**。在其中，`Canvas`类型被定义为一个具有许多方法的接口。这允许`vg`拥有丰富的后端选项：'
- en: '`vg/vgimg`: This is the primary package we''ve been using so far; it writes
    to an image file.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vg/vgimg`：这是我们迄今为止主要使用的包；它将数据写入图像文件。'
- en: '`vg/vgpdf`: This package writes to a PDF file.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vg/vgpdf`：这个包将数据写入PDF文件。'
- en: '`vg/vgsvg`: This package writes to a SVG file.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vg/vgsvg`：这个包将数据写入SVG文件。'
- en: '`vg/vgeps`: This package writes to a EPS file.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vg/vgeps`：这个包将数据写入EPS文件。'
- en: '`vg/vgtex`: This package writes to a TEX file.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vg/vgtex`：这个包将数据写入TEX文件。'
- en: Each of these canvas implementations has a coordinate system that begins with
    (0, 0) at the bottom left.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些画布实现中的每一个都有一个以 (0, 0) 为左下角的坐标系。
- en: The residuals plotter
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 残差绘图器
- en: A deeper look at the canvasing system will be explored later in the chapter.
    For now, let's return to the `Plot` method that satisfies the `plot.Plotter` interface.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分将更深入地探讨画布系统。现在，让我们回到满足 `plot.Plotter` 接口的 `Plot` 方法。
- en: 'Most interesting are the following lines:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的是以下几行：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`p.Transforms(&c)` returns two functions, which will transform the coordinate
    of our data point to the coordinate of the backend. This way we wouldn''t have
    to worry about the absolute location of each point. Instead, it will be treated
    in relation to the absolute location in the final image.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`p.Transforms(&c)` 返回两个函数，这些函数将我们的数据点的坐标转换到后端的坐标。这样我们就不必担心每个点的绝对位置。相反，它将与最终图像中的绝对位置相关联。'
- en: Having gotten the transformation functions, we then loop through the residuals
    that we have, and transform each to the coordinate (`x := trX(xy.X)` and `y :=
    trY(xy.Y)`) within the canvas.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 获得变换函数后，我们遍历我们拥有的残差，并将每个转换到画布内的坐标（`x := trX(xy.X)` 和 `y := trY(xy.Y)`）。
- en: 'Finally, we tell the canvas to draw a straight line between two points: (*x*,
    0) and (*x*, *y*). This draws a straight line up or down from the `X` axis.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们告诉画布在两个点之间画一条直线：（*x*，0）和（*x*，*y*）。这将在 `X` 轴上画一条直线向上或向下。
- en: 'Thus, we have created our own `plot.Plotter` interface, which we can now add
    to the `plot` object. But adding to a `*plot.Plot` object directly requires a
    lot of tinkering. So, here''s a function to nicely wrap all that up:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了自己的 `plot.Plotter` 接口，现在我们可以将其添加到 `plot` 对象中。但是直接添加到 `*plot.Plot` 对象需要很多调整。所以，这里有一个函数可以很好地封装所有这些：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function is reminiscent of `newTSPlot`—you provide it the `X` and `Y` values,
    and get a `*plot.Plot` object back out, with everything properly styled and formatted.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数让人联想到 `newTSPlot`——你提供 `X` 和 `Y` 的值，然后得到一个 `*plot.Plot` 对象，其中所有内容都经过适当的样式和格式化。
- en: 'You may note that we''re also adding the plotter object as a legend. To do
    this without an error, the `residChart` type needs to implement `plot.Thumbnailer`.
    Again, that''s fairly straightforward:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们还在添加绘图对象作为图例。为了不出现错误，`residChart` 类型需要实现 `plot.Thumbnailer`。这同样相当直接：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At this point, you may be wondering about the `canvas` object. If we are to
    draw a line between the canvas's minimum `X` to maximum `X`, wouldn't that just
    cause a horizontal line across the entire canvas?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道 `canvas` 对象。如果我们要在画布的最小 `X` 和最大 `X` 之间画一条线，这不是就会在整个画布上画一条水平线吗？
- en: The answer is not really. Recall earlier that the canvas is provided in the
    backend, and `draw.Canvas` is simply a tuple of a canvas backend and a rectangle?
    The rectangle actually serves to subset and constrain the canvas upon which it
    is being drawn.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 答案其实并不是。回想一下，画布是在后端提供的，而 `draw.Canvas` 只是一个包含画布后端和矩形的元组？这个矩形实际上用于在绘制时对画布进行子集化和约束。
- en: We shall see this in action. Now that we've finished, we can turn our attention
    to the next section, which depicts a combination of all the plots into one image.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到它的实际应用。现在我们已经完成，我们可以将注意力转向下一节，它描述了将所有图表组合成一张图像。
- en: Combining plots
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合图表
- en: 'A key function that allows us to do this is the `plot.Align` function. For
    us to see this in action, we need to write a that allows us to plot any number
    of plots to a file, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键函数允许我们做到这一点的是 `plot.Align` 函数。为了让我们看到它的实际应用，我们需要编写一个函数，允许我们将任意数量的图表绘制到一个文件中，如下所示：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We'll skip the part where if `a` is `plot.Plot`, we simply call the `.Save` method.
    Instead, we'll look at the second case, where `a` is `[][]*plot.Plot`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过如果 `a` 是 `plot.Plot`，我们只需调用 `.Save` 方法的部分。相反，我们将查看第二个案例，其中 `a` 是 `[][]*plot.Plot`。
- en: At first this may seem rather strange—why have a slice of slice of plots when
    all we want to do is to combine them in quick succession. The key to understanding
    this is that Gonum supports the tiling of charts so if you want four charts arranged
    in 2x2 fashion, it can be done. Having four charts in a row is simply a special
    case of a 4x1 layout.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 起初这可能会显得有些奇怪——为什么我们要有一个图表的切片的切片，而我们只想快速连续地将它们结合起来。理解这个问题的关键在于，Gonum 支持图表的平铺，所以如果你想要以
    2x2 的方式排列四个图表，这是可以实现的。一行中有四个图表只是 4x1 布局的特殊情况。
- en: 'We can arrange the layouts using a function, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个函数来安排布局，如下所示：
- en: '[PRE26]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Having acquired `[][]*plot.Plot`, we need to tell Gonum the tiling format that
    we''re interested in, so the following code snippet defines the tiling format:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得`[][]*plot.Plot`之后，我们需要告诉Gonum我们感兴趣的镶嵌格式，所以下面的代码片段定义了镶嵌格式：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you're following along with the code, you will realize that `rows` is `3` and
    `cols` is `1`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随代码，你会意识到`rows`是`3`，`cols`是`1`。
- en: 'Next, we have to provide a canvas to draw on:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须提供一个画布来绘制：
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we use the `vgimg` backend because we want to write to a PNG image. If,
    for example, you want to set the DPI of the image, you may use `vgimg.NewWith` instead,
    and pass in the DPI option.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`vgimg`后端，因为我们想写入PNG图像。例如，如果你想设置图像的DPI，你可以使用`vgimg.NewWith`，并传入DPI选项。
- en: '`dc` is `draw.Canvas` initiated from the large piece of canvas `img`. Now comes
    the magic: `canvases := plot.Align(at, t, dc)` basically splits the big canvas
    (`img`) into various smaller canvases—they''re still part of the big canvas, but
    now, each `*plot.Plot` object gets allocated a smaller piece of the canvas, each
    with their own coordinate systems that are relative to the bigger canvas.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`dc`是从大画布`img`初始化的`draw.Canvas`。现在到了神奇的部分：`canvases := plot.Align(at, t, dc)`基本上将大画布(`img`)分割成各种更小的画布——它们仍然是大画布的一部分，但现在，每个`*plot.Plot`对象都分配到了画布的一个更小的部分，每个部分都有相对于大画布的自己的坐标系。'
- en: 'The following code simply draws the plots onto their respective mini-canvases:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码只是将图表绘制到各自的迷你画布上：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Naturally, this process can be recursively repeated. A `Legend` object in `*plot.Plot` simply
    gets a smaller chunk of the canvas, and drawing a straight line from minimum `X`
    to maximum `X` simply draws a horizontal line across the entire mini canvas.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这个过程可以递归地重复。在`*plot.Plot`中的`Legend`对象只是简单地得到画布的一个更小的部分，从最小`X`到最大`X`的直线绘制只是在整个小画布上画一条水平线。
- en: And this is how plots are made.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是绘制图表的方法。
- en: Forecasting
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测
- en: 'We''re decomposing a time series here with the STL algorithm. There are other
    methods of decomposing time series—you may be familiar with one: the discrete
    Fourier transform. If your data is a time-based signal (like electrical pulses
    or music), a Fourier transform essentially allows you to decompose a time series
    into various parts. Bear in mind that they are no longer seasonality and trend,
    but rather decompositions of different time and frequency domains.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用STL算法分解时间序列。还有其他分解时间序列的方法——你可能熟悉其中一种：离散傅里叶变换。如果你的数据是基于时间的信号（如电脉冲或音乐），傅里叶变换本质上允许你将时间序列分解成不同的部分。记住，它们不再是季节性和趋势，而是不同时间和频率域的分解。
- en: 'This begs the question: what is the point of decomposing a time series?'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个问题：分解时间序列的目的是什么？
- en: A primary reason why we do any machine learning at all is to be able to predict
    values based on an input. When done on time series, this is called **forecasting**.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行任何机器学习的主要原因之一是能够根据输入预测值。当在时间序列上执行时，这被称为**预测**。
- en: 'Think about this for a bit: if a time series is made up of multiple components,
    wouldn''t it be better to be able to predict per component? If we are able to
    break a time series up into its components, be it by STL or by Fourier transforms,
    we would get better results if we predict per component and then recombine the
    data at the end.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这个问题：如果时间序列由多个组成部分组成，我们能否更好地按每个组成部分进行预测？如果我们能够通过STL或傅里叶变换将时间序列分解成其组成部分，那么如果我们按每个组成部分进行预测并在最后重新组合数据，我们会得到更好的结果。
- en: Since we work on STL, we already have our series decomposed. A very simple exponential
    smoothing algorithm invented by Holt in 1957 allows us to use the trend and seasonal
    components, along with the original data, to forecast.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在STL上工作，我们已经有分解好的序列。Holt在1957年发明的一个非常简单的指数平滑算法允许我们使用趋势和季节成分，以及原始数据来进行预测。
- en: Holt-Winters
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Holt-Winters
- en: 'In this section, I shall explain a modified form of the Holt-Winters exponential
    smoothing algorithm, which is quite useful for forecasting. Holt-Winters is a
    fairly simple algorithm. Here it is:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将解释Holt-Winters指数平滑算法的修改版，这对于预测非常有用。Holt-Winters是一个相当简单的算法。下面是它的样子：
- en: '[PRE30]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Calling it is rather easy. We would wind up with a time series with a number
    of additional periods. Hence, we would also need to extend our dates range before
    we call `newTSPlot`. Again, it''s a rather simple matter:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 调用它相当简单。我们最终会得到一个包含额外周期的时序。因此，在调用`newTSPlot`之前，我们也需要扩展我们的日期范围。这同样是一个相当简单的问题：
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Ideally, we would also like to draw a gray background indicating that the values
    in the area are forecasts. Putting it all together, it looks rather like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们还想绘制一个灰色背景，表示该区域内的值是预测值。将所有这些放在一起，看起来大致如下：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This would yield the following plot:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下图表：
- en: '![](img/5c0f2a7f-b316-46a3-b56e-4f83cb42a4ce.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c0f2a7f-b316-46a3-b56e-4f83cb42a4ce.png)'
- en: If everything keeps going as it is, we can expect to see an increased CO[2]
    level in 10 years. Of course, it could go down if we take action now.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切照旧进行，我们预计在10年内将看到二氧化碳水平增加。当然，如果我们现在采取行动，它可能会下降。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This has been a rather hard chapter to write. The primary subject matter, without
    exaggeration, is one of existential threat. The methods used in the science at
    large are far more sophisticated than what I have covered in this chapter.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章相当难写的章节。主要主题，毫不夸张地说，是关于存在性威胁的。在科学领域使用的方法比我在这章中涵盖的要复杂得多。
- en: The techniques I covered is a small part of a large field of statistics known
    as time series analysis, where we've yet to even scratch the surface of it with
    this composition technique.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我所涉及的技术是统计学一个大型领域——时间序列分析的一部分，而在这个写作技巧中，我们甚至还没有触及它的表面。
- en: References
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'The following are the references:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考文献：
- en: '*[0] Hershfield, Hal. (2011). Future self-continuity*: How conceptions of the
    future self transform intertemporal choice. Annals of the New York Academy of
    Sciences. 1235\. 30-43\. 10.1111/j.1749-6632.2011.06201.x.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[0] Hershfield, Hal. (2011). 未来自我连续性*: 如何对未来自我的概念改变跨时间选择。纽约科学院年鉴。1235卷。30-43页。10.1111/j.1749-6632.2011.06201.x.'
- en: '*[1] Qin, P. and Northoff, G. (2011)*: How is our self related to midline regions
    and the default-mode network?. NeuroImage, 57(3), pp.1221-1233.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[1] Qin, P. and Northoff, G. (2011)*: 我们的自我与中线区域和默认模式网络有何关联？. 神经影像学，57(3)，第1221-1233页。'
