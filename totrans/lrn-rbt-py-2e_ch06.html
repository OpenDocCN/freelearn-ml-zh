<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Interfacing Actuators and Sensors to the Robot Controller</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interfacing Actuators and Sensors to the Robot Controller</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we discussed the selection of the hardware components needed to build our robot. The important components in a robot are actuators and sensors. Actuators provide mobility to the robot and sensors provide information about the robot environment. In this chapter, we will concentrate on the different types of actuators and sensors that we are going to use in this robot and how they can be interfaced with Tiva C LaunchPad, which is a 32 bit ARM micro controller board from Texas Instruments, working at 80 MHz. We will start by discussing actuators. The actuator that we are going to discuss first is a DC-geared motor with an encoder. A DC-geared motor works using direct current and has gear reduction to reduce the shaft speed and increase the torque of the final shaft. These kinds of motors are very economical and satisfy our robot design requirement. We will use this motor in our robot prototype.</p>
<p>In the first section of this chapter, we will deal with the design of our robot drive system. The <strong>drive system</strong> of our robot is a differential drive and consists of two DC-geared motors with encoders and a motor driver. The motor driver is controlled by Tiva C LaunchPad. We will look at the interfacing of the motor driver and quadrature encoder with Tiva C Launchpad. After that, we will look at some of the latest actuators that can replace the existing DC-geared motor with an encoder. If the desired robot needs more payload and accuracy, we have to switch to these kinds of actuators. Finally, we will look at some different sensors that are commonly used for robots.</p>
<p>In this chapter, we will cover:</p>
<ul>
<li>Interfacing a DC-geared motor with Tiva C LaunchPad</li>
<li>Interfacing a quadrature encoder with Tiva C LaunchPad</li>
<li>An explanation of interfacing code</li>
<li>Interfacing Dynamixel actuators</li>
<li>Interfacing ultrasonic sensors and IR proximity sensors</li>
<li>Interfacing inertial measurement units (IMUs)</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will need the necessary robot hardware component and Energia IDE set up in Ubuntu 16.04 LTS.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interfacing DC geared motor to Tiva C LaunchPad</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we selected a DC-geared motor with an encoder from Pololu and an embedded board from Texas Instruments, called Tiva C LaunchPad. We need the following components to interface the motor with LaunchPad:</p>
<ul>
<li>Two Pololu metal gear motors, 37Dx73L mm with 64 counts per revolution encoder</li>
<li>Pololu wheel, 90x10 mm and a matching hub</li>
<li>Pololu dual VNH2SP30 motor driver carrier, MD03A</li>
<li>A sealed lead acid/lithium ion battery of 12V</li>
<li>A logic level convertor of 3.3V to 5V; visit <a href="https://www.sparkfun.com/products/11978"><span class="URLPACKT">https://www.sparkfun.com/products/11978</span></a>.</li>
<li>A Tiva C LaunchPad and its compatible interfacing wires</li>
</ul>
<p>The following diagram shows the interfacing circuit of two motors using Pololu H-Bridge:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/5ce9e995-90df-474d-a082-35bceab88334.png" style="width:62.17em;height:22.50em;"/></div>
<div class="packt_figure">
<div class="CDPAlignCenter CDPAlign packt_figref">Motor interfacing circuit</div>
</div>
<p>To interface with Launchpad, we have to connect a level shifter board in between these two motors. The motor driver works in 5V but the Launchpad works in 3.3V, so we have to connect a level shifter, as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/62074ed0-c097-4073-b041-9cb8cc46deb7.png" style="width:39.25em;height:18.92em;"/></div>
<div class="packt_figure">
<div class="CDPAlignCenter CDPAlign packt_figref">Level shifter circuit</div>
</div>
<p>The two geared DC motors are connected to <strong>OUT1A</strong>, <strong>OUT1B</strong>, and <strong>OUT2A</strong>, <strong>OUT2B</strong> of the motor driver. <strong>VIN (+)</strong> and <strong>GND (-)</strong> are the supply voltage of the motor. These DC motors can work with a 12V supply, so we give 12V as the input voltage. The motor driver will support an input voltage ranging from 5.5V to 16V.</p>
<p>The control signals/input pins of the motor drivers are on the left side of the driver. The first pin is <strong>1DIAG/EN</strong>; in most cases, we leave this pin disconnected. These pins are externally pulled high in the driver board itself. The main use of this pin is to enable or disable the H-bridge chip. It is also used to monitor the faulty condition of the H-Bridge IC. Pins <strong>1INA</strong> and <strong>1INB</strong> control the direction of the rotation of the motor. The <strong>1PWM</strong> pin will switch the motor to the ON and OFF state. We achieve speed control using <strong>PWM</strong> pins. The <strong>CS</strong> pin will sense the output current. It will output 0.13V per Ampere of the output current. The <strong>VIN</strong> and <strong>GND</strong> pins give the same input voltage that we supplied for the motor. We are not using these pins here. The <strong>+5V(IN)</strong> and <strong>GND</strong> pins are the supply for the motor driver IC. The supply to the motor driver and motors are different.</p>
<p>The following table shows the truth table of the input and output combinations:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>INA</p>
</td>
<td>
<p>INB</p>
</td>
<td>
<p>DIAGA/ENA</p>
</td>
<td>
<p>DIAGB/ENB</p>
</td>
<td>
<p>OUTA</p>
</td>
<td>
<p>OUTB</p>
</td>
<td>
<p>CS</p>
</td>
<td>
<p>Operating mode</p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>H</p>
</td>
<td>
<p>H</p>
</td>
<td>
<p>High Imp</p>
</td>
<td>
<p>Brake to Vcc</p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>H</p>
</td>
<td>
<p>L</p>
</td>
<td>
<p>Isense = Iout / K</p>
</td>
<td>
<p>Clockwise (CW)</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>L</p>
</td>
<td>
<p>H</p>
</td>
<td>
<p>Isense = Iout / K</p>
</td>
<td>
<p>Counterclockwise (CCW)</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>L</p>
</td>
<td>
<p>L</p>
</td>
<td>
<p>High Imp</p>
</td>
<td>
<p>Breaker to GND</p>
</td>
</tr>
</tbody>
</table>
<p>&#160;</p>
<p>The value <strong>DIAG/EN</strong> pins are always high because these pins are externally pulled high in the driver board itself. Using the aforementioned signal combinations, we can move the robot in any direction and by adjusting the PWM signal, we can adjust the speed of the motor too. This is the basic logic behind controlling a DC motor using an H-Bridge circuit.</p>
<p>While interfacing motors to Launchpad, we may require a level shifter. This is because the output pins of Launchpad can only supply 3.3V but the motor driver needs 5V to trigger; so, we have to connect 3.3V to the 5V logic level convertor to start working.</p>
<p>The two motors work in a differential drive mechanism. The following section discusses the differential drive and its operation.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Differential wheeled robot</h1>
                </header>
            
            <article>
                
<p>The robot we have designed is a differential wheeled/drive robot. In a differential wheeled robot, the movement is based on two separately driven wheels placed on either side of the robot's body. It can change its direction by changing the relative rate of rotation of its wheels, and hence, doesn't require additional steering motion. To balance the robot, a free turning wheel or caster wheels may be added. The following diagram shows a typical representation of a differential drive:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/96923b01-7cc8-446a-914d-97042a6273cc.png" style="width:16.00em;height:12.00em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Differential wheeled robot</div>
<p>If the two motors are in the same direction, the robot will move forward or backward. If one motor has more speed than the other, then the robot turns to the slower motor side; so, to turn left, stop the left motor and move the right motor. The following diagram shows how we connect the two motors in our robot. The two motors are mounted on the opposite sides of the base plate and we put two casters in the front and back of the robot for balancing:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/1cd00226-487c-45e0-8698-6154eb64ce0c.png" style="width:21.25em;height:17.17em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Top view of robot base</div>
<p>Next, we can program the motor controller using Launchpad according to the truth table data. Programming is done using an IDE called <strong>Energia</strong> (<span class="URLPACKT"><a href="http://energia.nu/">http://energia.nu/</a>)</span>. We are programming Launchpad using the C++ language, very similar to Arduino boards (<a href="http://energia.nu/Reference_Index.html"><span class="URLPACKT">http://energia.nu/Reference_Index.html</span></a>).</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Energia IDE</h1>
                </header>
            
            <article>
                
<p>We can download the latest version of Energia from the following link:</p>
<p><a href="http://energia.nu/download/"><span class="URLPACKT">http://energia.nu/download/</span></a></p>
<p>We will discuss the installation procedure mainly on Ubuntu 16.04 LTS, 64-bit. The Energia version that we will use is 0101E0018:</p>
<ol>
<li>Download Energia for Linux 64-bit from the preceding link.</li>
<li>Extract the Energia compressed file into the Home folder of the user.</li>
<li>The instructions for setting the Tiva C Launchpad boards are given in the following link: <a href="http://energia.nu/guide/guide_linux/">http://energia.nu/guide/guide_linux/</a></li>
<li>You have to download the <kbd>71-ti-permissions.rules</kbd> file from the following link: <a href="http://energia.nu/files/71-ti-permissions.rules">http://energia.nu/files/71-ti-permissions.rules</a></li>
<li>The rules file will give permission to the user for reading and writing to the Launchpad board. You have to save the file as 71-ti-permissions.rules and execute the following command from the current path to copy the rules files into a system folder to get the permission:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo mv 71-ti-permissions.rules /etc/udev/rules.d/</strong></pre>
<ol start="6">
<li>After copying the file, execute the following command to activate the rules:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo service udev restart</strong></pre>
<ol start="7">
<li>You can plug the Tiva C Launchpad to your PC now and execute the <kbd>dmesg</kbd> command in the Linux Terminal to see the Linux kernel log. If it is created, a serial port device will show at the end of the messages, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/543ba969-e43e-4869-ae48-3c8cc61aadb2.png" style="width:41.67em;height:6.67em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Top view of robot base</div>
<ol start="8">
<li>If you can see the serial port device, then start Energia using the following command inside the folder:</li>
</ol>
<pre>    <strong>$./energia</strong>  </pre>
<p style="padding-left: 90px">The following screenshot shows the Energia IDE:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/a9a39ae5-9f7b-48e3-82ad-b20bb3d685f9.png" style="width:30.50em;height:34.33em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Energia IDE</div>
<p style="padding-left: 90px">Now, we have to select the board tm4c123 in the IDE for compiling the code specific for this board. To do so, we have to install the packages of this board. You can select the option <span class="packt_screen">Tools</span> | <span class="packt_screen">Boards</span> | <span class="packt_screen">Boards Manager</span> to install the packages.</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/d4fd0270-51aa-4ab5-92c4-4a38a0f1a753.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Board Manager of Energia</div>
<ol start="9">
<li>After installing the packages, you can select the board by navigating to <span class="packt_screen">Tools</span> | <span class="packt_screen">Boards</span> | <span class="packt_screen">Launchpad (Tiva C) w/tm4c123 (80MHz),</span> as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/87043600-18d4-40bb-8b8a-3f866ca0b4ae.png" style="width:40.33em;height:25.33em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Energia board selection</div>
<ol start="10">
<li>Then, select the serial port by navigating to <span class="packt_screen">Tools</span> | <span class="packt_screen">Serial Port</span> | <span class="packt_screen">/dev/ttyACM0</span>, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/ac0c8dfc-a033-455b-9863-3c00eac17947.png" style="width:34.83em;height:30.83em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Energia serial port selection</div>
<ol start="11">
<li>Compile and upload the code by using the <span class="packt_screen">Upload</span> button. The Upload button will do both the processes. The following screenshot illustrates a successful upload:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/6d41d768-e211-4e1a-a33d-103dcb5d7216.png" style="width:29.58em;height:37.17em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Energia serial port selection</div>
<p>Visit the following links to install Energia on Linux, macOS X, and Windows:</p>
<ul>
<li>Refer to <a href="http://energia.nu/guide/guide_linux/"><span class="URLPACKT">http://energia.nu/guide/guide_linux/</span></a> for Linux</li>
<li>Refer to <a href="http://energia.nu/Guide_MacOSX.html"><span class="URLPACKT">http://energia.nu/Guide_MacOSX.html</span></a> for macOS X</li>
<li>Refer to <a href="http://energia.nu/Guide_Windows.html"><span class="URLPACKT">http://energia.nu/Guide_Windows.html</span></a> for Windows</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Motor interfacing code</h1>
                </header>
            
            <article>
                
<p>The following code in Energia can be used to test the two motors in the differential drive configuration. This code can move the robot forward for 5 seconds and backward for 5 seconds. Then, it moves the robot to the left for 5 seconds and right for 5 seconds. After each movement, the robot will stop for 1 second.</p>
<p>At the start of the code, we define pins for INA, INB, and PWM of the two motors, as follows:</p>
<pre>///Left Motor  Pins 
#define INA_1 12 
#define INB_1 13 
#define PWM_1 PC_6 
 
///Right Motor Pins 
#define INA_2 5 
#define INB_2 6 
#define PWM_2 PC_5 </pre>
<p>The pinout for Launchpad is given at:&#160;<a href="http://energia.nu/pin-maps/guide_tm4c123launchpad/"><span class="URLPACKT">http://energia.nu/pin-maps/guide_tm4c123launchpad/</span></a></p>
<p>The following code shows the five functions to move the robot forward, backward, left, and right. The fifth function is to stop the robot. We will use the <kbd>digitalWrite()</kbd> function to write a digital value to a pin. The first argument of <kbd>digitalWrite()</kbd> is the pin number and the second argument is the value to be written to the pin. The value can be <kbd>HIGH</kbd> or <kbd>LOW</kbd>. We will use the <kbd>analogWrite()</kbd> function to write a PWM value to a pin. The first argument of this function is the pin number and the second is the PWM value. The range of this value is from 0-255. At high PWM, the motor driver will switch fast and have more speed. At low PWM, switching inside the motor driver will be slow, so the motor will also be slow. Currently, we are running at full speed:</p>
<pre>void move_forward() 
{ 
    //Setting CW rotation to and Left Motor  and CCW to Right Motor  
    //Left Motor  
    digitalWrite(INA_1,HIGH); 
    digitalWrite(INB_1,LOW); 
    analogWrite(PWM_1,255); 
    //Right Motor  
    digitalWrite(INA_2,LOW); 
    digitalWrite(INB_2,HIGH); 
    analogWrite(PWM_2,255);   
} 
 
/////////////////////////////////////////////////////// 
 
void move_left() 
{ 
    //Left Motor  
    digitalWrite(INA_1,HIGH); 
    digitalWrite(INB_1,HIGH); 
    analogWrite(PWM_1,0); 
    //Right Motor  
    digitalWrite(INA_2,LOW); 
    digitalWrite(INB_2,HIGH); 
    analogWrite(PWM_2,255);   
} 
 
////////////////////////////////////////////////////// 
 
void move_right() 
{ 
      //Left Motor  
      digitalWrite(INA_1,HIGH); 
      digitalWrite(INB_1,LOW); 
      analogWrite(PWM_1,255); 
      //Right Motor  
      digitalWrite(INA_2,HIGH); 
      digitalWrite(INB_2,HIGH); 
      analogWrite(PWM_2,0);   
} 
 
//////////////////////////////////////////////////////// 
 
void stop() 
{ 
    //Left Motor  
    digitalWrite(INA_1,HIGH); 
    digitalWrite(INB_1,HIGH); 
    analogWrite(PWM_1,0); 
    //Right Motor  
    digitalWrite(INA_2,HIGH); 
    digitalWrite(INB_2,HIGH); 
    analogWrite(PWM_2,0);   
} 
 
///////////////////////////////////////////////// 
 
void move_backward() 
 
{ 
    //Left Motor  
    digitalWrite(INA_1,LOW); 
    digitalWrite(INB_1,HIGH); 
    analogWrite(PWM_1,255); 
    //Right Motor  
    digitalWrite(INA_2,HIGH); 
    digitalWrite(INB_2,LOW); 
    analogWrite(PWM_2,255);   
} </pre>
<p>We first set the <kbd>INA</kbd> and <kbd>INB</kbd> pins of the two motors to the <kbd>OUTPUT</kbd> mode, so that we can write <kbd>HIGH</kbd> or <kbd>LOW</kbd> values to these pins. The <kbd>pinMode()</kbd> function is used to set the mode of the I/O pin. The first argument of <kbd>pinMode()</kbd> is the pin number and the second argument is the mode. We can set a pin as input or output. To set a pin as output, give the <kbd>OUTPUT</kbd> argument as the second argument; to set it as input, give <kbd>INPUT</kbd> as the second argument, as shown in following code. There is no need to set the PWM pin as the output because <kbd>analogWrite()</kbd> writes the PWM signal without setting <kbd>pinMode()</kbd>:</p>
<pre>void setup() 
{ 
   //Setting Left Motor pin as OUTPUT 
    pinMode(INA_1,OUTPUT);  
    pinMode(INB_1,OUTPUT); 
    pinMode(PWM_1,OUTPUT); 
 
   //Setting Right Motor pin as OUTPUT 
    pinMode(INA_2,OUTPUT); 
    pinMode(INB_2,OUTPUT); 
    pinMode(PWM_2,OUTPUT);   
} </pre>
<p>The following snippet is the main loop of the code. It will call each function, such as <kbd>move forward()</kbd>, <kbd>move_backward()</kbd>, <kbd>move_left()</kbd>, and <kbd>move_right(),</kbd>for <kbd>5</kbd> seconds. After calling each function, the robot stops for <kbd>1</kbd> second:</p>
<pre>void loop() 
{ 
  //Move forward for 5 sec 
move_forward(); 
delay(5000); 
  //Stop for 1 sec 
stop(); 
delay(1000); 
 
  //Move backward for 5 sec 
move_backward(); 
delay(5000); 
  //Stop for 1 sec 
stop(); 
delay(1000); 
 
  //Move left for 5 sec 
move_left(); 
delay(5000); 
  //Stop for 1 sec 
stop(); 
delay(1000); 
 
  //Move right for 5 sec 
move_right(); 
delay(5000);   
  //Stop for 1 sec 
stop(); 
delay(1000); 
} </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interfacing quadrature encoder with Tiva C Launchpad</h1>
                </header>
            
            <article>
                
<p>The wheel encoder is a sensor attached to the motor to sense the number of rotations of the wheel. If we know the number of rotations, we can compute the velocity and displacement of the wheel.</p>
<p>For this robot, we have chosen a motor with an in-built encoder. This encoder is a quadrature type, which can sense both the direction and speed of the motor. Encoders use different types of sensors, such as optical and hall sensors, to detect these parameters. This encoder uses the hall effect to sense the rotation. The quadrature encoder has two channels, namely <strong>Channel A</strong> and <strong>Channel B</strong>. Each channel will generate digital signals with a 90-degree phase shift. The following diagram shows the wave form of a typical quadrature encoder:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/7969c070-2911-431d-a5dc-916a8fbd6335.png" style="width:25.33em;height:16.25em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Quadrature encoder waveforms</div>
<p>If the motor rotates in a clockwise direction, <strong>Channel A</strong> will lead <strong>Channel B,</strong> and if the motor rotates counterclockwise, <strong>Channel B</strong> will lead <strong>Channel A</strong>. This reading will be useful to sense the direction of rotation of the motor. The following section discusses how we can translate the encoder output to useful measurements, such as displacement and velocity.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Processing encoder data</h1>
                </header>
            
            <article>
                
<p>Encoder data is a two-channel pulse out with 90 degrees out of phase. Using this data, we can find the direction of rotation and how many times the motor has rotated, and thereby find the displacement and velocity.</p>
<p>Some of the terms that specify encoder resolution are <strong>pulses per revolution</strong> (<strong>PPR</strong>) or <strong>lines per revolution</strong> (<strong>LPR</strong>) and <strong>counts per revolution</strong> (<strong>CPR</strong>). PPR specifies how many electrical pulses (0 to 1 transitions) there will be during one revolution of the motor final shaft. Some manufactures use the name CPR instead of PPR, because each pulse will contain two edges (rising and falling) and there are two pulse channels (A and B) with 90-degree phase shift; the total number of edges will be four times the number of PPR. Most quadrature receivers use the so-called 4X decoding to count all the edges from encoder A and B channels yielding 4X resolution compared to the raw PPR value.</p>
<p>In our motor, Pololu specifies that the CPR is 64 for the motor shaft, which corresponds to 8,400 CPR of the gearbox's output shaft. In effect, we get 8,400 counts from the gearbox output shaft when the motor's final shaft completes one revolution. The following diagram shows how we can compute the count from the encoder pulses:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/d6324108-5123-4d55-b66a-56716c982163.png" style="width:23.92em;height:8.92em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Encoder pulses with count value</div>
<p>In this encoder specification, the count per revolution is given; it is calculated by the encoder channel edge transitions. One pulse of an encoder channel corresponds to four counts. So, to get 8,400 counts in our motor, the PPR will be <em>8,400 / 4 = 2,100</em>. From the preceding diagram, we will be able to calculate the number of counts in one revolution, but we also need to sense the direction of movement. This is because irrespective of whether the robot moves forward or backward, the counts that we get will be same; so, sensing the direction is important in order to decode the signal. The following diagram shows how we can decode the encoder pulses:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/bf1151a7-310f-42dc-80c0-bd5357fd5e0d.png" style="width:15.25em;height:10.17em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Detecting motor direction from encoder pulses</div>
<p>If we observe the code pattern, we can understand that it follows the 2-bit Gray code. A Gray code is the encoding of numbers, so that adjacent numbers have a single digit differing by 1. Gray code (<a href="http://en.wikipedia.org/wiki/Gray_code"><span class="URLPACKT">http://en.wikipedia.org/wiki/Gray_code</span></a>) is commonly used in rotary encoders for efficient coding.</p>
<p>We can predict the direction of rotation of a motor by state transitions. The state transition table is as follows:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>State</p>
</td>
<td>
<p>Clockwise transition</p>
</td>
<td>
<p>Counterclockwise transition</p>
</td>
</tr>
<tr>
<td>
<p>0,0</p>
</td>
<td>
<p>0,1 to 0,0</p>
</td>
<td>
<p>1,0 to 0,0</p>
</td>
</tr>
<tr>
<td>
<p>1,0</p>
</td>
<td>
<p>0,0 to 1,0</p>
</td>
<td>
<p>1,1 to 1,0</p>
</td>
</tr>
<tr>
<td>
<p>1,1</p>
</td>
<td>
<p>1,0 to 1,1</p>
</td>
<td>
<p>0,1 to 1,1</p>
</td>
</tr>
<tr>
<td>
<p>0,1</p>
</td>
<td>
<p>1,1 to 0,1</p>
</td>
<td>
<p>0,0 to 0,1</p>
</td>
</tr>
</tbody>
</table>
<p>&#160;</p>
<p>It will be more convenient if we represent it in a state transition diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/ced2e452-275e-43f7-b313-231d8549f634.png" style="width:16.50em;height:16.50em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">State transition diagram of encoders</div>
<p>After getting this Gray code, we can process the pulses using a microcontroller. The channel pins of the motor have to be connected to the interrupt pins of the microcontroller. So, when the channel has edge transitions, it will generate an interrupt or trigger in the pins, and if any interrupts arrives in that pin, an interrupt service routine, or simply a function, will be executed inside the microcontroller program. It can read the current state of the two pins. According to the current state of the pins and previous values, we can determine the direction of rotation and can decide whether we have to increment or decrement the count. This is the basic logic for encoder handling.</p>
<p>After getting the count, we can calculate the angle of rotation (in degrees) using <em>Angle = (Count Value / CPR) * 360</em>. Here, if we substitute CPR with 8,400, the equation becomes <em>Angle = 0.04285 * Count Value</em>; that is, for turning one degree, 24 counts have to be received or six encoded channel pulses have to come.</p>
<p>The following diagram shows the interfacing circuit of one motor encoder with Tiva C LaunchPad:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/617798bd-cbd8-45c5-8d3f-a24f53b9e415.png" style="width:42.75em;height:22.33em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Interfacing encoder to Launchpad</div>
<p>From the above diagram, you can find motor pins CH A and CH B which are the output from the motor encoders. These pins are interfaced to PB2 and PB7 pins of the Tiva C Launchpad. The pins ENC VCC and ENC GND are the power pins of the encoder,&#160; so we have to provide +5V and GND to these pins.&#160; The next set of pins are for powering the motors. The MOTOR VCC&#160; and MOTOR GND are marked as OUTA and OUTB which is directly going to Motor driver in order to control the motor speed.</p>
<p>The maximum voltage level of output pulse is in between 0V to 5V from the encoder. In this case, we can directly interface the encoder with Launchpad because it can receive input up to 5V, or we can use a 3.3V to 5V level shifter like we used for motor driver interfacing earlier.</p>
<p>In the next section, we will upload code in Energia to test the quadrature encoder signal. We need to check whether we get a proper count from the encoder.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Quadrature encoder interfacing code</h1>
                </header>
            
            <article>
                
<p>This code will print the count of the left and right motor encoder via a serial port. The two encoders are in a 2X decoding scheme, so we will get 4,200 CPR. In the first section of the code, we are defining pins for two channel outputs of two encoders and we are declaring the count variable for two encoders. The encoder variable uses a volatile keyword before the variable data type. The main use of <kbd>volatile</kbd> is that the variable with the <kbd>volatile</kbd> keyword will store in RAM memory, whereas normal variables are in CPU registers. Encoder values will change very quickly, so using an ordinary variable will not be accurate. In order to get accuracy, we will use <kbd>volatile</kbd> for encoder variables, as follows:</p>
<pre>//Encoder pins definition 
 
// Left encoder 
 
#define Left_Encoder_PinA 31 
#define Left_Encoder_PinB 32 
 
volatile long Left_Encoder_Ticks = 0; 
 
//Variable to read current state of left encoder pin 
volatile bool LeftEncoderBSet; 
 
//Right Encoder 
 
#define Right_Encoder_PinA 33 
#define Right_Encoder_PinB 34 
volatile long Right_Encoder_Ticks = 0; 
//Variable to read current state of right encoder pin 
volatile bool RightEncoderBSet; </pre>
<p>The following code snippet is the definition of the <kbd>setup()</kbd> function. In Energia, <kbd>setup()</kbd> is a built-in function used for initialization and for one-time execution of variables and functions. Inside <kbd>setup()</kbd>, we initialize the serial data communication with a baud rate of <kbd>115200</kbd> and call a user-defined <kbd>SetupEncoders()</kbd> function to initialize pins of the encoders. The serial data communication is mainly done to check the encoder count via the serial terminal:</p>
<pre>void setup() 
{ 
    //Init Serial port with 115200 buad rate 
  Serial.begin(115200);   
  SetupEncoders(); 
} </pre>
<p>The definition of <kbd>SetupEncoders()</kbd> is given in the code that follows. To receive the encoder pulse, we need two pins in Launchpad as the input. Configure the encoder pins to Launchpad as the input and activate its pull-up resistor. The <kbd>attachInterrupt ()</kbd> function will configure one of the encoder pins as an interrupt. The <kbd>attachInterrupt ()</kbd> function has three arguments. The first argument is the pin number, the second argument is the <strong>interrupt service routine</strong> (<strong>ISR</strong>), and the third argument is the interrupt condition, that is, the condition in which the interrupt has to fire ISR. In this code, we are configuring <kbd>PinA</kbd> of the left and right encoder pins as the interrupt; it calls the ISR when there is a rise in the pulse:</p>
<pre>void SetupEncoders() 
{ 
  // Quadrature encoders 
  // Left encoder 
  pinMode(Left_Encoder_PinA, INPUT_PULLUP); 
  // sets pin A as input   
  pinMode(Left_Encoder_PinB, INPUT_PULLUP); 
  // sets pin B as input 
  attachInterrupt(Left_Encoder_PinA, do_Left_Encoder, RISING); 
 
  // Right encoder 
  pinMode(Right_Encoder_PinA, INPUT_PULLUP); 
  // sets pin A as input 
  pinMode(Right_Encoder_PinB, INPUT_PULLUP); 
  // sets pin B as input 
 
  attachInterrupt(Right_Encoder_PinA, do_Right_Encoder, RISING); 
} </pre>
<p>The following code is the built-in <kbd>loop()</kbd> function in Energia. The <kbd>loop()</kbd> function is an infinite loop where we put our main code. In this code, we call the <kbd>Update_Encoders()</kbd> function to print the encoder value continuously through the serial Terminal:</p>
<pre>void loop() 
{ 
  Update_Encoders();                        
} </pre>
<p>The following code is the function definition of the <kbd>Update_Encoders()</kbd> function. It prints two encoder values in a line with a starting character <kbd>e</kbd> and the values are separated by tab spaces. The <kbd>Serial.print()</kbd> function is a built-in function that will print the character/string given as the argument:</p>
<pre>void Update_Encoders() 
{ 
  Serial.print("e"); 
  Serial.print("t"); 
  Serial.print(Left_Encoder_Ticks); 
  Serial.print("t"); 
  Serial.print(Right_Encoder_Ticks); 
  Serial.print("n"); 
 } </pre>
<p>The following code is the ISR definition of the left and right encoders. When a rising edge is detected on each of the pins, one of the ISRs will be called. The current interrupt pins are <kbd>PinA</kbd> of each of the encoders. After getting the interrupt, we can assume that the rising <kbd>PinA</kbd> has a higher value state, so there is no need to read that pin. Read <kbd>PinB</kbd> of both the encoders and store the pin state to <kbd>LeftEncoderBSet</kbd> or <kbd>RightEncoderBSet</kbd>. The current state is compared to the previous state of <kbd>PinB</kbd> and can detect the direction and decide whether the count has to be incremented or decremented according to the state transition table:</p>
<pre>void do_Left_Encoder() 
{ 
  LeftEncoderBSet = digitalRead(Left_Encoder_PinB); 
  // read the input pin 
  Left_Encoder_Ticks -= LeftEncoderBSet ? -1 : +1; 
} 
 
void do_Right_Encoder() 
{ 
  RightEncoderBSet = digitalRead(Right_Encoder_PinB); 
  // read the input pin 
  Right_Encoder_Ticks += RightEncoderBSet ? -1 : +1; 
} </pre>
<p>Upload the sketch and view the output using the serial monitor in Energia. Navigate to <span class="packt_screen">Tools</span> | <span class="packt_screen">Serial monitor</span>. Move the two motors manually and you will see the count changing. Set the baud rate in the serial monitor, which is the same as that initialized in the code; in this case, it is <strong>115200</strong>. The output will look like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/2718f894-08de-4d89-b453-c6e701eeab4f.png" style="width:35.25em;height:20.58em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Interfacing encoder to Launchpad</div>
<p>If we want to upgrade the robot to high accuracy and payload, we have to consider high quality actuators, such as Dynamixel. Dynamixel servos are intelligent actuators, which have in-built PID control and monitoring of the servo and encoder parameters, such as torque, position, and so on. In this robot, we are not using Dynamixel.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with Dynamixel actuators</h1>
                </header>
            
            <article>
                
<p><strong>Dynamixel</strong> is a kind of networked actuator for robots developed by the Korean manufacture, ROBOTIS. It is widely used by companies, universities, and hobbyists due to its versatile expansion capability, power feedback function, position, speed, internal temperature, input voltage, and so on.</p>
<p>The Dynamixel servos can be connected in a daisy chain; it is a method of connecting devices in a serial fashion, connecting one device to another through the connected devices, and can control all the connected servos from one controller. Dynamixel servos communicate via RS485 or TTL. The list of available Dynamixel servos is given at <a href="http://www.robotis.com/xe/dynamixel_en"><span class="URLPACKT">http://www.robotis.com/xe/dynamixel_en</span></a>.</p>
<p>The interfacing of Dynamixel is very easy. Dynamixel comes with a controller called USB2Dyanmixel, which will convert a USB to Dynamixel compatible TTL/RS485 levels. The following diagram shows the interfacing diagram of Dynamixel:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/49479e5f-e31f-43b8-8a35-ce370c301094.png" style="width:48.42em;height:9.83em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Interfacing Dynamixel actuators to a PC</div>
<p>ROBOTIS provides Dynamixel SDK for accessing motor registers; we can read and write values to Dynamixel registers and retrieve data, such as position, temperature, voltage, and so on.</p>
<div class="packt_infobox">The instructions to set USB2Dynamixel and Dynamixel SDK are given at <a href="http://support.robotis.com/en/"><span class="URLPACKT">support.robotis.com/en/</span></a>.</div>
<p>Dynamixel can be programed using Python libraries. One of the Python libraries for handling Dynamixel servos is <strong>pydynamixel</strong>. This package is available for Windows and Linux. Pydynamixel will support RX, MX, and EX series servos.</p>
<p>We can download the the pydynamixel Python package from <a href="https://pypi.python.org/pypi/dynamixel/"><span class="URLPACKT">https://pypi.python.org/pypi/dynamixel/</span></a>.</p>
<p>Download the package and extract it to the <kbd>home</kbd> folder. Open a terminal/DOS prompt and execute the following command:</p>
<pre>    <strong>sudo python setup.py install </strong>  </pre>
<p>After installing the package, we can try the following Python example, which will detect the servo attached to the USB2Dynamixel and write some random position to the servo. This example will work with RX and MX servos:</p>
<pre>#!/usr/bin/env python </pre>
<p>The following code will import the necessary Python modules required for this example. This includes Dynamixel Python modules too:</p>
<pre>import os 
import dynamixel 
import time 
import random </pre>
<p>The following code defines the main parameters needed for Dynamixel communication parameters. The <kbd>nServos</kbd> variable denotes the number of Dynamixel servos connected to the bus. The <kbd>portName</kbd> variable indicates the serial port of USB2Dynamixel to which Dynamixel servos are connected. The <kbd>baudRate</kbd> variable is the communication speed of USB2Dynamixel and Dynamixel:</p>
<pre># The number of Dynamixels on our bus. 
nServos = 1 
 
# Set your serial port accordingly. 
if os.name == "posix": 
    portName = "/dev/ttyUSB0" 
else: 
    portName = "COM6" 
     
# Default baud rate of the USB2Dynamixel device. 
baudRate = 1000000 </pre>
<p>The following code is the Dynamixel Python function to connect to Dynamixel servos. If it is connected, the program will print it and scan the communication bus to find the number of servos starting from ID <kbd>1</kbd> to <kbd>255</kbd>. The servo ID is the identification of each servo. We are given <kbd>nServos</kbd> as <kbd>1</kbd>, so it will stop scanning after getting one servo on the bus:</p>
<pre># Connect to the serial port 
print "Connecting to serial port", portName, '...', 
serial = dynamixel.serial_stream.SerialStream( port=portName, baudrate=baudRate, timeout=1) 
print "Connected!" 
net = dynamixel.dynamixel_network.DynamixelNetwork( serial ) 
net.scan( 1, nServos ) </pre>
<p>The following code will append the Dynamixel ID and the servo object to the <kbd>myActutors</kbd> list. We can write servo values to each servo using the servo ID and servo object. We can use the <kbd>myActutors</kbd> list for further processing:</p>
<pre># A list to hold the dynamixels 
myActuators = list() 
print myActuators 
 
This will create a list for storing  dynamixel actuators details. 
 
print "Scanning for Dynamixels...", 
for dyn in net.get_dynamixels(): 
    print dyn.id, 
    myActuators.append(net[dyn.id]) 
print "...Done" </pre>
<p>The following code will write random positions from 450 to 600 to each Dynamixel actuator that is available on the bus. The range of positions in Dynamixel is 0 to 1,023. This will set the servo parameters, such as <kbd>speed</kbd>, <kbd>torque,torque_limt</kbd>, <kbd>max_torque</kbd>, and so on:</p>
<pre># Set the default speed and torque 
for actuator in myActuators: 
    actuator.moving_speed = 50 
    actuator.synchronized = True 
    actuator.torque_enable = True 
    actuator.torque_limit = 800 
    actuator.max_torque = 800 </pre>
<p>The following code will print the current position of the current actuator:</p>
<pre># Move the servos randomly and print out their current positions 
while True: 
    for actuator in myActuators: 
        actuator.goal_position = random.randrange(450, 600) 
    net.synchronize() </pre>
<p>The following code will read all data from the actuators:</p>
<pre>    for actuator in myActuators: 
        actuator.read_all() 
        time.sleep(0.01) 
 
    for actuator in myActuators: 
        print actuator.cache[dynamixel.defs.REGISTER['Id']], actuator.cache[dynamixel.defs.REGISTER['CurrentPosition']] 
 
    time.sleep(2) </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with ultrasonic distance sensors</h1>
                </header>
            
            <article>
                
<p>One of the important capabilities of a mobile robot is navigation. An ideal navigation means a robot can plan its path from its current position to the destination and can move without any obstacles. We use ultrasonic distance sensors in this robot for detecting near objects that can't be detected using the Kinect sensor. A combination of Kinect and ultrasonic sound sensors provides ideal collision avoidance on this robot.</p>
<p>Ultrasonic distance sensors work in the following manner. The transmitter will send an ultrasonic sound that is not audible to human ears. After sending an ultrasonic wave, it will wait for an echo of the transmitted wave. If there is no echo, it means there are no obstacles in front of the robot. If the receiving sensor receives any echo, a pulse will be generated on the receiver, and it can calculate the total time the wave will take to travel to the object and return to the receiver sensors. If we get this time, we can compute the distance to the obstacle using the following formula:</p>
<p><em>Speed of Sound * Time Passed /2 = Distance from Object</em>.</p>
<p>Here, the speed of sound can be taken as 340 m/s.</p>
<p>Most of the ultrasonic range sensors have a distance range from 2 cm to 400 cm. In this robot, we use a sensor module called HC-SR04. We look at how to interface HC-SR04 with Tiva C LaunchPad to get the distance from the obstacles.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interfacing HC-SR04 to Tiva C LaunchPad</h1>
                </header>
            
            <article>
                
<p>The following diagram illustrates the interfacing circuit of the HC-SR04 ultrasonic sound sensor with Tiva C LaunchPad:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/0ef11ee4-03be-46e4-bcd2-6b6e13c39834.png" style="width:26.25em;height:24.33em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Interfacing ultrasonic sound sensors to Launchpad</div>
<p>The working voltage of the ultrasonic sensor is 5V and the input/output of this sensor is also 5V, so we need a level shifter on the <strong>Trig</strong> and <strong>Echo</strong> pins for interfacing into the <strong>3.3V</strong> level Launchpad. In the level shifter, we need to apply high voltage, that is, 5V, and low voltage, that is, 3.3V, as shown in the preceding diagram, to switch from one level to another level. <strong>Trig</strong> and <strong>Echo</strong> pins are connected on the high voltage side of the level shifter and the low voltage side pins are connected to Launchpad. The <strong>Trig</strong> pin and <strong>Echo</strong> are connected to the 10th and 9th pins of Launchpad. After interfacing the sensor, we can see how to program the two I/O pins.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working of HC-SR04</h1>
                </header>
            
            <article>
                
<p>The timing of the waveform on each pin is shown in the following diagram. We need to apply a short 10 µs pulse to the trigger input to start the ranging and then the module will send out an eight-cycle burst of ultrasound at 40 KHz and raise its echo. The echo is a distance object that is the pulse width and the range in proportion. You can calculate the range through the time interval between sending trigger signals and receiving echo signals using the following formula:</p>
<p><em>Range = high level time of echo pin output * velocity (340 M/S) / 2</em>.</p>
<p>It will be better to use a delay of 60 ms before each trigger to avoid overlapping between trigger and echo:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/c24f5ba9-eef8-422d-a8ef-e32675e839cc.png" style="width:48.08em;height:22.42em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Input and output waveform of ultrasound sensor</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interfacing Code of Tiva C Launchpad</h1>
                </header>
            
            <article>
                
<p>The following Energia code for Launchpad reads values from the ultrasound sensor and monitors the values through a serial port.</p>
<p>The following code defines the pins in Launchpad to handle ultrasonic echo and trigger pins and also defines variables for the duration of the pulse and the distance in centimeters:</p>
<pre>const int echo = 9, Trig = 10; 
long duration, cm; </pre>
<p>The following code snippet is the <kbd>setup()</kbd> function. The <kbd>setup()</kbd> function is called when the program starts. Use this to initialize variables, pin modes, to start using libraries, and so on. The setup function will only run once, after each power up or reset of the Launchpad board. Inside <kbd>setup()</kbd>, we initialize serial communication with a baud rate of 115200 and set up the mode of ultrasonic handling pins by calling a <kbd>SetupUltrasonic();function:</kbd></p>
<pre>void setup() 
{ 
   
  //Init Serial port with 115200 baud rate 
  Serial.begin(115200);   
  SetupUltrasonic();   
} </pre>
<p>The following is the setup function for the ultrasonic sensor; it will configure the <kbd>Trigger</kbd> pin as <kbd>OUTPUT</kbd> and the <kbd>Echo</kbd> pin as <kbd>INPUT</kbd>. The <kbd>pinMode()</kbd> function is used to set the pin as <kbd>INPUT</kbd> or <kbd>OUTPUT</kbd>:</p>
<pre>void SetupUltrasonic() 
{ 
 pinMode(Trig, OUTPUT); 
 pinMode(echo, INPUT);  
   
} </pre>
<p>After creating a <kbd>setup()</kbd> function, which initializes and sets the initial values, the <kbd>loop()</kbd> function does precisely what its name suggests, and loops consecutively, allowing your program to change and respond. Use it to actively control the Launchpad board.</p>
<p>The main loop of this is in the following code. This function is an infinite loop and calls the <kbd>Update_Ultra_Sonic()</kbd> function to update and print the ultrasonic readings through a serial port:</p>
<pre>void loop() 
{ 
    Update_Ultra_Sonic(); 
    delay(200); 
} </pre>
<p>The following code is the definition of the <kbd>Update_Ultra_Sonic()</kbd> function. This function will do the following operations. First it will take the trigger pin to the <kbd>LOW</kbd> state for <kbd>2</kbd> microseconds and <kbd>HIGH</kbd> for <kbd>10</kbd> microseconds. After <kbd>10</kbd> microseconds, it will again return the pin to the <kbd>LOW</kbd> state. This is according to the timing diagram. We already saw that 10 µs is the trigger pulse width.</p>
<p>After triggering with 10 µs, we have to read the time duration from the Echo pin. The time duration is the time taken for the sound to travel from the sensor to the object and from the object to the sensor receiver. We can read the pulse duration by using the <kbd>pulseIn()</kbd> function. After getting the time duration, we can convert the time into centimeters by using the <kbd>microsecondsToCentimeters()</kbd> function, as shown in the following code:</p>
<pre>void Update_Ultra_Sonic() 
{ 
  digitalWrite(Trig, LOW); 
  delayMicroseconds(2); 
  digitalWrite(Trig, HIGH); 
  delayMicroseconds(10); 
  digitalWrite(Trig, LOW); 
 
  duration = pulseIn(echo, HIGH); 
  // convert the time into a distance 
  cm = microsecondsToCentimeters(duration); 
   
  //Sending through serial port 
  Serial.print("distance="); 
  Serial.print("t"); 
  Serial.print(cm); 
  Serial.print("n"); 
   
} </pre>
<p>The following code is the conversion function from microseconds to distance in centimeters. The speed of sound is 340 m/s, that is, 29 microseconds per centimeter. So, we get the total distance by diving the total microseconds by 29/2:</p>
<pre>long microsecondsToCentimeters(long microseconds) 
{ 
return microseconds / 29 / 2; 
} </pre>
<p>After uploading the code, open the serial monitor from the Energia menu under <span class="packt_screen">Tools</span> | <span class="packt_screen">Serial Monitor</span> and change the baud rate to <span class="packt_screen">115200</span>. The values from the ultrasonic sensor are shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/3f4f56c0-8820-4164-b093-96609d030585.png" style="width:25.50em;height:23.25em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Output of the ultrasonic distance sensor in Energia serial monitor</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interfacing Tiva C LaunchPad with Python</h1>
                </header>
            
            <article>
                
<p>In this section, we will look at how to connect Tiva C LaunchPad with Python to receive data from Launchpad in a PC.</p>
<p>The <strong>PySerial</strong> module can be used for interfacing Launchpad to Python. The detailed documentation of PySerial and its installation procedure for Windows, Linux, and OS X can be found here :&#160;<a href="http://pyserial.sourceforge.net/pyserial.html"><span class="URLPACKT">http://pyserial.sourceforge.net/pyserial.html</span></a></p>
<p><a href="http://pyserial.sourceforge.net/pyserial.html"></a></p>
<p>PySerial is available in the Ubuntu package manager and it can be easily installed in Ubuntu using the following command in the Terminal:</p>
<pre>    <strong>$ sudo apt-get install python-serial</strong>  </pre>
<p>After installing the <kbd>python-serial</kbd> package, we can write Python code to interface Launchpad. The interfacing code is given in the following section.</p>
<p>The following code imports the Python <kbd>serial</kbd> module and the <kbd>sys</kbd> module. The <kbd>serial</kbd> module handles the serial ports of Launchpad and performs operations such as reading, writing, and so on. The <kbd>sys</kbd> module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter. It is always available:</p>
<pre>#!/usr/bin/env python 
import serial 
import sys </pre>
<p>When we plug Launchpad to the computer, the device registers on the OS as a virtual serial port. In Ubuntu, the device name looks like <kbd>/dev/ttyACMx</kbd>. Here, <span class="packt_screen">x</span> can be a number; if there is only one device, it will probably be 0. To interact with Launchpad, we need to handle this device file only.</p>
<p>The following code will try to open the serial port <kbd>/dev/ttyACM0</kbd> of Launchpad with a baud rate of <kbd>115200</kbd>. If it fails, it will print <kbd>Unable to open serial port</kbd>:</p>
<pre>try: 
    ser = serial.Serial('/dev/ttyACM0',115200) 
except: 
    print "Unable to open serial port" </pre>
<p>The following code will read the serial data until the serial character becomes a new line (<kbd>'n'</kbd>) and prints it on the Terminal. If we press <span class="KeyPACKT">Ctrl</span> + <span class="KeyPACKT">C</span> on the keyboard, to quit the program, it will exit by calling <kbd>sys.exit(0)</kbd>:</p>
<pre>while True: 
    try: 
        line = ser.readline() 
        print line 
    except: 
        print "Unable to read from device" 
        sys.exit(0) </pre>
<p>After saving the file, change the permission of the file to executable using the following command:</p>
<pre>    <strong>$ sudo chmod +X script_name</strong>
    <strong>$ ./ script_name</strong>  </pre>
<p>The output of the script will look like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/8883a773-2d2e-4bf9-b7ef-1cddc170630e.png" style="width:24.17em;height:14.83em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Output of the ultrasonic distance sensor in Energia serial monitor</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with the IR proximity sensor</h1>
                </header>
            
            <article>
                
<p>Infrared sensors are another method to find obstacles and the distance from the robot. The principle of infrared distance sensors is based on the infrared light that is reflected from a surface when hitting an obstacle. An IR receiver will capture the reflected light and the voltage is measured based on the amount of light received.</p>
<p>One of the popular IR range sensors is Sharp GP2D12. The product link can be found here:&#160;<a href="http://www.robotshop.com/en/sharp-gp2y0a21yk0f-ir-range-sensor.html"><span class="URLPACKT">http://www.robotshop.com/en/sharp-gp2y0a21yk0f-ir-range-sensor.html</span></a></p>
<p>The following image shows the Sharp GP2D12 sensor:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/b860054a-dc96-4bbc-adb2-1b64eec7fbd9.png" style="width:16.75em;height:7.67em;"/></div>
<p>The sensor sends out a beam of IR light and uses triangulation to measure the distance. The detection range of the GP2D12 is between 10 cm and 80 cm. The beam is 6 cm wide at a distance of 80 cm. The transmission and reflection of the IR light sensor is illustrated in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/08cd0547-f099-46c0-a2b1-6f56d60a8e2a.png" style="width:10.25em;height:13.08em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Obstacle sensing using IR light sensor</div>
<p>On the left of the sensor is an IR transmitter, which continuously sends IR radiation. After hitting into some objects, the IR light will reflect and it will be received by the IR receiver. The interfacing circuit of the IR sensor is shown here:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/4ac903e7-cd5f-4439-9768-00e2ada402f1.png" style="width:20.83em;height:14.08em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Pinout of Sharp IR sensor</div>
<p>The analog out pin <strong>Vo</strong> can be connected to the ADC pin of Launchpad. The interfacing code of the Sharp distance sensor with the Tiva C Launchpad is discussed further in this section. In this code, we select the 18th pin of Launchpad and set it to the ADC mode and read the voltage levels from the Sharp distance sensor. The range equation of the GP2D12 IR sensor is given as follows:</p>
<p><em>Range = (6,787 / (Volt - 3)) - 4</em></p>
<p>Here, <em>Volt</em> is the analog voltage value from the ADC of the Volt pin.</p>
<p>In this first section of the code, we set the 18th pin of Tiva C LaunchPad as the input pin and start a serial communication at a baud rate of 115200:</p>
<pre>int IR_SENSOR = 18; // Sensor is connected to the analog A3 
int intSensorResult = 0; //Sensor result 
float fltSensorCalc = 0; //Calculated value 
 
void setup() 
{ 
Serial.begin(115200); // Setup communication with computer <br/>   to present results serial monitor 
} </pre>
<p>In the following section of code, the controller continuously reads the analog pin and converts it to the distance value in centimeters:</p>
<pre>void loop() 
{ 
 
// read the value from the ir sensor 
intSensorResult = analogRead(IR_SENSOR); //Get sensor value 
 
//Calculate distance in cm according to the range equation 
fltSensorCalc = (6787.0 / (intSensorResult - 3.0)) - 4.0;  
 
Serial.print(fltSensorCalc); //Send distance to computer 
Serial.println(" cm"); //Add cm to result 
delay(200); //Wait 
} </pre>
<p>This is the basic code to interface a sharp distance sensor. There are some drawbacks with IR sensors. Some of them are as follows:</p>
<ul>
<li>We can't use them in direct or indirect sunlight, so it's difficult to use them in an outdoor robot</li>
<li>They may not work if the object is not&#160;reflective</li>
<li>The range equation only works within the range</li>
</ul>
<p>In the next section, we will discuss the IMU and its interfacing with Tiva C LaunchPad. An IMU can give the odometry data and it can be used as the input to navigation algorithms.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with Inertial Measurement Units</h1>
                </header>
            
            <article>
                
<p>An <strong>inertial measurement unit</strong> (<strong>IMU</strong>) is an electronic device that measures velocity, orientation, and gravitational forces using a combination of accelerometers, gyroscopes, and magnetometers. IMUs have a lot of applications in robotics; some of the applications are applied in balancing of <strong>unmanned aerial vehicles</strong> (<strong>UAVs</strong>) and robot navigation.</p>
<p>In this section, we will discuss the role of IMUs in mobile robot navigation and some of the latest IMUs on the market and their interfacing with Launchpad.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Inertial navigation</h1>
                </header>
            
            <article>
                
<p>An IMU provides acceleration and orientation relative to inertial space. If you know the initial position, velocity, and orientation, you can calculate the velocity by integrating the sensed acceleration and the second integration gives the position. To get the correct direction of the robot, the orientation of the robot is required; this can be obtained by integrating sensed angular velocity from a gyroscope.</p>
<p>The following diagram illustrates an inertial navigation system, which will convert IMU values to odometry data:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/96725089-cfd4-4614-9161-c6e5ea42f5b2.png" style="width:35.08em;height:14.75em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Block diagram of IMU</div>
<p>The values we get from the IMU are converted into navigational information using navigation equations and feeding them into estimation filters, such as the Kalman filter. The <strong>Kalman</strong> filter is an algorithm that estimates the state of a system from the measured data (<a href="http://en.wikipedia.org/wiki/Kalman_filter"><span class="URLPACKT">http://en.wikipedia.org/wiki/Kalman_filter</span></a>). The data from an <strong>inertial navigation system</strong> (<strong>INS</strong>) will have some drift because of the error from the accelerometer and gyroscope. To limit the drift, an INS is usually aided by other sensors that provide direct measurements of the integrated quantities. Based on the measurements and sensor error models, the Kalman filter estimates errors in the navigation equations and all the colored sensors' errors. The following diagram illustrates an aided inertial navigation system using the Kalman filter:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/eac139d5-1f99-4cfd-9e7c-2a8975f60b91.png" style="width:30.42em;height:22.17em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">IMU with inertial navigation system</div>
<p>Along with the motor encoders, the value from the IMU can be taken as the odometer value and it can be used for <strong>dead reckoning</strong>, the process of finding the current position of a moving object by using a previously determined position.</p>
<p>In the next section, we are going to look at one of the most popular IMUs from InvenSense, called <strong>MPU 6050</strong>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interfacing MPU 6050 with Tiva C LaunchPad</h1>
                </header>
            
            <article>
                
<p>The MPU-6000/MPU-6050 family of parts is the world's first and only six-axis motion tracking devices designed for the low power, low cost, and high-performance requirements of smartphones, tablets, wearable sensors, and robotics.</p>
<p>The MPU-6000/6050 devices combine a three-axis gyroscope and three-axis accelerometer on the silicon die together with an onboard digital motion processor capable of processing complex nine-axis motion fusion algorithms. The following diagram shows the system diagram of MPU 6050 and break out of MPU 6050:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/d3155f85-5dea-4496-b7e4-e43717a72ef1.png" style="width:30.67em;height:6.08em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Block diagram of MPU 6050</div>
<p>The breakout board of MPU 6050 is shown in the following diagram and it can be purchased from here&#160;<span class="URLPACKT"><a href="http://a.co/7C3yL96">http://a.co/7C3yL96</a>:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/f9d921ce-0ffe-4c31-a559-8eff293c3c11.png" style="width:15.75em;height:20.92em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">MPU 6050 breakout board</div>
<p>The connection from Launchpad to MPU 6050 is given in the following table. The remaining pins can be left disconnected:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>Launchpad pins</p>
</td>
<td>
<p>MPU6050 pins</p>
</td>
</tr>
<tr>
<td>
<p>+3.3V</p>
</td>
<td>
<p>VCC/VDD</p>
</td>
</tr>
<tr>
<td>
<p>GND</p>
</td>
<td>
<p>GND</p>
</td>
</tr>
<tr>
<td>
<p>PD0</p>
</td>
<td>
<p>SCL</p>
</td>
</tr>
<tr>
<td>
<p>PD1</p>
</td>
<td>
<p>SDA</p>
</td>
</tr>
</tbody>
</table>
<p>&#160;</p>
<p>The following diagram shows the interfacing of MPU 6050 and Tiva C Launchpad:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/f91bf3ea-20e4-4715-9754-9882297e09b9.png" style="width:30.83em;height:31.92em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Interfacing MPU 6050 breakout board to Launchpad</div>
<p>MPU 6050 and Launchpad communicate using the I2C protocol. The supply voltage is 3.3V and it is taken from Launchpad.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting the MPU 6050 library in Energia</h1>
                </header>
            
            <article>
                
<p>The interfacing code of Energia is discussed in this section. The interfacing code uses the <a href="https://github.com/jrowberg/i2cdevlib/zipball/master"><span class="URLPACKT">https://github.com/jrowberg/i2cdevlib/zipball/master</span></a> library for interfacing MPU 6050.</p>
<p>Download the ZIP file from the preceding link and navigate to <span class="packt_screen">Preference from File</span> | <span class="packt_screen">Preference in Energia</span>, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/b88d717b-08da-41dc-b6bd-fdbe7b916eda.png" style="width:35.67em;height:26.42em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Interfacing MPU 6050 breakout board to Launchpad</div>
<p>Go to <span class="packt_screen">Sketchbook location</span> under <span class="packt_screen">Preferences</span>, as seen in the preceding screenshot, and create a folder called <kbd>libraries</kbd>. Extract the files inside the <span class="packt_screen">Arduino</span> folder inside the ZIP file to the <kbd>sketchbook/libraries</kbd> location. The Arduino packages in this repository are also compatible with Launchpad. The extracted files contain the <kbd>I2Cdev</kbd>, <kbd>Wire</kbd>, and <kbd>MPU6050</kbd> packages that are required for the interfacing of the MPU 6050 sensor. There are other sensor packages that are present in the <kbd>libraries</kbd> folder but we are not using them now.</p>
<p>The preceding procedure is done in Ubuntu, but it is the same for Windows and macOS X.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interfacing code of Energia</h1>
                </header>
            
            <article>
                
<p>This code is used to read the raw value from MPU 6050 to Launchpad. It uses an MPU 6050 third-party library compatible with Energia IDE. The following are the explanations of each block of the code.</p>
<p>In this first section of code, we include the necessary headers for interfacing MPU 6050 to Launchpad, such as <kbd>12C</kbd>, <kbd>Wire</kbd> and the <kbd>MPU6050</kbd> library, and create an object of <kbd>MPU6050</kbd> with the name <kbd>accelgyro</kbd>. The <kbd>MPU6050.h</kbd> library contains a class named <kbd>MPU6050</kbd> to send and receive data to and from the sensor:</p>
<pre>#include "Wire.h" 
 
#include "I2Cdev.h" 
#include "MPU6050.h" 
 
MPU6050 accelgyro; </pre>
<p>In the following section, we start the I2C and serial communication to communicate with MPU 6050 and print sensor values through the serial port. The serial communication baud rate is <kbd>115200</kbd> and <kbd>Setup_MPU6050()</kbd> is the custom function to initialize the MPU 6050 communication:</p>
<pre>void setup() 
{ 
   
  //Init Serial port with 115200 buad rate 
  Serial.begin(115200);   
  Setup_MPU6050(); 
} </pre>
<p>The following section is the definition of the <kbd>Setup_MPU6050()</kbd> function. The <kbd>Wire</kbd> library allows you to communicate with the I2C devices. MPU 6050 can communicate using I2C. The <kbd>Wire.begin()</kbd> function will start the I2C communication between MPU 6050 and Launchpad; also, it will initialize the MPU 6050 device using the <kbd>initialize()</kbd> method defined in the <kbd>MPU6050</kbd> class. If everything is successful, it will print <span class="packt_screen">connection successful;</span> otherwise, it will print <span class="packt_screen">connection failed</span>:</p>
<pre>void Setup_MPU6050() 
{ 
   Wire.begin(); 
   
      // initialize device 
    Serial.println("Initializing I2C devices..."); 
    accelgyro.initialize(); 
 
    // verify connection 
    Serial.println("Testing device connections..."); 
    Serial.println(accelgyro.testConnection() ? "MPU6050 connection successful" : "MPU6050 connection failed"); 
} </pre>
<p>The following code is the <kbd>loop()</kbd> function, which continuously reads the sensor value and prints its values through the serial port: The <kbd>Update_MPU6050()</kbd> custom function is responsible for printing the updated value from MPU 6050:</p>
<pre>void loop() 
{ 
 
   //Update MPU 6050 
    Update_MPU6050(); 
  
} </pre>
<p>The definition of <kbd>Update_MPU6050()</kbd> is given as follows. It declares six variables to handle the accelerometer and gyroscope value in three-axis. The <kbd>getMotion6()</kbd> function in the MPU 6050 class is responsible for reading the new values from the sensor. After reading them, it will print via the serial port:</p>
<pre>void Update_MPU6050() 
{ 
   
   int16_t ax, ay, az; 
  int16_t gx, gy, gz; 
 
      // read raw accel/gyro measurements from device 
    accelgyro.getMotion6(&amp;ax, &amp;ay, &amp;az, &amp;gx, &amp;gy, &amp;gz); 
 
    // display tab-separated accel/gyro x/y/z values 
    Serial.print("i");Serial.print("t"); 
    Serial.print(ax); Serial.print("t"); 
    Serial.print(ay); Serial.print("t"); 
    Serial.print(az); Serial.print("t"); 
    Serial.print(gx); Serial.print("t"); 
    Serial.print(gy); Serial.print("t"); 
    Serial.println(gz); 
    Serial.print("n"); 
} </pre>
<p>The output from the serial monitor is shown here:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/43c41c23-6657-4d2b-8332-ab2ea0c1341e.png" style="width:34.00em;height:18.33em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Output from MPU 6050 in the serial monitor</div>
<p>We can read these values using the Python code that we used for ultrasonic. The following is the screenshot of the Terminal when we run the Python script:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/1731f2d5-8b4a-4609-94fb-c55811f65a8b.png" style="width:27.75em;height:15.50em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Output from MPU 6050 in the Linux Terminal</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have discussed the interfacing of the motors that we are using in our robot. We have looked at motor and encoder interfacing with a controller board called Tiva C Launchpad. We have discussed the controller code for interfacing motors and encoders. In the future, if the robot requires high accuracy and torque, we have looked at Dynamixel servos that can substitute current DC motors. We have also looked at the robotic sensors that can be used in our robot. The sensors we discussed are ultrasonic distance sensors, IR proximity sensors, and IMUs. These three sensors help in the navigation of the robot. We also discussed the basic code to interface these sensors to Tiva C LaunchPad. We will discuss the vision sensors used in this robot further in the next chapter.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the H-Bridge circuit?</li>
<li>What is a quadrature encoder?</li>
<li>What is the 4X encoding scheme?</li>
<li>How do we calculate displacement from encoder data?</li>
<li>What are the features of the Dynamixel actuator?</li>
<li>What are ultrasonic sensors and how do they work?</li>
<li>How do you calculate distance from the ultrasonic sensor?</li>
<li>What is the IR proximity sensor and how does it work?</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Read more about Energia programming at the following link:</p>
<p><a href="http://energia.nu/guide/">http://energia.nu/guide/</a></p>


            </article>

            
        </section>
    </div>
</body>
</html>