["```py\n    $ sudo apt-get install ros-kinetic-vision-opencv  \n```", "```py\n    $ sudo apt-get install ros-melodic-vision-opencv\n```", "```py\n    >>> import cv2\n    >>> cv2.__version__\n```", "```py\n#!/usr/bin/env python \nimport numpy as np \nimport cv2 \n```", "```py\nimg = cv2.imread('robot.jpg',0) \n```", "```py\ncv2.imshow('image', img) \ncv2.waitKey(0) \n```", "```py\ncv2.destroyAllWindows() \n```", "```py\n    $python image_read.py\n```", "```py\n#!/usr/bin/env python \nimport numpy as np \nimport cv2\n```", "```py\ncap = cv2.VideoCapture(0) \n```", "```py\nwhile(True): \n    # Capture frame-by-frame \n    ret, frame = cap.read() \n    # Display the resulting frame \n    cv2.imshow('frame', frame) \n    k = cv2.waitKey(30) \n    if k > 0: \n        break \n```", "```py\n$ sudo apt-get install ros-<version>-openni-launch\n```", "```py\n    $ sudo apt-get install ros-<version>-openni2-launch   \n```", "```py\n    $ roslaunch openni_launch openni.launch  \n```", "```py\n    $ rostopic list  \n```", "```py\n    $ rosrun image_view image_view image:=/camera/rgb/image_color  \n```", "```py\n    $ catkin-create-pkg sample_opencv_pkg sensor_msgs cv_bridge \n rospy std_msgs  \n```", "```py\nimport rospy\nimport sys\nimport cv2\nfrom sensor_msgs.msg import Image, CameraInfo\nfrom cv_bridge import CvBridge, CvBridgeError\nfrom std_msgs.msg import String\nimport numpy as np\n```", "```py\nclass cvBridgeDemo(): \n    def __init__(self): \n        self.node_name = \"cv_bridge_demo\" \n        #Initialize the ros node \n        rospy.init_node(self.node_name) \n\n        # What we do during shutdown \n        rospy.on_shutdown(self.cleanup) \n\n        # Create the cv_bridge object \n        self.bridge = CvBridge() \n\n        # Subscribe to the camera image and depth topics and set \n        # the appropriate callbacks \n        self.image_sub = \n rospy.Subscriber(\"/camera/rgb/image_raw\", Image, \n self.image_callback)        self.depth_sub = \n rospy.Subscriber(\"/camera/depth/image_raw\", Image, \n self.depth_callback) \n\n #Callback executed when the timer timeout \n      rospy.Timer(rospy.Duration(0.03), self.show_img_cb) \n\n      rospy.loginfo(\"Waiting for image topics...\")\n```", "```py\n    def show_img_cb(self,event): \n         try:  \n\n             cv2.namedWindow(\"RGB_Image\", cv2.WINDOW_NORMAL) \n             cv2.moveWindow(\"RGB_Image\", 25, 75) \n\n             cv2.namedWindow(\"Processed_Image\", cv2.WINDOW_NORMAL) \n             cv2.moveWindow(\"Processed_Image\", 500, 75) \n\n             # And one for the depth image \n             cv2.moveWindow(\"Depth_Image\", 950, 75) \n             cv2.namedWindow(\"Depth_Image\", cv2.WINDOW_NORMAL) \n\n             cv2.imshow(\"RGB_Image\",self.frame) \n             cv2.imshow(\"Processed_Image\",self.display_image) \n             cv2.imshow(\"Depth_Image\",self.depth_display_image) \n             cv2.waitKey(3) \n         except: \n             pass \n```", "```py\n    def image_callback(self, ros_image): \n        # Use cv_bridge() to convert the ROS image to OpenCV format \n        try: \n            self.frame = self.bridge.imgmsg_to_cv2(ros_image, \"bgr8\") \n        except CvBridgeError, e: \n            print e \n       pass \n\n        # Convert the image to a Numpy array since most cv2 functions \n        # require Numpy arrays. \n        frame = np.array(self.frame, dtype=np.uint8) \n\n        # Process the frame using the process_image() function \n        self.display_image = self.process_image(frame) \n\n```", "```py\n       def depth_callback(self, ros_image): \n        # Use cv_bridge() to convert the ROS image to OpenCV format \n        try: \n            # The depth image is a single-channel float32 image \n            depth_image = self.bridge.imgmsg_to_cv2(ros_image, \"32FC1\") \n        except CvBridgeError, e: \n            print e \n       pass \n        # Convert the depth image to a Numpy array since most cv2 functions \n        # require Numpy arrays. \n        depth_array = np.array(depth_image, dtype=np.float32) \n\n        # Normalize the depth image to fall between 0 (black) and 1 (white) \n        cv2.normalize(depth_array, depth_array, 0, 1, cv2.NORM_MINMAX) \n\n        # Process the depth image \n        self.depth_display_image = self.process_depth_image(depth_array) \n```", "```py\n    def process_image(self, frame): \n        # Convert to grayscale \n        grey = cv2.cvtColor(frame, cv.CV_BGR2GRAY) \n\n        # Blur the image \n        grey = cv2.blur(grey, (7, 7)) \n\n        # Compute edges using the Canny edge filter \n        edges = cv2.Canny(grey, 15.0, 30.0) \n\n        return edges \n```", "```py\n    def process_depth_image(self, frame): \n        # Just return the raw image for this demo \n        return frame \n```", "```py\n    def cleanup(self): \n        print \"Shutting down vision node.\" \n        cv2.destroyAllWindows()\n```", "```py\ndef main(args): \n    try: \n        cvBridgeDemo() \n        rospy.spin() \n    except KeyboardInterrupt: \n        print \"Shutting down vision node.\" \n        cv.DestroyAllWindows() \n\nif __name__ == '__main__': \n    main(sys.argv) \n```", "```py\n    $ chmod +X cv_bridge_demo.py  \n```", "```py\n    $ roslaunch openni_launch openni.launch  \n```", "```py\n    $ rosrun sample_opencv_pkg cv_bridge_demo.py  \n```", "```py\n    $ roslaunch astra_launch astra.launch  \n```", "```py\n    $ sudo apt-get install ros-kinetic-astra-camera\n    $ sudo apt-get install ros-kinetic-astra-launch  \n```", "```py\n    $ roslaunch openni_launch openni.launch  \n```", "```py\n    $ roslaunch astra_launch astra.launch  \n```", "```py\n    $ rosrun rviz rviz  \n```", "```py\n    $ sudo apt-get install ros-<version>-depthimage-to-laserscan\n```", "```py\n  <!-- Fake laser --> \n  <node pkg=\"nodelet\" type=\"nodelet\" \n name=\"laserscan_nodelet_manager\" args=\"manager\"/>  <node pkg=\"nodelet\" type=\"nodelet\" \n name=\"depthimage_to_laserscan\"        args=\"load depthimage_to_laserscan/DepthImageToLaserScanNodelet \n laserscan_nodelet_manager\"> \n    <param name=\"scan_height\" value=\"10\"/> \n    <param name=\"output_frame_id\" value=\"/camera_depth_frame\"/> \n    <param name=\"range_min\" value=\"0.45\"/> \n    <remap from=\"image\" to=\"/camera/depth/image_raw\"/> \n    <remap from=\"scan\" to=\"/scan\"/> \n  </node> \n```", "```py\n    $ roslaunch chefbot_gazebo gmapping_demo.launch  \n```"]