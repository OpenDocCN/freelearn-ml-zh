- en: Appendix C
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录C
- en: Computational Complexity
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计算复杂性
- en: '*An algorithm is a finite answer to an infinite number of questions*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法是对无限多个问题的有限回答*'
- en: — Stephen Kleene
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: — 斯蒂芬·克莱尼
- en: Computational complexity theory is the branch of theoretical computer science
    that is concerned with quantifying the resources needed to solve problems with
    algorithms. It asks questions such as “How much time is needed to multiply two
    integer numbers of ![n](img/file244.png "n") bits each?”, “Do you need more memory
    space to solve a problem than to check its solution?”, or “Is randomness useful
    in computational tasks?”.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 计算复杂性理论是理论计算机科学的一个分支，它关注于量化算法解决问题所需的资源。它提出的问题包括“需要多少时间来乘以两个![n](img/file244.png
    "n")位整数？”、“解决一个问题是否需要比检查其解决方案更多的内存空间？”或者“随机性在计算任务中是否有用？”。
- en: In this brief introduction to computational complexity, we will focus mainly
    on the concepts involved in estimating how much time is required to solve certain
    problems. For a thorough treatment of this and other topics (including space or
    memory complexity, the role of randomness in computation, approximation algorithms,
    and other advanced matters), you can check standard computational complexity books
    such as the ones by Sipser [[90](ch030.xhtml#Xsipser2012introduction)], Papadimitriou
    [[74](ch030.xhtml#Xpapadimitriou1993computational)], or Arora and Barak [[8](ch030.xhtml#Xarora2009computational)].
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节对计算复杂性的简要介绍中，我们将主要关注涉及估计解决某些问题所需时间的概念。对于这个主题和其他主题（包括空间或内存复杂性、计算中的随机性作用、近似算法和其他高级问题）的深入探讨，您可以查阅标准计算复杂性书籍，如Sipser
    [[90](ch030.xhtml#Xsipser2012introduction)]、Papadimitriou [[74](ch030.xhtml#Xpapadimitriou1993computational)]
    或 Arora 和 Barak [[8](ch030.xhtml#Xarora2009computational)] 的著作。
- en: To study the kind of questions posed in computational complexity theory, we
    need first to introduce a computational model that allows us to measure computation
    time, memory, and other resources. The usual choice is that of **Turing machines**.
    It is beyond the scope of this book to mathematically define what Turing machines
    are (for the details, check the books cited in the previous paragraph), but let
    us at least give an informal description so you can understand how we can use
    them to model computational tasks and to measure the resources involved in solving
    problems with them. Please notice that different textbooks use slightly different
    definitions of Turing machines, but it is straightforward to show that they are
    all equivalent in power.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了研究计算复杂性理论中提出的问题，我们首先需要引入一个计算模型，该模型允许我们测量计算时间、内存和其他资源。通常的选择是**图灵机**。本书的范围不包括对图灵机进行数学定义（有关详情，请参阅前一段中引用的书籍），但至少让我们给出一个非正式的描述，以便您了解我们如何使用它们来模拟计算任务以及如何测量使用它们解决问题所涉及的资源。请注意，不同的教科书对图灵机的定义略有不同，但可以很容易地证明它们在能力上是等效的。
- en: C.1 A few words on Turing machines
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C.1 关于图灵机的几点说明
- en: A Turing machine is a (theoretical) device that has a (potentially infinite)
    **tape** divided into **cells**. Each of these cells can store a symbol from a
    finite and fixed number of possibilities (usually, ![0](img/file12.png "0"), ![1](img/file13.png
    "1"), and a “blank” symbol to denote an empty cell). The machine also has a **head**
    that, at any given moment, is scanning one of the tape cells. Additionally, the
    machine is in a **state** (also from a finite number of fixed options) at any
    step in the computation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵机是一种（理论上的）设备，它有一个（可能无限大的）**带子**，带子被分成**单元格**。这些单元格中的每一个都可以存储来自有限且固定数量的可能性的符号（通常，![0](img/file12.png
    "0")、![1](img/file13.png "1")以及一个表示空单元格的“空白”符号）。机器还有一个**头**，在任何给定时刻，它正在扫描带子上的一个单元格。此外，机器在计算过程中的任何一步都处于一个**状态**（也是从有限数量的固定选项中选择的一个状态）。
- en: The machine has a list of instructions that, depending on the machine’s state
    and the content of the cell that the head is scanning, tell the machine what it
    should do next. This can involve changing the machine state, writing a different
    symbol on the cell that is being scanned, and moving the head one cell to the
    left or to the right. For instance, one such instruction could be “If the state
    is ![q_{2}](img/file1610.png "q_{2}") and the symbol being read is ![1](img/file13.png
    "1"), change the state to ![q_{5}](img/file1611.png "q_{5}"), change the symbol
    to ![0](img/file12.png "0"), and stay in the same cell,” while another could be
    “If the state is ![q_{0}](img/file1612.png "q_{0}") and the symbol is ![0](img/file12.png
    "0"), change the state to ![q_{1}](img/file1613.png "q_{1}"), leave the symbol
    unchanged, and move the head one cell to the right.”
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 机器有一系列指令，这些指令根据机器的状态和头正在扫描的单元格的内容，告诉机器接下来应该做什么。这可能包括改变机器状态，在正在扫描的单元格上写上不同的符号，并将头移动一个单元格到左边或右边。例如，这样的指令可能包括“如果状态是
    ![q_{2}](img/file1610.png "q_{2}") 并且正在读取的符号是 ![1](img/file13.png "1")，则将状态改为
    ![q_{5}](img/file1611.png "q_{5}")，将符号改为 ![0](img/file12.png "0")，并保持在同一单元格”，而另一个可能包括“如果状态是
    ![q_{0}](img/file1612.png "q_{0}") 并且符号是 ![0](img/file12.png "0")，则将状态改为 ![q_{1}](img/file1613.png
    "q_{1}")，符号保持不变，并将头向右移动一个单元格。”
- en: Important note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A Turing machine is a (theoretical) device that has an unbounded tape divided
    into cells and a head that scans one of those cells. At any given moment, the
    machine is in an internal state from a finite number of possibilities. The instructions
    of the machine specify, depending on the machine state and the content of the
    cell that the head is scanning, what the next state is, the new content of the
    cell, and the action of the machine (move left, move right, or stay, for instance).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵机是一种（理论上的）设备，它有一个无限长的带子，带子被分成单元格，并且有一个头扫描这些单元格中的一个。在任何给定时刻，机器处于有限数量的内部状态之一。机器的指令根据机器状态和头正在扫描的单元格的内容指定下一个状态、单元格的新内容以及机器的动作（例如，向左移动、向右移动或保持不动）。
- en: 'In order to perform a computation, the input is given as a finite string of
    symbols on the tape (the rest are left blank). Then, the Turing machine operates
    in the following way: it starts in a predefined initial state and with its head
    scanning the first symbol of the input; then, it changes its state, tape content,
    and head position following its instructions in discrete steps. Eventually, the
    machine can stop because it reaches a predefined, halting state. If the machine
    stops, the output of the computation is the string of symbols written on the tape.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行计算，输入作为带子上有限符号的字符串给出（其余部分留空）。然后，图灵机按照以下方式操作：它从一个预定义的初始状态开始，并且头扫描输入的第一个符号；然后，它根据其指令在离散步骤中改变其状态、带子内容和头位置。最终，机器可以停止，因为它达到了一个预定义的、停止状态。如果机器停止，计算的输出是带子上写下的符号字符串。
- en: To learn more…
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息…
- en: 'It is not guaranteed that a Turing machine will stop for all its inputs. In
    fact, it can be proved that determining whether a Turing machine will eventually
    stop with a given input (what is usually called the **halting problem**) is unsolvable
    in a very precise way: there is no algorithm that can give the correct answer
    for every possible Turing machine and every possible input. Check the book by
    Sipser [[90](ch030.xhtml#Xsipser2012introduction)] for a proof of this amazing
    fact.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 并不能保证图灵机对所有输入都会停止。实际上，可以证明，确定一个图灵机是否最终会停止给定输入（通常称为**停机问题**）以一种非常精确的方式是不可解的：没有算法可以为每个可能的图灵机和每个可能的输入给出正确答案。请参阅Sipser的书籍[[90](ch030.xhtml#Xsipser2012introduction)]以了解这一惊人事实的证明。
- en: Turing machines may seem like too simple a model, but it can be proved that
    any computation that can be carried out with any other reasonable computational
    model can also be carried out with a Turing machine (maybe with some slowdown).
    For instance, it is rather straightforward to prove that if we extend Turing machines
    by giving them multiple tapes (**multi-tape Turing** **machines**) or the possibility
    of non-deterministically choosing among several instructions for the same state-symbol
    situation (**non-deterministic** **Turing machines**), the new devices aren’t
    more powerful than our original single-tape, deterministic Turing machines (again,
    see the book by Sipser [[90](ch030.xhtml#Xsipser2012introduction)] for all the
    details). The same happens if we consider models that are much closer to the actual
    architecture of modern computers, such as the **Random-Access Machines** model
    (see Section 3.4 in the book by Savage [[84](ch030.xhtml#Xsavage1998models)]),
    or even models, such as that of **while-Programs** (see the book by Kfoury, Moll,
    and Arbib [[58](ch030.xhtml#Xkfoury2012programming)]) that are based on common
    programming languages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵机可能看起来太简单了，但可以证明，任何可以用任何其他合理计算模型完成的计算也可以用图灵机完成（可能有一些减速）。例如，可以相当直接地证明，如果我们通过给图灵机添加多个磁带（**多带图灵机**）或非确定性地选择相同状态-符号情况下的几个指令的可能性（**非确定性图灵机**）来扩展图灵机，新设备并不比我们原始的单带确定性图灵机更强大（再次，请参阅Sipser的书籍[[90](ch030.xhtml#Xsipser2012introduction)]以获取所有详细信息）。如果我们考虑更接近现代计算机实际架构的模型，例如**随机访问机**模型（参见Savage的书籍中的第3.4节[[84](ch030.xhtml#Xsavage1998models)]），或者基于常见编程语言的模型，如**while程序**（参见Kfoury、Moll和Arbib的书籍[[58](ch030.xhtml#Xkfoury2012programming)]），情况也是如此。
- en: This has led to the firm belief that Turing machines indeed formally capture
    the informal notion of what an algorithm is. This fact is usually known as the
    **Church-Turing thesis**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了坚定的信念，即图灵机确实形式上捕捉了算法的非正式概念。这个事实通常被称为**丘奇-图灵论题**。
- en: C.2 Measuring computational time
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C.2 计算时间测量
- en: 'We can say that the Church-Turing thesis is simply stating that, if you are
    only interested in identifying which tasks can be solved algorithmically and which
    cannot, you can just use any of a wide number of equivalent models: single-tape
    Turing machines, multi-tape Turing machines, non-deterministic Turing machines,
    Random-Access Machines, while-Programs, and many, many others. Each of them will
    give you exactly the same power.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，丘奇-图灵论题只是简单地陈述，如果你只对确定哪些任务可以通过算法解决以及哪些不能解决感兴趣，你只需使用大量等效模型中的任何一个：单带图灵机、多带图灵机、非确定性图灵机、随机访问机、while程序，以及许多其他模型。每个模型都会给你带来完全相同的能力。
- en: But be cautious! If you care about the resources needed to carry out the computations
    (and that is what computational complexity is all about), then the choice of the
    model can be important. So let’s fix, for now, the single-tape Turing machines
    (the ones that we have described informally in the previous section) as our computational
    model. In this way, we can easily measure the time needed to carry out a certain
    computation with one of these Turing machines as the number of steps that it must
    take to complete it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但要小心！如果你关心执行计算所需的资源（这正是计算复杂性的全部内容），那么模型的选择可能很重要。因此，现在让我们固定单带图灵机（我们在上一节中非正式地描述过的那些）作为我们的计算模型。这样，我们可以很容易地测量使用这些图灵机之一完成特定计算所需的时间，即它必须完成它的步骤数。
- en: That works well for a fixed Turing machine with a particular input, but we are
    usually more interested in analyzing how the running time grows with the size
    of the input than we are in finding concrete running-time values for concrete
    problem instances. For example, we could be interested in knowing whether the
    time needed for a certain task grows so rapidly that it quickly becomes unfeasible
    to solve the problem when the input size becomes moderately big.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于具有特定输入的固定图灵机效果很好，但我们通常更感兴趣的是分析运行时间如何随着输入大小的增长而增长，而不是寻找具体问题实例的具体运行时间值。例如，我们可能想知道，对于某个任务所需的时间增长是否如此之快，以至于当输入大小适中时，解决问题变得不可行。
- en: 'For this reason, we will define the running time of a Turing machine as a function
    of the input length, not as a function of the particular input. Namely, the running
    time of a Turing machine ![M](img/file704.png "M") is a function ![T](img/file74.png
    "T") that takes as input a non-negative integer ![n](img/file244.png "n") and
    returns the maximum number of steps that ![M](img/file704.png "M") performs with
    an input ![x](img/file269.png "x") of ![n](img/file244.png "n") bits before it
    stops. Notice that this is a worst-case definition of running-time: it is defined
    in terms of the string that needs the most time in order to be processed. Note
    also that, if a machine does not stop for some inputs, its running time for inputs
    of those lengths will be infinite. This is not a problem for our purposes, because
    we will only consider machines that always stop.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将图灵机的运行时间定义为输入长度的函数，而不是特定输入的函数。也就是说，图灵机 ![M](img/file704.png "M") 的运行时间是一个函数
    ![T](img/file74.png "T")，它接受一个非负整数 ![n](img/file244.png "n") 作为输入，并在停止之前返回 ![M](img/file704.png
    "M") 在 ![n](img/file244.png "n") 位输入 ![x](img/file269.png "x") 上执行的最大步数。请注意，这是一个最坏情况的定义：它是基于需要最多时间处理的字符串来定义的。还要注意，如果一个机器对于某些输入不会停止，那么这些长度的输入的运行时间将是无限的。这对我们来说不是问题，因为我们只会考虑总是停止的机器。
- en: Important note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: The running time of a Turing machine ![M](img/file704.png "M") is a function
    ![T](img/file74.png "T") such that ![T(n)](img/file1614.png "T(n)") is the maximum
    number of steps that ![M](img/file704.png "M") performs when given an input of
    length ![n](img/file244.png "n").
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵机 ![M](img/file704.png "M") 的运行时间是一个函数 ![T](img/file74.png "T")，其中 ![T(n)](img/file1614.png
    "T(n)") 是 ![M](img/file704.png "M") 在给定长度为 ![n](img/file244.png "n") 的输入时执行的最大步数。
- en: For other computational models, running times can be defined in analogous ways.
    For instance, for multi-tape Turing machines, the running time is again measured
    as the maximum number of steps performed on inputs of size ![n](img/file244.png
    "n"). For computational models that use idealized programming languages (the while-Programs
    model, for instance) or abstract architectures (the Random-Access Machines model),
    running time can be defined as the maximum number of basic instructions (setting
    a variable to zero, incrementing a variable, comparing the value of two variables...)
    executed with inputs of size ![n](img/file244.png "n").
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他计算模型，运行时间可以以类似的方式定义。例如，对于多带图灵机，运行时间再次被测量为在大小为 ![n](img/file244.png "n")
    的输入上执行的最大步数。对于使用理想化编程语言（例如while-Programs模型）或抽象架构（例如随机访问机器模型）的计算模型，运行时间可以定义为在大小为
    ![n](img/file244.png "n") 的输入上执行的最大基本指令（将变量设置为0，增加变量，比较两个变量的值...）。
- en: C.3 Asymptotic complexity
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C.3 渐近复杂度
- en: 'In order to compare different running times associated with different Turing
    machines, it is convenient to perform some simplifications. We usually do not
    care about whether the running time of a Turing machine is exactly ![T_{1}(n)
    = 4321n^{2} + 784n + 142](img/file1615.png "T_{1}(n) = 4321n^{2} + 784n + 142")
    or, rather, ![T_{2}(n) = n^{3} + 3n^{2} + 5n + 3](img/file1616.png "T_{2}(n) =
    n^{3} + 3n^{2} + 5n + 3"). In fact, we are more interested in whether ![T(n)](img/file1614.png
    "T(n)") grows roughly like ![n^{3}](img/file1617.png "n^{3}") or like ![n^{2}](img/file1618.png
    "n^{2}"), because this implies a qualitative difference: for values of ![n](img/file244.png
    "n") that are big enough, any polynomial of degree ![3](img/file472.png "3") grows
    more rapidly than any polynomial of ![2](img/file302.png "2"). In the context
    of computational complexity theory, we would always prefer a ![T(n)](img/file1614.png
    "T(n)") that grows as ![n^{2}](img/file1618.png "n^{2}") over one that grows as
    ![n^{3}](img/file1617.png "n^{3}"), because its behavior for big inputs (its asymptotic
    growth, in other words) is better.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较不同图灵机相关的不同运行时间，进行一些简化是方便的。我们通常不关心一个图灵机的运行时间是否正好是 ![T_{1}(n) = 4321n^{2}
    + 784n + 142](img/file1615.png "T_{1}(n) = 4321n^{2} + 784n + 142") 或者，更确切地说，![T_{2}(n)
    = n^{3} + 3n^{2} + 5n + 3](img/file1616.png "T_{2}(n) = n^{3} + 3n^{2} + 5n +
    3")。实际上，我们更感兴趣的是 ![T(n)](img/file1614.png "T(n)") 是否大致像 ![n^{3}](img/file1617.png
    "n^{3}") 或者像 ![n^{2}](img/file1618.png "n^{2}") 增长，因为这表明了质的差异：对于足够大的 ![n](img/file244.png
    "n") 值，任何三次多项式都比任何二次多项式增长得更快。在计算复杂度理论的背景下，我们总是更倾向于 ![T(n)](img/file1614.png "T(n)")
    以 ![n^{2}](img/file1618.png "n^{2}") 的速度增长，而不是以 ![n^{3}](img/file1617.png "n^{3}")
    的速度增长，因为它的行为对于大输入（即其渐近增长）更好。
- en: This intuitive idea is captured by the famous **Big O notation**. Given two
    time functions ![T_{1}(n)](img/file1619.png "T_{1}(n)") and ![T_{2}(n)](img/file1620.png
    "T_{2}(n)"), we say that ![T_{1}(n)](img/file1619.png "T_{1}(n)") is ![O(T_{2}(n))](img/file1621.png
    "O(T_{2}(n))") (and we read it is as “![T_{1}(n)](img/file1619.png "T_{1}(n)")
    is Big O of ![T_{2}(n)](img/file1620.png "T_{2}(n)")”) if there exist an integer
    constant ![n_{0}](img/file1622.png "n_{0}") and a real constant ![C > 0](img/file1262.png
    "C > 0") such that for all ![n \geq n_{0}](img/file1623.png "n \geq n_{0}") it
    holds that
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个直观的想法被著名的 **大 O 符号** 所捕捉。给定两个时间函数 ![T_{1}(n)](img/file1619.png "T_{1}(n)")
    和 ![T_{2}(n)](img/file1620.png "T_{2}(n)"), 我们说 ![T_{1}(n)](img/file1619.png "T_{1}(n)")
    是 ![O(T_{2}(n))](img/file1621.png "O(T_{2}(n))")（并且我们读作“![T_{1}(n)](img/file1619.png
    "T_{1}(n)") 是 ![T_{2}(n)](img/file1620.png "T_{2}(n)") 的大 O”）如果存在一个整数常数 ![n_{0}](img/file1622.png
    "n_{0}") 和一个实数常数 ![C > 0](img/file1262.png "C > 0")，使得对于所有 ![n \geq n_{0}](img/file1623.png
    "n \geq n_{0}")，它都成立。
- en: '![T_{1}(n) \leq CT_{2}(n).](img/file1624.png "T_{1}(n) \leq CT_{2}(n).")'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![T_{1}(n) \leq CT_{2}(n).](img/file1624.png "T_{1}(n) \leq CT_{2}(n).")'
- en: For instance, you can check that ![4321n^{2} + 784n + 142](img/file1625.png
    "4321n^{2} + 784n + 142") is ![O(n^{3} + 3n^{2} + 5n + 3)](img/file1626.png "O(n^{3}
    + 3n^{2} + 5n + 3)").
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以检查 ![4321n^{2} + 784n + 142](img/file1625.png "4321n^{2} + 784n + 142")
    是 ![O(n^{3} + 3n^{2} + 5n + 3)](img/file1626.png "O(n^{3} + 3n^{2} + 5n + 3)").
- en: The main idea behind this definition is that if ![T_{1}(n)](img/file1619.png
    "T_{1}(n)") is ![O(T_{2}(n))](img/file1621.png "O(T_{2}(n))"), then the growth
    of ![T_{1}](img/file1627.png "T_{1}") is not worse than that of ![T_{2}(n)](img/file1620.png
    "T_{2}(n)"). For example, it is easy to prove that ![n^{a}](img/file1628.png "n^{a}")
    is ![O(n^{b})](img/file1629.png "O(n^{b})") whenever ![a \leq b](img/file1630.png
    "a \leq b") and that ![n^{a}](img/file1628.png "n^{a}") is ![O(2^{n})](img/file1631.png
    "O(2^{n})") for any ![a](img/file16.png "a"). But, on the other hand, ![n^{b}](img/file1632.png
    "n^{b}") is not ![O(n^{a})](img/file1633.png "O(n^{a})") and ![2^{n}](img/file256.png
    "2^{n}") is not ![O(n^{a})](img/file1633.png "O(n^{a})"). See *Figure* * [*C.1*](#FigureC.1)
    for an example with linear, quadratic, cubic, and exponential functions. Notice
    how the exponential function eventually dominates all the others despite having
    ![10^{- 4}](img/file1634.png "10^{- 4}") as its coefficient.*
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义背后的主要思想是，如果 ![T_{1}(n)](img/file1619.png "T_{1}(n)") 是 ![O(T_{2}(n))](img/file1621.png
    "O(T_{2}(n))")，那么 ![T_{1}](img/file1627.png "T_{1}") 的增长不会比 ![T_{2}(n)](img/file1620.png
    "T_{2}(n)") 差。例如，很容易证明当 ![a \leq b](img/file1630.png "a \leq b") 时，![n^{a}](img/file1628.png
    "n^{a}") 是 ![O(n^{b})](img/file1629.png "O(n^{b})")，并且对于任何 ![a](img/file16.png
    "a")，![n^{a}](img/file1628.png "n^{a}") 是 ![O(2^{n})](img/file1631.png "O(2^{n})")。但是，另一方面，![n^{b}](img/file1632.png
    "n^{b}") 不是 ![O(n^{a})](img/file1633.png "O(n^{a})")，![2^{n}](img/file256.png
    "2^{n}") 也不是 ![O(n^{a})](img/file1633.png "O(n^{a})")。参见 *图* * [*C.1*](#FigureC.1)
    以了解线性、二次、三次和指数函数的增长示例。注意指数函数最终如何支配所有其他函数，尽管其系数为 ![10^{- 4}](img/file1634.png "10^{-
    4}")。
- en: '*![Figure C.1: Growth of linear, quadratic, cubic, and exponential functions](img/file1635.png)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*![图 C.1：线性、二次、三次和指数函数的增长](img/file1635.png)'
- en: '**Figure C.1**: Growth of linear, quadratic, cubic, and exponential functions'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 C.1**：线性、二次、三次和指数函数的增长'
- en: Important note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Given two non-negative functions ![T_{1}(n)](img/file1619.png "T_{1}(n)") and
    ![T_{2}(n)](img/file1620.png "T_{2}(n)"), we say that ![T_{1}(n)](img/file1619.png
    "T_{1}(n)") is ![O(T_{2}(n))](img/file1621.png "O(T_{2}(n))") if there exist ![n_{0}](img/file1622.png
    "n_{0}") and ![C > 0](img/file1262.png "C > 0") such that
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个非负函数 ![T_{1}(n)](img/file1619.png "T_{1}(n)") 和 ![T_{2}(n)](img/file1620.png
    "T_{2}(n)"), 我们说 ![T_{1}(n)](img/file1619.png "T_{1}(n)") 是 ![O(T_{2}(n))](img/file1621.png
    "O(T_{2}(n))")，如果存在 ![n_{0}](img/file1622.png "n_{0}") 和 ![C > 0](img/file1262.png
    "C > 0") 使得
- en: '![T_{1}(n) \leq CT_{2}(n)](img/file1636.png "T_{1}(n) \leq CT_{2}(n)")'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![T_{1}(n) \leq CT_{2}(n)](img/file1636.png "T_{1}(n) \leq CT_{2}(n)")'
- en: for every ![n \geq n_{0}](img/file1623.png "n \geq n_{0}").
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个 ![n \geq n_{0}](img/file1623.png "n \geq n_{0}")。
- en: Big O notation is extremely useful to estimate the behavior of running times
    without having to focus on small, cumbersome details. If the running time of a
    Turing machine is ![4321n^{2} + 784n + 142](img/file1625.png "4321n^{2} + 784n
    + 142"), we can just say that it is ![O(n^{2})](img/file1637.png "O(n^{2})") and
    forget about the particular coefficients in the time function. This is also the
    reason why we can abstractly think about the number of steps and not, for example,
    milliseconds. The particular amount of time that each step takes is a constant
    that will be “absorbed” by the Big O notation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大O符号对于估计运行时间的行为非常有用，而无需关注小而繁琐的细节。如果图灵机的运行时间是 ![4321n^{2} + 784n + 142](img/file1625.png
    "4321n^{2} + 784n + 142")，我们只需说它是 ![O(n^{2})](img/file1637.png "O(n^{2})")，并忘记时间函数中的特定系数。这也是为什么我们可以抽象地思考步骤的数量，而不是例如毫秒。每个步骤所花费的特定时间是一个常数，将被“吸收”到大O符号中。
- en: 'However, this comes at a price. A running time such as ![10^{100}n^{2}](img/file1638.png
    "10^{100}n^{2}") is certainly ![O(n^{2})](img/file1637.png "O(n^{2})"). But it
    is not preferable to ![n^{3}](img/file1617.png "n^{3}") unless ![n > 10^{100}](img/file1639.png
    "n > 10^{100}"), something that will never happen in practical situations, because
    ![10^{100}](img/file1640.png "10^{100}") is much, much bigger than the number
    of atoms in the visible universe. So use this notation wisely: with Big O comes
    Big Responsibility.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也有代价。例如，![10^{100}n^{2}](img/file1638.png "10^{100}n^{2}")这样的运行时间当然是![O(n^{2})](img/file1637.png
    "O(n^{2})")。但除非![n > 10^{100}](img/file1639.png "n > 10^{100}")，这在实际情况下永远不会发生，因为![10^{100}](img/file1640.png
    "10^{100}")远远大于可见宇宙中的原子数量。所以请明智地使用这个符号：大O意味着大责任。
- en: C.4 P and NP
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C.4 P 和 NP
- en: As we mentioned at the beginning of this appendix, computational complexity
    theory studies the amount of resources needed to solve problems with algorithms.
    So far, we have focused on how to mathematically define the notion of algorithm
    with the help of Turing machines and on how to measure the time needed to perform
    computations with them. Now, we turn our attention to defining computational problems
    and classifying them according to the time they take to be solved. That is, we
    will think in terms of their inherent complexity and not in terms of specific
    algorithms.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在附录开头提到的，计算复杂性理论研究用算法解决问题所需资源量。到目前为止，我们关注的是如何借助图灵机来数学上定义算法的概念，以及如何测量使用它们进行计算所需的时间。现在，我们将注意力转向定义计算问题和根据它们被解决所需的时间对它们进行分类。也就是说，我们将从它们固有的复杂性来思考，而不是从特定的算法来思考。
- en: In computational complexity theory, a **problem** consists of an infinite number
    of instances or inputs for which an output value needs to be returned. For example,
    we may be given two natural numbers and asked to compute their product. Or we
    may be given a graph and asked to check if it has a Hamiltonian path or not. In
    both cases, the number of possible inputs is infinite and there is a well-defined
    output or answer associated with each such input.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算复杂性理论中，一个**问题**由需要返回输出值的无穷多个实例或输入组成。例如，我们可能被给出两个自然数并要求计算它们的乘积。或者我们可能被给出一个图并要求检查它是否有哈密顿路径。在这两种情况下，可能的输入数量是无限的，并且与每个这样的输入相关联都有一个定义良好的输出或答案。
- en: 'Problem instances are usually encoded as binary strings in some way. For example,
    we can represent a natural number by its binary expansion or a graph by (the concatenation
    of the rows of) its adjacency matrix. In the same way, outputs can also be represented
    by binary strings. Consequently, a problem can be identified with a function that
    takes a binary string as its input and returns a binary string as its output.
    But a Turing machine does exactly that: it receives binary strings as inputs and
    returns binary strings as outputs. This allows us to study which problems can
    be solved with Turing machines and how much time is needed to solve them.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 问题实例通常以某种方式编码为二进制字符串。例如，我们可以用其二进制展开式来表示一个自然数，或者用一个图及其邻接矩阵的行（连接）来表示一个图。同样，输出也可以用二进制字符串表示。因此，一个问题可以用一个函数来识别，该函数以二进制字符串作为输入并返回二进制字符串作为输出。但图灵机正是这样做的：它接收二进制字符串作为输入并返回二进制字符串作为输出。这使得我们可以研究哪些问题可以用图灵机解决以及解决它们需要多少时间。
- en: In computational complexity, the simplest category of problem that we can consider
    is that of **decision problems**, in which the output is a single bit (we usually
    identify ![1](img/file13.png "1") with “true” and ![0](img/file12.png "0") with
    “false”). Examples of decision problems include determining whether a natural
    number ![m](img/file259.png "m") is prime, determining whether a graph has a Hamiltonian
    path, and determining whether a Turing machine stops for all its inputs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算复杂性理论中，我们可以考虑的最简单的问题类别是**决策问题**，其输出是一个单一的比特（我们通常将![1](img/file13.png "1")与“真”相对应，将![0](img/file12.png
    "0")与“假”相对应）。决策问题的例子包括确定一个自然数![m](img/file259.png "m")是否为素数，确定一个图是否具有哈密顿路径，以及确定图灵机是否对所有输入都停止。
- en: We say that a Turing machine is a **decider** for a decision problem if, given
    as input a binary string representing an instance of the problem, it eventually
    stops and returns the correct output (![0](img/file12.png "0") or ![1](img/file13.png
    "1")) for that instance. In that case, we also say that the Turing machine **solves**
    or **decides** the problem. There exist deciders for the problems of determining
    whether a number is prime and of determining whether a graph has a Hamiltonian
    path, but not for the problem of determining whether a Turing machine stops for
    all of its inputs (this is a consequence of the unsolvability of the halting problem
    that we mentioned earlier).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说一个图灵机是某个决策问题的**决定器**，如果给定一个表示问题实例的二进制字符串作为输入，它最终会停止并返回该实例的正确输出（![0](img/file12.png
    "0") 或 ![1](img/file13.png "1")）。在这种情况下，我们也说图灵机**解决**或**决定**了该问题。存在决定器可以解决确定一个数是否为素数和确定一个图是否具有哈密顿路径的问题，但不存在决定器可以解决确定图灵机对所有输入都停止的问题（这是之前提到的停机问题不可解性的一个后果）。
- en: Once we know that a problem has a decider, we can try to further refine its
    classification by taking into account the resources used by the decider. This
    leads, for instance, to the definition of the famous ![P](img/file1.png "P") (short
    for “polynomial time”) class. We say that a decision problem ![A](img/file183.png
    "A") is in ![P](img/file1.png "P") if there exists a decider for ![A](img/file183.png
    "A") that runs in polynomial time. That is, there exists a Turing machine ![D](img/file1101.png
    "D") that decides ![A](img/file183.png "A") and whose running time ![T(n)](img/file1614.png
    "T(n)") is ![O(n^{a})](img/file1633.png "O(n^{a})") for some non-negative integer
    ![a](img/file16.png "a"). Notice that, for a problem to be in ![P](img/file1.png
    "P"), it is enough to find one polynomial-time decider for it. However, in order
    to show that a decision problem ![A](img/file183.png "A") is not in ![P](img/file1.png
    "P"), we need to prove that no Turing machine running in polynomial time is able
    to decide ![A](img/file183.png "A"). This is usually much, much harder to do.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道一个问题有一个决定器，我们就可以通过考虑决定器使用的资源来进一步细化其分类。这导致了著名的![P](img/file1.png "P")（代表“多项式时间”）类的定义。我们说一个决策问题![A](img/file183.png
    "A")属于![P](img/file1.png "P")，如果存在一个决定![A](img/file183.png "A")的图灵机，它在多项式时间内运行。也就是说，存在一个图灵机![D](img/file1101.png
    "D")可以决定![A](img/file183.png "A")，并且其运行时间![T(n)](img/file1614.png "T(n)")对于某个非负整数![a](img/file16.png
    "a")是![O(n^{a})](img/file1633.png "O(n^{a})")。请注意，对于一个问题来说，要属于![P](img/file1.png
    "P")类，找到其中一个多项式时间的决定器就足够了。然而，为了证明一个决策问题![A](img/file183.png "A")不属于![P](img/file1.png
    "P")，我们需要证明没有任何运行在多项式时间内的图灵机能够决定![A](img/file183.png "A")。这通常要难得多。
- en: As an example, a celebrated result by Agrawal, Kayal, and Saxen [[5](ch030.xhtml#Xagrawal2004primes)]
    shows that the problem of determining whether a natural number is a prime is indeed
    in ![P](img/file1.png "P"). Other, simpler examples of problems in ![P](img/file1.png
    "P") include checking whether a number is a perfect square or checking whether
    a binary string is a palindrome (that is, it reads the same from left to right
    and from right to left). However, for the problem of determining whether a graph
    has a Hamiltonian path, we do not know whether it is in ![P](img/file1.png "P")
    or not. We very strongly believe that it is not in ![P](img/file1.png "P"), but
    despite the best efforts of thousands of mathematicians over several decades,
    we still can’t prove it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Agrawal、Kayal和Saxen [[5](ch030.xhtml#Xagrawal2004primes)] 提出的一个著名结果表明，确定一个自然数是否为素数的问题确实属于
    ![P](img/file1.png "P") 类。![P](img/file1.png "P") 类中的其他，更简单的问题示例包括检查一个数是否为完全平方数或检查一个二进制字符串是否为回文（即从左到右和从右到左读都一样）。然而，对于确定一个图是否有哈密顿路径的问题，我们不知道它是否属于
    ![P](img/file1.png "P") 类。我们非常坚信它不属于 ![P](img/file1.png "P") 类，但尽管数千名数学家在几十年的时间里付出了最大的努力，我们仍然无法证明这一点。
- en: Important note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We define ![P](img/file1.png "P") as the class of decision problems that can
    be solved with Turing machines in polynomial time.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 ![P](img/file1.png "P") 定义为可以用图灵机在多项式时间内解决的问题的决策问题类。
- en: Actually, ![P](img/file1.png "P") is interesting for several reasons. First,
    it is quite robust. We have defined it in terms of the computation time required
    by deciders that are single-tape Turing machines. However, if we had chosen another
    computational model such as, for instance, multi-tape Turing machines, then we
    would have arrived at exactly the same set of problems. This is so because it
    is possible to simulate a multi-tape Turing machine with a single-tape Turing
    machine with just a polynomial overhead in running time. The same is true for
    any other reasonable (classical) computational model, so although the particular
    running time might differ from one model to another (say ![O(n^{4}](img/file1641.png
    "O(n^{4}")) with single-tape Turing machines and ![O(n^{2})](img/file1637.png
    "O(n^{2})") with ![2](img/file302.png "2")-tape Turing machines), one will be
    polynomial if and only if the other is.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，![P](img/file1.png "P") 类有几个有趣的原因。首先，它非常稳健。我们是用单带图灵机所需的计算时间来定义它的。然而，如果我们选择了另一个计算模型，例如，多带图灵机，那么我们会得到完全相同的问题集合。这是因为可以用单带图灵机模拟多带图灵机，只需在运行时间上增加多项式开销。对于任何其他合理的（经典）计算模型也是如此，因此，尽管特定的运行时间可能因模型而异（例如，单带图灵机上的
    ![O(n^{4})](img/file1641.png "O(n^{4}")) 和 ![2](img/file302.png "2")-带图灵机上的 ![O(n^{2})](img/file1637.png
    "O(n^{2})")），一个将是多项式时间，当且仅当另一个是。
- en: What is more, ![P](img/file1.png "P") seems to capture quite well the notion
    of a problem being efficiently solvable. It is true that in ![P](img/file1.png
    "P") we allow running times such as ![n^{1000}](img/file1642.png "n^{1000}"),
    which can hardly be deemed as efficient. However, the running time of naturally-occurring
    problems that we can prove to be in ![P](img/file1.png "P") is typically much
    more tame, such as ![O(n^{2})](img/file1637.png "O(n^{2})") or ![O(n^{3})](img/file1643.png
    "O(n^{3})"). Moreover, if a decision problem is not in ![P](img/file1.png "P"),
    then the running time of any of its deciders will grow faster than any polynomial
    (at least, for an infinite number of its inputs). And that is something that we
    can unequivocally classify as not efficient at all.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，![P](img/file1.png "P") 类似乎很好地捕捉了问题可高效求解的概念。诚然，在 ![P](img/file1.png "P")
    类中，我们允许运行时间如 ![n^{1000}](img/file1642.png "n^{1000}")，这几乎不能被认为是高效的。然而，我们可以证明属于
    ![P](img/file1.png "P") 类的自然发生问题的运行时间通常要温和得多，例如 ![O(n^{2})](img/file1637.png "O(n^{2})")
    或 ![O(n^{3})](img/file1643.png "O(n^{3})")。此外，如果一个决策问题不属于 ![P](img/file1.png "P")
    类，那么其任何决策器的运行时间将比任何多项式增长得更快（至少，对于无限多个输入）。这是我们明确归类为完全不高效的事情。
- en: 'Another central class of problems in computational complexity is ![NP](img/file2.png
    "NP"). It is, again, a class of decision problems. But, in this case, the defining
    property is not that we can solve them efficiently (as in the case of ![P](img/file1.png
    "P")) but that we can check their solutions with an efficient algorithm. To make
    this idea formal, we say that a problem ![A](img/file183.png "A") has a **polynomial-time
    verifier** if there exists a Turing machine ![V](img/file379.png "V") that runs
    in polynomial time and a polynomial ![q](img/file292.png "q") with the two following
    properties:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 计算复杂性中的另一个核心问题类是 ![NP](img/file2.png "NP")。它同样是一个决策问题类。但在这个情况下，定义属性不是我们能否高效地解决它们（如
    ![P](img/file1.png "P") 的情况），而是我们能否用高效的算法检查它们的解。为了使这个想法形式化，我们说，如果存在一个运行在多项式时间内的图灵机
    ![V](img/file379.png "V") 和一个多项式 ![q](img/file292.png "q")，那么问题 ![A](img/file183.png
    "A") 有一个**多项式时间验证器**。
- en: If ![x](img/file269.png "x") is an instance of problem ![A](img/file183.png
    "A") of size ![n](img/file244.png "n") for which the answer is “true,” then there
    exists a binary string ![y](img/file270.png "y") of length at most ![q(n)](img/file1644.png
    "q(n)") such that ![V](img/file379.png "V") on input ![(x,y)](img/file1645.png
    "(x,y)") returns ![1](img/file13.png "1"). The string ![y](img/file270.png "y")
    is usually called a **witness**, a **certificate**, or a **proof** for ![x](img/file269.png
    "x").
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 ![x](img/file269.png "x") 是问题 ![A](img/file183.png "A") 的大小为 ![n](img/file244.png
    "n") 的一个实例，其答案为“true”，那么存在一个长度最多为 ![q(n)](img/file1644.png "q(n)") 的二进制字符串 ![y](img/file270.png
    "y")，使得 ![V](img/file379.png "V") 在输入 ![(x,y)](img/file1645.png "(x,y)") 时返回 ![1](img/file13.png
    "1")。这个字符串 ![y](img/file270.png "y") 通常被称为 ![x](img/file269.png "x") 的**证据**、**证书**或**证明**。
- en: If ![x](img/file269.png "x") is an instance of problem ![A](img/file183.png
    "A") of size ![n](img/file244.png "n") for which the answer is “false,” then for
    every binary string ![y](img/file270.png "y") of length at most ![q(n)](img/file1644.png
    "q(n)"), ![V](img/file379.png "V") on input ![(x,y)](img/file1645.png "(x,y)")
    returns ![0](img/file12.png "0").
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 ![x](img/file269.png "x") 是问题 ![A](img/file183.png "A") 的大小为 ![n](img/file244.png
    "n") 的一个实例，其答案为“false”，那么对于长度最多为 ![q(n)](img/file1644.png "q(n)") 的每一个二进制字符串 ![y](img/file270.png
    "y")，![V](img/file379.png "V") 在输入 ![(x,y)](img/file1645.png "(x,y)") 时返回 ![0](img/file12.png
    "0")。
- en: This definition is a little bit convoluted, so let’s analyze it in detail. The
    idea here is that for an instance ![x](img/file269.png "x") of ![A](img/file183.png
    "A") whose answer is positive, we can find a certificate ![y](img/file270.png
    "y") that is not long (its length is polynomial in the size ![x](img/file269.png
    "x")) and that we can check when we are given ![y](img/file270.png "y") together
    with ![x](img/file269.png "x"), with an efficient algorithm. However, for instances
    whose answer is negative, there is no such certificate. Note also that the total
    running time of ![V](img/file379.png "V") on ![(x,y)](img/file1645.png "(x,y)")
    is polynomial in the length of ![x](img/file269.png "x"), because ![V](img/file379.png
    "V") runs in polynomial time in its whole input and ![y](img/file270.png "y")
    has a length that is polynomial in ![x](img/file269.png "x"). Hence, this definition
    really captures the notion of checking that the answer to ![x](img/file269.png
    "x") is positive (through certificate ![y](img/file270.png "y")) with an efficient
    algorithm.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义有点复杂，让我们详细分析一下。这里的想法是，对于 ![A](img/file183.png "A") 的一个实例 ![x](img/file269.png
    "x")，其答案为正，我们可以找到一个不长的证书 ![y](img/file270.png "y")（其长度是 ![x](img/file269.png "x")
    大小的多项式），并且当我们得到 ![y](img/file270.png "y") 和 ![x](img/file269.png "x") 时，可以使用一个高效的算法来验证。然而，对于答案为负的实例，不存在这样的证书。注意，![V](img/file379.png
    "V") 在 ![(x,y)](img/file1645.png "(x,y)") 上的总运行时间是 ![x](img/file269.png "x") 长度的多项式，因为
    ![V](img/file379.png "V") 在整个输入上以多项式时间运行，而 ![y](img/file270.png "y") 的长度是 ![x](img/file269.png
    "x") 的多项式。因此，这个定义真正捕捉了通过高效的算法检查 ![x](img/file269.png "x") 的答案为正（通过证书 ![y](img/file270.png
    "y")）的概念。
- en: With this notion at our disposal, we can now define ![NP](img/file2.png "NP")
    as the class of decision problems for which there exists a polynomial-time verifier.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这个概念，我们现在可以将 ![NP](img/file2.png "NP") 定义为存在多项式时间验证器的决策问题类。
- en: To learn more…
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多…
- en: An alternative, but equivalent, definition of ![NP](img/file2.png "NP") can
    be given in terms of non-deterministic Turing machines. In fact, ![NP](img/file2.png
    "NP") is short for ”non-deterministic polynomial time.” You can find all the details
    in Sipser’s book [[90](ch030.xhtml#Xsipser2012introduction)].
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用非确定性图灵机的术语给出 ![NP](img/file2.png "NP") 的另一种但等价的定义。实际上，![NP](img/file2.png
    "NP") 是 “非确定性多项式时间” 的缩写。你可以在 Sipser 的书中找到所有细节 [[90](ch030.xhtml#Xsipser2012introduction)]。
- en: Let’s discuss an example to illustrate this definition. The problem of determining
    whether a graph has a Hamiltonian path is in ![NP](img/file2.png "NP"). The certificate
    ![y](img/file270.png "y") can, in this case, be just a Hamiltonian path in the
    graph. Indeed, it is easy to write a program (in Python, for example) that, given
    a graph represented by ![x](img/file269.png "x") and a sequence of vertices represented
    by ![y](img/file270.png "y"), checks whether ![y](img/file270.png "y") is a path
    in ![x](img/file269.png "x") that visits all the vertices in the graph. Moreover,
    we can easily do this computation in polynomial time and the certificate is always
    of size linear in the number of graph vertices. As required, for graphs that have
    a Hamiltonian path, there exists at least a certificate. However, for graphs without
    Hamiltonian paths, no ![y](img/file270.png "y") will make the verifier output
    ![1](img/file13.png "1"). If needed, we could translate our algorithm into Turing
    machine instructions; it is a tedious process, but it has no real difficulty.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来说明这个定义。确定一个图是否有哈密顿路径的问题属于 ![NP](img/file2.png "NP") 类。在这种情况下，证书 ![y](img/file270.png
    "y") 可以仅仅是图中的一个哈密顿路径。实际上，编写一个程序（例如用 Python）来检查给定的图 ![x](img/file269.png "x") 和由
    ![y](img/file270.png "y") 表示的顶点序列是否是访问图中所有顶点的路径是很容易的。此外，我们可以很容易地在多项式时间内完成这个计算，并且证书的大小总是与图顶点数线性相关。正如所要求的，对于有哈密顿路径的图，至少存在一个证书。然而，对于没有哈密顿路径的图，没有任何
    ![y](img/file270.png "y") 会使验证器输出 ![1](img/file13.png "1")。如果需要，我们可以将我们的算法翻译成图灵机指令；这是一个繁琐的过程，但并没有真正的困难。
- en: Important note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '![NP](img/file2.png "NP") is the class of decision problems whose solution
    can be verified with Turing machines in polynomial time.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![NP](img/file2.png "NP") 是一类决策问题，其解决方案可以用多项式时间内的图灵机进行验证。'
- en: Similar arguments can be given to prove that many important problems are in
    ![NP](img/file2.png "NP"), including determining whether a Boolean formula is
    satisfiable, determining whether a graph is ![3](img/file472.png "3")-colorable,
    or determining whether a graph has a cut of size bigger than a given integer ![k](img/file317.png
    "k"). The certificates for them can, of course, be a satisfying assignment, a
    ![3](img/file472.png "3")-coloring of the graph, and a cut of size bigger than
    ![k](img/file317.png "k"). All of them are of a size comparable to the problem
    instances they certify and can be checked efficiently with obvious procedures.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以给出类似的论据来证明许多重要问题都属于 ![NP](img/file2.png "NP") 类，包括确定一个布尔公式是否可满足、确定一个图是否 ![3](img/file472.png
    "3")-可着色，或者确定一个图的割集大小是否大于给定的整数 ![k](img/file317.png "k")。当然，它们的证书可以是满足的赋值、图的 ![3](img/file472.png
    "3")-着色，以及大于 ![k](img/file317.png "k") 的割集。所有这些证书的大小都与它们所证明的问题实例相当，并且可以用明显的程序高效地检查。
- en: 'Additionally, any problem in ![P](img/file1.png "P") is also in ![NP](img/file2.png
    "NP"). This is easily proved. By definition, a problem ![A](img/file183.png "A")
    in ![P](img/file1.png "P") has a decider. But we can directly use this decider
    to obtain a verifier for ![A](img/file183.png "A"): we only need to ignore the
    candidate certificate ![y](img/file270.png "y") and compute the answer with the
    decider itself. If the machine knows how to solve the problem in polynomial time
    on its own, it does not need any external help!'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，任何属于 ![P](img/file1.png "P") 类的问题也属于 ![NP](img/file2.png "NP") 类。这很容易证明。根据定义，![P](img/file1.png
    "P") 类中的问题 ![A](img/file183.png "A") 有一个决定器。但我们可以直接使用这个决定器来获得 ![A](img/file183.png
    "A") 的验证器：我们只需要忽略候选证书 ![y](img/file270.png "y") 并用决定器本身来计算答案。如果机器自己知道如何在多项式时间内解决问题，它就不需要任何外部帮助！
- en: So, we know that ![P](img/file1.png "P") is contained in ![NP](img/file2.png
    "NP"). And it seems like we should be able to prove that they are different, because
    there must be problems whose solutions we can check efficiently, but for which
    it is impossible to find those same solutions in a reasonable amount of time,
    right? Well, it turns out that this is by no means an easy task. In fact, it is
    literally the million-dollar question!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道![P](img/file1.png "P")包含在![NP](img/file2.png "NP")中。而且，看起来我们应该能够证明它们是不同的，因为一定存在我们可以高效检查其解，但在合理的时间内无法找到这些解的问题，对吧？然而，事实证明这绝对不是一项容易的任务。事实上，这可以说是千禧年问题！
- en: Determining whether ![P = NP](img/file337.png "P = NP") is one of the seven
    Millennium Problems selected by the Clay Mathematics Institute in 2000 as the
    most important open questions in all of mathematics (for an accessible account
    of the Millennium Problems, check the book by Keith Devlin [[30](ch030.xhtml#Xdevlin2002millennium)]).
    Whoever is able to give proof showing that ![P \neq NP](img/file1646.png "P \neq
    NP") or to show that every problem in ![NP](img/file2.png "NP") is also in ![P](img/file1.png
    "P"), will receive a one-million-dollar prize and will become world-famous.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 判断![P = NP](img/file337.png "P = NP")是否成立是克莱数学研究所于2000年选出的七个千禧年问题之一，被认为是整个数学中最重要的问题之一（关于千禧年问题的易懂描述，请参阅基思·德维林的书
    [[30](ch030.xhtml#Xdevlin2002millennium)]）。任何能够给出证明![P ≠ NP](img/file1646.png
    "P ≠ NP")或证明![NP](img/file2.png "NP")中的每个问题也在![P](img/file1.png "P")中的证明者，将获得一百万美元的奖金，并成为世界闻名的人物。
- en: Important note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Every problem in ![P](img/file1.png "P") is also in ![NP](img/file2.png "NP").
    The question of whether there are problems in ![NP](img/file2.png "NP") that cannot
    be solved in polynomial time is one of the most important open questions in all
    of mathematics.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![P](img/file1.png "P")中的每个问题也在![NP](img/file2.png "NP")中。是否存在![NP](img/file2.png
    "NP")中不能在多项式时间内解决的问题，这是整个数学中最重要的未解问题之一。'
- en: Almost every expert in computational complexity believes that, in fact, ![P
    \neq NP](img/file1646.png "P \neq NP"). All the evidence points in that direction.
    And it certainly seems logical that *checking* a solution should be easier in
    general than *finding* a solution. However, no one has yet succeeded in proving
    that there are problems in ![NP](img/file2.png "NP") that are not in ![P](img/file1.png
    "P"), and the most natural proof techniques have been shown to be insufficient
    (see *Section 6.5* in the epic book by Moore and Mertens [[68](ch030.xhtml#Xmoore2011nature)]).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有计算复杂性领域的专家都相信，实际上，![P ≠ NP](img/file1646.png "P ≠ NP")。所有证据都指向这个方向。而且，从逻辑上讲，*检查*一个解应该比*找到*一个解更容易。然而，到目前为止，还没有人成功证明在![NP](img/file2.png
    "NP")中存在不在![P](img/file1.png "P")中的问题，而且最自然的证明技术已经被证明是不够的（参见摩尔和梅伦斯撰写的史诗般巨著中的*第6.5节*
    [[68](ch030.xhtml#Xmoore2011nature)]）。
- en: C.5 Hardness, completeness, and reductions
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C.5 难度、完备性和归约
- en: Although our current mathematical tools are not powerful enough to give satisfactory
    lower bounds on the resources needed by computational problems, we do know a good
    deal more about comparing the relative hardness of problems. The main concept
    used for that kind of comparison is what we call a **reduction**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们目前的数学工具还不够强大，无法给出计算问题所需资源的满意下界，但我们确实对比较问题的相对难度了解得更多。用于这种比较的主要概念就是我们所说的**归约**。
- en: Intuitively, a reduction is a procedure to solve a problem from the solution
    to a different problem. We could say that we reduce solving problem ![A](img/file183.png
    "A") to solving problem ![B](img/file184.png "B"). So if we know how to solve
    ![B](img/file184.png "B") with an algorithm, we can use that algorithm and some
    additional computation to also solve ![A](img/file183.png "A").
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地说，归约是一种从不同问题的解来解决一个问题的过程。我们可以这样说，我们将解决![A](img/file183.png "A")问题归约为解决![B](img/file184.png
    "B")问题。所以，如果我们知道如何用算法解决![B](img/file184.png "B")问题，我们就可以使用那个算法和一些额外的计算来解决![A](img/file183.png
    "A")问题。
- en: 'To put it more formally, consider two problems ![A](img/file183.png "A") and
    ![B](img/file184.png "B"), and imagine that we have an algorithm ![M_{B}](img/file1647.png
    "M_{B}") that solves ![B](img/file184.png "B"). ![M_{B}](img/file1647.png "M_{B}")
    is usually called an **oracle** for ![B](img/file184.png "B"). We say that ![A](img/file183.png
    "A") is **reducible** to ![B](img/file184.png "B") if we can solve ![A](img/file183.png
    "A") given an oracle for ![B](img/file184.png "B"). For instance, multiplying
    two numbers is reducible to adding two numbers: if we are given an oracle that
    adds numbers, we can use it to multiply by repeated addition.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，考虑两个问题 ![A](img/file183.png "A") 和 ![B](img/file184.png "B")，并想象我们有一个算法
    ![M_{B}](img/file1647.png "M_{B}") 可以解决 ![B](img/file184.png "B")。![M_{B}](img/file1647.png
    "M_{B}") 通常被称为 ![B](img/file184.png "B") 的 **预言机**。如果我们能够通过一个 ![B](img/file184.png
    "B") 的预言机来解决 ![A](img/file183.png "A")，我们就说 ![A](img/file183.png "A") 是 **可归约**
    到 ![B](img/file184.png "B") 的。例如，乘以两个数可以归约到加法：如果我们有一个加法的预言机，我们可以通过重复加法来使用它进行乘法。
- en: Of course, when studying computational classes such as ![P](img/file1.png "P")
    and ![NP](img/file2.png "NP"), we are interested in reductions that take a polynomial
    amount of time. But how can we capture that idea formally? Well, we can simply
    count each call to the oracle as just another step in the computation. Then, we
    say that a problem ![A](img/file183.png "A") is **polynomial-time** **reducible**
    to a problem ![B](img/file184.png "B") if, given an oracle ![M_{B}](img/file1647.png
    "M_{B}") for ![B](img/file184.png "B"), we can solve any instance ![x](img/file269.png
    "x") of ![A](img/file183.png "A") with a total number of computational steps plus
    calls to ![M_{B}](img/file1647.png "M_{B}") that is polynomial in the size of
    ![x](img/file269.png "x"). Another way of seeing this is imagining that we extend
    our Turing machines with the capability of computing ![M_{B}](img/file1647.png
    "M_{B}") in a single step (these new devices are unsurprisingly called **oracle
    Turing machines**). Then, showing that ![A](img/file183.png "A") is polynomial-time
    reducible to ![B](img/file184.png "B") is the same as finding an oracle Turing
    machine (with an oracle for ![B](img/file184.png "B")) that solves ![A](img/file183.png
    "A") in polynomial time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们研究计算类如 ![P](img/file1.png "P") 和 ![NP](img/file2.png "NP") 时，我们感兴趣的是那些需要多项式时间复杂度的归约。但我们应该如何形式化地捕捉这个想法呢？嗯，我们可以简单地认为每次对预言机的调用只是计算过程中的另一个步骤。然后，我们说一个问题
    ![A](img/file183.png "A") 是 **多项式时间** **可归约** 到一个问题 ![B](img/file184.png "B")，如果给定
    ![B](img/file184.png "B") 的预言机 ![M_{B}](img/file1647.png "M_{B}")，我们可以用总计算步骤加上对
    ![M_{B}](img/file1647.png "M_{B}") 的调用次数（这些次数在 ![x](img/file269.png "x") 的大小上是多项式的）来解决
    ![A](img/file183.png "A") 的任何实例。另一种看待这个问题的方法是想象我们扩展了我们的图灵机，使其能够在单步中计算 ![M_{B}](img/file1647.png
    "M_{B}")（这些新设备不出所料地被称为 **预言机图灵机**）。然后，证明 ![A](img/file183.png "A") 是多项式时间可归约到
    ![B](img/file184.png "B") 与找到一台预言机图灵机（具有 ![B](img/file184.png "B") 的预言机）在多项式时间内解决
    ![A](img/file183.png "A") 是相同的。
- en: Notice that ![A](img/file183.png "A") being polynomial-time reducible to ![B](img/file184.png
    "B") has important consequences. The first one is that if ![B](img/file184.png
    "B") is in ![P](img/file1.png "P"), then ![A](img/file183.png "A") is also in
    ![P](img/file1.png "P"). This is so because, if ![B](img/file184.png "B") is in
    ![P](img/file1.png "P"), we can replace every call to ![M_{B}](img/file1647.png
    "M_{B}") with an actual Turing machine that solves ![B](img/file184.png "B") and
    runs in polynomial time, making the total time involved in solving ![A](img/file183.png
    "A") also polynomial. This also implies that if ![A](img/file183.png "A") is not
    in ![P](img/file1.png "P"), then ![B](img/file184.png "B") cannot be in ![P](img/file1.png
    "P") either, because it would lead us to a contradiction.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 ![A](img/file183.png "A") 是多项式时间可归约到 ![B](img/file184.png "B") 有重要的后果。第一个后果是，如果
    ![B](img/file184.png "B") 在 ![P](img/file1.png "P") 中，那么 ![A](img/file183.png
    "A") 也在 ![P](img/file1.png "P") 中。这是因为，如果 ![B](img/file184.png "B") 在 ![P](img/file1.png
    "P") 中，我们可以用解决 ![B](img/file184.png "B") 并在多项式时间内运行的图灵机来替换每个对 ![M_{B}](img/file1647.png
    "M_{B}") 的调用，从而使解决 ![A](img/file183.png "A") 所涉及的总时间也是多项式的。这也意味着，如果 ![A](img/file183.png
    "A") 不在 ![P](img/file1.png "P") 中，那么 ![B](img/file184.png "B") 也不能在 ![P](img/file1.png
    "P") 中，因为这会导致我们产生矛盾。
- en: Now, we say that a problem ![B](img/file184.png "B") is ![NP](img/file2.png
    "NP")**-hard** if every problem ![A](img/file183.png "A") in ![NP](img/file2.png
    "NP") is polynomial-time reducible to ![B](img/file184.png "B"). This means that
    ![B](img/file184.png "B") is at least as hard as any problem ![A](img/file183.png
    "A") in ![NP](img/file2.png "NP"), because if we knew how to solve ![B](img/file184.png
    "B") efficiently, then we would also know how to solve ![A](img/file183.png "A")
    efficiently. And if at least one problem in ![A](img/file183.png "A") cannot be
    solved in polynomial time, that implies that ![B](img/file184.png "B") cannot
    be solved in polynomial time either.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们说一个问题是![B](img/file184.png "B")![NP](img/file2.png "NP")**-hard**，如果![NP](img/file2.png
    "NP")中的每个问题![A](img/file183.png "A")都可以在多项式时间内被归约到![B](img/file184.png "B")。这意味着![B](img/file184.png
    "B")至少和![NP](img/file2.png "NP")中的任何问题![A](img/file183.png "A")一样难，因为如果我们知道如何有效地解决![B](img/file184.png
    "B")，那么我们也会知道如何有效地解决![A](img/file183.png "A")。而且，如果![A](img/file183.png "A")中至少有一个问题不能在多项式时间内解决，那么这也意味着![B](img/file184.png
    "B")也不能在多项式时间内解决。
- en: Important note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A problem is ![NP](img/file2.png "NP")-hard if every problem in ![NP](img/file2.png
    "NP") is polynomial-time reducible to it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是![NP](img/file2.png "NP")-hard，如果![NP](img/file2.png "NP")中的每个问题都可以在多项式时间内归约到它。
- en: Being ![NP](img/file2.png "NP")-hard seems like a very strong property. Is it
    really possible for *every* problem ![A](img/file183.png "A") in ![NP](img/file2.png
    "NP") to be reduced to a single problem ![B](img/file184.png "B")? As surprising
    as this may seem, we know of hundreds (if not thousands) of problems that occur
    naturally in practice and that are indeed ![NP](img/file2.png "NP")-hard. A notable
    example is the problem of determining whether a Boolean formula is satisfiable
    or not, also called SAT. That SAT is ![NP](img/file2.png "NP")-hard is the content
    of the famous Cook-Levin theorem (see the book by Sipser for a proof [[90](ch030.xhtml#Xsipser2012introduction)]).
    In *Chapter* * [*3*](ch011.xhtml#x1-590003), *Working with Quadratic* *Unconstrained
    Binary Optimization Problems*, we work with many ![NP](img/file2.png "NP")-hard
    problems. For many other examples and much more on the concept of ![NP](img/file2.png
    "NP")-hardness, you can check the classical book by Garey and Johnson [[44](ch030.xhtml#Xgarey1979computers)].*
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 成为![NP](img/file2.png "NP")-hard看起来是一个非常强的属性。真的可能对于![NP](img/file2.png "NP")中的**每个**问题![A](img/file183.png
    "A")都可以归约到单个问题![B](img/file184.png "B")吗？尽管这听起来可能令人惊讶，但我们知道有数百（如果不是数千）个在实践中自然出现并且确实是![NP](img/file2.png
    "NP")-hard的问题。一个显著的例子是确定布尔公式是否可满足的问题，也称为SAT。SAT是![NP](img/file2.png "NP")-hard的内容是著名的Cook-Levin定理的内容（参见Sipser的书籍以获取证明[[90](ch030.xhtml#Xsipser2012introduction)]）。在*第*
    *3* *章* *[*3*](ch011.xhtml#x1-590003)，*处理二次无约束二进制优化问题*中，我们处理了许多![NP](img/file2.png
    "NP")-hard问题。对于许多其他例子以及关于![NP](img/file2.png "NP")-hardness概念的更多内容，你可以查看Garey和Johnson的经典书籍[[44](ch030.xhtml#Xgarey1979computers)]。
- en: '*In fact, it turns out that we can prove that SAT and other decision problems
    in ![NP](img/file2.png "NP") have a property that is a bit stronger than ![NP](img/file2.png
    "NP")-hardness known as ![NP](img/file2.png "NP")**-completeness**. In order to
    discuss it, we first need to talk about a special type of reduction that is very
    useful when studying decision problems. We say that a decision problem ![A](img/file183.png
    "A") is **many-one reducible** to a decision problem ![B](img/file184.png "B")
    if there exists an algorithm ![F](img/file1320.png "F") that transforms an instance
    ![x](img/file269.png "x") of ![A](img/file183.png "A") into an instance ![F(x)](img/file1648.png
    "F(x)") of ![B](img/file184.png "B") with the property that the answer to ![x](img/file269.png
    "x") in ![A](img/file183.png "A") is positive if and only if the answer to ![x](img/file269.png
    "x") in ![B](img/file184.png "B") is positive.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际上，我们能够证明SAT和![NP](img/file2.png "NP")中的其他决策问题具有一种比![NP](img/file2.png "NP")-hardness更强的属性，称为![NP](img/file2.png
    "NP")**-completeness**。为了讨论这个问题，我们首先需要谈论一种在研究决策问题时非常有用的特殊归约类型。我们说一个决策问题![A](img/file183.png
    "A")是**单射归约**到决策问题![B](img/file184.png "B")的，如果存在一个算法![F](img/file1320.png "F")，可以将![A](img/file183.png
    "A")的一个实例![x](img/file269.png "x")转换成![B](img/file184.png "B")的一个实例![F(x)](img/file1648.png
    "F(x)")，并且具有以下性质：在![A](img/file183.png "A")中![x](img/file269.png "x")的答案是正的，当且仅当在![B](img/file184.png
    "B")中![x](img/file269.png "x")的答案是正的。'
- en: Note that, in this case, we indeed have a reduction in the more general sense
    that we were discussing earlier. If we are given an oracle ![M_{B}](img/file1647.png
    "M_{B}") for ![B](img/file184.png "B"), we can solve any instance ![x](img/file269.png
    "x") of ![A](img/file183.png "A") by computing ![F(x)](img/file1648.png "F(x)")
    and applying ![M_{B}](img/file1647.png "M_{B}") to ![F(x)](img/file1648.png "F(x)").
    Here, we are using only one call to ![M_{B}](img/file1647.png "M_{B}"), but in
    a general reduction, we can use ![M_{B}](img/file1647.png "M_{B}") as many times
    as we see fit. Thus, a many-one reduction is a special case of a reduction. Additionally,
    in the case in which the transformation ![F](img/file1320.png "F") can be computed
    in polynomial time, we say that we have a **polynomial-time** **many-one reduction**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，我们确实在更一般的意义上减少了我们之前讨论的内容。如果我们给定一个![B](img/file184.png "B")的![M_{B}](img/file1647.png
    "M_{B}")预言机，我们可以通过计算![F(x)](img/file1648.png "F(x)")并应用![M_{B}](img/file1647.png
    "M_{B}")到![F(x)](img/file1648.png "F(x)")上来解决![A](img/file183.png "A")的任何实例![x](img/file269.png
    "x")。在这里，我们只使用了一次![M_{B}](img/file1647.png "M_{B}")的调用，但在一般化简中，我们可以根据需要多次使用![M_{B}](img/file1647.png
    "M_{B}")。因此，单射化简是化简的一种特殊情况。此外，如果变换![F](img/file1320.png "F")可以在多项式时间内计算，我们说我们有一个**多项式时间**的单射化简。
- en: Important note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A polynomial-time many-one reduction of a decision problem ![A](img/file183.png
    "A") to a decision problem ![B](img/file184.png "B") is a polynomial-time algorithm
    ![F](img/file1320.png "F") that takes instances ![x](img/file269.png "x") of ![A](img/file183.png
    "A") to instances ![F(x)](img/file1648.png "F(x)") of ![B](img/file184.png "B")
    with the property that the answer to ![x](img/file269.png "x") in ![A](img/file183.png
    "A") is “true” if and only if the answer to ![F(x)](img/file1648.png "F(x)") in
    ![B](img/file184.png "B") is “true.”
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个决策问题![A](img/file183.png "A")到决策问题![B](img/file184.png "B")的多项式时间单射化简是一个多项式时间算法![F](img/file1320.png
    "F")，它将![A](img/file183.png "A")的实例![x](img/file269.png "x")转换为![B](img/file184.png
    "B")的实例![F(x)](img/file1648.png "F(x)")，并且具有以下性质：在![A](img/file183.png "A")中![x](img/file269.png
    "x")的答案是“真”当且仅当在![B](img/file184.png "B")中![F(x)](img/file1648.png "F(x)")的答案是“真”。
- en: 'Now, we can actually define that subclass of ![NP](img/file2.png "NP")-hard
    problems that we talked about before: the class of ![NP](img/file2.png "NP")**-complete**
    problems. We say that a problem is ![NP](img/file2.png "NP")-complete if it is
    both in ![NP](img/file2.png "NP") and every problem in ![NP](img/file2.png "NP")
    is polynomial-time many-one reducible to it. As we mentioned before, SAT, for
    example, is ![NP](img/file2.png "NP")-complete. Other ![NP](img/file2.png "NP")-complete
    problems include determining whether a graph is ![3](img/file472.png "3")-colorable,
    determining whether the constraints of a binary linear program can be satisfied,
    determining whether a graph has a cut of size bigger than a given integer ![k](img/file317.png
    "k"), and many other natural decision problems.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实际上定义我们之前提到的![NP](img/file2.png "NP")-难问题的子类：![NP](img/file2.png "NP")**-完全**问题类。我们说一个问题是![NP](img/file2.png
    "NP")-完全的，如果它既在![NP](img/file2.png "NP")中，并且![NP](img/file2.png "NP")中的每个问题都可以通过多项式时间单射化简到它。正如我们之前提到的，SAT，例如，是![NP](img/file2.png
    "NP")-完全的。其他![NP](img/file2.png "NP")-完全问题包括确定一个图是否是![3](img/file472.png "3")-可着色的，确定二进制线性规划的限制是否可以满足，确定一个图是否有一个大于给定整数![k](img/file317.png
    "k")的割，以及许多其他自然决策问题。
- en: '![NP](img/file2.png "NP")-complete problems are central to the study of the
    ![P\overset{?}{=}NP](img/file1649.png "P\overset{?}{=}NP") question because ![P
    = NP](img/file337.png "P = NP") if and only if at least one ![NP](img/file2.png
    "NP")-complete problem is in ![P](img/file1.png "P"). So, you can focus on, say,
    just studying SAT. If you find a polynomial-time algorithm for it, then ![P =
    NP](img/file337.png "P = NP"). If, on the contrary, you show that it is impossible
    to solve SAT in polynomial time, you have found a problem in ![NP](img/file2.png
    "NP") that is not in ![P](img/file1.png "P") and then, immediately, you can conclude
    that ![P \neq NP](img/file1646.png "P \neq NP").'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![NP](img/file2.png "NP")-完全问题对于![P\overset{?}{=}NP](img/file1649.png "P\overset{?}{=}NP")问题的研究至关重要，因为![P
    = NP](img/file337.png "P = NP")当且仅当至少一个![NP](img/file2.png "NP")-完全问题在![P](img/file1.png
    "P")中。因此，你可以专注于，比如说，只研究SAT。如果你找到了它的多项式时间算法，那么![P = NP](img/file337.png "P = NP")。相反，如果你证明在多项式时间内解决SAT是不可能的，那么你找到了一个![NP](img/file2.png
    "NP")中不在![P](img/file1.png "P")中的问题，然后，立即，你可以得出结论![P \neq NP](img/file1646.png
    "P \neq NP")。'
- en: Important note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A problem ![B](img/file184.png "B") is ![NP](img/file2.png "NP")-complete if
    it is in ![NP](img/file2.png "NP") and every other problem ![A](img/file183.png
    "A") in ![NP](img/file2.png "NP") is polynomial-time many-one reducible to ![B](img/file184.png
    "B").
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题![B](img/file184.png "B")是![NP](img/file2.png "NP")-complete，如果它在![NP](img/file2.png
    "NP")中，并且![NP](img/file2.png "NP")中的每一个其他问题![A](img/file183.png "A")都可以通过多项式时间单射归约到![B](img/file184.png
    "B")。
- en: There are, of course, ![NP](img/file2.png "NP")-hard problems that are not ![NP](img/file2.png
    "NP")-complete. This is the case, for instance, if you have an ![NP](img/file2.png
    "NP")-hard problem that is not a decision problem (and, hence, cannot be in ![NP](img/file2.png
    "NP")). Many problems that we study in *Chapter* * [*3*](ch011.xhtml#x1-590003),
    *Working with Quadratic* *Unconstrained Binary Optimization Problems*, fall under
    that category. For instance, finding a minimal coloring for a graph is clearly
    ![NP](img/file2.png "NP")-hard. If you knew how to solve this problem efficiently,
    then you could also determine whether a graph is ![3](img/file472.png "3")-colorable
    (you just need to compute the minimal coloring and check whether its number of
    colors is at most ![3](img/file472.png "3")). But checking whether a graph is
    ![3](img/file472.png "3")-colorable is ![NP](img/file2.png "NP")-hard and, thus,
    finding a minimal coloring is also ![NP](img/file2.png "NP")-hard.*
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，存在一些![NP](img/file2.png "NP")-hard问题，它们并不是![NP](img/file2.png "NP")-complete。例如，如果你有一个![NP](img/file2.png
    "NP")-hard问题，它不是一个决策问题（因此，不能在![NP](img/file2.png "NP")中），这种情况就会发生。我们在*第* *3* *章*
    *[*3*](ch011.xhtml#x1-590003)，*处理二次无约束二进制优化问题*中研究的大多数问题都属于这一类。例如，找到一个图的最小着色显然是![NP](img/file2.png
    "NP")-hard。如果你知道如何高效地解决这个问题，那么你也可以确定一个图是否是![3](img/file472.png "3")-可着色的（你只需要计算最小着色并检查其颜色数是否不超过![3](img/file472.png
    "3")）。但是检查一个图是否是![3](img/file472.png "3")-可着色的也是![NP](img/file2.png "NP")-hard，因此找到最小着色也是![NP](img/file2.png
    "NP")-hard。
- en: '*Many other examples of problems that are optimization versions of ![NP](img/file2.png
    "NP")-complete problems are also ![NP](img/file2.png "NP")-hard, including determining
    the maximum number of clauses that can be simultaneously satisfied in a Boolean
    formula in conjunctive normal form (the MAX-SAT problem), finding a maximum cut
    in a graph (the Max-Cut problem), finding a minimum-cost solution of a binary
    linear program, or solving the Traveling Salesperson problem. However, none of
    them is ![NP](img/file2.png "NP")-complete because they are not in ![NP](img/file2.png
    "NP"): they are not decision problems to start with and, moreover, it is far from
    clear that you could check efficiently that a candidate solution is, indeed, an
    optimal solution!'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多其他问题的优化版本也是![NP](img/file2.png "NP")-hard，包括在合取范式布尔公式中确定可以同时满足的最大子句数（MAX-SAT问题）、在一个图中找到最大割（Max-Cut问题）、找到二进制线性规划的最小成本解，或者解决旅行商问题。然而，它们都不是![NP](img/file2.png
    "NP")-complete，因为它们不在![NP](img/file2.png "NP")中：它们一开始就不是决策问题，而且，你能否高效地检查候选解确实是最优解，这一点远不清楚！'
- en: C.6 A very brief introduction to quantum computational complexity
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C.6 量子计算复杂性的简要介绍
- en: So far, we have focused only on measuring time complexity with classical models.
    However, this is a book on quantum computing, so it is natural to ask what will
    change if we consider quantum computational models instead. This is studied in
    **quantum computational complexity theory**, a fascinating topic that is totally
    beyond the scope of this book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只关注了使用经典模型来衡量时间复杂度。然而，这是一本关于量子计算的书，所以考虑量子计算模型会发生什么变化是很自然的。这属于**量子计算复杂性理论**的研究范畴，这是一个非常迷人的主题，但它完全超出了本书的范围。
- en: Let us, however, say a few words on the kind of concepts that arise when quantum
    models are considered instead of classical Turing machines. This is not at all
    needed to understand any other part of the book, so feel completely free to skip
    it. We will need to be brief, but you can refer to the survey by Watrous [[96](ch030.xhtml#Xwatrous2008quantum)]
    for more details.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们简要地谈谈当考虑量子模型而不是经典图灵机时出现的概念类型。这并不是理解本书其他部分所必需的，所以请随意跳过。我们需要简要说明，但你可以参考Watrous的综述[[96](ch030.xhtml#Xwatrous2008quantum)]以获取更多细节。
- en: It turns out that it is possible to define a class of problems that can be seen
    as a quantum analogous to ![P](img/file1.png "P"). This class is known as ![BQP](img/file1650.png
    "BQP"), and it contains those decision problems that can be solved with bounded
    error in polynomial time with a quantum algorithm.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，可以定义一类问题，这些问题可以看作是![P](img/file1.png "P")的量子对应物。这类问题被称为![BQP](img/file1650.png
    "BQP")，它包含那些可以用量子算法在多项式时间内以有界错误率解决的问题。
- en: There are a couple of things that we need to clarify here. The first one is
    that quantum algorithms being probabilistic, we cannot expect the correct answer
    to a decision problem to always be obtained. Instead, we impose that this correct
    answer is returned, for each input, with high probability. Formally, the requirement
    is that for every positive instance ![x](img/file269.png "x"), the probability
    of obtaining ![1](img/file13.png "1") when the input to the algorithm is ![x](img/file269.png
    "x") should be at least ![\left. 2\slash 3 \right.](img/file1651.png "\left. 2\slash
    3 \right."); similarly, for every negative instance ![x](img/file269.png "x"),
    the probability of obtaining ![0](img/file12.png "0") when the algorithm runs
    on ![x](img/file269.png "x") should be at least ![\left. 2\slash 3 \right.](img/file1651.png
    "\left. 2\slash 3 \right."). In this way, we can repeat the procedure with the
    same input several times and take the majority result. If the number of repetitions
    is big enough (but fixed), we can make the probability of error arbitrarily small
    while still having a total running time that is polynomial.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要澄清的几件事情中，第一点是量子算法是概率性的，我们不能期望决策问题的正确答案总是被获得。相反，我们要求对于每个输入，这个正确答案以高概率返回。形式上，要求是对于每个正实例![x](img/file269.png
    "x")，当算法的输入是![x](img/file269.png "x")时，获得![1](img/file13.png "1")的概率至少为![\left.
    2\slash 3 \right.](img/file1651.png "\left. 2\slash 3 \right.")；同样，对于每个负实例![x](img/file269.png
    "x")，当算法在![x](img/file269.png "x")上运行时，获得![0](img/file12.png "0")的概率至少为![\left.
    2\slash 3 \right.](img/file1651.png "\left. 2\slash 3 \right.")。这样，我们可以用相同的输入重复执行程序几次，并取多数结果。如果重复的次数足够多（但固定），我们可以在保持总运行时间多项式的同时，使错误概率任意小。
- en: To learn more…
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多…
- en: '![BQP](img/file1650.png "BQP") is not exactly analogous to ![P](img/file1.png
    "P") but to another (classical) computational class called ![BPP](img/file1652.png
    "BPP"). The class ![BPP](img/file1652.png "BPP") contains those decision problems
    that can be solved with bounded error in polynomial time with a probabilistic
    Turing machine (that is, a Turing machine with multiple instructions for certain
    state-symbol situations and that can decide which instruction to execute based
    on a sequence of random bits). ![BPP](img/file1652.png "BPP") stands for **bounded-error
    probabilistic polynomial time** while ![BQP](img/file1650.png "BQP") stands for
    **bounded-error quantum polynomial time**.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![BQP](img/file1650.png "BQP")并不完全等同于![P](img/file1.png "P")，而是等同于另一个（经典）计算类![BPP](img/file1652.png
    "BPP")。![BPP](img/file1652.png "BPP")类包含那些可以用概率图灵机在多项式时间内以有界错误率解决的问题（即，在特定状态-符号情况下有多个指令的图灵机，并且可以根据随机比特序列决定执行哪个指令）。![BPP](img/file1652.png
    "BPP")代表**有界错误概率多项式时间**，而![BQP](img/file1650.png "BQP")代表**有界错误量子多项式时间**。'
- en: The other thing that needs to be clarified about our definition of ![BQP](img/file1650.png
    "BQP") is what we exactly understand by a quantum algorithm. In the classical
    case, we have identified this notion with a (single-tape) Turing machine. It is
    possible to define a quantum version of Turing machines (see, for instance, the
    paper by Bernstein and Vazirani [[16](ch030.xhtml#Xbernstein1997quantum)]) and
    use it in our definition. But since our primary model for quantum computations
    throughout this book is the quantum circuit model, a natural question is whether
    we can also use it to formalize the notion of quantum algorithm.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们对![BQP](img/file1650.png "BQP")的定义需要澄清的另一件事是我们对量子算法的确切理解。在经典情况下，我们将这个概念与（单带）图灵机相联系。可以定义图灵机的量子版本（例如，参见Bernstein和Vazirani的论文[[16](ch030.xhtml#Xbernstein1997quantum)])，并将其用于我们的定义。但由于本书中我们主要的量子计算模型是量子电路模型，一个自然的问题是，我们是否也可以用它来形式化量子算法的概念。
- en: In fact, we can give a definition of what is a quantum algorithm in terms of
    quantum circuits, and this definition is equivalent in computational power to
    the one in terms of quantum Turing machines (and polynomially equivalent with
    respect to running time). However, there exist several subtleties that need to
    be confronted.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以用量子电路来定义什么是量子算法，这个定义在计算能力上与基于量子图灵机的定义等价（在运行时间上多项式等价）。然而，存在一些需要面对的细微差别。
- en: The first one is related to being able to consistently measure the execution
    time of a quantum circuit. To do that, we need to fix a finite set of gates and
    express every circuit using only those gates. Then, we can assign a cost of one
    unit to each of those gates and measure the running time of a circuit as its total
    number of gates. Otherwise, if we allow arbitrary gates, then we could argue that
    any circuit is just a single unitary gate (plus some measurements), something
    that is clearly meaningless in terms of analyzing its complexity. Notice that
    fixing a finite set of permitted gates also allows us to describe every circuit
    as a finite binary string, for instance, giving a list of the gates that we use
    and the qubits on which we apply them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题与能够一致地测量量子电路的执行时间有关。为了做到这一点，我们需要固定一个有限集的门，并使用这些门来表示每一个电路。然后，我们可以将每个这些门的成本设为1个单位，并测量电路的运行时间为其总门数。否则，如果我们允许任意门，那么我们可以认为任何电路只是一个单一的单位门（加上一些测量），这在分析其复杂度方面显然是没有意义的。请注意，固定一个允许的有限集门也允许我们将每个电路描述为一个有限的二进制字符串，例如，给出我们使用的门和它们作用在哪些量子位上的列表。
- en: The finite set of gates needs to be chosen in a way that we can approximate
    any given quantum circuit to arbitrary precision. A possible way of doing this
    is explained in the survey by Watrous [[96](ch030.xhtml#Xwatrous2008quantum)].
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 需要选择有限集的门，以便我们可以以任意精度逼近任何给定的量子电路。这种做法在Watrous的综述中有所解释[[96](ch030.xhtml#Xwatrous2008quantum)]。
- en: 'A second technical problem that we need to tackle is that, while a Turing machine
    can process inputs of any size, every quantum circuit has a fixed number of qubits
    and, hence, only admits inputs of a fixed size. As a consequence, we cannot represent
    a full algorithm (that needs to be able to solve every possible instance of a
    problem) with just one quantum circuit: we need to consider an infinite family
    of circuits, one for each input size. So, a quantum algorithm is not a single
    quantum circuit, but a collection ![\{ C_{n}\}](img/file1653.png "\{ C_{n}\}")
    of circuits, one for each natural number ![n](img/file244.png "n"), so that ![C_{n}](img/file1654.png
    "C_{n}") admits ![n](img/file244.png "n") qubits as its input.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的第二个技术问题是，虽然图灵机可以处理任何大小的输入，但每个量子电路都有固定数量的量子位，因此只能接受固定大小的输入。因此，我们不能只用一个量子电路来表示一个完整的算法（该算法需要能够解决所有可能的问题实例）：我们需要考虑一个无限多的电路族，每个电路对应一个输入大小。所以，量子算法不是一个单一的量子电路，而是一组![\{
    C_{n}\}](img/file1653.png "\{ C_{n}\}")电路，每个电路对应一个自然数![n](img/file244.png "n")，使得![C_{n}](img/file1654.png
    "C_{n}")可以接受![n](img/file244.png "n")个量子位作为其输入。
- en: The final issue that we need to address is related to the way in which we select
    that infinite family of circuits. If we allow any collection of circuits to represent
    a quantum algorithm, then we can end up in pathological situations such as being
    able to solve (a problem equivalent to) the Halting problem, which we know to
    be uncomputable! This is because we could just select a different, totally unrelated
    quantum circuit for each size in a way that the quantum circuit already “knows”
    the answer to the Halting problem for its input size. This is not something particular
    to just quantum circuits. The same happens with classical Boolean circuits (as
    we mentioned, this is a subtle point; see Section 2.2 in the book by Kitaev et
    al. [[60](ch030.xhtml#Xkitaev2002classical)] or Chapter 6 in the book by Arora
    and Barak [[8](ch030.xhtml#Xarora2009computational)], especially what is said
    there about the ![\left. P\slash poly \right.](img/file1655.png "\left. P\slash
    poly \right.") class of problems).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的最后一个问题与我们选择那个无限电路家族的方式有关。如果我们允许任何电路集合来表示量子算法，那么我们可能会陷入病态的情况，比如能够解决（与停机问题等价的问题），我们知道这是不可计算的！这是因为我们可以为每个大小选择一个完全不同的、完全不相关的量子电路，使得量子电路已经“知道”其输入大小的停机问题的答案。这不仅仅是对量子电路而言的。经典布尔电路也会发生同样的事情（正如我们提到的，这是一个微妙的问题；参见Kitaev等人书中第2.2节[[60](ch030.xhtml#Xkitaev2002classical)]或Arora和Barak的书中第6章[[8](ch030.xhtml#Xarora2009computational)]，特别是关于![\left.
    P\slash poly \right.](img/file1655.png "\left. P\slash poly \right.")问题类的内容）。
- en: The solution to this issue is to specify all the quantum circuits in the family
    in a **uniform** way. For instance, we can impose that there exists a (classical)
    Turing machine that, given a natural number ![n](img/file244.png "n"), generates
    the circuit for input size ![n](img/file244.png "n") in polynomial time (in ![n](img/file244.png
    "n")). In this way, we can’t hide any additional complexity in the selection of
    the quantum circuits. Remember that we can represent our quantum circuits as finite
    binary strings (because we have fixed a finite number of allowable quantum gates),
    so it makes sense to obtain them as the output of a Turing machine. Moreover,
    every circuit will have a polynomial size (a polynomial-time Turing machine can
    only output a polynomial number of bits, after all) and hence a polynomial running
    time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是统一地指定这个量子电路家族中的所有量子电路。例如，我们可以规定存在一个（经典）图灵机，给定一个自然数![n](img/file244.png
    "n")，在多项式时间内（在![n](img/file244.png "n")上）生成大小为![n](img/file244.png "n")的电路。这样，我们无法在量子电路的选择中隐藏任何额外的复杂性。记住，我们可以将我们的量子电路表示为有限二进制字符串（因为我们已经固定了允许的量子门的有限数量），因此从图灵机的输出中获得它们是有意义的。此外，每个电路都将具有多项式大小（毕竟，多项式时间的图灵机只能输出多项式数量的位）和多项式运行时间。
- en: Important note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '![BQP](img/file1650.png "BQP") is the class of decision problems that can be
    solved with bounded error by polynomial-time uniform families of quantum circuits.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![BQP](img/file1650.png "BQP")是可以通过多项式时间均匀量子电路家族以有界误差解决决策问题的类别。'
- en: Now that we have defined ![BQP](img/file1650.png "BQP"), it is natural to ask
    about its relationship with ![P](img/file1.png "P") and ![NP](img/file2.png "NP")
    in order to be able to assess the power of quantum computers when compared to
    that of classical ones.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了![BQP](img/file1650.png "BQP")，很自然地会询问它与![P](img/file1.png "P")和![NP](img/file2.png
    "NP")的关系，以便能够评估量子计算机与经典计算机相比的能力。
- en: It is easy to show that ![P \subseteq BQP](img/file1656.png "P \subseteq BQP"),
    that is, that every problem in ![P](img/file1.png "P") is also in ![BQP](img/file1650.png
    "BQP"). This follows directly from the fact that we can simulate any classical
    Boolean circuit with a quantum circuit (as we show in *Section* * [*1.5.2*](ch008.xhtml#x1-370001.5.2))
    and from the fact that polynomial-time uniform families of classical circuits
    are equivalent to polynomial-time Turing machines (see Section 6.2 in the book
    by Arora and Barak [[8](ch030.xhtml#Xarora2009computational)]). But this is not
    surprising at all, because we expect quantum computers to be at least as powerful
    as classical computers.*
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易证明![P \subseteq BQP](img/file1656.png "P \subseteq BQP")，也就是说，![P](img/file1.png
    "P")中的每个问题也在![BQP](img/file1650.png "BQP")中。这直接源于我们可以用量子电路模拟任何经典布尔电路（正如我们在*第1.5.2节*中所示）以及多项式时间的经典电路的均匀家族与多项式时间的图灵机等价（参见Arora和Barak的书中第6.2节[[8](ch030.xhtml#Xarora2009computational)]）。但这并不令人惊讶，因为我们期望量子计算机至少与经典计算机一样强大。
- en: '*So the question that we should really ask is whether there are problems in
    ![BQP](img/file1650.png "BQP") that are not in ![P](img/file1.png "P"). The short
    answer is that…we don’t know. Proving it would imply a major breakthrough not
    only in quantum computational complexity but also in classical computational complexity
    theory. It can be proved that ![BQP](img/file1650.png "BQP") is contained in ![PSPACE](img/file1657.png
    "PSPACE"), the class of decision problems solvable in polynomial space. Showing
    that ![P](img/file1.png "P") is different from ![BQP](img/file1650.png "BQP")
    would also imply that ![P](img/file1.png "P") is different from ![PSPACE](img/file1657.png
    "PSPACE"), which is a major open question in computational complexity (although
    it should be easier to solve than the ![P](img/file1.png "P") versus ![NP](img/file2.png
    "NP") problem, because ![NP](img/file2.png "NP") is also contained in ![PSPACE](img/file1657.png
    "PSPACE")).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*因此，我们真正应该问的问题是，在![BQP](img/file1650.png "BQP")中是否存在一些在![P](img/file1.png "P")中不存在的难题。简短的回答是……我们不知道。证明这一点将意味着不仅在量子计算复杂性理论，而且在经典计算复杂性理论方面都将取得重大突破。可以证明![BQP](img/file1650.png
    "BQP")包含在![PSPACE](img/file1657.png "PSPACE")中，即可解在多项式空间中的决策问题集合。证明![P](img/file1.png
    "P")与![BQP](img/file1650.png "BQP")不同，也将意味着![P](img/file1.png "P")与![PSPACE](img/file1657.png
    "PSPACE")不同，这是计算复杂性中的一个重大未解问题（尽管它应该比![P](img/file1.png "P")与![NP](img/file2.png
    "NP")问题更容易解决，因为![NP](img/file2.png "NP")也包含在![PSPACE](img/file1657.png "PSPACE")中）。'
- en: 'That being said, we have good reasons to believe that there are problems in
    ![BQP](img/file1650.png "BQP") that are not in ![P](img/file1.png "P"). In fact,
    we have a very good candidate: the factoring problem (given natural numbers ![m](img/file259.png
    "m") and ![k](img/file317.png "k"), check whether ![m](img/file259.png "m") has
    a factor ![l \neq 1](img/file1658.png "l \neq 1") that is less than ![k](img/file317.png
    "k")) is in ![BQP](img/file1650.png "BQP") thanks to Shor’s algorithm [[87](ch030.xhtml#Xshor99polynomial)],
    but it would be really, really surprising if it were in ![P](img/file1.png "P").
    In fact, many cryptographic protocols currently in use rely on the assumption
    that factoring is not in ![P](img/file1.png "P"). So, every time that you buy
    something online and you send your credit card number over the internet, you are
    implicitly trusting that ![P](img/file1.png "P") and ![BQP](img/file1650.png "BQP")
    are not equal (and that nobody owns a powerful enough quantum computer!).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们有充分的理由相信，在![BQP](img/file1650.png "BQP")中存在一些在![P](img/file1.png "P")中不存在的难题。事实上，我们有一个非常好的候选者：分解问题（给定自然数![m](img/file259.png
    "m")和![k](img/file317.png "k")，检查![m](img/file259.png "m")是否有小于![k](img/file317.png
    "k")的因子![l \neq 1](img/file1658.png "l \neq 1")），由于Shor算法 [[87](ch030.xhtml#Xshor99polynomial)]，它属于![BQP](img/file1650.png
    "BQP")，但如果它属于![P](img/file1.png "P")，那将是非常，非常令人惊讶的。实际上，许多目前使用的加密协议都基于分解不在![P](img/file1.png
    "P")中的假设。所以，每次你在网上购物并发送信用卡号码时，你都在隐含地相信![P](img/file1.png "P")和![BQP](img/file1650.png
    "BQP")不相等（以及没有人拥有足够强大的量子计算机！）。
- en: And what about ![BQP](img/file1650.png "BQP") and ![NP](img/file2.png "NP")?
    The situation there is a little bit more complicated. The evidence that we have
    seems to imply that there are problems in ![BQP](img/file1650.png "BQP") that
    are not in ![NP](img/file2.png "NP") (one of the strongest results in this direction
    can be found in a recent paper by Raz and Tal [[79](ch030.xhtml#Xraz2022oracle)]).
    But we also have some evidence that seems to suggest that there are problems in
    ![NP](img/file2.png "NP") that are not in ![BQP](img/file1650.png "BQP"), due
    to results by Bennett, Bernstein, Brassard, and Vazirani [[15](ch030.xhtml#Xbennett1997strengths)]
    that show that Grover’s algorithm is, in a certain sense, optimal among quantum
    algorithms for search tasks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于![BQP](img/file1650.png "BQP")和![NP](img/file2.png "NP")的情况又是如何呢？那里的情况要复杂一些。我们拥有的证据似乎暗示，在![BQP](img/file1650.png
    "BQP")中存在一些在![NP](img/file2.png "NP")中不存在的难题（在这个方向上最强大的结果之一可以在Raz和Tal最近的一篇论文中找到
    [[79](ch030.xhtml#Xraz2022oracle)]）。但也有一些证据似乎表明，在![NP](img/file2.png "NP")中存在一些在![BQP](img/file1650.png
    "BQP")中不存在的难题，这是由于Bennett、Bernstein、Brassard和Vazirani [[15](ch030.xhtml#Xbennett1997strengths)]的研究结果，这些结果表明Grover算法在某种意义上是量子算法在搜索任务中的最优算法。
- en: If all this is true, it would imply that there are problems that we can solve
    efficiently with quantum algorithms that we couldn’t solve efficiently even with
    non-deterministic machines. But, contrary to what can be read sometimes in the
    media, it also would imply that not every problem in ![NP](img/file2.png "NP")
    could be solved efficiently with a quantum computer, even if it were fault-tolerant.
    In particular, it would imply that no ![NP](img/file2.png "NP")-complete problem
    could be solved efficiently with quantum algorithms (we have represented all these
    relationships in *Figure* * [*C.2*](#FigureC.2)).*
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切都是真的，那么它将意味着存在一些问题，我们可以用量子算法高效地解决，即使是非确定性机器也无法高效解决。但是，与媒体上有时读到的相反，这也意味着并非所有
    ![NP](img/file2.png "NP") 中的问题都能用量子计算机高效解决，即使它是容错的。特别是，它将意味着没有任何 ![NP](img/file2.png
    "NP")-完全问题可以用量子算法高效解决（我们已在 *图* *[*C.2*](#FigureC.2)) 中表示了所有这些关系）。*
- en: '*![Figure C.2: Possible relationships between P, NP, BQP, and NP-complete problems
    according to the available evidence and the most accepted conjectures. Be warned:
    some of these classes might end up being completely equal! ](img/file1659.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*![图 C.2：根据现有证据和最广泛接受的猜想，P、NP、BQP 和 NP-完全问题之间可能的关系。请注意：这些类别中的一些最终可能完全相等！](img/file1659.jpg)*'
- en: '**Figure C.2**: Possible relationships between ![P](img/file1.png "P"), ![NP](img/file2.png
    "NP"), ![BQP](img/file1650.png "BQP"), and ![NP](img/file2.png "NP")-complete
    problems according to the available evidence and the most accepted conjectures.
    Be warned: some of these classes might end up being completely equal!'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 C.2**：根据现有证据和最广泛接受的猜想，![P](img/file1.png "P")、![NP](img/file2.png "NP")、![BQP](img/file1650.png
    "BQP") 和 ![NP](img/file2.png "NP")-完全问题之间可能的关系。请注意：这些类别中的一些最终可能完全相等！'
- en: 'Does this mean that quantum computers are not useful at all for optimization
    problems? Not necessarily. The methods that we describe in *Part* *[*II*](ch010.xhtml#x1-58000II)
    of this book may not be able to give the optimal solution to every optimization
    problem out there. But they provide approximation algorithms that might beat whatever
    is possible with just classical algorithms. For instance, the QAOA algorithm that
    we study in *Chapter* *[*5*](ch013.xhtml#x1-940005), *QAOA: Quantum Approximate
    Optimization* *Algorithm*, is considered a possible candidate for that kind of
    advantage (for some recent results in this direction, see the papers by Basso
    et al. [[12](ch030.xhtml#Xbasso2021quantum)] and by Farhi et al. [[38](ch030.xhtml#Xfarhi2022quantum)],
    but also check the response by Hastings [[51](ch030.xhtml#Xhastings2021classical)]).
    And even if that were not the case, methods such as quantum annealing (described
    in *Chapter* *[*4*](ch012.xhtml#x1-750004), *Adiabatic Quantum Computing and Quantum*
    *Annealing*) or QAOA may provide good heuristics that are useful in practice,
    in the same way that genetic algorithms, simulated annealing, or particle-swarm
    optimization are used to solve practical problems in many different fields.********'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '这是否意味着量子计算机对优化问题完全没有用处？不一定。本书 *第 *[*II*](ch010.xhtml#x1-58000II) *部分中描述的方法可能无法为所有优化问题提供最优解。但它们提供了近似算法，可能比仅使用经典算法所能做到的更好。例如，我们在
    *第 *[*5*](ch013.xhtml#x1-940005) *章 *QAOA: Quantum Approximate Optimization *Algorithm*
    中研究的 QAOA 算法被认为是这种优势的可能候选者（关于这一方向的一些最新结果，请参阅 Basso 等人的论文 [[12](ch030.xhtml#Xbasso2021quantum)]
    和 Farhi 等人的论文 [[38](ch030.xhtml#Xfarhi2022quantum)]，但也请查看 Hastings 的回应 [[51](ch030.xhtml#Xhastings2021classical)]。即使情况并非如此，量子退火（在第
    *[*4*](ch012.xhtml#x1-750004) 章 *Adiabatic Quantum Computing and Quantum *Annealing*
    中描述）或 QAOA 等方法也可能提供有用的启发式方法，这在实践中是有用的，就像遗传算法、模拟退火或粒子群优化在许多不同领域中用于解决实际问题一样。********'
