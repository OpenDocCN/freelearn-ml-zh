<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer104">
<h1 class="chapter-number" id="_idParaDest-52"><a id="_idTextAnchor066"/>3</h1>
<h1 id="_idParaDest-53"><a id="_idTextAnchor067"/>Understanding Data Processing</h1>
<p>A <strong class="bold">Machine Learning</strong> (<strong class="bold">ML</strong>) model is the output we get<a id="_idIndexMarker210"/> once data is fitted into an ML algorithm. It represents the underlying relationship between various features and how that relationship impacts the target variable. This relationship depends entirely on the contents of the dataset. What makes every ML model unique, despite using the same ML algorithm, is the dataset that is used to train said model. Data can be collected from various sources and can have different schemas and structures, which need not be structurally compatible among themselves but may in fact be related to each other. This relationship can be very valuable and can also potentially be the differentiator between a good and a bad model. Thus, it is important to transform this data to meet the requirements of the ML algorithm to eventually train a good model.</p>
<p><strong class="bold">Data processing</strong>, data preparation, and data preprocessing are all steps in the ML pipeline that focus on best exposing the underlying relationship between the features by transforming the structure of the data. Data processing<a id="_idIndexMarker211"/> may be the most challenging step in the ML pipeline, as there are no set steps to the transformation process. Data processing depends entirely on the problem you wish to solve; however, there are some similarities among all datasets that can help us define certain processes that we can perform to optimize our ML pipeline.</p>
<p>In this chapter, we will learn about some of the common functionalities that are often used in data processing and how H2O has in-built operations that can help us easily perform them. We will understand some of the H2O operations that can reframe the structure of our dataframe. We will understand how to handle missing values and the importance of the imputation of values. We will then investigate how we can manipulate the various feature columns in the dataframe, as well as how to slice the dataframe for different needs. We shall also investigate what encoding is and what the different types of encoding are. </p>
<p>In this chapter, we are going to cover the following main topics<a id="_idTextAnchor068"/>:</p>
<ul>
<li>Reframing your dataframe</li>
<li>Handling missing values in the dataframe</li>
<li>Manipulation of feature columns of the dataframe</li>
<li>Tokenization of textual data</li>
<li>Encoding of data using target encoding</li>
</ul>
<h1 id="_idParaDest-54"><a id="_idTextAnchor069"/>Technical requirements</h1>
<p>All code examples in this chapter are run on <strong class="bold">Jupyter Notebook</strong> for an easy understanding of what each line in the code block does. You can run the whole block of code via a Python or R script executor and observe the output results, or you can follow along by installing Jupyter Notebook and observing the execution results of every line in the code blocks.</p>
<p>To install Jupyter Notebook, make sure you have the latest version of Python and <strong class="source-inline">pip</strong> installed on your system and execute the following command:</p>
<p class="source-code">pip install jupyterlab</p>
<p>Once JupyterLab has successfully installed, you can start your Jupyter Notebook locally by executing the following command in your terminal:</p>
<p class="source-code">jupyter notebook</p>
<p>This will open the <strong class="bold">Jupyter Notebook</strong> page on your default browser. You can then select which language you want to use and start executing the lines in the code step by step.</p>
<p>All code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Practical-Automated-Machine-Learning-on-H2O/tree/main/Chapter%203">https://github.com/PacktPublishing/Practical-Automated-Machine-Learning-on-H2O/tree/main/Chapter%203</a>.</p>
<p>Now, let’s begin processing our data by first creating a dataframe and reframing it so that it meets our model training requirement.</p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor070"/>Reframing your dataframe</h1>
<p>Data collected<a id="_idIndexMarker212"/> from various sources is often termed <strong class="bold">raw data</strong>. It is called raw in the sense<a id="_idIndexMarker213"/> that there might be a lot of unnecessary or stale data, which might not necessarily benefit our model training. The structure of the data collected also might not be consistent among all the sources. Hence, it becomes very important to first reframe the data from various sources into a consistent format.</p>
<p>You may have noticed that once we import the dataset into H2O, H2O converts the dataset into a <strong class="source-inline">.hex</strong> file, also called a dataframe. You have <a id="_idIndexMarker214"/>the option to import multiple datasets as well. Assuming you are importing multiple datasets from various sources, each with its own format and structure, then you will need a certain functionality that helps you reframe the contents of the dataset and merge them to form a single dataframe that you can feed to your ML pipeline.</p>
<p>H2O provides several functionalities that you can use to perform the required manipulations.</p>
<p>Here are some of the dataframe manipulation functionalities that help you reframe your datafr<a id="_idTextAnchor071"/>ame:</p>
<ul>
<li>Combining columns from two datafr<a id="_idTextAnchor072"/>ames</li>
<li>Combining rows from two datafr<a id="_idTextAnchor073"/>ames</li>
<li>Merging two dataframes</li>
</ul>
<p>Let’s see how we can combine columns from different dataframes in H2O.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor074"/>Combining columns from two dataframes</h2>
<p>One of the most common dataframe<a id="_idIndexMarker215"/> manipulation functionalities is combining different<a id="_idIndexMarker216"/> columns from different dataframes. Sometimes, the columns of one dataframe may be related to those of another. This could prove beneficial during model training. Thus, it is quite useful to have a functionality that can help us manipulate these columns and combine them together to form a single dataframe for model training. </p>
<p>H2O has a function called <strong class="source-inline">cbind()</strong> that combines the columns<a id="_idIndexMarker217"/> from one dataset into another.</p>
<p>Let’s try this function out in our Jupyter Notebook<a id="_idIndexMarker218"/> using Python. Execute<a id="_idIndexMarker219"/> the following steps in sequence:</p>
<ol>
<li>Import the <strong class="source-inline">h2o</strong> library:<p class="source-code">import h2o</p></li>
<li>Import the <strong class="source-inline">numpy</strong> library; we will use this to create a sample dataframe for our study:<p class="source-code">import numpy as np</p></li>
<li>Initialize the <strong class="source-inline">h2o</strong> server:<p class="source-code">h2o.init()</p></li>
<li>Now, let’s create a dataframe called <strong class="source-inline">important_dataframe_1</strong>; this is a dataframe whose columns are important. To ensure that you generate the same values in the dataset as in this example, set the random seed value for <strong class="source-inline">numpy</strong> to <strong class="source-inline">123</strong>. We will set the number of rows to <strong class="source-inline">15</strong> and the number of columns to <strong class="source-inline">5</strong>. You can name the columns anything you like:<p class="source-code">np.random.seed(123)</p><p class="source-code">important_dataframe_1 = h2o.H2OFrame.from_python(np.random.randn(15,5).tolist(), column_names=list([" important_column_1" , " important_column_2" , " important_column_3" , " important_column_4" , " important_column_5" ]))</p></li>
<li>Let’s check out the content of the dataset by executing the following code:<p class="source-code">important_dataframe_1.describe</p></li>
</ol>
<p>The following screenshot shows you the contents of the dataset:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<img alt="Figure 3.1 – important_dataframe_1 data content " height="382" src="image/B17298_03_001.jpg" width="900"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – important_dataframe_1 data content</p>
<ol>
<li value="6">Let’s create another<a id="_idIndexMarker220"/> dataframe called <strong class="source-inline">important_dataframe_2</strong>, as before but with different<a id="_idIndexMarker221"/> column names, but an equal number of rows and only <strong class="source-inline">2</strong> columns:<p class="source-code">important_dataframe_2 = h2o.H2OFrame.from_python(np.random.randn(15,2).tolist(), column_names=list([" important_column_6" , " important_column_7" ]))</p></li>
<li>Let’s check out the content of this dataframe as well:</li>
</ol>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<img alt="Figure 3.2 – important_dataframe_2 data content " height="383" src="image/B17298_03_002.jpg" width="375"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – important_dataframe_2 data content</p>
<ol>
<li value="8">Now, let’s combine the columns<a id="_idIndexMarker222"/> of both the dataframes and store<a id="_idIndexMarker223"/> them<a id="_idIndexMarker224"/> in another variable called <strong class="source-inline">final_dataframe</strong>, using the <strong class="source-inline">cbind()</strong> function:<p class="source-code">final_dataframe = important_dataframe_1.cbind(important_dataframe_2)</p></li>
<li>Let’s now observe <strong class="source-inline">final_dataframe</strong>:<p class="source-code">final_dataframe.describe</p></li>
</ol>
<p>You should see the contents of <strong class="bold">final_dataframe</strong> as follows:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<img alt="Figure 3.3 – final_dataframe data content after cbind() " height="325" src="image/B17298_03_003.jpg" width="1040"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – final_dataframe data content after cbind()</p>
<p>Here, you will notice that we have successfully combined the columns from <strong class="source-inline">important_dataframe_2</strong> with the columns of <strong class="bold">important_dataframe_1</strong>.</p>
<p>This is how you can use the <strong class="source-inline">cbind()</strong> function<a id="_idIndexMarker225"/> to combine<a id="_idIndexMarker226"/> the columns of two different<a id="_idIndexMarker227"/> datasets into a single dataframe. The only thing to bear in mind while using the <strong class="source-inline">cbind()</strong> function is that it is necessary to ensure that both the datasets to be combined have the same number of rows. Also, if you have dataframes with the same column name, then H2O will append a <strong class="bold">0</strong> in front of the column from dataframe.</p>
<p>Now that we know how to combine the columns of different dataframes, let’s see how we can combine the column values of multiple dataframes with the same column structure.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor075"/>Combining rows from two dataframes</h2>
<p>The majority of big corporations<a id="_idIndexMarker228"/> often handle tremendous amounts<a id="_idIndexMarker229"/> of data. This data is often partitioned into multiple chunks to make storing and reading it faster and more efficient. However, during model training, we will often need to access all these partitioned datasets. These datasets have the same structure but the data contents are distributed. In other words, the dataframes have the same columns; however, the data values or rows are split among them. We will often need a function that combines all these dataframes together so that we have all the data values available for model training.</p>
<p>H2O has<a id="_idIndexMarker230"/> a function called <strong class="source-inline">rbind()</strong> that combines<a id="_idIndexMarker231"/> the rows from one dataset<a id="_idIndexMarker232"/> into another.</p>
<p>Let’s try this function out in the following example:</p>
<ol>
<li value="1">Import the <strong class="source-inline">h2o</strong> library:<p class="source-code">import h2o</p></li>
<li>Import the <strong class="source-inline">numpy</strong> library; we will use this to create a random dataframe for our study:<p class="source-code">import numpy as np</p></li>
<li>Initialize the <strong class="source-inline">h2o</strong> server:<p class="source-code">h2o.init()</p></li>
<li>Now, let’s create a random dataframe called <strong class="source-inline">important_dataframe_1</strong>. To ensure that you generate the same values in the dataset as in this example, set the random seed value for <strong class="source-inline">numpy</strong> to <strong class="source-inline">123</strong>. We will set the number of rows to <strong class="source-inline">15</strong> and the number of columns to <strong class="source-inline">5</strong>. You can name the columns anything you like:<p class="source-code">np.random.seed(123)</p><p class="source-code">important_dataframe_1 = h2o.H2OFrame.from_python(np.random.randn(15,5).tolist(), column_names=list([" important_column_1" , " important_column_2" ," important_column_3" ," important_column_4" ," important_column_5" ]))</p></li>
<li>Let’s check out the number of rows of the dataframe, which should be <strong class="source-inline">15</strong>:<p class="source-code">important_dataframe_1.nrows</p></li>
<li>Let’s create another dataframe called <strong class="source-inline">important_dataframe_2</strong>, as with the previous one, with the same column names and any number of rows. In the example, I have used <strong class="source-inline">10</strong> rows:<p class="source-code">important_dataframe_2 = h2o.H2OFrame.from_python(np.random.randn(10,5).tolist(), column_names=list([" important_column_1" , " important_column_2" ," important_column_3" ," important_column_4" ," important_column_5" ]))</p></li>
<li>Let’s check out <a id="_idIndexMarker233"/>the number of rows for <strong class="source-inline">important_dataframe_2</strong>, which<a id="_idIndexMarker234"/> should be <strong class="source-inline">10</strong>:<p class="source-code">important_dataframe_2.nrows</p></li>
<li>Now, let’s combine the rows of both the dataframes and store<a id="_idIndexMarker235"/> them in another variable called <strong class="source-inline">final_dataframe</strong>, using the <strong class="source-inline">rbind()</strong> function:<p class="source-code">final_dataframe = important_dataframe_1.rbind(important_dataframe_2)</p></li>
<li>Let’s now observe <strong class="source-inline">final_dataframe</strong>:<p class="source-code">final_dataframe.describe</p></li>
</ol>
<p>You should see the contents of <strong class="bold">final_dataframe</strong> as follows:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<img alt="Figure 3.4 – final_dataframe data contents after rbind() " height="300" src="image/B17298_03_004.jpg" width="713"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – final_dataframe data contents after rbind()</p>
<ol>
<li value="10">Let’s check out the number of rows in <strong class="bold">final_dataframe</strong>:<p class="source-code">final_dataframe.nrows</p></li>
</ol>
<p>The output of the last operation<a id="_idIndexMarker236"/> should show you the value of the number<a id="_idIndexMarker237"/> of rows in the final dataset. You will see that the value is <strong class="bold">25</strong> and the contents of the dataframe are the combined row values of both the previous datasets.</p>
<p>Now that we have understood how to combine the rows of two dataframes in H2O using the <strong class="source-inline">rbind()</strong> function, let’s see how we can fully combine two datasets.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor076"/>Merging two dataframes</h2>
<p>You can directly merge two dataframes, combining <a id="_idIndexMarker238"/>their rows and columns into a single <a id="_idIndexMarker239"/>dataframe. H2O provides a <strong class="source-inline">merge()</strong> function that combines two datasets that share a common column or common columns. During merging, columns that the two datasets<a id="_idIndexMarker240"/> have in common are used as the <strong class="bold">merge key</strong>. If they only have one column in common, then that column forms the singular primary key for the merge. If there are multiple common columns, then H2O will form a complex key of all these columns based on their data values and use that as the merge key. If there are multiple common columns between the two datasets and you only wish to merge a specific subset of them, then you will need to rename the other common columns to remove the corresponding commonality.</p>
<p>Let’s try this function out in the following example in Python:</p>
<ol>
<li value="1">Import the <strong class="source-inline">h2o</strong> library:<p class="source-code">import h2o</p></li>
<li>Import the <strong class="source-inline">numpy</strong> library; we will use this to create a random dataframe for our study:<p class="source-code">import numpy as np</p></li>
<li>Initialize the <strong class="source-inline">h2o</strong> server:<p class="source-code">h2o.init()</p></li>
<li>Now, let’s create a dataframe called <strong class="source-inline">dataframe_1</strong>. The dataf<a id="_idTextAnchor077"/>rame has <strong class="source-inline">3</strong> columns: <strong class="source-inline">words</strong>, <strong class="source-inline">numerical_representation</strong>, and <strong class="source-inline">letters</strong>. Now, let’s fill in the data content<a id="_idIndexMarker241"/> as follows:<p class="source-code">dataframe_1 = h2o.H2OFrame.from_python({'words':['Hello', 'World', 'Welcome', 'To', 'Machine', 'Learning'], 'numerical_representation': [0,1,2,3,4,5],'letters':['a','b','c','d']})</p></li>
<li>Let’s check out the content of the dataset:<p class="source-code">dataframe_1.describe</p></li>
<li>You will notice the contents of the dataset as follows:<div class="IMG---Figure" id="_idContainer074"><img alt="Figure 3.5 – dataframe_1 data content " height="240" src="image/B17298_03_005.jpg" width="368"/></div></li>
</ol>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – dataframe_1 data content</p>
<ol>
<li value="7">Let’s create another dataframe called <strong class="source-inline">dataframe_2</strong>. This dataframe also contains <strong class="source-inline">3</strong> columns: the <strong class="source-inline">numerical_representation</strong> column, the <strong class="source-inline">letters</strong> column (both of which it has in common with <strong class="source-inline">dataframe_1</strong>), and an uncommon column. Let’s call it <strong class="source-inline">other_words</strong>:<p class="source-code">dataframe_2 = h2o.H2OFrame.from_python({'other_words':['How', 'Are', 'You', 'Doing', 'Today', 'My', 'Friend', 'Learning', 'H2O', 'Artificial', 'Intelligence'], 'numerical_representation': [0,1,2,3,4,5,6,7,8,9],'letters':['a','b','c','d','e']})</p></li>
<li>Let’s check out the content of this dataframe as well:<p class="source-code">dataframe_2.head(11)</p></li>
</ol>
<p>On executing the code, you should<a id="_idIndexMarker242"/> see the following output in your notebook:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<img alt="Figure 3.6 – dataframe_2 data contents " height="393" src="image/B17298_03_006.jpg" width="374"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – dataframe_2 data contents</p>
<ol>
<li value="9">Now, let’s merge <strong class="source-inline">dataframe_1</strong> into <strong class="source-inline">dataframe_2</strong>, using the <strong class="source-inline">merge()</strong> operation:<p class="source-code">final_dataframe = dataframe_2.merge(dataframe_1)</p></li>
<li>Let’s now observe<a id="_idIndexMarker243"/> <strong class="source-inline">final_dataframe</strong>:<p class="source-code">final_dataframe.describe</p></li>
<li>You should see the contents of <strong class="bold">final_dataframe</strong> as follows:</li>
</ol>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<img alt="Figure 3.7 – final_dataframe contents after merge() " height="217" src="image/B17298_03_007.jpg" width="508"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – final_dataframe contents after merge()</p>
<p>You will notice that H2O used the combination<a id="_idIndexMarker244"/> of the <strong class="bold">numerical_representation</strong> column and the <strong class="bold">letters</strong> column as the merging key. This is why we have values ranging from <strong class="bold">1 to 5</strong> in the <strong class="source-inline">numerical_representation</strong> column with the appropriate values in the other columns. </p>
<p>Now, you may be wondering why there is no row for <strong class="bold">4</strong>. That is because while merging, we have two common columns: <strong class="bold">numerical_representation</strong> and <strong class="bold">letters</strong>. So, H2O used a c<a id="_idTextAnchor078"/>omplex merging key that uses both these columns: <strong class="bold">(0, a)</strong>, <strong class="bold">(1, b)</strong>, <strong class="bold">(2, c)</strong>, and so on. </p>
<p>Now the next question you might have is <em class="italic">What about the row with the value 5? It has no value in the letters column.</em> That is because even an empty value is treated as a unique value in ML. Thus, during merging, the complex key that was generated treated <strong class="bold">(5, )</strong> as a valid merge key.</p>
<p>H2O drops all the remaining values since <strong class="bold">dataframe_1</strong> does not have any more numerical representation values.</p>
<ol>
<li value="12">You can enforce H2O to not drop any of the values from the merge key column by setting the <strong class="source-inline">all_x</strong> parameter to <strong class="source-inline">True</strong> as follows:<p class="source-code">final_dataframe = dataframe_2.merge(dataframe_1, all_x = True)</p></li>
<li>Now, let’s observe the contents of <strong class="bold">final_dataframe</strong> by using its <strong class="source-inline">describe</strong> attribute:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer077">
<img alt="Figure 3.8 – final_dataframe data content after enforcing merge() " height="442" src="image/B17298_03_008.jpg" width="563"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – final_dataframe data content after enforcing merge()</p>
<p>You will notice that we now have all the values from both dataframes merged into a single dataframe. We have all the numerical representations from <strong class="bold">0 to 9</strong> and all letters from <strong class="bold">a to e</strong> from <strong class="bold">dataframe_2</strong> that were missing in the previous step, along with the correct values from the <strong class="bold">other_words</strong> column and the <strong class="bold">words</strong> column.</p>
<p>To recap, we learned how to combine<a id="_idIndexMarker245"/> dataframe columns and rows. We also learned how to combine<a id="_idIndexMarker246"/> entire dataframes together using the <strong class="source-inline">merge()</strong> function. However, we noticed that if we enforced the merging of dataframes despite them not having common data values in their key columns, we ended up with missing values in the dataframe. </p>
<p>Now, let’s look at the different methods we can use to handle missing values using H2O. </p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor079"/>Handling missing values in the dataframe</h1>
<p>Missing values in datasets<a id="_idIndexMarker247"/> are the most common issue <a id="_idIndexMarker248"/>in the real world. It is often expected to have at least a few instances of missing data in huge chunks of datasets collected from various sources. Data can be missing for several reasons, which can range from anything from data not being generated at the source all the way to downtimes in data collectors. Handling missing data is very important for model training, as many ML algorithms don’t support missing data. Those that do may end up giving more importance to looking for patterns in the missing data, rather than the actual data that is present, which distracts the machine from learning.</p>
<p>Missing data is often referred to as <strong class="bold">Not Available</strong> (<strong class="bold">NA</strong>) or <strong class="bold">nan</strong>. Before we can send a dataframe<a id="_idIndexMarker249"/> for model training, we need to handle these types of values first. You can either drop the entire row that contains any missing values or you can fill them with any default value either default or common for that data column. How you handle missing values depends entirely on which data is missing and how important it is for the overall model training.</p>
<p>H2O provides some functionalities that you can use to handle missing values in a dataframe. These are some of them:</p>
<ul>
<li>The <strong class="source-inline">fillna()</strong> function</li>
<li>Replacing values in a frame</li>
<li>Imputation</li>
</ul>
<p>Next, let’s see how we can fill missing values in a dataframe using H2O.</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor080"/>Filling NA values</h2>
<p><strong class="source-inline">fillna()</strong> is a function in H2O<a id="_idIndexMarker250"/> that you can use<a id="_idIndexMarker251"/> to fill missing data values in a sequential<a id="_idIndexMarker252"/> manner. This is especially handy if you have certain data values in a column that are sequential in nature, for example, time series or any metric that increases or decreases sequentially and can be sorted. The smaller the difference between the values in the sequence, the more applicable this function becomes.</p>
<p>The <strong class="source-inline">fillna()</strong> function<a id="_idIndexMarker253"/> has the following parameters:</p>
<ul>
<li><strong class="source-inline">method</strong>: This can either be <em class="italic">forward</em> or <em class="italic">backward</em>. It indicates the direction in which H2O should start filling the NA values in the dataframe.</li>
<li><strong class="source-inline">axis</strong>: <strong class="source-inline">0</strong> for column-wise fill or <strong class="source-inline">1</strong> for row-wise fill.</li>
<li><strong class="source-inline">maxlen</strong>: The maximum<a id="_idTextAnchor081"/> number of consecutive NAs to fill.</li>
</ul>
<p>Let’s see an example in Python<a id="_idIndexMarker254"/> of how we can use this function<a id="_idIndexMarker255"/> to fill missing values:</p>
<ol>
<li value="1">Import the <strong class="source-inline">h2o</strong> library:<p class="source-code">import h2o</p></li>
<li>Import the <strong class="source-inline">numpy</strong> library; we will use this to create a random dataframe for our study:<p class="source-code">import numpy as np</p></li>
<li>Initialize the <strong class="source-inline">h2o</strong> server:<p class="source-code">h2o.init()</p></li>
<li>Create a random dataframe with <strong class="source-inline">1000</strong> rows, <strong class="source-inline">3</strong> columns, and some NA values:<p class="source-code">dataframe = h2o.create_frame(rows=1000, cols=3, integer_fraction=1.0, integer_range=100, missing_fraction=0.2, seed=123)</p></li>
<li>Let’s observe the contents of this dataframe. Execute the following code and you will see certain missing values in the dataframe:<p class="source-code">dataframe.describe</p></li>
</ol>
<p>You should see the contents of the dataframe as follows:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<img alt="Figure 3.9 – Dataframe contents " height="457" src="image/B17298_03_009.jpg" width="174"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Dataframe contents</p>
<ol>
<li value="6">Let’s now use the <strong class="source-inline">fillna()</strong> function<a id="_idIndexMarker256"/> to forward fill<a id="_idIndexMarker257"/> the NA values. Execute<a id="_idIndexMarker258"/> the following code:<p class="source-code">filled_dataframe = dataframe.fillna(method=" forward" , axis=0, maxlen=1)</p></li>
<li>Let’s observe the filled contents of the dataframe. Execute the following code:<p class="source-code">filled_dataframe.describe</p></li>
<li>You should see the contents of the dataframe as follows:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer079">
<img alt="Figure 3.10 – filled_dataframe contents " height="443" src="image/B17298_03_010.jpg" width="166"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – filled_dataframe contents</p>
<p>The <strong class="source-inline">fillna()</strong> function<a id="_idIndexMarker259"/> has filled most of the NA values in the dataframe sequentially.</p>
<p>However, you will notice<a id="_idIndexMarker260"/> that we still have some <strong class="bold">nan</strong> values in the first row<a id="_idIndexMarker261"/> of the dataframe. This is because we filled the dataframe missing values row-wise in the <strong class="bold">forward</strong> direction. When filling NA values, H2O will record the last value in a row for a specific column and copy it if the value in the subsequent row is <strong class="source-inline">NA</strong>. Since this is the very first column, H2O does not have any previous value in the record to fill it, thus it skips over it.</p>
<p>Now that we understand how we can sequentially fill data in a dataframe using the <strong class="source-inline">fillna()</strong> function in H2O, let’s see how we can replace certain values in the dataframe.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor082"/>Replacing values in a frame</h2>
<p>Another common functionality<a id="_idIndexMarker262"/> often needed for data processing is replacing certain values<a id="_idIndexMarker263"/> in the dataframe. There can be plenty of reasons why you might want to do this. This is especially common for numerical data where some of the most common transformations include rounding off values, normalizing numerical ranges, or just correcting a data value. In this section, we will explore some of the functions that we can use in H2O to replace values in the dataframe.</p>
<p>Let’s first create a dataframe that we can use to test out such functions. Execute the following code so that we have a dataframe ready for manipulation:</p>
<pre class="source-code">
import h2o
h2o.init()
dataframe = h2o.create_frame(rows=10, cols=3, real_range=100, integer_fraction=1, missing_fraction=0.1, seed=5)
dataframe.describe</pre>
<p>The dataframe should look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<img alt="Figure 3.11 – Dataframe data contents " height="460" src="image/B17298_03_011.jpg" width="176"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Dataframe data contents</p>
<p>So, we have a dataframe<a id="_idIndexMarker264"/> with three columns: <strong class="bold">C1</strong>, <strong class="bold">C2</strong>, and <strong class="bold">C3</strong>. Each column has a few<a id="_idIndexMarker265"/> negative numbers and some <strong class="bold">nan</strong> values. Let’s see how we can play around with this dataframe.</p>
<p>Let’s start with something simple. Let’s update the value<a id="_idIndexMarker266"/> of a single data value, also called a <strong class="bold">datum</strong>, in the dataframe. Let’s update the fourth row of the <strong class="bold">C2</strong> column to <strong class="source-inline">99</strong>. You can update the value of a single data value based on its position in the dataframe as follows:</p>
<pre class="source-code">
dataframe[3,1] = 99</pre>
<p>Note that the columns and rows in the dataframe all start with <strong class="source-inline">0</strong>. Hence, we set the value in the dataframe with the row number of <strong class="source-inline">3</strong> and the column number of <strong class="source-inline">1</strong> as <strong class="source-inline">99</strong>. You should see the results in the dataframe by executing <strong class="source-inline">dataframe.describe</strong> as follows:</p>
<pre class="source-code">
dataframe.describe</pre>
<p>The dataframe should look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<img alt="Figure 3.12 – Dataframe contents after the datum update " height="482" src="image/B17298_03_012.jpg" width="184"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – Dataframe contents after the datum update</p>
<p>As you can see in the dataframe, we replaced the <strong class="bold">nan</strong> value that was previously in the third row of the <strong class="bold">C2</strong> column with <strong class="bold">99</strong>. </p>
<p>This is a manipulation<a id="_idIndexMarker267"/> of just one data<a id="_idIndexMarker268"/> value. Let’s see how we can replace the values of an entire column. Let’s increase the data values in the <strong class="bold">C3</strong> column to three times their original value. You can do so by executing the following code:</p>
<pre class="source-code">
dataframe[2] = 3*dataframe[2]</pre>
<p>You should see the results in the dataframe by executing <strong class="source-inline">dataframe.describe</strong> as follows:</p>
<pre class="source-code">
dataframe.describe</pre>
<p>The dataframe should look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<img alt="Figure 3.13 – Dataframe contents after column value updates " height="483" src="image/B17298_03_013.jpg" width="191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – Dataframe contents after column value updates</p>
<p>We can see in the output that the values in the <strong class="bold">C3</strong> column have now been increased to three times the original values in the column.</p>
<p>All these replacements <a id="_idIndexMarker269"/>we performed till now are straightforward. Let’s try some<a id="_idIndexMarker270"/> conditional updates on the dataframe. Let’s round off all the negative numbers in the dataframe to <strong class="source-inline">0</strong>. So, the condition is that we only update the negative numbers to <strong class="source-inline">0</strong> and don’t change any of the positive numbers. You can do conditional updates as follows:</p>
<pre class="source-code">
dataframe[dataframe['C1'] &lt; 0, " C1" ] = 0
dataframe[dataframe['C2'] &lt; 0, " C2" ] = 0
dataframe[dataframe['C2'] &lt; 0, " C3" ] = 0</pre>
<p>You should see the results in the dataframe by executing <strong class="source-inline">dataframe.describe</strong> as follows:</p>
<pre class="source-code">
dataframe.describe</pre>
<p>The dataframe should look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<img alt="Figure 3.14 – Dataframe contents after conditional updates " height="483" src="image/B17298_03_014.jpg" width="192"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Dataframe contents after conditional updates</p>
<p>As you can see in the dataframe, all the negative values have been rounded up/replaced by <strong class="bold">0</strong>.</p>
<p>Now, what if instead of rounding<a id="_idIndexMarker271"/> the negative numbers up to <strong class="bold">0</strong> we wished to just inverse<a id="_idIndexMarker272"/> the negative numbers? We could do so by combining the conditional updates with arithmetic updates. Refer to the following example:</p>
<pre class="source-code">
dataframe[" C1" ] = (dataframe[" C1" ] &lt; 0).ifelse(-1*dataframe[" C1" ], dataframe[" C1" ])
dataframe[" C2" ] = (dataframe[" C2" ] &lt; 0).ifelse(-1*dataframe[" C2" ], dataframe[" C2" ])
dataframe[" C3" ] = (dataframe[" C3" ] &lt; 0).ifelse(-1*dataframe[" C3" ], dataframe[" C3" ])</pre>
<p>Now, let’s try to see whether we can replace the remaining <strong class="bold">nan</strong> values with something valid. We already read about the <strong class="source-inline">fillna()</strong> function, but what if the <strong class="bold">nan</strong> values are nothing but some missing values that don’t exactly fall into any incremental or decremental pattern, and we just want to set it to 0? Let’s do that now. Run the following code:</p>
<pre class="source-code">
dataframe[dataframe[" C1" ].isna(), " C1" ] = 0
dataframe[dataframe[" C2" ].isna(), " C2" ] = 0
dataframe[dataframe[" C3" ].isna(), " C3" ] = 0</pre>
<p>You should see<a id="_idIndexMarker273"/> the results in the dataframe<a id="_idIndexMarker274"/> by executing <strong class="source-inline">dataframe.describe</strong> as follows:</p>
<pre class="source-code">
dataframe.describe</pre>
<p>The dataframe should look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<img alt="Figure 3.15 – Dataframe contents after replacing nan values with 0 " height="486" src="image/B17298_03_015.jpg" width="169"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – Dataframe contents after replacing nan values with 0</p>
<p>The <strong class="source-inline">isna()</strong> function is a function that checks whether the value in the datum is <strong class="bold">nan</strong> or not and returns either <strong class="bold">True</strong> or <strong class="bold">False</strong>. We use this condition to replace the values in the dataframe.</p>
<p class="callout-heading">Tip</p>
<p class="callout">There are plenty of ways to manipulate and replace the values in a dataframe and H2O provides plenty of functionality to make implementation easy. Feel free to explore and experiment more with manipulating<a id="_idIndexMarker275"/> the values in the dataframe. You can find more details here: <a href="https://docs.h2o.ai/h2o/latest-stable/h2o-py/docs/frame.xhtml">https://docs.h2o.ai/h2o/latest-stable/h2o-py/docs/frame.xhtml</a>.</p>
<p>Now that we have learned <a id="_idIndexMarker276"/>various methods to replace values<a id="_idIndexMarker277"/> in the dataframe, let’s look into a more advanced approach to doing so that data scientists and engineers often take.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor083"/>Imputation</h2>
<p>Previously, we have seen how we can<a id="_idIndexMarker278"/> replace nan values in the dataset using <strong class="source-inline">fillna()</strong>, which sequentially replaces<a id="_idIndexMarker279"/> the nan data in the dataframe. The <strong class="source-inline">fillna()</strong> function fills data in a sequential manner; however, data need not always be sequential in nature. For example, consider a dataset of people buying gaming laptops. The dataset will mostly contain data about people in the age demographic of 13-28, with a few outliers. In such a scenario, if there are any nan values in the <strong class="bold">age</strong> column of the dataframe, then we cannot use the <strong class="source-inline">fillna()</strong> function to fill the nan values, as any nan value after any outlier value will introduce a bias in the dataframe. We need to replace the nan value with a value that is common among the standard distribution of the age group for that product, something that is between 13 and 28, rather than say 59, which is less likely.</p>
<p>Imputation is the process of replacing certain values in the dataframe with an appropriate substitute that does not introduce any bias or outliers that may impact model training. The method or formulas<a id="_idIndexMarker280"/> used to calculate the substitute value are termed the <strong class="bold">imputation strategy</strong>. Imputation is one of the most important methods of data processing, which handles missing and nan values and tries to replace them with a value that will potentially introduce the least bias into the model training process.</p>
<p>H2O has a function called <strong class="source-inline">impute()</strong> that specifically provides this functionality. It has the following parameters:</p>
<ul>
<li><strong class="source-inline">column</strong>: This parameter accepts the column number that sets<a id="_idIndexMarker281"/> the columns to <strong class="source-inline">impute()</strong>. The value <strong class="source-inline">1</strong> imputes the entire dataframe.</li>
<li><strong class="source-inline">method</strong>: This parameter sets which method of imputation to use. The methods can be either <strong class="source-inline">mean</strong>, <strong class="source-inline">median</strong>, or <strong class="source-inline">mode</strong>.</li>
<li><strong class="source-inline">combine_method</strong>: This parameter dictates how to combine the quantiles for even samples when the imputation method chosen is <strong class="source-inline">median</strong>. The combination methods are either <strong class="source-inline">interpolate</strong>, <strong class="source-inline">average</strong>, <strong class="source-inline">low</strong>, or <strong class="source-inline">high</strong>.</li>
<li><strong class="source-inline">group_by_frame</strong>: This parameter imputes the values of the selected precomputed grouped frame.</li>
<li><strong class="source-inline">by</strong>: This parameter groups the imputation results by the selected columns.</li>
<li><strong class="source-inline">values</strong>: This parameter accepts<a id="_idIndexMarker282"/> a list of values that are imputed per column. Having the <strong class="source-inline">None</strong> value in the list skips the column. </li>
</ul>
<p>Let’s see an example in Python of how we can use<a id="_idIndexMarker283"/> this function to fill missing values. </p>
<p>For this, we shall use the <strong class="bold">high school student sprint</strong> dataset. The high school student sprint dataset is a dataset that consists of recordings of the age of high school students, their weight, maximum recorded speed, and their performance in a 100-meter sprint. The dataset is used to predict how the age, weight, and sprint speed affect the performance of students in a 100-meter sprint race.</p>
<p>The dataset looks as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<img alt="Figure 3.16 – A high school student sprint dataset " height="526" src="image/B17298_03_016.jpg" width="465"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – A high school student sprint dataset</p>
<p>The features<a id="_idIndexMarker284"/> of the dataset are as follows:</p>
<ul>
<li><strong class="bold">age</strong>: Age of the student</li>
<li><strong class="bold">weight</strong>: Weight of the student in kilograms</li>
<li><strong class="bold">max_speed</strong>: The maximum sprint speed of the student in kilometers per hour</li>
<li><strong class="bold">100_meter_time</strong>: The time taken by the student to finish a 100-meter sprint in seconds</li>
</ul>
<p>As you can see, there are plenty of missing values in the <strong class="bold">100_meter_time</strong> column.</p>
<p>We cannot simply use the <strong class="source-inline">fillna()</strong> function, as that will introduce bias into the data if the missing values happen to be right after the fastest or slowest time. We can’t simply replace the values with a constant number either.</p>
<p>What would actually make sense is to replace these missing values with whatever is normal for an average teenager doing a 100-meter dash. We already have values for the majority of students, so we can use their results to calculate a general average 100-meter sprint time and use that as a baseline to replace all the missing values without introducing any bias.</p>
<p>This is exactly what imputation is used for. Let’s use the imputation function<a id="_idIndexMarker285"/> to fill in these missing values:</p>
<ol>
<li value="1">Import the <strong class="source-inline">h20</strong> module and start the <strong class="source-inline">h20</strong> server: <p class="source-code">import h2o</p><p class="source-code">h2o.init()</p></li>
<li>We then import the <strong class="source-inline">high school student sprint</strong> dataset by using <strong class="source-inline">h2o.import_file()</strong>:<p class="source-code">dataframe = h2o.import_file(" Dataset/high_school_student_sprint.csv" )</p></li>
<li>Using the <strong class="source-inline">impute()</strong> function, let’s impute the missing values in the <strong class="source-inline">100_meter_time</strong> column by <strong class="source-inline">mean</strong> and display the data:<p class="source-code">dataframe.impute(" 100_meter_time" , method = " mean" )</p><p class="source-code">dataframe.describe</p></li>
</ol>
<p>You will see the output of the imputed dataframe as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer086">
<img alt="Figure 3.17 – 100_meter_time column imputed by its mean " height="386" src="image/B17298_03_017.jpg" width="382"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17 – 100_meter_time column imputed by its mean</p>
<ol>
<li value="4">H2O calculated the <strong class="source-inline">mean</strong> value of all the values<a id="_idIndexMarker286"/> in the <strong class="bold">100_meter_time</strong> column as <strong class="bold">23.5558</strong> and replaced the missing values with it.</li>
</ol>
<p>Similarly, instead of <strong class="source-inline">mean</strong>, you can use <strong class="source-inline">median</strong> values as well. However, note that if a column has categorical values, then the method must be <strong class="source-inline">mode</strong>. The decision is up to you to make, depending on the dataset that is most useful when replacing the missing values:</p>
<p class="source-code">dataframe.impute(" 100_meter_time" , method = " median" )</p>
<p class="source-code">dataframe.impute(" 100_meter_time" , method = " mode" )</p>
<ol>
<li value="5">Let’s increase the complexity a bit. What if the average 100-meter sprint time is not truly comparable between all students? What if the performances are more comparable age-wise? For example, students of age 16 are faster than the ones who are 13 since they are more physically developed. In that case, it won’t make sense considering a 13-year-old’s sprint time when imputing the missing value of a 16-year-old. This is where we can use the <strong class="source-inline">group</strong> parameter of the <strong class="source-inline">impute()</strong> function:<p class="source-code">dataframe = h2o.import_file(" Dataset/high_school_student_sprint.csv" )</p><p class="source-code">dataframe.impute(" 100_meter_time" , method = " mean" , by=[" age" ])</p><p class="source-code">dataframe.describe</p></li>
</ol>
<p>You will see<a id="_idIndexMarker287"/> the output as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<img alt="Figure 3.18 – 100_meter_sprint imputed by its mean and grouped by age " height="441" src="image/B17298_03_018.jpg" width="425"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18 – 100_meter_sprint imputed by its mean and grouped by age</p>
<p>You will notice that now H2O has calculated the <strong class="source-inline">mean</strong> values by age and replaced the respective missing values for that age in the <strong class="bold">100_meter_time</strong> column. Observe the first row in the dataset. The row was of students aged 13 and had missing values in its <strong class="bold">100_meter_time</strong> column. It was replaced with the <strong class="source-inline">mean</strong> value of all the <strong class="bold">100_meter_time</strong> values for other 13-year-olds. Similar steps were followed for other age groups. This is how you can use the group by parameter in the <strong class="source-inline">impute()</strong> function to flexibly impute the correct values.</p>
<p>The <strong class="source-inline">impute()</strong> function is extremely powerful to impute the correct values in a dataframe. The additional parameters for grouping via columns as well as frames make it very flexible for use in handling all sorts of missing values.</p>
<p>Feel free to use and explore<a id="_idIndexMarker288"/> all these functions on different datasets. At the end of the day, all these functions are just tools used by data scientists and engineers to improve the quality of the data; the real skill is understanding when and how to use these tools to get the most out of your data, and that requires experimentation and practice.</p>
<p>Now that we have learned about the different ways in which we can handle missing data, let’s move on to the next part of data processing, which is how to manipulate the feature columns of the dataframe.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor084"/>Manipulating feature columns of the dataframe</h1>
<p>The majority of the time, your data processing <a id="_idIndexMarker289"/>activities will mostly involve manipulating<a id="_idIndexMarker290"/> the columns of the dataframes. Most importantly, the type of values in the column and the ordering of the values in the column will play a major role in model training.</p>
<p>H2O provides some functionalities that help you do so. The following are some of the functionalities that help you handle missing values in your dataframe:</p>
<ul>
<li>Sorting of columns</li>
<li>Changing the type of the column</li>
</ul>
<p>Let’s first understand how we can sort a column using H2O.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor085"/>Sorting columns</h2>
<p>Ideally, you want the data<a id="_idIndexMarker291"/> in a dataframe to be shuffled before passing it off to model training. However, there may be certain scenarios where you might want to re-order the dataframe based on the values in a column.</p>
<p>H2O has a functionality called <strong class="source-inline">sort()</strong> to sort dataframes based on the values<a id="_idIndexMarker292"/> in a column. It has the following parameters:</p>
<ul>
<li><strong class="source-inline">by</strong>: The column to sort by. You can pass multiple column names as a list as well.</li>
<li><strong class="source-inline">ascending</strong>: A <strong class="source-inline">boolean</strong> array that denotes the direction in which H2O should sort the columns. If <strong class="source-inline">True</strong>, H2O will sort the column in ascending order. If <strong class="source-inline">False</strong>, then H2O will sort it in descending order. If neither of the flags is passed, then H2O defaults to sorting in ascending order.</li>
</ul>
<p>The way H2O will sort the dataframe<a id="_idIndexMarker293"/> depends on whether one column name is passed to the <strong class="source-inline">sort()</strong> function or multiple column<a id="_idIndexMarker294"/> names. If only a single column name is passed, then H2O will return a frame that is sorted by that column. </p>
<p>However, if multiple columns are passed, then H2O will return a dataframe that is sorted as follows:</p>
<ul>
<li>H2O will first sort the dataframe on the first column that is passed in the parameter.</li>
<li>H2O will then sort the dataframe on the next column passed in the parameter, but only those rows will be sorted that have the same values as in the first sorted column. If there are no duplicate values in the previous columns, then no sorting will be done on subsequent columns.</li>
</ul>
<p>Let’s see an example in Python of how we can use this function to sort columns:</p>
<ol>
<li value="1">Import the <strong class="source-inline">h2o</strong> library and initialize it:<p class="source-code">import h2o</p><p class="source-code">h2o.init()</p></li>
<li>Create a dataframe by executing the following code and observe the dataset:<p class="source-code">dataframe = h2o.H2OFrame.from_python({'C1': [3,3,3,0,12,13,1,8,8,14,15,2,3,8,8],'C2':[1,5,3,6,8,6,8,7,6,5,1,2,3,6,6],'C3':[15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]})</p><p class="source-code">dataframe.describe</p></li>
</ol>
<p>The contents of the dataset should be as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<img alt="Figure 3.19 – dataframe_1 data contents " height="425" src="image/B17298_03_019.jpg" width="139"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.19 – dataframe_1 data contents</p>
<ol>
<li value="3">So, at the moment, the values<a id="_idIndexMarker295"/> in columns <strong class="bold">C1</strong>, <strong class="bold">C2</strong>, and <strong class="bold">C3</strong> are all random<a id="_idIndexMarker296"/> in nature. Let’s use the <strong class="source-inline">sort()</strong> function to sort the dataframe by column <strong class="bold">C1</strong>. You can do so by either passing <strong class="source-inline">0</strong> into the <strong class="source-inline">by</strong> parameter, indicating the first column of the dataframe, or by passing <strong class="bold">[‘C1’]</strong>, which is a list containing column names to sequentially sort the dataset:<p class="source-code">sorted_dataframe_1 = dataframe.sort(0)</p><p class="source-code">sorted_dataframe_1.describe</p></li>
</ol>
<p>You should get an output of the code as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<img alt="Figure 3.20 – dataframe_1 sorted by the C1 column " height="425" src="image/B17298_03_020.jpg" width="138"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.20 – dataframe_1 sorted by the C1 column</p>
<p>You will see that the dataframe is now sorted in ascending order by the <strong class="bold">C1</strong> column.</p>
<ol>
<li value="4">Let’s see what we shall<a id="_idIndexMarker297"/> get if we pass multiple columns in the <strong class="source-inline">by</strong> parameter to sort on multiple columns. Run the following code line:<p class="source-code">sorted_dataframe_2 = dataframe.sort(['C1','C2']) sorted_dataframe_2.describe</p></li>
</ol>
<p>You should get an output as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<img alt="Figure 3.21 – dataframe_1 sorted by columns C1 and C2 " height="426" src="image/B17298_03_021.jpg" width="139"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.21 – dataframe_1 sorted by columns C1 and C2</p>
<p>As you can see, H2O first sorted<a id="_idIndexMarker298"/> the columns by the <strong class="bold">C1</strong> column. Then, it sorted the rows by the <strong class="bold">C2</strong> column for those rows that had the same value in the <strong class="bold">C1</strong> column. H2O will sequentially sort the dataframe column-wise for all the columns you pass in the <strong class="source-inline">sort</strong> function. </p>
<ol>
<li value="5">You can also reverse the sorting order by passing <strong class="source-inline">False</strong> in the <strong class="source-inline">ascending</strong> parameter. Let’s test this out by running the following code line:<p class="source-code">sorted_dataframe_3 = dataframe.sort(by=['C1','C2'], ascending=[True,False])</p><p class="source-code">sorted_dataframe_3.describe</p></li>
</ol>
<p>You should see an output as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<img alt="" height="425" src="image/B17298_03_022.jpg" width="139"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.22 – dataframe_1 sorted by the C1 column in ascending order and the C2 column in descending order</p>
<p>In this case, H2O first sorted the columns by the <strong class="bold">C1</strong> column. Then, it sorted the rows by the <strong class="bold">C2</strong> column<a id="_idIndexMarker299"/> for those rows that had the same value in the <strong class="bold">C1</strong> column. However, this time it sorted the values in descending order.</p>
<p>Now that you’ve learned how to sort the dataframe by a single column as well as by multiple columns, let’s move on to another column manipulation function that changes the type of the column.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor086"/>Changing column types</h2>
<p>As we saw in <a href="B17298_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with H2O Flow (H2O’s Web UI)</em>, we changed<a id="_idIndexMarker300"/> the type of the <strong class="source-inline">Heart Disease</strong> column to <strong class="source-inline">enum</strong> from <strong class="source-inline">numerical</strong>. The reason we did this is that the type of column plays a major role in model training. During model training, the type of column decides whether the ML problem is a classification problem or a regression problem. Despite the fact that the data in both cases is numerical in nature, how a ML algorithm will treat the column depends entirely on its type. Thus, it becomes very important to correct the types of columns that might not be correctly set during the initial stages of data collection.</p>
<p>H2O has several functions<a id="_idIndexMarker301"/> that not only help you change the type of the columns but also run initial checks on the column types.</p>
<p>Some of the functions are as follows:</p>
<ul>
<li><strong class="source-inline">.isnumeric()</strong>: Checks whether the column<a id="_idIndexMarker302"/> in the dataframe is of the numeric type. Returns <strong class="source-inline">True</strong> or <strong class="source-inline">False</strong> accordingly</li>
<li><strong class="source-inline">.asnumeric()</strong>: Creates a new frame with all the values<a id="_idIndexMarker303"/> converted to numeric for the specified column</li>
<li><strong class="source-inline">.isfactor()</strong>: Checks whether the column<a id="_idIndexMarker304"/> in the dataframe is of categorical type. Returns <strong class="source-inline">True</strong> or <strong class="source-inline">False</strong> accordingly</li>
<li><strong class="source-inline">.asfactor()</strong>: Creates a new frame with all the values<a id="_idIndexMarker305"/> converted to the categorical type for the specified column</li>
<li><strong class="source-inline">.isstring()</strong>: Checks whether the column<a id="_idIndexMarker306"/> in the dataframe is of the string type. Returns <strong class="source-inline">True</strong> or <strong class="source-inline">False</strong> accordingly</li>
<li><strong class="source-inline">.ascharacter()</strong>: Creates a new frame with all the values<a id="_idIndexMarker307"/> converted to the string type for the specified column</li>
</ul>
<p>Let’s see an example in Python of how we can use these functions to change the column types:</p>
<ol>
<li value="1">Import the <strong class="source-inline">h2o</strong> library and initialize H2O:<p class="source-code">import h2o</p><p class="source-code">h2o.init()</p></li>
<li>Create a dataframe by executing the following code line and observe the dataset:<p class="source-code">dataframe = h2o.H2OFrame.from_python({'C1': [3,3,3,0,12,13,1,8,8,14,15,2,3,8,8],'C2':[1,5,3,6,8,6,8,7,6,5,1,2,3,6,6],'C3':[15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]})</p><p class="source-code">dataframe.describe</p></li>
</ol>
<p>The contents of the dataset should be as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<img alt="Figure 3.23 – Dataframe data contents " height="365" src="image/B17298_03_023.jpg" width="122"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.23 – Dataframe data contents</p>
<ol>
<li value="3">Let’s confirm whether the <strong class="bold">C1 </strong>column<a id="_idIndexMarker308"/> is a <strong class="source-inline">numerical</strong> column by using the <strong class="source-inline">isnumeric()</strong> function as follows:<p class="source-code">dataframe['C1'].isnumeric()</p></li>
</ol>
<p>You should get an output of <strong class="source-inline">True</strong>.</p>
<ol>
<li value="4">Let’s see what we get if we check whether the <strong class="bold">C1</strong> column is a <strong class="source-inline">categorical</strong> column using the <strong class="source-inline">asfactor()</strong> function as follows:<p class="source-code">dataframe['C1'].isfactor()</p></li>
</ol>
<p>You should get an output of <strong class="source-inline">False</strong>.</p>
<ol>
<li value="5">Now let’s convert the <strong class="bold">C1</strong> column to a <strong class="source-inline">categorical</strong> column using the <strong class="source-inline">asfactor()</strong> function and then check whether <strong class="source-inline">isfactor()</strong> returns <strong class="source-inline">True</strong>:<p class="source-code">dataframe['C1'] = dataframe['C1'].asfactor()</p><p class="source-code">dataframe['C1'].isfactor()</p></li>
</ol>
<p>You should now get an output of <strong class="source-inline">True</strong>.</p>
<ol>
<li value="6">You can convert the <strong class="bold">C1</strong> column back into a <strong class="source-inline">numerical</strong> column by using the <strong class="source-inline">asnumeric()</strong> function:<p class="source-code">dataframe['C1'] = dataframe['C1'].asnumeric()</p><p class="source-code">dataframe['C1'].isnumeric()</p></li>
</ol>
<p>You should now get an output of <strong class="source-inline">True</strong>.</p>
<p>Now that you have learned<a id="_idIndexMarker309"/> how to sort the columns of a dataframe and change column types, let’s move on to another important topic in data processing, which is tokenization and encoding.</p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor087"/>Tokenization of textual data</h1>
<p>Not all <strong class="bold">Machine Learning Algorithms</strong> (<strong class="bold">MLAs</strong>) are focused on mathematical problem-solving. <strong class="bold">Natural Language Processing</strong> (<strong class="bold">NLP</strong>) is a branch of ML that<a id="_idIndexMarker310"/> specializes in analyzing meaning<a id="_idIndexMarker311"/> out of textual data, though<a id="_idIndexMarker312"/> it will try to derive meaning and understand the contents of a document or any text for that matter. Training an NLP model can be very tricky, as every language has its own grammatical rules and the interpretation of certain words depends heavily on context. Nevertheless, an NLP algorithm often tries its best to train a model that can predict the meaning and sentiments of a textual document.</p>
<p>The way to train an NLP algorithm<a id="_idIndexMarker313"/> is to first break down the chunk of textual data into smaller units called <strong class="bold">tokens</strong>. Tokens can be words, characters, or even letters. It depends on what the requirements of the MLA are and how it uses these tokens to train a model.</p>
<p>H2O has a function called <strong class="source-inline">tokenize()</strong> that helps break down string<a id="_idIndexMarker314"/> data in a dataframe into tokens and creates a separate column containing all the tokens for further processing.</p>
<p>It has the following parameter: <strong class="source-inline">split</strong>: We pass a regular expression in this parameter that will be used by the function to split the text data into tokens.</p>
<p>Let’s see an example of how we can use this function to tokenize string data in a dataframe:</p>
<ol>
<li value="1">Import the <strong class="source-inline">h2o</strong> library<a id="_idIndexMarker315"/> and initialize<a id="_idIndexMarker316"/> it:<p class="source-code">import h2o</p><p class="source-code">h2o.init()</p></li>
<li>Create a dataframe by executing the following code line and observe the dataset:<p class="source-code">dataframe1 = h2o.H2OFrame.from_python({'C1':['Today we learn AI', 'Tomorrow AI learns us', 'Today and Tomorrow are same', 'Us and AI are same']})</p><p class="source-code">dataframe1 = dataframe1.ascharacter()</p><p class="source-code">dataframe1.describe</p></li>
</ol>
<p>The dataset should look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<img alt="Figure 3.24 – Dataframe data contents " height="186" src="image/B17298_03_024.jpg" width="286"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.24 – Dataframe data contents</p>
<p>This type of textual data is usually collected in systems that generate a lot of log text or conversational data. To solve such NLP tasks, we need to break down the sentences into individual tokens so that we can eventually build the context and meaning of these texts that will help the ML algorithm to make semantic predictions. However, before diving into the complexities of NLP, data scientists and engineers will process this data by tokenizing it first. </p>
<ol>
<li value="3">Let’s tokenize our dataframe using<a id="_idIndexMarker317"/> this function to split the text with blank spaces and observe<a id="_idIndexMarker318"/> the tokenized column:<p class="source-code">tokenized_dataframe = dataframe1.tokenize("  " )</p><p class="source-code">tokenized_dataframe</p></li>
</ol>
<p>You should see the dataframe as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<img alt="Figure 3.25 – Tokenized dataframe data contents " height="376" src="image/B17298_03_025.jpg" width="111"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.25 – Tokenized dataframe data contents</p>
<p>You will notice that the <strong class="source-inline">tokenize()</strong> function splits the text data into tokens and appends the tokens as rows into a single column. You will also notice that all tokenized sentences are separated by empty rows. You can cross-check this by comparing the number of words in all the sentences in the dataframe, plus the empty spaces between the sentences against the number of rows in the tokenized dataset, using <strong class="source-inline">nrows</strong>.</p>
<p>These are some of the most used data processing methods that are used to process your data before you feed it to your ML pipeline for training. There are still plenty of methods and techniques that you can use to further clean and polish your dataframes. So much so that you could dedicate an entire book to discussing them. Data processing happens to be the most difficult part of the entire ML life cycle. The quality of the data used for training depends on the context of the problem statement. It also depends on the creativity and ingenuity of the data scientists and engineers in processing that data. The end goal of data processing is to extract as much information as we can from the dataset and remove noise and bias<a id="_idIndexMarker319"/> from the data to allow for a more efficient<a id="_idIndexMarker320"/> analysis of data during training.</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor088"/>Encoding data using target encoding</h1>
<p>As we know, machines<a id="_idIndexMarker321"/> are only capable of understanding <a id="_idIndexMarker322"/>numbers. However, plenty of real-world ML problems revolve around objects and information that are not necessarily numerical in nature. Things such as states, names, and classes, in general, are represented as categories<a id="_idIndexMarker323"/> rather than numbers. This kind of data is called <strong class="bold">categorical data</strong>. Categorical data will often play a big part in analysis and prediction. Hence, there is a need to convert these categorical values to a numerical format so that machines can understand them. The conversion should also be in such a way that we do not lose the inherent meaning of those categories, nor do we introduce new information into the data, such as the incremental nature of numbers, for example.</p>
<p>This is where encoding is used. <strong class="bold">Encoding</strong> is a process where categorical values<a id="_idIndexMarker324"/> are transformed, in other words, <em class="italic">encoded</em>, into numerical values. There are plenty of encoding methods that can perform<a id="_idIndexMarker325"/> this transformation. One of the most commonly used ones is <strong class="bold">target encoding</strong>.</p>
<p>Target encoding is an encoding process that transforms categorical values into numerical values by calculating the average probability of the target variable occurring for a given category. H2O also has methods that help users implement target encoding on their data.</p>
<p>To better understand this method, consider the following sample <strong class="source-inline">Mythical creatures</strong> dataset:</p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<img alt="Figure 3.26 – Our mythical creatures dataset " height="600" src="image/B17298_03_026.jpg" width="278"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.26 – Our mythical creatures dataset</p>
<p>This dataset<a id="_idIndexMarker326"/> has the following<a id="_idIndexMarker327"/> content:</p>
<ul>
<li><strong class="bold">Animals</strong>: This column contains categorical values of the names of animals.</li>
<li><strong class="bold">Mythical</strong>: This column contains the <strong class="bold">0</strong> binary value and the <strong class="bold">1</strong> binary value. <strong class="bold">1</strong> indicates that the creature is mythical, while <strong class="bold">0</strong> indicates that the creature is not mythical.</li>
</ul>
<p>Now, let’s encode the <strong class="bold">Animals</strong> <strong class="source-inline">categorical</strong> column using target encoding. Target encoding will perform the following steps:</p>
<ol>
<li value="1">Group the categorical values and record the number of times the target value, <strong class="bold">Mythical</strong>, was <strong class="bold">1</strong> and when it was <strong class="bold">0</strong> for a given category as follows:</li>
</ol>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<img alt="Figure 3.27 – The mythical creatures dataset with a target count " height="315" src="image/B17298_03_027.jpg" width="618"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.27 – The mythical creatures dataset with a target count</p>
<ol>
<li value="2">Calculate the probability<a id="_idIndexMarker328"/> that the <strong class="bold">1</strong> target value will occur, as compared<a id="_idIndexMarker329"/> to the <strong class="bold">0 </strong>target value within each specific group. This would look as follows:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer097">
<img alt="Figure 3.28 – The mythical creatures dataset with a Probability of Target 1 Occurring column " height="341" src="image/B17298_03_028.jpg" width="787"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.28 – The mythical creatures dataset with a Probability of Target 1 Occurring column</p>
<ol>
<li value="3">Drop the <strong class="bold">Animals</strong> column and use the <strong class="bold">Probability of Target 1 Occurring</strong> column as the encoded representation of the <strong class="bold">Animals</strong> column. The new encoded dataset will look as follows:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer098">
<img alt="Figure 3.29 – A target-encoded mythical creatures dataset " height="554" src="image/B17298_03_029.jpg" width="258"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.29 – A target-encoded mythical creatures dataset</p>
<p>In the encoded dataset, the <strong class="bold">Animals</strong> feature is encoded<a id="_idIndexMarker330"/> using target encoding and we have a dataset<a id="_idIndexMarker331"/> that is entirely numerical in nature. This dataset will be easy for an ML algorithm to interpret and learn from, providing high-quality models.</p>
<p>Let us now see how we can perform target encoding using H2O. The dataset we will use for this example is the <strong class="source-inline">Automobile price prediction</strong> dataset. You can find the details of this dataset at <a href="https://archive.ics.uci.edu/ml/datasets/Automobile">https://archive.ics.uci.edu/ml/datasets/Automobile</a> (<em class="italic">Dua, D. and Graff, C. (2019). UCI Machine Learning Repository</em> [<a href="http://archive.ics.uci.edu/ml">http://archive.ics.uci.edu/ml</a>]. <em class="italic">Irvine, CA: University of California, School of Information and Computer Science</em>).</p>
<p>The dataset is fairly straightforward. It contains various details about cars, such as the <strong class="bold">make of the car</strong>, <strong class="bold">engine size</strong>, <strong class="bold">fuel system</strong>, <strong class="bold">compression ratio</strong>, and <strong class="bold">price</strong>. The aim of the ML algorithm is to predict the price of a car based on these features.</p>
<p>For our experiment, we shall encode the <strong class="source-inline">categorical</strong> columns <strong class="bold">make</strong>, <strong class="bold">fuel type</strong>, and <strong class="bold">body style</strong> using target encoding where the <strong class="bold">price</strong> column is the target.</p>
<p>Let’s perform target encoding by following this example:</p>
<ol>
<li value="1">Import <strong class="source-inline">h2o</strong> and H2O’s <strong class="bold">target encoder</strong> library, <strong class="source-inline">H2OTargetEncoderEstimator</strong>, and initialize<a id="_idIndexMarker332"/> your H2O server. Execute<a id="_idIndexMarker333"/> the following code:<p class="source-code">import h2o</p><p class="source-code">from h2o.estimators import H2OTargetEncoderEstimator</p><p class="source-code">h2o.init()</p></li>
<li>Import the <strong class="source-inline">Automobile price prediction</strong> dataset and print the contents of the dataset. Execute the following code:<p class="source-code">automobile_dataframe = h2o.import_file(" Dataset\Automobile_data.csv" )</p><p class="source-code">automobile_dataframe</p></li>
</ol>
<p>Let’s observe the contents of the dataframe; it should look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<img alt="Figure 3.30 – An automobile price prediction dataframe " height="460" src="image/B17298_03_030.jpg" width="1194"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.30 – An automobile price prediction dataframe</p>
<p>As you can see in the preceding figure, the dataframe consists of a large number of columns containing the details of cars. For the sake of understanding target encoding, let’s filter out the columns that we want to experiment with while dropping the rest. Since we plan <a id="_idIndexMarker334"/>on encoding the <strong class="source-inline">make</strong> column, the <strong class="source-inline">fuel-type</strong> column, and<a id="_idIndexMarker335"/> the <strong class="source-inline">body-style</strong> column, let’s use only those columns along with the <strong class="source-inline">price</strong> response column. Execute the following code:</p>
<p class="source-code">automobile_dataframe = automobile_dataframe[:,[" make" , " fuel-type" , " body-style" , " price" ]]</p>
<p class="source-code">automobile_dataframe</p>
<p>The filtered dataframe will look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer100">
<img alt="Figure 3.31 – The automobile price prediction dataframe with filtered columns " height="434" src="image/B17298_03_031.jpg" width="411"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.31 – The automobile price prediction dataframe with filtered columns</p>
<ol>
<li value="3">Let’s now split this dataframe into training and testing dataframes. Execute the following code:<p class="source-code">automobile_dataframe_for_training, automobile_dataframe_for_test = automobile_dataframe.split_frame(ratios = [.8], seed = 123)</p></li>
<li>Let’s now train our target encoder model using <strong class="source-inline">H2OTargetEncoderEstimator</strong>. Execute the following code:<p class="source-code">automobile_te = H2OTargetEncoderEstimator()</p><p class="source-code">automobile_te.train(x= [" make" , " fuel-type" , " body-style" ], y=" price" , training_frame=automobile_dataframe_for_training)</p></li>
</ol>
<p>Once the target encoder has finished its training, you will see the following output:</p>
<div>
<div class="IMG---Figure" id="_idContainer101">
<img alt="Figure 3.32 – The result of target encoder training  " height="340" src="image/B17298_03_032.jpg" width="912"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.32 – The result of target encoder training </p>
<p>From the preceding<a id="_idIndexMarker336"/> screenshot, you can see that the H2O target<a id="_idIndexMarker337"/> encoder will generate the target-encoded values for the <strong class="source-inline">make</strong> column, the <strong class="source-inline">fuel-type</strong> column, and the <strong class="source-inline">body-style</strong> column and store them in different columns named <strong class="source-inline">make_te</strong>, <strong class="source-inline">fuel-type_te</strong>, and <strong class="source-inline">body-style_te</strong>, respectively. These new columns will contain the encoded values.</p>
<ol>
<li value="5">Let’s now use this trained target encoder to encode the training dataset and print the encoded dataframe:<p class="source-code">te_automobile_dataframe_for_training = automobile_te.transform(frame=automobile_dataframe_for_training, as_training=True)</p><p class="source-code">te_automobile_dataframe_for_training</p></li>
</ol>
<p>The encoded training frame should look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer102">
<img alt="Figure 3.33 – An encoded automobile price prediction training dataframe " height="385" src="image/B17298_03_033.jpg" width="694"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.33 – An encoded automobile price prediction training dataframe</p>
<p>As you can see from the figure, our training<a id="_idIndexMarker338"/> frame now has three additional<a id="_idIndexMarker339"/> columns, <strong class="source-inline">make_te</strong>, <strong class="source-inline">fuel-type_te</strong>, and <strong class="source-inline">body-style_te</strong>, with numerical values. These are the target-encoded columns for the <strong class="source-inline">make</strong> column, the <strong class="source-inline">fuel-type</strong> column, and the <strong class="source-inline">body-style</strong> column.</p>
<ol>
<li value="6">Similarly, let’s now use the trained target encoder to encode the test dataframe and print the encoded dataframe. Execute the following code:<p class="source-code">te_automobile_dataframe_for_test = automobile_te.transform(frame=automobile_dataframe_for_test, noise=0)</p><p class="source-code">te_automobile_dataframe_for_test</p></li>
</ol>
<p>The encoded test frame should look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer103">
<img alt="Figure 3.34 – An encoded automobile price prediction test dataframe " height="387" src="image/B17298_03_034.jpg" width="659"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.34 – An encoded automobile price prediction test dataframe</p>
<p>As you can see from the figure, our test frame also has three additional columns, which are the encoded columns. You can now use these dataframes to train your ML models.</p>
<p>Depending on your next actions, you can use<a id="_idIndexMarker340"/> the encoded dataframes however<a id="_idIndexMarker341"/> you see fit. If you want to use the dataframe to train ML models, then you can drop the <strong class="source-inline">categorical</strong> columns from the dataframe and use the respective encoded columns as training features to train your models. If you wish to perform any further analytics on the dataset, then you can keep both types of columns and perform any comparative study.</p>
<p class="callout-heading">Tip</p>
<p class="callout">H2O’s target encoder has several parameters that you can set to tweak the encoding process. Selecting the correct settings for target encoding your dataset can get very complex, depending on the type of data with which you are working. So, feel free to experiment with this function, as the better you understand this feature and target encoding in general, the better you can encode your dataframe and further improve your model training. You can find more details<a id="_idIndexMarker342"/> about H2O’s target encoder here: <a href="https://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/target-encoding.xhtml">https://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/target-encoding.xhtml</a>.</p>
<p>Congratulations! You have<a id="_idIndexMarker343"/> just understood how you can encode<a id="_idIndexMarker344"/> categorical values using H2O’s target encoder. </p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor089"/>Summary</h1>
<p>In this chapter, we first explored the various techniques and some of the common functions we use to preprocess our dataframe before it is sent to model training. We looked into how we can reframe our raw dataframe into a suitable consistent format that meets the requirement for model training. We learned how to manipulate the columns of dataframes by combining them with different columns of different dataframes. We learned how to combine rows from partitioned dataframes, as well as how to directly merge dataframes into a single dataframe.</p>
<p>Once we knew how to reframe our dataframes, we learned how to handle the missing values that are often present in freshly collected data. We learned how to fill NA values, replace certain incorrect values, as well as how to use different imputation strategies to avoid adding noise and bias when filling missing values.</p>
<p>We then investigated how we can manipulate the feature columns by sorting the dataframes by column, as well as changing the types of columns. We also learned how to tokenize strings to handle textual data, as well as how to encode categorical values using H2O’s target encoder.</p>
<p>In the next chapter, we will open the black box of AutoML, explore its training, and what happens internally during the AutoML process. This will help us to better understand how H2O does its magic and efficiently automates the model training process.</p>
</div>
<div>
<div id="_idContainer105">
</div>
</div>
</div></body></html>