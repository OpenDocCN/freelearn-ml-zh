- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Detecting Orientation with an IMU on Raspberry Pi Pico
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our robot can track how far it’s moved, but what about tracking which direction
    the robot is facing? Or how far it has turned? In this chapter, we will learn
    about the **Inertial Measurement Unit** (**IMU**), a device that can track the
    motion of the robot measured against gravity and the Earth’s magnetic field.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at how to select one of these devices, get it connected and then
    write code for it on our robot using the PID controller to steer the robot based
    on the IMU data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is an IMU and how to choose one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting the IMU to the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calibrating and getting readings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always face North behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a known turn behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The robot from [*Chapter 11*](B18001_11.xhtml#_idTextAnchor233), *Controlling
    Motion with Encoders on Raspberry* *Pi Pico*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot, encoder, and PID code from [*Chapter 11*](B18001_11.xhtml#_idTextAnchor233),
    *Controlling Motion with Encoders on Raspberry* *Pi Pico*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A screwdriver, bolts, and stand-offs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dupont jumper cables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A space where strong magnets can be avoided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PC or laptop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Android/iOS smartphone with Bluetooth LE and the Bluefruit LE Connect app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-12](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-12).
  prefs: []
  type: TYPE_NORMAL
- en: What is an IMU and how to choose one
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll look at the components of an IMU and what criteria we
    used to choose the one used in this robot.
  prefs: []
  type: TYPE_NORMAL
- en: Components of an IMU
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An IMU is a module that can measure movement. It uses multiple sensors to achieve
    this. In this section, we’ll briefly look at each sensor and how they contribute
    to the whole measurement.
  prefs: []
  type: TYPE_NORMAL
- en: These sensors are made using the **Micro-Electro-Mechanical-Systems** (**MEMS**)
    process. They have tiny moving parts embedded into the chips. We can model them
    mechanically to understand them. These parts sense the movement of parts through
    their magnetic fields and amplify tiny signals. Let’s look at the components.
  prefs: []
  type: TYPE_NORMAL
- en: The thermometer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mechanical components of an IMU will change size, depending on their temperature.
    These tiny changes may be enough to change the signals so that the IMU controller
    can use a temperature measurement to compensate for this.
  prefs: []
  type: TYPE_NORMAL
- en: The accelerometer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An **accelerometer** measures acceleration forces. It measures this as a vector
    – a direction and a size. The way this is measured is somewhat like a box with
    a suspended mass, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Accelerometer modeled as a mass with springs ](img/Figure_12.01_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Accelerometer modeled as a mass with springs
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows a mass suspended in a box by springs. When a force
    acts on the box, the mass retains its inertia and compresses the spring opposing
    the force’s direction. A MEMS accelerometer uses tiny silicon springs and masses
    and measures the electrical field changes when the mass moves.
  prefs: []
  type: TYPE_NORMAL
- en: While on Earth, gravity pulls the mass down. This system behaves like a force
    holding the box up, so an accelerometer registers an upward force. We can use
    this measurement to determine what the downward direction is and sense the tilt
    of a robot.
  prefs: []
  type: TYPE_NORMAL
- en: The accelerometer vector is an absolute orientation (see the *Absolute and relative
    sensing* section in [*Chapter 6*](B18001_06.xhtml#_idTextAnchor115), *Measuring
    Movement With Encoders on Raspberry Pi Pico*) for up. Still, other movements cause
    noise, so it is usually put through a low pass filter, only changing a setting
    by a percentage of the actual variation. This filter makes the output slow but
    stable.
  prefs: []
  type: TYPE_NORMAL
- en: A controller can combine this data with other sensors for a faster and more
    stable measurement, such as a gyroscope.
  prefs: []
  type: TYPE_NORMAL
- en: The gyroscope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **gyroscope** measures the rotation speed of a system, typically in degrees
    or radians per second in an angle around each axis. A physical gyroscope model,
    shown as follows, can be used to help illustrate what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – A model of a gyroscope ](img/Figure_12.02_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – A model of a gyroscope
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows a traditional gyroscope. This gyroscope has a spinning
    mass wheel in the middle, linked to concentric rings – each ring pivots in one
    direction – x, y, or *z*. The net effect is that when you move the handle, the
    spinning disk preserves its orientation. Sensors placed at the pivots would detect
    how much the system has rotated in each direction.
  prefs: []
  type: TYPE_NORMAL
- en: The MEMS version uses a tiny mass that’s moved back and forth in one direction.
    If the orientation is changed, the mass will continue vibrating in the original
    direction, which will change the electrical fields detected by the sensor. This
    movement in the original orientation appears to be a force known as the **Coriolis
    force**. The gyroscope can measure the magnitude of this force.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s essential to understand the directions of the gyroscope and how the measurements
    relate to time. See the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Gyroscope directions and problems with integrating it ](img/Figure_12.03_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Gyroscope directions and problems with integrating it
  prefs: []
  type: TYPE_NORMAL
- en: The left-hand side of the preceding diagram shows the three gyroscope rotations
    and the coordinate systems that the IMU uses. This coordinate system takes the
    robot into account. Traditionally, the front of the robot is in the positive X
    direction. Straight up is positive Z, and to the robot’s left is positive Y. Rotation
    around the *z* axis is known as **heading** (also known as yaw), rotation around
    the y axis is pitch, and rotation around the x axis is roll. This combination
    of three angles to determine orientation is known as **Euler** (pronounced *oil-er*
    angles).
  prefs: []
  type: TYPE_NORMAL
- en: The right-hand side of the diagram shows how a controller can use gyroscope
    data – it represents a relative change in angle or a speed in angle change over
    time. We can convert this into a new angle, but that is estimated. Multiplying
    this by time and adding them can give us a whole rotation relative to the starting
    position, but this will magnify any estimation or reading errors.
  prefs: []
  type: TYPE_NORMAL
- en: A controller should combine this with other sensors, where the gyroscope can
    provide a fast relative measurement, and the other sensor can provide a slower
    absolute measurement. However, the accelerometer cannot measure the heading. For
    that, we need a magnetometer.
  prefs: []
  type: TYPE_NORMAL
- en: The magnetometer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **magnetometer** is sensitive to magnetic fields. It passes electricity through
    a material that creates current when exposed to a magnetic field, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Diagram of a hall-effect sensor ](img/Figure_12.04_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Diagram of a hall-effect sensor
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure shows an example of detecting magnetic fields in action:'
  prefs: []
  type: TYPE_NORMAL
- en: The circuit passes an electric current from a source through a conducting plate
    (the gray rectangle). The arrows show the flow of electrons (negative charge carriers)
    moving around the circuit from the top of the plate downwards. The small circle
    with a V measures electrical flow across the sides of the plate. Currently, this
    reads `0` as the flow is straight down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we place a magnet above the plate, it deflects electrons to one side. This
    deflection creates a small electric flow through the measuring circuit and will
    show a reading above `0` on the sensor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we place a magnet below the plate, this deflects the electrons to the other
    side, creating a small sensor flow in the other direction, and show a reading
    below 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This sensor method is known as the **Hall effect**. By measuring three plates,
    you can sense magnetic fields in three dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: The great thing is that we can use this to sense the Earth’s magnetic field
    and magnetic North, although it can be deflected by magnets in objects around
    the magnetometer. Being able to sense magnetic North makes it a great way to sense
    heading.
  prefs: []
  type: TYPE_NORMAL
- en: Because it is subject to other magnets, it can be noisy and may need a low pass
    filter, but you can pair it with the gyroscope the same way the accelerometer
    is paired.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen the four sensor types that go into an IMU, we can look
    at how we choose one.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an IMU module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several IMU devices on the market. The first thing to note is that
    you want a module or breakout, not a bare chip (at least not yet).
  prefs: []
  type: TYPE_NORMAL
- en: The number of directions/movements an IMU system can sense is known as **degrees
    of freedom**, or **DOF**. A system with all three types of sensors is known as
    a 9-DOF because each can produce three axes worth of information. The temperature
    sensor isn’t counted in this DOF count usually.
  prefs: []
  type: TYPE_NORMAL
- en: 'These modules come in a few flavors. The following diagram illustrates these
    flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – IMU module integration levels ](img/Figure_12.05_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – IMU module integration levels
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram shows three different IMU module integration levels.
    They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The simplest has only one of the sensors, and you need to buy three to get the
    complete orientation. In addition, they do not have much helper circuitry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some modules integrate three or four separate sensor chips to give the full
    9-DOF and could be suitable. These have some support circuitry but might not have
    a controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The devices we will focus on are those based around a single chip that combines
    the sensors. These come as modules that integrate power and any additional required
    components (such as small resistors and capacitors). These have onboard controllers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They can also use a few different data buses to communicate. UART and SPI tie
    up a whole set of pins; however, I2C allows the device to share a bus with other
    sensors, so we’ll favor I2C devices.
  prefs: []
  type: TYPE_NORMAL
- en: The next factor in integration is how much calculation the device’s controller
    can do (if any). The algorithms to combine all three sensors and account for calibration,
    along with temperature, are complicated. Some devices can perform this on board,
    and some require it on another controller or require specialist code to be uploaded
    to activate the calculation (such as MPU and ICM TDK series). We will also favor
    modules that can do the calculation on board.
  prefs: []
  type: TYPE_NORMAL
- en: The BNO055 module is a good fit for these requirements. The BNO055 combines
    all 9-DOF, a temperature sensor, works over I2C, and has calculations and calibration
    on board, saving us writing that code on our Raspberry Pi Pico. They are also
    widely available, with Adafruit selling them in two variations, and there’s direct
    CircuitPython support for them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how we can use a BNO055 module with our robot.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the IMU to the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing the BNO055 requires performing a few steps. In this section, we’ll
    prepare the module, attach it to the robot rigidly, wire the part into the circuit,
    and then use some simple code to test that it is responding.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the BNO055
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The BNO055 from Adafruit comes without the headers attached. You’ll need to
    solder the headers in, as we have done previously. Adafruit has a guide for this
    at [https://learn.adafruit.com/adafruit-bno055-absolute-orientation-sensor/assembly](https://learn.adafruit.com/adafruit-bno055-absolute-orientation-sensor/assembly).
  prefs: []
  type: TYPE_NORMAL
- en: For this robot, you should solder this part with the headers facing up from
    the component side.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the BNO055
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To attach the part to the robot, see the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Drawing of the shelf with additional holes for the BNO055 module
    ](img/Figure_12.06_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Drawing of the shelf with additional holes for the BNO055 module
  prefs: []
  type: TYPE_NORMAL
- en: You will need to attach the IMU rigidly to the robot, so the velcro pad will
    not be sufficient. Stand-offs will make a suitable attachment here. The preceding
    figure shows where to make some 2.5 mm holes in the shelf in the highlighted area.
    You can insert M2 (or M2.5 if you have them) stand-offs to attach it. You can
    use stand-offs to gain some separation between the IMU and the metal or magnetic
    parts of the robot.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may need to adapt this to the BNO breakout you have. The following figure
    shows the part I am using and the orientation it should be in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – The BNO055 part’s orientation ](img/Figure_12.07_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – The BNO055 part’s orientation
  prefs: []
  type: TYPE_NORMAL
- en: I’ve made the holes so that they suit the part shown in the preceding figure.
    This figure shows the part with the robot chassis as a reference, with the x,
    y, and z axes indicated with arrows. The z in a circle means it runs through this
    diagram, with the upward direction being positive.
  prefs: []
  type: TYPE_NORMAL
- en: We mount the BNO055 so that its x axis faces the front of the robot. This is
    due to the BNO055 defaulting to the Android phone orientation – a minor quirk
    of the configuration of this module.
  prefs: []
  type: TYPE_NORMAL
- en: While the orientation of this part matters, it can be compensated for in code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to wire in this part.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the BNO055 to Raspberry Pi Pico
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will wire the BNO055 using I2C. See the following circuit diagram for details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – BNO055 I2C wiring ](img/Figure_12.08_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – BNO055 I2C wiring
  prefs: []
  type: TYPE_NORMAL
- en: The top part of the preceding diagram shows the whole circuit diagram. Since
    a lot is happening here, the highlighted region has been zoomed in below, showing
    the specific wiring. The BNO055 only needs four pins connected. It has power connections
    for GND and Vin from the 3V3 lines. The SCL and SDA are connected to I2C0, sharing
    an I2C bus with one of the distance sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the BNO055 is wired in, let’s try talking to it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the software and connecting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CircuitPython library includes an `adafruit_BNO055` module for use with
    this device. Copy over or use `adafruit_bus_device` and `adafruit_register` modules
    to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now write some code to check if we can get data from the device. I
    suggest putting the following code in `bno_connect/code.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code starts with imports. It then creates an I2C bus with the correct pins
    and constructs the sensor control object on this bus.
  prefs: []
  type: TYPE_NORMAL
- en: The last line fetches the temperature from the sensor and prints it to serial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Send this to Raspberry Pi Pico as `code.py`; it should show the temperature
    on the serial, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Great! You have now obtained data from the IMU. Before exploring more of the
    available features, let’s troubleshoot any problems.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don’t see the temperature output (or see errors instead), verify the
    connections carefully. Start by powering down the robot, and carefully check the
    power goes to 3V3, then that GND goes to ground.
  prefs: []
  type: TYPE_NORMAL
- en: If these look correct, verify the SCL and SDA lines – swapping these lines is
    a common issue. You can then power the robot again, and you should be able to
    read the temperature.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have connected to the IMU. Now, let’s learn how to get robot
    orientation information from this sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Calibrating and getting readings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you start up code using an IMU module with a controller, the sensors will
    not get correct readings. So, the IMU module will need to determine the sensitivity
    and correct states of the sensor, a process known as **calibration**. First, we
    need some code; then, we’ll need to take the robot through some motions to perform
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Calibration code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the code. In a file called `imu_calibration/code.py`, add
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code handles importing the module and setting it up. We also import `time`
    so that we can use it in loops later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must check the calibration state of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code will print the calibration status for each part of the BNO055\. The
    BNO055 can self-calibrate when turned on; however, the user needs to make motions
    with it to help. The `calibration_status` register holds what parts of the system
    you have calibrated. The system status is important for our purposes, but each
    device has its own status. Each can go from state `0` (uncalibrated) to state
    `3` (fully calibrated). When you have calibrated them, the system is ready to
    use. This code will print them out. We’ll use this to perform the calibration
    process motions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check this in a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we’ve calibrated it, we can check the data from all the sensors and the
    controller itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code will pull all the sensor data and ask the controller to convert the
    accelerometer, magnetometer, and gyroscope data into **Euler** absolute orientation.
    The code puts this into a dictionary so that when we print it, it will appear
    labeled.
  prefs: []
  type: TYPE_NORMAL
- en: We can upload this code and start the calibration process, watching the numbers
    in the calibration status. Let’s use it to calibrate.
  prefs: []
  type: TYPE_NORMAL
- en: The calibration process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following movements might look bizarre, but the IMU module is trying to
    determine the relative motions for each sensor. Then, with the hold postures,
    it is looking at absolute states. With the magnetometer, there will be offsets
    and distortions due to the metal on board the robot. The sensor looks for magnetic
    field changes and the extent in each direction, which it can use to account for
    the distortions.
  prefs: []
  type: TYPE_NORMAL
- en: Beware of calibrating near strong magnetic fields such as a laptop – they can
    make the magnetometer calibration incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following figure to help the IMU complete its calibration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – IMU calibration steps ](img/Figure_12.09_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – IMU calibration steps
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure shows the calibration steps. Use a hold time of at least
    2 seconds and slow motions for the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the robot on a flat surface and hold. This position will set up the
    gyroscope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a small, slow figure of 8 motion a few times to calibrate the magnetometer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold the robot on its back, then on its front.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, hold the robot on its left, then on its right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold the robot upside down; you should see the accelerometer status reach 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, rest it back the right way up. You should be able to see the system status
    reach 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This calibration may take a few attempts and can get stuck on the accelerometer
    sometimes; however, the experiments can continue if the system status reaches
    3 without the accelerometer.
  prefs: []
  type: TYPE_NORMAL
- en: When you have the system status at 3, the demonstration will start printing
    data from all four sensors and combine sensor data into Euler angles. With the
    robot standing, roll and pitch should be `0`. Turning the robot to face North
    should set the heading to `0` too.
  prefs: []
  type: TYPE_NORMAL
- en: We can now use this with a PID controller to make the robot always face North.
  prefs: []
  type: TYPE_NORMAL
- en: Always face North behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll build a behavior with a heading as a set point for a PID and the IMU Euler
    heading as feedback. The error value between these will be how far, in degrees,
    the robot is facing away from the North heading. For example, a heading of `0`
    should be North – note that you could pick another heading as needed. We will
    use the PID output to control the motor movements, with the output adding to the
    speed of one motor and subtracting from the other, producing a turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this looks as a block diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Face North behavior block diagram ](img/Figure_12.10_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Face North behavior block diagram
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the flow of data. The `dt` (delta time) are the
    inputs to the PID. The output from the PID, the **control signal**, is added for
    one motor and subtracted for the other. The motors then result in robot movement,
    which causes the IMU heading to change, feeding back into the error value.
  prefs: []
  type: TYPE_NORMAL
- en: We can now use this block diagram to build the code for this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: CircuitPython code for the face North behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now build the code for this behavior. We’ll start by putting the IMU
    initialization in `robot.py`. Add the following to the imports at the top of `robot.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the distance sensors already use the I2C bus, we can use the same initialized
    I2C bus for the BNO055:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The IMU will be available from `robot.py` once this has loaded. We can also
    add the `check_status` calibration function to `robot.py` so that we can use that
    in other behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The changes to `robot.py` for this section are complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need a new file for the behavior, which I suggest placing in `face_north/code.py`.
    We’ll start with the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then make a controller class for always facing North. It starts by
    defining the target as `0` for North and setting up a PID controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code here calls the `update` method with an `angle` and a delta time (`dt`).
    First, it will calculate the error in degrees. The method then checks the error
    in the range of -180 to 180 degrees. Otherwise, a robot at 359 degrees (-1 degrees
    from North) will turn a full circle to adjust itself, and any overshoot would
    result in unusable behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we pass `error` and `dt` into the PID `calculate` method and send the
    resulting control signals to the motors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now have an `async` task to manage this controller and read the sensor
    data in a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`control_loop` creates an instance of our `FaceNorthController` shown previously.
    It sleeps and manages the delta time, `dt`. Next, it reads the angle from the
    sensor’s `euler` data and passes this to the `update` method. Finally, this method
    logs the angle through Bluetooth so that we can plot it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can make our `main` async function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This part will start a calibration/status loop and print it via Bluetooth when
    the robot is ready. Because we don’t want the robot to start trying to drive out
    of your hands, we will make it wait for a start signal from Bluetooth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The user will see `start` to make the robot move. The code then starts the `control_loop`
    part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can start everything up by starting the `main` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You should be able to send this to the robot and calibrate it. Then, when you
    instruct it to start, the robot will turn to face North.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The robot may be turning to an angle that is not North. The common reason for
    this is that there is a strong magnetic field where you are testing or calibrating
    the robot. In some situations, I have found that I’ve had to turn a sensor 90
    degrees for it to work.
  prefs: []
  type: TYPE_NORMAL
- en: If the robot is overshooting, try reducing the `P` value. If it is taking a
    while to hunt out the actual value, increase the I value a little. I have found
    that the `D` value doesn’t help in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to face one way, can we use this to make a fixed turn in
    any direction? Let’s see.
  prefs: []
  type: TYPE_NORMAL
- en: Making a known turn behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The known turn behavior is a variation of the always face North behavior. The
    idea is to measure the angle at the start of the turn and then make the set point
    the new intended angle.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make it so that the whole app will accept a difference in the intended
    angle, offsetting the last intended angle, with the whole app starting based on
    the robot’s current heading. The user can send `+30` to turn 30 degrees and `-90`
    to rotate 90 degrees back.
  prefs: []
  type: TYPE_NORMAL
- en: 'The block diagram is exactly as before, as we only need to manipulate the expected
    heading. Make a copy of `face_north` in a folder called `known_turn`. Let’s rename
    the controller `IMUTurnController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update` method doesn’t change, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need an additional Bluetooth `command_handler` for accepting user input
    for the intended angle. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This handler sets the target (set point) of `turn_controller` for dealing with
    positive and negative number settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now integrate these into a modified `control_loop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This control loop sets the controller target as the current robot’s heading
    instead of `0`. It will also create the command handler async task with the controller
    as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The loop is the same as what we saw previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` method for this gets to be much simpler as the robot will not move
    until we ask it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Send this to the robot and calibrate it. Then, when you see **Ready to go**
    on Bluetooth, you can send back an angle to turn.
  prefs: []
  type: TYPE_NORMAL
- en: The same troubleshooting steps apply as before.
  prefs: []
  type: TYPE_NORMAL
- en: Try `30`, `45`, `60`, and `90`, or small values such as `5` and `10` degrees.
    Do not go above `179` or `-179`, as this can cause the robot to spin until turned
    off. You could add code to limit this.
  prefs: []
  type: TYPE_NORMAL
- en: It can be helpful to store the error in `IMUTurnController` (as `self.error`)
    and plot this data instead of the angle for tuning the PID.
  prefs: []
  type: TYPE_NORMAL
- en: You can now make a known turn.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we investigated the IMU and how we can use it to control the
    heading of our robot. We learned how to connect the device and calibrate it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we used data from it to face North by combining the sensor data with a
    PID controller. Finally, we built on this example so that it can turn a specified
    number from the current heading.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build a small arena for the robot and look at how
    we can combine the encoders and distance sensors to estimate the robot’s position
    within this arena, improving its estimation as it moves.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These exercises will deepen your understanding of the topics that were covered
    in this chapter and make the robot code better:'
  prefs: []
  type: TYPE_NORMAL
- en: Combining the preceding behaviors with the menu system for the UART we’ve seen
    in previous chapters would allow you to tune the PID with the robot running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Could you use the known turn behavior and straight-line behavior to write a
    better version of the planned path program from [*Chapter 5*](B18001_05.xhtml#_idTextAnchor098),
    *Driving Motors with Raspberry* *Pi Pico*?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment with the Euler heading reading – after calibrating, see how the readings
    change when you bring the robot near objects such as a laptop or kitchen appliances.
    This experiment will demonstrate a weakness with this kind of sensor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An advanced experiment would be to extract the quaternion (instead of Euler
    data) and write this to the UART.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These further study aids will help you learn more and dive deeper into the
    PID algorithm and its quirks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Adafruit CircuitPythong API guide for the BNO055 shows what else you can
    do with this sensor: [https://docs.circuitpython.org/projects/bno055/en/latest/api.html](https://docs.circuitpython.org/projects/bno055/en/latest/api.html)
    - BNO055.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learn Robotics Programming* provides a guide for interfacing a Raspberry Pi
    device with a different IMU chip, the ICM90248, and writing code to calculate
    Euler angles, along with interesting ways to visualize this. It also shows how
    you can use encoders to make a known turn instead, perhaps when objects distort
    the magnetometer readings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Paul McWhorter performs Arduino experiments with the same BNO055 sensor in
    an intensive video series: [https://toptechboy.com/arduino-based-9-axis-inertial-measurement-unit-imu-based-on-bno055-sensor/](https://toptechboy.com/arduino-based-9-axis-inertial-measurement-unit-imu-based-on-bno055-sensor/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
