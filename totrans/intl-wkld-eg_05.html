<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer042">
			<h1 id="_idParaDest-53"><em class="italic"><a id="_idTextAnchor052"/>Chapter 3</em>: Building the Edge</h1>
			<p>In this chapter, you will learn about <strong class="bold">edge</strong> solution concepts such as gateways and how <strong class="bold">AWS IoT Greengrass</strong> is used as a powerful edge appliance to interact with physical interfaces and leaf devices. The goal of this chapter is to start building proficiency with the use of IoT Greengrass for the writing and deploying of software components. This material is foundational to much of the book's hands-on projects and for understanding how we build solutions for the edge. </p>
			<p>We will introduce you to the different protocols that IoT Greengrass can support out of the box and discuss commonly used protocols when building edge solutions. Additionally, we will review several security best practices for you to learn how to keep your edge workloads protected from threats and vulnerabilities. The chapter concludes with a hands-on activity to connect your first two device capabilities as components, whether using actual hardware or a pair of simulators. </p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Exploring the topology of the edge</li>
				<li>Reviewing common standards and protocols</li>
				<li>Security at the edge</li>
				<li>Connecting your first device – sensing at the edge</li>
				<li>Connecting your second device – actuating at the edge </li>
			</ul>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Technical requirements</h1>
			<p>To complete the hands-on exercises in this chapter, you will need to have completed the steps in <a href="B17595_02_Final_SS_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Foundations of Edge Workloads</em> such that your edge device has been set up with the IoT Greengrass Core software running and the <strong class="source-inline">greengrass-cli</strong> component installed.</p>
			<p>You will want to clone the chapter's resources from the book's GitHub repository, for ease of use, if you haven't already done so. There is a step included in the <em class="italic">Connecting your first device – sensing at the edge</em> section that enables you to clone the repository at <a href="https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter3">https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter3</a>. You can perform this step now if you would like to browse the resources in advance: </p>
			<p class="source-code">git clone https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge-<strong class="source-inline"> </strong></p>
			<p>As a reminder, the hands-on steps for this book were authored with a <strong class="bold">Raspberry Pi</strong> and <strong class="bold">Sense HAT</strong> expansion board in mind. For those of you using other Linux-based systems for the edge device, alternate technical resources are included in the GitHub repository with guidance on how to substitute them.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>Exploring the topology of the edge</h1>
			<p>Solutions <a id="_idIndexMarker174"/>built for the edge take on many shapes and sizes. The number of distinct devices included in a solution ranges from one to many. The network layout, compute resources, and budget allowed will drive your architectural and implementation decisions. In an edge <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>) solution, we should consider the requirements for running ML models. ML models work more accurately when they are custom built for a specific instance of a device, as opposed to one model supporting many physical instances of the same device. This means that as the number of devices supported by an edge ML workload grows, so too will the number of ML models and compute resources required at the edge. There are four topologies to consider when architecting an edge ML solution: star, bus, tree, and hybrid. Here is a description of each of them: </p>
			<ul>
				<li><strong class="bold">Star topology</strong>: The <strong class="bold">Home Base Solutions</strong> (<strong class="bold">HBS</strong>) hub device and appliance monitoring <a id="_idIndexMarker175"/>kits represent a common pattern in edge ML <a id="_idIndexMarker176"/>solutions called <strong class="bold">star</strong> topology. The<a id="_idIndexMarker177"/> appliance monitoring kits are single-purpose devices that report telemetry back to the hub device. This creates several advantages in terms of cost optimization for the kits since they do not need to bundle all of the hardware that is necessary to independently communicate directly with a cloud solution. Nor do they require any compute power or local storage to run their own ML models. The hub device in the star topology acts as a server in the sense that it can exchange data with the kits and perform heavier compute and storage tasks on their behalf. Entities such as leaf devices or software components <a id="_idIndexMarker178"/>address other entities directly to send them messages, and<a id="_idIndexMarker179"/> they get routed to the right destination. The following diagram shows an example of the HBS product design operating in a star topology:</li>
			</ul>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="Images/Figure_03_01.jpg" alt="Figure 3.1 – An example of the star topology with hub and devices&#13;&#10;" width="930" height="332"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – An example of the star topology with hub and devices</p>
			<ul>
				<li><strong class="bold">Bus topology</strong>: In a <strong class="bold">bus</strong> pattern, all of the nodes in the topology are connected to a <a id="_idIndexMarker180"/>single shared line, meaning a message <a id="_idIndexMarker181"/>published by one entity can be received by as many entities as are sharing the bus. The bus pattern comes from computer network history where devices are used to physically tap into the network line, expanding the bus with each device. While these days, we don't usually view this pattern as physically wired, there is a logical application of the bus pattern in edge ML solutions. In a decoupled solution, such as the one we are building, an entity such as a software component or leaf device can publish a message without addressing any other particular entity by using a topic address. A topic address doesn't strictly identify other entities; it is up to those other entities to subscribe to such topic addresses in order to get a copy of the message. In this way, the hub device is, technically, the center of a star-like topology; however, the way in which connected entities interact with each other is, in practice, more like a bus. The following diagram illustrates the bus concept for a parallel universe where HBS delivers the monitoring of industrial equipment with an equipment monitoring kit, a local server running ML inference, and an <strong class="bold">andon</strong> light all connected to a hub:</li>
			</ul>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="Images/Figure_03_02.jpg" alt="Figure 3.2 – An example of the logical bus topology&#13;&#10;" width="1650" height="695"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – An example of the logical bus topology</p>
			<ul>
				<li><strong class="bold">Tree topology</strong>: While<a id="_idIndexMarker182"/> it is a good practice for any edge ML solution to functionally operate in isolation, we cannot ignore the benefits of bridging our solution to the wider network and cloud services. In a <strong class="bold">tree</strong> topology, our<a id="_idIndexMarker183"/> hub device is just one layer of nodes in a tree graph where a centralized service communicates with our fleet of hubs. Each hub is then responsible for a specific number of leaf devices and components running in a local star pattern. Managing our HBS product at scale requires us to think about the fleet in its entirety. The following diagram shows the relationship between a cloud service orchestrating our fleet, the fleet of HBS hub devices, and the local appliance monitoring kits supported per hub:</li>
			</ul>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="Images/Figure_03_03.jpg" alt="Figure 3.3 – An example of the tree topology for managing a fleet of connected hubs&#13;&#10;" width="621" height="361"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – An example of the tree topology for managing a fleet of connected hubs</p>
			<ul>
				<li><strong class="bold">Hybrid topology</strong>: If our<a id="_idIndexMarker184"/> product design or hub device budget didn't allow running ML workloads at the edge and simply handled the cloud connectivity on behalf of the kits, this would necessitate a <strong class="bold">hybrid</strong> topology. In a <a id="_idIndexMarker185"/>hybrid topology, the hub might centralize just enough resources to establish the cloud connectivity and routes messages back and forth between the kits and the cloud service. Here, hybrid defines the additional topological complexity of running further compute workloads, such as our ML inference, in the cloud. In this scenario, the cloud-based ML workloads making inferences against incoming telemetry would require some subset of device messages to be transmitted to the cloud. Some scenarios might opt to reduce the bill of materials of the hub in favor of a cloud-based ML solution. This makes sense when the volume of traffic is on the lower end of the spectrum or when the number of ML workloads exceeds what is reasonable to run on a single gateway device. The following diagram shows a modified example of our fictional product design running as a hybrid:</li>
			</ul>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="Images/Figure_03_04.jpg" alt="Figure 3.4 – An example of hybrid topology with remote compute and storage resources&#13;&#10;" width="1278" height="613"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – An example of hybrid topology with remote compute and storage resources</p>
			<p>There are two additional patterns that are common when studying network topologies, that is, the mesh and ring topologies: </p>
			<ul>
				<li>In a <strong class="bold">mesh topology</strong>, nodes <a id="_idIndexMarker186"/>can have <a id="_idIndexMarker187"/>one-to-many relationships with other nodes and exchange information through that network of connections to reach that information's destination:</li>
			</ul>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="Images/Figure_03_05.jpg" alt="Figure 3.5 – A mesh topology where a sensor on gateway 2 traverses the mesh to &#13;&#10;reach an actuator on gateway 5&#13;&#10;" width="521" height="391"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – A mesh topology where a sensor on gateway 2 traverses the mesh to reach an actuator on gateway 5</p>
			<ul>
				<li>In a <strong class="bold">ring topology</strong>, nodes <a id="_idIndexMarker188"/>have at most two<a id="_idIndexMarker189"/> neighboring connections and exchange information through the ring until it reaches its destination: </li>
			</ul>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="Images/Figure_03_06.jpg" alt="Figure 3.6 – A ring topology where a sensor reading from gateway 2 passes through adjacent gateways to reach an actuator at gateway 3&#13;&#10;" width="521" height="461"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – A ring topology where a sensor reading from gateway 2 passes through adjacent gateways to reach an actuator at gateway 3</p>
			<p>These patterns emphasize decentralization where nodes connect to each other directly. While these patterns have their time and place in the broader spectrum of IoT solutions, they are infrequently used in edge ML solutions where a gateway or hub device and cloud service are often best practices or outright requirements. </p>
			<p>When deciding on a particular topology for your solution architecture, start by considering whether all devices at the edge are weighted equally or whether they will communicate with a central node such as a gateway. A consumer product design for an edge ML solution tends to use the star pattern when thinking about the edge in isolation. A good edge solution should be able to operate in its star pattern even when any external link to a larger tree or hybrid topology is severed. We use the star pattern to implement the HBS product since the hub device will run any and all ML runtime workloads that we require. </p>
			<p>IoT Greengrass is <a id="_idIndexMarker190"/>designed to run as the hub of a star implementation<a id="_idIndexMarker191"/> and plug into a larger tree or hybrid topology connecting to the AWS cloud. Solution architects can choose how much or how little compute work is performed by the gateway device running IoT Greengrass. In the next section, we will review the protocols used to exchange messages at the edge and between the edge and cloud.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Reviewing common standards and protocols</h1>
			<p>Protocols <a id="_idIndexMarker192"/>define the specifications for exchanging messages with an edge solution. This means the format of the message, how it is serialized over the wire, and also the networking protocols for communicating between two actors in the solution. Standards and protocols help us to architect within best practices and enable quick decision-making when selecting implementations. Before diving into the common protocols that are used in edge solutions, first, let's review two architectural standards used in information technology and operations technology to gain an understanding of where IoT Greengrass fits into these standards. Using these as a baseline will help set the context for the protocols used and how messages traverse these models in an edge solution. </p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>IoT Greengrass in the OSI model</h2>
			<p>The <strong class="bold">Open Systems Interconnection</strong> (<strong class="bold">OSI</strong>) model <a id="_idIndexMarker193"/>defines a stack of seven layers of network communications, describing the <a id="_idIndexMarker194"/>purpose and media used to exchange information between devices at each layer. At the top of the stack is layer seven, the <em class="italic">application layer</em>, where high-level APIs and transfer protocols are <a id="_idIndexMarker195"/>defined. At the bottom is layer one, the <em class="italic">physical layer</em>, where digital bits are transmitted over physical media using electricity and radio signals. The following is a diagram of the OSI model and shows how IoT Greengrass fits in with individual layers:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="Images/Figure_03_07.jpg" alt="Figure 3.7 – An OSI model with an overlay of IoT Greengrass layer interactions&#13;&#10;" width="625" height="507"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – An OSI model with an overlay of IoT Greengrass layer interactions</p>
			<p>Here, you <a id="_idIndexMarker196"/>can observe that our runtime orchestrator, IoT Greengrass, operates from layer four to layer seven. There <a id="_idIndexMarker197"/>are high-level applications and transfer protocols used in the IoT Greengrass Core software to exchange application messages with the AWS cloud and local devices using protocols such as HTTPS and MQTT. Additionally, libraries bundled in the core software are responsible for the transport layer communications in the TCP/IP stack, but then further transmission throughout the OSI model is handed off to the host operating system.</p>
			<p>Note that while the IoT Greengrass Core software operates from layer four to layer seven, the software components deployed to your edge solution might reach all the way down to layer one. For example, any sensors or actuators physically connected to the IoT Greengrass device could be accessed with code running in a component, usually with a low-level library API.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>IoT Greengrass in ANSI/ISA-95</h2>
			<p><strong class="bold">American National Standards Institute/International Society of Automation standard 95</strong> (<strong class="bold">ANSI/ISA-95</strong>) defines<a id="_idIndexMarker198"/> the process in which to relate the interfaces between<a id="_idIndexMarker199"/> the enterprise<a id="_idIndexMarker200"/> and control systems. This standard is used in enterprise and industrial solution architectures. It describes another layered hierarchy; this one is for the level at which systems are controlled and suggests the time scale at which decisions must be made. The following diagram presents another frame of reference for how IoT Greengrass and an edge ML solution fit into a holistic picture:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="Images/Figure_03_08.jpg" alt="Figure 3.8 – The ISA-95 model with an overlay of IoT Greengrass layer interactions&#13;&#10;" width="1268" height="737"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – The ISA-95 model with an overlay of IoT Greengrass layer interactions</p>
			<p>Here, you can <a id="_idIndexMarker201"/>observe that IoT Greengrass primarily fits in layer three, the <em class="italic">Monitoring and Supervising</em> layer <a id="_idIndexMarker202"/>of control systems, to facilitate the upward aggregation of device telemetry, downward distribution of commands, and handle some decision making in a supervisory capacity. IoT Greengrass is useful in any kind of edge solution, be it consumer-grade products or to facilitate the operation of industrial machinery. While our HBS product example is not an industrial use case, the same pattern applies in that our hub device performs as a gateway for sensor monitoring equipment.</p>
			<p>Now that you have a framework regarding how IoT Greengrass fits into these hierarchies, we can review common protocols that are used at the relevant layers.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Application layer protocols</h2>
			<p>Examples <a id="_idIndexMarker203"/>of application layer <a id="_idIndexMarker204"/>communications include requesting data from an API, publishing sensor telemetry, or sending a command to a device. This kind of data is relevant to the solution itself and the business logic in service of your solution's outcomes. For example, none of the other layers of the OSI model, such as the transport layer or the network layer, make decisions in the event that a deployed sensor is reporting the <a id="_idIndexMarker205"/>ambient temperature at 22°C. Only the running applications of your solution can use this data and send or receive that data by interacting with the application layer.</p>
			<p>To <a id="_idIndexMarker206"/>communicate between the edge and the cloud, the most popular application layer <a id="_idIndexMarker207"/>protocol is <strong class="bold">HTTPS</strong> for request-response interactions. IoT Greengrass uses HTTPS to interact with AWS cloud services for the purposes of fetching metadata and downloading resources for your components, such as the component recipe and artifacts such as your code and trained ML models. Additionally, your custom components running at the edge might use HTTPS to interact with other AWS services, on-premises systems, and the APIs of other remote servers.</p>
			<p>To exchange messages between the edge and the cloud, and within the edge solution, bi-directional messaging protocols (also called <em class="italic">publish-subscribe</em> or <em class="italic">pubsub</em>) are commonly used, such as MQTT or AMQP. The <a id="_idIndexMarker208"/>benefits of these kinds of protocols are listed as follows:</p>
			<ul>
				<li>They use stateful connections to minimize the frequency of handshake connections.</li>
				<li>Traffic can flow in either direction without one end or the other having to be responsible for initiating a new exchange.</li>
				<li>They offer minimal overhead per message making them ideal for constrained devices.</li>
				<li>Clients at the edge can initiate these connections, eliminating the need for inbound connections to be permitted by network firewall rules.</li>
			</ul>
			<p>IoT Greengrass uses the MQTT protocol to open connections to the AWS IoT Core service in a client-broker model in order to pass messages from local devices up to the cloud, receive commands from the cloud and relay them to local devices, and synchronize the state after a period of disconnection. Additionally, IoT Greengrass can serve as the broker to other local devices that connect to it via MQTT. The following is a diagram of an IoT Greengrass device, such as the HBS hub device, acting as both the client and the broker:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="Images/Figure_03_09.jpg" alt="Figure 3.9 – The HBS hub acting as both a client to AWS IoT and a server to local devices&#13;&#10;" width="1069" height="531"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – The HBS hub acting as both a client to AWS IoT and a server to local devices</p>
			<p>Next up are <a id="_idIndexMarker209"/>the message format<a id="_idIndexMarker210"/> protocols that describe the way data is structured as it is sent over the application layer protocols.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Message format protocols</h2>
			<p>If a <a id="_idIndexMarker211"/>messaging protocol <a id="_idIndexMarker212"/>such as MQTT specifies how connections are established and how messages are exchanged, a <em class="italic">message format protocol</em> specifies what the shape and content of an exchanged message are. You can consider a telephone as an analogy. The telephone handset represents how speech is sent in both directions, but the language being spoken by the participants at both ends must be understood in order for that speech to make sense! In this analogy, MQTT represents the telephone itself (abstracting away the public telephone exchange network), and the message format protocol is the language being spoken by the people on either end. </p>
			<p>For any two participants exchanging data with each other, that data is either transmitted as binary or it will go through a process of serialization and deserialization. Common message format protocols used in edge solutions include <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>), Google<strong class="bold"> Protocol Buffers</strong> (<strong class="bold">protobuf</strong>), and <strong class="bold">Binary JSON </strong>(<strong class="bold">BSON</strong>). These <a id="_idIndexMarker213"/>formats make it easier for devices, edge <a id="_idIndexMarker214"/>components, and <a id="_idIndexMarker215"/>cloud solutions to interoperate. This is especially important in an architecture that is inclusive of mixed programming languages. The message format is a means of abstraction that is key to architecting solutions. By using a serializable message format protocol, the following <a id="_idIndexMarker216"/>diagram shows how a component written in Python can exchange messages with a component written in Java:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="Images/Figure_03_10.jpg" alt="Figure 3.10 – An example of serialization/deserialization using Greengrass components&#13;&#10;" width="702" height="207"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – An example of serialization/deserialization using Greengrass components</p>
			<p>You could <a id="_idIndexMarker217"/>send all messages as binary data, but you would end up with an overhead in each recipient that would need to figure out what to do with that data or enact strict conventions for what can be sent. For example, a sensor device that only ever sends a numerical measurement in degrees centigrade could just send the value as binary data. If that system never changes, there's limited value to adding notation and serializing it. The recipient on the other end can be hardcoded to know what to do with it, thus saving overhead on metadata, structure, and bandwidth. This works for rigid, static systems and for cases where transmission costs must be the top priority for optimization. </p>
			<p>Unstructured data such as images, video, and audio is commonly sent as binary payloads but with an accompanying header indicating what kind of data it is. In an HTTP request, the <em class="italic">Content-Type</em> header will include a value such as <em class="italic">text/HTML</em> or a MIME type such as <em class="italic">video/MP4</em>. This header tells the recipient how to process the binary payload of that message.</p>
			<p>The <strong class="bold">interprocess communication</strong> (<strong class="bold">IPC</strong>) functionality<a id="_idIndexMarker218"/> that is provided by IoT Greengrass to components to enable the exchange of messages between them supports the JSON message format along with the raw binary format. In this chapter, you will build two components that use IPC to pass JSON messages from one component to the other.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since IoT Greengrass does not prescribe any particular protocol to interact with edge devices and systems, you can easily implement components that include libraries to interact with any device and any protocol. </p>
			<p>The key <a id="_idIndexMarker219"/>takeaway <a id="_idIndexMarker220"/>regarding protocols is that we can use common protocols for the same, or similar, advantages as we use a good architecture pattern. They are battle-tested, well-documented, easy to implement, and prevent us from getting lost in the cycles of implementation details where our time would be better spent on delivering outcomes. In the next section, we will cover, at a high level, the security threats for an edge ML solution and some best practices and tools for mitigating them.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/>Security at the edge</h1>
			<p>With IoT <a id="_idIndexMarker221"/>security being a hot topic and frequently making headlines, security in your edge ML solutions must be your top priority. Your leadership at HBS will never want to see their company or product name in the news for a story concerning a <a id="_idIndexMarker222"/>hacked device. Ultimately, security is about establishing and maintaining trust with your customer. You can use a threat modeling exercise such as STRIDE to analyze atomic actors in your edge system such as end devices, gateways, and software components to reason about worst-case scenarios and the minimum viable mitigation to prevent them. In this section, we will cover common security threats and the best practices for mitigating them.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>End devices to your gateway</h2>
			<p>Let's start <a id="_idIndexMarker223"/>with the terminal segment in our edge ML solution along with the appliance monitoring kit itself and its connection to the hub device. The worst-case scenario for this segment is that an unhealthy appliance is mistakenly reported as healthy. If a customer installs the product and it fails to do the one thing it advertises, this will lose all customer trust in the product. To mitigate this scenario, the sensor readings from the monitoring kit must be authentic. This means we must prevent the hub device from receiving false measurements from a spoofed kit. </p>
			<p>Here, the <a id="_idIndexMarker224"/>best practice is to use some form of secret material that only the kit and the hub device understand. A secret can be a pre-shared key in a symmetrical cryptographic model, or it could be a public key and private key pair in an asymmetrical cryptographic model. If the kit can sign measurements sent to the hub device with a secret, then only the hub device can read them, and it will understand that it could only come from the device that it's paired with. Similarly, the monitoring kit would only act on messages, such as a request to update firmware, if those messages were signed by a secret it recognizes from the paired hub device. </p>
			<p>A safe design pattern for our pairing process between the monitoring kit and hub device is to task the customer with a manual step, such as a physical button press. This is similar to the Wi-Fi pairing method<a id="_idIndexMarker225"/> called <strong class="bold">Wi-Fi Protected Setup</strong> (<strong class="bold">WPS</strong>). If the customer has to manually start the pairing process, this means it is harder for an attacker to initiate communication with either the kit or the hub. If an attacker has physical access to the customer's premises to initiate pairing with their own device, this would be a much larger security breach that compromises our future product. </p>
			<p>IoT Greengrass provides a component <a id="_idIndexMarker226"/>called <em class="italic">secret manager</em> to help with this use case. The secret manager component can securely retrieve secret materials from the cloud through the AWS Secrets Manager service. You can build workflows into your edge solution, such as the monitoring kit pairing process, to establish a cryptographically verifiable relationship between your devices. </p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>The gateway device</h2>
			<p>The <a id="_idIndexMarker227"/>following list <a id="_idIndexMarker228"/>of risks and mitigations focus on the gateway device itself, which runs the IoT Greengrass Core software:</p>
			<ul>
				<li><strong class="bold">Secure connectivity to the cloud</strong>: So, how do you ensure that the connection <a id="_idIndexMarker229"/>between the core device and the cloud service, such as AWS IoT Core, is secure? Well, here, the worst-case scenarios are that the messages exchanged have been accessed, tampered with, or delivered to a spoofed endpoint. The best practice, and the one built into IoT Greengrass, is to<a id="_idIndexMarker230"/> use a <strong class="bold">public key infrastructure</strong> (<strong class="bold">PKI</strong>) and mutual validation. PKI implements asymmetrical cryptography by generating private keys and public certificates. A recipient uses the public certificate to validate <a id="_idIndexMarker231"/>that the messages from the sender are authentic. In a mutual validation model, both ends of a connection use this structure to prove the authenticity of the other during the handshake. Devices that include a <strong class="bold">Trusted Platform Module</strong> (<strong class="bold">TPM</strong>), which <a id="_idIndexMarker232"/>comes with a private key securely stored in it, can generate certificates for use in PKI without ever exposing the private key.</li>
				<li><strong class="bold">Inbound network connections</strong>: Any device on a network could be susceptible <a id="_idIndexMarker233"/>to receiving incoming connection requests. The worst-case scenario is that an attacker gains remote access to a system and starts probing the system or executing code. The best practice for establishing connections is to refuse inbound-initiated connections and rely on outbound, client-initiated connections instead. </li>
				<li><strong class="bold">Boot tampering</strong>: So, what <a id="_idIndexMarker234"/>happens if a device is physically modified between the point of manufacture and when a customer receives it? Well, malicious code could be loaded onto the device to be executed when it is received by the customer and added to the network. To prevent any tampering of the device, design your hardware platform with (or build on top of existing platforms that use) a TPM. A TPM can be used to validate that an encrypted disk has not been modified between boot sequences. </li>
			</ul>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Edge components</h2>
			<p>Next, we will <a id="_idIndexMarker235"/>move on to the components that are running in your edge solution on the IoT Greengrass Core device:</p>
			<ul>
				<li><strong class="bold">Component integrity on disk</strong>: So, what happens if an attacker can access the <a id="_idIndexMarker236"/>component artifacts after they are deployed to the core device? The worst-case scenario is that valuable intellectual property is stolen or modified to change component behavior. In IoT Greengrass, all component resources such as artifacts and recipes <a id="_idIndexMarker237"/>are stored on disk as root. The working directories that components use for file I/O belong to the default component system user in the IoT Greengrass configuration or the override user that has been specified during deployment. The best practice is to protect the root and component system user access by limiting additional system users beyond what is needed for the components of the solution. If additional system users are required to be on the device, they should not belong to the same groups as your component users or have permissions to escalate privilege to the root configuration.</li>
				<li><strong class="bold">Component integrity in the cloud</strong>: So, what happens if an attacker modifies the <a id="_idIndexMarker238"/>component artifacts before they are retrieved by IoT Greengrass for a deployment? The worst-case scenario is that a tampered component uses the <strong class="source-inline">RequiresPrivilege</strong> flag and then has full access to the core device. IoT Greengrass prevents this attack by computing a digest (that is, a mathematical summation for asserting the authenticity of a payload) whenever you upload and register a component. The core device will validate the digest against the component artifacts and fail if an artifact has been tampered with.</li>
				<li><strong class="bold">Model poisoning</strong>: So, what<a id="_idIndexMarker239"/> happens if an attacker compromises a model-backed decision-making process? For example, a camera feed using a local ML model to detect anomalous presence activity gets retrained with new data once a week. If an attacker understands the retraining loop, they can poison the training data over time with the intent of shifting the anomaly threshold to their advantage. To mitigate model poisoning, use <strong class="bold">human-in-the-loop validation</strong> to approve of new labeled data used in<a id="_idIndexMarker240"/> training. Human-in-the-loop validation means that you have a mechanism for your human experts to review unusual results, flagged results, or subsets of results as model quality assurance. Additionally, you can use a static approved training dataset to test later generations of models against their original success benchmark.</li>
				<li><strong class="bold">IPC</strong>: When<a id="_idIndexMarker241"/> multiple components are deployed to an IoT Greengrass Core device, some of those components might need to exchange messages with each other over IPC. The worst-case scenario is that a subscribing component receives commands from a component that shouldn't be allowed to control it. Another scenario is that sensitive data is leaked to a component that isn't approved to have access to the data. IoT Greengrass provides a security control for the IPC functionality that allows you to specify explicit topics that components are allowed to use in publish and subscribe operations, respectively. A recommended practice is to design and document your topic tree, indicating which topics are sensitive. In this way, you can use automated review mechanisms to flag recipes in your development life cycle that use the <strong class="source-inline">*</strong> wildcard, or sensitive topics, for explicit approval.</li>
			</ul>
			<p>So, this section covered a few high-risk security threats and the built-in mitigations provided by IoT Greengrass along with several best practices you can implement. Security at the edge is both complex and complicated. You can use threat modeling to identify the worst-case scenarios and best practices to mitigate those threats. In the next section, you will continue your journey as the HBS IoT architect by connecting two devices using components that deliver a simple sensor-to-actuator flow.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Connecting your first device – sensing at the edge</h1>
			<p>In this section, you<a id="_idIndexMarker242"/> will deploy a new component that delivers the first sensing capability of your edge solution. In the context of our HBS appliance monitoring kit and hub device, this first component will represent the sensor of an appliance monitoring kit. The sensor <a id="_idIndexMarker243"/>reports to the hub device the measured temperature and humidity of an attached <strong class="bold">heating, ventilation, and air conditioning</strong> (<strong class="bold">HVAC</strong>) appliance. Sensor data will be written to a local topic using the IPC feature of IoT Greengrass. A later section will deploy another component that consumes this sensor data.</p>
			<p>If you are using a Raspberry Pi and a Sense HAT for your edge device, the temperature and humidity measurements will be taken from the Sense HAT board. For any other project <a id="_idIndexMarker244"/>configurations, you will use a software data producer component to simulate measurements of new data. Component definitions for both paths are available in the GitHub repository, in the <strong class="source-inline">chapter3</strong> folder. </p>
			<p>Both versions of the component have been written for the Python 3 runtime and defined using Python virtual environments to isolate dependencies. You will deploy one or the other using <strong class="source-inline">greengrass-cli</strong> to create a new local deployment that merges with the component. This chapter covers steps regarding how to install the component that reads from and writes to the Sense HAT. Any procedural differences for the data producer and consumer components are covered in the GitHub repository's <strong class="source-inline">README.md</strong> file.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Installing the sensor component</h2>
			<p>Installing this <a id="_idIndexMarker245"/>component is just like installing the <strong class="source-inline">com.hbs.hub.HelloWorld</strong> component from <a href="B17595_02_Final_SS_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Foundations of Edge Workloads</em>. You will use the IoT Greengrass CLI to merge in a predefined component using the <strong class="source-inline">deployment</strong> command:</p>
			<ol>
				<li>On your hub device (Raspberry Pi), clone the Git repository that contains the book's companion resources: <p class="source-code"><strong class="bold">cd ~/ &amp;&amp; git clone https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge-.git</strong></p></li>
				<li>Change directory into the cloned folder for <strong class="source-inline">chapter3</strong>:<p class="source-code"><strong class="bold">cd Intelligent-Workloads-at-the-Edge-/chapter3</strong></p></li>
				<li>Create a deployment to include the <strong class="source-inline">com.hbs.hub.ReadSenseHAT</strong> component (or <strong class="source-inline">com.hbs.hub.ReadSenseHATSimulated</strong> if working on hardware other than a Raspberry Pi): <p class="source-code"><strong class="bold">sudo /greengrass/v2/bin/greengrass-cli deployment create --merge com.hbs.hub.ReadSenseHAT=1.0.0 --recipeDir recipes/ --artifactDir artifacts/</strong></p></li>
				<li>You can monitor the progress of the deployment in the log file: <p class="source-code"><strong class="bold">sudo tail -f /greengrass/v2/logs/greengrass.log</strong></p></li>
				<li>When<a id="_idIndexMarker246"/> the logs stop updating from the deployment, you can validate that the component was installed successfully:<p class="source-code"><strong class="bold">sudo /greengrass/v2/bin/greengrass-cli component list</strong></p></li>
				<li>You should observe the <strong class="bold">RUNNING</strong> status for <strong class="source-inline">com.hbs.hub.ReadSenseHAT</strong>.</li>
			</ol>
			<p>Now that the component has been installed, let's review the component.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Reviewing the sensor component</h2>
			<p>Let's <a id="_idIndexMarker247"/>review some interesting bits from this sensor component so that you have a better idea of what's going on in this component. In this section, we will review a few highlights, starting with the recipe file.</p>
			<h3>IPC permissions</h3>
			<p>In the <strong class="source-inline">com.hbs.hub.ReadSenseHAT-1.0.0.json</strong> section, we are using a new concept in <a id="_idIndexMarker248"/>the configuration called <strong class="source-inline">accessControl</strong>. This configuration defines the features of IoT Greengrass that the component is allowed to use. In this case, the recipe is defining a permission to use IPC and publish messages to any local topic. The operation is <strong class="source-inline">aws.greengrass#PublishToTopic</strong>, and the resource is the <strong class="source-inline">*</strong> wildcard, meaning the component is permitted to publish to any topic. In a later section, you will observe a different permission defined here to subscribe to IPC and receive the messages being published by this component. Here is the relevant section of the recipe file showing the <strong class="source-inline">accessControl</strong> configuration:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">com.hbs.hub.ReadSenseHAT-1.0.0.json</p>
			<p class="source-code">  "ComponentConfiguration": {</p>
			<p class="source-code">    "DefaultConfiguration": {</p>
			<p class="source-code">      "accessControl": {</p>
			<p class="source-code">        "aws.greengrass.ipc.pubsub": {</p>
			<p class="source-code">          "com.hbs.hub.ReadSenseHAT:pubsub:1": {</p>
			<p class="source-code">            "policyDescription": "Allows publish operations on local IPC",</p>
			<p class="source-code">            "operations": [</p>
			<p class="source-code">              "aws.greengrass#PublishToTopic"</p>
			<p class="source-code">            ],</p>
			<p class="source-code">            "resources": [</p>
			<p class="source-code">              "*"</p>
			<p class="source-code">            ]</p>
			<p class="source-code">          }</p>
			<p class="source-code">        }</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p>In the <a id="_idIndexMarker249"/>preceding JSON snippet, you can see that the default configuration for this component includes the <strong class="source-inline">accessControl</strong> key. The first child of <strong class="source-inline">accessControl</strong> is a key that is used to describe which system permission we are setting. In this scenario, the permission is for the <strong class="source-inline">aws.greengrass.ipc.pubsub</strong> system. The next child key is a unique policy ID that must be unique across all of your components. The best practice is to use the format of <em class="italic">component name, system name or shorthand, and a counter</em>, all joined by colon characters. The list of operations includes just one permission for publishing messages, but it could also include the operation for subscribing. Finally, the list of resources indicates the explicit list of topics permitted for the preceding operations. In this scenario, we use the <strong class="source-inline">*</strong> wildcard for simplicity; however, a better practice for observing the principle of least privilege is to exhaustively enumerate topics.</p>
			<h3>Multiple life cycle steps</h3>
			<p>In the <a id="_idIndexMarker250"/>simple <strong class="source-inline">"Hello, world"</strong> component, there was just a single life cycle step to invoke the shell script at runtime. In this component, you can see that we are using two different life cycle steps: install and run. Each life cycle step is processed at a different event in the IoT Greengrass component life cycle:</p>
			<ul>
				<li>The <strong class="bold">Bootstrap</strong> step is <a id="_idIndexMarker251"/>evaluated when the component is first deployed or when a new version of the component is deployed. You should include instructions in the Bootstrap life cycle when you want Greengrass or the device to restart. This component doesn't require any restarts, so we exclude it from the recipe.</li>
				<li>The <strong class="bold">Install</strong> step<a id="_idIndexMarker252"/> will run each time the component is launched, for example, after any time the device restarts and Greengrass is restarting components. Here, you should include instructions that install or configure dependencies before your main component code starts. </li>
				<li>The <strong class="bold">Run</strong> step is <a id="_idIndexMarker253"/>only evaluated after the <strong class="source-inline">Bootstrap</strong> and <strong class="source-inline">Install</strong> scripts have been completed successfully. Use the <strong class="source-inline">Run</strong> step to run an application or one-off activity.</li>
				<li>Another kind of life cycle step is<a id="_idIndexMarker254"/> the <strong class="bold">Startup</strong> step and its <a id="_idIndexMarker255"/>matching <strong class="bold">Shutdown</strong> step. Use these steps to start and stop system background processes, services, and daemons. Note that you can only use either <strong class="source-inline">Run</strong> or <strong class="source-inline">Startup</strong> in a recipe, not both.<p class="callout-heading">Note</p><p class="callout">The IoT Greengrass Core software supports multiple life cycle events in order to provide flexible use of the component recipe model and component dependency graph. A complete definition of these life cycle events can be found in the <em class="italic">References</em> section, which is at the end of the chapter. The <strong class="source-inline">Run</strong>, <strong class="source-inline">Install</strong>, and <strong class="source-inline">Startup</strong> life cycle events are the most commonly used in component recipes.</p></li>
			</ul>
			<p>Let's take a closer look at the life cycle steps of this recipe:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">com.hbs.hub.ReadSenseHAT-1.0.0.json</p>
			<p class="source-code">"Lifecycle": {</p>
			<p class="source-code">        "Install": {</p>
			<p class="source-code">          "RequiresPrivilege": true,</p>
			<p class="source-code">          "Script": "usermod -a -G i2c,input ggc_user &amp;&amp; apt update &amp;&amp; apt upgrade -y &amp;&amp; apt install python3 libatlas-base-dev -y &amp;&amp; python3 -m venv env &amp;&amp; env/bin/python -m pip install -r {artifacts:path}/requirements.txt"</p>
			<p class="source-code">        },</p>
			<p class="source-code">        "Run": {</p>
			<p class="source-code">          "Script": "env/bin/python {artifacts:path}/read_senseHAT.py"</p>
			<p class="source-code">        }</p>
			<p class="source-code">      }</p>
			<p>In this<a id="_idIndexMarker256"/> recipe, we use the <strong class="source-inline">Install</strong> step to make system-level changes that require escalated permissions, such as making sure Python is installed. The <strong class="source-inline">Install</strong> step uses <strong class="source-inline">pip</strong> to install any Python libraries defined by the <strong class="source-inline">requirements.txt</strong> file in our component artifacts. Finally, the <strong class="source-inline">Run</strong> step invokes Python to start our program.</p>
			<h3>Virtual environments</h3>
			<p>In this <a id="_idIndexMarker257"/>Python component, we are using a feature of Python 3 called virtual environments. A virtual environment allows you to specify an explicit version of the Python runtime to use when interpreting code. We use this to install any dependency libraries locally, so neither the dependencies nor runtime conflict with the system-level Python. This reinforces the best practice of applying isolation to our component. The relative invocation of <strong class="source-inline">env/bin/python</strong> is telling the script to use the virtual environment's version of Python instead of the one at the system level at <strong class="source-inline">/usr/bin/python</strong>. </p>
			<p>This component uses a <strong class="source-inline">requirements.txt</strong> file to store information about the Python packages used and the versions of those packages to install. The requirements file is stored<a id="_idIndexMarker258"/> as an artifact of the component, along with the Python code file. Since it is an artifact, the command to <strong class="source-inline">pip</strong> must use the <strong class="source-inline">{artifacts:path}</strong> variable provided by IoT Greengrass to locate this file on disk.</p>
			<p>We could achieve even better isolation for our component in one of two ways: </p>
			<ul>
				<li><strong class="bold">System-level Python runtime management</strong>: We could use a more specific methodology <a id="_idIndexMarker259"/>to load Python runtimes onto the device and reference the version this component needs. There is a risk of using the system-level Python 3 runtime that the recipe installs in the Bootstrap script since another component could later install a different Python 3 runtime. The best practice would be to use further components as dependencies to install each specific runtime that our component requires access to. In this way, a component such as this one could depend on a component that installs Python 3.7 and another component could depend on a component that installs Python 3.9, without conflicting with each other. </li>
				<li><strong class="bold">Containerization</strong>: Containers<a id="_idIndexMarker260"/> are a piece of technology used to enforce even stricter process and dependency isolation than a Python virtual environment. We could build and deploy our sensor component in a Docker container that includes the Python runtime, system packages, and Python libraries and perform any additional custom steps in a container environment before invoking our Python code. This would achieve the best level of isolation; however, it has the drawback of increased complexity to develop and requires more total disk space consumption to achieve that level of isolation. For a production environment, you, as the IoT architect, are responsible for making trade-offs on how much isolation is warranted for the additional overhead.</li>
			</ul>
			<p>Since this HBS project is a prototype and we are using a Raspberry Pi device that comes with Python 3 preinstalled, it is within acceptable risk to simply ensure Python 3 is installed. A comprehensive isolation approach with containers for every component could fit, but the lighter-weight approach with Python virtual environments is sufficient at this prototype stage.</p>
			<h3>Permissions to Unix devices</h3>
			<p>The code that <a id="_idIndexMarker261"/>reads from your Sense HAT device uses the Sense HAT Python library to read values from the device files that the Unix kernel exposes as device interfaces. These device files, such as <strong class="source-inline">/dev/i2c-1</strong> and <strong class="source-inline">/dev/input/event2</strong>, are restricted to system users in groups such as <strong class="source-inline">i2c</strong> and <strong class="source-inline">input</strong>. The root user has access to these devices and a Raspberry Pi, and so does the default <strong class="source-inline">pi</strong> user. Our default component user, <strong class="source-inline">ggc_user</strong>, is not in these groups; therefore, code run as <strong class="source-inline">ggc_user</strong> will not be able to access values from these device interfaces. There are three ways to resolve this issue, which are listed as follows:</p>
			<ul>
				<li>First, you could add <strong class="source-inline">ggc_user</strong> to the <strong class="source-inline">i2c</strong> and <strong class="source-inline">input</strong> groups using a system command such as <strong class="source-inline">usermod -a -G i2c,input ggc_user</strong>. </li>
				<li>Second, you could set the <strong class="source-inline">RequiresPrivilege</strong> flag in the component recipe's <strong class="source-inline">Run</strong> script to <strong class="source-inline">true</strong>. </li>
				<li>Third, you could override which system user the component should run at deployment time by adding the <strong class="source-inline">--runWith COMPONENT:posixUser=USERNAME</strong> flag. (This can be done with a configuration change in the deployment component in production components, which is covered in <a href="B17595_04_Final_SS_ePub.xhtml#_idTextAnchor073"><em class="italic">Chapter 4</em></a>, <em class="italic">Extending the Cloud to the Edge</em>.)</li>
			</ul>
			<p>The best practice is to update the groups that the <strong class="source-inline">ggc_user</strong> component user is in. This reduces how often we use privileged access in our IoT Greengrass components and maintains our isolation principle by bundling the requirement in our recipe file. Running the component as the <strong class="source-inline">pi</strong> user isn't bad; however, as a developer, you should not assume this user will exist on every device and have the necessary permissions just because they are operating system defaults. For convenience, here is another clip of the life cycle step that sets up our user permissions for <strong class="source-inline">ggc_user</strong>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">com.hbs.hub.ReadSenseHAT-1.0.0.json</p>
			<p class="source-code">"Lifecycle": {</p>
			<p class="source-code">  "Install": {</p>
			<p class="source-code">    "RequiresPrivilege": true,</p>
			<p class="source-code">    "Script": "usermod -a -G i2c,input ggc_user &amp;&amp; apt update &amp;&amp; apt upgrade -y &amp;&amp; apt install python3 libatlas-base-dev -y &amp;&amp; python3 -m venv env &amp;&amp; env/bin/python -m pip install -r {artifacts:path}/requirements.txt"</p>
			<p class="source-code">  },</p>
			<p>This covers the<a id="_idIndexMarker262"/> interesting new features used in the component recipe file. Next, let's take a deep dive into important bits of the code.</p>
			<h3>Logging</h3>
			<p>A critical part <a id="_idIndexMarker263"/>of monitoring your components is to log important events. These lines set up a logger object that you can use throughout your Python code. This should be standard in every application:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">read_senseHAT.py</p>
			<p class="source-code">logger = logging.getLogger()</p>
			<p class="source-code">handler = logging.StreamHandler(sys.stdout)</p>
			<p class="source-code">logger.setLevel(logging.INFO)</p>
			<p class="source-code">logger.addHandler(handler)</p>
			<p>When building Python applications for IoT Greengrass, you can copy lines such as these to Bootstrap logging. Note that your logger will capture logs at the <strong class="source-inline">INFO</strong> level or a level that is higher in criticality. Debug logs will not be captured unless you set the level to <strong class="source-inline">logging.DEBUG</strong>. You might set different levels of logs depending on where in the development life cycle you are, such as <strong class="source-inline">DEBUG</strong> in beta and <strong class="source-inline">INFO</strong> in production. You could set the logging level as a variable with component-level configuration and override it for a given deployment.</p>
			<h3>Reading from Sense HAT</h3>
			<p>Inside the <strong class="source-inline">build_message</strong> function is some simple code to initiate the Sense HAT interface <a id="_idIndexMarker264"/>and read values from its temperature and humidity sensors. These represent the values measured by our HBS appliance monitoring kit, attached to a fictional HVAC appliance:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Read_senseHAT.py</p>
			<p class="source-code">sense = SenseHat()</p>
			<p class="source-code">message = {}</p>
			<p class="source-code">message['timestamp'] = float("%.4f" % (time.time()))</p>
			<p class="source-code">message['device_id'] = 'hvac'</p>
			<p class="source-code">message['temperature'] = sense.get_temperature()</p>
			<p class="source-code">message['humidity'] = sense.get_humidity()</p>
			<p>This code builds up a new object, called <strong class="source-inline">message</strong>, and sets child properties equal to the values we're getting from the Sense HAT library. The code also sets a simple device ID string, and generates the current timestamp.</p>
			<h3>Publishing a message</h3>
			<p>Next, we will<a id="_idIndexMarker265"/> cover the key lines of code inside the <strong class="source-inline">publish_message</strong> function:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">read_senseHAT.py</p>
			<p class="source-code">publish_message = PublishMessage()</p>
			<p class="source-code">publish_message.json_message = JsonMessage()</p>
			<p class="source-code">publish_message.json_message.message = message</p>
			<p class="source-code">request = PublishToTopicRequest()</p>
			<p class="source-code">request.topic = topic</p>
			<p class="source-code">request.publish_message = publish_message</p>
			<p class="source-code">operation = ipc_client.new_publish_to_topic()</p>
			<p class="source-code">operation.activate(request)</p>
			<p class="source-code">future = operation.get_response()</p>
			<p class="source-code">try:</p>
			<p class="source-code">    future.result(TIMEOUT)</p>
			<p class="source-code">    logger.info('published message, payload is: %s', request.publish_message)</p>
			<p class="source-code">except Exception as e:</p>
			<p class="source-code">    logger.error('failed message publish: ', e)</p>
			<p>These lines <a id="_idIndexMarker266"/>of code prepare the message and the request that will be communicated to the IPC service of IoT Greengrass as a new publish operation. This code will look familiar in any later components that require you to publish messages to other components running on the HBS hub device.</p>
			<p>Now that we have taken a tour of the sensor application source code, let's examine what values you are measuring in the log file.</p>
			<h3>Testing the sensor component</h3>
			<p>To inspect<a id="_idIndexMarker267"/> the values that you are sampling from the sensor, you can tail the log file for this component. If you are using the <strong class="source-inline">ReadSenseHATSimulated</strong> component, make sure you inspect that log file instead.</p>
			<p>Tail the log file: </p>
			<p class="source-code">sudo tail -f /greengrass/v2/logs/com.hbs.hub.ReadSenseHAT.log</p>
			<p class="source-code">2021-06-29T01:03:07.746Z [INFO] (Copier) com.hbs.hub.ReadSenseHAT: stdout. published message, payload is: PublishMessage(json_message=JsonMessage(message={'timestamp': 1624928587.6789, 'device_id': 'hvac', 'temperature': 44.34784698486328, 'humidity': 22.96312713623047})). {scriptName=services.com.hbs.hub.ReadSenseHAT.lifecycle.Run.Script, serviceName=com.hbs.hub.ReadSenseHAT, currentState=RUNNING}</p>
			<p>You should observe new entries in the log file with the temperature and humidity measurements <a id="_idIndexMarker268"/>sampled. These values are being logged and also published over IPC to any other components that are listening for them. You don't have any other components listening on IPC yet, so now is a great time to move on to your second component.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Connecting your second device – actuating at the edge</h1>
			<p>The previously<a id="_idIndexMarker269"/> deployed component acts as a sensor to read values from a fictional appliance monitoring kit and publishes those values over IoT Greengrass IPC on a local topic. The next step is to create an actuator component that will respond to those published measurements and act upon them. Your actuator component will subscribe to the same local topic over IPC and render the sensor readings to the LED matrix of your Sense HAT board. For projects not using the Raspberry Pi with Sense HAT, the simulation actuator component will write measurements to a file as a proof of concept. </p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Installing the component</h2>
			<p>Similar to the<a id="_idIndexMarker270"/> previous installation, you will create a deployment that merges with the new component. Please refer to the earlier steps for the location of the source files and validation steps that the deployment concluded. For projects not using the Raspberry Pi with the Sense HAT module, you will deploy the <strong class="source-inline">com.hbs.hub.SimulatedActuator</strong> component instead.</p>
			<p>Create a deployment to include the <strong class="source-inline">com.hbs.hub.WriteSenseHAT</strong> component:</p>
			<p class="source-code">sudo /greengrass/v2/bin/greengrass-cli deployment create --merge com.hbs.hub.WriteSenseHAT=1.0.0 --recipeDir recipes/ --artifactDir artifacts/</p>
			<p>Once deployed, you should start seeing messages appear on the LED matrix in the format of <strong class="source-inline">t: 40.15 h:23.79</strong>. These are the temperature and humidity values reported by your sensor component. The following photograph shows a snapshot of the LED matrix scrolling through the output message:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="Images/Figure_03_11.jpg" alt="Figure 3.11 – A photograph of Sense HAT scrolling through reported sensor values&#13;&#10;" width="798" height="575"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – A photograph of Sense HAT scrolling through reported sensor values</p>
			<p>If, at any <a id="_idIndexMarker271"/>point, you get tired of seeing the scrolling messages on your device, you can simply remove the <strong class="source-inline">com.hbs.hub.WriteSenseHAT</strong> component with a new deployment, as follows:</p>
			<p class="source-code">sudo /greengrass/v2/bin/greengrass-cli deployment create --remove com.hbs.hub.WriteSenseHAT </p>
			<p>Read on to learn how this component is structured.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>Reviewing the actuator component</h2>
			<p>Let's review <a id="_idIndexMarker272"/>the interesting differences between this component and the sensor component. </p>
			<h3>Recipe file differences</h3>
			<p>Starting with <a id="_idIndexMarker273"/>the recipe file, there is only one key difference to observe. Here is a snippet of the recipe file that we'll review:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">com.hbs.hub.WriteSenseHAT-1.0.0.json</p>
			<p class="source-code">"accessControl": {</p>
			<p class="source-code">        "aws.greengrass.ipc.pubsub": {</p>
			<p class="source-code">          "com.hbs.hub.WriteSenseHAT:pubsub:1": {</p>
			<p class="source-code">            "policyDescription": "Allows subscribe operations on local IPC",</p>
			<p class="source-code">            "operations": [</p>
			<p class="source-code">              "aws.greengrass#SubscribeToTopic"</p>
			<p class="source-code">            ],</p>
			<p class="source-code">            "resources": [</p>
			<p class="source-code">              "*"</p>
			<p class="source-code">            ]</p>
			<p class="source-code">          }</p>
			<p class="source-code">        }</p>
			<p class="source-code">      }</p>
			<p>In the recipe for <strong class="source-inline">com.hbs.hub.WriteSenseHAT</strong>, the <strong class="source-inline">accessControl</strong> permission specifies a different operation, <strong class="source-inline">aws.greengrass#SubscribeToTopic</strong>. This is the inverse of what we defined in the sensor component (<strong class="source-inline">aws.greengrass#PublishToTopic</strong>). This permission allows the component to set up topic subscriptions on IPC and receive messages published by other IPC clients, such as the sensor component. The following diagram shows the <a id="_idIndexMarker274"/>contrast of IPC permissions between a publishing sensor and a subscribing actuator: </p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="Images/Figure_03_12.jpg" alt="Figure 3.12 – IPC permissions for the sensor and the actuator&#13;&#10;" width="663" height="271"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – IPC permissions for the sensor and the actuator</p>
			<p>In addition to this, the resources list uses the <strong class="source-inline">*</strong> wildcard to indicate that the component can subscribe to any local topic. Following a principle of least privilege for a production solution, this list of resources would specify the explicit list of topics to which the component is allowed to publish or subscribe. Since this hub device is a prototype, the wildcard approach is acceptable. Each of the read and write components accept arguments to override the local topic used for your own experimentation (please check out the <strong class="source-inline">main()</strong> functions to learn more). Since any topic can be passed in as an override, this is another reason to use the wildcard resource with the component permissions. Recall that this is okay for developing and testing, but the best practice for production components would be to exhaustively specify the permitted topics for publishing and subscribing.</p>
			<p>The remainder of the recipe file is essentially the same, with differences simply in the naming of the component and the Python file to invoke in the <strong class="source-inline">Run</strong> script. Also, note that we add a new user group to <strong class="source-inline">ggc_user</strong>; the <strong class="source-inline">video</strong> group enables access to the LED matrix. Next, let's review the interesting new lines of code from this component's Python file.</p>
			<h3>Receiving messages on IPC</h3>
			<p>The business logic for receiving messages over IPC and writing messages to the LED matrix is <a id="_idIndexMarker275"/>coded in <strong class="source-inline">scrolling_measurements.py</strong>. Here are a few important sections to familiarize yourself with:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">scrolling_measurements.py</p>
			<p class="source-code">class StreamHandler(client.SubscribeToTopicStreamHandler):</p>
			<p class="source-code">    def __init__(self):</p>
			<p class="source-code">        super().__init__()</p>
			<p class="source-code">    def on_stream_event(self, event: SubscriptionResponseMessage) -&gt; None:</p>
			<p class="source-code">        try:</p>
			<p class="source-code">            message = event.json_message.message</p>
			<p class="source-code">            logger.info('message received! %s', message)</p>
			<p class="source-code">            scroll_message('t: ' + str("%.2f" % message['temperature']))</p>
			<p class="source-code">            scroll_message('h: ' + str("%.2f" % message['humidity']))</p>
			<p class="source-code">        except:</p>
			<p class="source-code">            traceback.print_exc()</p>
			<p>In this selection, you can observe that a new local class is defined, called <strong class="source-inline">StreamHandler</strong>. The <strong class="source-inline">StreamHandler</strong> class is responsible for implementing the behavior of IPC client subscription methods such as the following:</p>
			<ul>
				<li><strong class="source-inline">on_stream_event</strong> is the <a id="_idIndexMarker276"/>handler defining what to do when a new message arrives.</li>
				<li><strong class="source-inline">on_stream_error</strong> is the <a id="_idIndexMarker277"/>handler defining what to do when the subscription encounters an error.</li>
				<li><strong class="source-inline">on_stream_close</strong> is the <a id="_idIndexMarker278"/>handler defining how to clean up any resources when the subscription is closed. </li>
			</ul>
			<p>Since the <a id="_idIndexMarker279"/>sensor component is publishing messages in JSON format, you can see that it is easy to get the value of that payload with <strong class="source-inline">event.json_message.message</strong>. Following this, the <strong class="source-inline">on_stream_event</strong> handler retrieves the values for both the <strong class="source-inline">temperature</strong> and <strong class="source-inline">humidity</strong> keys and sends a string to the <strong class="source-inline">scroll_message</strong> function. Here is the code for that function:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">scrolling_measurements.py</p>
			<p class="source-code">def scroll_message(message):</p>
			<p class="source-code">    sense = SenseHat()</p>
			<p class="source-code">    sense.show_message(message)</p>
			<p>That's it! You can view how easy it is to work with the Sense HAT library. The library provides the logic to manipulate the LED matrix into a scrolling wall of text. There are additional functions in the library for more fine-grained control of the LED matrix if scrolling a text message is too specific an action. You might want to render a solid color, a simple bitmap, or create an animation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In this pair of components, the messages transmitted over IPC use the JSON specification. This is a clean default for device software that can use JSON libraries since it reduces the code we have to write for serializing and deserializing messages over the wire. Additionally, using JSON payloads will reduce code for components that will exchange messages with the cloud via the AWS IoT Core service. This service also defaults to JSON payloads. However, both the IPC feature of IoT Greengrass and the AWS IoT Core service support sending messages with binary payloads. </p>
			<p>In the context of the HBS hub device and appliance monitoring kit, the Raspberry Pi and its Sense HAT board are pulling double duty when it comes to representing both devices in our prototype model. It would be impractical to ask customers to review scrolling text on a screen attached to either device. In reality, the solution would only notify customers of an important event and not signal each time the measurements are taken. However, this pattern of sensor and actuator communicating through a decoupled interface of IPC<a id="_idIndexMarker280"/> topics and messages illustrates a core concept that we will use throughout the rest of the edge solutions built in this book.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Summary</h1>
			<p>In this chapter, you learned about the topologies that are common in building edge ML solutions and how they relate to the constraints and requirements informing architectural decisions. You learned about the common protocols used in exchanging messages throughout the edge and to the cloud, and why those protocols are used today. You learned how to evaluate an edge ML solution for security risks and the best practices for mitigating those risks. Additionally, you delivered your first multi-component edge solution that maps sensor readings to an actuator using a decoupled interface. </p>
			<p>Now that you understand the basics of building for the edge, the next chapter will introduce how to build and deploy for the edge using cloud services and a remote deployment tool. In addition to this, you will deploy your first ML component using a precompiled model.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>Knowledge check</h1>
			<p>Before moving on to the next chapter, test your knowledge by answering these questions.</p>
			<p>The answers can be found at the end of the book:</p>
			<ol>
				<li value="1">What are three network topologies that are common in edge solutions? Which one is implemented by the HBS hub device and appliance monitoring kit?</li>
				<li>True or false: IoT Greengrass operates at the physical layer (that is, layer 1) of the OSI model.</li>
				<li>What is the benefit of using a publish/subscribe model to exchange messages?</li>
				<li>True or false: IoT Greengrass can act as both a messaging client and a messaging broker.</li>
				<li>Is a message such as <strong class="source-inline">{"temperature": 70}</strong> an example of structured data or unstructured data? Is it serializable?</li>
				<li>Is image data captured from a camera an example of structured data or unstructured data? Is it serializable?</li>
				<li>What do you think is the worst-case scenario if your home network router was compromised by an attacker but was still processing traffic as normal?</li>
				<li>What is a mitigation strategy for verifying authenticity between two network devices?</li>
				<li>Why is it important to protect root access via privilege escalation on a gateway device?</li>
				<li>Is there any downside to wrapping every edge component in a container?</li>
				<li>What functionality does IoT Greengrass provide to allow components to exchange messages?</li>
				<li>What is one way to make the sensor and actuator solution you deployed in this chapter more secure? (Hint: review the recipe files!)</li>
				<li>How might you redesign the sensor and actuator solution if you required a third component to interpret the sensor results before sending a message to the actuator?</li>
			</ol>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>References</h1>
			<p>Please refer to the following resources for additional information on the concepts discussed in this chapter:</p>
			<ul>
				<li><em class="italic">The STRIDE Threat Model</em>: <a href="https://docs.microsoft.com/en-us/previous-versions/commerce-server/ee823878(v=cs.20)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/commerce-server/ee823878(v=cs.20)?redirectedfrom=MSDN</a> </li>
				<li><em class="italic">OSI model</em>: <a href="https://en.wikipedia.org/wiki/OSI_model">https://en.wikipedia.org/wiki/OSI_model</a> </li>
				<li><em class="italic">ISA95, Enterprise-Control System Integration</em>: <a href="https://www.isa.org/standards-and-publications/isa-standards/isa-standards-committees/isa95">https://www.isa.org/standards-and-publications/isa-standards/isa-standards-committees/isa95</a> </li>
				<li><em class="italic">PEP 405 -- Python Virtual Environments</em>: <a href="https://www.python.org/dev/peps/pep-0405/%20%0D">https://www.python.org/dev/peps/pep-0405/ </a></li>
				<li><em class="italic">Open Container Initiative</em>: <a href="https://opencontainers.org/">https://opencontainers.org/</a> </li>
				<li>Docker: <a href="https://www.docker.com/">https://www.docker.com/</a> </li>
				<li><em class="italic">AWS IoT Greengrass component recipe reference</em>: <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/component-recipe-reference.html">https://docs.aws.amazon.com/greengrass/v2/developerguide/component-recipe-reference.html</a> </li>
			</ul>
		</div>
	</div></body></html>