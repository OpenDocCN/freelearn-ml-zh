<html><head></head><body>
<div id="_idContainer096">
<h1 class="chapter-number" id="_idParaDest-97"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-98"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.2.1">Driving Motors with Raspberry Pi Pico</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Our robot is looking ready to run. </span><span class="koboSpan" id="kobo.3.2">The first real test of a robot chassis is getting its motors to drive. </span><span class="koboSpan" id="kobo.3.3">This chapter will bring the robot to life, testing the wiring and motors, using </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">CircuitPython</span></strong><span class="koboSpan" id="kobo.5.1"> on Raspberry Pi Pico. </span><span class="koboSpan" id="kobo.5.2">We will start with simple tests for each motor and then use them together to make movements. </span><span class="koboSpan" id="kobo.5.3">Finally, we will learn more sophisticated code to control their speed and end the chapter by making </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">a path.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Driving forward </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">and back</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Steering with </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">two motors</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">An introduction to PWM </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">speed control</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Driving along a </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">planned path</span></span></li>
</ul>
<h1 id="_idParaDest-99"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.18.1">For this chapter, you will need </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.20.1">First is the built robot, as made in the </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">previous chapters</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">6 x fresh </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">AA batteries</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">A PC or laptop with a USB </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">micro cable</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Mu software to write our code and </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">upload it</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Clear floor space with a meter or so in each direction to test </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">the robot</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.30.1">All code examples are on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">at </span></span><a href="https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-05"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-05</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.33.1">.</span></span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.34.1">Driving forward and back</span></h1>
<p><span class="koboSpan" id="kobo.35.1">Our motors are attached, and the robot is looking ready to power up. </span><span class="koboSpan" id="kobo.35.2">First, we’ll use CircuitPython to make test code to try each motor in turn. </span><span class="koboSpan" id="kobo.35.3">Then, when we have demonstrated the motors running, we’ll make simple code to drive the motors straight forward and </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">then back.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.37.1">Testing each motor with CircuitPython</span></h2>
<p><span class="koboSpan" id="kobo.38.1">We will start</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.39.1"> driving our robot by looking at how we </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.40.1">connected our Raspberry Pi Pico to our motors in the </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.42.1"><img alt="Figure 5.1 – Motor connections from Raspberry Pi Pico " src="image/Figure_5.01_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.43.1">Figure 5.1 – Motor connections from Raspberry Pi Pico</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.44.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.45.1">.1</span></em><span class="koboSpan" id="kobo.46.1"> shows a closer look at the robot motor connections. </span><span class="koboSpan" id="kobo.46.2">On the left is Raspberry Pi Pico with four connections to the motor controller. </span><span class="koboSpan" id="kobo.46.3">They are on GPIO 16, 17, 18, and 19. </span><span class="koboSpan" id="kobo.46.4">These connections result in the motor controller powering the motor via one of the motor wires. </span><span class="koboSpan" id="kobo.46.5">Testing each of the Pico pins should cause a motor to </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">do something.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">Let’s try this with some code, setting up one motor, and making it drive in a single direction. </span><span class="koboSpan" id="kobo.48.2">This example is </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">motors_test_1_pin.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.52.1">
import time
import board
import digitalio
motor_A1 = digitalio.DigitalInOut(board.GP17)
motor_A1.direction = digitalio.Direction.OUTPUT
motor_A1.value = True
time.sleep(0.3)
motor_A1.value = False</span></pre>
<p><span class="koboSpan" id="kobo.53.1">This code looks very similar to the LED code from </span><a href="B18001_02.xhtml#_idTextAnchor041"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.54.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.55.1">, </span><em class="italic"><span class="koboSpan" id="kobo.56.1">Preparing Raspberry Pi Pico</span></em><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">We set </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">board.GP17</span></strong><span class="koboSpan" id="kobo.59.1">, connected to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">AIN1</span></strong><span class="koboSpan" id="kobo.61.1"> pin on the motor controller, to a </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">digital output.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">The code sets </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">GP17</span></strong><span class="koboSpan" id="kobo.65.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">True</span></strong><span class="koboSpan" id="kobo.67.1">, turning it on, then waits for 0.3 seconds, and sets the motor pin to </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">False</span></strong><span class="koboSpan" id="kobo.69.1"> to turn </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">it off.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">Type this code into </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">Mu</span></strong><span class="koboSpan" id="kobo.73.1"> and save it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">CIRCUITPY</span></strong><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">For this test, prop the robot up so that the wheels do not contact anything. </span><span class="koboSpan" id="kobo.75.3">To start this file, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">code.py</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.77.1">module too:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.78.1">
import </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">motors_test_1_pin</span></strong></pre>
<p><span class="koboSpan" id="kobo.80.1">If you recall from </span><a href="B18001_02.xhtml#_idTextAnchor041"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.81.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.82.1">, </span><em class="italic"><span class="koboSpan" id="kobo.83.1">Preparing Raspberry Pi Pico</span></em><span class="koboSpan" id="kobo.84.1">, Raspberry Pi Pico will run the content of </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">code.py</span></strong><span class="koboSpan" id="kobo.86.1"> when the robot starts or when you change a file on </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">CIRCUITPY</span></strong><span class="koboSpan" id="kobo.88.1">. </span></p>
<p><span class="koboSpan" id="kobo.89.1">When you start</span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.90.1"> this code, a motor moves for a short time and</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.91.1"> stops. </span><span class="koboSpan" id="kobo.91.2">The motor should run forward. </span><span class="koboSpan" id="kobo.91.3">If not, swap the motor output pins on this side. </span><span class="koboSpan" id="kobo.91.4">Repeat this exercise with </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">GP18</span></strong><span class="koboSpan" id="kobo.93.1"> and check whether the other motor runs </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">forward too.</span></span></p>
<h3><span class="koboSpan" id="kobo.95.1">How do you test this?</span></h3>
<p><span class="koboSpan" id="kobo.96.1">For all the remaining examples in the chapter, use the </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">following procedure:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.98.1">On the </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.99.1">Pico (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">CIRCUITPY</span></strong><span class="koboSpan" id="kobo.101.1"> drive), ensure </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.102.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">code.py</span></strong><span class="koboSpan" id="kobo.104.1"> file is empty; otherwise, it will rerun the old program until you </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">update it.</span></span></li>
<li><span class="koboSpan" id="kobo.106.1">Write your program and save it on your computer. </span><span class="koboSpan" id="kobo.106.2">You don’t want to </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">lose it!</span></span></li>
<li><span class="koboSpan" id="kobo.108.1">Copy the program (and supporting files that have changed; we will be adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">robot.py</span></strong><span class="koboSpan" id="kobo.110.1"> soon) onto </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">the Pico.</span></span></li>
<li><span class="koboSpan" id="kobo.112.1">Ensure the power switch is on and batteries </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">are installed.</span></span></li>
<li><span class="koboSpan" id="kobo.114.1">Have the robot propped up on something so that the wheels don’t </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">contact anything.</span></span></li>
<li><span class="koboSpan" id="kobo.116.1">Update </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">code.py</span></strong><span class="koboSpan" id="kobo.118.1"> to import the name of your program without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.121.1"> extension.</span></span></li>
<li><span class="koboSpan" id="kobo.122.1">The first test of the code is seeing it run </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">this way.</span></span></li>
<li><span class="koboSpan" id="kobo.124.1">To run it for real, disconnect the Pico and turn off </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">the power.</span></span></li>
<li><span class="koboSpan" id="kobo.126.1">Then, put the robot in a clear space (the carpet or floor) and power </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">it on.</span></span></li>
<li><span class="koboSpan" id="kobo.128.1">Be prepared to pick it up and turn it off if it does something unexpected – the robot can damage itself if it drives into an obstacle </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">without stopping.</span></span></li>
<li><span class="koboSpan" id="kobo.130.1">You can also </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.131.1">press </span><em class="italic"><span class="koboSpan" id="kobo.132.1">Ctrl</span></em><span class="koboSpan" id="kobo.133.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.134.1">C</span></em><span class="koboSpan" id="kobo.135.1"> from the REPL at any </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.136.1">time to stop a </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">program running.</span></span></li>
</ol>
<h3><span class="koboSpan" id="kobo.138.1">Troubleshooting</span></h3>
<p><span class="koboSpan" id="kobo.139.1">There are some ways</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.140.1"> this could go wrong. </span><span class="koboSpan" id="kobo.140.2">Let’s check a </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">few here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.142.1">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">import</span></strong><span class="koboSpan" id="kobo.144.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">code.py</span></strong><span class="koboSpan" id="kobo.146.1"> and your </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">motors_test_1_pin</span></strong><span class="koboSpan" id="kobo.148.1"> filename do not match, you’ll likely get an error in the REPL and nothing </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">will happen.</span></span></li>
<li><span class="koboSpan" id="kobo.150.1">If the robot’s UBEC is connected but the batteries are powered down, the robot may try to take too much power from the USB port. </span><span class="koboSpan" id="kobo.150.2">If you intend to test the motors, ensure the robot is powered on. </span><span class="koboSpan" id="kobo.150.3">If not, it may be good to disconnect the UBEC. </span></li>
<li><span class="koboSpan" id="kobo.151.1">If nothing still happens, disconnect the robot, turn it off, and check the wiring thoroughly – there</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.152.1"> should be no hot parts in </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">the robot.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.154.1">Now that you know how to test your code and make a simple example work, you are ready for more </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">complicated examples.</span></span></p>
<h3><span class="koboSpan" id="kobo.156.1">Testing multiple pins</span></h3>
<p><span class="koboSpan" id="kobo.157.1">Let’s extend this </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.158.1">code to test all the motor pins </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">motors_test_all_pins.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.162.1">
import time
import board
import digitalio
motor_A1 = digitalio.DigitalInOut(board.GP17)
motor_A2 = digitalio.DigitalInOut(board.GP16)
motor_B1 = digitalio.DigitalInOut(board.GP18)
motor_B2 = digitalio.DigitalInOut(board.GP19)
motor_A1.direction = digitalio.Direction.OUTPUT
motor_A2.direction = digitalio.Direction.OUTPUT
motor_B1.direction = digitalio.Direction.OUTPUT
motor_B2.direction = digitalio.Direction.OUTPUT
motor_A1.value = True
time.sleep(0.3)
motor_A1.value = False
time.sleep(0.3)
motor_A2.value = True
time.sleep(0.3)
motor_A2.value = False
time.sleep(0.3)
motor_B1.value = True
time.sleep(0.3)
motor_B1.value = False
time.sleep(0.3)
motor_B2.value = True
time.sleep(0.3)
motor_B2.value = False</span></pre>
<p><span class="koboSpan" id="kobo.163.1">This code extends the first code example to test all the motor pins. </span><span class="koboSpan" id="kobo.163.2">Update </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">code.py</span></strong><span class="koboSpan" id="kobo.165.1"> to import this instead, and you should see each wheel turn one way and then the other. </span><span class="koboSpan" id="kobo.165.2">If you do not see movement like this, please turn off the power/disconnect the robot and go back to </span><a href="B18001_04.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.166.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.167.1">, </span><em class="italic"><span class="koboSpan" id="kobo.168.1">Building a Robot around Pico</span></em><span class="koboSpan" id="kobo.169.1">, to carefully check </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">the wiring.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">We will </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.172.1">use these motors a lot. </span><span class="koboSpan" id="kobo.172.2">To save us from copying all the setup code each time, we can put it in a new file </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">robot.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.176.1">
import board
import digitalio
motor_A1 = digitalio.DigitalInOut(board.GP17)
motor_A2 = digitalio.DigitalInOut(board.GP16)
motor_B1 = digitalio.DigitalInOut(board.GP18)
motor_B2 = digitalio.DigitalInOut(board.GP19)
motor_A1.direction = digitalio.Direction.OUTPUT
motor_A2.direction = digitalio.Direction.OUTPUT
motor_B1.direction = digitalio.Direction.OUTPUT
motor_B2.direction = digitalio.Direction.OUTPUT</span></pre>
<p><span class="koboSpan" id="kobo.177.1">Now, you won’t have to type that again. </span><span class="koboSpan" id="kobo.177.2">We can </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">rewrite </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">motors_test_1_pin.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.181.1">
import time
import robot
robot.motor_A1.value = True
time.sleep(0.3)
robot.motor_A1.value = False</span></pre>
<p><span class="koboSpan" id="kobo.182.1">You can run </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.183.1">this (remember to change </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">code.py</span></strong><span class="koboSpan" id="kobo.185.1">) and apply the same change </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">motors_test_all_pins.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">This code demonstrates that we can move the motors, but how do we use </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">them together?</span></span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.191.1">Driving wheels in a straight line</span></h2>
<p><span class="koboSpan" id="kobo.192.1">In terms of motor direction, each</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.193.1"> motor pin controls this. </span><span class="koboSpan" id="kobo.193.2">Look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.195.1"><img alt="Figure 5.2 – Controlling motor direction " src="image/Figure_5.02_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.196.1">Figure 5.2 – Controlling motor direction</span></p>
<p><span class="koboSpan" id="kobo.197.1">The preceding diagram shows a box representing the connection to the motor and its pins. </span><span class="koboSpan" id="kobo.197.2">Beside each is </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">True</span></strong><span class="koboSpan" id="kobo.199.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">False</span></strong><span class="koboSpan" id="kobo.201.1">, signifying the state of the controlling pin on a Raspberry Pi Pico. </span><span class="koboSpan" id="kobo.201.2">The arrows show the conventional current direction of power to the motor. </span><span class="koboSpan" id="kobo.201.3">With one pin high, current flows from this pin; if it is low, current flows back. </span><span class="koboSpan" id="kobo.201.4">When we set motor pins to opposite values, current will flow between the motor controller outputs and a motor turns. </span><span class="koboSpan" id="kobo.201.5">If the motor pins are both low, there is no current, and the motor is</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.202.1"> turned off and can coast. </span><span class="koboSpan" id="kobo.202.2">If they are both high, the motor will stop, like brakes. </span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.203.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.204.1">In electronics, we describe current in two ways. </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">Conventional current</span></strong><span class="koboSpan" id="kobo.206.1"> describes electricity flowing from the positive terminal of a </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.207.1">power source to the negative terminal. </span><span class="koboSpan" id="kobo.207.2">However, the actual physics shows that negatively charged electrons flow the other way. </span><span class="koboSpan" id="kobo.207.3">We will stick to using conventional current to </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">avoid confusion.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">We can put this to use driving in a straight line. </span><span class="koboSpan" id="kobo.209.2">When we drive both motors together, a robot drives in a line forward or back. </span><span class="koboSpan" id="kobo.209.3">For example, look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.211.1"><img alt="Figure 5.3 – Driving in a straight line " src="image/Figure_5.03_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.212.1">Figure 5.3 – Driving in a straight line</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.213.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.214.1">.3</span></em><span class="koboSpan" id="kobo.215.1"> shows a</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.216.1"> forward arrow from each wheel showing the motors are going forward. </span><span class="koboSpan" id="kobo.216.2">The combined wheel movement results in the robot driving forward – shown by the wide arrow in front of </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">the robot.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">The lines aren’t quite straight as motors are slightly different, and it goes off slightly; we call this </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">veer</span></strong><span class="koboSpan" id="kobo.220.1">. </span><span class="koboSpan" id="kobo.220.2">We’ll see how to</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.221.1"> correct this later in </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">the book.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">Let’s make code to drive forward – </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">motors_forward.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.226.1">
import time
import robot
robot.motor_A1.value = True
robot.motor_B1.value = True
time.sleep(0.3)
robot.motor_A1.value = False
robot.motor_B1.value = False</span></pre>
<p><span class="koboSpan" id="kobo.227.1">This code sets both motors forward by enabling (setting to </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">True</span></strong><span class="koboSpan" id="kobo.229.1">) the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">A1</span></strong><span class="koboSpan" id="kobo.231.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">B1</span></strong><span class="koboSpan" id="kobo.233.1"> pins. </span><span class="koboSpan" id="kobo.233.2">It waits for 0.3 seconds (300 ms) and then stops both motors. </span><span class="koboSpan" id="kobo.233.3">To drive for longer, you can increase the time. </span><span class="koboSpan" id="kobo.233.4">Using time to approximately control distance is not very </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">accurate though.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">Going backward means using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">A2</span></strong><span class="koboSpan" id="kobo.237.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">B2</span></strong><span class="koboSpan" id="kobo.239.1"> pins </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">instead (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">motors_backward.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.243.1">
import time
import robot
robot.motor_A2.value = True
robot.motor_B2.value = True
time.sleep(0.3)
robot.motor_A2.value = False
robot.motor_B2.value = False</span></pre>
<p><span class="koboSpan" id="kobo.244.1">Other than</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.245.1"> changing the pins, this code </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">is identical.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">We can now drive forward and backward, but how do we </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">make turns?</span></span></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.249.1">Steering with two motors</span></h1>
<p><span class="koboSpan" id="kobo.250.1">If we move</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.251.1"> one motor and not the other, the robot turns toward the</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.252.1"> wheel that isn’t moving. </span><span class="koboSpan" id="kobo.252.2">For example, look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<span class="koboSpan" id="kobo.254.1"><img alt="Figure 5.4 – Steering a robot with motors " src="image/Figure_5.04_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.255.1">Figure 5.4 – Steering a robot with motors</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.256.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.257.1">.4</span></em><span class="koboSpan" id="kobo.258.1"> shows</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.259.1"> two turning robots. </span><span class="koboSpan" id="kobo.259.2">There is a forward arrow above</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.260.1"> the left wheel in the first panel, showing the wheel is driving forward. </span><span class="koboSpan" id="kobo.260.2">The right wheel is stopped. </span><span class="koboSpan" id="kobo.260.3">A transparent arrow superimposed on this shows the turn direction and that this turn pivots on the right wheel. </span><span class="koboSpan" id="kobo.260.4">The right robot shows an opposite turn. </span><span class="koboSpan" id="kobo.260.5">A robot can turn backward in the same way by reversing a single </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">motor instead.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">As we will do more with motors, we’ll extend </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">robot.py</span></strong><span class="koboSpan" id="kobo.264.1"> so that we can stop them all. </span><span class="koboSpan" id="kobo.264.2">Add this code at the end of </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">robot.py</span></strong><span class="koboSpan" id="kobo.266.1">: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
def stop():
    motor_A1.value = False
    motor_A2.value = False
    motor_B1.value = False
    motor_B2.value = False</span></pre>
<p><span class="koboSpan" id="kobo.268.1">Ensure you copy this new version onto </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">the Pico.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">We can now use our turn principle in some code – </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">motors_1_motor_turn.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.273.1">
import time
import robot
robot.motor_A1.value = True
time.sleep(0.3)
robot.stop()</span></pre>
<p><span class="koboSpan" id="kobo.274.1">This code example is very similar to the one-pin motor test. </span><span class="koboSpan" id="kobo.274.2">Only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">stop()</span></strong><span class="koboSpan" id="kobo.276.1"> command is new. </span><span class="koboSpan" id="kobo.276.2">We roughly control the angle of turn by timing. </span><span class="koboSpan" id="kobo.276.3">It is tricky but possible to get 90-degree turns, but they won’t be exact. </span><span class="koboSpan" id="kobo.276.4">Using different pins, we can turn using the motor on the other side, or reverse the current motor using the </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">same principle.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">What about</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.279.1"> using two motors? </span><span class="koboSpan" id="kobo.279.2">If we drive one motor forward </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.280.1">and the other back, we can make a faster tighter turn and spin on the spot. </span><span class="koboSpan" id="kobo.280.2">Look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.282.1"><img alt="Figure 5.5 – Spinning with two motors " src="image/Figure_5.05_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.283.1">Figure 5.5 – Spinning with two motors</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.284.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.285.1">.5</span></em><span class="koboSpan" id="kobo.286.1"> shows the robot with an arrow going forward from one motor and back from the other. </span><span class="koboSpan" id="kobo.286.2">I’ve included a rotation arrow between the two wheels, showing the pivot for this turn. </span><span class="koboSpan" id="kobo.286.3">Let’s see this in code; I suggest calling </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">motors_2_motor_turn.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.290.1">
import time
import robot
robot.motor_A1.value = True
robot.motor_B2.value = True
time.sleep(0.3)
robot.stop()</span></pre>
<p><span class="koboSpan" id="kobo.291.1">This code sets two pins high, </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">A1</span></strong><span class="koboSpan" id="kobo.293.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">B2</span></strong><span class="koboSpan" id="kobo.295.1"> – you could say, diagonally opposite pairs. </span><span class="koboSpan" id="kobo.295.2">Driving </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">A2</span></strong><span class="koboSpan" id="kobo.297.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">B1</span></strong><span class="koboSpan" id="kobo.299.1"> would spin the </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.300.1">other way. </span><span class="koboSpan" id="kobo.300.2">Again, the timing controls the angle, and then we stop all </span><a id="_idIndexMarker290"/><span class="No-Break"><span class="koboSpan" id="kobo.301.1">the motors.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">We can now move our motors, but they are on or off. </span><span class="koboSpan" id="kobo.302.2">However, we aren’t controlling the speed, and we seem to be able to do one motor turn or full spin – what about gentler sweeping turns? </span><span class="koboSpan" id="kobo.302.3">The following section will get into pulse width modulation and how this controls </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">motor speeds.</span></span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.304.1">An introduction to pulse width modulation speed control</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.305.1">Pulse Width Modulation</span></strong><span class="koboSpan" id="kobo.306.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.307.1">PWM</span></strong><span class="koboSpan" id="kobo.308.1">) is how</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.309.1"> we control motor speeds from a digital control system. </span><span class="koboSpan" id="kobo.309.2">Instead of varying the voltage supplied to a motor, we use pulses to control it. </span><span class="koboSpan" id="kobo.309.3">The pulses are usually at a fixed rate, but the ratio of time-on to time-off changes. </span><span class="koboSpan" id="kobo.309.4">We call this</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.310.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.311.1">duty cycle</span></strong><span class="koboSpan" id="kobo.312.1">. </span><span class="koboSpan" id="kobo.312.2">Controlling how much time per cycle the signal is on versus off will control the power getting to a motor. </span><span class="koboSpan" id="kobo.312.3">If the pulse is on for longer, the motor will go faster. </span><span class="koboSpan" id="kobo.312.4">The motor will go slower if the pulse is on for less time. </span><span class="koboSpan" id="kobo.312.5">So, at 50% time-on, the motor will be about 50% of its maximum speed. </span></p>
<p><span class="koboSpan" id="kobo.313.1">The following diagram shows visual examples </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">of this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.315.1"><img alt="Figure 5.6 – PWM signals " src="image/Figure_5.06_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.316.1">Figure 5.6 – PWM signals</span></p>
<p><span class="koboSpan" id="kobo.317.1">The preceding</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.318.1"> diagram shows graphs of PWM signals. </span><span class="koboSpan" id="kobo.318.2">The top is a signal for driving a motor at half speed. </span><span class="koboSpan" id="kobo.318.3">The pulses on and off time are the same. </span><span class="koboSpan" id="kobo.318.4">The </span><em class="italic"><span class="koboSpan" id="kobo.319.1">X</span></em><span class="koboSpan" id="kobo.320.1"> axis is the level, and the </span><em class="italic"><span class="koboSpan" id="kobo.321.1">Y</span></em><span class="koboSpan" id="kobo.322.1"> axis is for time, with a solid line for the PWM signal and a dashed line for the power going to the motor. </span><span class="koboSpan" id="kobo.322.2">This panel shows a signal at half speed, with the duty cycle on for half </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">the cycle.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">The second graph shows control signals, ranging from 0 to completely on. </span><span class="koboSpan" id="kobo.324.2">When there are no pulses, this is equivalent to 0. </span><span class="koboSpan" id="kobo.324.3">When it is entirely on with no break, this is equivalent </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">to 100%.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">PWM can be fine-grained, with the bottom graph showing a sine wave along with the equivalent PWM signal for this. </span><span class="koboSpan" id="kobo.326.2">However, it’s not smooth, as it can only change when there is a new pulse, and the levels also have </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">a resolution.</span></span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.328.1">Driving fast and slow</span></h2>
<p><span class="koboSpan" id="kobo.329.1">We can take </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.330.1">advantage of this PWM system to drive the robot at different speeds. </span><span class="koboSpan" id="kobo.330.2">Let’s see how this works on a single wheel </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">motors_pwm_drive_slower.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.334.1">
import time
import board
import pwmio
A1_PWM = pwmio.PWMOut(board.GP17)
A1_PWM.duty_cycle = 2**16-1
time.sleep(0.3)
A1_PWM.duty_cycle = 2**15
time.sleep(0.3)
A1_PWM.duty_cycle = 0</span></pre>
<p><span class="koboSpan" id="kobo.335.1">In this example, we’ve gone back to setting up a pin from the board, but this time using </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">pwmio.PWMOut</span></strong><span class="koboSpan" id="kobo.337.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">DigitalIO</span></strong><span class="koboSpan" id="kobo.339.1">. </span><span class="koboSpan" id="kobo.339.2">We are using the motor </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">A1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.341.1"> pin.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">We then set </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">duty_cycle</span></strong><span class="koboSpan" id="kobo.344.1">, the amount of on-time to its highest value. </span><span class="koboSpan" id="kobo.344.2">It is a 16-bit value, so we use 2 to the power of 16 and subtract 1 – we don’t need to do this calculation ourselves and can let the computer do it. </span><span class="koboSpan" id="kobo.344.3">This value will cause the motor to drive, as before, at </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">full speed.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">The code sleeps and then sets the duty cycle to 2 to the power of 15, half of our previous value. </span><span class="koboSpan" id="kobo.346.2">The motor will go at 50% </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">speed here.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">We let it run for 0.3 seconds and then set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">duty_cycle</span></strong><span class="koboSpan" id="kobo.350.1"> to 0, which will turn off the motor. </span><span class="koboSpan" id="kobo.350.2">You can experiment with different values, but you may find the motor stalls (doesn’t move) and beeps at values lower than </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">half speed.</span></span></p>
<h3><span class="koboSpan" id="kobo.352.1">Adjusting the robot library</span></h3>
<p><span class="koboSpan" id="kobo.353.1">We will need to apply </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.354.1">changes to our robot library, where we set up motor pins as </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">DigitalIO</span></strong><span class="koboSpan" id="kobo.356.1"> pins. </span><span class="koboSpan" id="kobo.356.2">We now need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">PWMOut</span></strong><span class="koboSpan" id="kobo.358.1"> to set the pins up. </span><span class="koboSpan" id="kobo.358.2">Here is a </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">new </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">robot.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.362.1">
import board
import pwmio
motor_A1 = pwmio.PWMOut(board.GP17)
motor_A2 = pwmio.PWMOut(board.GP16)
motor_B1 = pwmio.PWMOut(board.GP18)
motor_B2 = pwmio.PWMOut(board.GP19)
def stop():
    motor_A1.duty_cycle = 0
    motor_A2.duty_cycle = 0
    motor_B1.duty_cycle = 0
    motor_B2.duty_cycle = 0</span></pre>
<p><span class="koboSpan" id="kobo.363.1">This code swaps the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">Digital IO</span></strong><span class="koboSpan" id="kobo.365.1"> setup we used before and uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">PWMOut</span></strong><span class="koboSpan" id="kobo.367.1"> instead. </span><span class="koboSpan" id="kobo.367.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">stop</span></strong><span class="koboSpan" id="kobo.369.1"> function now sets the pins </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">duty_cycle</span></strong><span class="koboSpan" id="kobo.371.1"> to zero to stop all </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">motor pins.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">We can now use this to demonstrate the robot moving </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">motors_convert_speed.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.377.1">
import time
import robot
max_speed = 2**16-1
robot.motor_A1.duty_cycle = int(0.8 * max_speed)
time.sleep(0.3)
robot.stop()</span></pre>
<p><span class="koboSpan" id="kobo.378.1">We use our refreshed </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">robot</span></strong><span class="koboSpan" id="kobo.380.1"> class to set things up in this demonstration. </span><span class="koboSpan" id="kobo.380.2">First, we set a </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">max_speed</span></strong><span class="koboSpan" id="kobo.382.1"> variable to hold the </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">maximum value.</span></span></p>
<p><span class="koboSpan" id="kobo.384.1">Having </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">max_speed</span></strong><span class="koboSpan" id="kobo.386.1"> makes things more convenient, as we can then multiply it by a fraction between 0 and 1 to get a duty cycle value – here, we set the motor to 80% speed for 0.3 seconds and stop. </span><span class="koboSpan" id="kobo.386.2">We must use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">int()</span></strong><span class="koboSpan" id="kobo.388.1"> function to convert the result to an integer (</span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">whole number).</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">We can move this multiplication up into the robot library. </span><span class="koboSpan" id="kobo.390.2">Add this code after the motor pins </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">robot.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.394.1">
max_speed = 2**16-1
right_motor = motor_A1, motor_A2
left_motor = motor_B1, motor_B2</span></pre>
<p><span class="koboSpan" id="kobo.395.1">First, there is max speed, as </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.396.1">seen before, and then two variables to group our pins as respective motors. </span><span class="koboSpan" id="kobo.396.2">It means we can use pairs of pins, as </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.398.1">
def set_speed(motor, speed):
    if speed &lt; 0:
        direction = motor[1], motor[0]
        speed = -speed
    else:
        direction = motor
    speed = min(speed, 1) # limit to 1.0
    direction[0].duty_cycle = int(max_speed * speed)
    direction[1].duty_cycle = 0</span></pre>
<p><span class="koboSpan" id="kobo.399.1">This function will accept a motor (or pair of pins) as defined previously and then a speed between </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">-1</span></strong><span class="koboSpan" id="kobo.401.1"> (going in reverse) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">1</span></strong><span class="koboSpan" id="kobo.403.1"> (going forward). </span></p>
<p><span class="koboSpan" id="kobo.404.1">It checks whether the speed is negative and, if so, sets a </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">direction</span></strong><span class="koboSpan" id="kobo.406.1"> variable with the motor pins swapped and makes the speed positive; otherwise, it just stores the current motor pins as a pair </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">direction</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">The next line uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">min()</span></strong><span class="koboSpan" id="kobo.412.1"> function, which returns the minimum of two values. </span><span class="koboSpan" id="kobo.412.2">Putting in </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">speed</span></strong><span class="koboSpan" id="kobo.414.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">1</span></strong><span class="koboSpan" id="kobo.416.1"> will limit the speed to no more </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">than </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">1.0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.420.1">We then use the pins stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">direction</span></strong><span class="koboSpan" id="kobo.422.1"> variable, setting the first pin’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">duty_cycle</span></strong><span class="koboSpan" id="kobo.424.1"> to the converted speed and the other pin </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">We can add two more functions on </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">robot.py</span></strong><span class="koboSpan" id="kobo.430.1"> to make this </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">more convenient:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.432.1">
def set_left(speed):
    set_speed(left_motor, speed)
def set_right(speed):
    set_speed(right_motor, speed)</span></pre>
<p><span class="koboSpan" id="kobo.433.1">These wrap the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">set_speed</span></strong><span class="koboSpan" id="kobo.435.1"> function, and </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.436.1">they can now be used in your code with calls such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">robot.set_left(1.0)</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.438.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">robot.set_right(0.8)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">Let’s use these and try a few different speeds </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">motors_pwm_multispeed.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.445.1">
import time
import robot
try:
    for speed in range(5, 10):
        robot.set_left(speed/10)
        robot.set_right(speed/10)
        time.sleep(0.3)
finally:
    robot.stop()</span></pre>
<p><span class="koboSpan" id="kobo.446.1">The previous example uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">for</span></strong><span class="koboSpan" id="kobo.448.1"> loop, looping over the numbers 5 to 10. </span><span class="koboSpan" id="kobo.448.2">This means we get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">speed</span></strong><span class="koboSpan" id="kobo.450.1"> variable in each loop. </span><span class="koboSpan" id="kobo.450.2">We divide this by 10, so we now get 0.5 to 1.0 and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">robot.set_...</span></strong><span class="koboSpan" id="kobo.452.1"> methods to set both motors to this </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">speed</span></strong><span class="koboSpan" id="kobo.454.1">. </span><span class="koboSpan" id="kobo.454.2">The program then sleeps for 0.3 seconds and loops to the </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">next item.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">It is wrapped in </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">try…finally</span></strong><span class="koboSpan" id="kobo.458.1"> so that the program will always call </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">robot.stop()</span></strong><span class="koboSpan" id="kobo.460.1">, even if something fails in our loop; this ensures that the motors don’t </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">keep driving.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">The robot will start</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.463.1"> slowly and then speed up and stop when you run </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">this example.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">We can use the variable motor speeds to make gentle sweeping turns too. </span><span class="koboSpan" id="kobo.465.2">Let’s see how in the </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">next section.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.467.1">Turning while moving</span></h2>
<p><span class="koboSpan" id="kobo.468.1">We can make</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.469.1"> gentle, sweeping turns by sending different speeds to each motor using PWM. </span><span class="koboSpan" id="kobo.469.2">For example, look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.471.1"><img alt="Figure 5.7 – Robots making sweeping turns " src="image/Figure_5.07_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.472.1">Figure 5.7 – Robots making sweeping turns</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.473.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.474.1">.7</span></em><span class="koboSpan" id="kobo.475.1"> shows robots making gentle sweeping turns to the right and the left. </span><span class="koboSpan" id="kobo.475.2">The speed difference between the motor’s controls where the turn’s pivot is. </span><span class="koboSpan" id="kobo.475.3">The closer the speeds are, the wider the turn radius is. </span><span class="koboSpan" id="kobo.475.4">This is demonstrated </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">motors_pwm_gentle_turn.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.479.1">
import time
import robot
try:
    robot.set_left(1.0)
    robot.set_right(0.5)
    time.sleep(1)
finally:
    robot.stop()</span></pre>
<p><span class="koboSpan" id="kobo.480.1">This example </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.481.1">uses the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">try…finally</span></strong><span class="koboSpan" id="kobo.483.1"> construct as before. </span><span class="koboSpan" id="kobo.483.2">It sets the left motor to full speed and the right to half speed, making a wide arc to the right for half a second. </span><span class="koboSpan" id="kobo.483.3">The robot </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">then stops.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">We’ve now seen how to control a robot’s motor speeds with PWM and make different turns. </span><span class="koboSpan" id="kobo.485.2">Finally, we are ready to put some of this together to make the robot drive in a pre-determined path on </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">the floor.</span></span></p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.487.1">Driving along a planned path</span></h1>
<p><span class="koboSpan" id="kobo.488.1">We can use our straight-line </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.489.1">driving motions and curved turns to make an almost square path on the floor. </span><span class="koboSpan" id="kobo.489.2">We can use the helper functions we’ve made to keep </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">this short.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.491.1">Putting line and turn moves together</span></h2>
<p><span class="koboSpan" id="kobo.492.1">We are going to put</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.493.1"> some of our learning together to make a simple square pattern, as the following </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">diagram shows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.495.1"><img alt="Figure 5.8 – Driving a square path " src="image/Figure_5.08_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.496.1">Figure 5.8 – Driving a square path</span></p>
<p><span class="koboSpan" id="kobo.497.1">The figure shows a square made up of four straight lines and four turns. </span><span class="koboSpan" id="kobo.497.2">These eight instructions are four repeating sets of a straight line and then a turn. </span><span class="koboSpan" id="kobo.497.3">We will have to adjust the timing of the turn to make it close to </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">90 degrees.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">We start this code with some helpers for our motions – </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">pwm_drive_square.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.503.1">
import time
import robot
def straight(speed, duration):
    robot.set_left(speed)
    robot.set_right(speed)
    time.sleep(duration)
def left(speed, duration):
    robot.set_left(0)
    robot.set_right(speed)
    time.sleep(duration)</span></pre>
<p><span class="koboSpan" id="kobo.504.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">straight()</span></strong><span class="koboSpan" id="kobo.506.1"> function just puts both motors going forward (or back) for the duration. </span><span class="koboSpan" id="kobo.506.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">left()</span></strong><span class="koboSpan" id="kobo.508.1"> function stops one motor and drives the other </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">at speed.</span></span></p>
<p><span class="koboSpan" id="kobo.510.1">We can then use these in a main </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">for</span></strong><span class="koboSpan" id="kobo.512.1"> loop to get the </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">four turns:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.514.1">
try:
    for n in range(0, 4):
        straight(0.6, 1.0)
        left(0.6, 1.0)
finally:
    robot.stop()</span></pre>
<p><span class="koboSpan" id="kobo.515.1">Our loop counts</span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.516.1"> four times using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">range()</span></strong><span class="koboSpan" id="kobo.518.1"> function. </span><span class="koboSpan" id="kobo.518.2">We then use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">straight</span></strong><span class="koboSpan" id="kobo.520.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">left</span></strong><span class="koboSpan" id="kobo.522.1"> functions with speed </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">and duration.</span></span></p>
<p><span class="koboSpan" id="kobo.524.1">Note that the performance of this will vary greatly, depending on how fresh the batteries are and which surface you drive on – friction will slow motors down. </span><span class="koboSpan" id="kobo.524.2">You will likely need to adjust the relative times of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">straight</span></strong><span class="koboSpan" id="kobo.526.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">left</span></strong><span class="koboSpan" id="kobo.528.1"> function uses to try and get </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">a square.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.530.1">The flaw with driving this way</span></h2>
<p><span class="koboSpan" id="kobo.531.1">You’ll notice that the path </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.532.1">we planned is not quite the plan we got. </span><span class="koboSpan" id="kobo.532.2">Even after some time adjusting it, you probably got a path like </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<span class="koboSpan" id="kobo.534.1"><img alt="Figure 5.9 – What your path might look like " src="image/Figure_5.09_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.535.1">Figure 5.9 – What your path might look like</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.536.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.537.1">.9</span></em><span class="koboSpan" id="kobo.538.1"> shows an exaggerated version of what you may have got. </span><span class="koboSpan" id="kobo.538.2">Even after much tweaking, the robot may have made turns slightly above or below 90 degrees. </span><span class="koboSpan" id="kobo.538.3">The robot may also have veered slightly while making the straight lines. </span><span class="koboSpan" id="kobo.538.4">In the next chapter, we will pick up our first sensor, the encoders, which can be used for more accurate turning and to correct </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">for veer.</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">The moment you </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.541.1">change surfaces or the batteries degrade, the robot will go off course further. </span><span class="koboSpan" id="kobo.541.2">Drawing a path like this is a start, but later in the book, we’ll see how to use sensors to improve the accuracy of </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">such motion.</span></span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.543.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.544.1">In this chapter, we learned how a controller such as Raspberry Pi Pico uses a motor controller to drive motors. </span><span class="koboSpan" id="kobo.544.2">We saw how to control motor directions to drive in a straight(ish) line or make a </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">robot turn.</span></span></p>
<p><span class="koboSpan" id="kobo.546.1">We then learned about PWM control and how to vary motor speeds, creating a handy </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">robot</span></strong><span class="koboSpan" id="kobo.548.1"> Python library for our robot in the process. </span><span class="koboSpan" id="kobo.548.2">Next, we used this to make sweeping curves and build a multi-step path example with our robot. </span><span class="koboSpan" id="kobo.548.3">This path code did, however, show up some </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">accuracy shortcomings.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">We have used time to estimate how much we move our motors. </span><span class="koboSpan" id="kobo.550.2">However, motors don’t start immediately, and they can sometimes stick. </span><span class="koboSpan" id="kobo.550.3">In addition, some motors are slower than others. </span><span class="koboSpan" id="kobo.550.4">Therefore, we are working only with approximates. </span><span class="koboSpan" id="kobo.550.5">In the next chapter, we will look at how to measure how much the motors have turned to get a more accurate estimation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">robot’s movement.</span></span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.552.1">Exercises</span></h1>
<p><span class="koboSpan" id="kobo.553.1">Now you’ve had a taste of driving the robot motors, perhaps you can practice your skills with the </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">following challenges:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.555.1">Can you make other shapes with this method, such as a triangle, or, by using gentle turns, drive in </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">a circle?</span></span></li>
<li><span class="koboSpan" id="kobo.557.1">What is the lowest PWM value before the robot stalls on </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">two motors?</span></span></li>
<li><span class="koboSpan" id="kobo.559.1">Does the preceding value change on </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">one motor?</span></span></li>
<li><span class="koboSpan" id="kobo.561.1">How does the robot’s driving behave on a different surface, such as carpet </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">or wood?</span></span></li>
</ul>
<h1 id="_idParaDest-112"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.563.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.564.1">These additional resources will help you learn more about the concepts covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.566.1">A great YouTube video by Afrotechmods shows more about </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">PWM: </span></span><a href="https://www.youtube.com/watch?v=YmPziPfaByw"><span class="No-Break"><span class="koboSpan" id="kobo.568.1">https://www.youtube.com/watch?v=YmPziPfaByw</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.569.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.570.1">Sparkfun has an explanation of PWM at </span><a href="https://learn.sparkfun.com/tutorials/pulse-width-modulation/all"><span class="koboSpan" id="kobo.571.1">https://learn.sparkfun.com/tutorials/pulse-width-modulation/all</span></a><span class="koboSpan" id="kobo.572.1"> where, in addition to its use of motors and servo motors, it shows how you can use the technique to control </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">LED brightness.</span></span></li>
<li><span class="koboSpan" id="kobo.574.1">Adafruit, the team that created CircuitPython, has a PWM programming tutorial </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">at </span></span><a href="https://learn.adafruit.com/circuitpython-essentials/circuitpython-pwm"><span class="No-Break"><span class="koboSpan" id="kobo.576.1">https://learn.adafruit.com/circuitpython-essentials/circuitpython-pwm</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.577.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.578.1">My book </span><em class="italic"><span class="koboSpan" id="kobo.579.1">Learn Robotics Programming, Second Edition</span></em><span class="koboSpan" id="kobo.580.1">, also published by Packt, has a chapter covering motor steering mechanisms, including the one seen here, with Python code for </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">Raspberry Pi.</span></span></li>
</ul>
</div>


<div class="Content" id="_idContainer097">
<h1 id="_idParaDest-113"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.1.1">Part 2: Interfacing Raspberry Pi Pico with Simple Sensors and Outputs</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, we will build upon the basic Raspberry Pi Pico knowledge, adding more complicated devices and code to interface them. </span><span class="koboSpan" id="kobo.2.2">We will see how sensors can interface our robot more with the real world. </span><span class="koboSpan" id="kobo.2.3">We will add Bluetooth LE to link with a computer.</span></p>
<p><span class="koboSpan" id="kobo.3.1">This part contains the following chapters:</span></p>
<ul>
<li><a href="B18001_06.xhtml#_idTextAnchor115"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Measuring Movement with Encoders on Raspberry Pi Pico</span></em></li>
<li><a href="B18001_07.xhtml#_idTextAnchor139"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.8.1">, </span><em class="italic"><span class="koboSpan" id="kobo.9.1">Planning and Shopping for More Devices</span></em></li>
<li><a href="B18001_08.xhtml#_idTextAnchor166"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.11.1">, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">Sensing Distances to Detect Objects with Pico</span></em></li>
<li><a href="B18001_09.xhtml#_idTextAnchor189"><em class="italic"><span class="koboSpan" id="kobo.13.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.14.1">, </span><em class="italic"><span class="koboSpan" id="kobo.15.1">Teleoperating a Raspberry Pi Pico Robot with Bluetooth LE</span></em></li>
</ul>
</div>
</body></html>