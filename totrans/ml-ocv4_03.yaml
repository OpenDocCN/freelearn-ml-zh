- en: Working with Data in OpenCV
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在OpenCV中处理数据
- en: Now that we have whetted our appetite for machine learning, it is time to delve
    a little deeper into the different parts that make up a typical machine learning
    system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经激发了大家对机器学习的兴趣，是时候深入探讨构成典型机器学习系统的不同部分了。
- en: Far too often, you hear someone throw around the phrase, *J**ust apply machine
    learning to your data!*, as if that will instantly solve all of your problems.
    You can imagine that the reality of this is much more intricate, although, I will
    admit that nowadays, it is incredibly easy to build your own machine learning
    system simply by cutting and pasting a few lines of code from the internet. However,
    to build a system that is truly powerful and effective, it is essential to have
    a firm grasp of the underlying concepts and an intimate knowledge of the strengths
    and weaknesses of each method. So, don't worry if you don't consider yourself
    a machine learning expert just yet. Good things take time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 太频繁了，你可能会听到有人随意抛出“**J**ust apply machine learning to your data!”这样的短语，好像这样就能立刻解决你所有的问题。你可以想象，现实远比这复杂得多，尽管，我必须承认，如今，仅通过从互联网上复制粘贴几行代码，就极其容易构建自己的机器学习系统。然而，要构建一个真正强大和有效的系统，掌握底层概念以及深入了解每种方法的优缺点是至关重要的。所以，如果你还没有把自己视为机器学习专家，请不要担心。好事多磨。
- en: Earlier, I described machine learning as a subfield of artificial intelligence.
    This might be true—mainly for historical reasons—but most often, machine learning
    is simply about making sense of data. Therefore, it might be more suitable to
    think of machine learning as a subfield of data science, where we build mathematical
    models to help us to understand data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我把机器学习描述为人工智能的一个子领域。这可能确实如此——主要是出于历史原因——但大多数情况下，机器学习只是关于**理解数据**。因此，将机器学习视为数据科学的一个子领域可能更为合适，在那里我们构建数学模型来帮助我们理解数据。
- en: 'Hence, this chapter is all about data. We want to learn how data fits in with
    machine learning and how to work with data using the tools of our choice: OpenCV
    and Python.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章全部关于数据。我们想要了解数据如何与机器学习相结合，以及如何使用我们选择的工具（OpenCV和Python）来处理数据。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the machine learning workflow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解机器学习工作流程
- en: Understanding training data and test data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解训练数据和测试数据
- en: Learning how to load, store, edit, and visualize data with OpenCV and Python
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用OpenCV和Python加载、存储、编辑和可视化数据
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can refer to the code for this chapter from the following link: [https://github.com/PacktPublishing/Machine-Learning-for-OpenCV-Second-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Machine-Learning-for-OpenCV-Second-Edition/tree/master/Chapter02).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从以下链接获取本章的代码：[https://github.com/PacktPublishing/Machine-Learning-for-OpenCV-Second-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Machine-Learning-for-OpenCV-Second-Edition/tree/master/Chapter02)。
- en: 'Here is a summary of the software and hardware requirements:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是软件和硬件要求的总结：
- en: You will need OpenCV version 4.1.x (4.1.0 or 4.1.1 will both work just fine).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要OpenCV版本4.1.x（4.1.0或4.1.1都完全可以）。
- en: You will need Python version 3.6 (any Python version 3.x will be fine).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要Python版本3.6（任何3.x版本的Python都行）。
- en: You will need Anaconda Python 3 for installing Python and the required modules.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要安装Anaconda Python 3来安装Python和所需的模块。
- en: You can use any OS—macOS, Windows, and Linux-based OSes along with this book.
    We recommend you have at least 4 GB RAM in your system.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用任何操作系统——macOS、Windows以及基于Linux的操作系统——配合本书使用。我们建议你的系统至少有4GB的RAM。
- en: You don't need to have a GPU to run the code provided along with this book.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行本书提供的代码不需要GPU。
- en: Understanding the machine learning workflow
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解机器学习工作流程
- en: As mentioned earlier, machine learning is all about building mathematical models
    to understand data. The learning aspect enters this process when we give a machine
    learning model the capability to adjust its **internal parameters**; we can tweak
    these parameters so that the model explains the data better. In a sense, this
    can be understood as the model learning from the data. Once the model has learned
    enough—whatever that means—we can ask it to explain newly observed data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，机器学习就是构建数学模型来理解数据。当我们赋予机器学习模型调整其**内部参数**的能力时，学习过程就进入了这个环节；我们可以调整这些参数，使模型更好地解释数据。从某种意义上说，这可以理解为模型从数据中学习。一旦模型学习到足够多的东西——无论这意味着什么——我们就可以要求它解释新观察到的数据。
- en: 'A typical classification process is illustrated in the following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个典型的分类过程的示意图：
- en: '![](img/f30a037e-5be4-4b0f-ad02-06e546ea42f3.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f30a037e-5be4-4b0f-ad02-06e546ea42f3.png)'
- en: Let's break it down step by step.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地分解它。
- en: 'The first thing to notice is that machine learning problems are always split
    into (at least) two distinct phases:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，机器学习问题总是分为（至少）两个不同的阶段：
- en: A **training phase**, during which we aim to train a machine learning model
    on a set of data that we call the **training dataset**
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**训练阶段**，在这个阶段，我们旨在使用我们称之为**训练数据集**的一组数据来训练机器学习模型
- en: A test phase, during which we evaluate the learned (or finalized) machine learning model on
    a new set of never-before-seen data that we call the **test dataset**
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**测试阶段**，在这个阶段，我们评估学习到的（或最终确定的）机器学习模型在称为**测试数据集**的一组从未见过的新数据上的表现
- en: 'The importance of splitting our data into a training set and test set cannot
    be understated. We always evaluate our models on an independent test set because
    we are interested in knowing how well our models **generalize to new data**. In
    the end, isn''t this what learning is all about—be it machine learning or human
    learning? Think back to school, when you were a learner yourself: the problems
    you had to solve as part of your homework would never show up in exactly the same
    form in the final exam. The same scrutiny should be applied to a machine learning
    model; we are not so much interested in how well our models can memorize a set
    of data points (such as a homework problem), but we want to know how our models
    will use what they have learned to solve new problems (such as the ones that show up
    in a final exam) and explain new data points.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的数据分为训练集和测试集的重要性不容忽视。我们总是在一个独立的测试集上评估我们的模型，因为我们感兴趣的是了解我们的模型如何**泛化到新的数据**。最终，这不就是学习的全部意义所在——无论是机器学习还是人类学习吗？回想一下学校的时候，当你自己还是一名学习者时：作为家庭作业一部分需要解决的问题在期末考试中绝不会以完全相同的形式出现。同样的严格性应该应用于机器学习模型；我们并不那么关心我们的模型能够多好地记住一组数据点（例如家庭作业问题），而是想知道我们的模型将如何利用他们所学的知识来解决新的问题（例如在期末考试中出现的问题）并解释新的数据点。
- en: The workflow of an advanced machine learning problem will typically include
    a third set of data termed a **validation dataset**. For now, this distinction
    is not important. A validation set is typically formed by further partitioning
    the training dataset. It is used in advanced concepts such as model selection,
    which we will talk about in [Chapter 11](904bc419-cb0e-44cd-ae3f-8ce97e15baa2.xhtml), *Selecting
    the Right Model with Hyperparameter Tuning*, when we have become proficient in
    building machine learning systems.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 高级机器学习问题的工作流程通常包括第三组数据，称为**验证数据集**。目前，这种区别并不重要。验证集通常是通过进一步划分训练数据集形成的。当我们已经熟练构建机器学习系统时，我们将在第11章[选择合适的模型与超参数调整](904bc419-cb0e-44cd-ae3f-8ce97e15baa2.xhtml)中讨论的模型选择等高级概念中使用它。
- en: 'The next thing to notice is that machine learning is really all about the **data**.
    Data enters the previously described workflow diagram in its raw form—whatever
    that means—and is used in both training and test phases. Data can be anything
    from images and movies to text documents and audio files. Therefore, in its raw
    form, data might be made of pixels, letters, words, or even worse: pure bits.
    It is easy to see that data in such a raw form might not be very convenient to
    work with. Instead, we have to find ways to **preprocess** the data to bring it
    into a form that is easy to **parse or use the data**.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要注意的是，机器学习实际上完全是关于**数据**的。数据以原始形式进入之前描述的工作流程图——无论这意味着什么——并在训练和测试阶段中使用。数据可以是图像、电影、文本文档或音频文件等任何东西。因此，在原始形式下，数据可能由像素、字母、单词甚至更糟糕的是：纯比特组成。很容易看出，这种原始形式的数据可能不太方便处理。相反，我们必须找到方法来**预处理**数据，使其以易于**解析或使用**的形式出现。
- en: 'Data preprocessing comes in two stages:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数据预处理分为两个阶段：
- en: '**Feature selection**: This is the process of identifying important attributes (or
    features) in the data. Possible features of an image might be the location of
    edges, corners, or ridges. You might already be familiar with some more advanced
    feature descriptors that OpenCV provides, such as **Speeded Up Robust Features**
    (**SURF**) or the **Histogram of Oriented Gradients** (**HOG**). Although these
    features can be applied to any image, they might not be that important (or work
    that well) for our specific task. For example, if our task was to distinguish
    between clean and dirty water, the most important feature might turn out to be
    the color of the water, and the use of SURF or HOG features might not help us
    much.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特征选择**：这是识别数据中重要属性（或特征）的过程。图像的可能特征可能包括边缘、角点或脊的位置。你可能已经熟悉 OpenCV 提供的一些更高级的特征描述符，如**加速鲁棒特征**（SURF）或**方向梯度直方图**（HOG）。尽管这些特征可以应用于任何图像，但它们可能对我们的特定任务并不那么重要（或效果并不好）。例如，如果我们的任务是区分干净和脏水，最重要的特征可能是水的颜色，而使用
    SURF 或 HOG 特征可能对我们帮助不大。'
- en: '**Feature extraction**: This is the actual process of transforming the raw
    data into the desired **feature space**. An example would be the **Harris operator**,
    which allows us to extract corners (that is, a selected feature) in an image.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特征提取**：这是将原始数据转换为所需**特征空间**的实际过程。一个例子是**哈里斯算子**，它允许我们在图像中提取角点（即选定的特征）。'
- en: A more advanced topic is the process of inventing informative features, which
    is known as **feature engineering**. After all, before people could select from
    popular features, someone had to invent them first. This is often more important
    for the success of our algorithm than the choice of the algorithm itself. We will
    talk about feature engineering extensively in [Chapter 4](142fec63-a847-4cde-9de9-c34805d2bb84.xhtml), *Representing
    Data and Engineering Features*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更高级的话题是发明信息特征的过程，这被称为**特征工程**。毕竟，在人们可以从流行的特征中选择之前，必须先有人发明它们。这对于我们算法的成功往往比算法本身的选择更重要。我们将在第
    4 章[表示数据和特征工程](142fec63-a847-4cde-9de9-c34805d2bb84.xhtml)中广泛讨论特征工程。
- en: Don't let naming **conventions** confuse you! Sometimes, feature selection and
    feature extraction are hard to distinguish, mainly because of how things are named.
    For example, SURF stands for both the feature extractor as well as the actual
    name of the features. The same is true for the **S****cale-Invariant Feature Transform**
    (**SIFT**), which is a feature extractor that yields what is known as **SIFT** **features**.
    Unfortunately, both the algorithms are patented and cannot be used for commercial
    purposes. We won't be sharing any code about either algorithms.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让命名**规范**混淆你！有时候，特征选择和特征提取难以区分，主要是因为命名方式。例如，SURF 既可以指特征提取器，也可以指实际的特征名称。同样，**尺度不变特征变换**（SIFT）也是如此，它是一种特征提取器，可以产生所谓的**SIFT**特征。不幸的是，这两个算法都获得了专利，不能用于商业目的。我们不会分享任何关于这两个算法的代码。
- en: The last point to be made is that, in supervised learning, every data point
    must have a **label**. A label identifies a data point either of belonging to
    a certain class of things (such as cat or dog) or of having a certain value (such
    as the price of a house). At the end of the day, the goal of a supervised machine
    learning system is to predict the label of all data points in the test set (as
    shown in the previous diagram). We do this by learning regularities in the training
    data, using the labels that come with it, and then testing our performance on
    the test set.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是，在监督学习中，每个数据点都必须有一个**标签**。标签可以识别数据点属于某个类别（如猫或狗）或具有某个值（如房屋的价格）。最终，监督机器学习系统的目标是预测测试集中所有数据点的标签（如前图所示）。我们通过学习训练数据中的规律性，使用随附的标签，然后在测试集上测试我们的性能来实现这一点。
- en: Therefore, to build a functioning machine learning system, we first have to
    cover how to load, store, and manipulate data. How do you even do that in OpenCV
    with Python?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了构建一个功能齐全的机器学习系统，我们首先必须了解如何加载、存储和处理数据。你如何在 OpenCV 中使用 Python 做到这一点呢？
- en: Dealing with data using OpenCV and Python
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenCV 和 Python 处理数据
- en: The world of data is full of various kinds of data types. This, at times, makes
    it very difficult for users to distinguish between the data type to use for a
    particular value. Here, we will try to keep it simple by treating everything as
    an array, except the scalar values, which will retain their standard data types.
    So, images will become 2D arrays because they have width and height. A 1D array
    could be a sound clip with intensity varying over time.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的世界充满了各种类型的数据。有时，这会让用户很难区分特定值应使用的数据类型。在这里，我们将尝试将其保持简单，将所有内容视为数组，除了标量值，它们将保留其标准数据类型。因此，图像将成为二维数组，因为它们有宽度和高度。一维数组可能是一个随时间强度变化的音频剪辑。
- en: If you have mostly been using OpenCV's C++ **Application Programming Interface**
    (**API**) and plan on continuing to do so, you might find that dealing with data
    in C++ can be a bit of a pain. Not only will you have to deal with the syntactic
    overhead of the ...
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你主要使用 OpenCV 的 C++ **应用程序编程接口**（**API**）并且计划继续这样做，你可能会发现处理 C++ 中的数据可能会有些痛苦。你不仅必须处理语法开销，...
- en: Starting a new IPython or Jupyter session
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动一个新的 IPython 或 Jupyter 会话
- en: 'Before we can get our hands on NumPy, we need to open an IPython shell or start
    a Jupyter Notebook:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够接触到 NumPy 之前，我们需要打开一个 IPython 壳或启动一个 Jupyter 笔记本：
- en: 'Open a Terminal as we did in the previous chapter and navigate to the `OpenCV-ML` directory:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端，就像我们在上一章中做的那样，并导航到 `OpenCV-ML` 目录：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Activate the `conda` environment we created in the previous chapter:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活我们在上一章中创建的 `conda` 环境：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Start a new IPython or Jupyter session:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的 IPython 或 Jupyter 会话：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you chose to start an IPython session, the program should have greeted you
    with a welcome message like the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择启动一个 IPython 会话，程序应该会以如下欢迎信息问候你：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The line starting with `In [1]` is where you type in your regular Python commands.
    In addition, you can also use the *Tab* key while typing the names of variables
    and functions to have IPython automatically complete them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `In [1]` 开头的行是输入常规 Python 命令的地方。此外，在输入变量和函数名称时，你也可以使用 *Tab* 键让 IPython 自动完成。
- en: A limited number of Unix and macOS system shell commands work too—such as `ls` and `pwd`.
    You can run any shell command by prefixing it with `!`, such as `!ping www.github.com`.
    For more information, check out the official IPython reference at [https://ipython.org/ipython-doc/3/interactive/tutorial.html](https://ipython.org/ipython-doc/3/interactive/tutorial.html).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有限数量的 Unix 和 macOS 系统外壳命令也可以使用——例如 `ls` 和 `pwd`。你可以通过在命令前加上 `!` 来运行任何外壳命令，例如
    `!ping www.github.com`。更多信息，请查看官方 IPython 参考文档：[https://ipython.org/ipython-doc/3/interactive/tutorial.html](https://ipython.org/ipython-doc/3/interactive/tutorial.html)。
- en: 'If you chose to start a Jupyter session, a new window should have opened in
    your web browser that is pointing to `http://localhost:8888`. You want to create
    a new notebook by clicking on New in the top-right corner and selecting Notebooks
    (Python 3):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择启动一个 Jupyter 会话，你的网络浏览器应该会打开一个指向 `http://localhost:8888` 的新窗口。你想要通过点击右上角的“新建”并选择“Notebooks
    (Python 3)”来创建一个新的笔记本：
- en: '![](img/9e67e509-0fd8-4871-bee8-3ef9963f27bf.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e67e509-0fd8-4871-bee8-3ef9963f27bf.png)'
- en: 'This will open a new window that looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个看起来像这样的新窗口：
- en: '![](img/8ed28073-144e-4935-929d-3b781ce55abd.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ed28073-144e-4935-929d-3b781ce55abd.png)'
- en: The cell (which looks like the preceding textbox) labeled with `In [ ]` is the
    same as the command line in an IPython session. Now you can start typing your
    Python code!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为 `In [ ]` 的单元格（看起来像前面的文本框）与 IPython 会话中的命令行相同。现在你可以开始输入你的 Python 代码了！
- en: Dealing with data using Python's NumPy package
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 的 NumPy 包处理数据
- en: I am assuming that you already have NumPy installed in your virtual environment
    if you have installed Anaconda. If you have used Python's standard distribution
    or any other distribution, you can go to [http://www.numpy.org](http://www.numpy.org) and
    follow the installation instructions provided there.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设如果你已经安装了 Anaconda，那么你已经在虚拟环境中安装了 NumPy。如果你使用了 Python 的标准发行版或任何其他发行版，你可以访问
    [http://www.numpy.org](http://www.numpy.org) 并遵循那里提供的安装说明。
- en: As mentioned previously, it's okay if you aren't a Python expert yet. Who knows,
    perhaps you're just now switching from OpenCV's C++ API. This is all fine. I wanted
    to give you a quick overview of how to get started with NumPy. If you are a more
    advanced Python user, you can simply skip this section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果你还不是 Python 专家，这完全没问题。谁知道呢，也许你刚刚从 OpenCV 的 C++ API 转换过来。我只是想给你一个关于如何开始使用
    NumPy 的快速概述。如果你是更高级的 Python 用户，你可以简单地跳过这一部分。
- en: Once you are familiar with NumPy, you will find that most scientific computing
    tools in the Python world are built around ...
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Importing NumPy
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you start a new IPython or Jupyter session, you can import the NumPy module
    and verify its version as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Recall that in the Jupyter Notebook, you can hit *Ctrl* + *Enter* to execute
    a cell once you have typed the command. Alternatively, *Shift* + *Enter* executes
    the cell and automatically inserts or selects the cell below it. Check out all
    of the keyboard shortcuts by clicking on Help | Keyboard Shortcut or take a quick
    tour by clicking on Help | User Interface Tour.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'For the parts of the package discussed here, I would recommend using NumPy
    version 1.8 or later. By convention, you''ll find that most people in the scientific
    Python world will import NumPy using `np` as an alias:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Throughout this chapter and the rest of this book, we will stick to the same
    convention.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Understanding NumPy arrays
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might already know that Python is a **weakly typed language**. This means
    that you do not have to specify a data type whenever you create a new variable.
    For example, the following will automatically be represented as an integer:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can double-check this by typing the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As the standard Python implementation is written in C, every Python object is
    basically a C structure in disguise. This is true even for integers in Python,
    which are actually pointers to compound C structures that contain more than just
    the **raw** integer value. Therefore, the default C data type used to represent
    Python integers will depend on your system architecture (that is, whether it is
    a 32-bit ...
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Accessing single array elements by indexing
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have used Python''s standard list indexing before, then you won''t find many
    issues with indexing in NumPy. In a 1D array, the *i*^(th) value (counting from
    zero) can be accessed by specifying the desired index in square brackets, just
    as with Python lists:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To index from the end of the array, you can use negative indices:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are a few other cool tricks for **slicing arrays**, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I encourage you to play around with these arrays yourself!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The general form of slicing arrays in NumPy is the same as it is for standard
    Python lists. To access a slice of an array, `x`, use `x[start:stop:step]`. If
    any of these are unspecified, they default to the `start=0`, `stop=size of dimension`, `step=1` values.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Creating multidimensional arrays
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays need not be limited to lists. In fact, they can have an arbitrary number
    of dimensions. In machine learning, we will often deal with at least 2D arrays,
    where the column index stands for the values of a particular feature and the rows
    contain the actual feature values.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'With NumPy, it is easy to create multidimensional arrays from scratch. Let''s
    say that we want to create an array with three rows and five columns, with all
    of the elements initialized to zero. If we don''t specify a data type, NumPy will
    default to using floats:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you probably know from your OpenCV days, this ...
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从 OpenCV 时代可能知道的，这 ...
- en: Loading external datasets in Python
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Python 中加载外部数据集
- en: Thanks to the SciPy community, there are many resources out there for getting
    our hands on some data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢 SciPy 社区，有许多资源可以帮助我们获取数据。
- en: 'A particularly useful resource comes in the form of the `sklearn.datasets` package
    of **scikit-learn**. This package comes preinstalled with some small datasets
    that do not require us to download any files from external websites. These datasets
    include the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别有用的资源来自 **scikit-learn** 的 `sklearn.datasets` 包。这个包预先安装了一些小型数据集，我们不需要从外部网站下载任何文件。这些数据集包括以下内容：
- en: '`load_boston`: The Boston dataset contains housing prices in different suburbs
    of Boston along with several interesting features such as per capita crime rate
    by town, proportion of residential land, and number of non-retail business'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load_boston`：波士顿数据集包含波士顿不同郊区的房价，以及一些有趣的特征，如城镇人均犯罪率、住宅用地比例和非零售商业数量'
- en: '`load_iris`: The Iris dataset contains three different types of Iris flowers
    (Setosa, Versicolor, and Virginica), along with four features describing the width
    and length of the sepals and petals'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load_iris`：爱丽丝花数据集包含三种不同类型的爱丽丝花（塞托萨、变色和维吉尼卡），以及描述萼片和花瓣宽度和长度的四个特征'
- en: '`load_diabetes`: The diabetes dataset lets us classify patients as having diabetes
    or not, based on features such as patient age, sex, body mass index, average blood
    pressure, and six blood serum measurements'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load_diabetes`：糖尿病数据集让我们可以根据患者的年龄、性别、体重指数、平均血压和六项血液血清测量值来分类患者是否患有糖尿病'
- en: '`load_digits`: The digits dataset contains 8 x 8 pixel images of the digits
    *0-9*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load_digits`：数字数据集包含 *0-9* 数字 8 x 8 像素的图像'
- en: '`load_linnerud`: The Linnerud dataset contains 3 physiological variables and
    3 exercise variables measured on 20 middle-aged men in a fitness club'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load_linnerud`：Linnerud 数据集包含 3 个生理变量和 3 个锻炼变量，这些变量是在健身俱乐部对 20 名中年男性测量的'
- en: 'Also, scikit-learn allows us to download datasets directly from external repositories,
    such as the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，scikit-learn 允许我们直接从外部存储库下载数据集，如下所示：
- en: '`fetch_olivetti_faces`: The Olivetti faces dataset contains 10 different images
    each of 40 distinct subjects'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_olivetti_faces`：Olivetti 面部数据集包含 10 个不同图像，每个图像有 40 个不同的主题'
- en: '`fetch_20newsgroups`: The 20 newsgroup dataset contains around 18,000 newsgroup
    posts on 20 topics'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_20newsgroups`：20 个新闻组数据集包含大约 18,000 个关于 20 个主题的新闻组帖子'
- en: 'Even better, it is possible to download datasets directly from the machine
    learning database at [http://openml.org](http://mldata.org). For example, to download
    the Iris flower dataset, simply type the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，可以直接从机器学习数据库 [http://openml.org](http://mldata.org) 下载数据集。例如，要下载爱丽丝花数据集，只需输入以下命令：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The Iris flower database contains a total of `150` samples with `4` features—sepal
    length, sepal width, petal length, and petal width. The data is divided into three
    classes—Iris Setosa, Iris Versicolour, and Iris Virginica. Data and labels are
    delivered in two separate containers, which we can inspect as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝花数据库包含总共 `150` 个样本，具有 `4` 个特征——花瓣长度、花瓣宽度、萼片长度和萼片宽度。数据分为三个类别——爱丽丝花塞托萨、爱丽丝花变色和爱丽丝花维吉尼卡。数据和标签分别存放在两个独立的容器中，我们可以如下检查：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we can see that `iris_data` contains `150` samples, each with `4` features
    (and that's why the number 4 is in the shape). Labels are stored in `iris_target`,
    where there is only one label per sample.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 `iris_data` 包含 `150` 个样本，每个样本有 `4` 个特征（这就是为什么数字 4 出现在形状中）。标签存储在 `iris_target`
    中，每个样本只有一个标签。
- en: 'We can further inspect the values of all targets, but we don''t just want to
    print them all. Instead, we are interested to see all distinct target values,
    which is easy to do with NumPy:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步检查所有目标值的值，但我们不想打印所有值。相反，我们感兴趣的是查看所有不同的目标值，这使用 NumPy 很容易做到：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Another Python library for data analysis that you should have heard about is **pandas**
    ([http://pandas.pydata.org](http://pandas.pydata.org)). pandas implements several
    powerful data operations for both databases and spreadsheets. However great the
    library, at this point, pandas is a bit too advanced for our purposes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你应该听说过的 Python 数据分析库是 **pandas** ([http://pandas.pydata.org](http://pandas.pydata.org))。pandas
    实现了数据库和电子表格的几个强大的数据操作。尽管这个库很强大，但就我们的目的而言，pandas 现在可能有点过于高级了。
- en: Visualizing the data using Matplotlib
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Matplotlib 可视化数据
- en: Knowing how to load data is of limited use if we don't know how to look at the
    data. Thankfully, there is **Matplotlib**!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不知道如何查看数据，那么知道如何加载数据就有限的价值。幸运的是，有**Matplotlib**！
- en: Matplotlib is a multiplatform data visualization library built on NumPy arrays—see,
    I promised you NumPy would show up again. It was conceived by John Hunter in 2002,
    originally designed as a patch to IPython to enable interactive MATLAB-style plotting
    from the command line. In more recent years, newer and shinier tools have popped
    up to eventually replace Matplotlib (such as `ggplot` and `ggvis` in the R language),
    but Matplotlib remains essential as a well-tested, cross-platform graphics engine.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 是一个基于 NumPy 数组的跨平台数据可视化库——看，我承诺 NumPy 会再次出现。它由 John Hunter 在 2002
    年构思，最初设计为 IPython 的一个补丁，用于从命令行启用交互式 MATLAB 风格的绘图。在最近几年，出现了更多更炫酷的工具来最终取代 Matplotlib（例如
    R 语言中的`ggplot`和`ggvis`），但 Matplotlib 仍然是一个经过良好测试的跨平台图形引擎。
- en: Importing Matplotlib
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入 Matplotlib
- en: 'You might be in luck again: if you followed the advice outlined in the previous
    chapter and installed the Python Anaconda stack, you already have Matplotlib installed
    and are ready to go. Otherwise, you might want to visit [http://matplotlib.org](http://matplotlib.org/) for
    installation instructions.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能又走运了：如果你遵循了上一章中概述的建议并安装了 Python Anaconda 堆栈，那么你已经有 Matplotlib 安装好了，可以开始使用了。否则，你可能需要访问[http://matplotlib.org](http://matplotlib.org/)以获取安装说明。
- en: 'Just as we used the `np` shorthand for NumPy, we will use some standard shorthand
    for the Matplotlib imports:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们使用`np`简写来表示 NumPy 一样，我们将为 Matplotlib 导入使用一些标准简写：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `plt` interface is what we will use most often, as we shall see throughout
    this book.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`plt` 接口是我们将最常使用的，正如我们将在整本书中看到的那样。'
- en: Producing a simple plot
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成一个简单的图形
- en: Without further ado, let's create our first plot.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们创建我们的第一个图形。
- en: 'Let''s say that we want to produce a simple line plot of the sine function, `sin(x)`.
    We want the function to be evaluated at all points on the *x *axis where `0 <
    x < 10`. We will use NumPy''s `linspace` function to create a linear spacing on
    the *x* axis, from `x` values `0` to `10`, and a total of `100` sampling points:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要生成一个简单的正弦函数`sin(x)`的线形图。我们希望函数在*x*轴上所有`0 < x < 10`的点上进行评估。我们将使用 NumPy
    的`linspace`函数在*x*轴上创建线性间距，从`x`值`0`到`10`，总共`100`个采样点：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can evaluate the `sin` function at all points, `x`, using NumPy''s `sin` function,
    and visualize the result by calling the `plot` function of `plt`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 NumPy 的`sin`函数在所有点`x`上评估`sin`函数，并通过调用`plt`的`plot`函数来可视化结果：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Did you try it yourself? What happened? Did anything show up?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你自己试了吗？发生了什么？有什么显示出来吗？
- en: The thing is, depending on where you are running this script, you might not
    ...
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，根据你运行此脚本的位置，你可能不会 ...
- en: Visualizing data from an external dataset
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化外部数据集的数据
- en: As a final test for this chapter, let's visualize some data from an external
    dataset, such as the `digits` dataset from scikit-learn.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的最终测试，让我们可视化来自外部数据集的一些数据，例如 scikit-learn 中的`digits`数据集。
- en: 'Specifically, we will need three tools for visualization:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们需要三个工具来进行可视化：
- en: scikit-learn for the actual data
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: scikit-learn 用于实际数据
- en: NumPy for data processing
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 用于数据处理
- en: Matplotlib
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matplotlib
- en: 'So, let''s start by importing all of these:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先导入所有这些：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first step is to actually load the data:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是实际加载数据：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we remember correctly, `digits` is supposed to have two different fields:
    a `data` field containing the actual image data and a `target` field containing
    the image labels. Rather than trusting our memory, we should simply investigate
    the `digits` object. We do this by typing out its name, adding a period, and then
    hitting the *Tab* key: `digits.<TAB>`. This will reveal that the `digits` object
    also contains some other fields, such as one called `images`. The two fields, `images` and `data`,
    seem to simply differ by shape:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们记得正确的话，`digits`应该有两个不同的字段：一个包含实际图像数据的`data`字段和一个包含图像标签的`target`字段。与其依赖我们的记忆，我们不如简单地调查`digits`对象。我们通过键入其名称，添加一个点，然后按*Tab*键来完成：`digits.<TAB>`。这将揭示`digits`对象还包含一些其他字段，例如一个名为`images`的字段。这两个字段`images`和`data`似乎只是在形状上有所不同：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In both cases, the first dimension corresponds to the number of images in the
    dataset. However, `data` has all of the pixels lined up in one big vector, whereas `images` preserves
    the 8 x 8 spatial arrangement of each image.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，第一个维度对应于数据集中图像的数量。然而，`data`将所有像素排列在一个大向量中，而`images`则保留了每个图像的 8 x 8 空间排列。
- en: 'Hence, if we wanted to plot a single image, the `images` field would be more
    appropriate. First, we grab a single image from the dataset using NumPy''s array
    slicing:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想绘制单个图像，`images` 字段将更为合适。首先，我们使用 NumPy 的数组切片从数据集中获取单个图像：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we are saying that we want to grab the first row in the 1,797-item-long
    array and all of the corresponding *8 x 8 = 64* pixels. We can then plot the image
    using the `imshow` function of `plt`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们表示要从 1,797 项长数组中抓取第一行以及所有相应的 *8 x 8 = 64* 像素。然后我们可以使用 `plt` 的 `imshow`
    函数来绘制图像：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding command gives the following output. Note that the image is blurred
    because we have resized it to a larger size. The original image''s size is just
    8 x 8:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令给出了以下输出。请注意，由于我们将图像调整到了更大的尺寸，所以图像是模糊的。原始图像的大小仅为 8 x 8：
- en: '![](img/6a72066a-c69e-45d7-9756-b26d35d259a3.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a72066a-c69e-45d7-9756-b26d35d259a3.png)'
- en: In addition, I also specified a colormap with the `cmap` argument. By default,
    Matplotlib uses MATLAB's default colormap **jet**. However, in the case of grayscale
    images, the **gray** colormap makes more sense.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我还指定了一个使用 `cmap` 参数的颜色映射。默认情况下，Matplotlib 使用 MATLAB 的默认颜色映射 **jet**。然而，对于灰度图像，**gray**
    颜色映射更有意义。
- en: 'Finally, we can plot a whole number of digit samples using the `subplot` function
    of `plt`. The `subplot` function is the same as in MATLAB, where we specify the
    number of rows, number of columns, and current subplot index (starts counting
    at `1`). We will use a `for` loop to iterate over the first 10 images in the dataset
    and every image gets assigned its own subplot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `plt` 的 `subplot` 函数绘制大量数字样本。`subplot` 函数与 MATLAB 中的相同，我们指定行数、列数和当前子图索引（从
    `1` 开始计数）。我们将使用 `for` 循环遍历数据集中的前 10 张图像，每张图像都会分配一个自己的子图：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This leads to the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下输出：
- en: '![](img/30a0d81b-b5e2-49c8-8801-99dc8677959b.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30a0d81b-b5e2-49c8-8801-99dc8677959b.png)'
- en: Another great resource for all sorts of datasets is the machine learning repository
    of my alma mater, the University of California, Irvine: [http://archive.ics.uci.edu/ml/index.php](http://archive.ics.uci.edu/ml/index.php).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于各种数据集，我母校加州大学欧文分校的机器学习存储库也是一个极好的资源：[http://archive.ics.uci.edu/ml/index.php](http://archive.ics.uci.edu/ml/index.php)。
- en: Dealing with data using OpenCV's TrainData container in C++
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenCV 的 TrainData 容器在 C++ 中处理数据
- en: For the sake of completeness and for those who insist on using the C++ API of OpenCV,
    let's do a quick detour on OpenCV's `TrainData` container, which allows us to
    load numerical data from `.csv` files.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性和那些坚持使用 OpenCV 的 C++ API 的人，让我们快速了解一下 OpenCV 的 `TrainData` 容器，它允许我们从 `.csv`
    文件中加载数值数据。
- en: Among other things, in C++, the `ml` module contains a class called `TrainData`,
    which provides a container to work with data in C++. Its functionality is limited
    to reading (preferably) numerical data from `.csv` files (containing comma-separated
    values). Hence, if the data that you want to work with comes in a neatly organized `.csv` file,
    this class will save you a lot of time. If your data comes from a different source,
    I'm afraid your best option might be to create a `.csv` file by hand, using ...
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他方面，在 C++ 中，`ml` 模块包含一个名为 `TrainData` 的类，它提供了一个用于在 C++ 中处理数据的容器。其功能仅限于从 `.csv`
    文件（包含逗号分隔值）中读取（最好是）数值数据。因此，如果您想要处理的数据来自整洁的 `.csv` 文件，这个类将为您节省大量时间。如果您的数据来自不同的来源，恐怕您最好的选择可能是手动创建一个
    `.csv` 文件，使用 ...
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we talked about a typical workflow to deal with machine learning
    problems: how we can extract informative features from raw data, how we can use
    data and labels to train a machine learning model, and how we can use the finalized
    model to predict new data labels. We learned that it is essential to split data
    into a training set and test set, as this is the only way to know how well a model
    will generalize to new data points.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了处理机器学习问题的典型工作流程：我们如何从原始数据中提取信息性特征，我们如何使用数据和标签来训练机器学习模型，以及我们如何使用最终模型来预测新的数据标签。我们了解到，将数据分为训练集和测试集是至关重要的，因为这是唯一了解模型如何泛化到新数据点的途径。
- en: On the software side of things, we significantly improved our Python skills.
    We learned how to use NumPy arrays to store and manipulate data and how to use
    Matplotlib for data visualization. We talked about scikit-learn and its many useful
    data resources. Finally, we also addressed OpenCV's own `TrainData` container,
    which provides some relief for users of OpenCV's C++ API.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件方面，我们显著提高了我们的Python技能。我们学习了如何使用NumPy数组来存储和处理数据，以及如何使用Matplotlib进行数据可视化。我们讨论了scikit-learn及其许多有用的数据资源。最后，我们还提到了OpenCV自带的`TrainData`容器，它为OpenCV的C++
    API用户提供了一些缓解。
- en: With these tools in hand, we are now ready to implement our first real machine
    learning model! In the next chapter, we will focus on supervised learning and
    its two main problem categories, classification and regression.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些工具在手，我们现在已经准备好实现我们的第一个真正的机器学习模型了！在下一章中，我们将专注于监督学习及其两个主要问题类别，分类和回归。
