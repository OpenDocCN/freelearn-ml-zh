- en: Setting Up the ML.NET Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a firm grasp of the basics of machine learning, an understanding
    of what Microsoft's ML.NET is, and what it provides, it is time to train and create
    your first machine learning model! We will be building a simple restaurant sentiment
    analysis model based on reviews and integrating this model into a simple .NET
    Core application. Before we can jump into training and creating our model, we
    will first have to configure the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first model, from start to finish, with ML.NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fortunately, configuring your environment for ML.NET is relatively easy. In
    this section, we will be installing Visual Studio 2019 and .NET Core 3\. If you
    are unsure whether you have either installed, please observe the following steps.
    In addition, there are some organizational elements and processes to establish
    early on as we proceed through this book and you begin experimenting on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the heart of ML.NET development is Microsoft Visual Studio. For all samples
    and screenshots used throughout this book, Microsoft Visual Studio 2019 Professional
    on Windows 10 19H2 will be used. At the time of writing, 16.3.0 is the latest
    version. Please use the latest version available. If you do not have Visual Studio
    2019, a fully featured Community version is available for free on [www.visualstudio.com](http://www.visualstudio.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the scope of this book as mentioned in [Chapter 1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml),
    *Getting Started with Machine Learning and ML.NET*,we will be creating a wide
    range of application types to demonstrate ML.NET in various problem areas on specific
    application platforms. Hence, we are going to install several of the available
    workloads upfront to avoid having to return to the installer in later chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, ensure that **.NET desktop development**, **Universal Windows Platform
    Development**, and **ASP.NET and web development** are checked. These workloads
    will enable you to create UWP, WPF, and ASP.NET applications that we will be using
    in later chapters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f155b5c9-7175-43c2-b406-ff163fdf625b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition, ensure that **.NET Core cross-platform development** is also checked.
    This will enable .NET Core development for both command-line and desktop apps,
    such as the app we will be making later in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b00ccd5b-b95d-450e-be33-a9e28239b89c.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing .NET Core 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in [Chapter 1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml), *Getting
    Started with Machine Learning and ML.NET*, .NET Core 3 is the preferred .NET framework
    at the time of writing when targeting multiple platforms, due to the optimization
    work achieved during the development of .NET Core 3\. At the time of writing .NET
    Core 3 is not bundled with the Visual Studio Installer prior to version 16.3.0
    and needs to be downloaded separately here: [https://dotnet.microsoft.com/download/dotnet-core/3.0](https://dotnet.microsoft.com/download/dotnet-core/3.0).
    The download specifically used through the scope of this book is version 3.0.100,
    but a newer version may be available by the time you are reading this. For those
    readers who are curious, the runtime is bundled with the SDK.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify that the installation was successful by opening a PowerShell
    or Command Prompt and executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The output should begin with *3*, as shown here. At the time of writing, 3.0.100
    is the latest production version available.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to install both 32-bit and 64-bit versions to avoid issues when targeting
    32-bit and 64-bit platforms later on in this book and your future experiments.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over the course of this book and your own explorations, you will gather sample
    data, build models, and try various applications. Establishing a process early
    on to keep these elements organized will make things easier in the long run. Here
    are a few suggestions to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Always use source control for all of your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that test and training sets are named properly in their own folders (versioned
    if possible).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning models with both naming and source control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retain evaluation metrics in a spreadsheet along with the parameters used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you develop your skillset and create more complex problems, additional tooling
    such as Apache Spark or other clustering platforms will more than likely be required.
    We will discuss this in [Chapter 11](116bbc2d-9659-4d34-9b2b-26593e29f54a.xhtml),*Training
    and Building Production Models*, along with other suggestions on training at scale.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first ML.NET application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The time has come to start creating your first ML.NET application. For this
    first application, we will create a .NET Core console application. This application
    will classify a sentence of words as either a positive statement or a negative
    statement, training on a small sample dataset provided. For this project, we will
    use a binary logistic regression classification model using the **Stochastic Dual
    Coordinate Ascent** (**SDCA**) method. In [Chapter 3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml), *Regression
    Model*, we will go into greater depth on this method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Upon opening, and depending on your configuration in Visual Studio, it will
    either open directly on to the project creation screen, or will be an empty Visual
    Studio window. If your environment displays the latter, simply click **File**,
    then **New**, and then **Project**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the window opens, type `console app` in the search field to find **Console
    App (.NET Core)**. Make sure that the language type is C# (there are Visual Basic
    templates of the same name), highlight this template, and then click **Next**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/597d9e75-4c16-48cc-bec9-9f2a1b4a6f05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I suggest giving the project name something you can refer back to, such as
    `Chapter02`, to help you find the project later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4a2a7bc0-6834-49ad-86d8-a1b239db193c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, you have a .NET Core 3 console application, so now let''s add
    the `ML.NET` NuGet package. Right-click on the project and click **Manage NuGet
    Packages**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/23558c59-1a57-46d2-895f-d68fcb12d343.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Type `microsoft ml` into the search field. You should see the latest `Microsoft.ML`
    version available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/25864161-c542-4cab-a55d-b4085469a101.png)'
  prefs: []
  type: TYPE_IMG
- en: Once found, click the **Install** button. Simple!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the time of writing, 1.3.1 is the latest version available and all examples
    throughout this book will use that version. Prior to 1.0, the syntax was very
    much in flux, but since then has been consistent, so using a newer version should
    function identically.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the project is configured for ML.NET—all future projects will
    reference ML.NET in this fashion and refer you back to these steps.
  prefs: []
  type: TYPE_NORMAL
- en: Project architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simple project will be split into two primary functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Training and evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model runs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This split between functionality models real-world production applications that
    utilize machine learning, as there are often teams dedicated to each.
  prefs: []
  type: TYPE_NORMAL
- en: For those who wish to start with a completed project and follow along with the
    rest of this section, you can get the code from here: [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter02](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter02)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the project breakdown in Solution Explorer of
    Visual Studio. As mentioned earlier, the project is split into two main classes—`Predictor`
    and `Trainer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4131596-ad64-4b3c-b897-e5b8a14cb398.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Trainer` class contains all the model building and evaluation code, while
    the `Predictor` class, as the name implies, contains the code to run predictions
    with a trained model.
  prefs: []
  type: TYPE_NORMAL
- en: The `BaseML` class is what we will be using in subsequent chapters and expanding
    upon throughout the remainder of the book. The idea behind this class is to cut
    down on the **DRY** (**don't** **repeat** **yourself**) violations and to create
    a cohesive and easy to iterate framework. The `Constants` class further assists
    this idea—to cut down on magic strings as we move into more complex applications;
    this design will be used in all future chapter projects.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the `Program` class is the main entry point for our console application.
  prefs: []
  type: TYPE_NORMAL
- en: Running the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now deep dive into the various classes used within this project, including the
    following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RestaurantFeedback`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RestaurantPrediction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Trainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Predictor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BaseML`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Program`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RestaurantFeedback class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `RestaurantFeedback` class provides the input class for our model. In ML.NET
    (and other frameworks), the traditional approach is to have a structured input
    to feed into your data pipeline, which, in turn, is passed into the training phase
    and eventually your trained model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class defines our container class to hold our prediction values.
    This is the approach that we will use throughout the rest of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be wondering what the correlation between the `Label` and `Text`
    properties in the `RestarauntFeedback` class and the source data is at first glance.
    Contained within the `Data` folder, there is a file named `sampledata.csv`. This
    file contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first column maps to the `Label` property. As you might recall in [Chapter
    1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml), *Getting Started with Machine
    Learning and ML.NET*, supervised learning such as that being performed in this
    sample requires labeling. In this project, our label is a Boolean. False (0) in
    the dataset indicates positive feedback, while True (1) indicates negative feedback.
  prefs: []
  type: TYPE_NORMAL
- en: The second column maps to the `Text` property to propagate the sentiment (which
    is, the sentence to feed into the model).
  prefs: []
  type: TYPE_NORMAL
- en: The RestaurantPrediction class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `RestaurantPrediction` class contains the output properties that will come
    out of our model runs. Depending on the algorithm used, the output class, as you
    will find in future chapters, will contain many more properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Akin to the `RestaurantFeedback Label` property, the `Prediction` property contains
    the overall result of positive or negative feedback. The `Probability` property
    contains the confidence of our model of that decision. The `Score` property is
    used for the evaluation of our model.
  prefs: []
  type: TYPE_NORMAL
- en: The Trainer class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following, you will find the sole method in the `Trainer` class. The
    `Trainer` method at a high level does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It loads the training data (in this case our CSV) into memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It builds a training set and a test set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates the pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It trains and saves the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It performs an evaluation on the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the structure and flow we will follow throughout the rest of this book.
    Now, let''s dive into the code behind the `Train` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we check to make sure that the training data filename exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Even though this is a simple test application, it is always a good practice
    to treat it like a production-grade application. In addition, since this is a
    console application, you may incorrectly pass in a path for the training data,
    which then can cause exceptions further on in the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `LoadFromTextFile` helper method that ML.NET provides to assist with
    the loading of text files into an `IDataView` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are passing in both the training filename and the type;
    in this case, it is the `RestaurantFeedback` class mentioned earlier. It should
    be noted that this method has several other parameters, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`separatorChar`: This is the column separator character; it defaults to `\t`
    (in other words, a tab).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasHeader`: If set to `true`, the dataset''s first row has the header; it
    defaults to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowQuoting`: This defines whether the source file can contain columns defined
    by a quoted string; it defaults to false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trimWhitespace`: This removes trailing whitespace from the rows; it defaults
    to false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowSparse`: This defines whether the file can contain numerical vectors
    in sparse format; it defaults to false. The sparse format requires a new column
    to have the number of features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For most projects used throughout this book, we will use the default settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the `IDataView` object we created previously, use the `TrainTestSplit` method
    that ML.NET provides to create a test set from the main training data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in [Chapter 1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml), *Getting
    Started with Machine Learning and ML.NET*, sample data is split into two sets—training
    and test. The parameter, `testFraction`, specifies the percentage of the dataset
    to hold back for testing, in our case, 20%. By default, this parameter is set
    to 0.2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we create the pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Future examples will have a much more complex pipeline. In this example, we
    are simply mapping the `Text` property discussed earlier to the `Features` output
    column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we instantiate our `Trainer` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you might remember from [Chapter 1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml),
    *Getting Started with Machine Learning and ML.NET*, the various algorithms found
    in ML.NET are referred to as trainers. In this project, we are using an SCDA trainer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we complete the pipeline by appending the trainer we instantiated previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we train the model with the dataset we created earlier in the chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We save our newly created model to the filename specified, matching the training
    set''s schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we transform our newly created model with the test set we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will use the `testSetTransform` function created previously and
    pass it into the `BinaryClassification` class''s `Evaluate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This method allows us to generate model metrics. We then print the main metrics
    using the trained model with the test set. We will dive into these properties
    specifically in the *Evaluating the Model* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Predictor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Predictor` class, as noted earlier, is the class that provides prediction
    support in our project. The idea behind this method is to provide a simple interface
    to run the model, given the relatively simple input. In future chapters, we will
    be expanding this method structure to support more complex integrations, such
    as those hosted in a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Akin to what was done in the `Trainer` class, we verify that the model exists
    prior to reading it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the `ITransformer` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This object will contain our model once we load via the `Model.Load` method.
    This method can also take a direct file path. However, the stream approach lends
    itself to support non on-disk approaches that we will use in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `PredictionEngine` object given the model we loaded earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We are passing in both TSrc and TDst, in our case for this project, `RestaurantFeedback`
    and `RestaurantPrediction`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, call the `Predict` method on the `PredictionEngine` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Because, when we created the object with TSrc, the type was set to `RestaurantFeedback`,
    we have a strongly typed interface to our model. We then create the `RestaurantFeedback`
    object with the `inputData` variable that contains the string with the sentence
    we are going to run our model on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, display the prediction output along with the probability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The BaseML class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `BaseML` class, as discussed earlier, is going to contain the common code
    between our `Trainer` and `Predictor` classes, starting with this chapter. Over
    the remainder of the book, we will build on top of the `BaseML` class defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For all ML.NET applications in both training and predictions, an `MLContext`
    object is required. Initializing the object with a specific seed value is needed
    to create more consistent results during the testing component. Once a model is
    loaded, the seed value (or lack thereof) does not affect the output.
  prefs: []
  type: TYPE_NORMAL
- en: The Program class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Those of you who have created console applications should be familiar with
    the `Program` class and the `Main` method within. We will follow this structure
    for other console-based applications throughout the remainder of the book. The
    following code block contains the program class from which the application will
    begin execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This constitutes a fairly straightforward method implementation for those familiar
    with parsing command-line arguments. A simple two-argument approach is used as
    the help text indicates.
  prefs: []
  type: TYPE_NORMAL
- en: When executing a more complex command-line application that takes in several
    arguments (optional and required), Microsoft has provided a simple-to-use NuGet
    package, which is available here: [https://github.com/dotnet/command-line-api](https://github.com/dotnet/command-line-api)
  prefs: []
  type: TYPE_NORMAL
- en: Running the example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run both the training and prediction, simply build the project and then pass
    in the appropriate data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For training, you can use the included `sampledata.csv` file or create your
    own. We will do this by opening a PowerShell window and passing in the relative
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the model is built, you can run the prediction as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to try various phrases to test the efficacy of the model, and congratulations
    on training your first model!
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw when running the trainer component of the sample project, there are
    various elements of model evaluation. For each model type, there are different
    metrics to look at when analyzing the performance of a model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In binary classification models like the one found in the example project,
    the following properties are exposed in `CalibratedBiniaryClassificationMetrics`
    that we set after calling the `Evaluate` method. However, first, we need to define
    the four prediction types in a binary classification:'
  prefs: []
  type: TYPE_NORMAL
- en: 'True negative: Properly classified as negative'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'True positive: Properly classified as positive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False negative: Improperly classified as negative'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False positive: Improperly classified as positive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first metric to understand is **Accuracy**. As the name implies, accuracy
    is one of the most commonly used metrics when evaluating a model. This metric
    is calculated simply as the ratio of correctly classified predictions to total
    classifications.
  prefs: []
  type: TYPE_NORMAL
- en: The next metric to understand is **Precision**. Precision is defined as the
    proportion of true results over all the positive results in a model. For example,
    a precision of 1 means there were no false positives, an ideal scenario. A false
    positive is classifying something as positive when it should be classified as
    negative, as mentioned previously. A common example of a false positive is misclassifying
    a file as malicious when it is actually benign.
  prefs: []
  type: TYPE_NORMAL
- en: The next metric to understand is **Recall**. Recall is the fraction of all correct
    results returned by the model. For example, a recall of 1 means there were no
    false negatives, another ideal scenario. A false negative is classifying something
    as negative when it should have been classified as positive.
  prefs: []
  type: TYPE_NORMAL
- en: The next metric to understand is the **F-score**, which utilizes both precision
    and recall, producing a weighted average based on the false positives and false
    negatives. F-scores give another perspective on the performance of the model compared
    to simply looking at accuracy. The range of values is between 0 and 1, with an
    ideal value of 1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Area Under the Curve**, also referred to as AUC, is, as the name implies,
    the area under the curve plotted with true positives on the y-axis and false positives
    on the x-axis. For classifiers such as the model that we trained earlier in this
    chapter, as you saw, this returned values of between 0 and 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, **Average Log Loss** and **Training Log Loss** are both used to further
    explain the performance of the model. The average log loss is effectively expressing
    the penalty for wrong results in a single number by taking the difference between
    the true classification and the one the model predicts. Training log loss represents
    the uncertainty of the model using probability versus the known values. As you
    train your model, you will look to have a low number (lower numbers are better).
  prefs: []
  type: TYPE_NORMAL
- en: As regards the other model types, we will deep dive into how to evaluate them
    in their respective chapters, where we will cover regression and clustering metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this chapter, we have set up our development environment
    and learned about the proper organization of files going forward. We also created
    our first ML.NET application in addition to training, evaluating, and running
    predictions against a new model. Lastly, we explored how to evaluate a model and
    what the various properties mean.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deep dive into logistic regression algorithms.
  prefs: []
  type: TYPE_NORMAL
