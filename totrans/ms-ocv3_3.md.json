["```py\n      //convert image to gray \n      Mat img_gray; \n      cvtColor(input, img_gray, CV_BGR2GRAY); \n      blur(img_gray, img_gray, Size(5,5));    \n\n```", "```py\n      void Sobel(InputArray src, OutputArray dst, int ddepth, int       \n      xorder, int yorder, int ksize=3, double scale=1, double delta=0,        int borderType=BORDER_DEFAULT ) \n\n```", "```py\n      //Find vertical lines. Car plates have high density of vertical        \n      lines \n      Mat img_sobel; \n      Sobel(img_gray, img_sobel, CV_8U, 1, 0, 3, 1, 0); \n\n```", "```py\n      //threshold image \n      Mat img_threshold; \n      threshold(img_sobel, img_threshold, 0, 255,       \n      CV_THRESH_OTSU+CV_THRESH_BINARY); \n\n```", "```py\n      Mat element = getStructuringElement(MORPH_RECT, Size(17, 3)); \n\n```", "```py\n      morphologyEx(img_threshold, img_threshold, CV_MOP_CLOSE, \n      element); \n\n```", "```py\n      //Find contours of possibles plates \n      vector< vector< Point>> contours; \n      findContours(img_threshold, \n                contours,            // a vector of contours \n                CV_RETR_EXTERNAL,    // retrieve the external contours \n                CV_CHAIN_APPROX_NONE); // all pixels of each contours \n\n```", "```py\n      //Start to iterate to each contour founded \n      vector<vector<Point>>::iterator itc= contours.begin(); \n      vector<RotatedRect> rects; \n\n      //Remove patch that has no inside limits of aspect ratio and      \n      area.    \n      while (itc!=contours.end()) { \n        //Create bounding rect of object \n          RotatedRect mr= minAreaRect(Mat(*itc)); \n          if(!verifySizes(mr)){ \n          itc= contours.erase(itc); \n          }else{ \n          ++itc; \n          rects.push_back(mr); \n        } \n      } \n\n```", "```py\n      bool DetectRegions::verifySizes(RotatedRect candidate ){ \n\n      float error=0.4; \n        //Spain car plate size: 52x11 aspect 4,7272 \n      const float aspect=4.7272; \n        //Set a min and max area. All other patchs are discarded \n      int min= 15*aspect*15; // minimum area \n      int max= 125*aspect*125; // maximum area \n        //Get only patches that match to a respect ratio. \n      float rmin= aspect-aspect*error; \n      float rmax= aspect+aspect*error; \n\n      int area= candidate.size.height * candidate.size.width; \n      float r= (float)candidate.size.width /       \n      (float)candidate.size.height; \n      if(r<1) \n          r= 1/r; \n\n      if(( area < min || area > max ) || ( r < rmin || r > rmax )){ \n          return false; \n      }else{ \n          return true; \n        } \n      } \n\n```", "```py\n      for(int i=0; i< rects.size(); i++){ \n      //For better rect cropping for each possible box \n      //Make floodfill algorithm because the plate has white background \n      //And then we can retrieve more clearly the contour box \n        ircle(result, rects[i].center, 3, Scalar(0,255,0), -1); \n      //get the min size between width and height \n        float minSize=(rects[i].size.width < rects[i].size.height)?      \n      rects[i].size.width:rects[i].size.height; \n      minSize=minSize-minSize*0.5; \n      //initialize rand and get 5 points around center for floodfill      \n      algorithm \n      srand ( time(NULL) ); \n      //Initialize floodfill parameters and variables \n      Mat mask; \n      mask.create(input.rows + 2, input.cols + 2, CV_8UC1); \n      mask= Scalar::all(0); \n      int loDiff = 30; \n      int upDiff = 30; \n      int connectivity = 4; \n      int newMaskVal = 255; \n      int NumSeeds = 10; \n      Rect ccomp; \n      int flags = connectivity + (newMaskVal << 8 ) +             \n      CV_FLOODFILL_FIXED_RANGE + CV_FLOODFILL_MASK_ONLY; \n      for(int j=0; j<NumSeeds; j++){ \n      Point seed; \n      seed.x=rects[i].center.x+rand()%(int)minSize-(minSize/2); \n      seed.y=rects[i].center.y+rand()%(int)minSize-(minSize/2); \n      circle(result, seed, 1, Scalar(0,255,255), -1); \n      int area = floodFill(input, mask, seed, Scalar(255,0,0), &ccomp,        Scalar(loDiff, loDiff, loDiff), Scalar(upDiff, upDiff, upDiff),  \n      flags); \n\n```", "```py\n     intfloodFill(InputOutputArray image, InputOutputArray mask, Point       seed, Scalar newVal, Rect* rect=0, Scalar loDiff=Scalar(), Scalar       upDiff=Scalar(), int flags=4 ) \n\n```", "```py\n      //Check new floodfill mask match for a correct patch. \n      //Get all points detected for get Minimal rotated Rect \n      vector<Point> pointsInterest; \n      Mat_<uchar>::iterator itMask= mask.begin<uchar>(); \n      Mat_<uchar>::iterator end= mask.end<uchar>(); \n      for( ; itMask!=end; ++itMask) \n        if(*itMask==255) \n          pointsInterest.push_back(itMask.pos()); \n      RotatedRect minRect = minAreaRect(pointsInterest); \n      if(verifySizes(minRect)){ \n\n```", "```py\n      //Get rotation matrix \n      float r= (float)minRect.size.width / (float)minRect.size.height; \n      float angle=minRect.angle;     \n      if(r<1) \n      angle=90+angle; \n      Mat rotmat= getRotationMatrix2D(minRect.center, angle,1); \n\n```", "```py\n      //Create and rotate image \n      Mat img_rotated; \n      warpAffine(input, img_rotated, rotmat, input.size(), \n      CV_INTER_CUBIC); \n\n```", "```py\n      //Crop image \n      Size rect_size=minRect.size; \n      if(r < 1) \n      swap(rect_size.width, rect_size.height); \n      Mat img_crop; \n      getRectSubPix(img_rotated, rect_size, minRect.center, \n      img_crop); \n\n```", "```py\n      Mat resultResized; \n      resultResized.create(33,144, CV_8UC3); \n resize(img_crop, resultResized, resultResized.size(), 0, 0,       \n      INTER_CUBIC); \n      //Equalize croped image \n      Mat grayResult; \n      cvtColor(resultResized, grayResult, CV_BGR2GRAY); \n      blur(grayResult, grayResult, Size(3,3)); \n equalizeHist(grayResult, grayResult);\n\n```", "```py\n      output.push_back(Plate(grayResult,minRect.boundingRect())); \n\n```", "```py\n      FileStorage fs; \n      fs.open(\"SVM.xml\", FileStorage::READ); \n      Mat SVM_TrainingData; \n      Mat SVM_Classes; \n      fs[\"TrainingData\"] >>SVM_TrainingData; \n      fs[\"classes\"] >>SVM_Classes; \n\n```", "```py\n      Ptr<TrainData> trainData = TrainData::create(SVM_TrainingData,         \n      ROW_SAMPLE, SVM_Classes); \n\n```", "```py\n      Ptr<SVM> svmClassifier = SVM::create() \n\n```", "```py\n      svmClassifier-\n      >setTermCriteria(TermCriteria(TermCriteria::MAX_ITER, 1000,       \n      0.01)); \n      svmClassifier->setC(0.1); \n      svmClassifier->setKernel(SVM::LINEAR); \n\n```", "```py\n      svmClassifier->train(trainData); \n\n```", "```py\n      vector<Plate> plates; \n      for(int i=0; i< posible_regions.size(); i++) \n      { \n      Mat img=posible_regions[i].plateImg; \n      Mat p= img.reshape(1, 1);//convert img to 1 row m features \n      p.convertTo(p, CV_32FC1); \n int response = (int)svmClassifier.predict( p ); \n      if(response==1) \n      plates.push_back(posible_regions[i]); \n      } \n\n```", "```py\n      Mat img_threshold; \n      threshold(input, img_threshold, 60, 255, CV_THRESH_BINARY_INV); \n      if(DEBUG) \n      imshow(\"Threshold plate\", img_threshold); \n      Mat img_contours; \n      img_threshold.copyTo(img_contours); \n      //Find contours of possibles characters \n      vector< vector< Point>> contours; \n      findContours(img_contours, \n          contours, // a vector of contours \n          CV_RETR_EXTERNAL, // retrieve the external contours \n          CV_CHAIN_APPROX_NONE); // all pixels of each contours \n\n```", "```py\n      bool OCR::verifySizes(Mat r){ \n        //Char sizes 45x77 \n      float aspect=45.0f/77.0f; \n      float charAspect= (float)r.cols/(float)r.rows; \n      float error=0.35; \n      float minHeight=15; \n      float maxHeight=28; \n        //We have a different aspect ratio for number 1, and it can be \n       ~0.2 \n       float minAspect=0.2; \n      float maxAspect=aspect+aspect*error; \n        //area of pixels \n      float area=countNonZero(r); \n        //bb area \n      float bbArea=r.cols*r.rows; \n        //% of pixel in area \n      float percPixels=area/bbArea; \n      if(percPixels < 0.8 && charAspect > minAspect && charAspect <  \n      maxAspect && r.rows >= minHeight && r.rows < maxHeight) \n        return true; \n       else \n        return false; \n      } \n\n```", "```py\n      Mat OCR::ProjectedHistogram(Mat img, int t) \n      { \n      int sz=(t)?img.rows:img.cols; \n      Mat mhist=Mat::zeros(1,sz,CV_32F); \n\n      for(int j=0; j<sz; j++){ \n      Mat data=(t)?img.row(j):img.col(j); \n      mhist.at<float>(j)=countNonZero(data); \n      } \n\n      //Normalize histogram \n      double min, max; \n      minMaxLoc(mhist, &min, &max); \n\n      if(max>0) \n      mhist.convertTo(mhist,-1 , 1.0f/max, 0); \n\n      return mhist; \n      } \n\n```", "```py\n      Mat OCR::features(Mat in, int sizeData){ \n        //Histogram features \n Mat vhist=ProjectedHistogram(in,VERTICAL);Mat       \n      hhist=ProjectedHistogram(in,HORIZONTAL); \n        //Low data feature \n Mat lowData;resize(in, lowData, Size(sizeData, sizeData) ); \n      int numCols=vhist.cols + hhist.cols + lowData.cols * \n      lowData.cols; \n      Mat out=Mat::zeros(1,numCols,CV_32F); \n        //Asign values to feature \n      int j=0; \n      for(int i=0; i<vhist.cols; i++){ \n        out.at<float>(j)=vhist.at<float>(i); j++;} \n      for(int i=0; i<hhist.cols; i++){ \n        out.at<float>(j)=hhist.at<float>(i); \n        j++;} \n      for(int x=0; x<lowData.cols; x++){ \n        for(int y=0; y<lowData.rows; y++){ \n          out.at<float>(j)=(float)lowData.at<unsigned char>(x,y); \n          j++; \n          } \n        } \n      return out; \n      } \n\n```", "```py\n      void OCR::train(Mat TrainData, Mat classes, int nlayers){ \n      Mat_<int> layerSizes(1, 3); \n      layerSizes(0, 0) = data.cols; \n      layerSizes(0, 1) = nlayers; \n      layerSizes(0, 2) = numCharacters; \n      ann= ANN_MLP::create(); \n      ann->setLayerSizes(layerSizes); \n      ann->setActivationFunction(ANN_MLP::SIGMOID_SYM, 0, 0); \n      ann->setTrainMethod(ANN_MLP::BACKPROP, 0.0001, 0.0001); \n\n      //Prepare trainClases \n      //Create a mat with n trained data by m classes \n      Mat trainClasses; \n      trainClasses.create( TrainData.rows, numCharacters, CV_32FC1 ); \n      for( int i = 0; i <trainClasses.rows; i++ ) \n      { \n          for( int k = 0; k < trainClasses.cols; k++ ) \n          { \n            //If class of data i is same than a k class \n         if( k == classes.at<int>(i) ) \n             trainClasses.at<float>(i,k) = 1; \n               else \n                   trainClasses.at<float>(i,k) = 0; \n           } \n          } \n\n       Ptr<TrainData> trainData = TrainData::create(data, ROW_SAMPLE,           trainClasses); \n       //Learn classifier \n        ann->train( trainData ); \n\n      } \n\n```", "```py\n      int OCR::classify(Mat f){ \n      int result=-1; \n      Mat output; \n ann.predict(f, output); \n      Point maxLoc; \n      double maxVal; \n minMaxLoc(output, 0, &maxVal, 0, &maxLoc); \n      //We need know where in output is the max val, the x (cols) is        \n      the class. \n      return maxLoc.x; \n      } \n\n```", "```py\n      string licensePlate=plate.str(); \n      rectangle(input_image, plate.position, Scalar(0,0,200)); \n      putText(input_image, licensePlate, Point(plate.position.x,              plate.position.y), CV_FONT_HERSHEY_SIMPLEX, 1, \n      Scalar(0,0,200),2); \n\n```", "```py\n      Mat classes; \n      Mat trainingData; \n      //Read file storage. \n      FileStorage fs; \n      fs.open(\"OCR.xml\", FileStorage::READ); \n      fs[data] >> trainingData; \n      fs[\"classes\"] >> classes; \n\n```", "```py\n      float test(Mat samples, Mat classes){ \n      float errors=0; \n      for(int i=0; i<samples.rows; i++){ \n        int result= ocr.classify(samples.row(i)); \n        if(result!= classes.at<int>(i)) \n        errors++; \n      } \n      return errors/samples.rows; \n      } \n\n```", "```py\n      #!/bin/bash \n      echo \"#ITS t 5 t 10 t 15 t 20\">data.txt \n      folder=$(pwd) \n\n      for numNeurons in 10 20 30 40 50 60 70 80 90 100 120 150 200 500 \n      do \n      s5=0; \n      s10=0; \n      s15=0; \n      s20=0; \n      for j in {1..100} \n      do \n      echo $numNeurons $j \n      a=$($folder/build/evalOCR $numNeurons TrainingDataF5) \n      s5=$(echo \"scale=4; $s5+$a\" | bc -q 2>/dev/null) \n\n      a=$($folder/build/evalOCR $numNeurons TrainingDataF10) \n      s10=$(echo \"scale=4; $s10+$a\" | bc -q 2>/dev/null) \n\n      a=$($folder/build/evalOCR $numNeurons TrainingDataF15) \n      s15=$(echo \"scale=4; $s15+$a\" | bc -q 2>/dev/null) \n\n      a=$($folder/build/evalOCR $numNeurons TrainingDataF20) \n      s20=$(echo \"scale=4; $s20+$a\" | bc -q 2>/dev/null) \n      done \n\n      echo \"$i t $s5 t $s10 t $s15 t $s20\" \n      echo \"$i t $s5 t $s10 t $s15 t $s20\">>data.txt \n      done \n\n```"]