<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;R &#x2013; A Powerful Tool for Developing Machine Learning Algorithms"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. R – A Powerful Tool for Developing Machine Learning Algorithms</h1></div></div></div><p>Before using the machine learning techniques, we need to choose the proper software. There are many programming languages and types of software that provide the user with machine learning tools. In fact, the most important part is knowing which techniques to use and how to build new ones, and the software is just a tool. However, choosing the right software allows you to build faster and more accurate solutions.</p><p>In this chapter, you will learn:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The software requirements for building a machine learning solution</li><li class="listitem" style="list-style-type: disc">How R, combined with RStudio, facilitates the development of a machine learning solution</li><li class="listitem" style="list-style-type: disc">The structure of R</li><li class="listitem" style="list-style-type: disc">The tools of R</li><li class="listitem" style="list-style-type: disc">Some important R packages</li></ul></div><div class="section" title="Why R"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Why R</h1></div></div></div><p>Understanding the <a id="id46" class="indexterm"/>challenges in developing machine learning solutions helps in choosing the software that allows you to face them in the easiest and most effective way. This chapter illustrates the software requirements and explains why we will use R.</p><div class="section" title="An interactive approach to machine learning"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>An interactive approach to machine learning</h2></div></div></div><p>Developing a <a id="id47" class="indexterm"/>machine learning solution consists of steps that have different requirements. In addition, the result of a step helps in improving the previous, so it's often necessary to come back to modify it.</p><p>Before facing a problem and building its machine learning solution, we want to know as much as possible about the challenge and the available resources. Effectively, it's very important to have all the possible information in order to define the right path to the solution. For this purpose, starting from the data, we extract business insights and patterns from the data using statistical and machine learning tools.</p><p>A simple example is a big supermarket that launches a new marketing campaign that targets some specific customers. The available data is the transactions about the past sales. Before building any machine learning technique, we need some basic information such as the total number of customers and the total sales volume in the previous year. After knowing the total number of customers, we want to identify the average customer's annual expenditure. Then, the next step can be to divide the customers in groups with homogeneous purchasing habits and compute the average customer's annual expenditure for each group.</p><p>After extracting some basic information, we have a more detailed overview of the problem, and there will be new questions coming out very often. Therefore, we need to identify new patterns and extract new insights by applying other statistical and machine learning models. This procedure will go on until the information allows us to identify the final machine learning solution.</p><p>There are often different options for a solution to a problem. In order to choose the most proper one, we can build some of them and compare their results. In addition, most of the algorithms can be tuned to improve their performance, and the tuning depends on the results.</p><p>In conclusion, building a machine learning solution consists of different steps strongly related with each other. The target of a new step is based on the analysis of the previous one, and sometimes, a step is modified on the basis of the following results. There isn't a well-defined path that goes from the start to the end, and the software should allow that.</p><div class="mediaobject"><img src="graphics/7740OS_02_01.jpg" alt="An interactive approach to machine learning"/></div></div><div class="section" title="Expectations of machine learning software"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Expectations of machine learning software</h2></div></div></div><p>There are <a id="id48" class="indexterm"/>different options for a machine learning software, and this section shows what we are expecting from our choice. The software should, at the same time, provide the user with the machine learning tools and allow specific solutions to be built.</p><p>The most important machine learning techniques are provided by different types of software and packages. However, using cutting-edge techniques improves the solution. Most of the machine learning algorithms are developed by the academic world and used for research, so it takes time before they come into business. In addition, apart from a few exceptions, companies don't have enough resources to develop advanced techniques. Therefore, software should allow the user to access the tools developed in academia. In the case of free and open source software, there is usually an international community that provides the users with many packages that contain cutting-edge tools.</p><p>Another software requirement is to allow the user to develop quick and effective solutions. The approach to the machine learning problems requires a lot of interaction in the sense that the user often modifies the solution depending on the result. A good user-friendly graphic package is important to explore the results of each step and determine what to do. Therefore, the tool should allow the user to quickly build reusable components for data exploration, process, and visualization.</p><p>In conclusion, the software requirements are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Machine learning tools</li><li class="listitem" style="list-style-type: disc">Graphic packages</li><li class="listitem" style="list-style-type: disc">Reusability <a id="id49" class="indexterm"/>of components</li></ul></div></div><div class="section" title="R and RStudio"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>R and RStudio</h2></div></div></div><p>The software that we <a id="id50" class="indexterm"/>will use is R and this subsection explains why.</p><p>
<span class="strong"><strong>R</strong></span> is a <a id="id51" class="indexterm"/>programming language designed for data analysis and machine learning. It's an interpreted language in the sense that it executes the commands directly, so it is more user friendly than other programming languages. Although its learning curve is steeper compared to some commercial software, R is easier to learn compared to other programming languages.</p><p>R is the most popular programming language for statistics, and there is a huge international community that supports it. Its repository (CRAN) contains more than 5,000 packages with statistics and machine learning tools. In this way, we can use the most cutting-edge tools provided by its international community.</p><p>Other useful R tools are its graphic packages that allow the generation of nice and professional charts using just a few lines of code. In this way, it's very easy to explore data and results during the solution development.</p><p>Another advantage of R is <span class="strong"><strong>RStudio</strong></span>, which is an IDE projected for R. RStudio includes an interactive console and tools that are used to access the R help, visualize/save charts, and for debugging. R, combined with RStudio, allows the users to develop powerful machine learning solutions relatively quickly.</p></div></div></div>
<div class="section" title="The R tutorial"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>The R tutorial</h1></div></div></div><p>I assume that you are already familiar with a programming language, although not necessarily R. This section contains a brief R tutorial that shows some tools that are useful for building machine learning solutions. Since a proper introduction to R would require an entire book, this tutorial focuses on just some relevant topics.</p><p>If you're already familiar with R, you can quickly read through this section. If you're new to R, I advise you to combine this section with an interactive online tutorial to get a more complete overview. In addition, it'll be very useful to play with the tools in order to acquire more familiarity.</p><p>Before starting with the tutorial, we need to install R and RStudio. Both types of software are open source, and they support the most relevant operating systems. It's also useful to read the RStudio tutorial to understand how to use this powerful IDE.</p><p>My advice is to generate a new R script in the RStudio environment and to copy and paste the code into the <a id="id52" class="indexterm"/>script. You can run the command by going to the specific command line and pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Enter</em></span>.</p><div class="section" title="The basic tools of R"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>The basic tools of R</h2></div></div></div><p>The basic structure of R is very easy. Any kind of variable is stored in an <a id="id53" class="indexterm"/>object that can be visualized by typing its name. Let's start defining some numbers:</p><div class="informalexample"><pre class="programlisting">n1 &lt;- 2
n2 &lt;- 3</pre></div><p>We can visualize an <a id="id54" class="indexterm"/>object by typing its name, as follows:</p><div class="informalexample"><pre class="programlisting">n1
<span class="strong"><strong>[1] 2</strong></span>
</pre></div><p>We can perform some basic operations on the objects:</p><div class="informalexample"><pre class="programlisting">n1 + n2
<span class="strong"><strong>[1] 5</strong></span>
n1 * n2
<span class="strong"><strong>[1] 6</strong></span>
</pre></div><p>The output of any operation can be stored in another object:</p><div class="informalexample"><pre class="programlisting">nSum &lt;- n1 + n2
nProd &lt;- n1 * n2
nSum
<span class="strong"><strong>[1] 5</strong></span>
</pre></div><p>The standard syntax used to add comments to the code consists of starting the line with a hash, as shown:</p><div class="informalexample"><pre class="programlisting"># we performed some basic operations on the numbers</pre></div><p>We can apply the R functions to the object and the syntax is very easy since the arguments are always within the parenthesis: <code class="literal">result &lt;- functionName(argument1, argument2, …)</code>.</p><p>For instance, we can use <code class="literal">sum</code> to compute the sum of numeric variables:</p><div class="informalexample"><pre class="programlisting">sum(2, 3)
<span class="strong"><strong>[1] 5</strong></span>
sum(2, 3, 4)
<span class="strong"><strong>[1] 9</strong></span>
</pre></div><p>Similarly, for the operators, we can store the output of a function into another object, as shown:</p><div class="informalexample"><pre class="programlisting">s1 &lt;- sum(2, 3)
s2 &lt;- sum(2, 3, 4)</pre></div><p>There are also functions that print a message on the console. For instance, given any object, <code class="literal">print</code> displays its content in the same way, that is, by just typing the object name:</p><div class="informalexample"><pre class="programlisting">print(s1)
<span class="strong"><strong>[1] 5</strong></span>
</pre></div><p>The syntax used to define new functions is easy. For instance, we can define a function, <code class="literal">funProd</code>, which computes the product of its two arguments:</p><div class="informalexample"><pre class="programlisting">funProd &lt;- function(n1, n2)
{
  n &lt;- n1 * n2
  return(n)
}</pre></div><p>The <code class="literal">n1</code> and <code class="literal">n2</code> inputs are defined within the parenthesis and the operations are contained in the curly brackets. The <code class="literal">return</code> <a id="id55" class="indexterm"/>method terminates the function, giving the result as the output. We can <a id="id56" class="indexterm"/>visualize the code within any function just by typing its name.</p><p>In order to keep <a id="id57" class="indexterm"/>track of what the function is doing, we can print the variables while the <a id="id58" class="indexterm"/>function is executing, shown as follows:</p><div class="informalexample"><pre class="programlisting">funProdPrint &lt;- function(n1, n2){
  n &lt;- n1 * n2
  print(n1)
  print(n2)
  print(n)
  return(n)
}
prod &lt;- funProdPrint(n1 = 2, n2 = 3)
<span class="strong"><strong>[1] 2</strong></span>
<span class="strong"><strong>[1] 3</strong></span>
<span class="strong"><strong>[1] 6</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>There are different R functions associated with documentation. We can use <code class="literal">help</code> to display their description, as shown:</p><div class="informalexample"><pre class="programlisting">help(sum)</pre></div><p>Another option is to use <code class="literal">sum</code>, but personally, I prefer to use <code class="literal">help</code> in order to use the same parenthesis syntax of the other R functions.</p><p>In order to perform basic R operations, we have to store the data in the vectors that are objects that contain a sorted collection of values. We can define a new vector using <code class="literal">c</code>, which is a function that concatenates its input, shown as follows:</p><div class="informalexample"><pre class="programlisting">a1 &lt;- c(1, 2, 3)
a1
<span class="strong"><strong>[1] 1 2 3</strong></span>
</pre></div><p>We can extract an element of the vector using square brackets. The first element can be extracted putting <code class="literal">1</code> inside the square brackets. Please note that R indexes differently from other programming languages <a id="id59" class="indexterm"/>such as Python, where the first element is indexed as <code class="literal">0</code> instead of <code class="literal">1</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">a1[1]
<span class="strong"><strong>[1] 1</strong></span>
</pre></div><p>We can extract <a id="id60" class="indexterm"/>more than one element at the same time by putting a vector <a id="id61" class="indexterm"/>inside the square brackets, as shown here:</p><div class="informalexample"><pre class="programlisting">a1[c(1, 2)]
<span class="strong"><strong>[1] 1 2</strong></span>
</pre></div><p>We can also perform some basic operations on the vectors:</p><div class="informalexample"><pre class="programlisting">a sPaste &lt;- paste(s1, s2, sep = '_')
1 + 1
<span class="strong"><strong>[1] 2 3 4</strong></span>
a2 &lt;- c(1, 2, 3)
a1 + a2
<span class="strong"><strong>[1] 2 4 6</strong></span>
</pre></div><p>If we want to define a vector that contains a sequence of integers, we can use this notation:</p><div class="informalexample"><pre class="programlisting">a3 &lt;- 1:10
a3
<span class="strong"><strong>[1]  1  2  3  4  5  6  7  8  9 10</strong></span>
</pre></div><p>The vectors can contain undefined values, which are <code class="literal">NA</code> in R:</p><div class="informalexample"><pre class="programlisting">a4 &lt;- c(1, NA, 2)</pre></div><p>If we perform an operation on an <code class="literal">NA</code> value, the output will be <code class="literal">NA</code>.</p><p>Another important data element is Boolean. Boolean variables are defined using <code class="literal">TRUE</code> and <code class="literal">FALSE</code>, and the basic operators are <code class="literal">&amp;</code> or <code class="literal">&amp;&amp;</code> (AND), <code class="literal">|</code> or <code class="literal">||</code> (OR), as well as <code class="literal">!</code> (NOT). Boolean elements can be single elements or vectors. In the case of vectors, the shorter forms (<code class="literal">&amp;</code> and <code class="literal">|</code>) compare each element and the long forms (<code class="literal">&amp;&amp;</code> and <code class="literal">||</code>) evaluate only the first element of each vector, shown as follows:</p><div class="informalexample"><pre class="programlisting">bool1 &lt;- TRUE
bool2 &lt;- FALSE
bool3 &lt;- bool1 &amp; bool2
bool4 &lt;- bool1 | bool2
bool5 &lt;- !bool1
bool3
<span class="strong"><strong>[1] FALSE</strong></span>
bool4
<span class="strong"><strong>[1] TRUE</strong></span>
bool5
<span class="strong"><strong>[1] FALSE</strong></span>
</pre></div><p>We can define <a id="id62" class="indexterm"/>Boolean variables using relational operators <a id="id63" class="indexterm"/>such as <code class="literal">==</code> (equal to), <code class="literal">!=</code> (not equal to), <code class="literal">&lt;=</code> (less than or equal to), <code class="literal">&gt;=</code>, <code class="literal">&lt;</code>, and <code class="literal">&gt;</code>:</p><div class="informalexample"><pre class="programlisting">x1 &lt;- 1
x2 &lt;- 2
bool5 &lt;- x1 == x2
bool6 &lt;- x1 != x2
bool7 &lt;- x1 &lt;= x2
bool5
<span class="strong"><strong>[1] FALSE</strong></span>
bool6
<span class="strong"><strong>[1] TRUE</strong></span>
bool7
<span class="strong"><strong>[1] FALSE</strong></span>
</pre></div><p>Boolean variables can be included in the <code class="literal">if</code> statements defined by <code class="literal">if</code> with a syntax similar to the functions. We <a id="id64" class="indexterm"/>put the condition within the parenthesis and the operations are within the curly brackets, shown as follows:</p><div class="informalexample"><pre class="programlisting">if(bool5){
  x &lt;- 1
}else{
  x &lt;- 2
}
x
<code class="literal">[1] 2</code>
</pre></div><p>We can define <code class="literal">for</code> loops using <code class="literal">for</code> and their syntax is the same as <code class="literal">if</code>. The parenthesis contains the variable name and the vector with the values, and the curly brackets contain the operations, shown as follows:</p><div class="informalexample"><pre class="programlisting">vectorI &lt;- c(1, 2, 5)
x &lt;- 0
for(i in vectorI)
{
  if(i &gt; 1)
  {
    x &lt;- x + i
  }
}
x
<span class="strong"><strong>[1] 7</strong></span>
</pre></div><p>If we want to repeat an operation for a fixed number of times, we can define a vector that contains the first <span class="emphasis"><em>n</em></span> <a id="id65" class="indexterm"/>integer numbers:</p><div class="informalexample"><pre class="programlisting">nIter &lt;- 10
vectorIter &lt;- 1:nIter
total &lt;- 0
for(i in vectorIter){
  total &lt;- total + 1
}
total
<span class="strong"><strong>[1] 10</strong></span>
</pre></div><p>This subsection showed <a id="id66" class="indexterm"/>some basic components of R. The next subsection <a id="id67" class="indexterm"/>presents the R objects that analyze the data.</p></div><div class="section" title="Understanding the basic R objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Understanding the basic R objects</h2></div></div></div><p>There are different <a id="id68" class="indexterm"/>kinds of objects, and we have seen some of them: <code class="literal">numeric</code>, <code class="literal">function</code>, <code class="literal">boolean</code>, and <code class="literal">vector</code>. We can easily identify the class of the objects <a id="id69" class="indexterm"/>used in the previous examples.</p><p>Consider the <a id="id70" class="indexterm"/>following example:</p><div class="informalexample"><pre class="programlisting">class(n1)
<span class="strong"><strong>[1] "numeric"</strong></span>
class(funProd)
<span class="strong"><strong>[1] "function"</strong></span>
class(bool5)
<span class="strong"><strong>[1] "logical"</strong></span>
class(a1)
<span class="strong"><strong>[1] "numeric"</strong></span>
</pre></div><p>The <code class="literal">a1</code> vector belongs to the <code class="literal">numeric</code> class because all its elements are numeric. In the same way, a vector with logical elements belongs to <code class="literal">logical</code>.</p><p>Strings are defined using single or double quotes, shown as follows:</p><div class="informalexample"><pre class="programlisting">s1 &lt;- 'string1'
s2 &lt;- "string2"</pre></div><p>There are different string functions such as <code class="literal">paste</code>, which concatenates two strings, and <code class="literal">substring</code>, which extracts a subset from the string, as shown:</p><div class="informalexample"><pre class="programlisting">sPaste &lt;- paste(s1, s2, sep = '_')
sPaste
<span class="strong"><strong>[1] "string1_string2"</strong></span>
sSub &lt;- substring(sPaste, 2, 5)
sSub
<span class="strong"><strong>[1] "trin"</strong></span>
</pre></div><p>It's possible to define a <code class="literal">string</code> vector in the same way as <code class="literal">numeric</code> or <code class="literal">logical</code>:</p><div class="informalexample"><pre class="programlisting">vectorStrings &lt;- c(s1, s2, sPaste, sSub)
vectorStrings
<span class="strong"><strong>[1] "string1"         "string2"         "string1_string2" "trin"</strong></span>
class(vectorStrings)
<span class="strong"><strong>[1] "character"</strong></span>
</pre></div><p>A vector can include <a id="id71" class="indexterm"/>any kind of object (even functions potentially). What happens if we define a vector that contains strings and numbers?</p><div class="informalexample"><pre class="programlisting">vectorStringsNum &lt;- c(s1, s2, 10, 1.3)
vectorStringsNum
<span class="strong"><strong>[1] "string1" "string2" "10"      "1.3"   </strong></span>
class(vectorStringsNum)
<span class="strong"><strong>[1] "character"</strong></span>
</pre></div><p>As shown in the preceding <a id="id72" class="indexterm"/>code, R converted the numbers into characters in order to have a homogeneous vector. However, there are other data structures that allow us to store heterogeneous objects.</p><p>If we have categoric variables, we can use strings to store them, but there is another option: <code class="literal">factors</code>. This <a id="id73" class="indexterm"/>R object contains a variable whose value belongs to a defined set of values known as <code class="literal">levels</code>. Each level is associated with an integer and the data can be treated as integers or characters that obtain the same result. Factors can also help in creating ordinal variables.</p><p>Starting from a string, we can generate a factor using <code class="literal">factor</code>:</p><div class="informalexample"><pre class="programlisting">vectorString &lt;- c('a', 'a', 'b', 'c')
vectorFactor &lt;- factor(vectorString)
class(vectorFactor)
<span class="strong"><strong>[1] "factor"</strong></span>
</pre></div><p>Using levels, we can identify the possible values:</p><div class="informalexample"><pre class="programlisting">levels(vectorFactor)</pre></div><p>Another useful function, although not necessarily related to factors, is <code class="literal">table</code>, and it counts the occurrences of each level:</p><div class="informalexample"><pre class="programlisting">table(vectorFactor)
<span class="strong"><strong>vectorFactor</strong></span>
<span class="strong"><strong>a b c </strong></span>
<span class="strong"><strong>2 1 1 </strong></span>
</pre></div><p>Another useful data element is <code class="literal">Date</code>, and it is one of the R options used to store dates. We start building a string such as <code class="literal">'2013-01-01'</code> and defining the position of the year, month, and day in another string, as shown:</p><div class="informalexample"><pre class="programlisting">stringDate &lt;- '2013-01-01'
formatDate &lt;- '%Y-%m-%d'</pre></div><p>Now, using <code class="literal">as.Date</code>, we can generate the date object:</p><div class="informalexample"><pre class="programlisting">date1 &lt;- as.Date(stringDate, format = formatDate)
class(date1)
<span class="strong"><strong>[1] "Date"</strong></span>
date1
<span class="strong"><strong>[1] "2013-01-01"</strong></span>
</pre></div><p>We can apply simple <a id="id74" class="indexterm"/>operations on dates, such as adding a definite number of days:</p><div class="informalexample"><pre class="programlisting">date2 &lt;- date1 + 10
date2
<span class="strong"><strong>[1] "2013-01-11"</strong></span>
</pre></div><p>We can also use Boolean operators to match two dates:</p><div class="informalexample"><pre class="programlisting">date1 &gt; date2
<span class="strong"><strong>[1] FALSE</strong></span>
</pre></div><p>Another data type is <a id="id75" class="indexterm"/>
<code class="literal">list</code>, and it defines an ordered heterogeneous collection of <a id="id76" class="indexterm"/>data elements:</p><div class="informalexample"><pre class="programlisting">l1 &lt;- list(1, a1, sPaste)
l1
<span class="strong"><strong>[[1]]</strong></span>
<span class="strong"><strong>[1] 1</strong></span>

<span class="strong"><strong>[[2]]</strong></span>
<span class="strong"><strong>[1] 1 2 3</strong></span>

<span class="strong"><strong>[[3]]</strong></span>
<span class="strong"><strong>[1] "string1_string2"</strong></span>
</pre></div><p>Each object can be associated with a key that allows us to access it:</p><div class="informalexample"><pre class="programlisting">l2 &lt;- list(elNumber = 1, elvector = a1, elString = sPaste)
l2
<span class="strong"><strong>$elNumber</strong></span>
<span class="strong"><strong>[1] 1</strong></span>

<span class="strong"><strong>$elVector</strong></span>
<span class="strong"><strong>[1] 1 2 3</strong></span>

<span class="strong"><strong>$elString</strong></span>
<span class="strong"><strong>[1] "string1_string2"</strong></span>
</pre></div><p>In both cases, we can extract an element from a list using a double square bracket and the position of the element, as shown:</p><div class="informalexample"><pre class="programlisting">l1[[1]]
<span class="strong"><strong>[1] 1</strong></span>
l2[[1]]
<span class="strong"><strong>[1] 1</strong></span>
</pre></div><p>In the case of <code class="literal">l2</code>, we have <a id="id77" class="indexterm"/>defined its key, so we can access its elements using the <code class="literal">$</code> operator:</p><div class="informalexample"><pre class="programlisting">l2$elNumber
<span class="strong"><strong>[1] 1</strong></span>
</pre></div><p>We can visualize all the key names using <code class="literal">names</code>:</p><div class="informalexample"><pre class="programlisting">names(l2)
<span class="strong"><strong>[1] "elNumber" "elVector"  "elString"</strong></span>
</pre></div><p>It's also possible to define or change the key names:</p><div class="informalexample"><pre class="programlisting">names(l1) &lt;- c('el1', 'el2', 'el3')
names(l1)
<span class="strong"><strong>[1] "el1" "el2" "el3"</strong></span>
</pre></div><p>In order to extract a <a id="id78" class="indexterm"/>sublist from a list, we can use the single square brackets, similar to the <a id="id79" class="indexterm"/>vectors:</p><div class="informalexample"><pre class="programlisting">l3 &lt;- l2[1]
l3
$elNumber
<span class="strong"><strong>[1] 1</strong></span>
l4 &lt;- l2[c(1, 2)]
l4
$elNumber
<span class="strong"><strong>[1] 1</strong></span>

$elVector
<span class="strong"><strong>[1] 1 2 3</strong></span>
</pre></div><p>An R object that allows you to store tabular data is a <code class="literal">matrix</code>. To generate a new matrix, put all the values in a vector and use <code class="literal">matrix</code>, shown as follows:</p><div class="informalexample"><pre class="programlisting">vectorMatrix &lt;- c(1, 2, 3, 11, 12, 13)
matrix1 &lt;- matrix(vectorMatrix, ncol = 2)
matrix1
<span class="strong"><strong>     [,1] [,2]</strong></span>
<span class="strong"><strong>[1,]    1   11</strong></span>
<span class="strong"><strong>[2,]    2   12</strong></span>
<span class="strong"><strong>[3,]    3   13</strong></span>
</pre></div><p>Using <code class="literal">t</code>, we can transpose a matrix, which means we can switch the rows with the columns:</p><div class="informalexample"><pre class="programlisting">matrix2 &lt;- t(matrix1)
matrix2
<span class="strong"><strong>     [,1] [,2] [,3]</strong></span>
<span class="strong"><strong>[1,]    1    2    3</strong></span>
<span class="strong"><strong>[2,]   11   12   13</strong></span>
</pre></div><p>As shown in the preceding code, <code class="literal">matrix1</code> and <code class="literal">matrix2</code> contain only numeric data. Using <code class="literal">cbind</code>, we can add another column. What happens if we add a character column?</p><div class="informalexample"><pre class="programlisting">vector3 &lt;- c('a', 'b', 'c')
matrix3 &lt;- cbind(matrix1, vector3)
matrix3</pre></div><p>R converts numbers into <a id="id80" class="indexterm"/>characters. The reason is that the matrices, like vectors, can contain only homogeneous data.</p><p>The matrices can have <a id="id81" class="indexterm"/>row and column names, and we can display them using <a id="id82" class="indexterm"/>
<code class="literal">rownames</code> and <code class="literal">colnames</code>:</p><div class="informalexample"><pre class="programlisting">rownames(matrix3)
<span class="strong"><strong>NULL</strong></span>
colnames(matrix3)
<span class="strong"><strong>[1] ""       ""       "vector3"</strong></span>
</pre></div><p>We defined <code class="literal">matrix3</code> by adding a column to <code class="literal">matrix3</code>. Its columns and R automatically set the last column name equal to the vector name, that is, <code class="literal">vector3</code>. Using the same functions, we can set the row and column names manually, as shown:</p><div class="informalexample"><pre class="programlisting">rownames(matrix3) &lt;- c('row1', 'row2', 'row3')
colnames(matrix3) &lt;- c('col1', 'col2', 'col3')
matrix3
<span class="strong"><strong>     col1 col2 col3</strong></span>
<span class="strong"><strong>row1 "1"  "11" "a" </strong></span>
<span class="strong"><strong>row2 "2"  "12" "b" </strong></span>
<span class="strong"><strong>row3 "3"  "13" "c" </strong></span>
</pre></div><p>We can visualize a data frame using <code class="literal">View</code>:</p><div class="informalexample"><pre class="programlisting">View(df2)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>For the data frames, refer to the scripts of this chapter.</p></div></div><p>There are some functions that allow the same operation to be performed on each element of a vector, matrix, or list. The functions are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">apply</code>: Apply a <a id="id83" class="indexterm"/>function to each row, column, or element of a matrix</li><li class="listitem" style="list-style-type: disc"><code class="literal">sapply</code>: Apply a function <a id="id84" class="indexterm"/>to each element of a vector</li><li class="listitem" style="list-style-type: disc"><code class="literal">lapply</code>: Apply a function to <a id="id85" class="indexterm"/>each element of a list</li></ul></div><p>The <code class="literal">sapply</code> function is the easiest, so we can start with it. We can define a vector <code class="literal">x1</code> with the integer numbers between <code class="literal">1</code> and <code class="literal">10</code>, and a function, <code class="literal">func1</code>, which returns the square of the input:</p><div class="informalexample"><pre class="programlisting">x1 &lt;- 1:10
func1 &lt;- function(el){
  result &lt;- el ^ 2
  return(result)
}</pre></div><p>Now, we can use <code class="literal">sapply</code> <a id="id86" class="indexterm"/>by specifying the arguments: <code class="literal">X</code>—the array, and <code class="literal">FUN</code>—the <a id="id87" class="indexterm"/>function:</p><div class="informalexample"><pre class="programlisting">sapply(X = x1, FUN = func1)
<span class="strong"><strong>[1]   1   4   9  16  25  36  49  64  81 100</strong></span>
</pre></div><p>Similarly, we can <a id="id88" class="indexterm"/>use <code class="literal">lapply</code>:</p><div class="informalexample"><pre class="programlisting">l1 &lt;- list(a = 1, b = 2, c = 3)
lapply(X = l1, FUN = func1)
<span class="strong"><strong>$a</strong></span>
<span class="strong"><strong>[1] 1</strong></span>

<span class="strong"><strong>$b</strong></span>
<span class="strong"><strong>[1] 4</strong></span>

<span class="strong"><strong>$c</strong></span>
<span class="strong"><strong>[1] 9</strong></span>
</pre></div><p>The function that performs an operation on a matrix is <code class="literal">apply</code>. It can be used to apply the same function to each row. Let's first define a matrix:</p><div class="informalexample"><pre class="programlisting">matrix4 &lt;- matrix(1:9, nrow = 3)
matrix4
<span class="strong"><strong>     [,1] [,2] [,3]</strong></span>
<span class="strong"><strong>[1,]    1    4    7</strong></span>
<span class="strong"><strong>[2,]    2    5    8</strong></span>
<span class="strong"><strong>[3,]    3    6    9</strong></span>
</pre></div><p>In order to apply the <code class="literal">sum</code> function to each row, we use <code class="literal">apply</code>, defining the <code class="literal">MARGIN</code> input equal to <code class="literal">1</code>, which specifies that we perform the operation on each row:</p><div class="informalexample"><pre class="programlisting">apply(X = matrix4, MARGIN = 1, FUN = sum)
<span class="strong"><strong>[1] 12 15 18</strong></span>
</pre></div><p>Defining <code class="literal">MARGIN = 2</code>, we perform the operation on each column:</p><div class="informalexample"><pre class="programlisting">apply(X = matrix4, MARGIN = 2, FUN = sum)
<span class="strong"><strong>[1]  6 15 24</strong></span>
</pre></div><p>We can apply the <a id="id89" class="indexterm"/>function to each element of the matrix using <code class="literal">MARGIN = c(1, 2)</code>:</p><div class="informalexample"><pre class="programlisting">apply(X = matrix4, MARGIN = c(1, 2), FUN = func1)
<span class="strong"><strong>     [,1] [,2] [,3]</strong></span>
<span class="strong"><strong>[1,]    1   16   49</strong></span>
<span class="strong"><strong>[2,]    4   25   64</strong></span>
<span class="strong"><strong>[3,]    9   36   81</strong></span>
</pre></div><p>This section showed some <a id="id90" class="indexterm"/>R objects and tools that are relevant to machine learning <a id="id91" class="indexterm"/>analysis. However, they're still just the basics.</p></div><div class="section" title="What are the R standards?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>What are the R standards?</h2></div></div></div><p>There are some style rules for <a id="id92" class="indexterm"/>having a clean and standardized code, and this subsection shows some of them.</p><p>Unlike other programming <a id="id93" class="indexterm"/>languages, R doesn't require any indentation. However, indenting the code makes it more readable and clean. The R standard is to use two spaces, and RStudio automatically defines this indentation.</p><p>The standard for <a id="id94" class="indexterm"/>assigning a variable is to use the <code class="literal">&lt;-</code> operator even if it's possible to use <code class="literal">=</code> to make R more similar to other programming languages. However, the two operators have a different meaning if used within function input.</p><p>There are different options for the identifiers, and personally, I like the lower camel case:</p><div class="informalexample"><pre class="programlisting">lowerCamelCase</pre></div><p>However, the R community is very big and there are different conventions.</p><p>Each operator should be surrounded by spaces, and in a function's input, there should always be a space after a comma:</p><div class="informalexample"><pre class="programlisting">x &lt;- 1
sum(1, 2)</pre></div><p>There are some other style rules, and you can find them at <a class="ulink" href="https://google-styleguide.googlecode.com/svn/trunk/Rguide.xml">https://google-styleguide.googlecode.com/svn/trunk/Rguide.xml</a>.</p></div></div>
<div class="section" title="Some useful R packages"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Some useful R packages</h1></div></div></div><p>There are different R <a id="id95" class="indexterm"/>packages that provide users with general-purpose functions and specific techniques. This chapter introduces two powerful general purpose packages: <code class="literal">data.table</code> and <code class="literal">plyr</code>.</p><p>Some packages are already <a id="id96" class="indexterm"/>installed in the basic version of R. However, in order to use <code class="literal">data.table</code> and <code class="literal">plyr</code>, we need to download them from the official CRAN repository using <code class="literal">install.packages</code>. Let's start with <code class="literal">data.table</code>, which is a package that provides additional tools used to deal with data frames:</p><div class="informalexample"><pre class="programlisting">install.packages('data.table')</pre></div><p>If the command doesn't work, you can specify the repository:</p><div class="informalexample"><pre class="programlisting">install.packages(
  pkgs = 'data.table',
  repos = 'http://cran.us.r-project.org'
)</pre></div><p>After installing <a id="id97" class="indexterm"/>the package, we need to load it in order to use its functions. Unfortunately, R will import all the functions from the package without using a namespace, and sometimes there might be name conflicts across different packages:</p><div class="informalexample"><pre class="programlisting">library(data.table)</pre></div><p>The package contains a new class called <code class="literal">data.table</code>, which inherits from <code class="literal">data.frame</code>. Inheritance means that data tables can use all the data frame tools, if not overrided, plus others.</p><p>In order to use the package, the starting point is a dataset that we will analyze. R provides the user with some datasets, and we can see their list and description using <code class="literal">data</code>:</p><div class="informalexample"><pre class="programlisting">data()</pre></div><p>The dataset that we will use is <code class="literal">iris</code>. Although it's a very standard dataset for the tutorials, I decided to use it since it's good to use to show the data table tools. I promise that I will choose more interesting topics in the following chapters. First, let's read the data description:</p><div class="informalexample"><pre class="programlisting">help(iris)</pre></div><p>The dataset contains the data about three species of iris flowers: <code class="literal">setosa</code>, <code class="literal">versicolor</code>, and <code class="literal">virginica</code>. The data displays the length and the width of the sepal and the petals of each flower.</p><p>The <code class="literal">iris</code> dataset is a data frame. First, let's convert it into a data table using <code class="literal">data.table</code>:</p><div class="informalexample"><pre class="programlisting">class(iris)
<span class="strong"><strong>[1] "data.frame"</strong></span>
dtIris &lt;- data.table(iris)
class(dtIris)
<span class="strong"><strong>[1] "data.table" "data.frame"</strong></span>
</pre></div><p>The <code class="literal">dtIris</code> object belongs to the <code class="literal">data.table</code> and <code class="literal">data.frame</code> classes because of inheritance. Before <a id="id98" class="indexterm"/>analyzing the data, we can use <code class="literal">str</code> to quickly explore the structure:</p><div class="informalexample"><pre class="programlisting">str(dtIris)
<span class="strong"><strong>Classes 'data.table' and 'data.frame':  150 obs. of  5 variables:</strong></span>
<span class="strong"><strong> $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...</strong></span>
<span class="strong"><strong> $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...</strong></span>
<span class="strong"><strong> $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...</strong></span>
<span class="strong"><strong> $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...</strong></span>
<span class="strong"><strong> $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...</strong></span>
<span class="strong"><strong> - attr(*, ".internal.selfref")=&lt;externalptr&gt; </strong></span>
</pre></div><p>As we can see, there are four numerical columns that show the attributes of the flower and one factor column that <a id="id99" class="indexterm"/>shows the species. Now, using <code class="literal">print</code>, we can display <a id="id100" class="indexterm"/>the data contained in <code class="literal">dtIris</code>:</p><div class="informalexample"><pre class="programlisting">print(dtIris)
<span class="strong"><strong>     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species</strong></span>
<span class="strong"><strong>  1:          5.1         3.5          1.4         0.2    setosa</strong></span>
<span class="strong"><strong>  2:          4.9         3.0          1.4         0.2    setosa</strong></span>
<span class="strong"><strong>  3:          4.7         3.2          1.3         0.2    setosa</strong></span>
<span class="strong"><strong>  4:          4.6         3.1          1.5         0.2    setosa</strong></span>
<span class="strong"><strong>  5:          5.0         3.6          1.4         0.2    setosa</strong></span>
<span class="strong"><strong> ---                                                            </strong></span>
<span class="strong"><strong>146:          6.7         3.0          5.2         2.3 virginica</strong></span>
<span class="strong"><strong>147:          6.3         2.5          5.0         1.9 virginica</strong></span>
<span class="strong"><strong>148:          6.5         3.0          5.2         2.0 virginica</strong></span>
<span class="strong"><strong>149:          6.2         3.4          5.4         2.3 virginica</strong></span>
<span class="strong"><strong>150:          5.9         3.0          5.1         1.8 virginica</strong></span>
</pre></div><p>Now, we can see the first and last five rows. In order to see the whole table, we can use <code class="literal">View</code>:</p><div class="informalexample"><pre class="programlisting">View(dtIris)</pre></div><p>After viewing the data, let's see the basic operations. The square brackets allow us to perform a wide range of operations. For instance, by putting a number in the square brackets, we extract the related row:</p><div class="informalexample"><pre class="programlisting">dtIris[1]
<span class="strong"><strong>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species</strong></span>
<span class="strong"><strong>1:          5.1         3.5          1.4         0.2  setosa</strong></span>
</pre></div><p>By putting a vector, we can extract more rows:</p><div class="informalexample"><pre class="programlisting">dtIris[1:3]
<span class="strong"><strong>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species</strong></span>
<span class="strong"><strong>1:          5.1         3.5          1.4         0.2  setosa</strong></span>
<span class="strong"><strong>2:          4.9         3.0          1.4         0.2  setosa</strong></span>
<span class="strong"><strong>3:          4.7         3.2          1.3         0.2  setosa</strong></span>
</pre></div><p>If we want to extract a <a id="id101" class="indexterm"/>column, we insert the column name as the second argument:</p><div class="informalexample"><pre class="programlisting">dtIris[, Species]
<span class="strong"><strong>[1] setosa     setosa     setosa     setosa     setosa     setosa   </strong></span>
<span class="strong"><strong>…</strong></span>
<span class="strong"><strong>[145] virginica  virginica  virginica  virginica  virginica  virginica </strong></span>
<span class="strong"><strong>Levels: setosa versicolor virginica</strong></span>
</pre></div><p>Instead of the column name, we could have used the number of the column position, which, is 5 in this case. We <a id="id102" class="indexterm"/>can also extract rows and columns at the same time:</p><div class="informalexample"><pre class="programlisting">dtIris[1:3, Species]
<span class="strong"><strong>[1] setosa setosa setosa</strong></span>
<span class="strong"><strong>Levels: setosa versicolor virginica</strong></span>
</pre></div><p>What if we want to <a id="id103" class="indexterm"/>define a data table that has only the first three columns? We can use a similar notation, including <code class="literal">Species</code> as a string and adding <code class="literal">with = F</code> as the third argument:</p><div class="informalexample"><pre class="programlisting">dtIris[1:3, 'Species', with = F]
<span class="strong"><strong>   Species</strong></span>
<span class="strong"><strong>1:  setosa</strong></span>
<span class="strong"><strong>2:  setosa</strong></span>
<span class="strong"><strong>3:  setosa</strong></span>
</pre></div><p>We can also extract a data table with two or more columns of <code class="literal">dtIris</code>:</p><div class="informalexample"><pre class="programlisting">dtIris[1:3, c(5, 1, 2), with = F]
<span class="strong"><strong>   Species Sepal.Length Sepal.Width</strong></span>
<span class="strong"><strong>1:  setosa          5.1         3.5</strong></span>
<span class="strong"><strong>2:  setosa          4.9         3.0</strong></span>
<span class="strong"><strong>3:  setosa          4.7         3.2</strong></span>
</pre></div><p>We put a vector in the first argument to select rows. Like data frames and matrices, we can select the rows that define a logical vector, for instance <code class="literal">dtIris$Sepal.Length &gt; 7</code>. In the case of data tables, we can directly access the columns without using the <code class="literal">$</code> operator. Then, we just need to include <code class="literal">Sepal.Length &gt; 7</code> as the first argument:</p><div class="informalexample"><pre class="programlisting">dtIris[Sepal.Length &gt; 7]
<span class="strong"><strong>    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species</strong></span>
<span class="strong"><strong> 1:          7.1         3.0          5.9         2.1 virginica</strong></span>
<span class="strong"><strong> 2:          7.6         3.0          6.6         2.1 virginica</strong></span>
<span class="strong"><strong> 3:          7.3         2.9          6.3         1.8 virginica</strong></span>
<span class="strong"><strong> 4:          7.2         3.6          6.1         2.5 virginica</strong></span>
<span class="strong"><strong> 5:          7.7         3.8          6.7         2.2 virginica</strong></span>
<span class="strong"><strong> 6:          7.7         2.6          6.9         2.3 virginica</strong></span>
<span class="strong"><strong> 7:          7.7         2.8          6.7         2.0 virginica</strong></span>
<span class="strong"><strong> 8:          7.2         3.2          6.0         1.8 virginica</strong></span>
<span class="strong"><strong> 9:          7.2         3.0          5.8         1.6 virginica</strong></span>
<span class="strong"><strong>10:          7.4         2.8          6.1         1.9 virginica</strong></span>
<span class="strong"><strong>11:          7.9         3.8          6.4         2.0 virginica</strong></span>
<span class="strong"><strong>12:          7.7         3.0          6.1         2.3 virginica</strong></span>
</pre></div><p>To define a new column, we can use the <code class="literal">:=</code> operator in the second square bracket argument. We can access the other columns just by typing their name. For instance, we can define <code class="literal">Sepal.Area</code> as <a id="id104" class="indexterm"/>the product of <code class="literal">Sepal.Length * Sepal.Width</code>:</p><div class="informalexample"><pre class="programlisting">dtIris[, Sepal.Area := Sepal.Length * Sepal.Width]
dtIris[1:6]
<span class="strong"><strong>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Area</strong></span>
<span class="strong"><strong>1:          5.1         3.5          1.4         0.2  setosa      17.85</strong></span>
<span class="strong"><strong>2:          4.9         3.0          1.4         0.2  setosa      14.70</strong></span>
<span class="strong"><strong>3:          4.7         3.2          1.3         0.2  setosa      15.04</strong></span>
<span class="strong"><strong>4:          4.6         3.1          1.5         0.2  setosa      14.26</strong></span>
<span class="strong"><strong>5:          5.0         3.6          1.4         0.2  setosa      18.00</strong></span>
<span class="strong"><strong>6:          5.4         3.9          1.7         0.4  setosa      21.06</strong></span>
</pre></div><p>If we want to compute the average <code class="literal">Sepal.Area</code>, we can perform the operation within the second argument in the <a id="id105" class="indexterm"/>square brackets:</p><div class="informalexample"><pre class="programlisting">dtIris[, mean(Sepal.Area)]
<span class="strong"><strong>[1] 17.82287</strong></span>
</pre></div><p>What if we want to <a id="id106" class="indexterm"/>know the average petal area for each species? The syntax is the same; we include <code class="literal">by = 'Species'</code> in the third argument:</p><div class="informalexample"><pre class="programlisting">dtIris[, mean(Sepal.Area), by = 'Species']
<span class="strong"><strong>      Species      V1</strong></span>
<span class="strong"><strong>1:     setosa 17.2578</strong></span>
<span class="strong"><strong>2: versicolor 16.5262</strong></span>
<span class="strong"><strong>3:  virginica 19.6846</strong></span>
</pre></div><p>We compute more statistics at the same time. For instance, we can determine the maximum and minimum sepal area for each species. In this case, the syntax is similar, with the addition of <code class="literal">list</code> in the second argument:</p><div class="informalexample"><pre class="programlisting">dtIris[
     , list(areaMin = min(Sepal.Area), areaMax = max(Sepal.Area)),
     by = 'Species'
     ]
<span class="strong"><strong>      Species areaMin areaMax</strong></span>
<span class="strong"><strong>1:     setosa   10.35   25.08</strong></span>
<span class="strong"><strong>2: versicolor   10.00   22.40</strong></span>
<span class="strong"><strong>3:  virginic</strong></span>
<span class="strong"><strong>a   12.25   30.02</strong></span>
</pre></div><p>Another useful package is <code class="literal">plyr</code>, and it contains some functions similar to <code class="literal">apply</code> and is applicable in different contexts. Let's first install and load the package:</p><div class="informalexample"><pre class="programlisting">install.packages('plyr')
library('plyr')</pre></div><p>A useful function is <code class="literal">dlply</code>, and it splits a data frame into chunks, applies a function to each chunk, and defines a <a id="id107" class="indexterm"/>list that contains the function output. The types of input are given as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">.data</code>: This is the <a id="id108" class="indexterm"/>data frame.</li><li class="listitem" style="list-style-type: disc"><code class="literal">.variables</code>: This is the <a id="id109" class="indexterm"/>variable that defines the split. Each chunk corresponds to a possible value of the variable.</li><li class="listitem" style="list-style-type: disc"><code class="literal">.fun</code>: This is the <a id="id110" class="indexterm"/>function to apply to each chunk.</li></ul></div><p>For instance, starting from the <code class="literal">iris</code> data frame, we can compute the average sepal length for each species. First, we <a id="id111" class="indexterm"/>can define <code class="literal">funcDl</code> by computing the average sepal length:</p><div class="informalexample"><pre class="programlisting">funcDl &lt;- function(dtChunk){
  result &lt;- mean(dtIris$Sepal.Length)
  return(result)
}</pre></div><p>Now, we can <a id="id112" class="indexterm"/>use <code class="literal">dlply</code> to apply <code class="literal">funcDl</code> to each species:</p><div class="informalexample"><pre class="programlisting">dlply(
  .data = iris,
  .variables = 'Species',
  .fun = funcDl
)
<span class="strong"><strong>$setosa</strong></span>
<span class="strong"><strong>[1] 5.843333</strong></span>

<span class="strong"><strong>$versicolor</strong></span>
<span class="strong"><strong>[1] 5.843333</strong></span>

<span class="strong"><strong>$virginica</strong></span>
<span class="strong"><strong>[1] 5.843333</strong></span>
</pre></div><p>Let's explore the data that is contained in the list:</p><div class="informalexample"><pre class="programlisting">names(listIris)</pre></div><p>Each element of the list has the name of the corresponding species. Let's take a look at one of the elements:</p><div class="informalexample"><pre class="programlisting">listIris$setosa</pre></div><p>The <code class="literal">dlply</code> function <a id="id113" class="indexterm"/>generates a list starting from a data frame, and in the name, <code class="literal">d</code> stands for data frame, and <code class="literal">l</code> stands for list. There are other <code class="literal">ply</code> functions and the options are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">a</code>: Array</li><li class="listitem" style="list-style-type: disc"><code class="literal">d</code>: Data frame</li><li class="listitem" style="list-style-type: disc"><code class="literal">l</code>: List</li></ul></div><p>For instance, <code class="literal">adply</code> defines a data frame starting from an array, and <code class="literal">laply</code> defines an array starting from a list.</p><p>This section introduced two <a id="id114" class="indexterm"/>useful packages. There are more than 5,000 packages in the <a id="id115" class="indexterm"/>CRAN repository, and we will see a few of them in the <a id="id116" class="indexterm"/>following chapters.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Summary</h1></div></div></div><p>In this chapter, you understood the software required to develop a machine learning solution. You saw why R, combined with RStudio, is a good tool to use to help you overcome machine learning challenges.</p><p>You learned about the basics of R and some of the most important data types and functions. You have also seen packages such as <code class="literal">data.table</code> and <code class="literal">plyr</code>.</p><p>The next chapter shows you a simple example of a challenge that can be faced using exploratory data analysis and machine learning. You will see R tools used to build charts and use machine learning algorithms.</p></div></body></html>