["```py\n   // Read input image\n   cv::Mat image= cv::imread(\"binary.bmp\");\n\n   // Erode the image\n   cv::Mat eroded;  // the destination image\n   cv::erode(image,eroded,cv::Mat());\n\n   // Dilate the image\n   cv::Mat dilated;  // the destination image\n   cv::dilate(image,dilated,cv::Mat());\n```", "```py\n   cv::Mat element(7,7,CV_8U,cv::Scalar(1));\n   cv::erode(image,eroded,element);\n```", "```py\n   // Erode the image 3 times.\n   cv::erode(image,eroded,cv::Mat(),cv::Point(-1,-1),3);\n```", "```py\n   cv::erode(image,image,cv::Mat());\n```", "```py\n   cv::Mat element5(5,5,CV_8U,cv::Scalar(1));\n   cv::Mat closed;\n   cv::morphologyEx(image,closed,cv::MORPH_CLOSE,element5);\n```", "```py\n   cv::Mat opened;\n   cv::morphologyEx(image,opened,cv::MORPH_OPEN,element5);\n```", "```py\n   // dilate original image\n   cv::dilate(image,result,cv::Mat());\n   // in-place erosion of the dilated image\n   cv::erode(result,result,cv::Mat()); \n```", "```py\n// Get the gradient image using a 3x3 structuring element\ncv::Mat result;\ncv::morphologyEx(image,result,\n                         cv::MORPH_GRADIENT,cv::Mat());\n\n// Apply threshold to obtain a binary image\nint threshold= 40;\ncv::threshold(result, result, \n                    threshold, 255, cv::THRESH_BINARY);\n```", "```py\nclass MorphoFeatures {\n\n  private:\n\n     // threshold to produce binary image\n    int threshold;\n    // structuring elements used in corner detection\n    cv::Mat_<uchar> cross;\n    cv::Mat_<uchar> diamond;\n    cv::Mat_<uchar> square;\n    cv::Mat_<uchar> x;\n```", "```py\nMorphoFeatures() : threshold(-1), \n      cross(5, 5), diamond(5, 5), square(5, 5), x(5, 5) {\n\n      // Creating the cross-shaped structuring element\n      cross <<\n        0, 0, 1, 0, 0,\n        0, 0, 1, 0, 0,\n        1, 1, 1, 1, 1,\n        0, 0, 1, 0, 0,\n        0, 0, 1, 0, 0;\n      // Similarly creating the other elements\n```", "```py\ncv::Mat getCorners(const cv::Mat &image) {\n\n   cv::Mat result;\n\n   // Dilate with a cross   \n   cv::dilate(image,result,cross);\n\n   // Erode with a diamond\n   cv::erode(result,result,diamond);\n\n   cv::Mat result2;\n   // Dilate with a X   \n   cv::dilate(image,result2,x);\n\n   // Erode with a square\n   cv::erode(result2,result2,square);\n   // Corners are obtained by differencing\n   // the two closed images\n   cv::absdiff(result2,result,result);\n\n   // Apply threshold to obtain a binary image\n   applyThreshold(result);\n\n   return result;\n}\n```", "```py\n// Get the corners\ncv::Mat corners;\ncorners= morpho.getCorners(image);\n\n// Display the corner on the image\nmorpho.drawOnImage(corners,image);\ncv::namedWindow(\"Corners on Image\");\ncv::imshow(\"Corners on Image\",image);\n```", "```py\nclass WatershedSegmenter {\n\n  private:\n\n     cv::Mat markers;\n\n  public:\n\n     void setMarkers(const cv::Mat& markerImage) {\n\n      // Convert to image of ints\n      markerImage.convertTo(markers,CV_32S);\n     }\n\n     cv::Mat process(const cv::Mat &image) {\n\n      // Apply watershed\n      cv::watershed(image,markers);\n\n      return markers;\n     }\n```", "```py\n   // Eliminate noise and smaller objects\n   cv::Mat fg;\n   cv::erode(binary,fg,cv::Mat(),cv::Point(-1,-1),4);\n```", "```py\n   // Identify image pixels without objects\n   cv::Mat bg;\n   cv::dilate(binary,bg,cv::Mat(),cv::Point(-1,-1),4);\n   cv::threshold(bg,bg,1,128,cv::THRESH_BINARY_INV);\n```", "```py\n   // Create markers image\n   cv::Mat markers(binary.size(),CV_8U,cv::Scalar(0));\n   markers= fg+bg;\n```", "```py\n   // Create watershed segmentation object\n   WatershedSegmenter segmenter;\n\n   // Set markers and process\n   segmenter.setMarkers(markers);\n   segmenter.process(image);\n```", "```py\n     // Return result in the form of an image\n     cv::Mat getSegmentation() {\n\n      cv::Mat tmp;\n      // all segment with label higher than 255\n      // will be assigned value 255\n      markers.convertTo(tmp,CV_8U);\n\n      return tmp;\n     }\n```", "```py\n     // Return watershed in the form of an image\n     cv::Mat getWatersheds() {\n\n      cv::Mat tmp;\n      // Each pixel p is transformed into\n      // 255p+255 before conversion\n      markers.convertTo(tmp,CV_8U,255,255);\n\n      return tmp;\n     }\n```", "```py\n// Identify background pixels\ncv::Mat imageMask(image.size(),CV_8U,cv::Scalar(0));\ncv::rectangle(imageMask,cv::Point(5,5),\n     cv::Point(image.cols-5,\n               image.rows-5),cv::Scalar(255),3);\n// Identify foreground pixels \n// (in the middle of the image)\ncv::rectangle(imageMask,\n     cv::Point(image.cols/2-10,image.rows/2-10),\n     cv::Point(image.cols/2+10,image.rows/2+10),\n     cv::Scalar(1),10);\n```", "```py\n// basic MSER detector\ncv::MSER mser(5, // delta value for extremal region detection\n            200, // min acceptable area \n          1500); // max acceptable area\n```", "```py\n  // vector of point sets\n  std::vector<std::vector<cv::Point>> points;\n  // detect MSER features\n  mser(image, points);\n```", "```py\n  // create white image\n  cv::Mat output(image.size(),CV_8UC3);\n  output= cv::Scalar(255,255,255);\n\n  // random number generator\n  cv::RNG rng;\n\n  // for each detected feature\n  for (std::vector<std::vector<cv::Point>>::\n            iterator it= points.begin();\n         it!= points.end(); ++it) {\n\n    // generate a random color\n    cv::Vec3b c(rng.uniform(0,255),\n               rng.uniform(0,255),\n               rng.uniform(0,255));\n\n    // for each point in MSER set\n    for (std::vector<cv::Point>::\n                 iterator itPts= it->begin();\n              itPts!= it->end(); ++itPts) {\n\n      //do not overwrite MSER pixels\n      if (output.at<cv::Vec3b>(*itPts)[0]==255) {\n\n        output.at<cv::Vec3b>(*itPts)= c;\n      }\n    }\n  }\n```", "```py\nclass MSERFeatures {\n\n  private:\n\n    cv::MSER mser;        // mser detector\n    double minAreaRatio;  // extra rejection parameter\n\n  public:\n\n    MSERFeatures(\n           // aceptable size range\n           int minArea=60, int maxArea=14400,\n           // min value for MSER area/bounding-rect area \n           double minAreaRatio=0.5,\n           // delta value used for stability measure \n           int delta=5, \n           // max allowed area variation\n           double maxVariation=0.25, \n           // min size increase between child and parent\n           double minDiversity=0.2):\n           mser(delta,minArea,maxArea,\n           maxVariation,minDiversity), \n           minAreaRatio(minAreaRatio) {}\n```", "```py\n// get the rotated bounding rectangles \n// corresponding to each MSER feature\n// if (mser area / bounding rect area) < areaRatio, \n// the feature is rejected\nvoid getBoundingRects(const cv::Mat &image, \n                      std::vector<cv::RotatedRect> &rects) {\n\n  // detect MSER features\n  std::vector<std::vector<cv::Point>> points;\n  mser(image, points);\n\n  // for each detected feature\n  for (std::vector<std::vector<cv::Point>>::\n            iterator it= points.begin();\n         it!= points.end(); ++it) {\n\n        // Extract bouding rectangles\n        cv::RotatedRect rr= cv::minAreaRect(*it);\n\n        // check area ratio\n        if (it->size() > minAreaRatio*rr.size.area())\n        rects.push_back(rr);\n  }\n}\n```", "```py\n// draw the rotated ellipses corresponding to each MSER\ncv::Mat getImageOfEllipses(const cv::Mat &image,\n            std::vector<cv::RotatedRect> &rects, \n            cv::Scalar color=255) {\n\n  // image on which to draw\n  cv::Mat output= image.clone();\n\n  // get the MSER features\n  getBoundingRects(image, rects);\n\n  // for each detected feature\n  for (std::vector<cv::RotatedRect>::\n            iterator it= rects.begin();\n         it!= rects.end(); ++it) {\n        cv::ellipse(output,*it,color);\n  }\n\n  return output;\n}\n```", "```py\n  // create MSER feature detector instance\n  MSERFeatures mserF(200, // min area \n                    1500, // max area\n                    0.5); // ratio area threshold\n                          // default delta is used\n\n  // the vector of bounding rotated rectangles\n  std::vector<cv::RotatedRect> rects;\n\n  // detect and get the image\n  cv::Mat result= mserF.getImageOfEllipses(image,rects);\n```", "```py\n   // define bounding rectangle\n   // the pixels outside this rectangle\n   // will be labeled as background \n   cv::Rect rectangle(5,70,260,120);\n```", "```py\n   cv::Mat result; // segmentation (4 possible values)\n   cv::Mat bgModel,fgModel; // the models (internally used)\n   // GrabCut segmentation\n   cv::grabCut(image,    // input image\n            result,      // segmentation result\n            rectangle,   // rectangle containing foreground \n            bgModel,fgModel, // models\n            5,           // number of iterations\n            cv::GC_INIT_WITH_RECT); // use rectangle\n```", "```py\n   // Get the pixels marked as likely foreground\n   cv::compare(result,cv::GC_PR_FGD,result,cv::CMP_EQ);\n   // Generate output image\n   cv::Mat foreground(image.size(),CV_8UC3,\n                      cv::Scalar(255,255,255));\n   image.copyTo(foreground,// bg pixels are not copied\n                result);\n```", "```py\n   // checking first bit with bitwise-and\n   result= result&1; // will be 1 if FG \n```", "```py\n   // Generate output image\n   cv::Mat foreground(image.size(),CV_8UC3,\n             cv::Scalar(255,255,255)); // all white image\n   image.copyTo(foreground,result); // bg pixels not copied\n```"]