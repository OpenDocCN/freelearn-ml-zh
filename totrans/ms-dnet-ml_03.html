<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;3.&#xA0;More AdventureWorks Regression"><div class="book" id="RL0A2-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. More AdventureWorks Regression</h1></div></div></div><p class="calibre6">In the last chapter, you had your software developer hat on and you stuck your toe into machine learning waters. You created a simple linear regression and implemented it in your website. The regression attempted to explain how customer reviews affected bike sales quantity to retail shops. In this chapter, we are going to pick up where we left off and use a multiple linear regression to explain bike sales with more precision. Then we will switch over to a logistic regression to see if we can predict whether an individual customer will or will not purchase a bike based on the same factors. We will then consider how to implement the regression in an experiment that will help with the model's accuracy and repeatability. Finally, we will wrap up by considering some of the strengths and weaknesses of regressions.</p></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;More AdventureWorks Regression">
<div class="book" title="Introduction to multiple linear regression"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec22" class="calibre1"/>Introduction to multiple linear regression</h1></div></div></div><p class="calibre6">A multiple linear<a id="id114" class="calibre1"/> regression has the same concept as a simple linear regression, in that we are trying to find the best fit. The major difference is that we have more than one independent variable that is trying to explain the dependent variable. If you remember from the last chapter, we made a regression like this: <span class="strong"><em class="calibre11">Y = x0 + E</em></span>, where <span class="strong"><em class="calibre11">Y</em></span> was bike sales and <span class="strong"><em class="calibre11">x0</em></span> was average ratings.</p><p class="calibre6">If we want to see whether there is a relationship between average rating and price of the bike on bike sales, we can use the formula <span class="strong"><em class="calibre11">Y = x0 + x1 + E</em></span>, where <span class="strong"><em class="calibre11">Y</em></span> is bike sales, <span class="strong"><em class="calibre11">x0</em></span> is the average ratings, and <span class="strong"><em class="calibre11">x1</em></span> is the price of the bike.</p></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;More AdventureWorks Regression">
<div class="book" title="Introduction to multiple linear regression">
<div class="book" title="Intro example"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec25" class="calibre1"/>Intro example</h2></div></div></div><p class="calibre6">Before diving into <a id="id115" class="calibre1"/>actual data, let's dissect a multiple linear regression. Open up Visual Studio and create a new F# library project. Add a script file called <code class="literal">AccordDotNet.fsx</code>. Next, add a NuGet reference to <code class="literal">Accord.Statistics</code>. If you are unfamiliar with how to do any of those tasks, review <a class="calibre1" title="Chapter 1. Welcome to Machine Learning Using the .NET Framework" href="part0015_split_000.html#E9OE1-a18db0be6c20485ba81f22e43ca13055">Chapter 1</a>, <span class="strong"><em class="calibre11">Welcome to Machine Learning Using the .NET Framework</em></span>, and <a class="calibre1" title="Chapter 2. AdventureWorks Regression" href="part0024_split_000.html#MSDG2-a18db0be6c20485ba81f22e43ca13055">Chapter 2</a>, <span class="strong"><em class="calibre11">AdventureWorks Regression</em></span>, where each step is detailed using screenshots.</p><p class="calibre6">At the top of your script, add in the following references:</p><div class="informalexample"><pre class="programlisting">#r "../packages/Accord.3.0.2/lib/net40/Accord.dll"
#r "../packages/Accord.Statistics.3.0.2/lib/net40/Accord.Statistics.dll"
#r "../packages/Accord.Math.3.0.2/lib/net40/Accord.Math.dll"

open Accord
open Accord.Statistics.Models.Regression.Linear</pre></div><p class="calibre6">Next, let's create a dummy dataset. In this case, let's see if there is a relationship between a student's age, their IQ, and their GPA. Since there are two independent variables (<code class="literal">x0</code> and <code class="literal">x1</code>), we will create an input value called, well, <code class="literal">xs</code> and see it with five observations. Since there are two <a id="id116" class="calibre1"/>values for each observation, <code class="literal">xs</code> is a jagged array.</p><div class="informalexample"><pre class="programlisting">let xs = [| [|15.0;130.0|];[|18.0;127.0|];[|15.0;128.0|];[|17.0;120.0|];[|16.0;115.0|] |]</pre></div><p class="calibre6">Sending it to the REPL, we get:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val xs : float [] [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|[|15.0; 130.0|]; [|18.0; 127.0|]; [|15.0; 128.0|]; [|17.0; 120.0|]; [|16.0; 115.0|]|]</strong></span>
</pre></div><p class="calibre6">In this dataset, the first observation is a 15 year old with a 130 IQ, the second is an 18 year old with a 127 IQ, and so on. With the inputs taken care of, let's create the <code class="literal">y</code>, which is the student's GPA:</p><div class="informalexample"><pre class="programlisting">let y = [|3.6;3.5;3.8;3.4;2.6|]</pre></div><p class="calibre6">Sending to the REPL, we get:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val y : float [] = [|3.6; 3.5; 3.8; 3.4; 2.6|]</strong></span>
</pre></div><p class="calibre6">The first student has a 3.6 GPA, the second has a 3.5, and so on. Notice that since our output is a single number, we only need a simple array to hold the values. With our inputs taken care of, let's create a multiple linear regression with our <code class="literal">xs</code> and <code class="literal">y</code>:</p><div class="informalexample"><pre class="programlisting">let regression = MultipleLinearRegression(2, true)
let error = regression.Regress(xs, y)

let a = regression.Coefficients.[0]
let b = regression.Coefficients.[1]
let c = regression.Coefficients.[2]</pre></div><p class="calibre6">Sending this to the REPL, we get:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val regression : MultipleLinearRegression =</strong></span>

<span class="strong"><strong class="calibre7">  y(x0, x1) = 0.0221298495645295*x0 + 0.0663103721298495*x1 + -5.20098970704672</strong></span>
<span class="strong"><strong class="calibre7">val error : float = 0.1734125099</strong></span>
<span class="strong"><strong class="calibre7">val a : float = 0.02212984956</strong></span>
<span class="strong"><strong class="calibre7">val b : float = 0.06631037213</strong></span>
<span class="strong"><strong class="calibre7">val c : float = -5.200989707</strong></span>
</pre></div><p class="calibre6">There are a couple of things to notice. First, Accord printed the formula of our multiple linear regression for us as <code class="literal">y(x0, x1) = 0.0221298495645295*x0 + 0.0663103721298495*x1 + -5.20098970704672</code>. The key thing to notice is that you cannot interpret the results of multiple regressions the same as the simple regression, for example, summing <code class="literal">x1</code> and <code class="literal">x2</code> together to be the slope of a line would be incorrect. Rather, each <code class="literal">x</code> is the slope of the line if the other <code class="literal">x</code> is held constant. So, in this case, if <code class="literal">x1</code> is held constant, each change of one unit of <code class="literal">x0</code> changes <code class="literal">y</code> <code class="literal">.022</code>. Back to our example, we can say that if we increase<a id="id117" class="calibre1"/> a person's age by one year, a person's GPA increases by .022, holding the IQ constant. Similarly, we can say that for every one point drop in a person's IQ, the person's GPA drops 0.066, holding the person's age constant. We can't use a scatterplot to show all of the results of a multiple regression the way we can with a simple regression because you would need an axis for each <code class="literal">x</code> value and that quickly will get unwieldy, if not impossible.</p><p class="calibre6">Next, let's see how good our regression is using our old friends <code class="literal">r2</code> and <code class="literal">rmse</code>:</p><div class="informalexample"><pre class="programlisting">let sse = regression.Regress(xs, y)
let mse = sse/float xs.Length 
let rmse = sqrt(mse)
let r2 = regression.CoefficientOfDetermination(xs,y)</pre></div><p class="calibre6">Sending this to the REPL, we get:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val sse : float = 0.1734125099</strong></span>
<span class="strong"><strong class="calibre7">val mse : float = 0.03468250198</strong></span>
<span class="strong"><strong class="calibre7">val rmse : float = 0.186232387</strong></span>
<span class="strong"><strong class="calibre7">val r2 : float = 0.7955041157</strong></span>
</pre></div><p class="calibre6">Notice that <code class="literal">sse</code> is the same as the error from above. Accord.NET returns <code class="literal">sse</code> as an error, so I will just use that in the future. Also, looking at our result, we can see that we have an <code class="literal">r2</code> of <code class="literal">.79</code>, which is pretty good and that our <code class="literal">rmse</code> is <code class="literal">.18</code>, which is also low enough that the regression is a viable one.</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;More AdventureWorks Regression">
<div class="book" title="Introduction to multiple linear regression">
<div class="book" title="Keep adding x variables?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec26" class="calibre1"/>Keep adding x variables?</h2></div></div></div><p class="calibre6">If two <code class="literal">x</code> variables are<a id="id118" class="calibre1"/> good, are three better? Let's take a<a id="id119" class="calibre1"/> look. Let's add another variable, in this case, the student's prior year GPA as a third <code class="literal">x</code> value. Go back to the REPL and add this:</p><div class="informalexample"><pre class="programlisting">let xs' = [| [|15.0;130.0;3.6|];[|18.0;127.0;3.5|];
            [|15.0;128.0;3.7|];[|17.0;120.0;3.5|];
            [|17.0;120.0;2.5|] |]

let regression' = MultipleLinearRegression(3,true)
let error' = regression'.Regress(xs',y)

let a' = regression'.Coefficients.[0]
let b' = regression'.Coefficients.[1]
let c' = regression'.Coefficients.[2]
let d' = regression'.Coefficients.[3]

let mse' = error'/float xs'.Length 
let rmse' = sqrt(mse')
let r2' = regression'.CoefficientOfDetermination(xs',y)</pre></div><p class="calibre6">Sending this to the REPL, we get:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val xs' : float [] [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|[|15.0; 130.0; 3.6|]; [|18.0; 127.0; 3.5|]; [|15.0; 128.0; 3.7|];</strong></span>
<span class="strong"><strong class="calibre7">    [|17.0; 120.0; 3.5|]; [|17.0; 120.0; 2.5|]|]</strong></span>
<span class="strong"><strong class="calibre7">val regression' : MultipleLinearRegression =</strong></span>
<span class="strong"><strong class="calibre7">  y(x0, x1, x2) = -0.0202088664499619*x0 + 0.0116951379763468*x1 + 0.834082578324918*x2 + -0.552984300435694</strong></span>
<span class="strong"><strong class="calibre7">val error' : float = 0.01071166747</strong></span>
<span class="strong"><strong class="calibre7">val a' : float = -0.02020886645</strong></span>
<span class="strong"><strong class="calibre7">val b' : float = 0.01169513798</strong></span>
<span class="strong"><strong class="calibre7">val c' : float = 0.8340825783</strong></span>
<span class="strong"><strong class="calibre7">val d' : float = -0.5529843004</strong></span>
<span class="strong"><strong class="calibre7">val mse' : float = 0.002142333495</strong></span>
<span class="strong"><strong class="calibre7">val rmse' : float = 0.0462853486</strong></span>
<span class="strong"><strong class="calibre7">val r2' : float = 0.9873683167</strong></span>
</pre></div><p class="calibre6">So the <code class="literal">r2</code> is now up to 99%, which means we can explain 99% of the change in a person's GPA using their<a id="id120" class="calibre1"/> age, IQ, and prior year GPA. Also, note<a id="id121" class="calibre1"/> that the <code class="literal">rmse</code> is <code class="literal">.04</code>, which is nice and low. We have a pretty good model.</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;More AdventureWorks Regression">
<div class="book" title="Introduction to multiple linear regression">
<div class="book" title="AdventureWorks data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec27" class="calibre1"/>AdventureWorks data</h2></div></div></div><p class="calibre6">With the demo<a id="id122" class="calibre1"/> out of the way, let's implement a multiple linear regression back at the bike company. Since we are <a id="id123" class="calibre1"/>using more realistic data, I don't think we will get a 99% <code class="literal">r2</code>, but we can hope. In your <span class="strong"><strong class="calibre7">Solution Explorer</strong></span>, add another F# script called <code class="literal">AccordDotNet2.fsx</code>. Then, add a reference to <code class="literal">System.Transactions</code> so that we can use ADO.NET to access our data. Go back to <code class="literal">AccordDotNet2.fsx</code> and<a id="id124" class="calibre1"/> add the following<a id="id125" class="calibre1"/> code:</p><div class="informalexample"><pre class="programlisting">#r "System.Transactions.dll"
#r "../packages/Accord.3.0.2/lib/net40/Accord.dll"
#r "../packages/Accord.Statistics.3.0.2/lib/net40/Accord.Statistics.dll"
#r "../packages/Accord.Math.3.0.2/lib/net40/Accord.Math.dll"

open Accord
open Accord.Statistics
open Accord.Statistics.Models.Regression.Linear

open System
open System.Data.SqlClient

type ProductInfo = {ProductID:int; AvgOrders:float; AvgReviews: float; ListPrice: float}

let productInfos =  ResizeArray&lt;ProductInfo&gt;()

[&lt;Literal&gt;]
let connectionString = "data source=nc54a9m5kk.database.windows.net;initial catalog=AdventureWorks2014;user id=chickenskills@nc54a9m5kk;password=sk1lzm@tter;"

[&lt;Literal&gt;]
let query = "Select 
            A.ProductID, AvgOrders, AvgReviews, ListPrice
            From
            (Select 
            ProductID,
            (Sum(OrderQty) + 0.0)/(Count(Distinct SOH.CustomerID) + 0.0) as AvgOrders
            from [Sales].[SalesOrderDetail] as SOD
            inner join [Sales].[SalesOrderHeader] as SOH
            on SOD.SalesOrderID = SOH.SalesOrderID
            inner join [Sales].[Customer] as C
            on SOH.CustomerID = C.CustomerID
            Where C.StoreID is not null
            Group By ProductID) as A
            Inner Join 
            (Select
            ProductID,
            (Sum(Rating) + 0.0) / (Count(ProductID) + 0.0) as AvgReviews
            from [Production].[ProductReview] as PR
            Group By ProductID) as B
            on A.ProductID = B.ProductID
            Inner Join
            (Select
            ProductID,
            ListPrice
            from [Production].[Product]
            ) as C
            On A.ProductID = C.ProductID"
            
let connection = new SqlConnection(connectionString)
let command = new SqlCommand(query,connection)
connection.Open()
let reader = command.ExecuteReader()
while reader.Read() do
    productInfos.Add({ProductID=reader.GetInt32(0);
                        AvgOrders=(float)(reader.GetDecimal(1));
                        AvgReviews=(float)(reader.GetDecimal(2));
                        ListPrice=(float)(reader.GetDecimal(3));})</pre></div><p class="calibre6">Notice that this is very similar to the code that you wrote in the prior chapter. In fact, you might want to<a id="id126" class="calibre1"/> copy and paste that code<a id="id127" class="calibre1"/> and make the following changes:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Add a <code class="literal">ListPrice</code> field to the <code class="literal">ProductInfo</code> record type.</li><li class="listitem" value="2">Update the query to add a clause to pull down the list price of the bike.</li><li class="listitem" value="3">Update <code class="literal">productInfos</code>. Add a method to include the third value we are bringing down.</li></ol><div class="calibre13"/></div><p class="calibre6">The code itself shapes a data frame of a number of orders, average reviews, and average price by <code class="literal">productId</code> in SQL and brings it local. Sending this code to the REPL, we get the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">type ProductInfo =</strong></span>
<span class="strong"><strong class="calibre7">  {ProductID: int;</strong></span>
<span class="strong"><strong class="calibre7">   AvgOrders: float;</strong></span>
<span class="strong"><strong class="calibre7">   AvgReviews: float;</strong></span>
<span class="strong"><strong class="calibre7">   ListPrice: float;}</strong></span>
<span class="strong"><strong class="calibre7">val productInfos : Collections.Generic.List&lt;ProductInfo&gt;</strong></span>
<span class="strong"><strong class="calibre7">val connectionString : string =</strong></span>
<span class="strong"><strong class="calibre7">  "data source=nc54a9m5kk.database.windows.net;initial catalog=A"+[72 chars]</strong></span>
<span class="strong"><strong class="calibre7">val query : string =</strong></span>
<span class="strong"><strong class="calibre7">  "Select </strong></span>
<span class="strong"><strong class="calibre7">            A.ProductID, AvgOrders, AvgReviews, ListP"+[937 chars]</strong></span>
<span class="strong"><strong class="calibre7">val connection : SqlConnection = System.Data.SqlClient.SqlConnection</strong></span>
<span class="strong"><strong class="calibre7">val command : SqlCommand = System.Data.SqlClient.SqlCommand</strong></span>
<span class="strong"><strong class="calibre7">val reader : SqlDataReader</strong></span>
<span class="strong"><strong class="calibre7">val it : unit = ()</strong></span>
</pre></div><p class="calibre6">With the data down, let's <a id="id128" class="calibre1"/>create a multiple linear regression. Add the following code to the script file:</p><div class="informalexample"><pre class="programlisting">let xs = 
    productInfos 
    |&gt; Seq.map (fun pi -&gt; [|pi.AvgReviews; pi.ListPrice|]) 
    |&gt; Seq.toArray
let y = 
    productInfos 
    |&gt; Seq.map (fun pi -&gt; pi.AvgOrders) 
    |&gt; Seq.toArray
let regression = MultipleLinearRegression(2, true)
let error = regression.Regress(xs, y)

let a = regression.Coefficients.[0]
let b = regression.Coefficients.[1]
let c = regression.Coefficients.[2]

let mse = error/float xs.Length 
let rmse = sqrt mse
let r2 = regression.CoefficientOfDetermination(xs, y)</pre></div><p class="calibre6">Sending this <a id="id129" class="calibre1"/>code to the REPL, we get:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val regression : MultipleLinearRegression =</strong></span>
<span class="strong"><strong class="calibre7">  y(x0, x1) = 9.68314848116308*x0 + -0.000913619922709572*x1 + -26.1836956342657</strong></span>
<span class="strong"><strong class="calibre7">val error : float = 682.6439378</strong></span>
<span class="strong"><strong class="calibre7">val a : float = 9.683148481</strong></span>
<span class="strong"><strong class="calibre7">val b : float = -0.0009136199227</strong></span>
<span class="strong"><strong class="calibre7">val c : float = -26.18369563</strong></span>
<span class="strong"><strong class="calibre7">val mse : float = 7.037566369</strong></span>
<span class="strong"><strong class="calibre7">val rmse : float = 2.652841188</strong></span>
<span class="strong"><strong class="calibre7">val r2 : float = 0.3532529168</strong></span>
</pre></div><p class="calibre6">By adding the price of the bike, our <code class="literal">r2</code> moves from <code class="literal">.29</code> to <code class="literal">.35</code>. Also, our <code class="literal">rmse</code> moves from <code class="literal">2.77</code> to <code class="literal">2.65</code>. This change means we have a more accurate model with a smaller amount of error. Because this is better, let's add this to our production application.</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;More AdventureWorks Regression">
<div class="book" title="Introduction to multiple linear regression">
<div class="book" title="Adding multiple regression to our production application"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch03lvl2sec28" class="calibre1"/>Adding multiple regression to our production application</h2></div></div></div><p class="calibre6">Open up the<a id="id130" class="calibre1"/> <code class="literal">AdventureWorks</code> solution that you started working on in the last chapter. In the <span class="strong"><strong class="calibre7">Solution Explorer</strong></span>, navigate to<a id="id131" class="calibre1"/> the <code class="literal">AdventureWorks.MachineLearning</code> project and open <code class="literal">OrderPrediction.fs</code>.</p><p class="calibre6">Locate the <code class="literal">ProductReview</code> type and replace it with this:</p><div class="informalexample"><pre class="programlisting">type ProductInfo = {ProductID:int; AvgOrders:float; AvgReviews: float; ListPrice: float}</pre></div><p class="calibre6">Next, go into the <code class="literal">OrderPrediction</code> type and find the line where the reviews value is assigned and replace it with this:</p><div class="informalexample"><pre class="programlisting">let productInfos = ResizeArray&lt;ProductInfo&gt;()</pre></div><p class="calibre6">Next, locate the query value and replace its contents with this:</p><div class="informalexample"><pre class="programlisting">[&lt;Literal&gt;]
let query = "Select 
            A.ProductID, AvgOrders, AvgReviews, ListPrice
            From
            (Select 
            ProductID,
            (Sum(OrderQty) + 0.0)/(Count(Distinct SOH.CustomerID) + 0.0) as AvgOrders,
            Sum(OrderQty) as TotalOrders
            from [Sales].[SalesOrderDetail] as SOD
            inner join [Sales].[SalesOrderHeader] as SOH
            on SOD.SalesOrderID = SOH.SalesOrderID
            inner join [Sales].[Customer] as C
            on SOH.CustomerID = C.CustomerID
            Where C.StoreID is not null
            Group By ProductID) as A
            Inner Join 
            (Select
            ProductID,
            (Sum(Rating) + 0.0) / (Count(ProductID) + 0.0) as AvgReviews
            from [Production].[ProductReview] as PR
            Group By ProductID) as B
            on A.ProductID = B.ProductID
            Inner Join
            (Select
            ProductID,
            ListPrice
            from [Production].[Product]
            ) as C
            On A.ProductID = C.ProductID"</pre></div><p class="calibre6">Next, scroll down to the <code class="literal">PredictQuantity</code> function and locate the <code class="literal">reader.Read()</code> line of codes. Replace it with this:</p><div class="informalexample"><pre class="programlisting">        while reader.Read() do
            productInfos.Add({ProductID=reader.GetInt32(0);
                                AvgOrders=(float)(reader.GetDecimal(1));
                                AvgReviews=(float)(reader.GetDecimal(2));
                                ListPrice=(float)(reader.GetDecimal(3));})</pre></div><p class="calibre6">Finally, remove all of<a id="id132" class="calibre1"/> the remaining code in the <code class="literal">PredictQuantity</code> function starting with:</p><div class="informalexample"><pre class="programlisting">let x = reviews |&gt; Seq.map(fun pr -&gt; pr.AvgReviews) |&gt; Seq.toArray</pre></div><p class="calibre6">Replace it <a id="id133" class="calibre1"/>with this:</p><div class="informalexample"><pre class="programlisting">        let xs = 
            productInfos 
            |&gt; Seq.map (fun pi -&gt; [|pi.AvgReviews; pi.ListPrice|]) 
            |&gt; Seq.toArray
        let y = 
            productInfos 
            |&gt; Seq.map (fun pi -&gt; pi.AvgOrders) 
            |&gt; Seq.toArray
        let regression = MultipleLinearRegression(2, true)
        let error = regression.Regress(xs, y)

        let a = regression.Coefficients.[0]
        let b = regression.Coefficients.[1]
        let c = regression.Coefficients.[2]

        let mse = error/float xs.Length 
        let rmse = sqrt mse
        let r2 = regression.CoefficientOfDetermination(xs, y)

        let productInfo = 
            productInfos 
            |&gt; Seq.find (fun r -&gt; r.ProductID = productId)
        let xs' = [|[|productInfo.AvgReviews; productInfo.ListPrice|]|]
        regression.Compute(xs') |&gt; Seq.head</pre></div><p class="calibre6">Notice we have to create a jagged array even though we are only entering in one <code class="literal">productInfo</code> for the final <code class="literal">regression.Compute()</code>. Also, notice that the <code class="literal">Compute</code> function returns an array, but since we are only entering in one value, the resulting array will always have a length of one. We used the <code class="literal">Seq.head</code> to pull the first value of the array. The head function comes in quite handy at certain times and we will be seeing it again in this <a id="id134" class="calibre1"/>book.</p><p class="calibre6">Build the project and <a id="id135" class="calibre1"/>open up the UI; you can see that our prediction has been adjusted:</p><div class="mediaobject"><img src="../images/00053.jpeg" alt="Adding multiple regression to our production application" class="calibre8"/></div><p class="calibre9"> </p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;More AdventureWorks Regression">
<div class="book" title="Introduction to multiple linear regression">
<div class="book" title="Considerations when using multiple x variables"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch03lvl2sec29" class="calibre1"/>Considerations when using multiple x variables</h2></div></div></div><p class="calibre6">At this point, you might be thinking, "This is great! I can keep adding more and more variables to my<a id="id136" class="calibre1"/> multiple linear regression and I will get a better and better <code class="literal">r2</code> and a lower <code class="literal">rmse</code>." As Lee Corso might say, "Not so fast!" Without getting too far into the details, every time you add a new feature of a linear multiple regression, you will always get a better result, or, at least, not a worse result. This means, if you add in the average temperature from different cities on June 29, 1999, the model might improve. Also, as you increase the number of features, the chance of introducing unwanted side effects into your model increases; we will talk about that in a little bit. In fact, I have seen some models where the number of features outnumber the number of observations. As a rule, this is a not a good idea.</p><p class="calibre6">To combat feature growth, you can take two approaches. First, you can combine common sense with Occam's Razor. Occam's Razor is the notion that given a choice of possible solutions, the simplest one should always be chosen. This combination of sense and simplicity is <a id="id137" class="calibre1"/>more common and powerful than most people realize. The gray matter between the ears is a pretty powerful computer in its own right and can do a good job of seeing patterns and making relationships.</p><p class="calibre6">Indeed, the business analyst who has spent time in the domain might know of relationships that are not apparent to an external data scientist looking at a laundry list of features or a basic machine learning model that is thrown at the data. Granted, humans do have biases and sometimes miss relationships, but on the whole, they are still good at matching patterns. Applying Occam's Razor to feature selection means that you are trying to find the fewest number of features that has the greatest impact on the model's predictability.</p><p class="calibre6">Let's head over to our friendly business analyst at AdventureWorks and ask him what he thinks influences the quantity of bicycles purchased by our resellers. He says, "Well, I think that price and customer reviews are certainly very important, but I think that the weight of the bike influences our resellers. The heavier the bike, the less likely they are to order some."</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;More AdventureWorks Regression">
<div class="book" title="Introduction to multiple linear regression">
<div class="book" title="Adding a third x variable to our model"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch03lvl2sec30" class="calibre1"/>Adding a third x variable to our model</h2></div></div></div><p class="calibre6">With the business<a id="id138" class="calibre1"/> analyst's idea in mind, let's add a third independent variable to our model, bike weight. Go back to the <span class="strong"><strong class="calibre7">Solution Explorer</strong></span> and add another script file. Add the following code to the script:</p><div class="informalexample"><pre class="programlisting">#r "System.Transactions.dll"
#r "../packages/Accord.3.0.2/lib/net40/Accord.dll"
#r "../packages/Accord.Statistics.3.0.2/lib/net40/Accord.Statistics.dll"
#r "../packages/Accord.Math.3.0.2/lib/net40/Accord.Math.dll"

open Accord
open Accord.Statistics
open Accord.Statistics.Models.Regression.Linear

open System
open System.Data.SqlClient

type ProductInfo = {ProductID:int; AvgOrders:float; AvgReviews: float; ListPrice: float; Weight: float}

let productInfos = ResizeArray&lt;ProductInfo&gt;()

[&lt;Literal&gt;]
let connectionString = "data source=nc54a9m5kk.database.windows.net;initial catalog=AdventureWorks2014;user id=chickenskills@nc54a9m5kk;password=sk1lzm@tter;"

[&lt;Literal&gt;]
let query = "Select 
            A.ProductID, AvgOrders, AvgReviews, ListPrice, Weight
            From
            (Select 
            ProductID,
            (Sum(OrderQty) + 0.0)/(Count(Distinct SOH.CustomerID) + 0.0) as AvgOrders
            from [Sales].[SalesOrderDetail] as SOD
            inner join [Sales].[SalesOrderHeader] as SOH
            on SOD.SalesOrderID = SOH.SalesOrderID
            inner join [Sales].[Customer] as C
            on SOH.CustomerID = C.CustomerID
            Where C.StoreID is not null
            Group By ProductID) as A
            Inner Join 
            (Select
            ProductID,
            (Sum(Rating) + 0.0) / (Count(ProductID) + 0.0) as AvgReviews
            from [Production].[ProductReview] as PR
            Group By ProductID) as B
            on A.ProductID = B.ProductID
            Inner Join
            (Select
            ProductID,
            ListPrice,
            Weight
            from [Production].[Product]
            ) as C
            On A.ProductID = C.ProductID"
            
let connection = new SqlConnection(connectionString)
let command = new SqlCommand(query, connection)
connection.Open()
let reader = command.ExecuteReader()
while reader.Read() do
    productInfos.Add({ProductID=reader.GetInt32(0);
                        AvgOrders=(float)(reader.GetDecimal(1));
                        AvgReviews=(float)(reader.GetDecimal(2));
                        ListPrice=(float)(reader.GetDecimal(3));
                        Weight=(float)(reader.GetDecimal(4));})

let xs = 
    productInfos 
    |&gt; Seq.map (fun pi -&gt; [|pi.AvgReviews; pi.ListPrice; pi.Weight|]) 
    |&gt; Seq.toArray
let y = 
    productInfos 
    |&gt; Seq.map (fun pi -&gt; pi.AvgOrders) 
    |&gt; Seq.toArray
let regression = MultipleLinearRegression(3, true)
let error = regression.Regress(xs, y)

let a = regression.Coefficients.[0]
let b = regression.Coefficients.[1]
let c = regression.Coefficients.[2]
let d = regression.Coefficients.[3]

let mse = error/float xs.Length 
let rmse = sqrt mse
let r2 = regression.CoefficientOfDetermination(xs, y)</pre></div><p class="calibre6">Sending this to the REPL, notice that our <code class="literal">r2</code> goes to <code class="literal">.36</code> and our <code class="literal">rmse</code> drops to <code class="literal">2.63</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val regression : MultipleLinearRegression =</strong></span>
<span class="strong"><strong class="calibre7">  y(x0, x1, x2) = 8.94836007927991*x0 + -0.00103754084861455*x1 + -0.0848953592695415*x2 + -21.2973971475571</strong></span>
<span class="strong"><strong class="calibre7">val error : float = 671.2299241</strong></span>
<span class="strong"><strong class="calibre7">val a : float = 8.948360079</strong></span>
<span class="strong"><strong class="calibre7">val b : float = -0.001037540849</strong></span>
<span class="strong"><strong class="calibre7">val c : float = -0.08489535927</strong></span>
<span class="strong"><strong class="calibre7">val d : float = -21.29739715</strong></span>
<span class="strong"><strong class="calibre7">val mse : float = 6.919896125</strong></span>
<span class="strong"><strong class="calibre7">val rmse : float = 2.630569544</strong></span>
<span class="strong"><strong class="calibre7">val r2 : float = 0.3640667242</strong></span>
</pre></div><p class="calibre6">Our analyst's intuition about price and customer reviews was spot on, the weight…not so much. Using Occam's Razor, we can use price and customer reviews for our model and ignore the weight variable.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Logistic regression"><div class="book" id="SJGS2-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec23" class="calibre1"/>Logistic regression</h1></div></div></div><p class="calibre6">Now that we are becoming more comfortable with regressions, let's introduce another type of regression—the logistic regression. Up to this point, the regressions have had a numeric output value—like predicting a person's GPA or predicting the number of bikes sold. Logistic regressions use the same technique of fitting a group of independent features to a line, but they do not attempt to predict a number. Rather, a logistic regression attempts to predict a binary value (yes/no, true/false, tastes great/less filling) and then assigns a probability to that value.</p></div>

<div class="book" title="Logistic regression">
<div class="book" title="Intro to logistic regression"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec31" class="calibre1"/>Intro to logistic regression</h2></div></div></div><p class="calibre6">Since you have already had an introduction to regressions, we can skip straight to the code and see one in action. Open up the regression project and add a script called <code class="literal">AccordDotNet7.fsx</code>. Copy in the following lines of code:</p><div class="informalexample"><pre class="programlisting">#r "../packages/Accord.3.0.2/lib/net40/Accord.dll"
#r "../packages/Accord.Statistics.3.0.2/lib/net40/Accord.Statistics.dll"
#r "../packages/Accord.Math.3.0.2/lib/net40/Accord.Math.dll"

open Accord
open Accord.Statistics.Analysis
open Accord.Statistics.Models.Regression
open Accord.Statistics.Models.Regression.Fitting

let xs = [| [|0.5|];[|0.75|];
            [|1.0|];[|1.25|];[|1.5|];[|1.75|];[|1.75|];
            [|2.0|];[|2.25|];[|2.5|];[|2.75|];
            [|3.0|];[|3.25|];[|3.5|];
            [|4.0|];[|4.25|];[|4.5|];[|4.75|];
            [|5.0|];[|5.5|];|]

let y = [|0.0;0.0;0.0;0.0;0.0;0.0;1.0;0.0;1.0;0.0;
          1.0;0.0;1.0;0.0;1.0;1.0;1.0;1.0;1.0;1.0|]</pre></div><p class="calibre6">Sending this to the REPL gives us:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val xs : float [] [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|[|0.5|]; [|0.75|]; [|1.0|]; [|1.25|]; [|1.5|]; [|1.75|]; [|1.75|]; [|2.0|];</strong></span>
<span class="strong"><strong class="calibre7">    [|2.25|]; [|2.5|]; [|2.75|]; [|3.0|]; [|3.25|]; [|3.5|]; [|4.0|]; [|4.25|];</strong></span>
<span class="strong"><strong class="calibre7">    [|4.5|]; [|4.75|]; [|5.0|]; [|5.5|]|]</strong></span>
<span class="strong"><strong class="calibre7">val y : float [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 1.0; 0.0; 1.0; 0.0; 1.0; 0.0; 1.0; 0.0; 1.0;</strong></span>
<span class="strong"><strong class="calibre7">    1.0; 1.0; 1.0; 1.0; 1.0|]</strong></span>
</pre></div><p class="calibre6">I pulled this dataset from Wikipedia and it represents 20 students, how many hours of studying they did the day before an exam, and whether they passed the exam represented as <code class="literal">0.0</code> for failure and <code class="literal">1.0</code> for pass. Looking at the <code class="literal">xs</code>, student 0 studied 0.5 hours and looking at the <code class="literal">y</code>, we can see that s/he did not pass the exam.</p><p class="calibre6">Next, let's create our regression analysis and look at some results:</p><div class="informalexample"><pre class="programlisting">let analysis = new LogisticRegressionAnalysis(xs, y)
analysis.Compute() |&gt; ignore
let pValue = analysis.ChiSquare.PValue
let coefficientOdds = analysis.Regression.GetOddsRatio(0)
let hoursOfStudyingOdds = analysis.Regression.GetOddsRatio(1)
let coefficients = analysis.CoefficientValues</pre></div><p class="calibre6">Sending this to the REPL gives this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val analysis : LogisticRegressionAnalysis</strong></span>
<span class="strong"><strong class="calibre7">val pValue : float = 0.0006364826185</strong></span>
<span class="strong"><strong class="calibre7">val coefficientOdds : float = 0.01694617045</strong></span>
<span class="strong"><strong class="calibre7">val hoursOfStudyingOdds : float = 4.502556825</strong></span>
<span class="strong"><strong class="calibre7">val coefficients : float [] = [|-4.077713403; 1.504645419|]</strong></span>
</pre></div><p class="calibre6">There are plenty of new things going on here, so let's take a look at them in turn. After we create an analysis, we compute the regression. The next item is <code class="literal">pValue</code>. <code class="literal">pValue</code> is a common measure of accuracy for logistic regressions. As we saw earlier, linear regressions typically use <code class="literal">rmse</code> and <code class="literal">r2</code> as a way to measure model accuracy. Logistic regressions can use those measures, but usually don't. Unlike the linear regression where the model spits out an exact number using something called <span class="strong"><em class="calibre11">least-squares</em></span>, the logistic regression uses something called <span class="strong"><em class="calibre11">maximum-likelihood</em></span> where the regression iterates and tries different combinations of the input values to maximize the likelihood of the result. Therefore, the logistic regression needs to be run many times over the dataset and we can configure how precise we want the model to be. Graphically, it looks like this:</p><div class="mediaobject"><img src="../images/00054.jpeg" alt="Intro to logistic regression" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Coming back to <code class="literal">pValue</code>, it is a measure of how well our model compares to the <code class="literal">null</code> hypothesis, or basically, how well our model compares to a completely random model. If the <code class="literal">pValue</code> is less than 0.05, our model is valid. If the number is above 0.05, the model is no better than a random one. You might be asking yourself, "What is so special about 0.05?" The exact <a id="id139" class="calibre1"/>answer resides in some low-level mathematical functions that are beyond the scope of this book. The rough answer is, well, that is what everyone uses so that is what Accord baked in. If you don't find that explanation satisfactory, take a look <a id="id140" class="calibre1"/>at this post on Wikipedia (<a class="calibre1" href="https://en.wikipedia.org/wiki/P-value">https://en.wikipedia.org/wiki/P-value</a>). In any event, the 0.0006 is very good.</p><p class="calibre6">Moving on to the next values, we see <code class="literal">GetOddsRatio</code> results:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val coefficientOdds : float = 0.01694617045</strong></span>
<span class="strong"><strong class="calibre7">val hoursOfStudyingOdds : float = 4.502556825</strong></span>
</pre></div><p class="calibre6">What this means is that if we didn't study at all, we would have 1.6% chance of passing the exam. If we want to pass the exam, we need to study 4.5 hours. Next, take a look at the coefficients:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val coefficients : float [] = [|-4.077713403; 1.504645419|]</strong></span>
</pre></div><p class="calibre6">Accord.NET passes back an array for the coefficients, with the first value being the intercept. With these, you can create a formula to predict if a student can pass the exam given any input of hours of studying. For example, here are the predictions from our base dataset:</p><div class="mediaobject"><img src="../images/00055.jpeg" alt="Intro to logistic regression" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">If we want to start playing with beer and hours of studying combinations (for example, "Will I pass if I study for 4.5 hours?"), we can do that using the <code class="literal">Compute</code> function. At the bottom of the script file, enter in:</p><div class="informalexample"><pre class="programlisting">let result = analysis.Regression.Compute([|3.75|])</pre></div><p class="calibre6">Send it to the<a id="id141" class="calibre1"/> REPL for this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val result : float = 0.8270277278</strong></span>
</pre></div><p class="calibre6">So you have an 82% chance of passing if you study for 3.75 hours.</p></div></div>

<div class="book" title="Logistic regression">
<div class="book" title="Adding another x variable"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec32" class="calibre1"/>Adding another x variable</h2></div></div></div><p class="calibre6">Next, let's add in <a id="id142" class="calibre1"/>another variable to our model—the number of beers you drank the night before the exam. Go back to your script file and add this to the bottom:</p><div class="informalexample"><pre class="programlisting">let xs' = [| [|0.5;2.5|];
   [|0.75;1.5|];
            [|1.0;4.0|];
  [|1.25;1.0|];
  [|1.5;0.0|];
  [|1.75;3.0|];
  [|1.75;0.0|];
            [|2.0;3.0|];
            [|2.25;1.0|];
            [|2.5;4.5|];
            [|2.75;1.5|];
            [|3.0;1.0|];
            [|3.25;2.5|];
            [|3.5;0.0|];
            [|4.0;2.0|];
            [|4.25;1.5|];
            [|4.5;4.5|];
            [|4.75;0.0|];
            [|5.0;1.0|];
            [|5.5;0.0|];|]

let analysis' = new LogisticRegressionAnalysis(xs', y)
analysis'.Compute() |&gt; ignore
let pValue' = analysis'.ChiSquare.PValue
let coefficientOdds' = analysis'.Regression.GetOddsRatio(0)
let hoursOfStudyingOdds' = analysis'.Regression.GetOddsRatio(1)
let numberOfBeersDrankOdds' = analysis'.Regression.GetOddsRatio(2)
let coefficients' = analysis'.CoefficientValues</pre></div><p class="calibre6">Sending this to the REPL, we see:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val analysis' : LogisticRegressionAnalysis</strong></span>
<span class="strong"><strong class="calibre7">val pValue' : float = 0.002336631577</strong></span>
<span class="strong"><strong class="calibre7">val coefficientOdds' : float = 0.02748131566</strong></span>
<span class="strong"><strong class="calibre7">val hoursOfStudyingOdds' : float = 4.595591714</strong></span>
<span class="strong"><strong class="calibre7">val numberOfBeersDrankOdds' : float = 0.7409200941</strong></span>
<span class="strong"><strong class="calibre7">val coefficients' : float [] = [|-3.594248936; 1.525097521; -0.2998624947|]</strong></span>
</pre></div><p class="calibre6">Evaluating the results, we still need to study 4.59 hours to pass, holding the number of beers constant. Also, we will need to drink less than .74 of a beer to pass. Notice that the odds ratio is<a id="id143" class="calibre1"/> positive, even though consuming more beer actually decreases our chance to pass. We know that there is an inverse relationship between the number of beers and the odds of passing because the coefficient for beer (-.029986) is negative.</p><p class="calibre6">Now, we can start trading off studying hours and drinking beer on the chance of us passing the exam. Go to the script file and add in studying 4.5 hours and drinking one beer:</p><div class="informalexample"><pre class="programlisting">let result' = analysis'.Regression.Compute([|4.50; 1.00|])</pre></div><p class="calibre6">Sending it to the REPL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val result' : float = 0.9511458187</strong></span>
</pre></div><p class="calibre6">So you have a 95% chance of passing if you drink a beer and study 4.5 hours. To further cement your odds, try filling out "B" on question 4 to push you over the top—that always worked for me in<a id="id144" class="calibre1"/> middle school.</p></div></div>

<div class="book" title="Logistic regression">
<div class="book" title="Applying a logistic regression to AdventureWorks data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec33" class="calibre1"/>Applying a logistic regression to AdventureWorks data</h2></div></div></div><p class="calibre6">So going back to a more<a id="id145" class="calibre1"/> realistic dataset, let's take a look at AdventureWorks. Go ahead and add a new<a id="id146" class="calibre1"/> script file to the project. Call it <code class="literal">AccordDotNet8.fsx</code>. Copy and paste the following code into the script file:</p><div class="informalexample"><pre class="programlisting">#r "System.Transactions.dll"
#r "../packages/Accord.3.0.2/lib/net40/Accord.dll"
#r "../packages/Accord.Statistics.3.0.2/lib/net40/Accord.Statistics.dll"
#r "../packages/Accord.Math.3.0.2/lib/net40/Accord.Math.dll"

open Accord
open Accord.Statistics.Filters
open Accord.Statistics.Analysis
open Accord.Statistics.Models.Regression
open Accord.Statistics.Models.Regression.Fitting

open System
open System.Data.SqlClient

type ProductInfo = {ProductID:int; Color:string; AvgReviews: float; Markup: float}
let productInfos = ResizeArray&lt;ProductInfo&gt;()

[&lt;Literal&gt;]
let connectionString = "data source=nc54a9m5kk.database.windows.net;initial catalog=AdventureWorks2014;user id=chickenskills@nc54a9m5kk;password=sk1lzm@tter;"

[&lt;Literal&gt;]
let query = "Select
    A.ProductID,
    A.Color,
    B.AvgReviews,
    A.MarkUp
    From
    (Select P.ProductID,
      Color,
      ListPrice - StandardCost as Markup
      from [Sales].[SalesOrderDetail] as SOD
        inner join [Sales].[SalesOrderHeader] as SOH
        on SOD.SalesOrderID = SOH.SalesOrderID
        inner join [Sales].[Customer] as C
        on SOH.CustomerID = C.CustomerID
      inner join [Production].[Product] as P
      on SOD.ProductID = P.ProductID
      inner join [Production].[ProductSubcategory] as PS
      on P.ProductSubcategoryID = PS.ProductSubcategoryID
      Where C.StoreID is null
      and PS.ProductCategoryID = 1) as A
    Inner Join
    (Select PR.ProductID,
      (Sum(Rating) + 0.0) / (Count(ProductID) + 0.0) as AvgReviews
        from [Production].[ProductReview] as PR
        Group By ProductID) as B
    on A.ProductID = B.ProductID"
            
let connection = new SqlConnection(connectionString)
let command = new SqlCommand(query, connection)
connection.Open()
let reader = command.ExecuteReader()
while reader.Read() do
    productInfos.Add({ProductID=reader.GetInt32(0);
                        Color=(string)(reader.GetString(1));
                        AvgReviews=(float)(reader.GetDecimal(2));
                        Markup=(float)(reader.GetDecimal(3));})</pre></div><p class="calibre6">Sending this<a id="id147" class="calibre1"/> to the REPL, you should <a id="id148" class="calibre1"/>see:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">type ProductInfo =</strong></span>
<span class="strong"><strong class="calibre7">  {ProductID: int;</strong></span>
<span class="strong"><strong class="calibre7">   Color: string;</strong></span>
<span class="strong"><strong class="calibre7">   AvgReviews: float;</strong></span>
<span class="strong"><strong class="calibre7">   Markup: float;}</strong></span>
<span class="strong"><strong class="calibre7">val productInfos : List&lt;ProductInfo&gt;</strong></span>
<span class="strong"><strong class="calibre7">val connectionString : string =</strong></span>
<span class="strong"><strong class="calibre7">  "data source=nc54a9m5kk.database.windows.net;initial catalog=A"+[72 chars]</strong></span>
<span class="strong"><strong class="calibre7">val query : string =</strong></span>
<span class="strong"><strong class="calibre7">  "Select</strong></span>
<span class="strong"><strong class="calibre7">    A.ProductID,</strong></span>
<span class="strong"><strong class="calibre7">    A.Color,</strong></span>
<span class="strong"><strong class="calibre7">    B.AvgReviews,</strong></span>
<span class="strong"><strong class="calibre7">    A."+[803 chars]</strong></span>
<span class="strong"><strong class="calibre7">val connection : SqlConnection = System.Data.SqlClient.SqlConnection</strong></span>
<span class="strong"><strong class="calibre7">val command : SqlCommand = System.Data.SqlClient.SqlCommand</strong></span>
<span class="strong"><strong class="calibre7">val reader : SqlDataReader</strong></span>
<span class="strong"><strong class="calibre7">val it : unit = ()</strong></span>
</pre></div><p class="calibre6">There's no new code here, so we can safely press on. However, I would like to note that this query might take a bit longer than any other query we have run against the database so far. This has an implication for how we architect our code when we integrate it to our application. We will discuss<a id="id149" class="calibre1"/> this in length in <a class="calibre1" title="Chapter 5. Time Out – Obtaining Data" href="part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055">Chapter 5</a>, <span class="strong"><em class="calibre11">Time Out – Obtaining Data</em></span>, but for now, we just want to note it.</p><p class="calibre6">Going back to<a id="id150" class="calibre1"/> the script file, go ahead and add this code to the bottom:</p><div class="informalexample"><pre class="programlisting">type ProductInfo' = {ProductID:int; BlackInd:float; BlueInd:float; RedInd:float; SilverInd:float; OtherInd: float; AvgReviews: float; HighMargin:float}

let getProductInfo'(productInfo:ProductInfo) =
        {ProductInfo'.ProductID=productInfo.ProductID;
        BlackInd = (match productInfo.Color with | "Black" -&gt; 1.0 | _ -&gt; 0.0);
        BlueInd = (match productInfo.Color with | "Blue" -&gt; 1.0 | _ -&gt; 0.0);
        RedInd = (match productInfo.Color with | "Red" -&gt; 1.0 | _ -&gt; 0.0);
        SilverInd = (match productInfo.Color with | "Silver" -&gt; 1.0 | _ -&gt; 0.0);
        OtherInd = (match productInfo.Color with | "Silver" | "Blue" | "Red"  -&gt; 0.0 | _ -&gt; 1.0);
        AvgReviews = productInfo.AvgReviews;
        HighMargin = (match productInfo.Markup &gt; 800.0 with | true -&gt; 1.0 | false -&gt; 0.0);}

let productInfos' = 
    productInfos 
    |&gt; Seq.map (fun pi -&gt; getProductInfo'(pi))
let xs = 
    productInfos' 
    |&gt; Seq.map (fun pi -&gt; [|pi.BlackInd; pi.BlueInd; pi.RedInd; pi.SilverInd; pi.OtherInd; pi.AvgReviews|]) 
    |&gt; Seq.toArray
let y = 
    productInfos' 
    |&gt; Seq.map (fun pi -&gt; pi.HighMargin) 
    |&gt; Seq.toArray

let analysis = new LogisticRegressionAnalysis(xs, y)
analysis.Compute() |&gt; ignore
let pValue = analysis.ChiSquare.PValue
let coefficientOdds = analysis.Regression.GetOddsRatio(0)
let blackIndOdds = analysis.Regression.GetOddsRatio(1)
let blueIndOdds = analysis.Regression.GetOddsRatio(2)
let redIndOdds = analysis.Regression.GetOddsRatio(3)
let silverIndOdds = analysis.Regression.GetOddsRatio(4)
let otherIndOdds = analysis.Regression.GetOddsRatio(5)
let ratingsOdds = analysis.Regression.GetOddsRatio(6)
let coefficients = analysis.CoefficientValues</pre></div><p class="calibre6">Sending this<a id="id151" class="calibre1"/> to the REPL, you should get:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val analysis : LogisticRegressionAnalysis</strong></span>
<span class="strong"><strong class="calibre7">val pValue : float = 0.0</strong></span>
<span class="strong"><strong class="calibre7">val coefficientOdds : float = 4.316250806e-07</strong></span>
<span class="strong"><strong class="calibre7">val blackIndOdds : float = 6.708924364</strong></span>
<span class="strong"><strong class="calibre7">val blueIndOdds : float = 0.03366007966</strong></span>
<span class="strong"><strong class="calibre7">val redIndOdds : float = 0.0897074697</strong></span>
<span class="strong"><strong class="calibre7">val silverIndOdds : float = 0.04618907808</strong></span>
<span class="strong"><strong class="calibre7">val otherIndOdds : float = 0.003094736179</strong></span>
<span class="strong"><strong class="calibre7">val ratingsOdds : float = 127.5863311</strong></span>
<span class="strong"><strong class="calibre7">val coefficients : float [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|-14.65570849; 1.903438635; -3.391442724; -2.411201239; -3.075011914;</strong></span>
<span class="strong"><strong class="calibre7">    -5.778052618; 4.848793242|]</strong></span>
</pre></div><p class="calibre6">There are some new <a id="id152" class="calibre1"/>pieces of code to look at and two new concepts. First, notice that a new record type was created for <code class="literal">ProductInfo</code> and the colors are broken out from a single column (<code class="literal">ProductType.Color</code>) to a series of 0.0/1.0 columns (<code class="literal">ProductType'.BlackInd</code>, <code class="literal">ProductType'BlueInd</code>, and so on). The reason I did not make the columns bool is that Accord.NET expects inputs to be a float and 0.0/1.0 serves the purpose just as well. These columns are called "dummy" variables and they are used by logistic regressions to accommodate categorical data. At this point, you are probably asking, "What the heck is categorical data?" Fair question.</p></div></div>

<div class="book" title="Logistic regression">
<div class="book" title="Categorical data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec34" class="calibre1"/>Categorical data</h2></div></div></div><p class="calibre6">You might not have<a id="id153" class="calibre1"/> noticed, but all of the <code class="literal">x</code> variables that we have used until this last query have been numeric—number of bikes sold, average reviews, number of beers drank, and the like. These values are considered continuous because they can be of infinite value. I can have one, two, or three beers. Similarly, the average reviews of a bike can be 3.45, 3.46, and so on. Because these values are treated as numbers, they can be added, averaged, and manipulated in all of the ways that you've learned since first grade. Note that continuous values can be range-bound: the average review can only be between 0.0 and 5.0 because that is what we limited users to enter.</p><p class="calibre6">Categorical values are different. Typically, they are integers that stand in for a non-numeric concept. For <a id="id154" class="calibre1"/>example, 0 might be male and 1 might be female. Similarly, the status of the sales order might be 1 for open, 2 for pending, 3 for closed, and 4 for returned. Although these values are stored in the database as integers, they cannot be added, averaged, or otherwise manipulated. Categorical values may also be stored as strings, like we have seen for a bike color: "black", "blue", and the like. In this case, the range of strings is limited to a set from which numbers can be chosen.</p><p class="calibre6">Going back to our analysis, we have the bike color, which is a categorical value and is being stored as a string. We can't send this string to Accord.NET as a single <code class="literal">x</code> variable because the <code class="literal">LogisticRegressionAnalysis</code> only takes in floats in the array. Note that in other statistical packages like R or SAS, you can pass in a string because there is behind-the-scenes code that translates those string values to numeric. So, back to color. We want to use it, but it has to become a float. We could create a new field called <code class="literal">ColorId</code> and hook up a translation function that turns each of the colors to a numeric representation like this:</p><div class="informalexample"><pre class="programlisting">let getColorId (color:string) =
    match color.ToLower() with
    | "black" -&gt; 1.0
    | "blue" -&gt; 2.0
    | "red" -&gt; 3.0
    | "silver" -&gt; 4.0
    | _ -&gt; 5.0</pre></div><p class="calibre6">And we will do that in other places in the book. However, using those numeric values makes no sense in our logistic regression because there is no real meaning in comparing values: an <code class="literal">oddsRatio</code> of 2.3 means what? In fact, no type of regression can make sense of categorical data coded in this way. Instead of building nonsensical values, we create dummy variables that can be interpreted with meaning in a regression. For each of the possible values of our categorical variable, we create a bool column that indicates whether that particular record has that value. Technically, we can create one less than the total possible values, but I find it easier to reason and display a column for each value. We can then pass these dummy variables into a regression and get a meaningful response.</p><p class="calibre6">Also notice that I did the pattern matching for the colors assignment on one line like this:</p><div class="informalexample"><pre class="programlisting">BlackInd = (match productInfo.Color with | "Black" -&gt; 1.0 | _ -&gt; 0.0);</pre></div><p class="calibre6">There is some heated controversy in the F# community about whether this is considered bad form: some people want to see each possible outcome of the pattern matching statement to be on one line, and others do not. I find it much more readable to keep everything on one line in cases like this, but I acknowledge it is a bit harder for someone new to F# from a curly-braced language like C#. If, however, you use ternary operators you should be comfortable with the syntax.</p><p class="calibre6">Also, notice that <a id="id155" class="calibre1"/>we changed our continuous variable of <code class="literal">Markup</code> to <code class="literal">High Margin</code> using this line of code:</p><div class="informalexample"><pre class="programlisting">HighMargin = (match productInfo.Markup &gt; 800.0 with | true -&gt; 1.0 | false -&gt; 0.0);}</pre></div></div></div>

<div class="book" title="Logistic regression">
<div class="book" title="Attachment point"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch03lvl2sec35" class="calibre1"/>Attachment point</h2></div></div></div><p class="calibre6">Since logistic<a id="id156" class="calibre1"/> regressions need to have a 0.0 or 1.0 as a <code class="literal">y</code> variable, we need a way of splitting the data into something that has both business meaning <a id="id157" class="calibre1"/>and can be evaluated into 0.0 or 1.0. How did I pick $800? I eyeballed it after doing this in the database:</p><div class="informalexample"><pre class="programlisting">Select 
ProductID,
P.Name,
ProductNumber,
Color,
StandardCost,
ListPrice,
ListPrice - StandardCost as Markup
from [Production].[Product] as P
Inner Join [Production].[ProductSubcategory] as PS
on P.ProductSubcategoryID = PS.ProductSubcategoryID
Where PS.ProductCategoryID = 1
Order by ListPrice - StandardCost</pre></div><p class="calibre6">That $800 number is often called the "attachment point" and is often the most discussed part of any logistic regression model. In the real world, that number is often set by the President of a small company on the back of a napkin, or, in a large company, a multi-disciplinary team that takes six weeks. The key thing to remember is that you want that number in your <code class="literal">config</code> file (if you are running your regression at real-time) or a separate variable at the top of your script (if doing it ad hoc). Note that to make our script even smarter, it is possible to inject in another model that determines the attachment point dynamically, so it will not require a human to update it, but that will be an exercise for another day.</p></div></div>

<div class="book" title="Logistic regression">
<div class="book" title="Analyzing results of the logistic regression"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch03lvl2sec36" class="calibre1"/>Analyzing results of the logistic regression</h2></div></div></div><p class="calibre6">Let's look at the odds ratios and coefficients, and we'll see two things stand out. First, notice that black odds (6.7) is much higher than all of the other numbers and that it has a positive coefficient <a id="id158" class="calibre1"/>while all of the other colors have a negative one. Since all of the bikes are available in all the colors, in this context, we can reasonably conclude that black is the new black. People are buying our higher margin bikes and preferring the color black when they do so.</p><p class="calibre6">The other striking number is the average review's <code class="literal">OddsRatio</code>, which is 127. How can a number that usually falls between 3 and 5 have an odds ratio of 127? Should we interpret it to mean that increasing the average review 1,270 times will move a customer from a low-margin to a high-margin bike? Well, no. When we get an abnormally high <code class="literal">OddsRatio</code>, it means that our predictors are highly correlated with each other (you might hear data scientists talk about sparse matrices, and the like here). As we learned from Occam's Razor, we want to remove variables whenever we can. Since ratings and colors are correlated (which is in itself an interesting discovery), let's drop the average rating and only focus on color.</p><p class="calibre6">Since black seems to be associated with higher margin products, what should we do? Should we suggest to the management that we should be like Harry Ford and offer our bikes, "In any color they like, as long as it is black?" No, we want to offer other colors, because some people don't want black and we want their business. However, what we can do is use black to drive higher-margin sales. Here is a small snippet from the order form for individuals on our website:</p><div class="mediaobject"><img src="../images/00056.jpeg" alt="Analyzing results of the logistic regression" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Notice that the colors are ordered in a random manner and are placed after the customer selects the model. What if we moved the colors to the first selection to get the user in the "black frame of mind" and then offer models? Also, perhaps we should move the color selection so that black is on top?</p><p class="calibre6">While this is pretty good, this is a book about machine learning and there is little machine learning here to this point (unless you count the logistic regression's methodology in determining the <a id="id159" class="calibre1"/>answer, which I don't). How can we update our site automatically as customers' preferences change? What if all the cool kids started riding silver bikes? How can we quickly take advantage of this? How can the machine learn faster than the research analysts running the model periodically?</p><p class="calibre6">We could do what we did in the last chapter and run the model on each page creation, create an evaluator of the model, and then populate the select list. However, if you remember about how long it took to run, it is a suboptimal solution because by the time it takes to run the model, most of our customers would abandon the site (though if they were using a mobile device, we can always blame the network connection; developers have never done this before). As an alternative, what if we created a process when the website started that constantly runs the model and caches the result? This way, each time the page is created, the<a id="id160" class="calibre1"/> data behind the select list is as fresh as it can be. Let's drop into Visual Studio and make it happen.</p></div></div>

<div class="book" title="Logistic regression">
<div class="book" title="Adding logistic regression to the application"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch03lvl2sec37" class="calibre1"/>Adding logistic regression to the application</h2></div></div></div><p class="calibre6">Open up the<a id="id161" class="calibre1"/> <code class="literal">AdventureWorks</code> solution and go<a id="id162" class="calibre1"/> to the <code class="literal">AdventureWorks.MachineLearning</code> project:</p><div class="mediaobject"><img src="../images/00057.jpeg" alt="Adding logistic regression to the application" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Add a new F# source file and name it <code class="literal">ColorPrediction.fs</code>. You will notice that it is placed at the bottom of the project. The order of the files is important in an F# project because of the type inference system. What you can do is right-click on the file and move it up above the <code class="literal">.config</code> file:</p><div class="mediaobject"><img src="../images/00058.jpeg" alt="Adding logistic regression to the application" class="calibre8"/><div class="caption"><p class="calibre18">The Move Up option</p></div></div><p class="calibre9"> </p><p class="calibre6">Go into the <code class="literal">ColorPrediction.fs</code> file and replace<a id="id163" class="calibre1"/> all the existing code with the following<a id="id164" class="calibre1"/> code:</p><div class="informalexample"><pre class="programlisting">namespace AdventureWorks.MachineLearning

open Accord
open Accord.Statistics.Filters
open Accord.Statistics.Analysis
open Accord.Statistics.Models.Regression
open Accord.Statistics.Models.Regression.Fitting

open System
open System.Data.SqlClient</pre></div><p class="calibre6">Next, let's add in the types that we created in the regression project and the one type we need for this compiled assembly. While we're at it, add in the list of <code class="literal">ProductInfos</code> and the connection string and query values from the regression project:</p><div class="informalexample"><pre class="programlisting">type ProductInfo = {ProductID:int; Color:string; AvgReviews: float; Markup: float}
type ProductInfo' = {ProductID:int; BlackInd:float; BlueInd:float; RedInd:float; SilverInd:float; OtherInd: float; AvgReviews: float; HighMargin:float}

type public ColorPrediction () = 
    let productInfos = ResizeArray&lt;ProductInfo&gt;()

    [&lt;Literal&gt;]
    let connectionString = "data source=nc54a9m5kk.database.windows.net;initial catalog=AdventureWorks2014;user id=chickenskills@nc54a9m5kk;password=sk1lzm@tter;"

    [&lt;Literal&gt;]
    let query = "Select
        A.ProductID,
        A.Color,
        B.AvgReviews,
        A.MarkUp
        From
        (Select P.ProductID,
          Color,
          ListPrice - StandardCost as Markup
          from [Sales].[SalesOrderDetail] as SOD
            inner join [Sales].[SalesOrderHeader] as SOH
            on SOD.SalesOrderID = SOH.SalesOrderID
            inner join [Sales].[Customer] as C
            on SOH.CustomerID = C.CustomerID
            inner join [Production].[Product] as P
            on SOD.ProductID = P.ProductID
            inner join [Production].[ProductSubcategory] as PS
            on P.ProductSubcategoryID = PS.ProductSubcategoryID
            Where C.StoreID is null
            and PS.ProductCategoryID = 1) as A
        Inner Join
        (Select PR.ProductID,
            (Sum(Rating) + 0.0) / (Count(ProductID) + 0.0) as AvgReviews
            from [Production].[ProductReview] as PR
            Group By ProductID) as B
        on A.ProductID = B.ProductID"</pre></div><p class="calibre6">Next, let's add <a id="id165" class="calibre1"/>a method that will return an ordered list of <a id="id166" class="calibre1"/>colors with the most important one on top:</p><div class="informalexample"><pre class="programlisting">    member this.GetColors(attachmentPoint) = 
        let connection = new SqlConnection(connectionString)
        let command = new SqlCommand(query, connection)
        connection.Open()
        let reader = command.ExecuteReader()
        while reader.Read() do
            productInfos.Add({ProductID=reader.GetInt32(0);
              Color=(string)(reader.GetString(1));
              AvgReviews=(float)(reader.GetDecimal(2));
              Markup=(float)(reader.GetDecimal(3));})

        let getProductInfo'(productInfo:ProductInfo) =
                {ProductInfo'.ProductID=productInfo.ProductID;
                BlackInd = (match productInfo.Color with | "Black" -&gt; 1.0 | _ -&gt; 0.0);
                BlueInd = (match productInfo.Color with | "Blue" -&gt; 1.0 | _ -&gt; 0.0);
                RedInd = (match productInfo.Color with | "Red" -&gt; 1.0 | _ -&gt; 0.0);
                SilverInd = (match productInfo.Color with | "Silver" -&gt; 1.0 | _ -&gt; 0.0);
                OtherInd = (match productInfo.Color with | "Silver" | "Blue" | "Red" | "Silver" -&gt; 0.0 | _ -&gt; 1.0);
                AvgReviews = productInfo.AvgReviews;
                HighMargin = (match productInfo.Markup &gt; attachmentPoint with | true -&gt; 1.0 | false -&gt; 0.0);}

        let productInfos' = 
            productInfos 
            |&gt; Seq.map (fun pi -&gt; getProductInfo'(pi))
        let xs = 
            productInfos' 
            |&gt; Seq.map (fun pi -&gt; [|pi.BlackInd; pi.BlueInd; pi.RedInd; pi.SilverInd; pi.OtherInd; pi.AvgReviews|])
            |&gt; Seq.toArray
        let 
            y = productInfos' 
            |&gt; Seq.map (fun pi -&gt; pi.HighMargin) 
            |&gt; Seq.toArray
        
        let colors = [|"Black";"Blue";"Red";"Silver";"Other"|]

        let analysis = new LogisticRegressionAnalysis(xs, y)
        match analysis.Compute() with 
            | true -&gt;
                let coefficientValues = analysis.CoefficientValues |&gt; Seq.skip 1
                let colors' = Seq.zip colors coefficientValues
                colors' |&gt; Seq.mapi (fun i (c,cv) -&gt; c, (abs(cv)/cv), analysis.Regression.GetOddsRatio(i))
                        |&gt; Seq.map (fun (c, s, odr) -&gt; c, s * odr)
                        |&gt; Seq.sortBy (fun (c, odr) -&gt; odr)
                        |&gt; Seq.map (fun (c, odr) -&gt; c)
                        |&gt; Seq.toArray
            | false -&gt; colors</pre></div><p class="calibre6">Most of the code is the same as the work we did in the regression project, but there is some new code that needs some explanation. There is now a string array called <code class="literal">colors</code> that lists all of the colors that we sent to our regression. After the <code class="literal">analysis.Compute()</code> is called, we remove<a id="id167" class="calibre1"/> the first value from the <code class="literal">analysis.CoefficientValues</code> via this line:</p><div class="informalexample"><pre class="programlisting">analysis.CoefficientValues |&gt; Seq.skip 1</pre></div><p class="calibre6">Skip is a handy function that allows us to, well, skip the first rows of <code class="literal">Seq</code>. We are calling it here because the <code class="literal">analysis.CoefficientValues</code> returns the coefficient in the first value of the array.</p><p class="calibre6">Next, we call the following:</p><div class="informalexample"><pre class="programlisting">let colors' = Seq.zip colors coefficientValues</pre></div><p class="calibre6">We have seen <code class="literal">Seq.zip</code> before. We are gluing together the colors array with the coefficient values array<a id="id168" class="calibre1"/> so each row is a tuple of the color name and its coefficient. With that array set up, we then implement the final transformation pipeline:</p><div class="informalexample"><pre class="programlisting">                colors' |&gt; Seq.mapi (fun i (c,cv) -&gt; c, (abs(cv)/cv), analysis.Regression.GetOddsRatio(i+1))
                        |&gt; Seq.map (fun (c, s, odr) -&gt; c, s * odr)
                 |&gt; Seq.sortByDescending (fun (c,odr)-&gt; odr)
                        |&gt; Seq.map (fun (c, odr) -&gt; c)
                        |&gt; Seq.toArray</pre></div><p class="calibre6">The first step is as follows:</p><div class="informalexample"><pre class="programlisting">|&gt; Seq.mapi(fun i (c,cv) -&gt; c, (abs(cv)/cv), analysis.Regression.GetOddsRatio(i+1))</pre></div><p class="calibre6">This applies a <code class="literal">mapi</code> function to <code class="literal">colors</code>. <code class="literal">Seq.mapi</code> is a high order function that is just like the <code class="literal">Seq.map</code> function with one extra parameter, the index of each row. So the index <code class="literal">i</code> is passed in and then the tuple <code class="literal">(c,cv)</code>, which is the color and the <code class="literal">coefficientValue</code>. We return a tuple with the color, a -1 or +1 depending on the sign of the <code class="literal">coefficientValue</code>, and the odds ratio -&gt;, which we look up based on the index.</p><p class="calibre6">The next step is as follows:</p><div class="informalexample"><pre class="programlisting">|&gt; Seq.map(fun (c, s, odr) -&gt; c, s * odr)</pre></div><p class="calibre6">This applies another function that returns the color and a signed odds ratio. If you remember from before, <code class="literal">Regression.GetOddsRatio</code> is always positive. We are applying the sign so we can order the ratios from most probable to the least probable.</p><p class="calibre6">The next step is as follows:</p><div class="informalexample"><pre class="programlisting">|&gt; Seq.sortByDescending(fun (c,odr)-&gt; odr)</pre></div><p class="calibre6">This applies a function that sorts the array based on the odds ratio so that the tuple with the highest <code class="literal">oddsRatio</code> is on top.</p><p class="calibre6">The next two steps turn the tuple into a simple string. The color name then transforms our <code class="literal">Seq</code> to an array:</p><div class="informalexample"><pre class="programlisting">|&gt; Seq.map(fun (c, odr) -&gt; c)
|&gt; Seq.toArray</pre></div><p class="calibre6">With the code in<a id="id169" class="calibre1"/> place, let's hop over to our MVC project and<a id="id170" class="calibre1"/> implement it. Find the <code class="literal">Global.asax</code> file and open it up. Replace the code with the following:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Configuration;
using System.Linq;
using System.Threading;
using System.Web;
using System.Web.Mvc;
using System.Web.Optimization;
using System.Web.Routing;
using AdventureWorks.MachineLearning;

namespace AdventureWorks
{
    public class MvcApplication : System.Web.HttpApplication
    {
        static Object _lock = new Object();
        Timer _timer = null;
        static String[] _bikeColors = null;

        protected void Application_Start()
        {
            AreaRegistration.RegisterAllAreas();
            FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
            RouteConfig.RegisterRoutes(RouteTable.Routes);
            BundleConfig.RegisterBundles(BundleTable.Bundles);
            _bikeColors = new string[5] { "Red", "White", "Blue", "Black", "Silver" };
            _timer = new Timer(UpdateBikeColors,null,0,TimeSpan.FromMinutes(1).Milliseconds);
        }

        private void UpdateBikeColors(object state)
        {
            var attachmentPoint = Double.Parse(ConfigurationManager.AppSettings["attachmentPoint"]);
            var colorPrediction = new ColorPrediction();
            BikeColors = colorPrediction.GetColors(attachmentPoint);
        }

        public static String[] BikeColors
        {
            get
            {
                lock(_lock)
                {
                    return _bikeColors;
                }
            }
            set
            {
                lock(_lock)
                {
                    _bikeColors = value;
                }
            }
        }
    }
}</pre></div><p class="calibre6">Some of this code might<a id="id171" class="calibre1"/> be new, so let's take a closer look. First, we created two class-level variables: <code class="literal">_lock</code> and <code class="literal">_timer</code>. We use <code class="literal">_lock</code> to prevent our color array to be read while our regression <a id="id172" class="calibre1"/>could be updating it. You can see <code class="literal">_lock</code> in action in the public property that exposes the color array:</p><div class="informalexample"><pre class="programlisting">        public static String[] BikeColors
        {
            get
            {
                lock(_lock)
                {
                    return _bikeColors;
                }
            }
            set
            {
                lock(_lock)
                {
                    _bikeColors = value;
                }
            }
        }</pre></div><p class="calibre6">Next, we create a method that will be called when our timer fires:</p><div class="informalexample"><pre class="programlisting">        private void UpdateBikeColors(object state)
        {
            var attachmentPoint = Double.Parse(ConfigurationManager.AppSettings["attachmentPoint"]);
            var colorPrediction = new ColorPrediction();
            BikeColors = colorPrediction.GetColors(attachmentPoint);
        }</pre></div><p class="calibre6">Notice that we are<a id="id173" class="calibre1"/> creating an instance of our <code class="literal">ColorPrediction</code> class, which then invokes the <code class="literal">GetColors</code> method. We assign the <code class="literal">BikeColors</code> property with the return of our recently-calculated solution.</p><p class="calibre6">Finally, we instantiate the <code class="literal">_timer</code> variable in the <code class="literal">Application.Start</code> method, passing in the method that gets invoked when the timer counts down:</p><div class="informalexample"><pre class="programlisting">_timer = new Timer(UpdateBikeColors,null,0,TimeSpan.FromMinutes(1).Milliseconds);</pre></div><p class="calibre6">This means, every minute we call the color prediction to run the logistic regression based on the most recent data. Meanwhile, clients will be calling our website continuously and they will be getting <a id="id174" class="calibre1"/>an array of colors based on the most recent calculation.</p><p class="calibre6">Next, go to the <code class="literal">.config</code> file and add the attachment point to the <code class="literal">appSettings</code> section:</p><div class="informalexample"><pre class="programlisting">    &lt;add key="attachmentPoint" value="800" /&gt;</pre></div><p class="calibre6">Finally, open the <code class="literal">individualOrder</code> controller and replace the hardcoded values of colors with our generated one in the <code class="literal">Create</code> method:</p><div class="informalexample"><pre class="programlisting">var colors = MvcApplication.BikeColors;</pre></div><p class="calibre6">Run the site and you will see that our color list has changed:</p><div class="mediaobject"><img src="../images/00059.jpeg" alt="Adding logistic regression to the application" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">We now have a pretty good model that seems to be working in production, without a major performance hit. However, our solution so far has a fatal flaw. We are guilty of overfitting. As<a id="id175" class="calibre1"/> mentioned in <a class="calibre1" title="Chapter 2. AdventureWorks Regression" href="part0024_split_000.html#MSDG2-a18db0be6c20485ba81f22e43ca13055">Chapter 2</a>, <span class="strong"><em class="calibre11">AdventureWorks Regression</em></span>, overfitting, is the notion that the model we create only works against the data we have on hand and fails miserably when we introduce it to new data. Every machine learning<a id="id176" class="calibre1"/> technique has a problem with overfitting, and there are some common ways to mitigate its impact. We will look at that in the coming chapters.</p></div></div>
<div class="book" title="Summary" id="TI1E1-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec24" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">We covered a lot of ground in this chapter. We looked at multiple linear regressions, logistic regressions, and then considered a couple of techniques to normalize our dataset. Along the way, we learned some new F# code and learned a way to update a machine learning model without impact on our end user experience.</p><p class="calibre6">In the next chapter, we take a break from AdventureWorks and line of business development and start working with some open data as a data scientist using a decision tree. As Dick Clark used to say, "The hits just keep coming."</p></div></body></html>