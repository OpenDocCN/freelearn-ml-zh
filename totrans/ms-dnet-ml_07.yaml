- en: Chapter 7. Traffic Stops and Crash Locations – When Two Datasets Are Better
    Than One
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。交通拦截和事故地点 – 当两个数据集比一个更好
- en: If you remember from [Chapter 4](part0032_split_000.html#UGI01-a18db0be6c20485ba81f22e43ca13055
    "Chapter 4. Traffic Stops – Barking Up the Wrong Tree?"), *Traffic Stops – Barking
    Up the Wrong Tree?*, we used a decision tree to help us determine if a person
    received a ticket or a warning based on several seasonality factors like time
    of day, day of the week, and the like. Ultimately, we could not find a relationship.
    Your first inclination might be to throw out the dataset, which I think is a mistake
    because there might be data gold in them thar hills, but we are just using the
    wrong model. Also, if a single dataset is not profitable, I typically start augmenting
    that set with others to see if the combination of features will provide a more
    satisfactory answer. In this chapter, let's go back to our Code-4-Good group and
    see if we can both augment the traffic stop dataset and apply some different models
    that will help us formulate interesting questions and answers. Perhaps even if
    we are not asking the right questions, the computer can help us ask the right
    questions too.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得[第4章](part0032_split_000.html#UGI01-a18db0be6c20485ba81f22e43ca13055 "第4章。交通拦截
    – 是否走错了路？")，*交通拦截 – 是否走错了路？*，我们使用决策树来帮助我们根据诸如一天中的时间、一周中的哪一天等季节性因素来确定一个人是否收到了罚单或警告。最终，我们没有找到任何关系。你的第一个想法可能是丢弃数据集，我认为这是一个错误，因为其中可能隐藏着数据宝藏，但我们只是使用了错误的模型。此外，如果一个数据集本身不盈利，我通常开始用其他数据集来增强它，看看特征组合是否能提供更令人满意的答案。在本章中，让我们回到我们的Code-4-Good小组，看看我们是否可以增强交通拦截数据集，并应用一些不同的模型，这些模型将帮助我们提出有趣的问题和答案。也许即使我们没有提出正确的问题，计算机也能帮助我们提出正确的问题。
- en: Unsupervised learning
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无监督学习
- en: 'To this point in the book, we have used several different models to answer
    our questions: linear regression, logistic regression, and kNN to name a few.
    Although different in their methodology, they share a common thread; we told the
    computer the answer (called the dependent or *y* variable) and then provided a
    series of features (called independent or *x* variables) that can be associated
    with that answer. Consider the following diagram for example:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书我们已经使用了几种不同的模型来回答我们的问题：线性回归、逻辑回归和kNN等。尽管它们的方法不同，但它们有一个共同点；我们告诉计算机答案（称为因变量或*y*变量），然后提供一系列可以与该答案关联的特征（称为自变量或*x*变量）。以下图为例：
- en: '![Unsupervised learning](img/00085.jpeg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![无监督学习](img/00085.jpeg)'
- en: 'We then presented the computer with some combination of independent variables
    that it had not seen before and asked it to guess the answer:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后向计算机展示了一些它之前未曾见过的独立变量的组合，并要求它猜测答案：
- en: '![Unsupervised learning](img/00086.jpeg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![无监督学习](img/00086.jpeg)'
- en: 'We then compared to the known answers via the test and, if it did a good job
    guessing, we would use the model in production:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后通过测试将结果与已知答案进行比较，如果模型在猜测方面做得很好，我们就会在生产中使用该模型：
- en: '![Unsupervised learning](img/00087.jpeg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![无监督学习](img/00087.jpeg)'
- en: This methodology of telling the computer the answer ahead of time is called
    *supervised learning*. The term *supervised* is used because we provide the computer
    an answer explicitly and then tell it which model to use.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在事先告诉计算机答案的方法被称为*监督学习*。术语*监督*之所以被使用，是因为我们明确地提供给计算机一个答案，然后告诉它使用哪个模型。
- en: 'There is another class of models that do not provide the answer to the computer.
    This class is called *unsupervised learning*. If your mental model of *unsupervised
    learning* is the chaos that engulfs a sixth grade class when a substitute teacher
    shows up the day before summer vacation, you are not far off. Okay, maybe not
    *that* bad. With unsupervised learning, we hand the computer a data frame of only
    attributes and ask it to tell us about the data. With that information, we can
    then narrow down the data that might help us make insightful business decisions.
    For example, let''s say you send this data frame to the computer:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一类模型不会向计算机提供答案。这类模型被称为*无监督学习*。如果你的*无监督学习*的心理模型是替代教师在暑假前一天出现在六年级班级时的混乱，你并不远。好吧，可能没有*那么*糟糕。在无监督学习中，我们向计算机提供一个只包含属性的数据框，并要求它告诉我们关于数据的信息。有了这些信息，我们就可以缩小可能帮助我们做出有洞察力的商业决策的数据。例如，假设你将这个数据框发送给计算机：
- en: '![Unsupervised learning](img/00088.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![无监督学习](img/00088.jpeg)'
- en: 'It might tell you that the data seems to cluster in two areas:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会告诉你数据似乎在两个区域聚集：
- en: '![Unsupervised learning](img/00089.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![无监督学习](img/00089.jpeg)'
- en: Although you might have eye-balled this relationship on this simple 2D data
    frame, the task becomes much harder, if not impossible, when adding more rows
    and features. In this chapter, we are going to use the k-means model to do this
    kind of clustering.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能在简单的2D数据框上通过观察发现了这种关系，但在添加更多行和特征时，这项任务会变得非常困难，甚至不可能。在本章中，我们将使用k-means模型进行这种聚类。
- en: 'Also, we can use the computer to tell us what features are useful in a data
    frame and what features are just noise. For example, consider this dataset:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用计算机告诉我们数据框中有用的特征以及哪些特征只是噪声。例如，考虑以下数据集：
- en: '| Hours Of Studying | Number Of Beers | StudyLocation |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 学习时间 | 啤酒数量 | 学习地点 |'
- en: '| --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 2 | 4 | Dorm |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 4 | Dorm |'
- en: '| 1 | 5 | Dorm |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 5 | Dorm |'
- en: '| 6 | 0 | Dorm |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 0 | Dorm |'
- en: '| 5 | 1 | Dorm |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 1 | Dorm |'
- en: '| 2 | 8 | Dorm |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 8 | Dorm |'
- en: '| 4 | 4 | Dorm |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | Dorm |'
- en: Will the inclusion of **StudyLocation** in our data frame lead to any insights?
    The answer is no, because the values are all the same. In this chapter, we are
    going to use **Principle Component Analysis** (**PCA**) to this kind of feature
    filtering; it will tell us what features are important and what can be safely
    removed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将**学习地点**包含在我们的数据框中会导致任何洞察吗？答案是不会有，因为所有值都相同。在本章中，我们将使用**主成分分析**（PCA）进行此类特征过滤；它将告诉我们哪些特征是重要的，哪些可以安全地删除。
- en: k-means
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: k-means
- en: 'As mentioned in the prior section, k-means is an unsupervised technique: observations
    are grouped based on mean of each cluster. Let''s take a look at k-means in action.
    Open up Visual Studio and create a new Visual F# Windows Library Project. Rename
    the `Script.fsx` file to `kmeans.fsx`. Open up the **NuGet Package Manager** console
    and enter the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，k-means是一种无监督技术：观察值是根据每个簇的平均值进行分组的。让我们看看k-means的实际应用。打开Visual Studio，创建一个新的Visual
    F# Windows Library Project。将`Script.fsx`文件重命名为`kmeans.fsx`。打开**NuGet包管理器**控制台，并输入以下内容：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, go to the script and replace all of the contents with this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，转到脚本并替换所有内容为以下内容：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, let''s create an array of different beverages that are served at our
    local restaurant:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个数组，包含我们当地餐厅提供的各种饮料：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sending this to the FSI, you will see the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到FSI，你会看到以下结果：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Go back to the script and enter in some records of some patrons of the restaurant.
    We are using a float value because that is what Accord expects as an input.:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到脚本，并输入一些餐厅顾客的记录。我们使用浮点值，因为Accord期望作为输入。
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Sending that to the REPL gives us the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到REPL，我们得到以下结果：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will notice that there are nine different patrons and each had three drinks.
    Patron number 1 had a Boone''s Farm, a Mad Dog, and a Night Train. With this data
    ready, let''s run a k-means against it. Enter this into the script file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到有九位不同的顾客，每位顾客都喝了三种饮料。顾客编号1喝了布恩农场酒、疯狗酒和夜车酒。有了这些数据，让我们对它运行k-means算法。将以下内容输入到脚本文件中：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you send this to the FSI, you will see the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将此发送到FSI时，你会看到以下结果：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This output takes each patron and assigns them to one of the three clusters.
    For example, Patrons number 1 and 2 are in cluster number 0\. If we wanted more
    observations in each cluster, we could change the `numberOfClusters` like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出将每位顾客分配到三个簇中的一个。例如，顾客编号1和2在簇编号0中。如果我们想每个簇有更多的观察值，我们可以像这样更改`numberOfClusters`：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And sending that to the FSI would give the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到FSI，会得到以下结果：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that the computer does not try to label or otherwise assign any value
    to each of the clusters. The data scientist would then need to assign a meaningful
    value, if one is possible. Go back to the script and change the `numberOfClusters`
    back to three and resend to the FSI. Looking at the input array, we can say that
    the cluster assigned `0` is for fortified wine drinkers, cluster `1` is for hard
    liquor drinkers, and cluster `2` is for beer drinkers. However, sometimes you
    may not be able to tell what each cluster means by eye-balling the input array.
    In that case, you can ask Accord for some (limited) help. Enter this into the
    script file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，计算机不会尝试为每个簇标记或分配任何值。如果可能，数据科学家需要分配一个有意义的值。返回到脚本，将`numberOfClusters`改回三个，并重新发送到FSI。查看输入数组，我们可以认为分配簇`0`的是加强葡萄酒饮用者，簇`1`是烈酒饮用者，簇`2`是啤酒饮用者。然而，有时你可能无法仅通过观察输入数组来判断每个簇的含义。在这种情况下，你可以请求Accord提供一些（有限的）帮助。将以下内容输入到脚本文件中：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Sending this to the FSI will give the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到FSI将得到以下结果：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice the mean is mid-threes, which is a low number as we are counting from
    0 to 13\. We could say that category 0's label should be *Buckfast*-like drinkers,
    which is generally correct.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意均值是中间的三位数，这是一个相对较小的数字，因为我们是从0到13进行计数的。我们可以说，类别0的标签应该是类似**巴克夫斯特**的饮酒者，这通常是正确的。
- en: Principle Component Analysis (PCA)
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主成分分析（PCA）
- en: Another common task we can do with unsupervised learning is to help us throw
    out features that are not relevant. If you remember from the last chapter, we
    used a stepwise regression to determine the best features when building our model
    and then used Occum's Razor to toss insignificant features. One of the more common
    things you can do with PCA is use this unsupervised model as a way of picking
    the best features—the **principle components** of the frame.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用无监督学习来完成另一个常见任务，即帮助我们剔除不相关的特征。如果你还记得上一章，我们在构建模型时使用逐步回归来确定最佳特征，然后使用奥卡姆剃刀法则剔除不显著的特征。PCA的一个更常见用途是将这个无监督模型作为挑选最佳特征——即框架的**主成分**的一种方式。
- en: 'Add another script file to your project and name it `pca.fsx`. Add in the following
    code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将另一个脚本文件添加到你的项目中，并将其命名为`pca.fsx`。添加以下代码：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Sending this to the FSI gives the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到FSI将得到以下结果：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, the `sourceMatix` is a list of students that studied for a certain
    number of hours for an exam and the number of beers that they consumed before
    the exam. For example, the first student studied 2.5 hours and drank 2.4 beers.
    Unlike similar examples you have seen in the book so far, you will notice that
    there is not a dependent variable (Y) in this frame. We don't know if these students
    passed or not. But with just these features, we can determine which ones would
    be the most useful for an analysis. You might be saying to yourself, "How is that
    possible?" Without going too much into the math, the PCA will look at the variance
    of each of the variables under a series of scenarios. If the variable can explain
    differences, it is given a higher score. If it cannot, it is given a lower one.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`sourceMatrix`是一个学生列表，这些学生在考试前学习了一定小时数，并在考试前喝了多少啤酒。例如，第一个学生学习了2.5小时，喝了2.4杯啤酒。与你在书中看到的类似例子不同，你会注意到这个框架中没有因变量（Y）。我们不知道这些学生是否通过了考试。但仅凭这些特征，我们可以确定哪些特征对分析最有用。你可能会对自己说：“这怎么可能？”不深入数学的话，PCA将查看一系列场景下每个变量的方差。如果一个变量可以解释差异，它将得到更高的分数。如果它不能，它将得到较低的分数。
- en: 'Let''s see what PCA tells us about this dataset. Enter this code into the script:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看PCA关于这个数据集告诉我们什么。将以下代码输入到脚本中：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Sending this to the REPL, we will get the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，我们将得到以下结果：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You will notice that the output of the `ComponentMatrix` property is a 2 x 2
    array with the complementary value as a cross. In formal terms, this jagged array
    is called an eigenvector and the contents of the array are called eigenvalues.
    If you start working deeply with PCA, you will need to come up to speed with what
    those words mean and the implications of the values. For our purposes here, we
    can safely ignore these values (unless you want to toss around the word, eigenvalue,
    at your next family gathering).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`ComponentMatrix`属性的输出是一个2 x 2的数组，互补值以交叉形式表示。在正式术语中，这个锯齿形数组被称为特征向量，数组的内容被称为特征值。如果你开始深入研究PCA，你需要了解这些词汇的含义以及这些值的含义。对于我们这里的用途，我们可以安全地忽略这些值（除非你想要在下次家庭聚会中提及“特征值”这个词）。
- en: 'The important property that we do need to pay attention to with PCA is the
    component proportions. Go back to the script file and enter this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在PCA中，我们需要特别注意的一个重要属性是成分比例。回到脚本文件，输入以下内容：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Sending this to the REPL gives the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL将得到以下结果：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These values are important for our analysis. Notice how adding these two values
    together amounts to 100 percent? These percentages tell you the amount of variance
    (and therefore the amount of usefulness) in the data frame. In this case, the
    hours of studying is 96 percent of the variance with the amount of beer being
    only 4 percent, so if we wanted to use this data in some kind of analysis, we
    would certainly pick the hours of studying and safely discard the beer drinking.
    Note that if we increased the range of beers being drunk, the percentages would
    shift and perhaps we would want to use both variables. This is a fairly simple
    example with two features. PCA really shines when you have lots and lots of features
    and you need to determine their usefulness.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值对我们的分析很重要。注意，将这两个值相加等于 100 百分比？这些百分比告诉你数据框中的方差量（因此是数据的有用性量）。在这种情况下，学习时间是
    96 百分比的方差，而啤酒量只有 4 百分比，所以如果我们想用这种数据进行分析，我们肯定会选择学习时间，并安全地丢弃饮酒。注意，如果我们增加了饮酒的啤酒范围，百分比会发生变化，我们可能希望使用这两个变量。这是一个有两个特征的简单示例。PCA
    在你有大量特征并且需要确定它们的有用性时表现得尤为出色。
- en: Traffic stop and crash exploration
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交通拦截和事故探索
- en: 'With the k-means and PCA theory under our belts, let''s see what we can do
    with open data. If you remember, we had a dataset for traffic stops. Let''s bring
    in two more datasets: the number of car crashes over the same time period, and
    also the amount of precipitation on the day of the crash/ticket.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握 k-means 和 PCA 理论之后，让我们看看我们可以用开放数据做什么。如果你记得，我们有一个关于交通拦截的数据集。让我们再引入两个数据集：同一时间段内的汽车事故数量，以及事故/罚单当天降水量。
- en: Preparing the script and the data
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备脚本和数据
- en: 'In Visual Studio, create a new Visual F# Library Project called `Hack4Good.Traffic`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，创建一个名为 `Hack4Good.Traffic` 的新 Visual F# 库项目：
- en: '![Preparing the script and the data](img/00090.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![准备脚本和数据](img/00090.jpeg)'
- en: 'Once the project is created, rename the `Script.fsx` file to `Clustering.fsx`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建完成后，将 `Script.fsx` 文件重命名为 `Clustering.fsx`：
- en: '![Preparing the script and the data](img/00091.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![准备脚本和数据](img/00091.jpeg)'
- en: 'Next, open the NuGet Package Manager console and enter this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 NuGet 包管理器控制台，并输入以下内容：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside `Clustering.fsx`, enter in the following code into the script:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Clustering.fsx` 中，将以下代码输入到脚本中：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you send this to the FSI, you will see the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将此发送到 FSI 时，你会看到以下内容：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With this prep code out of the way, let''s bring down the stop data from the
    database. Put the following code into the script file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些准备工作后，让我们从数据库中获取停止数据。将以下代码放入脚本文件中：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When you send it to the REPL, you will see the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将其发送到 REPL 时，你会看到以下内容：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'All of this data should be familiar to you from [Chapter 4](part0032_split_000.html#UGI01-a18db0be6c20485ba81f22e43ca13055
    "Chapter 4. Traffic Stops – Barking Up the Wrong Tree?"), *Traffic Stops – Barking
    Up the Wrong Tree?*. The only real difference is that there is now a geolocation
    type that holds both latitude and longitude. Notice that we assign whatever values
    are in the database first in this line:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数据都应该对你熟悉，来自[第 4 章](part0032_split_000.html#UGI01-a18db0be6c20485ba81f22e43ca13055
    "第 4 章。交通拦截 – 是否走错了路？")，*交通拦截 – 是否走错了路？*。唯一的真正区别是现在有一个包含纬度和经度的地理位置类型。注意，我们在这一行中首先分配数据库中的任何值：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Also, you will notice that we are making the values to three decimal point
    precision with the `Math.Round`. With this data local, let''s bring in the crash
    data. Enter the following code into the script:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还会注意到我们正在使用 `Math.Round` 将值保留到小数点后三位精度。有了这些本地数据，让我们引入事故数据。将以下代码输入到脚本中：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Sending this to the FSI gives us the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到 FSI 给出以下结果：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have one more dataset we want to use: the traffic conditions for each day.
    Enter the following into the script:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个数据集想要使用：每天的交通状况。将以下内容输入到脚本中：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Sending this to the FSI gives us the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到 FSI 给出以下结果：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With these three datasets available, let's combine the traffic stop and traffic
    crash datasets together into a single data frame to see if there is anything going
    on with geolocation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有这三个数据集可用，让我们将交通拦截和交通事故数据集合并成一个数据框，看看是否有关于地理位置的任何情况。
- en: Geolocation analysis
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地理位置分析
- en: 'Go to the script file and add the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前往脚本文件，并添加以下内容：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Sending this to the REPL gives us the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到 REPL 给出以下结果：
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code should look familiar to you by now; we are counting up the number
    of traffic stops by geolocation. For the first record, geopoint 35.789/-78.829
    had 178 traffic stops.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这段代码应该对你来说已经很熟悉了；我们正在按地理位置统计交通停驶的数量。对于第一条记录，地理点35.789/-78.829有178次交通停驶。
- en: 'Next, go back to the script and enter the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，返回脚本并输入以下内容：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Sending this to the REPL gives us the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，我们得到以下结果：
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code is identical to the stop data; we are counting up the number of traffic
    crashes by geolocation. For the first record, geopoint 35.790/-78.781 had 51 traffic
    crashes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与停驶数据相同；我们正在按地理位置统计交通事故的数量。对于第一条记录，地理点35.790/-78.781有51次交通事故。
- en: 'Our next step is to combine these two datasets into a single data frame that
    we can send to Accord. As for most things in F#, let''s use types and functions
    to achieve this. Go back to the script file and enter the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的步骤是将这两个数据集合并成一个单一的数据框，我们可以将其发送到Accord。至于F#中的大多数事情，让我们使用类型和函数来实现这一点。返回脚本文件并输入以下内容：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When you send this to the FSI, you will see something like the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将此发送到FSI时，你会看到如下类似的内容：
- en: '[PRE33]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There is some new code here that can seem intimidating at first (at least,
    it was to me). We are using the LINQ class Enumerable''s *Join* method to join
    the `crashData` and `stopData` together. The *Join* method takes in several parameters:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新的代码，一开始可能会让人感到有些难以理解（至少对我来说是这样的）。我们正在使用LINQ类`Enumerable`的`Join`方法将`crashData`和`stopData`连接起来。`Join`方法接受几个参数：
- en: The first dataset (in this case `crashData`).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个数据集（在这种情况下为`crashData`）。
- en: The second dataset (in this case `stopData`).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个数据集（在这种情况下为`stopData`）。
- en: A lambda that extracts the value from the first dataset, which we will use to
    join. In this case, the first item of the tuple, which is the geolocation value.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个lambda表达式，用于从第一个数据集中提取值，我们将使用它来进行连接。在这种情况下，元组的第一个元素，即地理位置值。
- en: A lambda that extracts the value from the second dataset, which we will use
    to join. In this case, the first item of the tuple, which is the geolocation value.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个lambda表达式，用于从第二个数据集中提取值，我们将使用它来进行连接。在这种情况下，元组的第一个元素，即地理位置值。
- en: A lambda that specifies what the output of the join operation will look like.
    In this case, it is the record type called `GeoTraffic` that we defined on the
    first line of this code block.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个lambda表达式，指定连接操作输出的样子。在这种情况下，它是我们在这段代码块的第一个语句中定义的名为`GeoTraffic`的记录类型。
- en: The key thing to realize about using the Join method is that it only keeps records
    that are in both datasets (an inner join to you SQL fans). This means if there
    is a geolocation that has one traffic ticket and no traffic stops, it is dropped
    from our analysis. If you want to do an outer join, there is the *GroupJoin* method
    that does this. Since we are only really interested in high-activity areas, an
    inner join seems more appropriate.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用Join方法的关键一点是要意识到它只保留两个数据集中都存在的记录（对于SQL爱好者来说，这是一个内连接）。这意味着如果一个地理位置有一个交通罚单但没有交通停驶，它将从我们的分析中删除。如果你想要进行外连接，有`GroupJoin`方法可以实现这一点。由于我们真正感兴趣的是高活动区域，因此内连接似乎更合适。
- en: 'With our data frame created, we are now ready to send the data to Accord''s
    k-means. If you remember, Accord''s k-means wants the input to be a jagged array
    of floats. Therefore, we have one last transformation. Go to the script file and
    enter the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数据框后，我们现在准备将数据发送到Accord的k-means。如果你还记得，Accord的k-means需要输入是一个浮点数的不规则数组。因此，我们有一个最后的转换。转到脚本文件并输入以下内容：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Sending to the FSI, we get the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到FSI，我们得到以下结果：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Go back to the script file and enter the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 返回脚本文件，并输入以下内容：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Sending to the REPL, we will get the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到REPL，我们将得到以下结果：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Woot! We have a k-means working on our traffic data. If you inspect each of
    the clusters, you will see the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们正在对交通数据进行k-means聚类。如果你检查每个簇，你会看到以下内容：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We have three clusters. I pulled the means and the proportions from each of
    the clusters and put them into a spreadsheet like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个簇。我从每个簇中提取了平均值和比例，并将它们放入如下所示的电子表格中：
- en: '| Crashes | Stops | % of records |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 事故 | 停驶 | 记录百分比 |'
- en: '| --- | --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 67.5 | 6.48 | 20.2% |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 67.5 | 6.48 | 20.2% |'
- en: '| 11.69 | 2.62 | 76.3% |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 11.69 | 2.62 | 76.3% |'
- en: '| 188.87 | 13.35 | 4.5% |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 188.87 | 13.35 | 4.5% |'
- en: 'Looking at all the three clusters, it is notable that there are a lot more
    traffic crashes than stops. Also of interest is that the first and second cluster
    have about a 10:1 ratio of crashes to stops but the really high crash areas have
    a higher proportion of crashes to stops—about 14:1\. It seems reasonable to conclude
    that there are a few high-crash areas in town and the police are very active there,
    but they could be even more active. I would name each cluster after their activity
    level: (low, medium, and high). If the geolocation was not in our data frame (a
    majority of the points in town), we could call that *no activity*.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 观察所有三个聚类，值得注意的是交通事故比检查次数多得多。同样值得注意的是，第一和第二个聚类的事故与检查的比例大约是10:1，但真正高事故区域的事故与检查的比例更高——大约14:1。似乎有理由得出结论，城镇中有几个高事故区域，警察在那里非常活跃，但他们可能更加活跃。我会根据它们的活跃度给每个聚类命名：（低、中、高）。如果地理位置不在我们的数据框中（城镇中的大多数点），我们可以称之为“无活动”。
- en: 'Finally, enter this into the script file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下内容输入到脚本文件中：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Sending this to the FSI gives us the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些发送到FSI后，我们得到以下结果：
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We have seen `.zip` before. We are merging our data frame that contains the
    geolocation, number of stops, and number of crashes with the labels frame that
    came out k-means. Then we can look up a given geolocation and see its cluster
    assignment. For example, geolocation 35.790/-78.781 is in Cluster 1—or medium
    activity.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经见过`.zip`格式。我们现在将包含地理位置、停靠次数和事故次数的数据框与通过k-means得到的标签框合并。然后我们可以查找一个特定的地理位置并查看其聚类分配。例如，地理位置35.790/-78.781位于聚类1——中等活跃度。
- en: PCA
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PCA
- en: Now that we have a pretty good sense of the data via k-means, let's see if we
    can use PCA to uncover even more insights in our traffic data. Instead of location,
    let's look at date. As we found in [Chapter 4](part0032_split_000.html#UGI01-a18db0be6c20485ba81f22e43ca13055
    "Chapter 4. Traffic Stops – Barking Up the Wrong Tree?"), *Traffic Stops – Barking
    Up the Wrong Tree?*, using our decision tree, there was nothing we could conclude
    with different bins of date/time and our traffic tickets. Perhaps augmenting the
    stop data with crash and weather will lead to something.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过k-means对数据有了相当好的了解，让我们看看是否可以使用PCA来揭示我们交通数据中的更多洞察。而不是看位置，让我们看看日期。正如我们在[第4章](part0032_split_000.html#UGI01-a18db0be6c20485ba81f22e43ca13055
    "第4章。交通检查——走错了方向？")中找到的，“交通检查——走错了方向？”，使用我们的决策树，我们无法从不同时间段的日期/时间与交通罚单中得出任何结论。也许通过增加事故和天气数据到检查数据中会有所帮助。
- en: 'Go back into the `Clustering.fsx` script file and enter the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`Clustering.fsx`脚本文件，并输入以下内容：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Sending this to the FSI gives the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些发送到FSI后，我们得到以下结果：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code is very much like the code we already wrote when creating the `crashData`
    for k-means. In this case, we are counting up traffic crashes by `DayOfYear`.
    `DayOfYear` assigns each day of the year an index value. For example, January
    1 gets a 1, January 2 gets a 2 and December 31 gets a 365 or 366, depending on
    if it is a leap year or not. Notice that it is one-based because `DateTime.DayOfYear`
    is one-based.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们之前创建k-means的`crashData`时编写的代码非常相似。在这种情况下，我们是通过`DayOfYear`来统计交通事故的。`DayOfYear`将每年的每一天分配一个索引值。例如，1月1日得到1，1月2日得到2，12月31日得到365或366，这取决于是否是闰年。注意，它是基于1的，因为`DateTime.DayOfYear`是基于1的。
- en: 'Go back into the script file and enter the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到脚本文件并输入以下内容：
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Sending this to the FSI gives us the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些发送到FSI后，我们得到以下结果：
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you can probably guess, this sums up the number of traffic stops by the
    day of the year. Pressing onward, go to the script file and enter the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所能猜到的，这是按年度天数汇总的交通检查次数。继续前进，进入脚本文件并输入以下内容：
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Sending this to the REPL gives us the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些发送到REPL后，我们得到以下结果：
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Just like crash and stop data, this creates a dataset with the amount of precipitation
    by day of year. You will notice that the data was already at the date level (sometimes
    called the level of atomicity), so an `Array.map` was used to transform the date;
    we don't need to use `countBy`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就像事故和检查数据一样，这创建了一个按年度天数汇总的降水量数据集。你会注意到数据已经处于日期级别（有时称为原子级别），所以使用了`Array.map`来转换日期；我们不需要使用`countBy`。
- en: 'With the initial datasets created, we now need a way to join all three together.
    The `Enumerable.Join` method that we used in the k-means example will not do here,
    so we will have to build our own joiner function. Go into the script file and
    enter the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了初始数据集之后，我们现在需要一种方法来将这三个数据集合并在一起。我们在 k-means 示例中使用的 `Enumerable.Join` 方法在这里不适用，因此我们必须构建自己的连接函数。进入脚本文件，输入以下内容：
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When you send this to the FSI, you will get the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将此发送到 FSI 时，你会得到以下结果：
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This is a pretty complicated function signature. It might help if I added parameter
    hints to the method as shown in the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当复杂的函数签名。如果我在方法中添加参数提示，可能会有所帮助，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When you send this to the FSI, you will get the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将其发送到 FSI 时，你会得到以下结果：
- en: '[PRE50]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This should be slightly more accessible but less generic, which is fine because
    all of our datasets (crash, stops, and weather) are arrays of `int*int`. Reading
    the output, we see that `getItem` is a function that takes in one parameter named
    dataset that is an array of `int` tuples `(int * int)[]` and another parameter
    named item that is an int. The function then attempts to find the tuple in the
    array whose `fst` has the same value as the item. If it is found, it returns the
    second value of the tuple. If it does not find the item in the array, it returns
    `0`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该更容易访问但不太通用，这是可以接受的，因为我们的所有数据集（事故、停车和天气）都是 `int*int` 的数组。阅读输出，我们看到 `getItem`
    是一个接受一个名为 `dataset` 的参数的函数，该参数是一个 `int` 元组的数组 `(int * int)[]`，另一个参数名为 `item`，也是一个
    `int`。函数随后尝试在数组中找到其 `fst` 值与项目相同的元组。如果找到了，它返回元组的第二个值。如果没有在数组中找到项目，它返回 `0`。
- en: This function will work well for all three of our datasets (crash, stops, and
    weather) because all three only hold records for days they have observations.
    For traffic stops, this is not a problem because there was at least one traffic
    stop on each day of the year. However, there were 16 days where there were no
    traffic crashes recorded, so `stopData` has 350 records and there were over 250
    days where there was not any precipitation, so `weatherData` only has 114 records.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将适用于我们所有的三个数据集（事故、停车和天气），因为这三个数据集只包含有观测记录的日期。对于交通停车来说，这不是问题，因为每年每天都有至少一次交通停车。然而，有16天没有记录交通事故，所以
    `stopData` 有350条记录，而且有超过250天没有降水，所以 `weatherData` 只有114条记录。
- en: Since the first way of creating `getItem` is more generic and idiomatic to F#,
    I will use it for the remaining part of the chapter. Both the examples are in
    the example script file that you can download.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一种创建 `getItem` 的方法更通用且更符合 F# 的习惯用法，我将使用它来完成本章的剩余部分。这两个例子都在你可以下载的示例脚本文件中。
- en: 'Going back to the script, enter the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 回到脚本中，输入以下内容：
- en: '[PRE51]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When you send this to the REPL, you will see the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将此发送到 REPL 时，你会看到以下内容：
- en: '[PRE52]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first line creates a record type that contains the number of crashes, stops,
    and precipitation for the day. I used rain as the field name because we rarely
    get snow in North Carolina and I want to rub it in to any reader who lives up
    north. Of course, when we do get snow, it is borderline Armageddon.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个包含当天事故、停车和降水的记录类型。我使用“rain”作为字段名，因为我们很少在北卡罗来纳州下雪，我想让任何住在北方的读者都感到这一点。当然，当我们确实下雪时，那几乎就是世界末日。
- en: 'The next block of code is where we create our final data frame. First, an integer
    array is created with every day of the year. A mapper function is then applied
    that calls `getItem` three times for each item of the array: the first time for
    `crashData`, the second for stop data, and finally for weather data. The results
    are put into the `TrafficDay` record.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块是我们创建最终数据帧的地方。首先，创建了一个包含全年每一天的整数数组。然后应用了一个映射函数，为数组中的每个项目调用 `getItem` 三次：第一次为
    `crashData`，第二次为停车数据，最后为天气数据。结果被放入 `TrafficDay` 记录中。
- en: 'With the data frame setup, we are now ready for Accord. Go to the script file
    and enter the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 数据帧设置完成后，我们现在可以为 Accord 准备了。转到脚本文件，输入以下内容：
- en: '[PRE53]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When you send it to the REPL, you will get the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将其发送到 REPL 时，你会得到以下结果：
- en: '[PRE54]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This is a jagged array that Accord wants. Go back to the script and enter the
    following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Accord 所需要的锯齿数组。回到脚本中，输入以下内容：
- en: '[PRE55]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When you send this to the REPL, you will get the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将此发送到 REPL 时，你会得到以下结果：
- en: '[PRE56]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This shows that 94 percent of the variance in our data frame is from crashes,
    not stops or the weather. This is interesting because common wisdom is that, once
    it rains (or <gasp> snows <gasp>) in North Carolina, traffic accidents spike.
    Although that might make a good press story, this one-year sample does not bear
    it out.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们数据框中94%的方差来自事故，而不是停车或天气。这很有趣，因为常识认为，一旦在北卡罗来纳州下雨（或者<gasp>下雪 <gasp>），交通事故就会激增。尽管这可能是一个好的新闻报道，但这一年的样本并没有证实这一点。
- en: Analysis summary
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析摘要
- en: 'We now have a couple of models that point to some interesting ideas:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有几个模型指向一些有趣的想法：
- en: There are a few locations that account for most of the traffic crashes and tickets
    in town
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有几个地点占用了城镇大部分的交通事故和罚单
- en: Weather is not as important as you might think
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天气并不像你想象的那么重要
- en: With this knowledge, we are ready to put machine learning to work for us.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识，我们准备好将机器学习应用于实践。
- en: The Code-4-Good application
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Code-4-Good应用程序
- en: Let's create a Windows application that helps people drive more safely. In addition,
    let's make the application "smart" so that it will progressively get more accurate.
    Let's start in Visual Studio with the project you have already created.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个帮助人们更安全驾驶的Windows应用程序。此外，让我们使应用程序变得“智能”，这样它将逐渐变得更加准确。让我们从Visual Studio中已经创建的项目开始。
- en: Machine learning assembly
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器学习组件
- en: 'Go into the **Solution** **Explorer** and rename `Library1.fs` to `TrafficML.fs`.
    Add a reference to `System.Data`, `System.Data.Entity`, `System.Data.Linq`, and
    `FSharp.Data.TypeProviders`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 进入**解决方案****资源管理器**，将`Library1.fs`重命名为`TrafficML.fs`。添加对`System.Data`、`System.Data.Entity`、`System.Data.Linq`和`FSharp.Data.TypeProviders`的引用：
- en: '![Machine learning assembly](img/00092.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![机器学习组件](img/00092.jpeg)'
- en: Adding references
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 添加引用
- en: 'Go into the `TrafficML.fs` file and enter the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`TrafficML.fs`文件并输入以下代码：
- en: '[PRE57]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: I know it feels weird not to send code you just wrote to FSI, but there is no
    way of getting immediate feedback of the code you wrote in a compliable file.
    We will be addressing this in the next chapter when we talk TDD. Until then, just
    compile the project to make sure you are on the right track.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道不将你刚刚编写的代码发送到FSI感觉有点奇怪，但没有办法立即从可编译文件中获取你编写的代码的反馈。我们将在下一章讨论TDD时解决这个问题。在此之前，只需编译项目以确保你走在正确的轨道上。
- en: 'Back to the `TrafficML.fs` file, enter the following wall of code or copy it
    from the book''s download:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`TrafficML.fs`文件，输入以下代码块或从书籍的下载中复制：
- en: '[PRE58]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This code is very similar to the k-means code we wrote in the `Clustering.fsx`
    script file. Notice that all the work of getting the data, shaping it, and running
    a k-means on it happens in the constructor of the `TrafficML` type. This means
    every time you create a new instance of the class from another location, you are
    making database calls and running the model. Also, notice that the connection
    string is hardcoded into the `SqlEntity` type provider for the type but then passed
    in via the constructor parameter when `GetDataContext()` is actually called. This
    allows you to move to code around environments (dev/test/prod). The downside is
    that you need to have your DEV environment exposed always so that the type is
    generated. One way to avoid this is to hardcode your Entity Framework `.edmx`/schema
    into the project.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们之前在`Clustering.fsx`脚本文件中编写的k-means代码非常相似。请注意，获取数据、塑造数据和在其上运行k-means的所有工作都在`TrafficML`类型的构造函数中完成。这意味着每次从另一个位置创建类的新的实例时，你都在进行数据库调用并运行模型。此外，请注意，连接字符串被硬编码到`SqlEntity`类型提供者中，但在调用`GetDataContext()`时通过构造函数参数传递。这允许你在不同的环境中移动代码（开发/测试/生产）。缺点是您需要始终暴露您的开发环境，以便生成类型。避免这种情况的一种方法是将您的Entity
    Framework `.edmx`/架构硬编码到项目中。
- en: 'Go back to the `TrafficML.fs` file and enter in the following function to the
    `TrafficML` type:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`TrafficML.fs`文件，并在`TrafficML`类型中输入以下函数：
- en: '[PRE59]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This does a search of the geolocations. If there is a match, the cluster is
    returned. If there is no match, *a-1* is returned, signifying that there was not
    a match. We now have enough to make a first pass at creating a real time "smart"
    traffic application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这将搜索地理位置。如果有匹配项，则返回簇。如果没有匹配项，则返回*a-1*，表示没有匹配项。我们现在有足够的内容来尝试创建一个实时“智能”交通应用程序。
- en: The UI
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户界面
- en: 'In the **Solution Explorer**, add a new Visual C# WPF Application:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中，添加一个新的Visual C# WPF应用程序：
- en: '![The UI](img/00093.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面](img/00093.jpeg)'
- en: 'After the project is created, add a reference from the C# UI project to the
    F# one, `System.Configuration` and `System.Device`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建完成后，将 C# UI 项目添加到 F# 项目中，引用 `System.Configuration` 和 `System.Device`：
- en: '![The UI](img/00094.jpeg)![The UI](img/00095.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![UI](img/00094.jpeg)![UI](img/00095.jpeg)'
- en: As a quick preparatory note, you are supposed to follow MVVM and command relay
    patterns when writing WFP applications which we will not cover in this book. This
    is a book about machine learning, not coddling humans via a delightful UI, so
    I code up enough of the UI just to get it to work. If you are interested in doing
    WPF following best practices, consider *Windows Presentation Foundation 4.5 Cookbook*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速预备说明，当你编写 WFP 应用程序时，应该遵循 MVVM 和命令中继模式，这在本书中不会涉及。这是一本关于机器学习的书，而不是通过令人愉悦的
    UI 来宠爱人类，所以我只编写足够的 UI 代码，以便使其工作。如果你对遵循最佳实践进行 WPF 开发感兴趣，可以考虑阅读 *Windows Presentation
    Foundation 4.5 Cookbook*。
- en: 'Inside the UI project, open up the `MainWindow.xaml` file, locate the `Grid`
    element, and enter in this XAML inside the grid:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UI 项目中，打开 `MainWindow.xaml` 文件，找到 `Grid` 元素，并在网格中输入以下 XAML：
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, open up `MainWindow.xaml.cs` and enter the following `using` statements
    to the block of `using` at the top of the file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `MainWindow.xaml.cs` 文件，并将以下 `using` 语句添加到文件顶部的 `using` 块中：
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Your file should look like the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你的文件应该看起来像下面这样：
- en: '![The UI](img/00096.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![UI](img/00096.jpeg)'
- en: 'Inside the `MainWindow` class, enter three class-level variables:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainWindow` 类内部，输入三个类级别变量：
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Your file should look like the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你的文件应该看起来像下面这样：
- en: '![The UI](img/00097.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![UI](img/00097.jpeg)'
- en: 'Then, in the `MainWindow()` constructor, add in the following code below `InitializeComponent()`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `MainWindow()` 构造函数中，在 `InitializeComponent()` 下方添加以下代码：
- en: '[PRE63]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Your file should look like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你的文件应该看起来像这样：
- en: '![The UI](img/00098.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![UI](img/00098.jpeg)'
- en: 'Next, create the `Watcher_PositionChanged` method for the event handler:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为事件处理器创建 `Watcher_PositionChanged` 方法：
- en: '[PRE64]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, create a loop to refresh the `MachineLearning` model every minute:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个循环，每分钟刷新一次 `MachineLearning` 模型：
- en: '[PRE65]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, add an event handler placeholder for the button clicks on the screen:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为屏幕上的按钮点击添加事件处理器占位符：
- en: '[PRE66]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If you collapse the code to definitions (*CTRL* + *M*, *L*), your code should
    look like the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将代码折叠到定义中（*CTRL* + *M*, *L*），你的代码应该看起来如下：
- en: '![The UI](img/00099.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![UI](img/00099.jpeg)'
- en: 'Next, go into **Solution Explorer**, right-click to add a new **Application
    Configuration** file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进入 **解决方案资源管理器**，右键单击以添加一个新的 **应用程序配置** 文件：
- en: '![The UI](img/00100.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![UI](img/00100.jpeg)'
- en: Adding new Application Configuration file
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的应用程序配置文件
- en: 'Inside that `app.config` file, replace the contents with this XML (replace
    the connection string with your connection string if you are using a local instance
    of the database):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个 `app.config` 文件中，将内容替换为以下 XML（如果你使用的是本地数据库实例，请将连接字符串替换为你的连接字符串）：
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Go to **Solution** **Explorer** and make the UI project the startup project:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 **解决方案资源管理器** 并将 UI 项目设置为启动项目：
- en: '![The UI](img/00101.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![UI](img/00101.jpeg)'
- en: 'Compile your project. If all is well, try to run it. You should get a warning
    dialog like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 编译你的项目。如果一切顺利，尝试运行它。你应该会得到一个警告对话框，如下所示：
- en: '![The UI](img/00102.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![UI](img/00102.jpeg)'
- en: 'And then you will get a screen like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会看到一个类似这样的屏幕：
- en: '![The UI](img/00103.jpeg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![UI](img/00103.jpeg)'
- en: Once you completely take in the awesomeness of the user experience, stop running
    the application. So far, this is pretty good. If we put this application on a
    location-aware device (like a GPS) in the car and drive around, the status bar
    will warn us if we are within a quarter mile of a geolocation that might have
    a crash or stop risk. However, if we want to give ourselves more of a heads up,
    we need to add a bit more of code.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完全领略了用户体验的奇妙，停止运行应用程序。到目前为止，这已经相当不错了。如果我们把这个应用程序放在车载的位置感知设备（如 GPS）上并四处驾驶，状态栏会警告我们是否在可能发生事故或停车风险的地理位置四分之一英里范围内。然而，如果我们想给自己更多的提醒，我们需要添加更多的代码。
- en: Adding distance calculations
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加距离计算
- en: 'Go back to the F# project and open up the `TrafficML.fs` file. Locate the last
    line of the constructor. It looks like the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 F# 项目并打开 `TrafficML.fs` 文件。找到构造函数的最后一行。代码看起来如下：
- en: '[PRE68]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Below this line, enter the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在此行下方，输入以下内容：
- en: '[PRE69]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: These two functions allow us to calculate the distance between geolocations.
    Since the earth is curved, we can't simply subtract the latitudes and longitudes
    between the two geolocations. The Haversine formula is the most common way to
    do this calculation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数允许我们计算地理位置之间的距离。由于地球是弯曲的，我们不能简单地从两个地理位置的纬度和经度中减去。Haversine公式是进行这种计算最常见的方法。
- en: 'Go to the end of the file and add the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 前往文件末尾并添加以下内容：
- en: '[PRE70]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: What we are doing is overloading the `GetCluster` function with an additional
    parameter called distance. Using this input distance, we can calculate how far
    it is between the geolocation parameter and every geolocation in our `trafficGeo`
    array. If there are any matches, we sort by the highest number of cluster (`sortByDescending`)
    and return it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在做的是通过一个额外的参数`distance`来重载`GetCluster`函数。使用这个输入距离，我们可以计算出地理位置参数和我们的`trafficGeo`数组中的每个地理位置之间的距离。如果有任何匹配项，我们按簇数量最多的进行排序（`sortByDescending`），然后返回它。
- en: 'Go back to our UI project and open the `MainWindow.xaml.cs` file and locate
    the `Watcher_PositionChanged` method. Find the following line of code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 返回我们的用户界面项目，打开`MainWindow.xaml.cs`文件，找到`Watcher_PositionChanged`方法。找到以下代码行：
- en: '[PRE71]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Replace it with the following line of code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 替换为以下代码行：
- en: '[PRE72]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We now have a two mile heads-up to any problem area on the roads.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对道路上的任何问题区域都有了两英里的预警。
- en: Augmenting with human observations
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加人工观察
- en: There is one more thing we want to do to our UI. If you look at some of the
    *crowd source* road applications like Waze, they provide real-time notifications.
    Our app bases its classification based on historical data. However, if we were
    driving down the street in an area that was classified as *low risk*, and we saw
    a traffic crash, we would want to elevate the location to a *high risk*. Ideally,
    all the users of our application would get this update and override the model's
    classification of the geolocation (at least for the time being) and then we would
    update our database so that, as we retrain our model, the information gets more
    accurate.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想对我们的用户界面做一些改动。如果你看看一些像Waze这样的*众包*道路应用，它们提供实时通知。我们的应用基于历史数据来进行分类。然而，如果我们正在一个被归类为*低风险*的地区街道上驾驶，并且我们看到一起交通事故，我们希望将这个位置提升到*高风险*。理想情况下，我们应用的所有用户都能收到这个更新，并覆盖模型对地理位置的分类（至少暂时如此），然后我们会更新我们的数据库，以便在我们重新训练模型时，信息变得更加准确。
- en: 'Go to the `notifyButton_Click` event holder and replace `//TODO` with the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 前往`notifyButton_Click`事件处理程序，将`//TODO`替换为以下内容：
- en: '[PRE73]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The compiler will complain to you because we have not implemented the `AddGeolocationToClusterOverride`
    yet. Go back over to the F# project and open the `TrafficML.fs` file. At the very
    bottom, add the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会向你抱怨，因为我们还没有实现`AddGeolocationToClusterOverride`。回到F#项目，打开`TrafficML.fs`文件。在文件的底部，添加以下内容：
- en: '[PRE74]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We now have a way of updating the database for any override. Note that you
    will not be able to write to the shared database on Azure that was created for
    this book, but you will be able to write to your local copy. As a final step,
    go up to where we created the `trafficGeo` on the following line:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一种方法可以更新任何覆盖的数据库。请注意，你将无法写入为这本书创建的Azure上的共享数据库，但你将能够写入你的本地副本。作为最后一步，回到我们创建`trafficGeo`的以下行：
- en: '[PRE75]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Replace that line with the following code block:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将该行替换为以下代码块：
- en: '[PRE76]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This block goes to the database and pulls down all overrides that occurred within
    the last 5 minutes and places them in the overrides array. It then creates a function
    called `checkForOverride` that takes in the `geoTraffic` value. If the latitude
    and longitude match the override table, the `geoTraffic` value is replaced with
    a new value that has the override value assigned by the database and not from
    the k-means model. If no match is found, the original value is returned. Finally,
    we pipe this function to the creation of `trafficGeo`. Note that if you try and
    execute this on our shared server, it will throw an exception because you don't
    have rights to write to the database. Hopefully, though, the intention is clear
    with this example. With that, we have a real-time system where we combine machine
    learning and human observations to give our end user the best possible predictions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此块将数据传输到数据库，并拉取过去5分钟内发生的所有覆盖项，并将它们放入覆盖数组中。然后，它创建了一个名为`checkForOverride`的函数，该函数接受`geoTraffic`值。如果纬度和经度与覆盖表匹配，则将`geoTraffic`值替换为数据库分配的新值，而不是来自k-means模型的新值。如果没有找到匹配项，则返回原始值。最后，我们将此函数管道到`trafficGeo`的创建中。请注意，如果您尝试在我们的共享服务器上执行此操作，它将抛出一个异常，因为您没有权限写入数据库。然而，通过这个例子，希望意图是清晰的。有了这个，我们有一个实时系统，它结合了机器学习和人类观察，为我们最终用户提供最佳的可能预测。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot of ground in this chapter. We looked at k-means and PCA to
    help us find hidden relationships in our traffic datasets. We then built an application
    that took advantage of the insights we gleaned to make drivers more aware and,
    hopefully, safer. This application is unique because it blended both real-time
    machine learning modeling and human observations to provide the best possible
    outcome for the driver.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容。我们探讨了k-means和PCA算法，以帮助我们找到交通数据集中的隐藏关系。然后，我们构建了一个应用程序，利用我们获得的洞察力使驾驶员更加警觉，并希望他们能更安全。这个应用程序的独特之处在于它结合了实时机器学习建模和人类观察，为驾驶员提供最佳的可能结果。
- en: In the next chapter, we are going to look at some of the limitations of our
    coding so far in this book and see if we can improve on both model and feature
    selection.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨我们在这本书中迄今为止的编码的一些局限性，并看看我们是否可以改进模型和特征选择。
