["```py\n    from flask import Flask\n    ```", "```py\n    app = Flask(__name__)\n    ```", "```py\n    @app.route('/')\n    def biotech():\n        return \"Hello Biotech World!\"\n    ```", "```py\n    if __name__ == '__main__':\n        app.run(debug=True, port=8080)\n    ```", "```py\n    http://localhost:8080/. Upon reaching this URL, you should be greeted by our previous message. Please note that the localhost URL is a link only accessible locally on your computer and is not available to others. The concept of routes should be familiar to us from the many websites we have used in the past. We can break down a URL into its smaller components, as depicted in *Figure 11.7*:\n    ```", "```py\n$ python38 virtualenv .venv\n```", "```py\n> .\\.venv\\Scripts\\activate\n```", "```py\n$ source .venv\\bin\\activate\n```", "```py\nfrom flask import Flask, jsonify, request, render_template \nimport json\nfrom transformers import pipeline\nimport re\n```", "```py\napp = Flask(__name__, template_folder='templates')\n```", "```py\nsummarizer = pipeline(\"summarization\")\n```", "```py\n@app.route('/')\ndef home():\n    return render_template('index.html')\n```", "```py\n@app.route('/prediction', methods = [\"POST\"])\ndef ui_prediction():\n    \"\"\"\n    A function that takes a JSON with two fields: \"text\" & \"maxlen\"\n    Returns: the summarized text of the paragraphs.\n    \"\"\"\n    print(request.form.values())\n    paragraphs = request.form.get(\"paragraphs\")\n    paragraphs = re.sub(\"\\d+\", \"\", paragraphs)\n    maxlen = int(request.form.get(\"maxlen\"))\n    summary = summarizer(paragraphs, max_length=maxlen, min_length=49, do_sample=False)\n    return render_template('index.html', prediction_text = '\" {} \"'.format(summary[0][\"summary_text\"])), 200\n```", "```py\n@app.route('/api/prediction', methods = [\"POST\"])\ndef api_prediction():\n    \"\"\"\n    A function that takes a JSON with two fields: \"text\" & \"maxlen\"\n    Returns: the summarized text of the paragraphs.\n    \"\"\"\n    query = json.loads(request.data)\n    paragraphs = re.sub(\"\\d+\", \"\", query[\"text\"])\n    maxlen = query[\"maxlen\"]\n    minlen = query[\"minlen\"]\n    summary = summarizer(paragraphs, max_length=maxlen, min_length=minlen, do_sample=False)\n    return jsonify(summary), 200\n```", "```py\nif __name__ == '__main__':\n    app.run(debug=True)\n```", "```py\n{\n    \"text\" : \"Biotechnology is a broad area of biology, involving the use of living systems and organisms to develop or make products. \n                              …\n molecular biology, biochemistry, cell biology, embryology, genetics, microbiology) and conversely provides methods to support and perform basic research in biology.\",\n    \"maxlen\" : 60,\n    \"minlen\" : 30\n}\n```", "```py\n$ pip freeze > requirements.txt\n```", "```py\nfrom flask import Flask, jsonify, request, render_template \nimport json\nimport pickle\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n```", "```py\nloaded_scaler= pickle.load(open(\"./models/ch10_scaler.pickle\",'rb'))\nloaded_clf= pickle.load(open(\"./models/ch10_rfc_clf.pickle\",'rb'))\n```", "```py\ndef predict_diagnosis(inputData, scaler, model):\n    \"\"\"\n    Function that takes a list of measurements, scales them, and returns a prediction\n    \"\"\"\n    inputDataDF = pd.DataFrame([inputData])\n    scaledInputData = scaler.transform(inputDataDF)\n    prediction = model.predict(scaledInputData)\n    return prediction[0]\n```", "```py\napp = Flask(__name__, template_folder='templates')\n```", "```py\n@app.route('/')\ndef home():\n    return render_template('index.html')\n```", "```py\n@app.route('/prediction', methods = [\"POST\"])\ndef prediction():\n    print(request.form.values())\n    radius_mean = request.form.get(\"radius_mean\")\n    texture_mean = request.form.get(\"texture_mean\")\n    smoothness_mean = request.form.get(\"smoothness_mean\")\n    texture_se = request.form.get(\"texture_se\")\n    smoothness_se = request.form.get(\"smoothness_se\")\n    symmetry_se = request.form.get(\"symmetry_se\")\n    input_features = [radius_mean, texture_mean, smoothness_mean, texture_se, smoothness_se, symmetry_se]\n    prediction = predict_diagnosis(input_features, loaded_scaler, loaded_clf)\n    prediction = \"Malignant\" if prediction == \"M\" else \"Benign\"\n\n    return render_template('index.html', prediction_text = '\" {} \"'.format(prediction))\n```", "```py\nif __name__ == '__main__':\n    app.run(debug=False, port=5000)\n```"]