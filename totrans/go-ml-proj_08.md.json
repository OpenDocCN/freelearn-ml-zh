["```py\n```", "```py\n```", "```py\n```", "```py\n```", "```py\n goImg, err := img.ToImage()\n if err != nil {\n log.Fatal(err)\n }\n outFile, err := os.OpenFile(\"first.png\", os.O_WRONLY|os.O_TRUNC|os.O_CREATE, 0644)\n if err != nil {\n log.Fatal(err)\n }\n png.Encode(outFile, goImg)\n```", "```py\n window := gocv.NewWindow(\"Face Detection Window\")\n defer window.Close()\n```", "```py\n window.IMShow(img)\n```", "```py\n r := image.Rect(50, 50, 100, 100)\n```", "```py\n blue := color.RGBA{0, 0, 255, 0}\n```", "```py\n gocv.Rectangle(&amp;img, r, blue, 3)\n```", "```py\n```", "```py\n```", "```py\n```", "```py\n```", "```py\n```", "```py\n```", "```py\n```", "```py\n```", "```py\n```", "```py\n```", "```py\ndets := pigoClass.RunCascade(imgParams, cParams)\ndets = pigoClass.ClusterDetections(dets, 0.3)\n```", "```py\n// ImageParams is a struct for image related settings.\n// Pixels: contains the grayscale converted image pixel data.\n// Rows: the number of image rows.\n// Cols: the number of image columns.\n// Dim: the image dimension.\ntype ImageParams struct {\n  Pixels []uint8\n  Rows int\n  Cols int\n  Dim int\n}\n\n```", "```py\nfunc naughtyToImage(m *gocv.Mat, imge image.Image) error {\n                    typ := m.Type()\n  if typ != gocv.MatTypeCV8UC1 &amp;&amp; typ != gocv.MatTypeCV8UC3 &amp;&amp; typ != \n            gocv.MatTypeCV8UC4 {\n    return errors.New(\"ToImage supports only MatType CV8UC1, CV8UC3 and \n                       CV8UC4\")\n  }\n\n  width := m.Cols()\n  height := m.Rows()\n  step := m.Step()\n  data := m.ToBytes()\n  channels := m.Channels()\n\n  switch img := imge.(type) {\n  case *image.NRGBA:\n    c := color.NRGBA{\n      R: uint8(0),\n      G: uint8(0),\n      B: uint8(0),\n      A: uint8(255),\n    }\n    for y := 0; y &lt; height; y++ {\n      for x := 0; x &lt; step; x = x + channels {\n        c.B = uint8(data[y*step+x])\n        c.G = uint8(data[y*step+x+1])\n        c.R = uint8(data[y*step+x+2])\n        if channels == 4 {\n          c.A = uint8(data[y*step+x+3])\n        }\n        img.SetNRGBA(int(x/channels), y, c)\n      }\n    }\n\n  case *image.Gray:\n    c := color.Gray{Y: uint8(0)}\n    for y := 0; y &lt; height; y++ {\n      for x := 0; x &lt; width; x++ {\n        c.Y = uint8(data[y*step+x])\n        img.SetGray(x, y, c)\n      }\n    }\n  }\n  return nil\n}\n\n```", "```py\nfunc naughtyGrayscale(dst []uint8, src *image.NRGBA) []uint8 {\n  rows, cols := src.Bounds().Dx(), src.Bounds().Dy()\n  if dst == nil || len(dst) != rows*cols {\n    dst = make([]uint8, rows*cols)\n  }\n  for r := 0; r &lt; rows; r++ {\n    for c := 0; c &lt; cols; c++ {\n      dst[r*cols+c] = uint8(\n        0.299*float64(src.Pix[r*4*cols+4*c+0]) +\n          0.587*float64(src.Pix[r*4*cols+4*c+1]) +\n          0.114*float64(src.Pix[r*4*cols+4*c+2]),\n      )\n    }\n  }\n  return dst\n}\n```", "```py\nif dst == nil || len(dst) != rows*cols {\n    dst = make([]uint8, rows*cols)\n  }\n```", "```py\nvar haarCascadeFile = \"Path/To/CascadeFile.xml\"\nvar blue = color.RGBA{0, 0, 255, 0}\nvar green = color.RGBA{0, 255, 0, 0}\nfunc main() {\nvar err error\n  // open webcam\n  if webcam, err = gocv.VideoCaptureDevice(0); err != nil {\n    log.Fatal(err)\n  }\n  defer webcam.Close()\n  width := int(webcam.Get(gocv.VideoCaptureFrameWidth))\n  height := int(webcam.Get(gocv.VideoCaptureFrameHeight))\n\n  // open display window\n  window := gocv.NewWindow(\"Face Detect\")\n  defer window.Close()\n\n  // prepare image matrix\n  img := gocv.NewMat()\n  defer img.Close()\n\n  // set up pigo\n  goImg, grayGoImg, pigoClass, cParams, imgParams := pigoSetup(width, \n                                                     height)\n\n  for {\n    if ok := webcam.Read(&amp;img); !ok {\n      fmt.Printf(\"cannot read device %d\\n\", deviceID)\n      return\n    }\n    if img.Empty() {\n      continue\n    }\n    if err = naughtyToImage(&amp;img, goImg); err != nil {\n      log.Fatal(err)\n    }\n    grayGoImg = naughtyGrayscale(grayGoImg, goImg)\n    imgParams.Pixels = grayGoImg\n    dets := pigoClass.RunCascade(imgParams, cParams)\n    dets = pigoClass.ClusterDetections(dets, 0.3)\n\n    for _, det := range dets {\n      if det.Q &lt; 5 {\n        continue\n      }\n      x := det.Col - det.Scale/2\n      y := det.Row - det.Scale/2\n      r := image.Rect(x, y, x+det.Scale, y+det.Scale)\n      gocv.Rectangle(&amp;img, r, green, 3)\n    }\n\n    window.IMShow(img)\n    if window.WaitKey(1) &gt;= 0 {\n      break\n    }\n  }\n}\n\n```", "```py\ndets := pigoClass.RunCascade(imgParams, cParams)\ndets = pigoClass.ClusterDetections(dets, 0.3)\n```", "```py\nx := det.Col - det.Scale/2\ny := det.Row - det.Scale/2\nr := image.Rect(x, y, x+det.Scale, y+det.Scale)\n```", "```py\nvar haarCascadeFile = \"Path/To/CascadeFile.xml\"\nvar blue = color.RGBA{0, 0, 255, 0}\nvar green = color.RGBA{0, 255, 0, 0}\nfunc main() {\nvar err error\n  // open webcam\n  if webcam, err = gocv.VideoCaptureDevice(0); err != nil {\n    log.Fatal(err)\n  }\n  defer webcam.Close()\n  width := int(webcam.Get(gocv.VideoCaptureFrameWidth))\n  height := int(webcam.Get(gocv.VideoCaptureFrameHeight))\n\n  // open display window\n  window := gocv.NewWindow(\"Face Detect\")\n  defer window.Close()\n\n  // prepare image matrix\n  img := gocv.NewMat()\n  defer img.Close()\n\n  // set up pigo\n  goImg, grayGoImg, pigoClass, cParams, imgParams := pigoSetup(width, \n                                                       height)\n\n  // create classifier and load model\n  classifier := gocv.NewCascadeClassifier()\n  if !classifier.Load(haarCascadeFile) {\n    log.Fatalf(\"Error reading cascade file: %v\\n\", haarCascadeFile)\n  }\n  defer classifier.Close()\n\n  for {\n    if ok := webcam.Read(&amp;img); !ok {\n      fmt.Printf(\"cannot read device %d\\n\", deviceID)\n      return\n    }\n    if img.Empty() {\n      continue\n    }\n    // use PIGO\n    if err = naughtyToImage(&amp;img, goImg); err != nil {\n      log.Fatal(err)\n    }\n\n    grayGoImg = naughtyGrayscale(grayGoImg, goImg)\n    imgParams.Pixels = grayGoImg\n    dets := pigoClass.RunCascade(imgParams, cParams)\n    dets = pigoClass.ClusterDetections(dets, 0.3)\n\n    for _, det := range dets {\n      if det.Q &lt; 5 {\n        continue\n      }\n      x := det.Col - det.Scale/2\n      y := det.Row - det.Scale/2\n      r := image.Rect(x, y, x+det.Scale, y+det.Scale)\n      gocv.Rectangle(&amp;img, r, green, 3)\n    }\n\n    // use GoCV\n    rects := classifier.DetectMultiScale(img)\n    for _, r := range rects {\n      gocv.Rectangle(&amp;img, r, blue, 3)\n    }\n\n    window.IMShow(img)\n    if window.WaitKey(1) &gt;= 0 {\n      break\n    }\n  }\n}\n```", "```py\nfunc BenchmarkGoCV(b *testing.B) {\n  img := gocv.IMRead(\"test.png\", gocv.IMReadUnchanged)\n  if img.Cols() == 0 || img.Rows() == 0 {\n    b.Fatalf(\"Unable to read image into file\")\n  }\n\n  classifier := gocv.NewCascadeClassifier()\n  if !classifier.Load(haarCascadeFile) {\n    b.Fatalf(\"Error reading cascade file: %v\\n\", haarCascadeFile)\n  }\n\n  var rects []image.Rectangle\n  b.ResetTimer()\n\n  for i := 0; i &lt; b.N; i++ {\n    rects = classifier.DetectMultiScale(img)\n  }\n  _ = rects\n}\n```", "```py\nfunc BenchmarkPIGO(b *testing.B) {\n  img := gocv.IMRead(\"test.png\", gocv.IMReadUnchanged)\n  if img.Cols() == 0 || img.Rows() == 0 {\n    b.Fatalf(\"Unable to read image into file\")\n  }\n  width := img.Cols()\n  height := img.Rows()\n  goImg, grayGoImg, pigoClass, cParams, imgParams := pigoSetup(width, \n                                                     height)\n\n  var dets []pigo.Detection\n  b.ResetTimer()\n\n  for i := 0; i &lt; b.N; i++ {\n    grayGoImg = naughtyGrayscale(grayGoImg, goImg)\n    imgParams.Pixels = grayGoImg\n    dets = pigoClass.RunCascade(imgParams, cParams)\n    dets = pigoClass.ClusterDetections(dets, 0.3)\n  }\n  _ = dets\n}\n```", "```py\ngoos: darwin\ngoarch: amd64\npkg: chapter9\nBenchmarkGoCV-4 20 66794328 ns/op 32 B/op 1 allocs/op\nBenchmarkPIGO-4 30 47739076 ns/op 0 B/op 0 allocs/op\nPASS\nok chapter9 3.093s\n```", "```py\n| Consideration | Test |\n|:---:          |:---:|\n| Performance in detecting many faces | Benchmark with image of crowd |\n| Correctness in detecting many faces | Test with image of crowd, with  \n                                        known numbers |\n| No racial discrimination | Test with images of multi-ethnic peoples  \n                             with different facial features |\n```"]