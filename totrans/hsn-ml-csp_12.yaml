- en: Intuitive Deep Learning in C# .NET
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# .NET中的直观深度学习
- en: Our goal in this chapter is to expose you to some of the powerful functionality
    that is available with Kelp.Net.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是向您展示Kelp.Net提供的强大功能。
- en: 'In this chapter, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: How to use Kelp.Net to perform your own testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Kelp.Net进行自己的测试
- en: How to write tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写测试
- en: How to do benchmarks of functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何对函数进行基准测试
- en: How to extend Kelp.Net
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何扩展Kelp.Net
- en: Kelp.Net[4] is a deep learning library written in C# and .NET. With the ability
    to chain functions into a function stack, it provides an incredible amount of
    power in a very flexible and intuitive platform. It also takes heavy advantage
    of the OpenCL language platform to enable seamless operation on both CPU-and GPU-enabled
    devices. Deep learning is an incredibly powerful tool, and native support for
    Caffe and Chainer model loading makes this platform even more powerful. As you
    will see, you can create a 1 million hidden layer deep learning network in just
    a few lines of code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Kelp.Net[4]是一个用C#和.NET编写的深度学习库。它能够将函数链入函数堆栈，提供了一个非常灵活和直观的平台，具有极大的功能。它还充分利用了OpenCL语言平台，以实现CPU和GPU设备上的无缝操作。深度学习是一个功能强大的工具，对Caffe和Chainer模型加载的原生支持使这个平台更加强大。正如你将看到的，你只需几行代码就可以创建一个拥有100万个隐藏层的深度学习网络。
- en: Kelp.Net also makes it very easy to save and load models to and from disk storage.
    This is a very powerful feature, allowing you to perform your training, save the
    model, and then load and test as required. It also makes it much easier to productionize
    code and truly separate the training and the test phases.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Kelp.Net还使得将模型保存到磁盘存储和从磁盘加载变得非常容易。这是一个非常强大的功能，允许你进行训练、保存模型，然后根据需要加载和测试。它还使得将代码投入生产并真正分离训练和测试阶段变得更加容易。
- en: Among other things, Kelp.Net is an incredibly powerful tool for you to be able
    to learn and understand better various types of functions, their interactions,
    and performance. For instance, you can run tests against the same network with
    different optimizers and see the results by changing a single line of code. Also,
    you can design your tests easily to see the difference in using various batch
    sizes, number of hidden layers, epochs, and more. There really is no deep learning
    workbench for .NET that offers the power and flexibility found in Kelp.Net.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他方面，Kelp.Net是一个功能强大的工具，可以帮助你更好地学习和理解各种类型的函数、它们的交互和性能。例如，你可以对同一网络使用不同的优化器进行测试，通过更改一行代码来查看结果。你也可以轻松设计测试，以查看使用不同批量大小、隐藏层数量、epoch等时的差异。在.NET中，几乎没有提供Kelp.Net所具有的强大功能和灵活性的深度学习工作台。
- en: Let's begin by talking a little bit about deep learning.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先简单谈谈深度学习。
- en: What is deep learning?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度学习是什么？
- en: To discuss deep learning, we need to go back in time, not so long ago, to when
    big data arrived in front of all our faces. The term was, and still is, everywhere.
    It was a skill that everyone just had to have, a buzzword-compliant checklist
    item. But what exactly did that term really mean? Well, it just meant that rather
    than siloed SQL databases and files being FTP'ed to use, we had this explosion
    of digital data from social media, internet search engines, e-commerce sites,
    and much more. And of course, this data came in various forms and formats. More
    formally, we were suddenly dealing with unstructured data. Not only did we have
    this explosion of data due to applications such as Facebook, Twitter, Google,
    and more, but also the explosion continues. More and more people get and stay
    connected to each other, sharing vast amounts of information about themselves
    that they wouldn't dare provide to someone if asked via a telephone call, right?
    And we have little to no control over the format and quality of that data. This
    will become an important point as we proceed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要讨论深度学习，我们需要回顾一下，不久前，大数据出现在我们面前。这个术语当时，现在仍然无处不在。这是一个每个人都必须拥有的技能，一个符合流行术语的清单项。但这个术语究竟意味着什么呢？嗯，它只是意味着，我们不再使用孤立的SQL数据库和文件通过FTP传输来使用，而是从社交媒体、互联网搜索引擎、电子商务网站等地方爆发了大量的数字数据。当然，这些数据以各种形式和格式出现。更正式地说，我们突然开始处理非结构化数据。不仅由于Facebook、Twitter、Google等应用程序的数据爆炸，而且爆炸还在继续。越来越多的人相互连接并保持联系，分享大量关于自己的信息，这些信息他们如果通过电话询问，是绝对不敢提供的，对吧？我们对这些数据的格式和质量几乎没有控制权。随着我们继续前进，这将成为一个重要的观点。
- en: Now, this vast amount of data is great, but humans can barely absorb what they
    are exposed to daily, let alone this explosion of data. So, along the way, people
    realized that machine learning and artificial intelligence could be adapted to
    just such a task. From a simple machine learning algorithm, all the way up to
    multilayered networks, artificial intelligence and deep learning were born (at
    least the corporate world likes to believe it happened that way!).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这庞大的数据量是很好的，但人类几乎无法吸收他们每天所接触到的，更不用说数据爆炸了。因此，在这个过程中，人们意识到机器学习和人工智能可以适应这样的任务。从简单的机器学习算法到多层网络，人工智能和深度学习诞生了（至少企业界喜欢相信是这样发生的！）。
- en: Deep learning, which is a branch of machine learning and artificial intelligence,
    uses many levels of neural network layers (hierarchical, if you like) to perform
    its job. In many cases, these networks are built to mirror what we think we know
    about the human brain, with neurons connecting layers together like an intricately
    layered web. This allows data processing to occur in a nonlinear fashion. Each
    layer processes data from the previous layer (with an exception being the first
    layer, of course), passing its information on to the next layer. With any luck,
    each layer improves the model, and in the end, we achieve our goal and solve our
    problem.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习，作为机器学习和人工智能的一个分支，使用许多层级的神经网络层（如果你喜欢，可以称之为分层）来完成其任务。在许多情况下，这些网络被构建来反映我们对我们所了解的人脑的认识，神经元像复杂层叠的网一样连接各个层。这使得数据处理可以以非线性方式发生。每一层处理来自前一层的（当然，第一层除外）数据，并将信息传递给下一层。如果有任何运气，每一层都会改进模型，最终，我们达到目标并解决问题。
- en: OpenCL
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCL
- en: 'Kelp.Net makes heavy usage of the open computing language, or OpenCL. According
    to Wikipedia:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Kelp.Net大量使用开放计算语言，即OpenCL。根据维基百科：
- en: '"OpenCL views a computing system as consisting of a number of compute devices,
    which might be central processing units (CPUs), or accelerators such as graphics
    processing units (GPUs), attached to a host processor (a CPU). Functions executed
    on an OpenCL device are called kernels. A single compute device typically consists
    of several compute units, which in turn comprise multiple processing elements
    (PS). A single kernel execution can run on all or many of the PEs in parallel."'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: “OpenCL将计算系统视为由多个计算设备组成，这些设备可能是中央处理器（CPU），或者是连接到主机处理器（CPU）的加速器，如图形处理单元（GPU）。在OpenCL设备上执行的功能称为内核。单个计算设备通常由多个计算单元组成，这些计算单元又由多个处理元素（PE）组成。单个内核执行可以在所有或许多PE上并行运行。”
- en: In OpenCL, tasks are scheduled on command queues. There is at least one command
    queue for each device. The OpenCL runtime breaks the scheduled data-parallel tasks
    into pieces and sends the tasks to the device processing element.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenCL中，任务是在命令队列上安排的。每个设备至少有一个命令队列。OpenCL运行时将安排的数据并行任务分解成片段，并将任务发送到设备处理元素。
- en: 'OpenCL defines a memory hierarchy:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL定义了一个内存层次结构：
- en: '**Global**: Shared by all processing elements, and has high latency'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Global**: 由所有处理元素共享，具有高延迟'
- en: '**Read-only**: Smaller, of lower latency, and writable by the host CPU but
    not compute devices'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Read-only**: 较小，延迟较低，可由主机CPU写入但不能由计算设备写入'
- en: '**Local**: Shared by a process element group'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Local**: 由进程元素组共享'
- en: '**Per-element**: Private memory'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Per-element**: 私有内存'
- en: OpenCL also provides an API designed more towards math. This can be seen in
    the exposure of fixed-length vector types such as float4 (four vector of single-precision
    floats), available in lengths of 2, 3, 4, 8 and 16\. As you gain more exposure
    to Kelp.Net and start to create your own functions, you will encounter OpenCL
    programming. For now, it's enough to know that it exists and is being used under
    the hood extensively.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL还提供了一个更偏向数学的API。这可以从固定长度向量类型（如float4，单精度浮点数的四个向量）的暴露中看出，长度为2、3、4、8和16。随着你对Kelp.Net的更多了解以及开始创建自己的函数，你将遇到OpenCL编程。现在，只需知道它存在并且被广泛使用就足够了。
- en: OpenCL hierarchy
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCL层次结构
- en: 'In Kelp.Net, the hierarchy for various OpenCL resources is as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kelp.Net中，各种OpenCL资源的层次结构如下所示：
- en: '![](img/637115a5-7fd0-4e75-9e81-73caec8cee8c.png)![](img/c519fb66-bcbc-4634-b380-1b6c1fdf9bec.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/637115a5-7fd0-4e75-9e81-73caec8cee8c.png)![](img/c519fb66-bcbc-4634-b380-1b6c1fdf9bec.png)'
- en: Let's describe these in more detail.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地描述这些。
- en: Compute kernel
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算内核
- en: A kernel object encapsulates a specific kernel function declared in a program
    and the argument values to be used when executing this kernel function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 内核对象封装了程序中声明的特定内核函数以及执行此内核函数时要使用的参数值。
- en: Compute program
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算程序
- en: An OpenCL program consisting of a set of kernels. Programs may also contain
    auxiliary functions called by the kernel functions and constant data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由一组内核组成的 OpenCL 程序。程序还可以包含由内核函数调用的辅助函数和常量数据。
- en: Compute sampler
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算采样器
- en: An object that describes how to sample an image when the image is read in the
    kernel. The image read functions take a sampler as an argument. The sampler specifies
    the image addressing mode (meaning how out-of-range coordinates are handled),
    the filtering mode, and whether the input image coordinate is a normalized or
    unnormalized value.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个描述如何在内核中读取图像时进行采样的对象。图像读取函数接受一个采样器作为参数。采样器指定图像寻址模式（意味着如何处理超出范围的坐标）、过滤模式以及输入图像坐标是归一化还是未归一化的值。
- en: Compute device
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算设备
- en: A compute device is a collection of compute units. A command queue is used to
    queue commands to a device. Examples of commands include executing kernels or
    reading/writing memory objects. OpenCL devices typically correspond to a GPU,
    a multi-core CPU, and other processors such as **Digital Signal Processor** (**DSP**)
    and the cell/B.E. processor.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 计算设备是一组计算单元。命令队列用于向设备排队命令。命令的例子包括执行内核或读取/写入内存对象。OpenCL 设备通常对应于 GPU、多核 CPU 以及其他处理器，如**数字信号处理器**（**DSP**）和
    cell/B.E. 处理器。
- en: Compute resource
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算资源
- en: An OpenCL resource that can be created and deleted by the application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序可以创建和删除的 OpenCL 资源。
- en: Compute object
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算对象
- en: An object identified by its handle in the OpenCL environment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenCL 环境中通过其句柄识别的对象。
- en: Compute context
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算上下文
- en: A compute context is the actual environment within which the kernels execute
    and the domain in which synchronization and memory management are defined.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 计算上下文是内核实际执行的环境以及定义同步和内存管理的域。
- en: Compute command queue
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算命令队列
- en: A command queue is an object that holds commands that will be executed on a
    specific device. The command queue is created on a specific device within a context.
    Commands to a queue are queued in order but may be executed either in order or
    out of order.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 命令队列是一个对象，它包含将在特定设备上执行的操作。命令队列在上下文中的特定设备上创建。对队列的命令按顺序排队，但可以按顺序或非顺序执行。
- en: Compute buffer
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算缓冲区
- en: A memory object that stores a linear collection of bytes. Buffer objects are
    accessible using a pointer in a kernel executing on a device.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个存储字节线性集合的内存对象。缓冲区对象可以通过在设备上执行的内核中的指针访问。
- en: Compute event
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算事件
- en: An event encapsulates the status of an operation such as a command. It can be
    used to synchronize operations in a context.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 事件封装了操作的状态，如命令。它可以用于在上下文中同步操作。
- en: Compute image
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算图像
- en: A memory object that stores a 2D or 3D structured array. Image data can only
    be accessed with read and write functions. Read functions use a sampler.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个存储 2D 或 3D 结构化数组的内存对象。图像数据只能通过读取和写入函数访问。读取函数使用采样器。
- en: Compute platform
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算平台
- en: The host plus a collection of devices managed by the OpenCL framework that allow
    an application to share resources and execute kernels on devices on the platform.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 主机加上由 OpenCL 框架管理的设备集合，允许应用程序共享资源并在平台上的设备上执行内核。
- en: Compute user event
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算用户事件
- en: This represents a user-created event.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表一个用户创建的事件。
- en: The Kelp.Net Framework
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kelp.Net 框架
- en: Functions
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions are the basic building blocks of a Kelp.Net neural network. Single
    functions are chained together within function stacks to create powerful and possibly
    complex network chains. There are four primary types of functions you need to
    know about, and their purposes, should be self-explanatory:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是 Kelp.Net 神经网络的基本构建块。单个函数在函数栈中链在一起，以创建强大且可能复杂的网络链。你需要了解四种主要类型的函数，以及它们的目的，应该是显而易见的：
- en: Single-input functions
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单输入函数
- en: Dual-input functions
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双输入函数
- en: Multi-input functions
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多输入函数
- en: Multi-output functions
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多输出函数
- en: Functions are also chained together when networks are loaded from disks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当从磁盘加载网络时，函数也会被链在一起。
- en: 'Each function has a forward and backward method that you will be implementing
    when you create functions of your own:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都有一个正向和反向方法，你将在创建自己的函数时实现：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Function stacks
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数栈
- en: Function stacks are layers of functions that are executed simultaneously in
    one forward, backward, or update pass. Function stacks are created when you either
    create a test or load a model from disk. Here are some examples of function stacks.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 函数栈是在一个正向、反向或更新过程中同时执行的一组函数层。当你创建测试或从磁盘加载模型时，会创建函数栈。以下是一些函数栈的示例。
- en: 'They can be small and simple:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以很小且简单：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'They can be a little bit bigger:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以稍微大一点：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or, they can be very large:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们也可以非常大：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Function dictionaries
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数字典
- en: A function dictionary is a serializable dictionary of functions (described previously).
    When a network model is loaded from disk, a function dictionary will be returned
    and can be operated on exactly as if you had just created the function stack itself
    in code. The function dictionary is used primarily with the Caffe data model loader.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 函数字典是一个可序列化的函数字典（之前已描述）。当从磁盘加载网络模型时，将返回一个函数字典，可以像在代码中直接创建函数栈一样对其进行操作。函数字典主要用于与
    Caffe 数据模型加载器一起使用。
- en: Caffe1
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Caffe1
- en: Kelp.Net was developed strongly around the Caffe style of development and supports
    many of its features.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Kelp.Net 在 Caffe 风格的开发基础上得到了强化，并支持其许多特性。
- en: Caffe provides multimedia scientists and practitioners with a clean and modifiable
    framework for state-of-the-art deep learning algorithms and a collection of reference
    models. The framework is a BSD-licensed C++ library with Python and MATLAB bindings
    for training and deploying general-purpose convolutional neural networks and other
    deep models efficiently on commodity architectures. Caffe fits industry and internet-scale
    media needs by CUDA GPU computation, processing over 40 million images a day on
    a single K40 or Titan GPU (approximately 2 ms per image). By separating model
    representation and actual implementation, Caffe allows experimentation and seamless
    switching among platforms for ease of development and deployment, from prototyping
    machines to cloud environments.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Caffe 为多媒体科学家和从业者提供了一个干净且可修改的框架，用于最先进的深度学习算法和一系列参考模型。该框架是一个带有 Python 和 MATLAB
    绑定的 BSD 许可证 C++ 库，用于在通用架构上高效地训练和部署通用卷积神经网络和其他深度模型。通过 CUDA GPU 计算，Caffe 满足行业和互联网规模媒体需求，单个
    K40 或 Titan GPU 每天处理超过 4000 万张图片（每张图片大约 2 毫秒）。通过分离模型表示和实际实现，Caffe 允许实验，并在平台之间无缝切换，便于开发和部署，从原型机到云环境。
- en: Chainer
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chainer
- en: 'According to the Chainer documentation[2]:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Chainer 文档[2]：
- en: '"Chainer is a flexible framework for neural networks. One major goal is flexibility,
    so it must enable us to write complex architectures simply and intuitively."'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '"Chainer 是一个灵活的神经网络框架。一个主要目标是灵活性，因此它必须能够让我们简单直观地编写复杂的架构。"'
- en: Chainer adopts a define-by-run scheme, that is, the network is defined dynamically
    via the actual forward computation. More precisely, Chainer stores the history
    of computation instead of programming logic. For example, Chainer does not need
    any magic to introduce conditionals and loops into the network definitions. The
    define-by-run scheme is the core concept of Chainer. This strategy also makes
    it easy to write multi-GPU parallelization, since logic comes closer to network
    manipulation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Chainer 采用定义-运行方案，即网络通过实际的正向计算动态定义。更精确地说，Chainer 存储计算的历史而不是编程逻辑。例如，Chainer 不需要任何魔法就可以将条件语句和循环引入网络定义中。定义-运行方案是
    Chainer 的核心概念。这种策略也使得编写多 GPU 并行化变得容易，因为逻辑更接近网络操作。
- en: Kelp.Net can load a Chainer model directly from disk.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Kelp.Net 可以直接从磁盘加载 Chainer 模型。
- en: Loss
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 损失
- en: Kelp.Net is comprised of a single abstract `LossFunction` class, designed to
    be implemented for your specific instance in determining how you evaluate loss.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Kelp.Net 由一个单一的抽象 `LossFunction` 类组成，该类旨在实现你的特定实例，以确定你如何评估损失。
- en: 'In machine learning, a loss function or cost function is a function that maps
    an event or values of one or more variables onto a real number intuitively, representing
    some cost associated with the event. Kelp.Net offers two out-of-the-box loss functions:
    mean squared error and softmax cross entropy. You can easily extend these to meet
    your needs.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，损失函数或代价函数是一个将事件或一个或多个变量的值映射到实数的函数，直观地表示与事件相关的某些成本。Kelp.Net 提供了两种现成的损失函数：均方误差和
    softmax 交叉熵。你可以轻松扩展这些函数以满足你的需求。
- en: Model saving and loading
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型保存和加载
- en: 'Kelp.Net makes it very easy to save and load models with a call to one simple
    class. The `ModelIO` class exposes both a `Save` and a `Load` method for easy
    saving and loading to disk. Here is a very simple example of saving a model after
    training, reloading, and then performing testing on that model:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Kelp.Net 通过调用一个简单的类即可轻松保存和加载模型。`ModelIO` 类公开了 `Save` 和 `Load` 方法，以便轻松地将模型保存到磁盘。以下是一个在训练后保存模型、重新加载并随后对该模型进行测试的非常简单的示例：
- en: '![](img/4618e810-510c-49f1-8847-ec05afaf293e.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4618e810-510c-49f1-8847-ec05afaf293e.png)'
- en: Optimizers
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化器
- en: Optimization algorithms minimize or maximize an error function depending on
    the model's parameters. Examples of parameters would be weights and biases. They
    help compute the output value and update the model towards the position of optimal
    solution by minimizing loss. Extending Kelp.Net to add your own optimization algorithms
    is a simple process, although adding the OpenCL and resource side of things is
    a coordinated effort.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 优化算法根据模型的参数最小化或最大化误差函数。参数的例子可以是权重和偏差。它们帮助计算输出值，并通过最小化损失来更新模型，使其朝向最优解的位置。将 Kelp.Net
    扩展以添加自己的优化算法是一个简单的过程，尽管添加 OpenCL 和资源方面需要协调努力。
- en: 'Kelp.Net comes with many predefined optimizers, such as:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Kelp.Net 随带许多预定义的优化器，例如：
- en: AdaDelta
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AdaDelta
- en: AdaGrad
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AdaGrad
- en: Adam
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adam
- en: GradientClipping
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GradientClipping
- en: MomentumSGD
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MomentumSGD
- en: RMSprop
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RMSprop
- en: SGD
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SGD
- en: These are all based on the abstract optimizer class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是基于抽象优化器类。
- en: Datasets
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据集
- en: 'Kelp.Net natively supports the following datasets:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Kelp.Net 本地支持以下数据集：
- en: CIFAR
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CIFAR
- en: MNIST
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MNIST
- en: CIFAR
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CIFAR
- en: The CIFAR datasets come in two flavors, CIFAR-10 and CIFAR 100, with the difference
    being the number of classes within each. Let's briefly discuss both.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: CIFAR 数据集有两种风味，CIFAR-10 和 CIFAR 100，区别在于每个数据集中的类别数量。让我们简要讨论一下两者。
- en: CIFAR-10
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CIFAR-10
- en: The CIFAR-10 dataset consists of 60,000 32 x 32 color images in 10 classes,
    with 6,000 images per class. There are 50,000 training images and 10,000 test
    images. The dataset is divided into five training batches and one test batch,
    each with 10,000 images. The test batch contains exactly 1,000 randomly selected
    images from each class. The training batches contain the remaining images in random
    order, but some training batches may contain more images from one class than another.
    Between them, the training batches contain exactly 5,000 images from each class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: CIFAR-10 数据集由 10 个类别的 60,000 张 32 x 32 彩色图像组成，每个类别有 6,000 张图像。有 50,000 张训练图像和
    10,000 张测试图像。数据集分为五个训练批次和一个测试批次，每个批次有 10,000 张图像。测试批次包含每个类别恰好 1,000 张随机选择的图像。训练批次包含剩余的图像，以随机顺序排列，但某些训练批次可能包含比另一个类别更多的图像。在这些批次之间，训练批次包含每个类别恰好
    5,000 张图像。
- en: CIFAR-100
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CIFAR-100
- en: 'The CIFAR-100 dataset is just like CIFAR-10, except that it has 100 classes
    containing 600 images each. There are 500 training images and 100 testing images
    per class. The 100 classes in CIFAR-100 are grouped into 20 superclasses. Each
    image comes with a fine label (the class to which it belongs) and a coarse label
    (the superclass to which it belongs). Here is the list of classes in CIFAR-100:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: CIFAR-100 数据集与 CIFAR-10 类似，但它有 100 个类别，每个类别包含 600 张图片。每个类别有 500 张训练图片和 100 张测试图片。CIFAR-100
    的 100 个类别被分为 20 个超级类别。每张图片都附有一个精细标签（它所属的类别）和一个粗略标签（它所属的超级类别）。以下是 CIFAR-100 中类别的列表：
- en: '| **Superclass** | **Classes** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **超级类别** | **类别** |'
- en: '| Aquatic mammals | Beaver, dolphin, otter, seal, and whale |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 水生哺乳动物 | 海狸、海豚、水獭、海豹和鲸鱼 |'
- en: '| Fish | Aquarium fish, flatfish, ray, shark, and trout |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 鱼类 | 水族馆鱼类、扁鱼、鳐鱼、鲨鱼和鲑鱼 |'
- en: '| Flowers | Orchids, poppies, roses, sunflowers, and tulips |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 花卉 | 兰花、罂粟花、玫瑰、向日葵和郁金香 |'
- en: '| Food containers | Bottles, bowls, cans, cups, and plates |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 食品容器 | 瓶子、碗、罐头、杯子和盘子 |'
- en: '| Fruit and vegetables | Apples, mushrooms, oranges, pears, and sweet peppers
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 水果和蔬菜 | 苹果、蘑菇、橙子、梨和甜椒 |'
- en: '| Household electrical devices | Clock, computer keyboard, lamp, telephone,
    and television |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 家用电器 | 时钟、电脑键盘、灯、电话和电视 |'
- en: '| Household furniture | Bed, chair, couch, table, and wardrobe |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 家具 | 床、椅子、沙发、桌子和衣柜 |'
- en: '| Insects | Bee, beetle, butterfly, caterpillar, and cockroach |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 昆虫 | 蜜蜂、甲虫、蝴蝶、毛毛虫和蟑螂 |'
- en: '| Large carnivores | Bear, leopard, lion, tiger, and wolf |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 大型食肉动物 | 熊、豹、狮子、老虎和狼 |'
- en: '| Large man-made outdoor things | Bridge, castle, house, road, and skyscraper
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 大型人造户外物品 | 桥梁、城堡、房屋、道路和摩天大楼 |'
- en: '| Large natural outdoor scenes | Cloud, forest, mountain, plain, and sea |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 大型自然户外景观 | 云、森林、山脉、平原和海洋 |'
- en: '| Large omnivores and herbivores | Camel, cattle, chimpanzee, elephant, and
    kangaroo |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 大型杂食性和草食性动物 | 骆驼、牛、黑猩猩、大象和袋鼠 |'
- en: '| Medium-sized mammals | Fox, porcupine, possum, raccoon, and skunk |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 中型哺乳动物 | 狐狸、刺猬、负鼠、浣熊和臭鼬 |'
- en: '| Non-insect invertebrates | Crab, lobster, snail, spider, and worm |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 非昆虫无脊椎动物 | 螃蟹、龙虾、蜗牛、蜘蛛和蠕虫 |'
- en: '| People | Baby, boy, girl, man, and woman |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 人群 | 婴儿、男孩、女孩、男人和女人 |'
- en: '| Reptiles | Crocodile, dinosaur, lizard, snake, and turtle |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 爬行动物 | 鳄鱼、恐龙、蜥蜴、蛇和乌龟 |'
- en: '| Small mammals | Hamster, mouse, rabbit, shrew, and squirrel |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 小型哺乳动物 | 仓鼠、老鼠、兔子、鼩鼱和松鼠 |'
- en: '| Trees | Maple, oak, palm, pine, and willow |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 树木 | 榉树、橡树、棕榈、松树和柳树 |'
- en: '| Vehicles 1 | Bicycle, bus, motorcycle, pickup truck, and train |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 车辆1 | 自行车、公共汽车、摩托车、皮卡和火车 |'
- en: '| Vehicles 2 | Lawn-mower, rocket, streetcar, tank, and tractor |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 车辆2 | 草割机、火箭、电车、坦克和拖拉机 |'
- en: MNIST
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MNIST
- en: 'The MNIST database is a large database of handwritten digits that is commonly
    used for training various image processing systems. The database is also widely
    used for training and testing in the field of machine learning. It has a training
    set of 60,000 examples and a test set of 10,000 examples. The digits have been
    size-normalized and centered in a fixed-size image, making it the standard of
    choice for people wanting to try various learning techniques without requiring
    the effort of preprocessing and formatting:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: MNIST数据库是一个包含大量手写数字的大型数据库，通常用于训练各种图像处理系统。该数据库在机器学习领域的训练和测试中也得到了广泛的应用。它包含60,000个示例的训练集和10,000个示例的测试集。数字已经被标准化到固定大小的图像中，并进行了居中处理，这使得它成为想要尝试各种学习技术而不需要预处理和格式化工作的人们的首选标准：
- en: '![](img/19ca2c60-4ff0-483f-8711-a7b0c4500ff3.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19ca2c60-4ff0-483f-8711-a7b0c4500ff3.png)'
- en: MNIST Example
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: MNIST示例
- en: Tests
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'Tests are actual execution events, small programs if you will. Because of the
    usage of OpenCL, these programs are compiled at runtime. To create a test, you
    only need to provide a single static `Run` function that encapsulates your code.
    Kelp.Net comes with a preconfigured tester, which makes it very simple to add
    your own tests. We will explore this in detail in our section on writing tests,
    for now, here is an example of a simple XOR test program:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是实际的执行事件，可以说是小型程序。由于使用了OpenCL，这些程序在运行时进行编译。要创建一个测试，您只需要提供一个静态的`Run`函数，该函数封装了您的代码。Kelp.Net附带了一个预配置的测试器，这使得添加您自己的测试变得非常简单。我们将在编写测试的章节中详细探讨这一点，现在，这里有一个简单的XOR测试程序的示例：
- en: '[PRE4]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Monitoring Kelp.Net
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控Kelp.Net
- en: ReflectInsight from ReflectSoftware is hands down the best real-time logging
    framework for both logging and rich visualization available today. Kelp.Net has
    native support for this framework, thereby making it very easy for you to see
    what is going on inside your tests.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ReflectSoftware的ReflectInsight无疑是当今最好的实时日志记录和丰富可视化框架。Kelp.Net原生支持此框架，因此您很容易看到测试内部的运行情况。
- en: 'Here is what the main screen of ReflectInsight looks like:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是ReflectInsight主屏幕的样貌：
- en: '![](img/cdbc8870-d14b-43c1-820e-324905bcf3bb.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdbc8870-d14b-43c1-820e-324905bcf3bb.png)'
- en: An example of the main screen of Reflect Insight
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Reflect Insight主屏幕的一个示例
- en: Watches
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表盘
- en: 'Watches allow you to keep an eye on specific data elements throughout the execution
    of your tests. When it comes to machine learning, understanding and seeing exactly
    what is going on inside your algorithms is incredibly important, and the watch
    panel is exactly the place to accomplish that:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 监视器允许您在测试执行过程中关注特定的数据元素。在机器学习领域，理解和看到算法内部的确切运行情况至关重要，而监视面板正是实现这一目标的地方：
- en: '![](img/1c6900a8-53fa-44a2-b40c-de21a72a6e8c.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c6900a8-53fa-44a2-b40c-de21a72a6e8c.png)'
- en: Messages
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息
- en: 'The message panel is where each message is displayed during test execution.
    The information available is totally up to you. The image displayed to the immediate
    left of the message text is based upon the type of message that you send (Information,
    Debug, Warning, Error, etc.):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 消息面板是测试执行期间显示每个消息的地方。可用的信息完全取决于您。消息文本左侧显示的图像基于您发送的消息类型（信息、调试、警告、错误等）：
- en: '![](img/429ba129-b82f-404e-9542-a409769840fb.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/429ba129-b82f-404e-9542-a409769840fb.png)'
- en: Properties
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'Each message has predefined properties that can be viewed via the Properties
    panel. There are standard properties, such as that shown below, which are available
    for every message. Then there are customize message properties that can be applied:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个消息都有预定义的属性，可以通过属性面板查看。有标准属性，如下所示，适用于每个消息。然后还有可自定义的消息属性，可以应用：
- en: '![](img/58da7859-9e0b-422a-860d-7dc692adda5b.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/58da7859-9e0b-422a-860d-7dc692adda5b.png)'
- en: An example of per message properties
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 消息属性示例
- en: Weaver
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Weaver
- en: 'The weaver is a critical component of Kelp.Net and is the first object call
    you will make when running a test. This object houses a variety of OpenCL objects
    such as:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Weaver 是 Kelp.Net 的关键组件，当你运行测试时，你将首先调用这个对象。这个对象包含各种 OpenCL 对象，例如：
- en: ComputeContext
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算上下文
- en: An array of ComputeDevices
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组计算设备
- en: ComputeCommandQueue
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算命令队列
- en: A Boolean flag indicating if the GPU is enabled
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔标志，指示是否启用 GPU
- en: ComputePlatform
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算平台
- en: A dictionary of KernelSources
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心源字典
- en: 'The weaver is the place to tell your program whether you will be using a CPU
    or GPU, and which device (if your system is capable of multiple devices) you will
    be using. You only need to make a single call to the weaver, at the beginning
    of your program, similar to what you see here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Weaver 是你告诉程序是否将使用 CPU 或 GPU，以及你将使用哪个设备（如果你的系统具有多个设备）的地方。你只需要在程序开始时调用一次 weaver，就像你在这里看到的那样：
- en: '[PRE5]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You also can avoid using the initialization call of the weaver and allow it
    to determine what needs to happen automatically.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以避免使用 weaver 的初始化调用，并允许它自动确定需要发生什么。
- en: 'Here are the basic contents of the weaver. Its purpose is to build (compile
    dynamically at runtime) the program that will be executed:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 weaver 的基本内容。其目的是构建（在运行时动态编译）将要执行的程序：
- en: '[PRE6]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Writing tests
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: 'Creating tests for Kelp.Net is incredibly simple. Each test that you author
    needs only a single `Run` function exposed. The rest is your logic as to how you
    want your network to operate. The general guidelines for your `Run` function would
    be:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Kelp.Net 编写测试非常简单。你编写的每个测试只需要公开一个 `Run` 函数。其余的是你想要网络如何运行的逻辑。你的 `Run` 函数的一般指南将是：
- en: 'Load data (real or simulated):'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载数据（真实或模拟）：
- en: '[PRE7]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create your function stack:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的函数堆栈：
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Select your optimizer:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择你的优化器：
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Train your data:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练你的数据：
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Test your data:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的数据：
- en: '[PRE11]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Benchmarking functions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试函数
- en: The `SingleBenchmark` class within the `KelpNetTester` class allows for simple
    benchmarking of various activation, noise, and other functions. If a function
    has a GPU capability, that is benchmarked, and so are CPU capabilities. The timing
    is at the microsecond level, as ReLU forward will usually always be below 1 ms
    in granularity.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`KelpNetTester` 类中的 `SingleBenchmark` 类允许对各种激活、噪声和其他函数进行简单的基准测试。如果一个函数具有 GPU
    功能，那么它将被基准测试，CPU 功能也是如此。时间精度在微秒级别，因为 ReLU 前向通常总是低于 1 毫秒的粒度。'
- en: '**With CPU enabled**![](img/e2b3619a-941f-49cf-8c3f-116833511bf8.png)**With
    GPU enabled**![](img/03550d87-07a5-4a7e-86b1-e3a64b026410.png)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**启用 CPU**![图片](img/e2b3619a-941f-49cf-8c3f-116833511bf8.png)**启用 GPU**![图片](img/03550d87-07a5-4a7e-86b1-e3a64b026410.png)'
- en: Now let's talk about how we run a single benchmark.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈如何运行单个基准测试。
- en: Running a Single Benchmark
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行单个基准测试
- en: 'When you run the `SingleBenchmark` class, the functions you see in the upcoming
    images will be timed. Forward and backward CPU and GPU timing will be provided
    (GPU when applicable). Here is a collapsed view of the benchmark tests:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 `SingleBenchmark` 类时，你将在即将出现的图像中看到的功能将被计时。将提供前向和反向 CPU 和 GPU 的时间（当适用时）。以下是基准测试的折叠视图：
- en: '![](img/4e9befcb-0529-4b8e-8f39-6a46752776e6.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e9befcb-0529-4b8e-8f39-6a46752776e6.png)'
- en: 'And here is an expanded view of the benchmarks:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是基准测试的展开视图：
- en: '![](img/78e325aa-8eda-4da2-b0aa-5471ce3d223e.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/78e325aa-8eda-4da2-b0aa-5471ce3d223e.png)'
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we welcomed you to the world of intuitive deep learning. We
    showed you how you could use Kelp.Net to be your research platform to test virtually
    any hypothesis. We also showed you the power and flexibility of Kelp.Net. In our
    next chapter, we will enter the world of quantum computing and show you a little
    bit of the future of computing. Hold on to your hats, this one is different!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们欢迎你进入直观深度学习的世界。我们展示了你如何使用 Kelp.Net 作为你的研究平台来测试几乎任何假设。我们还展示了 Kelp.Net
    的强大功能和灵活性。在我们的下一章中，我们将进入量子计算的世界，并展示计算的一小部分未来。戴上你的帽子，这一章是不同的！
- en: References
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '*Convolutional Architecture for fast feature embedding*, Y Jia, E Shelhamer,
    J Donahue, S Karayev, J Long, proceedings of the 22^(nd) ACM international conference,
    2014'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*快速特征嵌入的卷积架构*，Y Jia, E Shelhamer, J Donahue, S Karayev, J Long，第 22 届 ACM 国际会议论文集，2014'
- en: Chainer at [https://docs.chainer.org/en/stable/index.html](https://docs.chainer.org/en/stable/index.html)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Chainer 在 [https://docs.chainer.org/en/stable/index.html](https://docs.chainer.org/en/stable/index.html)
- en: '*Learning* *Multiple Layers of Features from Tiny Images* at [https://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf](https://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf),
    Alex Krizhevsky, 2009'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*从微小图像中学习多层特征*，Alex Krizhevsky，2009，见 [https://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf](https://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf)'
- en: Original Kelp.Net at [https://github.com/harujoh](https://github.com/harujoh)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始 Kelp.Net 在 [https://github.com/harujoh](https://github.com/harujoh)
- en: '(Filice ''15) Simone Filice, Giuseppe Castellucci, Danilo Croce, Roberto Basili,
    *Kelp: a kernel-based Learning Platform for Natural Language Processing*, proceedings
    of ACL: system demonstrations, Beijing, China (July 2015)'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (Filice '15) Simone Filice, Giuseppe Castellucci, Danilo Croce, Roberto Basili，*Kelp：一种基于核的自然语言处理学习平台*，ACL
    系统演示会议论文集，北京，中国（2015 年 7 月）
