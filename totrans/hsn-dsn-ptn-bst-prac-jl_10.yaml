- en: Maintainability Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性模式
- en: This chapter will cover several patterns that are related to improving code
    readability and the ease of maintenance. These aspects are sometimes overlooked
    because programmers always think that they know what they are doing. In reality,
    programmers do not always write code that is readable to others. Sometimes, the
    code could be too cluttered and difficult to follow, or the files may not be very
    well organized. These problems can often be mitigated by refactoring.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍与提高代码可读性和易于维护相关的几种模式。这些方面有时会被忽视，因为程序员总是认为他们知道自己在做什么。实际上，程序员并不总是编写其他人可读的代码。有时，代码可能过于杂乱，难以跟随，或者文件可能没有很好地组织。这些问题通常可以通过重构来缓解。
- en: 'Metaprogramming can be a good way to further improve readability and maintainability.
    In some cases, there are existing macros that we can utilize today. It would be
    a shame if we do not explore such opportunities. We know good programmers always
    have the relentless desire for achieving excellence, so learning these techniques
    would be a rewarding exercise. In the subsequent sections, we will look into the
    following patterns:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程可以是一个进一步提高可读性和可维护性的好方法。在某些情况下，我们可以利用今天现有的宏。如果我们不探索这样的机会，那将是一件遗憾的事情。我们知道优秀的程序员总是有着不懈的追求卓越的渴望，因此学习这些技术将是一项有益的练习。在接下来的章节中，我们将探讨以下模式：
- en: Sub-module pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子模块模式
- en: Keyword definition pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字定义模式
- en: Code generation pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码生成模式
- en: Domain-specific language pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域特定语言模式
- en: By the end of this chapter, you will have learned how to organize your code
    better. You will be able to reduce clutter and write very concise code. In addition,
    if you are working on a problem with a specific industry domain, you can build
    your own **domain-specific language** (**DSL**) to further express your problem
    clearly in your own syntax.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何更好地组织你的代码。你将能够减少杂乱，并编写非常简洁的代码。此外，如果你正在处理一个具有特定行业领域的难题，你可以构建自己的**领域特定语言**（**DSL**）来进一步清晰地用你自己的语法表达你的问题。
- en: '*Let''s go!*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*让我们开始吧！*'
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample source code is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter07).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 示例源代码位于[https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter07)。
- en: The code is tested in a Julia 1.3.0 environment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在 Julia 1.3.0 环境中进行测试。
- en: Sub-module pattern
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子模块模式
- en: When a module becomes too large, it can be difficult to manage and comprehend.
    Generally, it can happen organically when the programmer keeps adding more and
    more functionalities to an application. So, how large is too large? It is difficult
    to say as it varies and depends on the programming language, the problem domain,
    and even the skillsets of the application maintainers. Nevertheless, it is mostly
    agreed upon by professionals that smaller modules are easier to manage, especially
    when the code is maintained by multiple developers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模块变得太大时，它可能难以管理和理解。通常，当程序员不断地向应用程序添加更多功能时，这种情况会自然发生。那么，多大才算太大？这很难说，因为它因编程语言、问题领域以及应用程序维护者的技能集而异。尽管如此，专业人士普遍认为，较小的模块更容易管理，尤其是在代码由多个开发者维护的情况下。
- en: In this section, we will explore the idea of splitting the source code of a
    large module into separately managed sub-modules. We will discuss how to make
    that decision and how to do that properly. As part of our journey, we will look
    into some examples and see how other experts do it in their packages.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨将大型模块的源代码拆分为单独管理的子模块的想法。我们将讨论如何做出这个决定以及如何正确地执行。作为我们旅程的一部分，我们将查看一些示例，并看看其他专家如何在他们的包中这样做。
- en: Understanding when sub-module is needed
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解何时需要子模块
- en: 'When should we consider creating sub-modules? There are several factors to
    consider:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在什么时候考虑创建子模块？有几个因素需要考虑：
- en: 'First, we could consider the size of the application. Size is an abstract concept
    and can be measured in several ways, some of which are mentioned here:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们可以考虑应用程序的大小。大小是一个抽象概念，可以通过多种方式来衡量，其中一些方式在这里被提及：
- en: '**Number of lines of code**: This is the simplest measure to understand the
    size of an application. The more lines of code in the source files, the larger
    the application. This is analogous to the number of pages in a book. It takes
    more time for you to read and understand the content for a book that has more
    pages.'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码行数**：这是理解应用程序大小的最简单方法。源文件中的代码行数越多，应用程序就越大。这类似于一本书的页数。一本书的页数越多，你阅读和理解内容所需的时间就越长。'
- en: '**Number of functions**: When there are too many functions in a single module,
    it is more difficult to understand and learn all those functions. When there are
    too many functions, the number of interactions between functions naturally increase,
    making the application more prone to messy spaghetti code.'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数数量**：当单个模块中有太多函数时，理解和学习所有这些函数会更加困难。当函数数量过多时，函数之间的交互数量自然增加，使得应用程序更容易出现混乱的意大利面代码。'
- en: '**Number of data types**: Every data type represents a kind of an object. It
    is more difficult for a developer to comprehend all the functions operating on
    a large number of data types because the human brain cannot handle too many concepts
    at the same time.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据类型数量**：每种数据类型都代表一种对象。对于开发者来说，理解作用于大量数据类型的所有函数是比较困难的，因为人脑不能同时处理太多概念。'
- en: The second thing we should consider is separation of concern. As we look into
    an application that comprises various components, we may logically think of them
    as separate things that can be managed independently. Humans are an excellent
    species that know how to work on items that are small and organized.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还应该考虑关注点的分离。当我们查看由各种组件组成的应用程序时，我们可能会逻辑上认为它们是独立的事物，可以独立管理。人类是一种优秀的物种，知道如何处理小而有序的项目。
- en: Lastly, we can consider the complexity of matter. Sometimes, you look at the
    source code and realize that the logic is difficult to grasp. Perhaps it's the
    domain knowledge. Or, it could be a complex algorithm. While the size of the application
    is not large, it may still make sense to split the code into separate files physically.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可以考虑物质复杂性。有时候，你看一下源代码，会发现逻辑难以理解。这可能是因为领域知识。或者，它可能是一个复杂的算法。尽管应用程序的大小并不大，但将代码物理上拆分成单独的文件仍然是有意义的。
- en: So far, we have not set any concrete threshold for any of the preceding factors.
    That is because the decision to call something large or complex is quite subjective.
    A common way to do that is to have a discussion among several software engineers
    and make a group decision. Doing that allows us to overcome the *original developer
    bias*, where the person already knows everything by heart, and therefore, the
    person would tend to believe that the application is not too large nor too complex.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有为任何先前的因素设定任何具体的阈值。这是因为判断某事物是否庞大或复杂是非常主观的。一个常见的方法是让几位软件工程师进行讨论，并做出集体决定。这样做可以帮助我们克服*原始开发者偏见*，即某人已经对一切了如指掌，因此，这个人可能会倾向于认为应用程序既不太大也不太复杂。
- en: Suppose that you are ready to take the plunge and split part of your code into
    sub-modules. The next challenge is to figure out how to do it properly. The work
    can be part art and part science. To formalize the process for splitting source
    code into sub-modules, we will first discuss the concept of coupling.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经准备好跳入水中，将部分代码拆分成子模块。接下来的挑战是如何正确地做到这一点。这项工作既需要艺术也需要科学。为了将源代码拆分成子模块的过程形式化，我们首先将讨论耦合的概念。
- en: Understanding afferent and efferent coupling
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解输入和输出耦合
- en: Before splitting code into separate components, the first step is to analyze
    the existing code structure. Are there any high-level domain concepts that stand
    on their own? For example, a banking application may involve account management,
    deposit/withdrawal, balance transfer, customer notification, and so on. Each of
    these domain concepts can potentially be split into separate components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在将代码拆分成单独的组件之前，第一步是分析现有的代码结构。是否存在任何独立存在的高级领域概念？例如，一个银行应用程序可能涉及账户管理、存款/取款、转账、客户通知等。这些领域概念中的每一个都可能被拆分成单独的组件。
- en: 'We must also understand how components interact with each other. Here, we will
    talk about two concepts that originated from object-oriented programming:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须了解组件之间是如何相互作用的。在这里，我们将讨论起源于面向对象编程的两个概念：
- en: Afferent coupling – number of external entities that depend on the current entity
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入耦合 - 依赖于当前实体的外部实体数量
- en: Efferent coupling – number of external entities that the current entity depends
    upon
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出耦合 - 当前实体所依赖的外部实体的数量
- en: 'Let''s take a look at this diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个图：
- en: '![](img/412d1824-97f5-42e4-93f0-9ce913d61c83.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/412d1824-97f5-42e4-93f0-9ce913d61c83.png)'
- en: 'In this example, we can arrive at the following observations:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以得出以下观察结果：
- en: Component A has two efferent couplings.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件A有两个输出耦合。
- en: Component B has one afferent coupling and one efferent coupling.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件B有一个输入耦合和一个输出耦合。
- en: Component C has one efferent coupling.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件C有一个输出耦合。
- en: Component D has three afferent couplings.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件D有三个输入耦合。
- en: So, if a component is *used by* many external components, then this component
    has high afferent coupling. On the other hand, if a component *uses* many external
    components, then it has high efferent coupling.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果一个组件被许多外部组件*使用*，那么这个组件就有高输入耦合。另一方面，如果一个组件*使用*许多外部组件，那么它就有高输出耦合。
- en: These coupling characteristics help us to understand the stability requirement
    of a component. A component having high afferent coupling needs to be as stable
    as possible because making changes in this component may have a higher risk of
    breaking other components. That would be the case for Component D in the preceding example.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些耦合特性帮助我们理解组件的稳定性要求。具有高输入耦合的组件需要尽可能稳定，因为在这个组件中做出更改可能具有更高的风险，会破坏其他组件。在前面例子中的组件D就是这种情况。
- en: Similarly, a component having high efferent coupling means that it may be more
    unstable due to many possible changes from the components that it depends on.
    That would be the case for the preceding Component A. Hence, it would be best
    to reduce coupling whenever possible, whether it's afferent or efferent. A decoupled
    system tends to have a minimum number of afferent and efferent couplings.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，具有高输出耦合的组件可能由于它所依赖的组件的许多可能变化而更加不稳定。前面例子中的组件A就是这种情况。因此，尽可能减少耦合是最佳选择，无论是输入耦合还是输出耦合。解耦系统通常具有最少数量的输入和输出耦合。
- en: The same concepts apply when designing sub-modules. When we split code into
    separate sub-modules, it would be most ideal if afferent/efferent couplings are
    minimized. Now, we will first take a look at the best practice of organizing files
    for sub-modules.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 设计子模块时也适用相同的概念。当我们把代码分成独立的子模块时，如果输入/输出耦合最小化，那就最理想了。现在，我们将首先看看组织子模块文件的最佳实践。
- en: Organizing sub-modules
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织子模块
- en: 'There are generally two patterns for organizing sub-module files. Let''s take
    a look at each:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 组织子模块文件通常有两种模式。让我们看看每种模式：
- en: 'The first one involves a simpler situation where each sub-module is fully contained
    in a single source file, as follows:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种情况涉及一个更简单的情况，即每个子模块完全包含在一个源文件中，如下所示：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second one involves larger sub-modules where there could be several source
    files for each sub-module. In that case, the source code of a sub-module resides
    in a subdirectory:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种情况涉及较大的子模块，其中每个子模块可能有几个源文件。在这种情况下，子模块的源代码位于子目录中：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Of course, the sub module''s directory may include multiple files. In the preceding
    example, `sub_module1` may contain several more source files, which are shown
    in the following code snippet:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，子模块的目录可能包含多个文件。在前面例子中，`sub_module1`可能包含更多源文件，这些文件在下面的代码片段中显示：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we will look into how to reference symbols and functions between the modules
    and these sub-modules.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何在模块和这些子模块之间引用符号和函数。
- en: Referencing symbols and functions between modules and sub-modules
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模块和子模块之间引用符号和函数
- en: A module can access its sub-modules using the regular `using` or `import` statements.
    In fact, a sub-module does not work any differently than an external package,
    except how it is being referenced.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以使用常规的`using`或`import`语句访问其子模块。实际上，子模块与外部包的工作方式没有区别，只是引用方式不同。
- en: 'Perhaps we can recall the example from [Chapter 2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules,
    Packages, and Type Concepts*. Back then, we created a `Calculator` module that
    defines two interest rate-related functions and a `Mortgage` sub-module that defines
    a payment calculator function. The `Calculator` module file has the following
    source code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们可以回忆起[第2章](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml)中的例子，*模块、包和类型概念*。当时，我们创建了一个`Calculator`模块，它定义了两个与利率相关的函数和一个`Mortgage`子模块，该子模块定义了一个支付计算器函数。`Calculator`模块文件具有以下源代码：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Furthermore, the sub-module contains the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，子模块包含以下代码：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's look into how to reference functions and symbols from a sub-module and
    vice versa.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何从子模块引用函数和符号，反之亦然。
- en: Referencing symbols defined in sub-modules
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从子模块引用定义的符号
- en: To begin, we can finish our implementation of the `Mortgage` sub-module with
    a real implementation of the `payment` function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以通过`payment`函数的真实实现来完成`Mortgage`子模块的实现。
- en: 'Let''s see how this works:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的：
- en: 'The `payment` function takes a loan amount, an annual interest rate, the number
    of years for the loan, and calculates the monthly payment of the loan, as shown
    in the following code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`payment`函数接受贷款金额、年利率、贷款年数，并计算贷款的月付款额，如下面的代码所示：'
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this point, the `Calculator` module should be able to use the `Mortgage` sub-module
    as if it''s yet another module, except that the notation to get access to the
    sub-module requires a relative path that is prefixed with a dot notation:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，`Calculator`模块应该能够像使用另一个模块一样使用`Mortgage`子模块，只是访问子模块的表示法需要一个以点表示法为前缀的相对路径：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we have brought the `payment` function into the current scope of the
    sub-module via `using .Mortgage: payment`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '这里，我们通过`using .Mortgage: payment`将`payment`函数引入了子模块的当前作用域。'
- en: 'In order to organize our code better, we have also moved the functions into
    a separate file called `funcs.jl`. The code is shown as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好地组织我们的代码，我们还把函数移动到了一个名为`funcs.jl`的单独文件中。代码如下：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see, the new `mortgage` function can use the `payment` function from
    the Mortgage sub-module now.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，新的`mortgage`函数现在可以使用来自Mortgage子模块的`payment`函数。
- en: Referencing symbols from the parent module
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从父模块引用符号
- en: 'If the sub-module needs access to any symbol from the parent module, then the
    sub-module may use the `import` or `using` statement while adding `..` as a prefix
    to the name of the parent module. This is shown with the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子模块需要访问父模块中的任何符号，那么子模块可以在添加`..`作为父模块名称的前缀的同时使用`import`或`using`语句。以下代码展示了这一点：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, the `Mortgage` sub-module has access to the `days_per_year` constant from
    the parent module.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Mortgage`子模块可以访问父模块中的`days_per_year`常量。
- en: Having the ability to reference symbols and functions between modules and sub-modules
    allows us to just reorganize code into various sub-modules and keep it working
    as before. However, the reason for separating code into sub-modules in the first
    place is to allow the developer to work in each module independently. In addition,
    having bidirectional references could lead to confusion and messy spaghetti code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在模块和子模块之间引用符号和函数，使我们能够将代码重新组织到各种子模块中，同时保持其原有的工作状态。然而，最初将代码分离到子模块中的原因是为了让开发者能够独立地在每个模块中工作。此外，双向引用可能会导致混淆和混乱的意大利面条式代码。
- en: Next, we will discuss how to reduce such coupling among modules and sub-modules.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何减少模块和子模块之间的这种耦合。
- en: Removing bidirectional coupling
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除双向耦合
- en: When we have a module (or sub-module) referencing another sub-module and vice
    versa, it increases coupling between these components. Generally speaking, it
    is best to avoid bidirectional dependency between the parent module and the sub-module
    because it introduces tight coupling and makes the code difficult to understand
    and debug. How can we fix this? Let's explore this next.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模块（或子模块）引用另一个子模块，反之亦然时，会增加这些组件之间的耦合。一般来说，最好避免父模块和子模块之间的双向依赖，因为它引入了紧密耦合，使得代码难以理解和调试。我们该如何解决这个问题？让我们接下来探讨这个问题。
- en: Passing data as function arguments
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据作为函数参数传递
- en: 'The first solution is to pass the required data as a function argument. Suppose
    that the `payment` function from the `Mortgage` sub-module can take a `days_per_year` keyword
    argument, then the `Calculator` module can just pass the value as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种解决方案是将所需数据作为函数参数传递。假设`Mortgage`子模块中的`payment`函数可以接受一个名为`days_per_year`的关键字参数，那么`Calculator`模块可以按如下方式传递值：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Hence, the `Mortgage` sub-module does not really need to reference the `days_per_year`
    symbol from `Calculator` anymore, reducing any unnecessary dependency.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Mortgage`子模块实际上不再需要从`Calculator`引用`days_per_year`符号，从而减少了任何不必要的依赖。
- en: Factoring common code as another sub-module
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将通用代码作为另一个子模块进行因式分解
- en: Another solution is to split the dependent member into a separate sub-module
    and have both existing modules depend on the new sub-module.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是将依赖成员拆分到单独的子模块中，并让两个现有模块都依赖于这个新的子模块。
- en: 'Suppose that we have two sub-modules set up in a way that they use functions
    from each other. Consider the scenario depicted in the diagram as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经以它们相互使用函数的方式设置了两个子模块。考虑以下图中描述的场景：
- en: '![](img/98b3b41e-4aaf-4f6e-b58f-b92714723954.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98b3b41e-4aaf-4f6e-b58f-b92714723954.png)'
- en: The `func1` function from the first sub-module uses `func6` from the other sub-module.
    And, the `func4` function from the other sub-module needs to call the `func3` function
    from the first module. Clearly, there is a high coupling between these two modules.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 来自第一个子模块的`func1`函数使用了来自其他子模块的`func6`。此外，来自其他子模块的`func4`函数需要调用第一个模块中的`func3`函数。显然，这两个模块之间存在高度的耦合。
- en: 'Considering the dependencies between these modules, it looks like a cycle as
    the first sub-module depends on the second sub-module and vice versa. To fix that,
    we can introduce a new sub-module to break the cycle as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这些模块之间的依赖关系，看起来像是一个循环，因为第一个子模块依赖于第二个子模块，反之亦然。为了解决这个问题，我们可以引入一个新的子模块来打破这个循环，如下所示：
- en: '![](img/d65272c2-b4ee-4f24-ab5a-4bdae82135c7.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d65272c2-b4ee-4f24-ab5a-4bdae82135c7.png)'
- en: Breaking the cycle has the benefit of a cleaner dependency graph. It also makes
    the code easier to understand.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 打破循环的好处是拥有更清晰的依赖图。它也使代码更容易理解。
- en: Considering splitting into top-level modules
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑拆分为顶层模块
- en: If we are already considering creating sub-modules, it may be a good time to
    consider splitting the code into top-level modules. These top-level modules can
    be put together as separate Julia packages.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经在考虑创建子模块，那么可能是时候考虑将代码拆分为顶层模块了。这些顶层模块可以组合成独立的Julia包。
- en: 'Let''s take a look at the benefits and potential issues for making new top-level
    modules:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看创建新的顶层模块的好处和潜在问题：
- en: 'The benefits of having separate top-level modules are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有独立顶层模块的好处如下：
- en: Each package can have its own release life cycle and version. It is possible
    to make changes to a package and release only that portion.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个包都可以有自己的发布生命周期和版本。可以修改包并仅发布该部分。
- en: Version compatibility is enforced by Julia's `Pkg` system. A new version of
    the package may be released, and it may be used by another package as long as
    the package versions are compatible.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia的`Pkg`系统强制执行版本兼容性。一个包的新版本可能被发布，并且只要包版本兼容，它就可以被另一个包使用。
- en: Packages are more reusable because they can be utilized by other applications.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包更可重用，因为它们可以被其他应用程序使用。
- en: 'Potential issues with top-level modules are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层模块的潜在问题如下：
- en: There is more management overhead because each package will be maintained and
    released independently.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个包都将独立维护和发布，因此管理开销更大。
- en: Deployment may be more difficult since multiple packages have to be installed
    and inter dependent packages must obey version compatibility requirements.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署可能更困难，因为必须安装多个包，并且相互依赖的包必须遵守版本兼容性要求。
- en: Understanding the counterarguments of using sub-modules
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解使用子模块的反驳意见
- en: 'You are advised to avoid this pattern under the following conditions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在以下条件下避免此模式：
- en: When the existing code base is not large enough, splitting into sub-modules
    too early hinders the speed of development. We should avoid doing this prematurely.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当现有的代码库不够大时，过早地将代码拆分为子模块会阻碍开发速度。我们应该避免过早地进行此操作。
- en: When there is a high coupling in the source code, it can be difficult to split
    the code. In that case, try to refactor the code to reduce coupling and then reconsider
    splitting code into sub-modules later.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当源代码中存在高度耦合时，拆分代码可能很困难。在这种情况下，尝试重构代码以减少耦合，然后稍后再重新考虑将代码拆分为子模块。
- en: The idea of creating sub-modules does force the programmer to think about code
    dependencies. It is a necessary step when the application eventually grows bigger.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建子模块的想法确实迫使程序员思考代码依赖关系。当应用程序最终变得更大时，这是一个必要的步骤。
- en: Next, we will discuss the keyword definition pattern, which allows us to construct
    objects with more readable code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论关键字定义模式，它允许我们用更易读的代码构建对象。
- en: Keyword definition pattern
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键字定义模式
- en: In Julia, you can create an object using the default constructor, which accepts
    a list of positional arguments for each of the fields defined for the struct.
    For small objects, this should be simple and straightforward. For larger objects,
    it becomes confusing because it is hard to remember which argument corresponds
    to which field without referring to the struct's definition every time we write
    code to create such objects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，你可以使用默认构造函数创建一个对象，该构造函数接受为结构体中定义的每个字段提供一个位置参数列表。对于小型对象，这应该是简单直接的。对于大型对象，这会变得令人困惑，因为不参考结构体定义就很难记住哪个参数对应哪个字段，每次编写创建此类对象的代码时都需要这样做。
- en: In 1956, George Miller, a psychologist, published research that involved figuring
    out how many random digits a person could remember at any time, so the Bell System
    could decide how many numbers to use for the format of a telephone number. He
    found that most people can only remember five to nine digits at any time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在1956年，心理学家乔治·米勒发表了一项研究，研究一个人在任何时候能记住多少随机数字，这样贝尔系统就可以决定电话号码格式的数字使用数量。他发现，大多数人一次只能记住五到九个数字。
- en: If remembering digits is difficult enough, it should be even more difficult
    to remember fields that come with different names and types.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果记住数字已经足够困难，那么记住具有不同名称和类型的字段应该更加困难。
- en: We will discuss how to reduce such stress when developing Julia code, and how
    it can be done using the `@kwdef` macro so that the code is easy to read and maintain.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何减少在编写Julia代码时产生的这种压力，以及如何使用`@kwdef`宏来实现，这样代码就易于阅读和维护。
- en: Revisiting struct definitions and constructors
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视结构体定义和构造函数
- en: Let's first take a look at how a struct is defined and what constructor is provided.
    Consider the use case of text style configuration for a text editing application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看结构体是如何定义的，以及提供了什么构造函数。考虑文本编辑应用程序中文本样式配置的使用案例。
- en: 'We may define a struct as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样定义一个结构体：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By default, Julia provides a constructor with positional arguments for all
    fields in the same order as how they are defined in the struct. So, the only way
    to create a `TextStyle` object is to do the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Julia提供了一个构造函数，它为结构体中定义的所有字段提供位置参数，顺序与它们在结构体中定义的顺序相同。因此，创建`TextStyle`对象的唯一方法是执行以下操作：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There is nothing wrong here, but we could argue that the code is not very readable.
    Every time we have to write code to create a `TextStyle` object, we must ensure
    that all arguments are specified in the right order. In particular, as a developer,
    I must remember that the first three arguments represent font settings, then followed
    by two colors where the foreground color comes first, and so on. In the end, I
    just give up and go back to revisit the struct definition again.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有错误，但我们可以说代码的可读性并不高。每次我们编写代码来创建一个`TextStyle`对象时，我们必须确保所有参数都按正确的顺序指定。特别是，作为一个开发者，我必须记住前三个参数代表字体设置，然后是两个颜色，其中前景色在前，以此类推。最后，我只好放弃，重新回到结构体定义中去。
- en: Another issue is that we may want to have default values for some fields. For
    example, we want the `alignment` field to have a value of `"left"` and the `rotation` field
    to have `0` by default. The default constructor does not provide an easy way to
    do that.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是我们可能希望某些字段有默认值。例如，我们希望`alignment`字段默认值为`"left"`，而`rotation`字段默认为`0`。默认构造函数并没有提供一种简单的方式来做到这一点。
- en: A more sensible syntax for creating objects with so many arguments is to use
    keyword arguments in the constructor. Let's try to implement that next.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建具有许多参数的对象的更合理的语法是在构造函数中使用关键字参数。让我们尝试实现这一点。
- en: Using keyword arguments in constructors
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构造函数中使用关键字参数
- en: 'We can always add new constructor functions to make it easier for creating
    objects. Using keyword arguments solves the following two problems:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以始终添加新的构造函数，使其更容易创建对象。使用关键字参数解决了以下两个问题：
- en: Code readability
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可读性
- en: Ability to specify default values
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定默认值的能力
- en: 'Let''s go ahead and define a new constructor as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续定义一个新的构造函数，如下所示：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we have elected to provide default values for most of the fields except
    `font_family` and `font_size`. It is simply defined as a function that provides
    keyword arguments for all fields in the struct. Creating the `TextStyle` object
    is much easier and the code is more readable now. In fact, we have obtained an
    additional benefit that the arguments can be specified in any order, as shown
    here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们选择为大多数字段提供默认值，除了 `font_family` 和 `font_size`。它被简单地定义为一个函数，为结构体中的所有字段提供关键字参数。创建
    `TextStyle` 对象变得更加容易，代码现在也更易读。事实上，我们获得了额外的好处，即参数可以按任何顺序指定，如下所示：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is, indeed, quite a simple recipe. We can just create this kind of constructor
    for every struct and the problem is solved. Right? Well, yes and no. While it
    is fairly easy to create these constructors, it is a hassle to do that for every
    struct everywhere.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个非常简单的配方。我们只需为每个结构体创建这种构造函数，问题就解决了。对吗？好吧，是的，也有不是的。虽然创建这些构造函数相当容易，但要在每个结构体上这样做确实很麻烦。
- en: In addition, the constructor definition must specify all field names in the
    function arguments, and these fields repeat in the body of the function. So, it
    becomes quite difficult to develop and maintain. Next, we will introduce a macro
    to simplify our code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，构造函数定义必须在函数参数中指定所有字段名称，并且这些字段在函数体中重复。因此，开发和维护变得相当困难。接下来，我们将介绍一个宏来简化我们的代码。
- en: Simplifying code with the @kwdef macro
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 @kwdef 宏简化代码
- en: 'Given that the keyword definition pattern addresses a fairly common use case,
    there is already a macro provided by Julia to help define structs along with constructors
    accepting keyword arguments. The macro is currently not exported, but you can
    use it directly as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关键字定义模式解决了一个相当常见的用例，Julia 已经提供了一个宏来帮助定义接受关键字参数的构造函数的结构体。该宏目前尚未导出，但您可以直接使用如下所示：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Basically, we can just place the `Base.@kwdef` macro in front of the type definition.
    As a part of the type definition, we can also provide default values. The macro
    automatically defines the struct and the corresponding constructor function with
    keyword arguments. We can see that by using the `methods` function as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们只需在类型定义前放置 `Base.@kwdef` 宏。作为类型定义的一部分，我们还可以提供默认值。该宏会自动定义结构体以及相应的带关键字参数的构造函数。我们可以通过以下方式看到：
- en: '![](img/68a1d94e-98ea-4421-8749-e7ce9d0060d0.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68a1d94e-98ea-4421-8749-e7ce9d0060d0.png)'
- en: 'From the output, we can see that the first method is the one that accepts keyword
    arguments. The second method is the default construct that requires positional
    arguments. Now, creating new objects is as convenient as we would like:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到第一个方法是接受关键字参数的方法。第二个方法是默认构造函数，它需要位置参数。现在，创建新对象就像我们希望的那样方便：
- en: '![](img/bec42ace-4d81-424e-8dd6-ae877d28709f.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bec42ace-4d81-424e-8dd6-ae877d28709f.png)'
- en: 'We should note that the preceding definition did not specify any default values
    for `font_family` and `font_size`. So, those fields are mandatory when creating
    a `TextStyle` object:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，前面的定义没有为 `font_family` 和 `font_size` 指定任何默认值。因此，在创建 `TextStyle` 对象时，这些字段是必需的：
- en: '![](img/39324ebd-d6dd-4d85-b96b-0a5afab117f4.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39324ebd-d6dd-4d85-b96b-0a5afab117f4.png)'
- en: Using this macro can greatly simplify object construction and make the code
    more readable. There is no reason not to use it everywhere.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个宏可以极大地简化对象构造，并使代码更易读。没有理由不将其用于所有地方。
- en: As of Julia version 1.3, the `@kwdef` macro is not exported. There is a feature
    request to export it. Should you feel uncomfortable using non-exported features,
    consider using the `Parameters.jl` package instead.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Julia 版本 1.3，`@kwdef` 宏尚未导出。有一个功能请求导出它。如果您觉得使用未导出的功能不舒服，请考虑使用 `Parameters.jl`
    包。
- en: Next, we will discuss code generation pattern, which allows us to create new
    functions dynamically so as to avoid writing repeated boilerplate code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论代码生成模式，它允许我们动态创建新函数，从而避免编写重复的样板代码。
- en: Code generation pattern
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码生成模式
- en: New Julia programmers are often amazed by the conciseness of the language. Surprisingly,
    some of the very popular Julia packages are written with very little code. There
    are multiple reasons for that, but one major contributing factor is the ability
    to generate code dynamically in Julia.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 Julia 程序员常常对语言的简洁性感到惊讶。令人惊讶的是，一些非常流行的 Julia 包是用非常少的代码编写的。这有多个原因，但一个主要的贡献因素是
    Julia 能够动态生成代码。
- en: In certain use cases, code generation can be extremely helpful. In this section,
    we will look into some code generation examples and try to explain how it can
    be done properly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the file logger use case
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider a use case for building a file logging facility.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we want to provide an API for logging messages to files based
    upon a set of logging levels. By default, we will support three levels: info,
    warning, and error. A logger facility is provided so that a message will be directed
    to a file, as long as it comes with a high enough logging level.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'The functional requirements can be summarized as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: An info-level logger accepts messages with info, warning, or error levels.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning-level logger accepts messages with warning or error levels only.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An error-level logger accepts messages with an error level only.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement the file logger, we will first define some constants for the three
    logging levels:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'These constants are designed to be in numerical order, so we can easily determine
    when a message has a logging level as high as what the logger can accept. Next,
    we define the `Logger` facility as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A `Logger` object carries the filename of the log file, the minimum level for
    which messages can be accepted by the logger, and a file handle that is used for
    saving data. We can provide a constructor for `Logger` as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The constructor automatically opens the specified file for writing. Now, we
    can develop the first logging function for info-level messages:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function is designed to write the message into the file only if the `INFO`
    level is high enough to be accepted by the logger. It also prints the current
    time using the `now()` function and an `[INFO]` label in the log file. Then, it
    writes all the arguments separated by spaces and finally flushes the I/O buffer.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'We can quickly test the code so far. First, we will use `info_logger`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d731f7c3-d00a-4de8-9c49-c8a7a8edf8c8.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: 'The message is correctly logged in the `/tmp/info.log` file. What happens if
    we send an info-level message to an error-level logger? Let''s take a look:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28148c4d-920f-4977-9b26-23877000bd3f.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: Now, this is a little more interesting. As expected, because the error-level
    logger only accepts a message with an `ERROR` level or higher, it did not pick
    up the info-level message.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we may be tempted to quickly finish the two other functions: `warning!`
    and `error!` and call it the day. If we were determined to do that, the `warning!` function
    would look just like `info!`, with just a few small changes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99466ffe-e10b-46f3-8448-16b0520fe85d.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: 'What are the differences between these two logging functions? Let''s take a
    look:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The function names are different: `info!` versus `warning!`.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logging level constants are different: `INFO` versus `WARNING`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The labels are different: `[INFO]` versus `[WARNING]`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than these, both functions shared the exact same code. Of course, we can
    just keep going and wrap up the project by writing `error!` the same way. However,
    this is not the best solution. Imagine that if the core logging logic needs to
    be changed, for example, the formatting of log messages, then we have to make
    the same change in three different functions. Worse yet, if we forget to modify
    all of these functions, then we end up with inconsistent logging formats. After
    all, we have violated the **Don't Repeat Yourself** (**DRY**) principle.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Code generation for function definitions
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code generation is one way to tackle this problem, as mentioned in the preceding
    section. What we will do is to build up the syntax of defining the function and
    then throw that into a loop to define all three logging functions. Here is how
    the code may look:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The explanation for the preceding code is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: As we need to define functions for three logging levels, we have created a loop
    that goes through a list of symbols: `:info`, `:warning`, and `:error`.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the loop, we can see the function name as `fn`, the label as `label`,
    and the constant for log level comparison (such as `INFO`, `WARN`, or `ERROR`) as `upper_level_sym`.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `@eval` macro to define the logging function, where the `fn` variables, `label`,
    and `upper_level_sym` are interpolated into the function body.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After running the code in the Julia REPL, all three functions: `info!`, `warning!`,
    and `error!` should be defined already. For testing, we can call these with three
    different kinds of loggers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try `info_logger` first:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62f6e51d-9509-4d00-9246-10768d779e96.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'As expected, all messages are logged to the file because `info_logger` can
    take messages at any level. Next, let''s test `error_logger`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94f9b0a0-7fb2-4aec-80bc-2abd03890dc1.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: In this case, only the error-level message was written to the log file. The
    `error_logger` code effectively filtered out any message that is lower than the
    error level.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Although we are quite satisfied with the resulting code, do we know what actually
    happened behind the scenes? How do we debug the code that we cannot even see?
    Let's take a look at this next.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Debugging code generation
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that the code is generated behind the scene, it may feel a little awkward
    when we cannot even see what the generated code will look like. How can we guarantee
    that the generated code is exactly what we expect after all those interpolations
    of variables?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there is a package called `CodeTracking` that can make debugging
    code generation easier. We will see how it works here.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'From the previous section, we should have generated three functions: `info!`,
    `warning!`, and `error!`. As these are defined as generic functions, we can examine
    what methods are defined for each. Let''s take `error!` as an example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86de4703-1c0c-4442-8f10-3ee14a317872.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'In this case, we only have a single method. We can get to the method object
    itself using the `first` function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44a8f083-716a-46bb-a0e6-97605cdb71df.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: 'Once we have a reference of the method object, we can lean on `CodeTracking`
    to reveal the source code of the generated function. In particular, we can use
    the `definition` function, which takes a method object and returns an expression
    object. In order to use this function, we also need to load the `Revise` package.
    Enough said, let''s try the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed446f67-790b-493c-8c8b-62994d639e3b.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Here, we can clearly see that the variables are interpolated correctly; the
    `logger.level` variable is compared with the `ERROR` constant, and the logging
    label correctly contains the `[ERROR]` string.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: We can also see that line numbers are included in the output. Since we defined
    the functions from the REPL, the line numbers are less useful. If we would have
    generated the functions from a module that is stored in a file, the filename and
    line number information would be much more interesting.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The line number nodes seem to be a bit too distracting here, though. We can
    easily remove them using the `rmlines` function from the `MacroTools` package:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27505180-7291-42e6-9a58-4ae8cffb4c76.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: The `MacroTools.postwalk` function is used to apply the `rmlines` function to
    every node in the abstract syntax tree. The `postwalk` function is necessary because
    the `rmlines` function only works with the current node.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to do code generation properly, let's turn around and
    ask ourselves—is code generation really necessary? Are there any other alternatives?
    Let us see in the next section.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Considering options other than code generation
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this section, we have been focusing on code generation techniques.
    The premise is that we can easily add a new function that works just like an existing
    one but a little differently. In practice, code generation is not the only option
    we have on hand.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue our discussion with the same example. As we recall, we wanted
    to add the `warning!` and `error!` functions after defining the logic for `info!`.
    If we take a step back, we can generalize the `info!` function and make it handle
    different logging levels. This can be done as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `logme!` function looks exactly like `info!` before, except that it takes
    two extra arguments: `level` and `label`. These variables are taken and used in
    the body of the function. Now we can define all three logging functions as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we can see, we have solved the original problem using a regular structured
    programming technique, and we have minimized as much repetitive code as possible.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the only variation between these functions are simple types:
    a constant and a string. In another situation, we may need to call different functions
    within the body. That is okay as well because functions are first-class in Julia,
    and so we could just pass around a reference of the function.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we do better? Yes. The code can be simplified a little more using closure
    technique. To illustrate the concept, let''s define a new `make_log_func` function
    as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This function takes the `level` and `label` arguments and returns an anonymous
    function that contains the main logging logic. The `level` and `label` arguments
    are captured in a closure and used inside the anonymous function. So, we can now
    define the logging functions more easily as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, three anonymous functions are defined here: `info!`, `warning!`, and `error!` and
    they all work equally well.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: In computer science terms, closure is a first-class function that captures variables
    from an enclosing environment.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Technically speaking, there is a non-trivial difference between the structured
    programming solution and closure. The former technique defines generic functions
    that are named functions within the module that can be extended. In contrast,
    anonymous functions are unique and cannot be extended.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to do code generation in Julia and how
    to debug this code. We have also discussed how to restructure code to achieve
    the same effect without having to use code generation technique. Both options
    are available.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss DSLs, which is a technique for building syntax for specific
    domain usage, thereby making the code much easier to read and write.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Domain-specific language pattern
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia is a general purpose programming language that can be used effectively
    for any domain problem. However, Julia is also one of the few programming languages
    that allows the developer to build new syntax to fit a specific domain usage.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: So, a DSL is an example of **Structured Query Language** (**SQL**). SQL is designed
    to process data in a two-dimensional table structure. It is very powerful, and
    yet it is only appropriate when you need to handle data in tables.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few prominent areas in the Julia ecosystem where a DSL is used
    extensively. The one that stood out the most is the `DifferentialEquations` package,
    which allows you to write differential equations in a form that is very close
    to their original mathematical notation. For example, consider the Lorenz system
    equations as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6b39340-b267-4954-8a9a-1bc151c0a186.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: 'The code to define these equations can be written as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see, the syntax almost matches with the mathematical equations.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: After this, in the next section, we will explore how to build our own DSL for
    a practical use case in computer graphics called L-System.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the L-System
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **L-System**, also known as **Lindenmayer System**, is a formal syntax for
    describing how organisms evolve by way of simple patterns. It was first introduced
    in 1968 by Aristid Lindenmayer, a Hungarian biologist and botanist. An L-System
    can generate interesting patterns that mimic real-life shape and form. A well-known
    example is the growth of a specific algae, which can be modeled as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is how it works. We always start with the axiom, in this case, the character
    `A`. For each generation, we apply the rules to every character in the string.
    If the character is A, then it is replaced with `AB`. Similarly, if the character
    is `B`, it is replaced with A. Let''s work through the first five iterations:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '`A`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AB`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABA`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABAAB`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABAABABA`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may wonder, how does it even look like an algae? Here''s a visualization
    of the growth from the first generation to the fifth generation:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11197064-fc9c-468d-b7c4-68b402e77e67.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: 'There are many softwares that can produce interesting graphical visualizations
    based on L-Systems. An example is **My Graphics**, an iOS app developed by me.
    The application can produce several kinds of patterns such as the preceding algae
    example. An interesting sample called a **Koch** curve is shown as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f43bf6e-dc2d-4e82-a33a-e3cabf81b3fa.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Enough said. From what we know so far, the concept is fairly simple. What we
    are going to do next is design a DSL for the L-System.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Designing DSL for L-System
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The characteristics of a DSL are that the source code should look like the
    original representation of the domain concept. In this case, the domain concept
    is described by an axiom and a set of rules. Using the algae growth example, it
    needs to look like the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we try to write them in plain Julia language, we may end up with code like
    this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As we can see, this is not ideal. While the code is neither long nor difficult
    to read, it does not look as clean as the L-System grammar. What we really want
    is to build a DSL that lets us specify the model as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will be the target syntax for our DSL.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the L-System core logic
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of this example, we will develop an L-System package together. Before
    we jump into the DSL implementation, let's take a quick detour and understand
    how the core logic works. Knowledge of the API allows us to design and test DSL
    properly.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Developing the LModel object
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To develop the `LModel` object, perform the following steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create a type called `LModel` to keep track of the axiom and the
    set of rules. The struct can be defined as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we can add a constructor that populates the `axiom` field and initializes
    the `rules` field:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'By design, the axiom is an array of a single element. The rules are captured
    in a dictionary for fast lookups. An `add_rule!` function is also written to append
    new rules to the model:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have used the `split` function to convert a string into an array of single-character
    strings.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we add a `Base.show` function just so we can display a model nicely
    on Terminal:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Having defined these functions, we can quickly verify our code as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93e1e95f-951f-4c90-b6e4-0e5b83c6c526.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: Next, we will work on the core logic that takes a model and keeps track of the
    current state of the iteration.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Developing the state object
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To simulate the growth of an L-System model, we can develop an `LState` type
    that keeps track of the current state of the growth. It''s a simple type that
    just keeps a reference to the model, the current iteration of growth, and the
    current result. For this, consider the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The constructor just needs to take the model as the only argument. It defaults
    `current_iteration` to `1` and defaults `result` to the axiom of the model, as
    shown here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We need a function to advance to the next stage of the growth. So, we just
    provide a `next` function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Basically, given the current state, it iterates all the elements of the current
    result and expands each element using the rules from the model. The `get` function
    looks up the element in the dictionary. If it is not found, it defaults to itself.
    The expanded elements are just appended to the `new_results` array.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, a new `LState` object is created with the next iteration number
    and the new result. For a better display in Terminal, we can add a `Base.show`
    method for `LState` as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `result` function just combines all the elements of the array into a single
    string. The `show` function displays both the current iteration number and the
    result string.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'We should have a fully functional system now. Let''s try to simulate the growth
    of the algae:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bb3bc5f-13e5-4d83-8a91-a198c3b367b7.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: '*Wonderful!* Now that the functionalities are built, we can move on to the
    interesting part of this chapter—how to create a DSL with the L-System syntax.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a DSL for L-System
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall from the previous section that we want to have a clean syntax for defining
    an L-System model. From a metaprogramming perspective, we just need to translate
    the code from one abstract syntax tree to another. The following diagram shows
    graphically what kind of translation is required:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42dd569b-7dda-480b-a0d6-049a50183069.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: It turns out that the translation is quite straightforward. When we encounter
    an axiom, we translate the code to construct a new `LModel` object. When we encounter
    a rule, we translate the code to an `add_rule!` function call.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: While it seems easy enough, this kind of source-to-source translation can be
    greatly simplified using pre-existing tools. In particular, the MacroTools package
    contains some very useful macros and functions for handling these cases. Let's
    first learn about the tool and then we can utilize them in developing our DSL.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Using the @capture macro
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MacroTools` package provides a macro called `@capture` that can be used
    to match an expression against a pattern. As part of the matching process, it
    also assigns variables for which the developer wishes to capture the matched values.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@capture` macro accepts two arguments; the first one is an expression
    that needs to be matched, and the second one is a pattern used for matching. Consider
    the following example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31789f4e-7b08-43e4-8516-8584c39ecf21.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: 'The macro returns `true` when the pattern can be matched, or else it just returns
    `false`. When the pattern is matched, the variables ending with an underscore
    will be assigned in the current environment, with the underscore stripped away
    from the variable name. In the preceding example, because `x = 1` matches `x =
    val_`, it has returned `true`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a760722-e681-4140-b3f0-b16648065432.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: Because the pattern was matched successfully, a `val` variable was also assigned
    with the value of `1`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Matching axiom and rule statements
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the same trick to extract useful information from the `axiom` and
    rule statements. Let''s do a quick experiment for the `axiom` statement, which
    consists of the word axiom, a colon, and a symbol. Matching it with the `@capture`
    macro is pretty slick as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/449c89e9-68ce-4a4f-b9e6-b57467fd0180.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: 'Matching a `rule` statement is just as easy. The only difference is that we
    want to match the original symbol and the corresponding replacement symbol, as
    shown here:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7eca749b-ff39-43a6-bef2-e7996dd58f15.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: Once matched, the `original` and `replacement` variables are assigned with the
    corresponding symbols from the rule. We can also observe that the matched variables
    are symbols rather than strings. As the `LModel` programming interface requires
    strings, we will have to perform an additional data conversion from the symbol
    in the `walk` function, which will be presented in the *Developing the macro for
    a DSL* section.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Using the postwalk function
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to traverse the whole abstract syntax tree, we can use the MacroTool''s
    `postwalk` function. To understand how it works, we can play with a simple example,
    as outlined in the following steps:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an expression object as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/793295b5-6846-4039-9f14-0958db34e525.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: Here, we have used the `rmlines` function to remove the line number nodes since
    we do not need them in this exercise.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can use the `postwalk` function to traverse the tree and display everything
    that it has ever encountered:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c34e43a4-1669-45ba-a29e-817f56f21ab7.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: The `postwalk` function accepts a function as its first argument and an expression
    as the second argument. As it traverses the tree, it calls the function with the
    sub-expression being visited. We can see that it considered every single leaf
    node (for example, `:x`) as well as every sub-tree from the expression such as `:(x
    = 1)`. It also includes the top-level expression as we can see at the bottom of
    the output.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: If we pay a little more attention to the order of the traversal, we realize
    that the `postwalk` function works from the bottom up, starting from the leaf
    nodes.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: MacroTools also provides a `prewalk` function that also traverses the tree.
    The difference between `prewalk` and `postwalk` is that `prewalk` would work from
    the top down rather than bottom up. You are encouraged to try that out and learn
    how they differ.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: For our use case, we can use either one.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to match expressions and traverse the tree, we have everything
    in our toolbox to develop our DSL. That's the fun part. *Let's go!*
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Developing the macro for a DSL
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To support the `LModel` syntax, we have to match both the axiom and rule statements
    to how they are written in the model.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started by creating the `lsys` macro, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The macro simply uses `postwalk` to traverse the abstract syntax tree. The
    resulting expression is returned as is. The main translation logic actually resides
    in the `walk` function as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let's dissect the preceding code one portion at a time.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'The `walk` function uses the `@capture` macro to match the `axiom` and `rule`
    patterns. When there is a match, the corresponding symbols are converted to a
    string and then interpolated into the corresponding expression, and the final
    expression is returned. Consider this line of code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `@capture` macro call tries to match the expression with the `axiom : sym_` pattern,
    which is an `axiom` symbol, followed by a colon, and then followed by another
    symbol. Since the `sym_` target symbol ends with an underscore, if the match is
    successful, the `sym` variable would be assigned with the matched value. In the
    `algae` model example of the *Developing the state object* section, we would expect
    `sym` to be assigned with the `:A` symbol. Once matched, the following code is
    executed:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The target expression simply constructs an `LModel` object and assigns it to
    the `model` variable. With the algae model, we can expect that the translated
    expression will look like this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Similarly, the `rule` statement can be matched using the pattern as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `original` and `replacement` variables are assigned, converted to a string,
    and interpolated into an `add_rule!` statement in the target expression.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `lsys` macro, the `walk` function is called by the `postwalk` function
    many times—once for each node and sub-tree of the abstract syntax tree. To see
    how `postwalk` generates the code, we can test it from the REPL:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cdd6c1f-f82e-4f83-9d86-35021d1b67f4.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: As it turns out, we are not completely done yet because the translated statements
    sit inside a `quote` block and the return value of the block would come from the
    block's last expression, which is zero as the `add_rule!` function does not return
    any meaningful value.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'This final change is actually the simple part. Let''s modify the `@lsys` macro
    again as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `push!` function was used to add the `:( model )` expression at the end
    of the block. Let''s test the macro expansion and see what it looks like:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/952c0249-95a2-45cf-87f2-536ef8a95bb9.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
- en: 'It''s good now! Finally, we can just use the macro as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce5c24ec-e98a-4dd1-9f28-8ba825403542.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: '*Awesome! *The `algae_model` example can now be constructed using our little
    DSL. As it turns out, developing a DSL is not difficult at all. Given excellent
    tools such as MacroTools, we can quickly come up with a set of translation patterns
    and manipulate an abstract syntax tree into whatever we want.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: A DSL is a great way to simplify the code and make it easier to maintain. It
    can be very useful in specific domain areas.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at several patterns related to improving the
    readability and maintainability of an application.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: First, we learned about when a module becomes too large and when it should be
    considered for reorganization. We realized that coupling is an important consideration
    when splitting code into separate modules. Next, we discussed the problem of constructing
    objects that have many fields. We determined that using a keyword-based constructor
    can make the code more readable and can provide additional flexibility of supporting
    default values. We learned that the Julia Base module already provides a macro.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Then we explored how to do code generation, which is a convenient technique
    for dynamically defining many similar functions without having to repeat the code.
    We picked up a utility from `CodeTracking` to review the generated source code.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we went over details about how to develop DSLs. It is a good way to
    simplify code by mimicking the syntax with the original form of the domain concepts.
    We used an L-System as an example for developing a DSL. We picked up several utilities
    from the MacroTools package, where we can transform our source code by matching
    patterns. We learned how to use the `postwalk` function to examine and transform
    source code. And, pleasantly, we were able to complete the exercise with very
    little code.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go over a set of patterns related to code safety.
    *Enjoy reading!*
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between afferent and efferent coupling?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are bidirectional dependencies bad from a maintainability perspective?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an easy way to generate code on the fly?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What would be an alternative to code generation?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When and why should you consider building a DSL?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the tools available for developing a DSL?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
