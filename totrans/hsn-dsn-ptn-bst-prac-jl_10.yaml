- en: Maintainability Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will cover several patterns that are related to improving code
    readability and the ease of maintenance. These aspects are sometimes overlooked
    because programmers always think that they know what they are doing. In reality,
    programmers do not always write code that is readable to others. Sometimes, the
    code could be too cluttered and difficult to follow, or the files may not be very
    well organized. These problems can often be mitigated by refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Metaprogramming can be a good way to further improve readability and maintainability.
    In some cases, there are existing macros that we can utilize today. It would be
    a shame if we do not explore such opportunities. We know good programmers always
    have the relentless desire for achieving excellence, so learning these techniques
    would be a rewarding exercise. In the subsequent sections, we will look into the
    following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Sub-module pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword definition pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code generation pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain-specific language pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to organize your code
    better. You will be able to reduce clutter and write very concise code. In addition,
    if you are working on a problem with a specific industry domain, you can build
    your own **domain-specific language** (**DSL**) to further express your problem
    clearly in your own syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '*Let''s go!*'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample source code is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: The code is tested in a Julia 1.3.0 environment.
  prefs: []
  type: TYPE_NORMAL
- en: Sub-module pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a module becomes too large, it can be difficult to manage and comprehend.
    Generally, it can happen organically when the programmer keeps adding more and
    more functionalities to an application. So, how large is too large? It is difficult
    to say as it varies and depends on the programming language, the problem domain,
    and even the skillsets of the application maintainers. Nevertheless, it is mostly
    agreed upon by professionals that smaller modules are easier to manage, especially
    when the code is maintained by multiple developers.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore the idea of splitting the source code of a
    large module into separately managed sub-modules. We will discuss how to make
    that decision and how to do that properly. As part of our journey, we will look
    into some examples and see how other experts do it in their packages.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding when sub-module is needed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When should we consider creating sub-modules? There are several factors to
    consider:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we could consider the size of the application. Size is an abstract concept
    and can be measured in several ways, some of which are mentioned here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number of lines of code**: This is the simplest measure to understand the
    size of an application. The more lines of code in the source files, the larger
    the application. This is analogous to the number of pages in a book. It takes
    more time for you to read and understand the content for a book that has more
    pages.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number of functions**: When there are too many functions in a single module,
    it is more difficult to understand and learn all those functions. When there are
    too many functions, the number of interactions between functions naturally increase,
    making the application more prone to messy spaghetti code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number of data types**: Every data type represents a kind of an object. It
    is more difficult for a developer to comprehend all the functions operating on
    a large number of data types because the human brain cannot handle too many concepts
    at the same time.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second thing we should consider is separation of concern. As we look into
    an application that comprises various components, we may logically think of them
    as separate things that can be managed independently. Humans are an excellent
    species that know how to work on items that are small and organized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we can consider the complexity of matter. Sometimes, you look at the
    source code and realize that the logic is difficult to grasp. Perhaps it's the
    domain knowledge. Or, it could be a complex algorithm. While the size of the application
    is not large, it may still make sense to split the code into separate files physically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have not set any concrete threshold for any of the preceding factors.
    That is because the decision to call something large or complex is quite subjective.
    A common way to do that is to have a discussion among several software engineers
    and make a group decision. Doing that allows us to overcome the *original developer
    bias*, where the person already knows everything by heart, and therefore, the
    person would tend to believe that the application is not too large nor too complex.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that you are ready to take the plunge and split part of your code into
    sub-modules. The next challenge is to figure out how to do it properly. The work
    can be part art and part science. To formalize the process for splitting source
    code into sub-modules, we will first discuss the concept of coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding afferent and efferent coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before splitting code into separate components, the first step is to analyze
    the existing code structure. Are there any high-level domain concepts that stand
    on their own? For example, a banking application may involve account management,
    deposit/withdrawal, balance transfer, customer notification, and so on. Each of
    these domain concepts can potentially be split into separate components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also understand how components interact with each other. Here, we will
    talk about two concepts that originated from object-oriented programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Afferent coupling – number of external entities that depend on the current entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efferent coupling – number of external entities that the current entity depends
    upon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/412d1824-97f5-42e4-93f0-9ce913d61c83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we can arrive at the following observations:'
  prefs: []
  type: TYPE_NORMAL
- en: Component A has two efferent couplings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component B has one afferent coupling and one efferent coupling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component C has one efferent coupling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component D has three afferent couplings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, if a component is *used by* many external components, then this component
    has high afferent coupling. On the other hand, if a component *uses* many external
    components, then it has high efferent coupling.
  prefs: []
  type: TYPE_NORMAL
- en: These coupling characteristics help us to understand the stability requirement
    of a component. A component having high afferent coupling needs to be as stable
    as possible because making changes in this component may have a higher risk of
    breaking other components. That would be the case for Component D in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a component having high efferent coupling means that it may be more
    unstable due to many possible changes from the components that it depends on.
    That would be the case for the preceding Component A. Hence, it would be best
    to reduce coupling whenever possible, whether it's afferent or efferent. A decoupled
    system tends to have a minimum number of afferent and efferent couplings.
  prefs: []
  type: TYPE_NORMAL
- en: The same concepts apply when designing sub-modules. When we split code into
    separate sub-modules, it would be most ideal if afferent/efferent couplings are
    minimized. Now, we will first take a look at the best practice of organizing files
    for sub-modules.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing sub-modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are generally two patterns for organizing sub-module files. Let''s take
    a look at each:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one involves a simpler situation where each sub-module is fully contained
    in a single source file, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one involves larger sub-modules where there could be several source
    files for each sub-module. In that case, the source code of a sub-module resides
    in a subdirectory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the sub module''s directory may include multiple files. In the preceding
    example, `sub_module1` may contain several more source files, which are shown
    in the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will look into how to reference symbols and functions between the modules
    and these sub-modules.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing symbols and functions between modules and sub-modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A module can access its sub-modules using the regular `using` or `import` statements.
    In fact, a sub-module does not work any differently than an external package,
    except how it is being referenced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps we can recall the example from [Chapter 2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules,
    Packages, and Type Concepts*. Back then, we created a `Calculator` module that
    defines two interest rate-related functions and a `Mortgage` sub-module that defines
    a payment calculator function. The `Calculator` module file has the following
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, the sub-module contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's look into how to reference functions and symbols from a sub-module and
    vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing symbols defined in sub-modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, we can finish our implementation of the `Mortgage` sub-module with
    a real implementation of the `payment` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `payment` function takes a loan amount, an annual interest rate, the number
    of years for the loan, and calculates the monthly payment of the loan, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the `Calculator` module should be able to use the `Mortgage` sub-module
    as if it''s yet another module, except that the notation to get access to the
    sub-module requires a relative path that is prefixed with a dot notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have brought the `payment` function into the current scope of the
    sub-module via `using .Mortgage: payment`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to organize our code better, we have also moved the functions into
    a separate file called `funcs.jl`. The code is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the new `mortgage` function can use the `payment` function from
    the Mortgage sub-module now.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing symbols from the parent module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the sub-module needs access to any symbol from the parent module, then the
    sub-module may use the `import` or `using` statement while adding `..` as a prefix
    to the name of the parent module. This is shown with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `Mortgage` sub-module has access to the `days_per_year` constant from
    the parent module.
  prefs: []
  type: TYPE_NORMAL
- en: Having the ability to reference symbols and functions between modules and sub-modules
    allows us to just reorganize code into various sub-modules and keep it working
    as before. However, the reason for separating code into sub-modules in the first
    place is to allow the developer to work in each module independently. In addition,
    having bidirectional references could lead to confusion and messy spaghetti code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how to reduce such coupling among modules and sub-modules.
  prefs: []
  type: TYPE_NORMAL
- en: Removing bidirectional coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have a module (or sub-module) referencing another sub-module and vice
    versa, it increases coupling between these components. Generally speaking, it
    is best to avoid bidirectional dependency between the parent module and the sub-module
    because it introduces tight coupling and makes the code difficult to understand
    and debug. How can we fix this? Let's explore this next.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data as function arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first solution is to pass the required data as a function argument. Suppose
    that the `payment` function from the `Mortgage` sub-module can take a `days_per_year` keyword
    argument, then the `Calculator` module can just pass the value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Hence, the `Mortgage` sub-module does not really need to reference the `days_per_year`
    symbol from `Calculator` anymore, reducing any unnecessary dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Factoring common code as another sub-module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another solution is to split the dependent member into a separate sub-module
    and have both existing modules depend on the new sub-module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we have two sub-modules set up in a way that they use functions
    from each other. Consider the scenario depicted in the diagram as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98b3b41e-4aaf-4f6e-b58f-b92714723954.png)'
  prefs: []
  type: TYPE_IMG
- en: The `func1` function from the first sub-module uses `func6` from the other sub-module.
    And, the `func4` function from the other sub-module needs to call the `func3` function
    from the first module. Clearly, there is a high coupling between these two modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the dependencies between these modules, it looks like a cycle as
    the first sub-module depends on the second sub-module and vice versa. To fix that,
    we can introduce a new sub-module to break the cycle as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d65272c2-b4ee-4f24-ab5a-4bdae82135c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Breaking the cycle has the benefit of a cleaner dependency graph. It also makes
    the code easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Considering splitting into top-level modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are already considering creating sub-modules, it may be a good time to
    consider splitting the code into top-level modules. These top-level modules can
    be put together as separate Julia packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the benefits and potential issues for making new top-level
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of having separate top-level modules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Each package can have its own release life cycle and version. It is possible
    to make changes to a package and release only that portion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version compatibility is enforced by Julia's `Pkg` system. A new version of
    the package may be released, and it may be used by another package as long as
    the package versions are compatible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages are more reusable because they can be utilized by other applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Potential issues with top-level modules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: There is more management overhead because each package will be maintained and
    released independently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment may be more difficult since multiple packages have to be installed
    and inter dependent packages must obey version compatibility requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the counterarguments of using sub-modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are advised to avoid this pattern under the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: When the existing code base is not large enough, splitting into sub-modules
    too early hinders the speed of development. We should avoid doing this prematurely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there is a high coupling in the source code, it can be difficult to split
    the code. In that case, try to refactor the code to reduce coupling and then reconsider
    splitting code into sub-modules later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea of creating sub-modules does force the programmer to think about code
    dependencies. It is a necessary step when the application eventually grows bigger.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the keyword definition pattern, which allows us to construct
    objects with more readable code.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword definition pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Julia, you can create an object using the default constructor, which accepts
    a list of positional arguments for each of the fields defined for the struct.
    For small objects, this should be simple and straightforward. For larger objects,
    it becomes confusing because it is hard to remember which argument corresponds
    to which field without referring to the struct's definition every time we write
    code to create such objects.
  prefs: []
  type: TYPE_NORMAL
- en: In 1956, George Miller, a psychologist, published research that involved figuring
    out how many random digits a person could remember at any time, so the Bell System
    could decide how many numbers to use for the format of a telephone number. He
    found that most people can only remember five to nine digits at any time.
  prefs: []
  type: TYPE_NORMAL
- en: If remembering digits is difficult enough, it should be even more difficult
    to remember fields that come with different names and types.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss how to reduce such stress when developing Julia code, and how
    it can be done using the `@kwdef` macro so that the code is easy to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting struct definitions and constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first take a look at how a struct is defined and what constructor is provided.
    Consider the use case of text style configuration for a text editing application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may define a struct as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Julia provides a constructor with positional arguments for all
    fields in the same order as how they are defined in the struct. So, the only way
    to create a `TextStyle` object is to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing wrong here, but we could argue that the code is not very readable.
    Every time we have to write code to create a `TextStyle` object, we must ensure
    that all arguments are specified in the right order. In particular, as a developer,
    I must remember that the first three arguments represent font settings, then followed
    by two colors where the foreground color comes first, and so on. In the end, I
    just give up and go back to revisit the struct definition again.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is that we may want to have default values for some fields. For
    example, we want the `alignment` field to have a value of `"left"` and the `rotation` field
    to have `0` by default. The default constructor does not provide an easy way to
    do that.
  prefs: []
  type: TYPE_NORMAL
- en: A more sensible syntax for creating objects with so many arguments is to use
    keyword arguments in the constructor. Let's try to implement that next.
  prefs: []
  type: TYPE_NORMAL
- en: Using keyword arguments in constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can always add new constructor functions to make it easier for creating
    objects. Using keyword arguments solves the following two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Code readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to specify default values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s go ahead and define a new constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have elected to provide default values for most of the fields except
    `font_family` and `font_size`. It is simply defined as a function that provides
    keyword arguments for all fields in the struct. Creating the `TextStyle` object
    is much easier and the code is more readable now. In fact, we have obtained an
    additional benefit that the arguments can be specified in any order, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is, indeed, quite a simple recipe. We can just create this kind of constructor
    for every struct and the problem is solved. Right? Well, yes and no. While it
    is fairly easy to create these constructors, it is a hassle to do that for every
    struct everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the constructor definition must specify all field names in the
    function arguments, and these fields repeat in the body of the function. So, it
    becomes quite difficult to develop and maintain. Next, we will introduce a macro
    to simplify our code.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying code with the @kwdef macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given that the keyword definition pattern addresses a fairly common use case,
    there is already a macro provided by Julia to help define structs along with constructors
    accepting keyword arguments. The macro is currently not exported, but you can
    use it directly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, we can just place the `Base.@kwdef` macro in front of the type definition.
    As a part of the type definition, we can also provide default values. The macro
    automatically defines the struct and the corresponding constructor function with
    keyword arguments. We can see that by using the `methods` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68a1d94e-98ea-4421-8749-e7ce9d0060d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the output, we can see that the first method is the one that accepts keyword
    arguments. The second method is the default construct that requires positional
    arguments. Now, creating new objects is as convenient as we would like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bec42ace-4d81-424e-8dd6-ae877d28709f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We should note that the preceding definition did not specify any default values
    for `font_family` and `font_size`. So, those fields are mandatory when creating
    a `TextStyle` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39324ebd-d6dd-4d85-b96b-0a5afab117f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Using this macro can greatly simplify object construction and make the code
    more readable. There is no reason not to use it everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: As of Julia version 1.3, the `@kwdef` macro is not exported. There is a feature
    request to export it. Should you feel uncomfortable using non-exported features,
    consider using the `Parameters.jl` package instead.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss code generation pattern, which allows us to create new
    functions dynamically so as to avoid writing repeated boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: Code generation pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: New Julia programmers are often amazed by the conciseness of the language. Surprisingly,
    some of the very popular Julia packages are written with very little code. There
    are multiple reasons for that, but one major contributing factor is the ability
    to generate code dynamically in Julia.
  prefs: []
  type: TYPE_NORMAL
- en: In certain use cases, code generation can be extremely helpful. In this section,
    we will look into some code generation examples and try to explain how it can
    be done properly.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the file logger use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider a use case for building a file logging facility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we want to provide an API for logging messages to files based
    upon a set of logging levels. By default, we will support three levels: info,
    warning, and error. A logger facility is provided so that a message will be directed
    to a file, as long as it comes with a high enough logging level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The functional requirements can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An info-level logger accepts messages with info, warning, or error levels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning-level logger accepts messages with warning or error levels only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An error-level logger accepts messages with an error level only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement the file logger, we will first define some constants for the three
    logging levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'These constants are designed to be in numerical order, so we can easily determine
    when a message has a logging level as high as what the logger can accept. Next,
    we define the `Logger` facility as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Logger` object carries the filename of the log file, the minimum level for
    which messages can be accepted by the logger, and a file handle that is used for
    saving data. We can provide a constructor for `Logger` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor automatically opens the specified file for writing. Now, we
    can develop the first logging function for info-level messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This function is designed to write the message into the file only if the `INFO`
    level is high enough to be accepted by the logger. It also prints the current
    time using the `now()` function and an `[INFO]` label in the log file. Then, it
    writes all the arguments separated by spaces and finally flushes the I/O buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can quickly test the code so far. First, we will use `info_logger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d731f7c3-d00a-4de8-9c49-c8a7a8edf8c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The message is correctly logged in the `/tmp/info.log` file. What happens if
    we send an info-level message to an error-level logger? Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28148c4d-920f-4977-9b26-23877000bd3f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, this is a little more interesting. As expected, because the error-level
    logger only accepts a message with an `ERROR` level or higher, it did not pick
    up the info-level message.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we may be tempted to quickly finish the two other functions: `warning!`
    and `error!` and call it the day. If we were determined to do that, the `warning!` function
    would look just like `info!`, with just a few small changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99466ffe-e10b-46f3-8448-16b0520fe85d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What are the differences between these two logging functions? Let''s take a
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: The function names are different: `info!` versus `warning!`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logging level constants are different: `INFO` versus `WARNING`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The labels are different: `[INFO]` versus `[WARNING]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than these, both functions shared the exact same code. Of course, we can
    just keep going and wrap up the project by writing `error!` the same way. However,
    this is not the best solution. Imagine that if the core logging logic needs to
    be changed, for example, the formatting of log messages, then we have to make
    the same change in three different functions. Worse yet, if we forget to modify
    all of these functions, then we end up with inconsistent logging formats. After
    all, we have violated the **Don't Repeat Yourself** (**DRY**) principle.
  prefs: []
  type: TYPE_NORMAL
- en: Code generation for function definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code generation is one way to tackle this problem, as mentioned in the preceding
    section. What we will do is to build up the syntax of defining the function and
    then throw that into a loop to define all three logging functions. Here is how
    the code may look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: As we need to define functions for three logging levels, we have created a loop
    that goes through a list of symbols: `:info`, `:warning`, and `:error`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the loop, we can see the function name as `fn`, the label as `label`,
    and the constant for log level comparison (such as `INFO`, `WARN`, or `ERROR`) as `upper_level_sym`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `@eval` macro to define the logging function, where the `fn` variables, `label`,
    and `upper_level_sym` are interpolated into the function body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After running the code in the Julia REPL, all three functions: `info!`, `warning!`,
    and `error!` should be defined already. For testing, we can call these with three
    different kinds of loggers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try `info_logger` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62f6e51d-9509-4d00-9246-10768d779e96.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As expected, all messages are logged to the file because `info_logger` can
    take messages at any level. Next, let''s test `error_logger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94f9b0a0-7fb2-4aec-80bc-2abd03890dc1.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, only the error-level message was written to the log file. The
    `error_logger` code effectively filtered out any message that is lower than the
    error level.
  prefs: []
  type: TYPE_NORMAL
- en: Although we are quite satisfied with the resulting code, do we know what actually
    happened behind the scenes? How do we debug the code that we cannot even see?
    Let's take a look at this next.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging code generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that the code is generated behind the scene, it may feel a little awkward
    when we cannot even see what the generated code will look like. How can we guarantee
    that the generated code is exactly what we expect after all those interpolations
    of variables?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there is a package called `CodeTracking` that can make debugging
    code generation easier. We will see how it works here.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the previous section, we should have generated three functions: `info!`,
    `warning!`, and `error!`. As these are defined as generic functions, we can examine
    what methods are defined for each. Let''s take `error!` as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86de4703-1c0c-4442-8f10-3ee14a317872.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, we only have a single method. We can get to the method object
    itself using the `first` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44a8f083-716a-46bb-a0e6-97605cdb71df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have a reference of the method object, we can lean on `CodeTracking`
    to reveal the source code of the generated function. In particular, we can use
    the `definition` function, which takes a method object and returns an expression
    object. In order to use this function, we also need to load the `Revise` package.
    Enough said, let''s try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed446f67-790b-493c-8c8b-62994d639e3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can clearly see that the variables are interpolated correctly; the
    `logger.level` variable is compared with the `ERROR` constant, and the logging
    label correctly contains the `[ERROR]` string.
  prefs: []
  type: TYPE_NORMAL
- en: We can also see that line numbers are included in the output. Since we defined
    the functions from the REPL, the line numbers are less useful. If we would have
    generated the functions from a module that is stored in a file, the filename and
    line number information would be much more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line number nodes seem to be a bit too distracting here, though. We can
    easily remove them using the `rmlines` function from the `MacroTools` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27505180-7291-42e6-9a58-4ae8cffb4c76.png)'
  prefs: []
  type: TYPE_IMG
- en: The `MacroTools.postwalk` function is used to apply the `rmlines` function to
    every node in the abstract syntax tree. The `postwalk` function is necessary because
    the `rmlines` function only works with the current node.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to do code generation properly, let's turn around and
    ask ourselves—is code generation really necessary? Are there any other alternatives?
    Let us see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Considering options other than code generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this section, we have been focusing on code generation techniques.
    The premise is that we can easily add a new function that works just like an existing
    one but a little differently. In practice, code generation is not the only option
    we have on hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue our discussion with the same example. As we recall, we wanted
    to add the `warning!` and `error!` functions after defining the logic for `info!`.
    If we take a step back, we can generalize the `info!` function and make it handle
    different logging levels. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `logme!` function looks exactly like `info!` before, except that it takes
    two extra arguments: `level` and `label`. These variables are taken and used in
    the body of the function. Now we can define all three logging functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we have solved the original problem using a regular structured
    programming technique, and we have minimized as much repetitive code as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the only variation between these functions are simple types:
    a constant and a string. In another situation, we may need to call different functions
    within the body. That is okay as well because functions are first-class in Julia,
    and so we could just pass around a reference of the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we do better? Yes. The code can be simplified a little more using closure
    technique. To illustrate the concept, let''s define a new `make_log_func` function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes the `level` and `label` arguments and returns an anonymous
    function that contains the main logging logic. The `level` and `label` arguments
    are captured in a closure and used inside the anonymous function. So, we can now
    define the logging functions more easily as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So, three anonymous functions are defined here: `info!`, `warning!`, and `error!` and
    they all work equally well.
  prefs: []
  type: TYPE_NORMAL
- en: In computer science terms, closure is a first-class function that captures variables
    from an enclosing environment.
  prefs: []
  type: TYPE_NORMAL
- en: Technically speaking, there is a non-trivial difference between the structured
    programming solution and closure. The former technique defines generic functions
    that are named functions within the module that can be extended. In contrast,
    anonymous functions are unique and cannot be extended.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to do code generation in Julia and how
    to debug this code. We have also discussed how to restructure code to achieve
    the same effect without having to use code generation technique. Both options
    are available.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss DSLs, which is a technique for building syntax for specific
    domain usage, thereby making the code much easier to read and write.
  prefs: []
  type: TYPE_NORMAL
- en: Domain-specific language pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia is a general purpose programming language that can be used effectively
    for any domain problem. However, Julia is also one of the few programming languages
    that allows the developer to build new syntax to fit a specific domain usage.
  prefs: []
  type: TYPE_NORMAL
- en: So, a DSL is an example of **Structured Query Language** (**SQL**). SQL is designed
    to process data in a two-dimensional table structure. It is very powerful, and
    yet it is only appropriate when you need to handle data in tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few prominent areas in the Julia ecosystem where a DSL is used
    extensively. The one that stood out the most is the `DifferentialEquations` package,
    which allows you to write differential equations in a form that is very close
    to their original mathematical notation. For example, consider the Lorenz system
    equations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6b39340-b267-4954-8a9a-1bc151c0a186.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code to define these equations can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the syntax almost matches with the mathematical equations.
  prefs: []
  type: TYPE_NORMAL
- en: After this, in the next section, we will explore how to build our own DSL for
    a practical use case in computer graphics called L-System.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the L-System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **L-System**, also known as **Lindenmayer System**, is a formal syntax for
    describing how organisms evolve by way of simple patterns. It was first introduced
    in 1968 by Aristid Lindenmayer, a Hungarian biologist and botanist. An L-System
    can generate interesting patterns that mimic real-life shape and form. A well-known
    example is the growth of a specific algae, which can be modeled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how it works. We always start with the axiom, in this case, the character
    `A`. For each generation, we apply the rules to every character in the string.
    If the character is A, then it is replaced with `AB`. Similarly, if the character
    is `B`, it is replaced with A. Let''s work through the first five iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`A`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABAAB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABAABABA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may wonder, how does it even look like an algae? Here''s a visualization
    of the growth from the first generation to the fifth generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11197064-fc9c-468d-b7c4-68b402e77e67.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are many softwares that can produce interesting graphical visualizations
    based on L-Systems. An example is **My Graphics**, an iOS app developed by me.
    The application can produce several kinds of patterns such as the preceding algae
    example. An interesting sample called a **Koch** curve is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f43bf6e-dc2d-4e82-a33a-e3cabf81b3fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Enough said. From what we know so far, the concept is fairly simple. What we
    are going to do next is design a DSL for the L-System.
  prefs: []
  type: TYPE_NORMAL
- en: Designing DSL for L-System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The characteristics of a DSL are that the source code should look like the
    original representation of the domain concept. In this case, the domain concept
    is described by an axiom and a set of rules. Using the algae growth example, it
    needs to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to write them in plain Julia language, we may end up with code like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, this is not ideal. While the code is neither long nor difficult
    to read, it does not look as clean as the L-System grammar. What we really want
    is to build a DSL that lets us specify the model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will be the target syntax for our DSL.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the L-System core logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of this example, we will develop an L-System package together. Before
    we jump into the DSL implementation, let's take a quick detour and understand
    how the core logic works. Knowledge of the API allows us to design and test DSL
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the LModel object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To develop the `LModel` object, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create a type called `LModel` to keep track of the axiom and the
    set of rules. The struct can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can add a constructor that populates the `axiom` field and initializes
    the `rules` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'By design, the axiom is an array of a single element. The rules are captured
    in a dictionary for fast lookups. An `add_rule!` function is also written to append
    new rules to the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We have used the `split` function to convert a string into an array of single-character
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we add a `Base.show` function just so we can display a model nicely
    on Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Having defined these functions, we can quickly verify our code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93e1e95f-951f-4c90-b6e4-0e5b83c6c526.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will work on the core logic that takes a model and keeps track of the
    current state of the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the state object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To simulate the growth of an L-System model, we can develop an `LState` type
    that keeps track of the current state of the growth. It''s a simple type that
    just keeps a reference to the model, the current iteration of growth, and the
    current result. For this, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor just needs to take the model as the only argument. It defaults
    `current_iteration` to `1` and defaults `result` to the axiom of the model, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a function to advance to the next stage of the growth. So, we just
    provide a `next` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Basically, given the current state, it iterates all the elements of the current
    result and expands each element using the rules from the model. The `get` function
    looks up the element in the dictionary. If it is not found, it defaults to itself.
    The expanded elements are just appended to the `new_results` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, a new `LState` object is created with the next iteration number
    and the new result. For a better display in Terminal, we can add a `Base.show`
    method for `LState` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `result` function just combines all the elements of the array into a single
    string. The `show` function displays both the current iteration number and the
    result string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should have a fully functional system now. Let''s try to simulate the growth
    of the algae:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bb3bc5f-13e5-4d83-8a91-a198c3b367b7.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Wonderful!* Now that the functionalities are built, we can move on to the
    interesting part of this chapter—how to create a DSL with the L-System syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a DSL for L-System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall from the previous section that we want to have a clean syntax for defining
    an L-System model. From a metaprogramming perspective, we just need to translate
    the code from one abstract syntax tree to another. The following diagram shows
    graphically what kind of translation is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42dd569b-7dda-480b-a0d6-049a50183069.png)'
  prefs: []
  type: TYPE_IMG
- en: It turns out that the translation is quite straightforward. When we encounter
    an axiom, we translate the code to construct a new `LModel` object. When we encounter
    a rule, we translate the code to an `add_rule!` function call.
  prefs: []
  type: TYPE_NORMAL
- en: While it seems easy enough, this kind of source-to-source translation can be
    greatly simplified using pre-existing tools. In particular, the MacroTools package
    contains some very useful macros and functions for handling these cases. Let's
    first learn about the tool and then we can utilize them in developing our DSL.
  prefs: []
  type: TYPE_NORMAL
- en: Using the @capture macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MacroTools` package provides a macro called `@capture` that can be used
    to match an expression against a pattern. As part of the matching process, it
    also assigns variables for which the developer wishes to capture the matched values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@capture` macro accepts two arguments; the first one is an expression
    that needs to be matched, and the second one is a pattern used for matching. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31789f4e-7b08-43e4-8516-8584c39ecf21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The macro returns `true` when the pattern can be matched, or else it just returns
    `false`. When the pattern is matched, the variables ending with an underscore
    will be assigned in the current environment, with the underscore stripped away
    from the variable name. In the preceding example, because `x = 1` matches `x =
    val_`, it has returned `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a760722-e681-4140-b3f0-b16648065432.png)'
  prefs: []
  type: TYPE_IMG
- en: Because the pattern was matched successfully, a `val` variable was also assigned
    with the value of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Matching axiom and rule statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the same trick to extract useful information from the `axiom` and
    rule statements. Let''s do a quick experiment for the `axiom` statement, which
    consists of the word axiom, a colon, and a symbol. Matching it with the `@capture`
    macro is pretty slick as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/449c89e9-68ce-4a4f-b9e6-b57467fd0180.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Matching a `rule` statement is just as easy. The only difference is that we
    want to match the original symbol and the corresponding replacement symbol, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7eca749b-ff39-43a6-bef2-e7996dd58f15.png)'
  prefs: []
  type: TYPE_IMG
- en: Once matched, the `original` and `replacement` variables are assigned with the
    corresponding symbols from the rule. We can also observe that the matched variables
    are symbols rather than strings. As the `LModel` programming interface requires
    strings, we will have to perform an additional data conversion from the symbol
    in the `walk` function, which will be presented in the *Developing the macro for
    a DSL* section.
  prefs: []
  type: TYPE_NORMAL
- en: Using the postwalk function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to traverse the whole abstract syntax tree, we can use the MacroTool''s
    `postwalk` function. To understand how it works, we can play with a simple example,
    as outlined in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an expression object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/793295b5-6846-4039-9f14-0958db34e525.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have used the `rmlines` function to remove the line number nodes since
    we do not need them in this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can use the `postwalk` function to traverse the tree and display everything
    that it has ever encountered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c34e43a4-1669-45ba-a29e-817f56f21ab7.png)'
  prefs: []
  type: TYPE_IMG
- en: The `postwalk` function accepts a function as its first argument and an expression
    as the second argument. As it traverses the tree, it calls the function with the
    sub-expression being visited. We can see that it considered every single leaf
    node (for example, `:x`) as well as every sub-tree from the expression such as `:(x
    = 1)`. It also includes the top-level expression as we can see at the bottom of
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: If we pay a little more attention to the order of the traversal, we realize
    that the `postwalk` function works from the bottom up, starting from the leaf
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: MacroTools also provides a `prewalk` function that also traverses the tree.
    The difference between `prewalk` and `postwalk` is that `prewalk` would work from
    the top down rather than bottom up. You are encouraged to try that out and learn
    how they differ.
  prefs: []
  type: TYPE_NORMAL
- en: For our use case, we can use either one.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to match expressions and traverse the tree, we have everything
    in our toolbox to develop our DSL. That's the fun part. *Let's go!*
  prefs: []
  type: TYPE_NORMAL
- en: Developing the macro for a DSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To support the `LModel` syntax, we have to match both the axiom and rule statements
    to how they are written in the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started by creating the `lsys` macro, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The macro simply uses `postwalk` to traverse the abstract syntax tree. The
    resulting expression is returned as is. The main translation logic actually resides
    in the `walk` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Let's dissect the preceding code one portion at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `walk` function uses the `@capture` macro to match the `axiom` and `rule`
    patterns. When there is a match, the corresponding symbols are converted to a
    string and then interpolated into the corresponding expression, and the final
    expression is returned. Consider this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@capture` macro call tries to match the expression with the `axiom : sym_` pattern,
    which is an `axiom` symbol, followed by a colon, and then followed by another
    symbol. Since the `sym_` target symbol ends with an underscore, if the match is
    successful, the `sym` variable would be assigned with the matched value. In the
    `algae` model example of the *Developing the state object* section, we would expect
    `sym` to be assigned with the `:A` symbol. Once matched, the following code is
    executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The target expression simply constructs an `LModel` object and assigns it to
    the `model` variable. With the algae model, we can expect that the translated
    expression will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the `rule` statement can be matched using the pattern as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `original` and `replacement` variables are assigned, converted to a string,
    and interpolated into an `add_rule!` statement in the target expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `lsys` macro, the `walk` function is called by the `postwalk` function
    many times—once for each node and sub-tree of the abstract syntax tree. To see
    how `postwalk` generates the code, we can test it from the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cdd6c1f-f82e-4f83-9d86-35021d1b67f4.png)'
  prefs: []
  type: TYPE_IMG
- en: As it turns out, we are not completely done yet because the translated statements
    sit inside a `quote` block and the return value of the block would come from the
    block's last expression, which is zero as the `add_rule!` function does not return
    any meaningful value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This final change is actually the simple part. Let''s modify the `@lsys` macro
    again as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `push!` function was used to add the `:( model )` expression at the end
    of the block. Let''s test the macro expansion and see what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/952c0249-95a2-45cf-87f2-536ef8a95bb9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s good now! Finally, we can just use the macro as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce5c24ec-e98a-4dd1-9f28-8ba825403542.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Awesome! *The `algae_model` example can now be constructed using our little
    DSL. As it turns out, developing a DSL is not difficult at all. Given excellent
    tools such as MacroTools, we can quickly come up with a set of translation patterns
    and manipulate an abstract syntax tree into whatever we want.'
  prefs: []
  type: TYPE_NORMAL
- en: A DSL is a great way to simplify the code and make it easier to maintain. It
    can be very useful in specific domain areas.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at several patterns related to improving the
    readability and maintainability of an application.
  prefs: []
  type: TYPE_NORMAL
- en: First, we learned about when a module becomes too large and when it should be
    considered for reorganization. We realized that coupling is an important consideration
    when splitting code into separate modules. Next, we discussed the problem of constructing
    objects that have many fields. We determined that using a keyword-based constructor
    can make the code more readable and can provide additional flexibility of supporting
    default values. We learned that the Julia Base module already provides a macro.
  prefs: []
  type: TYPE_NORMAL
- en: Then we explored how to do code generation, which is a convenient technique
    for dynamically defining many similar functions without having to repeat the code.
    We picked up a utility from `CodeTracking` to review the generated source code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we went over details about how to develop DSLs. It is a good way to
    simplify code by mimicking the syntax with the original form of the domain concepts.
    We used an L-System as an example for developing a DSL. We picked up several utilities
    from the MacroTools package, where we can transform our source code by matching
    patterns. We learned how to use the `postwalk` function to examine and transform
    source code. And, pleasantly, we were able to complete the exercise with very
    little code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go over a set of patterns related to code safety.
    *Enjoy reading!*
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between afferent and efferent coupling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are bidirectional dependencies bad from a maintainability perspective?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an easy way to generate code on the fly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What would be an alternative to code generation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When and why should you consider building a DSL?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the tools available for developing a DSL?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
