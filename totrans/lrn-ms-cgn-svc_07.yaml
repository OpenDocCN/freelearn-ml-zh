- en: Chapter 7. Building Recommendation Systems for Businesses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"By leveraging Azure Machine Learning and the Recommendations API, we have
    launched a new Personalized Commerce Experience for retailers that grows shopper
    conversion and engagement on any channel."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Frank Kouretas, Chief Product Officer at Orckestra
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the previous chapter, we covered the remaining language APIs. In this chapter,
    we will look at the Recommendations Solution template. This is a template for
    Microsoft Azure that contains the resources required to run Recommendations Solution.
    This is a solution well suited for e-commerce applications, where you can recommend
    different items based on different criteria. Recommending items in an online store
    is a process that can be very time-consuming if it is done by following a rule
    set. The Recommendations Solution allows us to utilize the power of machine learning
    to get good recommendations, potentially increasing the number of sales.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Recommendations Solution template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Training the recommendation model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing personalized recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you run an e-commerce site, a feature that is nice for your customers to
    have is recommendations. Using the Recommendation Solution, you can easily add
    this. Utilizing Microsoft Azure Machine Learning, the API can be trained to recognize
    items that should be recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two common scenarios for recommendations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item-to-Item Recommendations (I2I)**: I2I is the scenario where certain items
    are often viewed after other items. Typically, this will be in the form of *people
    who visited this item also visited this other item*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customer-to-Item Recommendations (U2I)**: U2I is the scenario where you utilize
    a customer''s previous actions to recommend items. If you sell movies, for example,
    then you can recommend other movies based on a customer''s previous movie choices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The general steps to use the Recommendation Solution are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploy the template in Azure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the catalog data (the items in your e-commerce site)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import usage data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Train a recommendation model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consume recommendations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have not already done so, you should sign up for an API key at [https://portal.azure.com](https://portal.azure.com).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Recommendation Solution template in Azure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To deploy the Recommendations Solution, you must have an active Microsoft Azure
    subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head over to [https://github.com/Microsoft/Product-Recommendations/tree/master/deploy](https://github.com/Microsoft/Product-Recommendations/tree/master/deploy)
    to start the deployment. Click on **Deploy to Azure**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying the Recommendation Solution template in Azure](img/B12373_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will take you to the following page in Microsoft Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying the Recommendation Solution template in Azure](img/B12373_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enter the required information, accept the terms and conditions, and click on
    **Purchase**. This will start the process of deploying the required resources
    for the Recommendations Solution.
  prefs: []
  type: TYPE_NORMAL
- en: After a few minutes, the deployment is done. You are now ready to upload data
    to train a model.
  prefs: []
  type: TYPE_NORMAL
- en: Importing catalog data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the solution deployed, we can add catalog data. This is where you would
    typically add items from your database. Items need to be uploaded as files. The
    files need to be in CSV format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes the data that is required for each item in your
    catalog:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Item ID | A unique identifier for a given item |'
  prefs: []
  type: TYPE_TB
- en: '| Item name | The name of the item |'
  prefs: []
  type: TYPE_TB
- en: '| Item category | The category for the item, such as hardware, software, book
    genre, and so on |'
  prefs: []
  type: TYPE_TB
- en: 'In addition, there are a few data fields that are optional. These are described
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Description | A description of the item |'
  prefs: []
  type: TYPE_TB
- en: '| Feature list | A comma-separated feature list that can enhance recommendations
    |'
  prefs: []
  type: TYPE_TB
- en: 'A file that has all the data included may have items that look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is typically better to add features as this improves the recommendations.
    Any new item that has little usage is unlikely to be recommended if no features
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: Features should be categorical. This means that a feature can be a price range.
    A price alone would not serve as a good feature.
  prefs: []
  type: TYPE_NORMAL
- en: You can add up to 20 features per item. When a catalog containing features for
    items is uploaded, you need to perform a rank build. This will rank each feature,
    where features of a higher ranking will typically be better to use.
  prefs: []
  type: TYPE_NORMAL
- en: The code example for this chapter contains a sample catalog. We will use this
    for the following example. Alternatively, you can download some data from Microsoft
    from [http://aka.ms/RecoSampleData](http://aka.ms/RecoSampleData). We want to
    use the data from `MsStoreData.zip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the files downloaded, we can upload the catalog to our storage. This can
    be done by heading to your newly created storage account and creating a new blob
    container for the catalog, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing catalog data](img/B12373_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on **Upload**, browse to the sample files you downloaded, and choose the
    `catalog.csv` file. This will upload the catalog.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the catalog file is not required, but it is recommended that you upload
    it in order to supply it to the model.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum number of items in a catalog is 100,000\. Any given catalog file
    cannot be larger than 200 MB. If your file is larger, and you still have more
    items, you can upload several files.
  prefs: []
  type: TYPE_NORMAL
- en: Importing usage data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step we need to make is to upload usage data. This is a file describing
    all the transactions from your customers in the past. The file contains rows,
    with transactions, where each transaction is a comma-separated line containing
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The required data fields are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| User ID | A unique identifier for each customer |'
  prefs: []
  type: TYPE_TB
- en: '| Item ID | A unique identifier for items that correlate to the catalog |'
  prefs: []
  type: TYPE_TB
- en: '| Time | The time of the transaction |'
  prefs: []
  type: TYPE_TB
- en: In addition, it is possible to have a field called `Event`. This describes the
    type of transaction. The allowed values for this field are `Click`, `RecommendationClick`,
    `AddShopCart`, `RemoveShopCart`, and `Purchase`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the preceding example from the catalog, a line in the usage file may
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The maximum file size for a usage file is 200 MB.
  prefs: []
  type: TYPE_NORMAL
- en: The quality of recommendations relies on the amount of usage data. Typically,
    you should have about 20 transactions registered per item. This means that if
    you have 100 items in the catalog, you should aim for 2,000 transactions in the
    usage file.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the current maximum number of transactions that the API accepts is
    5 million. If new transactions are added above this maximum, the oldest data will
    be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Again, you can find an example usage file at [http://aka.ms/RecoSampleData](http://aka.ms/RecoSampleData).
    Create another blob container called `usage` and click on **Upload**. Upload all
    the usage files from the sample folder.
  prefs: []
  type: TYPE_NORMAL
- en: Training a model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the catalog and usage data in place, it is time to train a model.
  prefs: []
  type: TYPE_NORMAL
- en: Starting to train
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To start a training process, we need to make an API call to an endpoint on the
    newly created app service. This can be done using a tool, such as Postman, or
    through your own application. We will use Postman for the purposes of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To download Postman, please visit [https://www.getpostman.com/](https://www.getpostman.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The training process can be started by sending a POST request to the following
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The request must include a header, `x-api-key`, with your API key. It must also
    include another header, `Content-Type`, which should be set to `application/json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the request must contain a body containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Mandatory | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `description` | No | Textual description. |'
  prefs: []
  type: TYPE_TB
- en: '| `blobContainerName` | Yes | Name of the blob container where the catalog
    and usage data are stored. |'
  prefs: []
  type: TYPE_TB
- en: '| `usageRelativePath` | Yes | Relative path to either a virtual directory that
    contains the usage file(s) or a specific usage file to be used for training. |'
  prefs: []
  type: TYPE_TB
- en: '| `catalogFileRelativePath` | No | Relative path to the catalog file. |'
  prefs: []
  type: TYPE_TB
- en: '| `evaluationUsageRelativePath` | No | Relative path to either a virtual directory
    that contains the usage file(s) or to a specific usage file to be used for evaluation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `supportThreshold` | No | How conservative the model is, measured in the
    number of cooccurrences of items to be considered for modeling. |'
  prefs: []
  type: TYPE_TB
- en: '| `cooccurrenceUnit` | No | Indicates how to group usage events before counting
    cooccurrence. |'
  prefs: []
  type: TYPE_TB
- en: '| `similarityFunction` | No | Defines the similarity function to be used. Can
    be Jaccard, Cooccurrence, or Lift. |'
  prefs: []
  type: TYPE_TB
- en: '| `enableColdItemPlacement` | No | This will be either `true` or `false`. Indicates
    whether recommendations should push cold items via feature similarity. |'
  prefs: []
  type: TYPE_TB
- en: '| `enableColdToColdRecommendations` | No | This will be either `true` or `false`.
    Indicates whether or not the similarity between pairs of cold items should be
    calculated. |'
  prefs: []
  type: TYPE_TB
- en: '| `enableUserAffinity` | No | This will be either `true` or `false`. Defines
    whether the event type and time of event should be considered as inputs to the
    result. |'
  prefs: []
  type: TYPE_TB
- en: '| `enableBackfilling` | No | This will be either `true` or `false`. This will
    backfill with popular items if not enough relevant items are returned. |'
  prefs: []
  type: TYPE_TB
- en: '| `allowSeedItemsInRecommendations` | No | This will be either `true` or `false`.
    Determines whether input items can be returned as results. |'
  prefs: []
  type: TYPE_TB
- en: '| `decayPeriodInDays` | No | The decay period in days. The longer the time
    since an event has occurred, the less weight the event will have. |'
  prefs: []
  type: TYPE_TB
- en: '| `enableUserToItemRecommendations` | No | This will be either `true` or `false`.
    If `true`, the user ID will be taken into account when personalized recommendations
    are requested. |'
  prefs: []
  type: TYPE_TB
- en: 'A successful call may yield the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting to train](img/B12373_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `id` field returned can be used to check the training status.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the completion of training
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the ID returned in the previous request, we can now run a `GET` request
    to the following endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This request requires a header, `x-api-key`, containing your API key. A successful
    request may give the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Verifying the completion of training](img/B12373_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Response of GET request
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a `modelStatus` field is presented. Once this is `Completed`,
    the model is trained and ready to be used. You will also be presented with statistics,
    such as the duration of training, among other details.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you prefer to use a user interface for the model training, you can visit
    https://<your_service>.azurewebsites.net/ui.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use the recommendation models we just created, we will create a new example
    application. Create this using the MVVM template we created previously.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, there is no client package for the recommendations API.
    This means that we need to rely on web requests, as we saw in [Chapter 6](ch06.html
    "Chapter 6. Understanding Text"), *Understanding Text*. To speed up the development
    time, copy the `WebRequest.cs` file from the example code in [Chapter 6](ch06.html
    "Chapter 6. Understanding Text"), *Understanding Text*. Paste this file into the
    `Model` folder, and make sure that you update the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to add references to System.Web and System.Runtime.Serialization.
  prefs: []
  type: TYPE_NORMAL
- en: As there is no need for much UI, we are going to add everything in the `MainView.xaml`
    file. We are going to need two `ComboBox` elements. These will list our recommendation
    models and catalog items. We also need a `Button` element to get the recommendations
    and a `TextBox` element to show the resultant recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: The corresponding `ViewModel`, `MainViewModel.cs`, will need properties to correspond
    to the UI elements. Add an `ObservableCollection` of a `RecommendationModel` type
    to hold our models. We will look at the type in a bit. We need a property of a
    `RecommendationModel` type to hold the selected model. Add an `ObservableCollection`
    property of a `Product` type with a corresponding `Product` property for the available
    and selected properties. We will also need a `string` property for the results
    and an `ICommand` property for our button.
  prefs: []
  type: TYPE_NORMAL
- en: Add a `private` member of a `WebRequest` type so that we can call the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new file called `Product` in the `Model` folder. To use the items from
    our catalog, we will load the catalog file into the application, creating a `Product`
    for each item. Ensure that `Product` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We need the `Id` of an item, as well as the `Name` and the `Category`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor should create a `WebRequest` object, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When we create the `WebRequest` object, we specify the recommendation endpoint
    and our API key. The `RecommendCommand` phrase is the `ICommand` object, as a
    `DelegateCommand`. We need to specify the action to be executed and the conditions
    under which we are allowed to execute the command. We should be allowed to execute
    the command if we have selected a recommendation model and a product.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Initialize` phrase will make sure that we fetch our recommendation models
    and products, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetModels` method will make a call to the API, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This call is a `GET` request, so we specify this in `GetModels`. A successful
    call should result in a JSON response that we then deserialize into a `RecommendationModel`
    object. This is a data contract, so add a file called `Models.cs` in a folder
    called `Contracts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful result will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have an array of `models`. Each item in this array has an `id`, `name`, `description`,
    `createdDateTime`, `activeBuildId`, and `catalogDisplayName`. Make sure that the
    `RecommendationModels` class contains this data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the call succeeds, we add the models to the `ObservableCollection` of available
    models, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When all items are added, we set the `SelectedModel` to the first available
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the items from our catalog, we need to read from the catalog file. In
    the example code provided with the book, this file is added to the project and
    copied to the output directory. The `GetProducts` method will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a basic file operation, reading in each line from the catalog. For each
    item, we get the required information, creating a `Product` for each item. This
    is then added to the `AvailableProducts` in the `ObservableCollection` property,
    and the `SelectedProduct` is the first available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our recommendation models and our products, we can execute
    the recommendation request, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The call to get the recommendations is a `GET` request. This requires us to
    add `itemIds`.
  prefs: []
  type: TYPE_NORMAL
- en: The `itemIds` parameter must be the ID of a selected product.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the `RecommendItem` method on the `_webRequest` object. This is a `GET`
    request, and we need to specify the ID of the `SelectedModel` in the query string.
    We also need to add a bit to the query string so that we reach the correct endpoint.
    A successful response will result in JSON output, which will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The result consists of an array of objects. Each item will have a `recommendedItemId`
    and a `score`. The score gives an indication of how likely a customer is to want
    the given item.
  prefs: []
  type: TYPE_NORMAL
- en: This result should be deserialized into a list of data contracts of a `RecommandedItem`
    type, so make sure you add this in the `Contracts` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have made a successful call, we want to display this in the UI, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we check to see whether we have any recommendations. If we do not have
    any, we will not move on. If we do have any items, we create a `StringBuilder`
    to format our output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We loop through all the `recommendedItems`. We output the `score` and the `id`.
    This will be printed in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful test run may give the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Consuming recommendations](img/B12373_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a few special cases to note:'
  prefs: []
  type: TYPE_NORMAL
- en: If the item list contains a single item that does not exist in the catalog,
    then an empty result is returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the item list contains some items that are not in the catalog, then these
    are removed from the query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the item list contains only cold items (items that have no usage data connected
    to them), then the most popular recommendation is returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the item list contains some cold items, then recommendations are returned
    for the other items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommending items based on prior activities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make recommendations based on user activity, we need a list of users. As
    such a list would be too cumbersome to create just for an example, we will only
    look at the steps and parameters that are required to make this kind of recommendation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The endpoint for this usage is a bit different, as it is another `GET` call.
    In code, it would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters in the query string are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `userId` (required) | A unique identifier of a given user. |'
  prefs: []
  type: TYPE_TB
- en: '| `numberOfResults` (required) | The number of recommendations returned. |'
  prefs: []
  type: TYPE_TB
- en: '| `itemsIds` (optional) | A list or single ID of the selected item(s). |'
  prefs: []
  type: TYPE_TB
- en: '| `includeMetadata` (optional) | If true, then the item''s metadata will be
    included. |'
  prefs: []
  type: TYPE_TB
- en: '| `buildId` (optional) | A number identifying the build we want to use. If
    none is specified, then the active build is used. |'
  prefs: []
  type: TYPE_TB
- en: A successful call will result in the same JSON output as the other recommendation
    models. Recommended items will, of course, be based on users' past activities.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, to be able to use this, U2I must be set to `true` when creating a
    model build.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dived into the recommendations API. We learned how to set
    up recommendation models using existing catalog and usage data. Using these models,
    we learned how to utilize these in a simple example application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start with the knowledge APIs. We will learn how
    to structure natural language queries and evaluate query expressions. In addition,
    we will learn how to add autocompletion to natural language queries.
  prefs: []
  type: TYPE_NORMAL
