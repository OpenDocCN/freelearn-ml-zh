- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Preparing Raspberry Pi Pico
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bare **Raspberry Pi Pico** can run code, but we need some preparatory steps
    before we can use it. In this chapter, you will see how to get **CircuitPython**
    up and running and take your first steps in programming Pico. You’ll then learn
    **soldering** so that you can add headers to your Pico—letting you plug it into
    things.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, you’ll have Pico ready to run code, with headers
    ready to add other hardware, and have your laptop or computer ready to send code
    to Pico. Plus, you’ll have some soldering experience if that is new to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting CircuitPython onto Raspberry Pi Pico
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the CircuitPython library for Pico
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding on Pico—first steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soldering headers to Raspberry Pi Pico
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get going on this section, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 Raspberry Pi Pico
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *USB Micro cable* (either *A to Micro* or *C to Micro* depending on your computer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A computer/laptop running Windows/Linux or macOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Mu** editor—we’ll show you how to get this
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A soldering iron and heatproof stand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A well-lit, well-ventilated space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Goggles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solder-wick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some male breakaway pin headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code examples for this example can be found on GitHub at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-02](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-02).
  prefs: []
  type: TYPE_NORMAL
- en: Getting CircuitPython onto Raspberry Pi Pico
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For us to get going and write code on Raspberry Pi Pico, we need to put the
    CircuitPython interpreter on it or “*flash it*” with CircuitPython.
  prefs: []
  type: TYPE_NORMAL
- en: First, you can find CircuitPython downloads at [https://circuitpython.org/downloads](https://circuitpython.org/downloads).
    This page shows just how many different boards support CircuitPython—although
    they won’t support some of the unique hardware capabilities of Pico (such as PIO),
    it means that many of the skills learned in this book along with the code you
    write can be directly translated to a huge number of other boards!
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Pico (By Raspberry Pi)**, and on the right is the current **stable**
    download of CircuitPython. There are many languages selectable here, and you can
    select *CircuitPython with error* messages in your language. Hit the **Download
    .uf2 now** button. Take note of the version number you downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plug one end of the USB cable into your laptop. Looking at Pico, there’s a
    tiny button on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Raspberry Pi Pico BOOTSEL button ](img/Fig_2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Raspberry Pi Pico BOOTSEL button
  prefs: []
  type: TYPE_NORMAL
- en: This button, shown in *Figure 2**.1*, is labeled **BOOTSEL**. Hold this down
    as you plug the USB cable into the computer. This puts Pico into a mode for flashing
    firmware onto it.
  prefs: []
  type: TYPE_NORMAL
- en: You should see a new `RPI-RP2` drive appear on your computer. This is Raspberry
    Pi Pico. Copy the Adafruit CircuitPython `uf2` file from your downloads to that
    folder. A simple drag and drop file copy will work here.
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi Pico will reboot, and the drive will disappear momentarily. It
    will then come back as `CIRCUITPY`.
  prefs: []
  type: TYPE_NORMAL
- en: You have downloaded and flashed CircuitPython on Pico. This Raspberry Pi Pico
    is running CircuitPython and is ready to program. Next, we’ll download the libraries
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the CircuitPython library for Pico
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CircuitPython is a good starting point—it gives you the basics that we will
    be using—but we will also be interfacing with other hardware. The **CircuitPython
    library**, united across many devices with the same version of Pico, creates an
    interface you can take with you to other microcontrollers should you want to try
    others out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the following steps to prepare a module from the library:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `CIRCUITPY` drive on your computer and find a folder called `lib`.
    This is the target for libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the CircuitPython Library Bundle from [https://circuitpython.org/libraries](https://circuitpython.org/libraries).
    The version you download should match the version of CircuitPython you downloaded
    before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This gets you a ZIP file. Expand the ZIP contents, and you should get a folder
    with a `README`, examples, and a `lib` folder. We will keep this handy. When we
    need libraries from here, we copy them over to Pico.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The whole library is too large to fit at once on a single Pico, but since you
    couldn’t use all those hardware peripherals at once, you would only copy what
    is needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `lib` folder in the `Adafruit Library` folder, and you should see `adafruit_vl53l0x.mpy`.
    Copy (drag and drop) this file into the `CIRCUITPY/lib` folder. This is all it
    takes to install libraries for this device—some devices require a group of files
    to be copied over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ve now got a copy of the CircuitPython library handy and seen how to install
    a module from it on Pico. We will be using this library later. We have CircuitPython
    and a library. Next, it’s time to try some code on Pico.
  prefs: []
  type: TYPE_NORMAL
- en: Coding on Pico – first steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing and testing code on Pico is made easier with a handy tool, **Mu**. We
    will get you up and running and get stuff going in Pico **REPL**. We’ll then write
    some code in a file and upload that program so that it runs when Raspberry Pi
    Pico boots. How do we get Mu? Let’s find out in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the Mu editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Mu editor gives easy access to the CircuitPython REPL. It also has a Python
    editor, allowing you to see the code and results together. It’s small and supports
    other hardware-oriented Python platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download it, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://codewith.mu/](https://codewith.mu/). Use the **Download** button
    to get the right version for your computer and install it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Launch Mu editor, and when it is running, click on the **Mode** button. From
    this, select **CircuitPython**. Look at the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Mu editor buttons ](img/Fig_2.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Mu editor buttons
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the toolbar in the middle, with the result of
    clicking the **Mode** button above it, and the result of clicking the **Serial**
    button below it.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need **Serial** enabled to see and interact with Python on Pico, so click
    the **Serial** button as indicated. **Serial** lets you send and receive text
    from Raspberry Pi Pico via the USB cable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To start interacting with Pico directly, click in the **Serial** window, shown
    below the **Serial** button in *Figure 2**.2*. When you type or press keys here,
    they are sent directly to Pico. Pico is waiting for you to interact with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On your keyboard, press any key to start the REPL. You will see a Adafruit CircuitPython
    message, as shown at the bottom of *Figure 2**.2*. We can start typing code here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have loaded the Mu editor and connected it to CircuitPython on Raspberry
    Pi Pico. By loading the **Serial** monitor and pressing any key here, you’ve entered
    the REPL where you can type code and see it evaluated immediately. Next, we explore
    some things we can do in this REPL.
  prefs: []
  type: TYPE_NORMAL
- en: Lighting the Pico LED with CircuitPython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The console here is running CircuitPython, and it is on Raspberry Pi Pico.
    You can type code here. The simplest thing we can do is a `"Hello, world!"`. Type
    the bold text, and it should respond as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Well done—this is the first bit of working CircuitPython code. However, this
    is about hardware, so we will light an LED instead. Type the following code into
    the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To talk to hardware, we start by importing some libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The `board` library stores board interface details—naming and mapping pins on
    the device to names. What is cool about this library is that if you pick up a
    different board and put CircuitPython on it, then to some degree, named pins such
    as `board.LED` will work on that too.
  prefs: []
  type: TYPE_NORMAL
- en: The `digitalio` library has the basics for reading and writing to IO pins, defining
    them as a **digital pin** (versus other ways you can use a Pico pin), and then
    setting their direction.
  prefs: []
  type: TYPE_NORMAL
- en: We then initialize a digital pin using `board.LED`. This uses the built-in LED.
    That LED is on *GPIO pin 25*. You could also have used `board.GP25` for the same
    result. We set this pin’s direction to `OUTPUT`; otherwise, you are not allowed
    to set its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in this code, we set `led.value` to `True`, which turns the LED on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The LED lit on Raspberry Pi Pico ](img/Fig_2.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – The LED lit on Raspberry Pi Pico
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the LED light at this point. We should turn it off when we are
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You’ve got an LED to light—some hardware interaction. You can flip that value
    from `False` to `True` and back again to turn the LED on and off.
  prefs: []
  type: TYPE_NORMAL
- en: You could set any pin to `True` or `False` this way to control simple hardware,
    and you’ve used the REPL to try stuff out. However, we don’t really want to do
    it manually— so, can we make it more automatic?
  prefs: []
  type: TYPE_NORMAL
- en: Blinking the LED with code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first automatic behavior would be to make the LED blink. In hardware circles,
    this is code is known as *blinky* and is equivalent to `"Hello, World"` for microcontrollers.
    This time, instead of typing this code in the REPL, we are going to write it in
    the editor and upload it to Pico. That way, we can tweak it and send the code
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by clicking in the code area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Click here to start coding ](img/Fig_2.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Click here to start coding
  prefs: []
  type: TYPE_NORMAL
- en: 'As the box says, we can write out code there. To blink an LED, the basic idea
    is to turn it on, wait a bit, turn it off, wait a bit, and repeat. Let us see
    that in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code starts with the import of `time`, which lets us control time! Well,
    OK—it lets us wait for a bit with `sleep`.
  prefs: []
  type: TYPE_NORMAL
- en: We import `board` and `digitalio` and set up the pin and its direction as before.
  prefs: []
  type: TYPE_NORMAL
- en: To make the LED keep on blinking, we put it in a `while True` loop, which will
    repeat the code indented under it until we (hard or soft) reset Pico.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `while` loop, first we turn the LED on, then we sleep for half a
    second. The time here is written as a decimal number—it is always in seconds,
    and we want less than a second.
  prefs: []
  type: TYPE_NORMAL
- en: We turn the LED off again, sleep again, and the code will loop around.
  prefs: []
  type: TYPE_NORMAL
- en: Save this code to Raspberry Pi Pico (the USB drive named `CIRCUITPY`) as `code.py`.
    It will automatically run the file named `code.py`—the LED should now start blinking.
  prefs: []
  type: TYPE_NORMAL
- en: While this seems simple, changing digital IO pins and sleeping is the basics
    of controlling motors too. In this section, you’ve written code to automatically
    blink a light, and seen how to use time and how to upload a file to Raspberry
    Pi Pico instead of typing everything at the REPL. Next, we’ll need to prepare
    Raspberry Pi Pico for plugging in other hardware by soldering on headers.
  prefs: []
  type: TYPE_NORMAL
- en: Soldering headers to Raspberry Pi Pico
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Raspberry Pi Pico can run some neat code, it can blink that LED, and you could
    get it to input things, and print on that serial console. But it’s going to be
    lots more fun if we start plugging stuff into it! To do that, it will need **headers**
    soldered into it. **Soldering** may seem daunting the first time around, but with
    practice, it will be a skill you’ll use repeatedly in robot building.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to be soldering header pins into Raspberry Pi Pico. These are
    breakaway pin headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Breakaway pin headers ](img/Fig_2.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Breakaway pin headers
  prefs: []
  type: TYPE_NORMAL
- en: Pin headers will let us plug Pico into a breadboard so that we can connect it
    to other electronics or use Pico with female cables to link to sensors. There
    are other kinds—female kinds, not so useful for the breadboard—and you can get
    2-row pin headers, which you’ll see in other Raspberry Pi models.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the right number of pins, we need to measure and snap them off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Snapping off the headers ](img/Fig_2.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Snapping off the headers
  prefs: []
  type: TYPE_NORMAL
- en: Breakaway headers such as these come in strips designed to break away. One straightforward
    way to get the right length, instead of counting each one out, is to place the
    short end of the header loose into Pico, as shown in *Figure 2**.6*, and then
    break at the join just past there. You can either cut with a knife or just pull
    them off at an angle. They come apart easily. We’ll want two sets like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raspberry Pi Pico comes with two rows of headers, and we can use this to our
    advantage. Push the Pico and header assembly into a breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Raspberry Pi Pico propped onto the headers ](img/Fig_2.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Raspberry Pi Pico propped onto the headers
  prefs: []
  type: TYPE_NORMAL
- en: When you solder, you do not want the headers to wobble in their sockets—you
    want them to stay still. The breadboard and headers as pictured in *Figure 2**.7*
    will hold Pico up and stop it from moving.
  prefs: []
  type: TYPE_NORMAL
- en: For this work, I recommend a chisel tip for the soldering iron. Chisel tips
    have a good surface area to heat joints with and are common.
  prefs: []
  type: TYPE_NORMAL
- en: You should have an iron, a stand, a tip cleaner (I prefer brass wire), and some
    solder. I recommend safety goggles too. You should also be working in a clear,
    well-lit, and well-ventilated space—use a solder fume extractor if you can; you
    should not inhale these fumes.
  prefs: []
  type: TYPE_NORMAL
- en: It’s now time to heat up a soldering iron. Allow the iron to heat up—this may
    take a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When the soldering iron is hot, only hold it by the plastic grips. You must
    never touch the metal parts or the tip as these can cause serious burns. Always
    place the iron back into its stand when you put it down.
  prefs: []
  type: TYPE_NORMAL
- en: You can test if an iron is hot by touching some solder to it—when hot enough,
    it should melt and *wet* the iron tip. This is known as **tinning** and ensures
    good heat transfer between the iron and the items to be soldered. If there is
    a bit of a blob of solder, use the brass-wire tip cleaner to wipe it off. What
    you should be left with is a thin layer of solder around the iron tip. A tinned
    and clean tip will make far better solder joints than a dry or dirty tip!
  prefs: []
  type: TYPE_NORMAL
- en: 'See the next diagram for how to make a solder *joint*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Making a solder joint ](img/Fig_2.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Making a solder joint
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram in *Figure 2**.8* shows the steps for making a good solder joint.
    Follow the points along with the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: Shown here is a pin going through a board and the solder pad (the metal bit
    on the board). Use the soldering iron tip to heat both the pad and the board.
    We want them both hot enough to accept solder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the pad and pin are hot, push the solder into the pad and pin, not into
    the soldering iron. It is important for nice joints that you heat the pad and
    pin, then bring the solder to it—this means the solder will melt against the pad
    and pin, not the iron, which will lead to a good bond, electrically and mechanically.
    You do not need to use any pressure from the iron, and at the right temperature,
    the solder will flow—it does not need any pressure either.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The solder starts to flow and should flow onto the pad and around the pin. You
    do not want a lot of solder here! Use enough to make the cone shape shown here.
    Remove the solder as soon as enough has flown. Pull the iron away from the joint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A good shape should be a shiny cone like this, contacting both the pad and pin.
    If you get a ball here, heat the solder, pad, and pin again—molten solder will
    only stick to hot stuff. If there is a big blob, you can use solder wick to remove
    excess.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can take a closer look at how this appears in the real world on Raspberry
    Pi Pico:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Solder joints on Raspberry Pi Pico ](img/Fig_2.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Solder joints on Raspberry Pi Pico
  prefs: []
  type: TYPE_NORMAL
- en: 'The order in which you make the joint is important. The panels in *Figure 2**.9*
    show where to start soldering:'
  prefs: []
  type: TYPE_NORMAL
- en: Start in one corner. In this photograph, I am heating up the pad and pin first.
    Ensure the pin headers and Raspberry Pi Pico do not move relative to each other
    when the solder cools. It will cool very quickly, but any movement here will make
    for a poor-quality joint. The breadboard holding strategy here should be enough
    to prevent most movement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, move across to the opposite corner. These two joints secure Pico to the
    breadboard, making the board less likely to move in the rig. In the photograph,
    I am adding solder to the joint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have done two opposite corners, solder the remaining corners, and then
    you can start filling in the rest of the pins. Good shiny joints should look like
    these. There are 40 in total, but you get into a rhythm once you’ve done the first
    few.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Between pins, it’s a good idea to occasionally clean the tip. Use the brass
    tip cleaner (stab the iron into it) to clear excess solder from the soldering
    iron tip.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While soldering, it is possible that you will accidentally bridge two pins—that
    is, connect between them. This must be remedied, or you could damage your Pico
    when you plug it in. See the following diagram on how to clear this up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Clearing a solder bridge ](img/Fig_2.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Clearing a solder bridge
  prefs: []
  type: TYPE_NORMAL
- en: 'To clear a **solder bridge**, first, clean the soldering iron tip, then follow
    the steps in *Figure 2**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the solder bridge. The solder has created an accidental connection between
    two pins that should not be connected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the iron between the pins, and when the solder melts, draw the iron through
    between them. The solder should flow around the two pins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The pins should look a little like this when the bridge has been cleared.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you have made the joints, inspect them to ensure that they are all conical
    tents, none is a bridge, and none has been missed. If so, you have completed this
    soldering job. Do not forget to turn off the soldering iron!
  prefs: []
  type: TYPE_NORMAL
- en: With the pin headers soldered in, this Raspberry Pi Pico is ready to connect
    to a robot.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve been on a close tour of Raspberry Pi Pico. We’ve put
    CircuitPython on the board and prepared some libraries to copy when we need them.
    We’ve downloaded an editor that can talk to Raspberry Pi Pico on its serial REPL,
    and have then written code to upload to Pico. In doing so, we’ve got the hardware
    to do some basic digital output.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also soldered headers onto Pico so that we can start building robots around
    it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll design the robot to build around it, using CAD and
    taking our test fit into a more serious gear so that we can start cutting material.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these exercises to get to know Pico more:'
  prefs: []
  type: TYPE_NORMAL
- en: Adjust the timings in the blink code. You should be able to get the light to
    blink quicker or slower by changing the number of seconds in the `sleep` statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Could you make the light blink in an irregular pattern? You could use a series
    of timings. Digging a bit at CircuitPython, you could use a list of values and
    loop through them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore using the REPL for other Python code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to need header pins on the motor board as well. Using the same
    techniques as covered in the section Soldering headers to Raspberry Pi Pico, solder
    pins into the motor driver board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following resources for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, it is worth having the datasheet for Raspberry Pi Pico to hand,
    available at [https://datasheets.raspberrypi.org/pico/pico-datasheet.pdf](https://datasheets.raspberrypi.org/pico/pico-datasheet.pdf).
    It has a helpful pin reference on *page 5*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CircuitPython also has a reference guide at [https://docs.circuitpython.org/en/7.3.x/docs/index.html](https://docs.circuitpython.org/en/7.3.x/docs/index.html).
    The *Core Modules* section will be helpful for further experimenting with this
    environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
