- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Preparing Raspberry Pi Pico
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备Raspberry Pi Pico
- en: The bare **Raspberry Pi Pico** can run code, but we need some preparatory steps
    before we can use it. In this chapter, you will see how to get **CircuitPython**
    up and running and take your first steps in programming Pico. You’ll then learn
    **soldering** so that you can add headers to your Pico—letting you plug it into
    things.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹的**Raspberry Pi Pico**可以运行代码，但在我们能够使用它之前，我们需要做一些准备工作。在本章中，您将了解如何启动**CircuitPython**并开始编程Pico的第一步。然后，您将学习**焊接**，这样您就可以将引脚添加到Pico上——让您可以将其插入其他设备。
- en: At the end of the chapter, you’ll have Pico ready to run code, with headers
    ready to add other hardware, and have your laptop or computer ready to send code
    to Pico. Plus, you’ll have some soldering experience if that is new to you.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将拥有一个准备运行代码的Pico，带有准备添加其他硬件的引脚，并且您的笔记本电脑或计算机已准备好向Pico发送代码。此外，如果您是新手，您还将获得一些焊接经验。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Getting CircuitPython onto Raspberry Pi Pico
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将CircuitPython安装到Raspberry Pi Pico上
- en: Preparing the CircuitPython library for Pico
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Pico准备CircuitPython库
- en: Coding on Pico—first steps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Pico上编码——第一步
- en: Soldering headers to Raspberry Pi Pico
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将焊锡引脚焊接在Raspberry Pi Pico上
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To get going on this section, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本节，您需要以下内容：
- en: 1 Raspberry Pi Pico
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Raspberry Pi Pico
- en: A *USB Micro cable* (either *A to Micro* or *C to Micro* depending on your computer)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根*USB Micro线*（根据您的计算机，可以是*A到Micro*或*C到Micro*）
- en: A computer/laptop running Windows/Linux or macOS
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Windows/Linux或macOS的计算机/笔记本电脑
- en: The **Mu** editor—we’ll show you how to get this
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mu**编辑器——我们将向您展示如何获取它'
- en: A soldering iron and heatproof stand
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一把焊锡枪和耐热支架
- en: A well-lit, well-ventilated space
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个明亮、通风良好的空间
- en: Goggles
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 护目镜
- en: Solder
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焊锡
- en: Solder-wick
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焊锡吸球
- en: A breadboard
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个面包板
- en: Some male breakaway pin headers
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些公头断开式引脚
- en: All the code examples for this example can be found on GitHub at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-02](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-02).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的所有代码示例都可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-02](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-02)。
- en: Getting CircuitPython onto Raspberry Pi Pico
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将CircuitPython安装到Raspberry Pi Pico上
- en: For us to get going and write code on Raspberry Pi Pico, we need to put the
    CircuitPython interpreter on it or “*flash it*” with CircuitPython.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们开始编写Raspberry Pi Pico的代码，我们需要在它上面安装CircuitPython解释器，或者“*闪存*”CircuitPython。
- en: First, you can find CircuitPython downloads at [https://circuitpython.org/downloads](https://circuitpython.org/downloads).
    This page shows just how many different boards support CircuitPython—although
    they won’t support some of the unique hardware capabilities of Pico (such as PIO),
    it means that many of the skills learned in this book along with the code you
    write can be directly translated to a huge number of other boards!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以在[https://circuitpython.org/downloads](https://circuitpython.org/downloads)找到CircuitPython的下载。这个页面展示了支持CircuitPython的不同电路板数量——尽管它们可能不支持Pico的一些独特硬件功能（例如PIO），但这意味着您在这本书中学到的许多技能以及您编写的代码可以直接应用于大量其他电路板！
- en: Click on **Pico (By Raspberry Pi)**, and on the right is the current **stable**
    download of CircuitPython. There are many languages selectable here, and you can
    select *CircuitPython with error* messages in your language. Hit the **Download
    .uf2 now** button. Take note of the version number you downloaded.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**Pico (By Raspberry Pi**)，在右侧是当前**稳定版**的CircuitPython下载。这里可以选择多种语言，您可以选择带有您语言错误信息的*CircuitPython*。点击**现在下载.uf2**按钮。注意您下载的版本号。
- en: 'Plug one end of the USB cable into your laptop. Looking at Pico, there’s a
    tiny button on it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将USB线的一端插入您的笔记本电脑。观察Pico，它上面有一个微小的按钮：
- en: '![Figure 2.1 – Raspberry Pi Pico BOOTSEL button ](img/Fig_2.1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – Raspberry Pi Pico BOOTSEL按钮](img/Fig_2.1.jpg)'
- en: Figure 2.1 – Raspberry Pi Pico BOOTSEL button
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – Raspberry Pi Pico BOOTSEL按钮
- en: This button, shown in *Figure 2**.1*, is labeled **BOOTSEL**. Hold this down
    as you plug the USB cable into the computer. This puts Pico into a mode for flashing
    firmware onto it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图2.1*所示的这个按钮，标记为**BOOTSEL**。当您将USB线插入计算机时，请按住此按钮。这会将Pico置于向其闪存固件的模式。
- en: You should see a new `RPI-RP2` drive appear on your computer. This is Raspberry
    Pi Pico. Copy the Adafruit CircuitPython `uf2` file from your downloads to that
    folder. A simple drag and drop file copy will work here.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在电脑上看到一个名为 `RPI-RP2` 的新驱动器出现。这是 Raspberry Pi Pico。将你的下载中的 Adafruit CircuitPython
    `uf2` 文件复制到该文件夹。简单的拖放文件复制在这里就可以工作。
- en: Raspberry Pi Pico will reboot, and the drive will disappear momentarily. It
    will then come back as `CIRCUITPY`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Pico 将重新启动，驱动器将暂时消失。然后它将以 `CIRCUITPY` 的形式回来。
- en: You have downloaded and flashed CircuitPython on Pico. This Raspberry Pi Pico
    is running CircuitPython and is ready to program. Next, we’ll download the libraries
    for it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经下载并烧录了 Pico 上的 CircuitPython。这个 Raspberry Pi Pico 正在运行 CircuitPython，并准备好编程。接下来，我们将下载它的库。
- en: Preparing the CircuitPython library for Pico
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备 Pico 的 CircuitPython 库
- en: CircuitPython is a good starting point—it gives you the basics that we will
    be using—but we will also be interfacing with other hardware. The **CircuitPython
    library**, united across many devices with the same version of Pico, creates an
    interface you can take with you to other microcontrollers should you want to try
    others out.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: CircuitPython 是一个良好的起点——它为你提供了我们将要使用的基础知识——但我们还将与其他硬件进行接口。**CircuitPython 库**，在具有相同版本
    Pico 的许多设备上统一，创建了一个你可以携带到其他微控制器的接口，如果你想要尝试其他设备的话。
- en: 'Let’s use the following steps to prepare a module from the library:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下步骤从库中准备一个模块：
- en: Open the `CIRCUITPY` drive on your computer and find a folder called `lib`.
    This is the target for libraries.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的电脑上打开 `CIRCUITPY` 驱动器，并找到一个名为 `lib` 的文件夹。这是库的目标文件夹。
- en: Download the CircuitPython Library Bundle from [https://circuitpython.org/libraries](https://circuitpython.org/libraries).
    The version you download should match the version of CircuitPython you downloaded
    before.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://circuitpython.org/libraries](https://circuitpython.org/libraries)
    下载 CircuitPython 库捆绑包。你下载的版本应该与你之前下载的 CircuitPython 版本相匹配。
- en: This gets you a ZIP file. Expand the ZIP contents, and you should get a folder
    with a `README`, examples, and a `lib` folder. We will keep this handy. When we
    need libraries from here, we copy them over to Pico.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会为你提供一个 ZIP 文件。展开 ZIP 文件的内容，你应该会得到一个包含 `README`、示例和一个 `lib` 文件的文件夹。我们将保留这个文件夹。当我们需要从这里获取库时，我们会将它们复制到
    Pico 上。
- en: The whole library is too large to fit at once on a single Pico, but since you
    couldn’t use all those hardware peripherals at once, you would only copy what
    is needed.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个库太大，无法一次性全部放入单个 Pico 中，但既然你无法同时使用所有那些硬件外围设备，你只会复制所需的文件。
- en: Open the `lib` folder in the `Adafruit Library` folder, and you should see `adafruit_vl53l0x.mpy`.
    Copy (drag and drop) this file into the `CIRCUITPY/lib` folder. This is all it
    takes to install libraries for this device—some devices require a group of files
    to be copied over.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Adafruit Library` 文件夹中打开 `lib` 文件夹，你应该会看到 `adafruit_vl53l0x.mpy` 文件。将（拖放）此文件复制到
    `CIRCUITPY/lib` 文件夹。这就是为该设备安装库的全部操作——一些设备需要复制一组文件。
- en: You’ve now got a copy of the CircuitPython library handy and seen how to install
    a module from it on Pico. We will be using this library later. We have CircuitPython
    and a library. Next, it’s time to try some code on Pico.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经有了一个 CircuitPython 库的副本，并看到了如何在 Pico 上安装库中的模块。我们将稍后使用这个库。我们有了 CircuitPython
    和一个库。现在是时候在 Pico 上尝试一些代码了。
- en: Coding on Pico – first steps
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Pico 上编码——第一步
- en: Writing and testing code on Pico is made easier with a handy tool, **Mu**. We
    will get you up and running and get stuff going in Pico **REPL**. We’ll then write
    some code in a file and upload that program so that it runs when Raspberry Pi
    Pico boots. How do we get Mu? Let’s find out in the next section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方便的工具 **Mu**，在 Pico 上编写和测试代码变得更容易。我们将帮助你启动并运行 Pico **REPL**。然后我们将编写一些代码到文件中，并上传该程序，以便在
    Raspberry Pi Pico 启动时运行。我们如何获取 Mu？让我们在下一节中找出答案。
- en: Downloading the Mu editor
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载 Mu 编辑器
- en: The Mu editor gives easy access to the CircuitPython REPL. It also has a Python
    editor, allowing you to see the code and results together. It’s small and supports
    other hardware-oriented Python platforms.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Mu 编辑器提供了对 CircuitPython REPL 的便捷访问。它还有一个 Python 编辑器，允许你一起查看代码和结果。它体积小，支持其他硬件导向的
    Python 平台。
- en: 'To download it, do the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下载它，请按照以下步骤操作：
- en: Go to [https://codewith.mu/](https://codewith.mu/). Use the **Download** button
    to get the right version for your computer and install it.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://codewith.mu/](https://codewith.mu/)。使用 **下载** 按钮获取适合你电脑的正确版本并安装它。
- en: 'Launch Mu editor, and when it is running, click on the **Mode** button. From
    this, select **CircuitPython**. Look at the following screenshot:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Mu 编辑器，当它运行时，点击 **模式** 按钮。从那里，选择 **CircuitPython**。查看以下截图：
- en: '![Figure 2.2 – Mu editor buttons ](img/Fig_2.2.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – Mu 编辑器按钮](img/Fig_2.2.jpg)'
- en: Figure 2.2 – Mu editor buttons
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – Mu 编辑器按钮
- en: The preceding screenshot shows the toolbar in the middle, with the result of
    clicking the **Mode** button above it, and the result of clicking the **Serial**
    button below it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了中间的工具栏，点击其上方的 **模式** 按钮的结果，以及点击其下方的 **串行** 按钮的结果。
- en: You’ll need **Serial** enabled to see and interact with Python on Pico, so click
    the **Serial** button as indicated. **Serial** lets you send and receive text
    from Raspberry Pi Pico via the USB cable.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要启用 **串行** 来查看和与 Pico 上的 Python 交互，所以点击如图 2**.2*** 所示的 **串行** 按钮。**串行** 允许你通过
    USB 线缆从 Raspberry Pi Pico 发送和接收文本。
- en: To start interacting with Pico directly, click in the **Serial** window, shown
    below the **Serial** button in *Figure 2**.2*. When you type or press keys here,
    they are sent directly to Pico. Pico is waiting for you to interact with it.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要直接与 Pico 交互，点击如图 2**.2*** 所示的 **串行** 按钮下方的 **串行** 窗口。当你在这里输入或按键时，它们会直接发送到 Pico。Pico
    正在等待你与之交互。
- en: On your keyboard, press any key to start the REPL. You will see a Adafruit CircuitPython
    message, as shown at the bottom of *Figure 2**.2*. We can start typing code here.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的键盘上，按任意键以启动 REPL。你将看到 Adafruit CircuitPython 消息，如图 2**.2*** 下方所示。我们可以在这里开始输入代码。
- en: You have loaded the Mu editor and connected it to CircuitPython on Raspberry
    Pi Pico. By loading the **Serial** monitor and pressing any key here, you’ve entered
    the REPL where you can type code and see it evaluated immediately. Next, we explore
    some things we can do in this REPL.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经加载了 Mu 编辑器并将其连接到 Raspberry Pi Pico 上的 CircuitPython。通过加载 **串行** 监视器并在此处按任意键，你已经进入了可以输入代码并立即看到其评估结果的
    REPL。接下来，我们将探索在这个 REPL 中我们可以做些什么。
- en: Lighting the Pico LED with CircuitPython
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CircuitPython 点亮 Pico LED
- en: 'The console here is running CircuitPython, and it is on Raspberry Pi Pico.
    You can type code here. The simplest thing we can do is a `"Hello, world!"`. Type
    the bold text, and it should respond as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的控制台正在运行 CircuitPython，它位于 Raspberry Pi Pico 上。你可以在其中输入代码。我们能做的最简单的事情是输入一个
    `"Hello, world!"`。输入粗体文本，它应该会做出如下响应：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Well done—this is the first bit of working CircuitPython code. However, this
    is about hardware, so we will light an LED instead. Type the following code into
    the REPL:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好——这是第一段可以工作的 CircuitPython 代码。然而，这涉及到硬件，所以我们将点亮一个 LED。在 REPL 中输入以下代码：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To talk to hardware, we start by importing some libraries.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要与硬件通信，我们首先导入一些库。
- en: The `board` library stores board interface details—naming and mapping pins on
    the device to names. What is cool about this library is that if you pick up a
    different board and put CircuitPython on it, then to some degree, named pins such
    as `board.LED` will work on that too.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`board` 库存储了板接口的详细信息——在设备上命名和映射引脚。这个库的酷之处在于，如果你拿起不同的板并在其上安装 CircuitPython，那么在某种程度上，像
    `board.LED` 这样的命名引脚也会在那里工作。'
- en: The `digitalio` library has the basics for reading and writing to IO pins, defining
    them as a **digital pin** (versus other ways you can use a Pico pin), and then
    setting their direction.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`digitalio` 库提供了读取和写入 IO 引脚的基本功能，将它们定义为 **数字引脚**（与其他你可以使用 Pico 引脚的方式相比），然后设置它们的方向。'
- en: We then initialize a digital pin using `board.LED`. This uses the built-in LED.
    That LED is on *GPIO pin 25*. You could also have used `board.GP25` for the same
    result. We set this pin’s direction to `OUTPUT`; otherwise, you are not allowed
    to set its value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用 `board.LED` 初始化一个数字引脚。这使用了内置的 LED。该 LED 位于 *GPIO 引脚 25*。你也可以使用 `board.GP25`
    来达到相同的效果。我们将此引脚的方向设置为 `OUTPUT`；否则，不允许设置其值。
- en: 'Finally, in this code, we set `led.value` to `True`, which turns the LED on:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这段代码中，我们将 `led.value` 设置为 `True`，从而点亮 LED：
- en: '![Figure 2.3 – The LED lit on Raspberry Pi Pico ](img/Fig_2.3.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – Raspberry Pi Pico 上点亮的 LED](img/Fig_2.3.jpg)'
- en: Figure 2.3 – The LED lit on Raspberry Pi Pico
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – Raspberry Pi Pico 上点亮的 LED
- en: 'You should see the LED light at this point. We should turn it off when we are
    done:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此时你应该看到 LED 点亮。当我们完成时应该将其关闭：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ve got an LED to light—some hardware interaction. You can flip that value
    from `False` to `True` and back again to turn the LED on and off.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经有一个可以点亮的 LED——一些硬件交互。你可以将此值从 `False` 切换到 `True` 再切换回来，以打开和关闭 LED。
- en: You could set any pin to `True` or `False` this way to control simple hardware,
    and you’ve used the REPL to try stuff out. However, we don’t really want to do
    it manually— so, can we make it more automatic?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过这种方式将任何引脚设置为`True`或`False`来控制简单的硬件，你已经使用REPL来尝试一些东西。然而，我们并不真的想手动操作——那么，我们能否让它更自动化？
- en: Blinking the LED with code
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用代码闪烁LED
- en: The first automatic behavior would be to make the LED blink. In hardware circles,
    this is code is known as *blinky* and is equivalent to `"Hello, World"` for microcontrollers.
    This time, instead of typing this code in the REPL, we are going to write it in
    the editor and upload it to Pico. That way, we can tweak it and send the code
    again.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个自动行为将是使LED闪烁。在硬件领域，这段代码被称为*闪烁*，对于微控制器来说，它相当于“Hello, World”。这次，我们不是在REPL中输入这段代码，而是要在编辑器中编写它并将其上传到Pico。这样，我们可以调整它并再次发送代码。
- en: 'Start by clicking in the code area:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在代码区域点击：
- en: '![Figure 2.4 – Click here to start coding ](img/Fig_2.4.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 点击此处开始编码](img/Fig_2.4.jpg)'
- en: Figure 2.4 – Click here to start coding
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 点击此处开始编码
- en: 'As the box says, we can write out code there. To blink an LED, the basic idea
    is to turn it on, wait a bit, turn it off, wait a bit, and repeat. Let us see
    that in code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如框所示，我们可以在那里编写代码。要闪烁LED，基本思路是打开它，等待一会儿，关闭它，等待一会儿，然后重复。让我们在代码中看看这个：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code starts with the import of `time`, which lets us control time! Well,
    OK—it lets us wait for a bit with `sleep`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码以导入`time`开始，它让我们可以控制时间！好吧——它让我们可以用`sleep`等待一段时间。
- en: We import `board` and `digitalio` and set up the pin and its direction as before.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`board`和`digitalio`，并像以前一样设置引脚及其方向。
- en: To make the LED keep on blinking, we put it in a `while True` loop, which will
    repeat the code indented under it until we (hard or soft) reset Pico.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让LED持续闪烁，我们将其放入一个`while True`循环中，这将重复其下缩进的代码，直到我们（硬或软）重置Pico。
- en: Inside the `while` loop, first we turn the LED on, then we sleep for half a
    second. The time here is written as a decimal number—it is always in seconds,
    and we want less than a second.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环内部，首先我们打开LED，然后休眠半秒钟。这里的时间以十进制数字表示——它总是以秒为单位，我们想要少于1秒。
- en: We turn the LED off again, sleep again, and the code will loop around.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次关闭LED，再次休眠，代码将循环。
- en: Save this code to Raspberry Pi Pico (the USB drive named `CIRCUITPY`) as `code.py`.
    It will automatically run the file named `code.py`—the LED should now start blinking.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码保存到Raspberry Pi Pico（名为`CIRCUITPY`的USB驱动器）中作为`code.py`。它将自动运行名为`code.py`的文件——LED现在应该开始闪烁。
- en: While this seems simple, changing digital IO pins and sleeping is the basics
    of controlling motors too. In this section, you’ve written code to automatically
    blink a light, and seen how to use time and how to upload a file to Raspberry
    Pi Pico instead of typing everything at the REPL. Next, we’ll need to prepare
    Raspberry Pi Pico for plugging in other hardware by soldering on headers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来很简单，但改变数字IO引脚和休眠也是控制电机的基础。在本节中，你已经编写了代码来自动闪烁灯光，并看到了如何使用时间和如何将文件上传到Raspberry
    Pi Pico而不是在REPL中输入所有内容。接下来，我们需要通过焊接引脚头来为Raspberry Pi Pico连接其他硬件做准备。
- en: Soldering headers to Raspberry Pi Pico
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 焊接引脚头到Raspberry Pi Pico
- en: Raspberry Pi Pico can run some neat code, it can blink that LED, and you could
    get it to input things, and print on that serial console. But it’s going to be
    lots more fun if we start plugging stuff into it! To do that, it will need **headers**
    soldered into it. **Soldering** may seem daunting the first time around, but with
    practice, it will be a skill you’ll use repeatedly in robot building.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Pico可以运行一些有趣的代码，它可以闪烁LED，你可以让它输入东西，并在串行控制台上打印。但如果我们开始将其连接到其他设备，那就更有趣了！为了做到这一点，它需要焊接上**引脚头**。**焊接**可能一开始看起来有些令人畏惧，但通过练习，它将成为你在机器人制作中反复使用的技能。
- en: 'We are going to be soldering header pins into Raspberry Pi Pico. These are
    breakaway pin headers:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要焊接引脚头到Raspberry Pi Pico上。这些是断开式引脚头：
- en: '![Figure 2.5 – Breakaway pin headers ](img/Fig_2.5.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 断开式引脚头](img/Fig_2.5.jpg)'
- en: Figure 2.5 – Breakaway pin headers
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 断开式引脚头
- en: Pin headers will let us plug Pico into a breadboard so that we can connect it
    to other electronics or use Pico with female cables to link to sensors. There
    are other kinds—female kinds, not so useful for the breadboard—and you can get
    2-row pin headers, which you’ll see in other Raspberry Pi models.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚头将允许我们将Pico插入到面包板上，这样我们就可以将其连接到其他电子设备，或者使用Pico与雌性电缆连接到传感器。还有其他类型的——雌性类型的，对面包板来说不太有用——你可以得到双排引脚头，你会在其他Raspberry
    Pi型号中看到。
- en: 'To get the right number of pins, we need to measure and snap them off:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到正确的引脚数量，我们需要测量并断开它们：
- en: '![Figure 2.6 – Snapping off the headers ](img/Fig_2.6.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 断开引脚](img/Fig_2.6.jpg)'
- en: Figure 2.6 – Snapping off the headers
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 断开引脚
- en: Breakaway headers such as these come in strips designed to break away. One straightforward
    way to get the right length, instead of counting each one out, is to place the
    short end of the header loose into Pico, as shown in *Figure 2**.6*, and then
    break at the join just past there. You can either cut with a knife or just pull
    them off at an angle. They come apart easily. We’ll want two sets like this.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种断开引脚的部件是成条设计的，可以断开。一种简单的方法是，而不是一个个数，将引脚的短端松散地放入Pico中，如图*图2.6*所示，然后在稍远处的接合处断开。你可以用刀切或者斜着拉掉它们。它们很容易分开。我们想要两套这样的。
- en: 'Raspberry Pi Pico comes with two rows of headers, and we can use this to our
    advantage. Push the Pico and header assembly into a breadboard:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Pico带有两排引脚，我们可以利用这一点。将Pico和引脚组件推入面包板：
- en: '![Figure 2.7 – Raspberry Pi Pico propped onto the headers ](img/Fig_2.7.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – Raspberry Pi Pico放置在引脚上](img/Fig_2.7.jpg)'
- en: Figure 2.7 – Raspberry Pi Pico propped onto the headers
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – Raspberry Pi Pico放置在引脚上
- en: When you solder, you do not want the headers to wobble in their sockets—you
    want them to stay still. The breadboard and headers as pictured in *Figure 2**.7*
    will hold Pico up and stop it from moving.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你焊接时，你不想让引脚在插座中晃动——你希望它们保持静止。图*图2.7*中所示的面包板和引脚将支撑Pico并阻止其移动。
- en: For this work, I recommend a chisel tip for the soldering iron. Chisel tips
    have a good surface area to heat joints with and are common.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这项工作，我推荐使用凿形尖端烙铁。凿形尖端有很好的表面积，可以加热焊点，并且很常见。
- en: You should have an iron, a stand, a tip cleaner (I prefer brass wire), and some
    solder. I recommend safety goggles too. You should also be working in a clear,
    well-lit, and well-ventilated space—use a solder fume extractor if you can; you
    should not inhale these fumes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该准备一个烙铁、一个支架、一个尖端清洁器（我更喜欢黄铜线）和一些焊锡。我也推荐使用安全眼镜。你还应该在明亮、通风良好的空间里工作——如果可能的话，使用焊锡烟雾吸收器；你不应该吸入这些烟雾。
- en: It’s now time to heat up a soldering iron. Allow the iron to heat up—this may
    take a few minutes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候加热烙铁了。让烙铁加热——这可能需要几分钟。
- en: Important note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When the soldering iron is hot, only hold it by the plastic grips. You must
    never touch the metal parts or the tip as these can cause serious burns. Always
    place the iron back into its stand when you put it down.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当烙铁加热时，只能用手握住塑料手柄。你绝对不能触摸金属部件或尖端，因为这些会导致严重的烧伤。当你放下烙铁时，总是把它放回支架上。
- en: You can test if an iron is hot by touching some solder to it—when hot enough,
    it should melt and *wet* the iron tip. This is known as **tinning** and ensures
    good heat transfer between the iron and the items to be soldered. If there is
    a bit of a blob of solder, use the brass-wire tip cleaner to wipe it off. What
    you should be left with is a thin layer of solder around the iron tip. A tinned
    and clean tip will make far better solder joints than a dry or dirty tip!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在烙铁上接触一些焊锡来测试烙铁是否加热——当足够热时，它应该会熔化并*湿润*烙铁尖端。这被称为**上锡**，确保烙铁和要焊接的物品之间有良好的热传递。如果有少量焊锡滴落，使用黄铜线尖端清洁器将其擦掉。你应该留下的是围绕烙铁尖端的一层薄薄的焊锡。一个上锡且干净的尖端会比干燥或脏的尖端制作出更好的焊点！
- en: 'See the next diagram for how to make a solder *joint*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 看下一张图了解如何制作焊点：
- en: '![Figure 2.8 – Making a solder joint ](img/Fig_2.8.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 制作焊点](img/Fig_2.8.jpg)'
- en: Figure 2.8 – Making a solder joint
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 制作焊点
- en: 'The diagram in *Figure 2**.8* shows the steps for making a good solder joint.
    Follow the points along with the diagram:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.8*中的图表显示了制作良好焊点的步骤。按照图表中的点进行操作：'
- en: Shown here is a pin going through a board and the solder pad (the metal bit
    on the board). Use the soldering iron tip to heat both the pad and the board.
    We want them both hot enough to accept solder.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里展示的是一个针穿过电路板和焊盘（电路板上的金属部分）。使用烙铁尖端加热焊盘和电路板。我们希望它们都足够热，可以接受焊锡。
- en: When the pad and pin are hot, push the solder into the pad and pin, not into
    the soldering iron. It is important for nice joints that you heat the pad and
    pin, then bring the solder to it—this means the solder will melt against the pad
    and pin, not the iron, which will lead to a good bond, electrically and mechanically.
    You do not need to use any pressure from the iron, and at the right temperature,
    the solder will flow—it does not need any pressure either.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当焊盘和引脚变热时，将焊料推入焊盘和引脚，而不是烙铁。为了得到好的焊接点，重要的是要加热焊盘和引脚，然后将焊料带到它们那里——这意味着焊料会熔化在焊盘和引脚上，而不是烙铁上，这将导致良好的电学和机械连接。你不需要用烙铁施加任何压力，在适当的温度下，焊料会流动——它也不需要任何压力。
- en: The solder starts to flow and should flow onto the pad and around the pin. You
    do not want a lot of solder here! Use enough to make the cone shape shown here.
    Remove the solder as soon as enough has flown. Pull the iron away from the joint.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 焊料开始流动，应该流向焊盘并围绕引脚流动。你在这里不希望有太多的焊料！使用足够的焊料来形成这里显示的圆锥形状。一旦足够的焊料流出，就立即移除焊料。将烙铁从焊接点拉离。
- en: A good shape should be a shiny cone like this, contacting both the pad and pin.
    If you get a ball here, heat the solder, pad, and pin again—molten solder will
    only stick to hot stuff. If there is a big blob, you can use solder wick to remove
    excess.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个好的形状应该是一个像这样的闪亮的圆锥体，接触焊盘和引脚。如果你在这里得到一个球，再次加热焊料、焊盘和引脚——熔化的焊料只会粘在热的东西上。如果有大滴，可以使用焊料吸球去除多余的焊料。
- en: 'We can take a closer look at how this appears in the real world on Raspberry
    Pi Pico:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更仔细地看看这如何在Raspberry Pi Pico的现实中呈现：
- en: '![Figure 2.9 – Solder joints on Raspberry Pi Pico ](img/Fig_2.9.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – Raspberry Pi Pico上的焊点](img/Fig_2.9.jpg)'
- en: Figure 2.9 – Solder joints on Raspberry Pi Pico
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – Raspberry Pi Pico上的焊点
- en: 'The order in which you make the joint is important. The panels in *Figure 2**.9*
    show where to start soldering:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你焊接的顺序很重要。*图2.9*中的面板显示了开始焊接的位置：
- en: Start in one corner. In this photograph, I am heating up the pad and pin first.
    Ensure the pin headers and Raspberry Pi Pico do not move relative to each other
    when the solder cools. It will cool very quickly, but any movement here will make
    for a poor-quality joint. The breadboard holding strategy here should be enough
    to prevent most movement.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个角落开始。在这张照片中，我首先加热焊盘和引脚。确保当焊料冷却时，引脚头和Raspberry Pi Pico相对于彼此不移动。它将很快冷却，但这里的任何移动都会导致焊接质量差。这里使用的面包板固定策略应该足以防止大多数移动。
- en: Then, move across to the opposite corner. These two joints secure Pico to the
    breadboard, making the board less likely to move in the rig. In the photograph,
    I am adding solder to the joint.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，移动到对角角落。这两个焊接点将Pico固定在面包板上，使板在夹具中移动的可能性更小。在照片中，我正在向焊接点添加焊料。
- en: Once you have done two opposite corners, solder the remaining corners, and then
    you can start filling in the rest of the pins. Good shiny joints should look like
    these. There are 40 in total, but you get into a rhythm once you’ve done the first
    few.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成两个对角角落后，焊接剩余的角落，然后你可以开始填充其余的引脚。好的光亮的焊接点应该看起来像这些。总共有40个，但一旦完成前几个，你就会进入节奏。
- en: Between pins, it’s a good idea to occasionally clean the tip. Use the brass
    tip cleaner (stab the iron into it) to clear excess solder from the soldering
    iron tip.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在引脚之间，偶尔清洁尖端是个好主意。使用黄铜尖端清洁器（将烙铁戳进去）清除烙铁尖端的多余焊料。
- en: 'While soldering, it is possible that you will accidentally bridge two pins—that
    is, connect between them. This must be remedied, or you could damage your Pico
    when you plug it in. See the following diagram on how to clear this up:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在焊接过程中，你可能会意外地将两个引脚桥接起来——也就是说，在它们之间连接。这必须得到纠正，否则当你插入Pico时可能会损坏它。请参阅以下图表了解如何清除：
- en: '![Figure 2.10 – Clearing a solder bridge ](img/Fig_2.10.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 清除焊桥](img/Fig_2.10.jpg)'
- en: Figure 2.10 – Clearing a solder bridge
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 清除焊桥
- en: 'To clear a **solder bridge**, first, clean the soldering iron tip, then follow
    the steps in *Figure 2**.10*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要清除**焊桥**，首先，清洁烙铁尖端，然后按照*图2.10*中的步骤进行：
- en: This is the solder bridge. The solder has created an accidental connection between
    two pins that should not be connected.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是焊桥。焊料意外地在两个本不应相连的引脚之间形成了连接。
- en: Put the iron between the pins, and when the solder melts, draw the iron through
    between them. The solder should flow around the two pins.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将烙铁放在引脚之间，当焊料融化时，将烙铁从它们之间拉过。焊料应该环绕着两个引脚流动。
- en: The pins should look a little like this when the bridge has been cleared.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当焊桥被清除后，引脚应该看起来有点像这样。
- en: Now you have made the joints, inspect them to ensure that they are all conical
    tents, none is a bridge, and none has been missed. If so, you have completed this
    soldering job. Do not forget to turn off the soldering iron!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经制作了关节，检查它们以确保它们都是圆锥形帐篷，没有一个是桥梁，也没有遗漏。如果是这样，你就完成了这个焊接工作。别忘了关掉烙铁！
- en: With the pin headers soldered in, this Raspberry Pi Pico is ready to connect
    to a robot.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在引脚焊接完成后，这款Raspberry Pi Pico就准备好连接到机器人了。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve been on a close tour of Raspberry Pi Pico. We’ve put
    CircuitPython on the board and prepared some libraries to copy when we need them.
    We’ve downloaded an editor that can talk to Raspberry Pi Pico on its serial REPL,
    and have then written code to upload to Pico. In doing so, we’ve got the hardware
    to do some basic digital output.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对Raspberry Pi Pico进行了深入的考察。我们在板上安装了CircuitPython，并准备了一些库，以便在需要时复制。我们还下载了一个可以与Raspberry
    Pi Pico的串行REPL通信的编辑器，并编写了上传到Pico的代码。在这个过程中，我们得到了可以进行一些基本数字输出的硬件。
- en: We’ve also soldered headers onto Pico so that we can start building robots around
    it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在Pico上焊接了引脚，这样我们就可以开始围绕它构建机器人了。
- en: In the next chapter, we’ll design the robot to build around it, using CAD and
    taking our test fit into a more serious gear so that we can start cutting material.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将设计围绕它构建的机器人，使用CAD并对我们的测试装配进行更严格的检查，以便我们可以开始切割材料。
- en: Exercises
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try these exercises to get to know Pico more:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下练习来更好地了解Pico：
- en: Adjust the timings in the blink code. You should be able to get the light to
    blink quicker or slower by changing the number of seconds in the `sleep` statements.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在blink代码中调整时间设置。你应该可以通过改变`sleep`语句中的秒数来使灯光更快或更慢地闪烁。
- en: Could you make the light blink in an irregular pattern? You could use a series
    of timings. Digging a bit at CircuitPython, you could use a list of values and
    loop through them.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能将灯光以不规则的模式闪烁吗？你可以使用一系列的时间设置。在CircuitPython中稍作研究，你可以使用一个值列表并通过循环遍历它们。
- en: Explore using the REPL for other Python code.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索使用REPL进行其他Python代码。
- en: We are going to need header pins on the motor board as well. Using the same
    techniques as covered in the section Soldering headers to Raspberry Pi Pico, solder
    pins into the motor driver board.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要在电机板上使用引脚。使用与第Soldering headers to Raspberry Pi Pico部分中介绍的技术，将引脚焊接进电机驱动板。
- en: Further reading
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Please refer to the following resources for more information:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下资源获取更多信息：
- en: At this stage, it is worth having the datasheet for Raspberry Pi Pico to hand,
    available at [https://datasheets.raspberrypi.org/pico/pico-datasheet.pdf](https://datasheets.raspberrypi.org/pico/pico-datasheet.pdf).
    It has a helpful pin reference on *page 5*.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个阶段，手头备有Raspberry Pi Pico的数据表会很有帮助，可在[https://datasheets.raspberrypi.org/pico/pico-datasheet.pdf](https://datasheets.raspberrypi.org/pico/pico-datasheet.pdf)找到。它在*第5页*上有有用的引脚参考。
- en: CircuitPython also has a reference guide at [https://docs.circuitpython.org/en/7.3.x/docs/index.html](https://docs.circuitpython.org/en/7.3.x/docs/index.html).
    The *Core Modules* section will be helpful for further experimenting with this
    environment.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CircuitPython还有一个参考指南，可在[https://docs.circuitpython.org/en/7.3.x/docs/index.html](https://docs.circuitpython.org/en/7.3.x/docs/index.html)找到。*核心模块*部分将有助于在此环境中进行进一步的实验。
