- en: Chapter 3. More AdventureWorks Regression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, you had your software developer hat on and you stuck your
    toe into machine learning waters. You created a simple linear regression and implemented
    it in your website. The regression attempted to explain how customer reviews affected
    bike sales quantity to retail shops. In this chapter, we are going to pick up
    where we left off and use a multiple linear regression to explain bike sales with
    more precision. Then we will switch over to a logistic regression to see if we
    can predict whether an individual customer will or will not purchase a bike based
    on the same factors. We will then consider how to implement the regression in
    an experiment that will help with the model's accuracy and repeatability. Finally,
    we will wrap up by considering some of the strengths and weaknesses of regressions.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to multiple linear regression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A multiple linear regression has the same concept as a simple linear regression,
    in that we are trying to find the best fit. The major difference is that we have
    more than one independent variable that is trying to explain the dependent variable.
    If you remember from the last chapter, we made a regression like this: *Y = x0
    + E*, where *Y* was bike sales and *x0* was average ratings.'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to see whether there is a relationship between average rating and
    price of the bike on bike sales, we can use the formula *Y = x0 + x1 + E*, where
    *Y* is bike sales, *x0* is the average ratings, and *x1* is the price of the bike.
  prefs: []
  type: TYPE_NORMAL
- en: Intro example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into actual data, let's dissect a multiple linear regression.
    Open up Visual Studio and create a new F# library project. Add a script file called
    `AccordDotNet.fsx`. Next, add a NuGet reference to `Accord.Statistics`. If you
    are unfamiliar with how to do any of those tasks, review [Chapter 1](part0015_split_000.html#E9OE1-a18db0be6c20485ba81f22e43ca13055
    "Chapter 1. Welcome to Machine Learning Using the .NET Framework"), *Welcome to
    Machine Learning Using the .NET Framework*, and [Chapter 2](part0024_split_000.html#MSDG2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 2. AdventureWorks Regression"), *AdventureWorks Regression*, where each
    step is detailed using screenshots.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of your script, add in the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's create a dummy dataset. In this case, let's see if there is a relationship
    between a student's age, their IQ, and their GPA. Since there are two independent
    variables (`x0` and `x1`), we will create an input value called, well, `xs` and
    see it with five observations. Since there are two values for each observation,
    `xs` is a jagged array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending it to the REPL, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this dataset, the first observation is a 15 year old with a 130 IQ, the
    second is an 18 year old with a 127 IQ, and so on. With the inputs taken care
    of, let''s create the `y`, which is the student''s GPA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending to the REPL, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first student has a 3.6 GPA, the second has a 3.5, and so on. Notice that
    since our output is a single number, we only need a simple array to hold the values.
    With our inputs taken care of, let''s create a multiple linear regression with
    our `xs` and `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of things to notice. First, Accord printed the formula of
    our multiple linear regression for us as `y(x0, x1) = 0.0221298495645295*x0 +
    0.0663103721298495*x1 + -5.20098970704672`. The key thing to notice is that you
    cannot interpret the results of multiple regressions the same as the simple regression,
    for example, summing `x1` and `x2` together to be the slope of a line would be
    incorrect. Rather, each `x` is the slope of the line if the other `x` is held
    constant. So, in this case, if `x1` is held constant, each change of one unit
    of `x0` changes `y` `.022`. Back to our example, we can say that if we increase
    a person's age by one year, a person's GPA increases by .022, holding the IQ constant.
    Similarly, we can say that for every one point drop in a person's IQ, the person's
    GPA drops 0.066, holding the person's age constant. We can't use a scatterplot
    to show all of the results of a multiple regression the way we can with a simple
    regression because you would need an axis for each `x` value and that quickly
    will get unwieldy, if not impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s see how good our regression is using our old friends `r2` and
    `rmse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `sse` is the same as the error from above. Accord.NET returns `sse`
    as an error, so I will just use that in the future. Also, looking at our result,
    we can see that we have an `r2` of `.79`, which is pretty good and that our `rmse`
    is `.18`, which is also low enough that the regression is a viable one.
  prefs: []
  type: TYPE_NORMAL
- en: Keep adding x variables?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If two `x` variables are good, are three better? Let''s take a look. Let''s
    add another variable, in this case, the student''s prior year GPA as a third `x`
    value. Go back to the REPL and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So the `r2` is now up to 99%, which means we can explain 99% of the change in
    a person's GPA using their age, IQ, and prior year GPA. Also, note that the `rmse`
    is `.04`, which is nice and low. We have a pretty good model.
  prefs: []
  type: TYPE_NORMAL
- en: AdventureWorks data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the demo out of the way, let''s implement a multiple linear regression
    back at the bike company. Since we are using more realistic data, I don''t think
    we will get a 99% `r2`, but we can hope. In your **Solution Explorer**, add another
    F# script called `AccordDotNet2.fsx`. Then, add a reference to `System.Transactions`
    so that we can use ADO.NET to access our data. Go back to `AccordDotNet2.fsx`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this is very similar to the code that you wrote in the prior chapter.
    In fact, you might want to copy and paste that code and make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `ListPrice` field to the `ProductInfo` record type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the query to add a clause to pull down the list price of the bike.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `productInfos`. Add a method to include the third value we are bringing
    down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code itself shapes a data frame of a number of orders, average reviews,
    and average price by `productId` in SQL and brings it local. Sending this code
    to the REPL, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With the data down, let''s create a multiple linear regression. Add the following
    code to the script file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this code to the REPL, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By adding the price of the bike, our `r2` moves from `.29` to `.35`. Also, our
    `rmse` moves from `2.77` to `2.65`. This change means we have a more accurate
    model with a smaller amount of error. Because this is better, let's add this to
    our production application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding multiple regression to our production application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open up the `AdventureWorks` solution that you started working on in the last
    chapter. In the **Solution Explorer**, navigate to the `AdventureWorks.MachineLearning`
    project and open `OrderPrediction.fs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the `ProductReview` type and replace it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, go into the `OrderPrediction` type and find the line where the reviews
    value is assigned and replace it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, locate the query value and replace its contents with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, scroll down to the `PredictQuantity` function and locate the `reader.Read()`
    line of codes. Replace it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, remove all of the remaining code in the `PredictQuantity` function
    starting with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice we have to create a jagged array even though we are only entering in
    one `productInfo` for the final `regression.Compute()`. Also, notice that the
    `Compute` function returns an array, but since we are only entering in one value,
    the resulting array will always have a length of one. We used the `Seq.head` to
    pull the first value of the array. The head function comes in quite handy at certain
    times and we will be seeing it again in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the project and open up the UI; you can see that our prediction has been
    adjusted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding multiple regression to our production application](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Considerations when using multiple x variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you might be thinking, "This is great! I can keep adding more
    and more variables to my multiple linear regression and I will get a better and
    better `r2` and a lower `rmse`." As Lee Corso might say, "Not so fast!" Without
    getting too far into the details, every time you add a new feature of a linear
    multiple regression, you will always get a better result, or, at least, not a
    worse result. This means, if you add in the average temperature from different
    cities on June 29, 1999, the model might improve. Also, as you increase the number
    of features, the chance of introducing unwanted side effects into your model increases;
    we will talk about that in a little bit. In fact, I have seen some models where
    the number of features outnumber the number of observations. As a rule, this is
    a not a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: To combat feature growth, you can take two approaches. First, you can combine
    common sense with Occam's Razor. Occam's Razor is the notion that given a choice
    of possible solutions, the simplest one should always be chosen. This combination
    of sense and simplicity is more common and powerful than most people realize.
    The gray matter between the ears is a pretty powerful computer in its own right
    and can do a good job of seeing patterns and making relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, the business analyst who has spent time in the domain might know of
    relationships that are not apparent to an external data scientist looking at a
    laundry list of features or a basic machine learning model that is thrown at the
    data. Granted, humans do have biases and sometimes miss relationships, but on
    the whole, they are still good at matching patterns. Applying Occam's Razor to
    feature selection means that you are trying to find the fewest number of features
    that has the greatest impact on the model's predictability.
  prefs: []
  type: TYPE_NORMAL
- en: Let's head over to our friendly business analyst at AdventureWorks and ask him
    what he thinks influences the quantity of bicycles purchased by our resellers.
    He says, "Well, I think that price and customer reviews are certainly very important,
    but I think that the weight of the bike influences our resellers. The heavier
    the bike, the less likely they are to order some."
  prefs: []
  type: TYPE_NORMAL
- en: Adding a third x variable to our model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the business analyst''s idea in mind, let''s add a third independent variable
    to our model, bike weight. Go back to the **Solution Explorer** and add another
    script file. Add the following code to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL, notice that our `r2` goes to `.36` and our `rmse`
    drops to `2.63`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Our analyst's intuition about price and customer reviews was spot on, the weight…not
    so much. Using Occam's Razor, we can use price and customer reviews for our model
    and ignore the weight variable.
  prefs: []
  type: TYPE_NORMAL
- en: Logistic regression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are becoming more comfortable with regressions, let's introduce
    another type of regression—the logistic regression. Up to this point, the regressions
    have had a numeric output value—like predicting a person's GPA or predicting the
    number of bikes sold. Logistic regressions use the same technique of fitting a
    group of independent features to a line, but they do not attempt to predict a
    number. Rather, a logistic regression attempts to predict a binary value (yes/no,
    true/false, tastes great/less filling) and then assigns a probability to that
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Intro to logistic regression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since you have already had an introduction to regressions, we can skip straight
    to the code and see one in action. Open up the regression project and add a script
    called `AccordDotNet7.fsx`. Copy in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: I pulled this dataset from Wikipedia and it represents 20 students, how many
    hours of studying they did the day before an exam, and whether they passed the
    exam represented as `0.0` for failure and `1.0` for pass. Looking at the `xs`,
    student 0 studied 0.5 hours and looking at the `y`, we can see that s/he did not
    pass the exam.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create our regression analysis and look at some results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL gives this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There are plenty of new things going on here, so let''s take a look at them
    in turn. After we create an analysis, we compute the regression. The next item
    is `pValue`. `pValue` is a common measure of accuracy for logistic regressions.
    As we saw earlier, linear regressions typically use `rmse` and `r2` as a way to
    measure model accuracy. Logistic regressions can use those measures, but usually
    don''t. Unlike the linear regression where the model spits out an exact number
    using something called *least-squares*, the logistic regression uses something
    called *maximum-likelihood* where the regression iterates and tries different
    combinations of the input values to maximize the likelihood of the result. Therefore,
    the logistic regression needs to be run many times over the dataset and we can
    configure how precise we want the model to be. Graphically, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Intro to logistic regression](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Coming back to `pValue`, it is a measure of how well our model compares to the
    `null` hypothesis, or basically, how well our model compares to a completely random
    model. If the `pValue` is less than 0.05, our model is valid. If the number is
    above 0.05, the model is no better than a random one. You might be asking yourself,
    "What is so special about 0.05?" The exact answer resides in some low-level mathematical
    functions that are beyond the scope of this book. The rough answer is, well, that
    is what everyone uses so that is what Accord baked in. If you don't find that
    explanation satisfactory, take a look at this post on Wikipedia ([https://en.wikipedia.org/wiki/P-value](https://en.wikipedia.org/wiki/P-value)).
    In any event, the 0.0006 is very good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to the next values, we see `GetOddsRatio` results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'What this means is that if we didn''t study at all, we would have 1.6% chance
    of passing the exam. If we want to pass the exam, we need to study 4.5 hours.
    Next, take a look at the coefficients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Accord.NET passes back an array for the coefficients, with the first value
    being the intercept. With these, you can create a formula to predict if a student
    can pass the exam given any input of hours of studying. For example, here are
    the predictions from our base dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Intro to logistic regression](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to start playing with beer and hours of studying combinations (for
    example, "Will I pass if I study for 4.5 hours?"), we can do that using the `Compute`
    function. At the bottom of the script file, enter in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Send it to the REPL for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: So you have an 82% chance of passing if you study for 3.75 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Adding another x variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s add in another variable to our model—the number of beers you drank
    the night before the exam. Go back to your script file and add this to the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL, we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating the results, we still need to study 4.59 hours to pass, holding the
    number of beers constant. Also, we will need to drink less than .74 of a beer
    to pass. Notice that the odds ratio is positive, even though consuming more beer
    actually decreases our chance to pass. We know that there is an inverse relationship
    between the number of beers and the odds of passing because the coefficient for
    beer (-.029986) is negative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start trading off studying hours and drinking beer on the chance
    of us passing the exam. Go to the script file and add in studying 4.5 hours and
    drinking one beer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending it to the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So you have a 95% chance of passing if you drink a beer and study 4.5 hours.
    To further cement your odds, try filling out "B" on question 4 to push you over
    the top—that always worked for me in middle school.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a logistic regression to AdventureWorks data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So going back to a more realistic dataset, let''s take a look at AdventureWorks.
    Go ahead and add a new script file to the project. Call it `AccordDotNet8.fsx`.
    Copy and paste the following code into the script file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL, you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: There's no new code here, so we can safely press on. However, I would like to
    note that this query might take a bit longer than any other query we have run
    against the database so far. This has an implication for how we architect our
    code when we integrate it to our application. We will discuss this in length in
    [Chapter 5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055 "Chapter 5. Time
    Out – Obtaining Data"), *Time Out – Obtaining Data*, but for now, we just want
    to note it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the script file, go ahead and add this code to the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL, you should get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There are some new pieces of code to look at and two new concepts. First, notice
    that a new record type was created for `ProductInfo` and the colors are broken
    out from a single column (`ProductType.Color`) to a series of 0.0/1.0 columns
    (`ProductType'.BlackInd`, `ProductType'BlueInd`, and so on). The reason I did
    not make the columns bool is that Accord.NET expects inputs to be a float and
    0.0/1.0 serves the purpose just as well. These columns are called "dummy" variables
    and they are used by logistic regressions to accommodate categorical data. At
    this point, you are probably asking, "What the heck is categorical data?" Fair
    question.
  prefs: []
  type: TYPE_NORMAL
- en: Categorical data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might not have noticed, but all of the `x` variables that we have used
    until this last query have been numeric—number of bikes sold, average reviews,
    number of beers drank, and the like. These values are considered continuous because
    they can be of infinite value. I can have one, two, or three beers. Similarly,
    the average reviews of a bike can be 3.45, 3.46, and so on. Because these values
    are treated as numbers, they can be added, averaged, and manipulated in all of
    the ways that you''ve learned since first grade. Note that continuous values can
    be range-bound: the average review can only be between 0.0 and 5.0 because that
    is what we limited users to enter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Categorical values are different. Typically, they are integers that stand in
    for a non-numeric concept. For example, 0 might be male and 1 might be female.
    Similarly, the status of the sales order might be 1 for open, 2 for pending, 3
    for closed, and 4 for returned. Although these values are stored in the database
    as integers, they cannot be added, averaged, or otherwise manipulated. Categorical
    values may also be stored as strings, like we have seen for a bike color: "black",
    "blue", and the like. In this case, the range of strings is limited to a set from
    which numbers can be chosen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our analysis, we have the bike color, which is a categorical
    value and is being stored as a string. We can''t send this string to Accord.NET
    as a single `x` variable because the `LogisticRegressionAnalysis` only takes in
    floats in the array. Note that in other statistical packages like R or SAS, you
    can pass in a string because there is behind-the-scenes code that translates those
    string values to numeric. So, back to color. We want to use it, but it has to
    become a float. We could create a new field called `ColorId` and hook up a translation
    function that turns each of the colors to a numeric representation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And we will do that in other places in the book. However, using those numeric
    values makes no sense in our logistic regression because there is no real meaning
    in comparing values: an `oddsRatio` of 2.3 means what? In fact, no type of regression
    can make sense of categorical data coded in this way. Instead of building nonsensical
    values, we create dummy variables that can be interpreted with meaning in a regression.
    For each of the possible values of our categorical variable, we create a bool
    column that indicates whether that particular record has that value. Technically,
    we can create one less than the total possible values, but I find it easier to
    reason and display a column for each value. We can then pass these dummy variables
    into a regression and get a meaningful response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also notice that I did the pattern matching for the colors assignment on one
    line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'There is some heated controversy in the F# community about whether this is
    considered bad form: some people want to see each possible outcome of the pattern
    matching statement to be on one line, and others do not. I find it much more readable
    to keep everything on one line in cases like this, but I acknowledge it is a bit
    harder for someone new to F# from a curly-braced language like C#. If, however,
    you use ternary operators you should be comfortable with the syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, notice that we changed our continuous variable of `Markup` to `High Margin`
    using this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Attachment point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since logistic regressions need to have a 0.0 or 1.0 as a `y` variable, we
    need a way of splitting the data into something that has both business meaning
    and can be evaluated into 0.0 or 1.0\. How did I pick $800? I eyeballed it after
    doing this in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: That $800 number is often called the "attachment point" and is often the most
    discussed part of any logistic regression model. In the real world, that number
    is often set by the President of a small company on the back of a napkin, or,
    in a large company, a multi-disciplinary team that takes six weeks. The key thing
    to remember is that you want that number in your `config` file (if you are running
    your regression at real-time) or a separate variable at the top of your script
    (if doing it ad hoc). Note that to make our script even smarter, it is possible
    to inject in another model that determines the attachment point dynamically, so
    it will not require a human to update it, but that will be an exercise for another
    day.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing results of the logistic regression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice that the colors are ordered in a random manner and are placed after the
    customer selects the model. What if we moved the colors to the first selection
    to get the user in the "black frame of mind" and then offer models? Also, perhaps
    we should move the color selection so that black is on top?
  prefs: []
  type: TYPE_NORMAL
- en: While this is pretty good, this is a book about machine learning and there is
    little machine learning here to this point (unless you count the logistic regression's
    methodology in determining the answer, which I don't). How can we update our site
    automatically as customers' preferences change? What if all the cool kids started
    riding silver bikes? How can we quickly take advantage of this? How can the machine
    learn faster than the research analysts running the model periodically?
  prefs: []
  type: TYPE_NORMAL
- en: We could do what we did in the last chapter and run the model on each page creation,
    create an evaluator of the model, and then populate the select list. However,
    if you remember about how long it took to run, it is a suboptimal solution because
    by the time it takes to run the model, most of our customers would abandon the
    site (though if they were using a mobile device, we can always blame the network
    connection; developers have never done this before). As an alternative, what if
    we created a process when the website started that constantly runs the model and
    caches the result? This way, each time the page is created, the data behind the
    select list is as fresh as it can be. Let's drop into Visual Studio and make it
    happen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding logistic regression to the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open up the `AdventureWorks` solution and go to the `AdventureWorks.MachineLearning`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding logistic regression to the application](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a new F# source file and name it `ColorPrediction.fs`. You will notice
    that it is placed at the bottom of the project. The order of the files is important
    in an F# project because of the type inference system. What you can do is right-click
    on the file and move it up above the `.config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding logistic regression to the application](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Move Up option
  prefs: []
  type: TYPE_NORMAL
- en: 'Go into the `ColorPrediction.fs` file and replace all the existing code with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add in the types that we created in the regression project and
    the one type we need for this compiled assembly. While we''re at it, add in the
    list of `ProductInfos` and the connection string and query values from the regression
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add a method that will return an ordered list of colors with the
    most important one on top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the code is the same as the work we did in the regression project,
    but there is some new code that needs some explanation. There is now a string
    array called `colors` that lists all of the colors that we sent to our regression.
    After the `analysis.Compute()` is called, we remove the first value from the `analysis.CoefficientValues`
    via this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Skip is a handy function that allows us to, well, skip the first rows of `Seq`.
    We are calling it here because the `analysis.CoefficientValues` returns the coefficient
    in the first value of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We have seen `Seq.zip` before. We are gluing together the colors array with
    the coefficient values array so each row is a tuple of the color name and its
    coefficient. With that array set up, we then implement the final transformation
    pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This applies a `mapi` function to `colors`. `Seq.mapi` is a high order function
    that is just like the `Seq.map` function with one extra parameter, the index of
    each row. So the index `i` is passed in and then the tuple `(c,cv)`, which is
    the color and the `coefficientValue`. We return a tuple with the color, a -1 or
    +1 depending on the sign of the `coefficientValue`, and the odds ratio ->, which
    we look up based on the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This applies another function that returns the color and a signed odds ratio.
    If you remember from before, `Regression.GetOddsRatio` is always positive. We
    are applying the sign so we can order the ratios from most probable to the least
    probable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This applies a function that sorts the array based on the odds ratio so that
    the tuple with the highest `oddsRatio` is on top.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two steps turn the tuple into a simple string. The color name then
    transforms our `Seq` to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'With the code in place, let''s hop over to our MVC project and implement it.
    Find the `Global.asax` file and open it up. Replace the code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of this code might be new, so let''s take a closer look. First, we created
    two class-level variables: `_lock` and `_timer`. We use `_lock` to prevent our
    color array to be read while our regression could be updating it. You can see
    `_lock` in action in the public property that exposes the color array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a method that will be called when our timer fires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are creating an instance of our `ColorPrediction` class, which
    then invokes the `GetColors` method. We assign the `BikeColors` property with
    the return of our recently-calculated solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we instantiate the `_timer` variable in the `Application.Start` method,
    passing in the method that gets invoked when the timer counts down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This means, every minute we call the color prediction to run the logistic regression
    based on the most recent data. Meanwhile, clients will be calling our website
    continuously and they will be getting an array of colors based on the most recent
    calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go to the `.config` file and add the attachment point to the `appSettings`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, open the `individualOrder` controller and replace the hardcoded values
    of colors with our generated one in the `Create` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the site and you will see that our color list has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding logistic regression to the application](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We now have a pretty good model that seems to be working in production, without
    a major performance hit. However, our solution so far has a fatal flaw. We are
    guilty of overfitting. As mentioned in [Chapter 2](part0024_split_000.html#MSDG2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 2. AdventureWorks Regression"), *AdventureWorks Regression*, overfitting,
    is the notion that the model we create only works against the data we have on
    hand and fails miserably when we introduce it to new data. Every machine learning
    technique has a problem with overfitting, and there are some common ways to mitigate
    its impact. We will look at that in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot of ground in this chapter. We looked at multiple linear regressions,
    logistic regressions, and then considered a couple of techniques to normalize
    our dataset. Along the way, we learned some new F# code and learned a way to update
    a machine learning model without impact on our end user experience.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we take a break from AdventureWorks and line of business
    development and start working with some open data as a data scientist using a
    decision tree. As Dick Clark used to say, "The hits just keep coming."
  prefs: []
  type: TYPE_NORMAL
