["```py\n// To create histograms of gray-level images\nclass Histogram1D {\n\n  private:\n\n    int histSize[1];         // number of bins in histogram\n    float hranges[2];        // range of values\n    const float* ranges[1];  // pointer to the value ranges\n    int channels[1];         // channel number to be examined\n\n  public:\n\n  Histogram1D() {\n\n    // Prepare default arguments for 1D histogram\n    histSize[0]= 256;   // 256 bins\n    hranges[0]= 0.0;    // from 0 (inclusive)\n    hranges[1]= 256.0;  // to 256 (exclusive)\n    ranges[0]= hranges; \n    channels[0]= 0;     // we look at channel 0\n  }\n```", "```py\n  // Computes the 1D histogram.\n  cv::Mat getHistogram(const cv::Mat &image) {\n\n    cv::Mat hist;\n\n    // Compute histogram\n    cv::calcHist(&image, \n      1,         // histogram of 1 image only\n      channels,  // the channel used\n      cv::Mat(), // no mask is used\n      hist,      // the resulting histogram\n      1,         // it is a 1D histogram\n      histSize,  // number of bins\n      ranges     // pixel value range\n    );\n\n    return hist;\n  }\n```", "```py\n   // Read input image\n   cv::Mat image= cv::imread(\"group.jpg\",\n                             0); // open in b&w\n\n   // The histogram object\n   Histogram1D h;\n\n   // Compute the histogram\n   cv::Mat histo= h.getHistogram(image);\n```", "```py\n   // Loop over each bin\n   for (int i=0; i<256; i++) \n      cout << \"Value \" << i << \" = \" << \n                   histo.at<float>(i) << endl;  \n```", "```py\n...\nValue 7 = 159\nValue 8 = 208\nValue 9 = 271\nValue 10 = 288\nValue 11 = 340\nValue 12 = 418\nValue 13 = 432\nValue 14 = 472\nValue 15 = 525\n...\n```", "```py\n// Computes the 1D histogram and returns an image of it.\ncv::Mat getHistogramImage(const cv::Mat &image, \n                             int zoom=1){\n\n  // Compute histogram first\n  cv::Mat hist= getHistogram(image);\n  // Creates image\n  return getImageOfHistogram(hist, zoom);\n}\n\n// Create an image representing a histogram (static method)\nstatic cv::Mat getImageOfHistogram\n                  (const cv::Mat &hist, int zoom) {\n  // Get min and max bin values\n  double maxVal = 0;\n  double minVal = 0;\n  cv::minMaxLoc(hist, &minVal, &maxVal, 0, 0);\n\n  // get histogram size\n  int histSize = hist.rows;\n\n  // Square image on which to display histogram\n  cv::Mat histImg(histSize*zoom, \n                   histSize*zoom, CV_8U, cv::Scalar(255));\n\n  // set highest point at 90% of nbins (i.e. image height)\n  int hpt = static_cast<int>(0.9*histSize);\n\n  // Draw vertical line for each bin \n  for (int h = 0; h < histSize; h++) {\n\n    float binVal = hist.at<float>(h);\n    if (binVal>0) {\n      int intensity = static_cast<int>(binVal*hpt / maxVal);\n      cv::line(histImg, cv::Point(h*zoom, histSize*zoom),\n        cv::Point(h*zoom, (histSize - intensity)*zoom), \n             cv::Scalar(0), zoom);\n    }\n  }\n\n  return histImg;\n}\n```", "```py\n   // Display a histogram as an image\n   cv::namedWindow(\"Histogram\");\n   cv::imshow(\"Histogram\",\n               h.getHistogramImage(image));\n```", "```py\ncv::Mat thresholded; // output binary image\ncv::threshold(image,thresholded,\n            60,    // threshold value\n            255,   // value assigned to \n                   // pixels over threshold value\n          cv::THRESH_BINARY); // thresholding type\n```", "```py\nvoid calcHist(const Mat* images, int nimages, \n  const int* channels, InputArray mask, OutputArray hist, \n  int dims, const int* histSize, const float** ranges, \n  bool uniform=true, bool accumulate=false )\n```", "```py\n         float binVal = hist.at<float>(h);\n```", "```py\nclass ColorHistogram {\n\n  private:\n\n    int histSize[3];        // size of each dimension\n    float hranges[2];       // range of values\n    const float* ranges[3]; // ranges for each dimension\n    int channels[3];        // channel to be considered\n\n  public:\n\n  ColorHistogram() {\n\n    // Prepare default arguments for a color histogram\n    // each dimension has equal size and range\n    histSize[0]= histSize[1]= histSize[2]= 256;\n    hranges[0]= 0.0;    // BRG range from 0 to 256\n    hranges[1]= 256.0;\n    ranges[0]= hranges; // in this class,  \n    ranges[1]= hranges; // all channels have the same range\n    ranges[2]= hranges; \n    channels[0]= 0;    // the three channels \n    channels[1]= 1; \n    channels[2]= 2; \n  }\n```", "```py\n  // Computes the histogram.\n  cv::Mat getHistogram(const cv::Mat &image) {\n\n    cv::Mat hist;\n\n    // BGR color histogram\n    hranges[0]= 0.0;    // BRG range\n    hranges[1]= 256.0;\n    channels[0]= 0;    // the three channels \n    channels[1]= 1; \n    channels[2]= 2; \n\n    // Compute histogram\n    cv::calcHist(&image, \n      1,          // histogram of 1 image only\n      channels,   // the channel used\n      cv::Mat(),  // no mask is used\n      hist,       // the resulting histogram\n      3,          // it is a 3D histogram\n      histSize,   // number of bins\n      ranges      // pixel value range\n    );\n\n    return hist;\n  }\n```", "```py\n  // Computes the histogram.\n  cv::SparseMat getSparseHistogram(const cv::Mat &image) {\n\n    cv::SparseMat hist(3,        // number of dimensions\n                      histSize, // size of each dimension\n                   CV_32F);\n\n    // BGR color histogram\n    hranges[0]= 0.0;    // BRG range\n    hranges[1]= 256.0;\n    channels[0]= 0;     // the three channels \n    channels[1]= 1; \n    channels[2]= 2; \n\n    // Compute histogram\n    cv::calcHist(&image, \n      1,         // histogram of 1 image only\n      channels,  // the channel used\n      cv::Mat(), // no mask is used\n      hist,      // the resulting histogram\n      3,         // it is a 3D histogram\n      histSize,  // number of bins\n      ranges     // pixel value range\n    );\n\n    return hist;\n  }\n```", "```py\n         newIntensity= lookup[oldIntensity];\n```", "```py\n   static cv::Mat applyLookUp(\n    const cv::Mat& image,     // input image\n    const cv::Mat& lookup) {  // 1x256 uchars\n\n      // the output image\n      cv::Mat result;\n\n      // apply lookup table\n      cv::LUT(image,lookup,result);\n\n      return result;\n   }\n```", "```py\n   // Create an image inversion table\n   int dim(256);\n   cv::Mat lut(1, // 1 dimension\n      &dim,       // 256 entries\n      CV_8U);     // uchar\n\n   for (int i=0; i<256; i++) {\n\n      lut.at<uchar>(i)= 255-i;\n   }\n```", "```py\n255.0*(i-imin)/(imax-imin);\n```", "```py\n   cv::Mat stretch(const cv::Mat &image, int minValue=0) {\n\n      // Compute histogram first\n      cv::Mat hist= getHistogram(image);\n\n      // find left extremity of the histogram\n      int imin= 0;\n      for( ; imin < histSize[0]; imin++ ) {\n         // ignore bins with less than minValue entries\n         if (hist.at<float>(imin) > minValue)\n            break;\n      }\n\n      // find right extremity of the histogram\n      int imax= histSize[0]-1;\n      for( ; imax >= 0; imax-- ) {\n\n         // ignore bins with less than minValue entries\n         if (hist.at<float>(imax) > minValue)\n            break;\n      }\n\n      // Create lookup table\n      int dim(256);\n      cv::Mat lookup(1,  // 1 dimension\n            &dim,        // 256 entries\n            CV_8U);      // uchar\n\n      // Build lookup table\n      for (int i=0; i<256; i++) {\n\n         // stretch between imin and imax\n         if (i < imin) lookup.at<uchar>(i)= 0;\n         else if (i > imax) lookup.at<uchar>(i)= 255;\n         // linear mapping\n      else lookup.at<uchar>(i)= \n        cvRound(255.0*(i-imin)/(imax-imin));\n      }\n\n      // Apply lookup table\n      cv::Mat result;\n      result= applyLookUp(image,lookup);\n\n      return result;\n   }\n```", "```py\n  // setting 1% of pixels at black and 1% at white\n  cv::Mat streteched = h.stretch(image,0.01f);\n```", "```py\nvoid colorReduce(cv::Mat &image, int div=64) {\n\n    // creating the 1D lookup table\n    cv::Mat lookup(1,256,CV_8U);\n\n    // defining the color reduction lookup\n    for (int i=0; i<256; i++) \n      lookup.at<uchar>(i)= i/div*div + div/2;\n\n    // lookup table applied on all channels\n    cv::LUT(image,lookup,image);\n}\n```", "```py\n      cv::equalizeHist(image,result);\n```", "```py\nlookup.at<uchar>(i)=   \n        static_cast<uchar>(255.0*p[i]/image.total());\n```", "```py\n   cv::Mat imageROI;\n   imageROI= image(cv::Rect(216,33,24,30)); // Cloud region\n```", "```py\n   Histogram1D h;\n   cv::Mat hist= h.getHistogram(imageROI);\n```", "```py\n   cv::normalize(histogram,histogram,1.0);\n```", "```py\n  cv::calcBackProject(&image,\n            1,          // one image\n            channels,   // the channels used, \n                        // based on histogram dimension\n            histogram,  // the histogram we are backprojecting\n            result,     // the resulting back projection image\n            ranges,     // the ranges of values\n            255.0       // the scaling factor is chosen \n            // such that a probability value of 1 maps to 255\n       );\n```", "```py\ncv::threshold(result, result, threshold, \n                      255, cv::THRESH_BINARY);\n```", "```py\nclass ContentFinder {\n\n  private:\n\n  // histogram parameters\n  float hranges[2];\n   const float* ranges[3];\n   int channels[3];\n\n  float threshold;           // decision threshold\n  cv::Mat histogram;         // input histogram \n\n  public:\n\n  ContentFinder() : threshold(0.1f) {\n\n    // in this class, all channels have the same range\n    ranges[0]= hranges;  \n    ranges[1]= hranges; \n    ranges[2]= hranges; \n  }\n```", "```py\n   // Sets the threshold on histogram values [0,1]\n   void setThreshold(float t) {\n\n      threshold= t;\n   }\n\n   // Gets the threshold\n   float getThreshold() {\n\n      return threshold;\n   }\n```", "```py\n   // Sets the reference histogram\n   void setHistogram(const cv::Mat& h) {\n\n      histogram= h;\n      cv::normalize(histogram,histogram,1.0);\n   }\n```", "```py\n  // All channels used, with range [0,256[\n  cv::Mat find(const cv::Mat& image) {\n\n    cv::Mat result;\n\n    hranges[0]= 0.0;   // default range [0,256[\n    hranges[1]= 256.0;\n    channels[0]= 0;    // the three channels \n    channels[1]= 1; \n    channels[2]= 2; \n\n    return find(image, hranges[0], hranges[1], channels);\n  }\n\n  // Finds the pixels belonging to the histogram\n  cv::Mat find(const cv::Mat& image, \n                float minValue, float maxValue, \n                int *channels) {\n\n    cv::Mat result;\n\n    hranges[0]= minValue;\n    hranges[1]= maxValue;\n\n    // histogram dim matches channel list\n    for (int i=0; i<histogram.dims; i++)\n        this->channels[i]= channels[i];\n\n    cv::calcBackProject(&image,\n            1,         // we only use one image at a time\n            channels,  // vector specifying what histogram \n            // dimensions belong to what image channels\n            histogram,    // the histogram we are using\n            result,       // the back projection image\n            ranges,       // the range of values, \n                          // for each dimension\n            255.0         // the scaling factor is chosen such \n            // that a histogram value of 1 maps to 255\n       );\n    }\n\n    // Threshold back projection to obtain a binary image\n    if (threshold>0.0)\n      cv::threshold(result, result, \n                255.0*threshold, 255.0, cv::THRESH_BINARY);\n\n    return result;\n  }\n```", "```py\n  // Load color image\n  ColorHistogram hc;\n  cv::Mat color= cv::imread(\"waves2.jpg\");\n\n  // extract region of interest\n  imageROI= color(cv::Rect(0,0,100,45)); // blue sky area\n\n  // Get 3D colour histogram (8 bins per channel)\n  hc.setSize(8); // 8x8x8\n  cv::Mat shist= hc.getHistogram(imageROI);\n```", "```py\n  // Create the content finder\n  ContentFinder finder;\n  // set histogram to be back-projected\n  finder.setHistogram(shist);\n  finder.setThreshold(0.05f);\n\n  // Get back-projection of color histogram\n  Cv::Mat result= finder.find(color);\n```", "```py\n   // Read reference image\n   cv::Mat image= cv::imread(\"baboon1.jpg\");\n   // Baboon's face ROI\n   cv::Mat imageROI= image(cv::Rect(110,260,35,40));\n   // Get the Hue histogram\n   int minSat=65;\n   ColorHistogram hc;\n   cv::Mat colorhist= \n            hc.getHueHistogram(imageROI,minSat);\n```", "```py\n  // Computes the 1D Hue histogram with a mask.\n  // BGR source image is converted to HSV\n  // Pixels with low saturation are ignored\n  cv::Mat getHueHistogram(const cv::Mat &image, \n                             int minSaturation=0) {\n\n    cv::Mat hist;\n\n    // Convert to HSV colour space\n    cv::Mat hsv;\n    cv::cvtColor(image, hsv, CV_BGR2HSV);\n\n    // Mask to be used (or not)\n    cv::Mat mask;\n\n    if (minSaturation>0) {\n\n      // Spliting the 3 channels into 3 images\n      std::vector<cv::Mat> v;\n      cv::split(hsv,v);\n\n      // Mask out the low saturated pixels\n      cv::threshold(v[1],mask,minSaturation,255,\n                                 cv::THRESH_BINARY);\n    }\n\n    // Prepare arguments for a 1D hue histogram\n    hranges[0]= 0.0;    // range is from 0 to 180\n    hranges[1]= 180.0;\n    channels[0]= 0;     // the hue channel \n\n    // Compute histogram\n    cv::calcHist(&hsv, \n      1,        // histogram of 1 image only\n      channels, // the channel used\n      mask,     // binary mask\n      hist,     // the resulting histogram\n      1,        // it is a 1D histogram\n      histSize, // number of bins\n      ranges    // pixel value range\n    );\n\n    return hist;\n  }\n```", "```py\n   ContentFinder finder;\n   finder.setHistogram(colorhist);\n```", "```py\n   image= cv::imread(\"baboon3.jpg\");\n   // Convert to HSV space\n   cv::cvtColor(image, hsv, CV_BGR2HSV);\n   // Get back-projection of hue histogram\n   int ch[1]={0};\n   finder.setThreshold(-1.0f); // no thresholding\n   cv::Mat result= finder.find(hsv,0.0f,180.0f,ch);\n```", "```py\n   // initial window position\n   cv::Rect rect(110,260,35,40);\n\n   // search object with mean shift\n   cv::TermCriteria criteria(cv::TermCriteria::MAX_ITER,\n                             10,0.01);\n   cv::meanShift(result,rect,criteria);\n```", "```py\nclass ImageComparator {\n\n  private:\n\n    cv::Mat refH;       // reference histogram\n    cv::Mat inputH;     // histogram of input image\n\n    ColorHistogram hist; // to generate the histograms\n    int nBins; // number of bins used in each color channel\n\n  public:\n\n    ImageComparator() :nBins(8) {\n\n  }\n```", "```py\n  // Set number of bins used when comparing the histograms\n  void setNumberOfBins( int bins) {\n\n    nBins= bins;\n  }\n```", "```py\n  // compute histogram of reference image\n  void setReferenceImage(const cv::Mat& image) {\n\n    hist.setSize(nBins);\n    refH= hist.getHistogram(image);\n  }\n```", "```py\n  // compare the images using their BGR histograms\n  double compare(const cv::Mat& image) {\n\n    inputH= hist.getHistogram(image);\n\n    return cv::compareHist(refH,inputH,CV_COMP_INTERSECT);\n  }\n```", "```py\n   ImageComparator c;\n   c.setReferenceImage(image);\n```", "```py\n  // Open image\n  cv::Mat image= cv::imread(\"bike55.bmp\",0);\n  // define image roi (here the girl on bike)\n  int xo=97, yo=112;\n  int width=25, height=30;\n  cv::Mat roi(image,cv::Rect(xo,yo,width,height));\n  // compute sum\n  // returns a Scalar to work with multi-channel images\n  cv::Scalar sum= cv::sum(roi);\n```", "```py\n  // compute integral image\n  cv::Mat integralImage;\n  cv::integral(image,integralImage,CV_32S);\n```", "```py\n  // get sum over an area using three additions/subtractions\n  int sumInt= integralImage.at<int>(yo+height,xo+width)\n            -integralImage.at<int>(yo+height,xo)\n            -integralImage.at<int>(yo,xo+width)\n            +integralImage.at<int>(yo,xo);\n```", "```py\n      // window at (xo,yo) of size width by height\n      return (integralImage.at<cv::Vec<T,N>>\n                                        (yo+height,xo+width)\n            -integralImage.at<cv::Vec<T,N>>(yo+height,xo)\n            -integralImage.at<cv::Vec<T,N>>(yo,xo+width)\n            +integralImage.at<cv::Vec<T,N>>(yo,xo));\n```", "```py\n  // using a fixed threshold \n  cv::Mat binaryFixed;\n  cv::threshold(image,binaryFixed,70,255,cv::THRESH_BINARY);\n```", "```py\n  // compute integral image\n  cv::Mat iimage;\n  cv::integral(image,iimage,CV_32S);\n```", "```py\n  int blockSize= 21; // size of the neighborhood\n  int threshold=10;  // pixel will be compared \n                      // to (mean-threshold)\n\n  // for each row\n  int halfSize= blockSize/2;\n    for (int j=halfSize; j<nl-halfSize-1; j++) {\n\n      // get the address of row j\n      uchar* data= binary.ptr<uchar>(j);\n      int* idata1= iimage.ptr<int>(j-halfSize);\n      int* idata2= iimage.ptr<int>(j+halfSize+1);\n\n      // for pixel of a line\n      for (int i=halfSize; i<nc-halfSize-1; i++) {\n\n        // compute sum\n        int sum= (idata2[i+halfSize+1]-\n                     idata2[i-halfSize]-\n                 idata1[i+halfSize+1]+\n                     idata1[i-halfSize])/\n                        (blockSize*blockSize);\n\n        // apply adaptive threshold\n        if (data[i]<(sum-threshold))\n          data[i]= 0;\n        else\n          data[i]=255;\n      }\n    }\n```", "```py\ncv::adaptiveThreshold(image,          // input image\n        binaryAdaptive,               // output binary image\n        255,                          // max value for output\n        cv::ADAPTIVE_THRESH_MEAN_C,   // method\n        cv::THRESH_BINARY,            // threshold type\n        blockSize,                    // size of the block\n        threshold);                   // threshold used\n```", "```py\n  cv::Mat filtered;\n  cv::Mat binaryFiltered;\n  cv::boxFilter(image,filtered,CV_8U,\n                 cv::Size(blockSize,blockSize));\n  filtered= filtered-threshold;\n  binaryFiltered= image>= filtered;\n```", "```py\n// convert to a multi-channel image made of binary planes\n// nPlanes must be a power of 2\nvoid convertToBinaryPlanes(const cv::Mat& input, \n                           cv::Mat& output, int nPlanes) {\n\n    // number of bits to mask out\n    int n= 8-static_cast<int>(\n      log(static_cast<double>(nPlanes))/log(2.0));\n    // mask used to eliminate least significant bits\n    uchar mask= 0xFF<<n; \n\n    // create a vector of binary images\n    std::vector<cv::Mat> planes;\n    // reduce to nBins by eliminating least significant bits\n    cv::Mat reduced= input&mask;\n\n    // compute each binary image plane\n    for (int i=0; i<nPlanes; i++) {\n      // 1 for each pixel equals to i<<shift\n      planes.push_back((reduced==(i<<n))&0x1);\n    }\n\n    // create multi-channel image\n    cv::merge(planes,output);\n}\n```", "```py\ntemplate <typename T, int N>\nclass IntegralImage {\n\n    cv::Mat integralImage;\n\n  public:\n\n    IntegralImage(cv::Mat image) {\n\n    // (costly) computation of the integral image\n    cv::integral(image,integralImage,cv::DataType<T>::type);\n    }\n\n    // compute sum over sub-regions of any size \n    // from 4 pixel accesses\n    cv::Vec<T,N> operator()(int xo, int yo, \n                             int width, int height) {\n\n    // window at (xo,yo) of size width by height\n    return (integralImage.at<cv::Vec<T,N>>\n                                       (yo+height,xo+width)\n        -integralImage.at<cv::Vec<T,N>>(yo+height,xo)\n        -integralImage.at<cv::Vec<T,N>>(yo,xo+width)\n        +integralImage.at<cv::Vec<T,N>>(yo,xo));\n    }\n\n};\n```", "```py\n  // histogram of 16 bins\n  Histogram1D h;\n  h.setNBins(16);\n  // compute histogram over image roi \n  cv::Mat refHistogram= h.getHistogram(roi);\n```", "```py\n  // first create 16-plane binary image\n  cv::Mat planes;\n  convertToBinaryPlanes(secondIimage,planes,16);\n  // then compute integral image\n  IntegralImage<float,16> intHistogram(planes);\n```", "```py\n  double maxSimilarity=0.0;\n  int xbest, ybest;\n  // loop over a horizontal strip around girl \n  // location in initial image\n  for (int y=110; y<120; y++) {\n    for (int x=0; x<secondImage.cols-width; x++) {\n\n      // compute histogram of 16 bins using integral image\n      histogram= intHistogram(x,y,width,height);\n      // compute distance with reference histogram\n      double distance= cv::compareHist(refHistogram, \n                                histogram, CV_COMP_INTERSECT);\n      // find position of most similar histogram\n      if (distance>maxSimilarity) {\n\n        xbest= x;\n        ybest= y;\n        maxSimilarity= distance;\n      }\n    }\n  }\n  // draw rectangle at best location\n  cv::rectangle(secondImage,\n                 cv::Rect(xbest,ybest,width,height),0));\n```"]