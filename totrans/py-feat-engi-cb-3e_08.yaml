- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Creating New Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新特征
- en: Adding new features to a dataset can help machine learning models learn patterns
    and important details in the data. For example, in finance, the **disposable income**,
    which is the *total income* minus the *acquired debt* for any one month, might
    be more relevant for credit risk than just the income or the acquired debt. Similarly,
    the *total acquired debt* of a person across financial products, such as a car
    loan, a mortgage, and credit cards, might be more important to estimate the credit
    risk than any debt considered individually. In these examples, we use domain knowledge
    to craft new variables, and these variables are created by adding or subtracting
    existing features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 向数据集中添加新特征可以帮助机器学习模型学习数据中的模式和重要细节。例如，在金融领域，**可支配收入**，即任何一个月的*总收入*减去*获得债务*，可能比仅仅的收入或获得债务对信用风险更为相关。同样，一个人在金融产品中的*总获得债务*，如车贷、房贷和信用卡，可能比单独考虑的任何债务对估计信用风险更为重要。在这些例子中，我们使用领域知识来构建新变量，这些变量是通过添加或减去现有特征创建的。
- en: In some cases, a variable may not have a linear or monotonic relationship with
    the target, but a polynomial combination might. For example, if our variable has
    a quadratic relationship with the target, ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>y</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow></mrow></math>](img/36.png),
    we can convert that into a linear relationship by squaring the original variable.
    We can also help linear models better understand the relationships between variables
    and targets by transforming the predictors through splines, or by using decision
    trees.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个变量可能没有与目标变量呈线性或单调关系，但多项式组合可能存在。例如，如果我们的变量与目标变量呈二次关系，![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>y</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow></mrow></math>](img/36.png)，我们可以通过平方原始变量将其转换为线性关系。我们还可以通过使用样条或决策树来转换预测变量，帮助线性模型更好地理解变量和目标之间的关系。
- en: The advantage of crafting additional features to train simpler models, such
    as linear or logistic regression, is that both the features and the models remain
    interpretable. We can explain the reasons driving a model’s output to management,
    clients, and regulators, adding a layer of transparency to our machine learning
    pipelines. In addition, simpler models tend to be faster to train and easier to
    deploy and maintain.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建额外的特征来训练更简单的模型，例如线性或逻辑回归，其优势在于特征和模型都保持可解释性。我们可以向管理层、客户和监管机构解释驱动模型输出的原因，为我们的机器学习流程增加一层透明度。此外，简单的模型往往训练速度更快，部署和维护也更容易。
- en: In this chapter, we will create new features by transforming or combining variables
    with mathematical functions, splines, and decision trees.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过变换或结合变量使用数学函数、样条和决策树来创建新特征。
- en: 'This chapter will cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Combining features with mathematical functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数学函数组合特征
- en: Comparing features to reference variables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将特征与参考变量进行比较
- en: Performing polynomial expansion
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行多项式展开
- en: Combining features with decision trees
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用决策树组合特征
- en: Creating periodic features from cyclical variables
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从周期性变量创建周期特征
- en: Creating spline features
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建样条特征
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will use the `pandas`, `numpy`, `matplotlib`, `scikit-learn`,
    and `feature-engine` Python libraries.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 `pandas`、`numpy`、`matplotlib`、`scikit-learn` 和 `feature-engine` 这些
    Python 库。
- en: Combining features with mathematical functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数学函数组合特征
- en: 'New features can be created by combining existing variables with mathematical
    and statistical functions. Taking an example from the finance industry, we can
    calculate the total debt of a person by summing up their debt across individual
    financial products, such as car loan, mortgage, or credit card debt:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合现有变量和数学及统计函数可以创建新特征。以金融行业为例，我们可以通过汇总个人在单个金融产品中的债务（如车贷、房贷或信用卡债务）来计算一个人的总债务：
- en: '*Total debt = car loan debt + credit card debt +* *mortgage debt*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*总债务 = 车贷债务 + 信用卡债务 + 房贷债务*'
- en: 'We can also derive other insightful features using alternative statistical
    operations. For example, we can determine the maximum debt of a customer across
    financial products or the average time a user spends on a website:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用其他统计操作推导出其他有洞察力的特征。例如，我们可以确定客户在金融产品中的最大债务或用户在网站上的平均停留时间：
- en: '*maximum debt = max(car loan balance, credit card balance,* *mortgage balance)*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*最大债务 = max(车贷余额, 信用卡余额, 按揭余额)*'
- en: '*average time on website = mean(time spent on homepage, time spent on about
    page, time spent on* *FAQ page)*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*网站平均停留时间 = mean(主页停留时间, 关于页面停留时间, FAQ 页面停留时间)*'
- en: We can, in principle, use any mathematical or statistical operation to create
    new features, such as the product, mean, standard deviation, or maximum or minimum
    values. In this recipe, we will implement these mathematical operations using
    `pandas` and `feature-engine`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在原则上，我们可以使用任何数学或统计运算来创建新的特征，例如乘积、平均值、标准差，或者最大或最小值。在这个食谱中，我们将使用 `pandas` 和 `feature-engine`
    来实现这些数学运算。
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While, in the recipe, we can show you how to combine features with mathematical
    functions, we can’t do justice to the use of domain knowledge in deciding which
    function to apply, as that varies with every domain. So, we will leave that with
    you.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然，在食谱中，我们可以向您展示如何使用数学函数组合特征，但我们无法公正地展示在决定应用哪个函数时领域知识的运用，因为每个领域都有所不同。所以，我们将这部分留给你。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the breast cancer dataset from `scikit-learn`. The
    features are computed from digitized images of breast cells and describe the characteristics
    of their cell nuclei, in terms of smoothness, concavity, symmetry, and compactness,
    among others. Each row contains information about the morphology of cell nuclei
    in a tissue sample. The target variable indicates whether the tissue sample corresponds
    to cancerous cells. The idea is to predict whether the tissue samples belong to
    benign or malignant breast cells, based on their cell nuclei morphology.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用来自 `scikit-learn` 的乳腺癌数据集。特征是通过乳腺细胞的数字化图像计算得出的，描述了细胞核的平滑度、凹陷度、对称性和紧凑度等特征。每一行包含关于组织样本中细胞核形态的信息。目标变量表示组织样本是否对应于癌细胞。目标是根据细胞核的形态预测组织样本属于良性还是恶性的乳腺细胞。
- en: 'To become familiar with the dataset, run the following commands in a Jupyter
    notebook or Python console:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉数据集，请在 Jupyter 笔记本或 Python 控制台中运行以下命令：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code block should print out a description of the dataset and an
    interpretation of its variables.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块应该打印出数据集的描述及其变量的解释。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we will create new features by combining variables using multiple
    mathematical operations:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将通过使用多个数学运算来组合变量来创建新的特征：
- en: 'Let’s begin by loading the necessary libraries, classes, and data:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先加载必要的库、类和数据：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, load the breast cancer dataset into a `pandas` DataFrame:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将乳腺癌数据集加载到 `pandas` DataFrame 中：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the following code lines, we will create new features by combining variables
    using multiple mathematical operations.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下代码行中，我们将通过使用多个数学运算来组合变量创建新的特征。
- en: 'Let’s begin by creating a list with the subset of the features that we want
    to combine:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建一个包含我们想要组合的特征子集的列表：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The features in *step 3* represent the mean characteristics of cell nuclei in
    the images. It might be useful to obtain the mean across all examined characteristics.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*步骤 3* 中的特征代表了图像中细胞核的平均特征。获取所有检查特征的均值可能是有用的。'
- en: 'Let’s get the mean value of the features and then display the resulting feature:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们计算特征的均值并显示结果特征：
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following output shows the mean value of the features from *step 3*:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的输出显示了 *步骤 3* 中特征的均值：
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Similarly, to capture the general variability of the cell nuclei, let’s determine
    the standard deviation of the mean characteristics, and then display the resulting
    feature:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，为了捕捉细胞核的一般变异性，让我们确定平均特征的标准差，然后显示结果特征：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following output shows the standard deviation of the features from step
    3:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的输出显示了 *步骤 3* 中特征的标准差：
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When we craft new features based on domain knowledge, we know exactly how we
    want to combine the variables. We could also combine features with multiple operations
    and then evaluate whether they are predictive, using, for example, a feature selection
    algorithm or deriving feature importance from the machine learning model.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们根据领域知识构建新的特征时，我们确切地知道我们想要如何组合变量。我们也可以通过多个运算组合特征，然后评估它们是否具有预测性，例如使用特征选择算法或从机器学习模型中推导特征重要性。
- en: 'Let’s make a list containing mathematical functions that we want to use to
    combine the features:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个包含我们想要使用的数学函数的列表来组合特征：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s apply the functions from *step 6* to combine the features from *step
    3*, capturing the resulting variables in a new DataFrame:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们应用 *步骤 6* 中的函数来组合 *步骤 3* 中的特征，将结果变量捕获到一个新的 DataFrame 中：
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we execute `df_t.head()`, we will see the DataFrame with the newly created
    features:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们执行 `df_t.head()`，我们将看到包含新创建特征的 DataFrame：
- en: '![Figure 8.1 – A DataFrame with the newly created features](img/B22396_08_1.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 包含新创建特征的 DataFrame](img/B22396_08_1.jpg)'
- en: Figure 8.1 – A DataFrame with the newly created features
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 包含新创建特征的 DataFrame
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`pandas` `agg` can apply multiple functions to combine features. It can take
    a list of strings with the function names, as we did in *step 7*; a list of NumPy
    functions, such as `np.log`; and Python functions that you create.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas` 的 `agg` 函数可以应用多个函数来组合特征。它可以接受一个包含函数名称的字符串列表，就像我们在 *步骤 7* 中做的那样；一个包含
    NumPy 函数（如 `np.log`）的列表；以及你创建的 Python 函数。'
- en: We can create the same features that we created with `pandas` automatically
    by using `feature-engine`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `feature-engine` 自动创建与使用 `pandas` 创建的相同特征。
- en: 'Let’s create a list by using the name of the output features:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用输出特征的名称创建一个列表：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s set up `MathFeatures()` to apply the functions in *step 6* to the features
    from *step 3*, naming the new features with the strings from *step 8*:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置 `MathFeatures()` 来将 *步骤 6* 中的函数应用于 *步骤 3* 中的特征，使用 *步骤 8* 中的字符串来命名新特征：
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s add the new features to the original DataFrame, capturing the result
    in a new variable:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将新特征添加到原始 DataFrame 中，将结果捕获到一个新变量中：
- en: '[PRE12]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can display the input and output features by executing `df_t[features +`
    `new_feature_names].head()`:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过执行 `df_t[features + new_feature_names].head()` 来显示输入和输出特征：
- en: '![Figure 8.2 – DataFrame with the input features and the newly created variables](img/B22396_08_2.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 包含输入特征和新创建变量的 DataFrame](img/B22396_08_2.jpg)'
- en: Figure 8.2 – DataFrame with the input features and the newly created variables
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 包含输入特征和新创建变量的 DataFrame
- en: While `pandas` `agg` returns a DataFrame with the features resulting from the
    operation, `feature-engine` goes one step further, by concatenating the new features
    to the original DataFrame.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `pandas` 的 `agg` 函数返回一个包含操作结果的 DataFrame，但 `feature-engine` 会更进一步，通过将新特征连接到原始
    DataFrame 上。
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`pandas` has many built-in operations to apply mathematical and statistical
    computations to a group of variables. To combine features mathematically, we first
    made a list containing the names of the features we wanted to combine. Then, we
    determined the mean and standard deviation of those features by using `pandas`
    `mean()` and `std()`. We could also apply any of the `sum()`, `prod()`, `max()`,
    and `min()` methods, which return the sum, product, maximum, and minimum values
    of those features, respectively. To perform these operations across the columns,
    we added the `axis=1` argument within the methods.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas` 有许多内置操作，可以将数学和统计计算应用于一组变量。为了在数学上组合特征，我们首先创建了一个包含我们想要组合的特征名称的列表。然后，我们使用
    `pandas` 的 `mean()` 和 `std()` 函数确定了这些特征的平均值和标准差。我们还可以应用 `sum()`、`prod()`、`max()`
    和 `min()` 方法中的任何一个，这些方法分别返回这些特征的总和、乘积、最大值和最小值。为了在列上执行这些操作，我们在方法中添加了 `axis=1` 参数。'
- en: With pandas `agg()`, we applied several mathematical functions simultaneously.
    It takes as arguments a list of strings, corresponding to the functions to apply
    and the `axis` that the functions should be applied to, which can be either `1`
    for columns or `0` for rows. As a result, pandas `agg()` returned a `pandas` DataFrame,
    resulting from applying the mathematical functions to the groups of features.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pandas 的 `agg()` 函数，我们可以同时应用多个数学函数。它接受一个字符串列表作为参数，对应于要应用的功能和函数应该应用的 `axis`，可以是
    `1`（列）或 `0`（行）。因此，pandas 的 `agg()` 函数返回一个应用数学函数到特征组的 `pandas` DataFrame。
- en: Finally, we created the same features by combining variables with `feature-engine`.
    We used the `MathFeatures()` transformer, which takes the features to combine
    and the functions to apply as input; it also has the option to indicate the names
    of the resulting features. When we used `fit()`, the transformer did not learn
    parameters but checked that the variables were indeed numerical. The `transform()`
    method triggered the use of `pandas.agg` under the hood, applying the mathematical
    functions to create the new variables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过结合变量和使用 `feature-engine` 创建了相同的特征。我们使用了 `MathFeatures()` 转换器，它接受要组合的特征和要应用的功能作为输入；它还提供了指示结果特征名称的选项。当我们使用
    `fit()` 时，转换器没有学习参数，而是检查变量确实是数值的。`transform()` 方法触发了底层使用 `pandas.agg`，应用数学函数来创建新的变量。
- en: See also
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To find out more about the mathematical operations supported by `pandas`, visit
    [https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#computations-descriptive-stats](https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#computations-descriptive-stats).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `pandas` 支持的数学运算，请访问 [https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#computations-descriptive-stats](https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#computations-descriptive-stats)。
- en: To learn more about `pandas` `aggregate`, check out [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.aggregate.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.aggregate.html).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `pandas` `aggregate` 的信息，请查看 [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.aggregate.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.aggregate.html)。
- en: Comparing features to reference variables
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较特征与参考变量
- en: 'In the previous recipe, *Combining features with mathematical functions*, we
    created new features by applying mathematical or statistical functions, such as
    the sum or the mean, to a group of variables. Some mathematical operations, however,
    such as subtraction or division, are performed *between* features. These operations
    are useful to derive ratios, such as the *debt-to-income ratio*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱 *使用数学函数组合特征* 中，我们通过将数学或统计函数（如总和或平均值）应用于一组变量来创建新特征。然而，一些数学运算（如减法或除法）是在特征之间进行的。这些操作对于推导比率（如
    *负债收入比*）很有用：
- en: '*debt-to-income ratio = total debt /* *total income*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*负债收入比 = 总负债 /* *总收入* '
- en: 'These operations are also useful to compute differences, such as the *disposable
    income*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作也有助于计算差异，例如 *可支配收入*：
- en: '*disposable income = income -* *total debt*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*可支配收入 = 收入 - 总负债*'
- en: In this recipe, we will learn how to create new features by subtracting or dividing
    variables with `pandas` and `feature-engine`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何通过使用 `pandas` 和 `feature-engine` 对变量进行减法或除法来创建新特征。
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the recipe, we will show you how to create features with subtraction and
    division. We hope that the examples, relating to the financial sector, shed some
    light on how to use domain knowledge to decide which features to combine and how.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将向您展示如何通过减法和除法创建特征。我们希望这些与金融部门相关的例子能对如何使用领域知识来决定要组合哪些特征以及如何进行一些启发。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s begin by loading the necessary Python libraries and the breast cancer
    dataset from scikit-learn:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先加载必要的 Python 库和来自 scikit-learn 的乳腺癌数据集：
- en: 'Load the necessary libraries, classes, and data:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载必要的库、类和数据：
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Load the breast cancer dataset into a `pandas` DataFrame:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将乳腺癌数据集加载到 `pandas` DataFrame 中：
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the breast cancer dataset, some features capture the worst and the mean characteristics
    of the cell nuclei of breast cells. For example, for each image (that is, for
    each row), we have the worst compactness observed in all nuclei and the mean compactness
    of all nuclei. A feature that captures the difference between the worst and the
    mean value could predict malignancy.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在乳腺癌数据集中，一些特征捕捉了乳腺细胞细胞核的最差和平均特征。例如，对于每个图像（即每行），我们都有观察到的所有核的最差紧密度和所有核的平均紧密度。一个捕捉最差值和平均值之间差异的特征可以预测恶性。
- en: 'Let’s capture the difference between two features, the `worst compactness`
    and `mean compactness` of cell nuclei, in a new variable and display its values:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们捕捉两个特征之间的差异，即细胞核的 `最差紧密度` 和 `平均紧密度`，并将它们存储在一个新变量中并显示其值：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the following output, we can see the difference between these feature values:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到这些特征值之间的差异：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We can perform the same calculation by executing `df["difference"] = df["worst
    compactness"] - (``df["mean compactness"])`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行 `df["difference"] = df["worst compactness"] - (``df["mean compactness"])`
    来进行相同的计算。
- en: Similarly, the ratio between the worst and the average characteristic of the
    cell nuclei might be indicative of malignancy.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，细胞核最坏和平均特征之间的比率可能表明恶性。
- en: 'Let’s create a new feature with the ratio between the worst and mean radius
    of the nuclei, and then display its values:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新特征，该特征是核的最坏和平均半径之间的比率，然后显示其值：
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the following output, we can see the values corresponding to the ratio between
    the features:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到特征之间的比率值：
- en: '[PRE18]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We can calculate the ratio by executing an alternative command, `df["quotient"]
    = df["worst radius"] / (``df["mean radius"])`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行一个替代命令来计算比率，`df["quotient"] = df["worst radius"] / (``df["mean radius"])`。
- en: We can also capture the ratio and difference between every nuclei morphology
    characteristic and the mean radius or mean area of the nuclei. Let’s begin by
    capturing these subsets of variables into lists.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以捕获每个核形态特征与核的平均半径或平均面积之间的比率。让我们首先将这些变量的子集捕获到列表中。
- en: 'Let’s make a list of the features in the numerator:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们列出分子中的特征：
- en: '[PRE19]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s make a list of the features in the denominator:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们列出分母中的特征：
- en: '[PRE20]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We can create features by dividing the features in *step 5* by one of the features
    in *step 6* with `pandas`, by executing `df[features].div(df["mean radius"])`.
    For subtraction, we’d execute `df[features].sub(df["mean radius"])`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `pandas` 中将 *步骤 5* 中的特征除以 *步骤 6* 中的某个特征来创建特征，通过执行 `df[features].div(df["mean
    radius"])`。对于减法，我们将执行 `df[features].sub(df["mean radius"])`。
- en: 'Let’s set up the `feature-engine` library’s `RelativeFeatures()` so that it
    subtracts or divides every feature from *step 5* with respect to the features
    from *step 6*:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置 `feature-engine` 库的 `RelativeFeatures()`，使其从 *步骤 5* 的每个特征中减去或除以 *步骤 6*
    的特征：
- en: '[PRE21]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Subtracting the features from *step 5* and *step 6* does not make biological
    sense, but we will do it anyway to demonstrate the use of the `RelativeFeatures()`
    transformer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *步骤 5* 和 *步骤 6* 中减去特征在生物学上没有意义，但我们将这样做以演示 `RelativeFeatures()` 转换器的使用。
- en: 'Let’s add the new features to the DataFrame and capture the result in a new
    variable:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将新特征添加到 DataFrame 中，并将结果捕获在一个新变量中：
- en: '[PRE22]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s capture the names of the new features in a list:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将新特征的名称捕获到一个列表中：
- en: '[PRE23]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`feature_names_in_` is a common attribute in `scikit-learn` and `feature-engine`
    transformers and stores the name of the variables from the DataFrame used to fit
    the transformer. In other words, it stores the names of the input features. When
    using `transform()`, the transformers check that the features from the new input
    dataset match those used during training. In *step 9*, we leverage this attribute
    to find the additional variables added to the data after the transformation.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`feature_names_in_` 是 `scikit-learn` 和 `feature-engine` 转换器中的一个常见属性，它存储用于拟合转换器的
    DataFrame 中的变量名称。换句话说，它存储了输入特征的名称。当使用 `transform()` 时，转换器会检查新输入数据集中的特征是否与训练期间使用的特征匹配。在
    *步骤 9* 中，我们利用这个属性来查找在转换后添加到数据中的额外变量。'
- en: 'If we execute `print(new_features)`, we will see a list with the names of the
    features created by `ReferenceFeatures()`. Note that the features contain the
    variables on the left- and right-hand sides of the mathematical equation, plus
    the function that was applied to them to create the new feature:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行 `print(new_features)`，我们将看到一个包含由 `ReferenceFeatures()` 创建的特征名称的列表。请注意，这些特征包含数学方程式左侧和右侧的变量，以及应用于它们的函数以创建新特征：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we can display the first five rows of the resulting variables by executing
    `df_t[new_features].head()`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过执行 `df_t[new_features].head()` 来显示结果变量的前五行：
- en: '![Figure 8.3 – A DataFrame with the newly created features](img/B22396_08_3.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 包含新创建特征的 DataFrame](img/B22396_08_3.jpg)'
- en: Figure 8.3 – A DataFrame with the newly created features
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 包含新创建特征的 DataFrame
- en: '`feature-engine` adds new features as columns at the right of the original
    DataFrame and automatically adds variable names to those features. By doing so,
    `feature-engine` automates much of the manual work that we would do with `pandas`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`feature-engine` 将新特征作为原始 DataFrame 右侧的列添加，并自动将这些特征的变量名添加到其中。通过这样做，`feature-engine`
    自动化了我们本应使用 `pandas` 做的大量手动工作。'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`pandas` has many built-in operations to compare a feature or a group of features
    to a reference variable. In this recipe, we used pandas `sub()` and `div()` to
    determine the difference or the ratio between two variables, or a subset of variables
    and one reference feature.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`有许多内置操作来比较一个特征或一组特征与一个参考变量。在这个菜谱中，我们使用了pandas的`sub()`和`div()`函数来确定两个变量或一组变量与一个参考特征之间的差异或比率。'
- en: To subtract one variable from another, we applied `sub()` to a `pandas` series
    with the first variable, passing the `pandas` series with the second variable
    as an argument to `sub()`. This operation returned a third `pandas` series with
    the difference between the first and second variables. To divide one variable
    from another, we used `div()`, which works identically to `sub()` – that is, it
    divides the variable on the left by the variable passed as an argument of `div()`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个变量中减去另一个变量，我们对第一个变量应用了`sub()`函数到一个`pandas`序列上，将第二个变量的`pandas`序列作为参数传递给`sub()`函数。这个操作返回了一个第三个`pandas`序列，包含第一个和第二个变量之间的差值。要除以另一个变量，我们使用了`div()`函数，它的工作方式与`sub()`相同——即，它将左侧的变量除以`div()`函数作为参数传递的变量。
- en: Then, we combined several variables with two reference variables automatically
    via subtraction or division, by utilizing `ReferenceFeatures()` from `Feature-engine`.
    The `ReferenceFeatures()` transformer takes the variables to be combined, the
    reference variables, and the functions to use to combine them. When using `fit()`,
    the transformer did not learn about parameters but checked that the variables
    were numerical. Executing `transform()` added the new features to the DataFrame.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过使用`Feature-engine`的`ReferenceFeatures()`函数，自动将几个变量与两个参考变量通过减法或除法组合起来。`ReferenceFeatures()`转换器接受要组合的变量、参考变量以及用于组合它们的函数。当使用`fit()`时，转换器不会学习参数，而是检查变量是否为数值。执行`transform()`会将新特征添加到DataFrame中。
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`ReferenceFeatures()` can also add, multiply, get the modulo, or get the power
    of a group of variables relating to a second group of reference variables. You
    can find out more in its documentation: [https://feature-engine.readthedocs.io/en/latest/api_doc/creation/RelativeFeatures.html](https://feature-engine.readthedocs.io/en/latest/api_doc/creation/RelativeFeatures.html).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReferenceFeatures()`还可以为与第二组参考变量相关的一组变量添加、乘法、取模或求幂。您可以在其文档中了解更多信息：[https://feature-engine.readthedocs.io/en/latest/api_doc/creation/RelativeFeatures.html](https://feature-engine.readthedocs.io/en/latest/api_doc/creation/RelativeFeatures.html)。'
- en: See also
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more about the binary operations supported by `pandas`, visit [https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#binary-operator-functions](https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#binary-operator-functions).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`pandas`支持的二进制操作，请访问[https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#binary-operator-functions](https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#binary-operator-functions)。
- en: Performing polynomial expansion
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行多项式展开
- en: 'Simple models, such as linear and logistic regression, can capture complex
    patterns if we feed them the right features. Sometimes, we can create powerful
    features by combining the variables in our datasets with themselves or with other
    variables. For example, in the following figure, we can see that the target, *y*,
    has a quadratic relation with the variable, *x*, and as shown in the left panel,
    a linear model is not able to capture that relationship accurately:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 简单模型，如线性回归和逻辑回归，如果我们向它们提供正确的特征，可以捕捉到复杂的模式。有时，我们可以通过将数据集中的变量与自身或其他变量组合来创建强大的特征。例如，在下面的图中，我们可以看到目标*y*与变量*x*有二次关系，如图左侧面板所示，线性模型无法准确捕捉这种关系：
- en: "![Figure 8.4 – A linear model fit to predict a target, y, from a feature, x,\
    \ which has a quadratic relationship to the target, before and after squaring\
    \ x. In the left panel: the model offers a poor fit by using the original variable;\
    \ in the right panel, the model offers a better fit, based on the squar\uFEFF\
    e of the original variable](img/B22396_08_4.jpg)"
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 一个线性模型拟合预测目标y，从特征x，x与目标有二次关系，在平方x之前和之后。在左侧面板：模型使用原始变量提供较差的拟合；在右侧面板，模型基于原始变量的平方提供更好的拟合](img/B22396_08_4.jpg)'
- en: 'Figure 8.4 – A linear model fit to predict a target, y, from a feature, x,
    which has a quadratic relationship to the target, before and after squaring x.
    In the left panel: the model offers a poor fit by using the original variable;
    in the right panel, the model offers a better fit, based on the square of the
    original variable'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 一个线性模型拟合以预测目标，y，从特征，x，该特征与目标之间存在二次关系，在平方x之前和之后。在左侧面板：模型通过使用原始变量提供较差的拟合；在右侧面板，模型基于原始变量的平方提供更好的拟合
- en: This linear model has a quadratic relationship to the target, before and after
    squaring *x*. However, if we square *x*, or, in other words, if we create a second-degree
    polynomial of the feature, the linear model can accurately predict the target,
    *y*, from the square of *x*, as we see in the right panel.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此线性模型在平方*x*之前和之后都与目标存在二次关系。然而，如果我们平方*x*，换句话说，如果我们创建特征的二次多项式，线性模型可以准确地从*x*的平方预测目标*y*，正如我们在右侧面板中看到的那样。
- en: 'Another classical example in which a simple feature can make a simple model,
    such as logistic regression, understand the underlying relationship in the data
    is the **XOR** situation. In the left panel of the following diagram, we see how
    the target class is distributed across the values of *x1* and *x2* (the class
    is highlighted with different color shades):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个经典例子是，一个简单的特征可以使一个简单的模型，如逻辑回归，理解数据中的潜在关系，这就是**XOR**情况。在以下图表的左侧面板中，我们看到目标类别是如何分布在*x1*和*x2*的值上的（类别用不同的颜色阴影突出显示）：
- en: '![Figure 8.5 – An illustration of the XOR relationship and how combining features
    allows a full class separation](img/B22396_08_5.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – XOR关系的插图以及如何通过组合特征实现完整的类别分离](img/B22396_08_5.jpg)'
- en: Figure 8.5 – An illustration of the XOR relationship and how combining features
    allows a full class separation
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – XOR关系的插图以及如何通过组合特征实现完整的类别分离
- en: If both features are positive, or both features are negative, then the class
    is 1, but if the features take different signs, then the class is 0 (left panel).
    Logistic regression will not be able to pick this pattern from each individual
    feature because, as we can see in the middle panel, there is significant class
    overlap across the values of the feature – in this case, x1\. However, multiplying
    x1 by x2 creates a feature that allows a logistic regression to predict the classes
    accurately because x3, as can we see in the right panel, allows the classes to
    be clearly separated.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个特征都是正的，或者两个特征都是负的，那么类别是1，但如果特征具有不同的符号，那么类别是0（左侧面板）。逻辑回归将无法从每个单独的特征中识别出这种模式，因为我们可以在中间面板中看到，特征值之间存在显著的类别重叠
    – 在这种情况下，x1。然而，将x1乘以x2创建了一个特征，这使得逻辑回归能够准确地预测类别，因为x3，正如我们在右侧面板中看到的那样，允许类别被清楚地分离。
- en: With similar logic, polynomial combinations of the same or different variables
    can return new variables that convey additional information and capture feature
    interaction thereby resulting in useful inputs for linear models. With huge datasets,
    analyzing every possible variable combination is not always possible. But we can
    create several polynomial variables automatically, using, for example, `scikit-learn`,
    and we can let the model decide which variables are useful. In this recipe, we
    will learn how to create multiple features through polynomial combinations using
    scikit-learn.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似的逻辑，相同或不同变量的多项式组合可以返回新的变量，这些变量传达了额外的信息并捕捉了特征交互，从而为线性模型提供了有用的输入。在大型数据集中，分析每个可能的变量组合并不总是可能的。但我们可以使用例如`scikit-learn`自动创建多个多项式变量，并让模型决定哪些变量是有用的。在本菜谱中，我们将学习如何使用scikit-learn通过多项式组合创建多个特征。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Polynomial expansion serves to automate the creation of new features, capture
    feature interaction, and potential non-linear relationships between the original
    variables and the target. To create polynomial features, we need to determine
    which features to combine and which polynomial degree to use.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式展开用于自动化新特征的创建，捕捉特征交互，以及原始变量与目标之间的潜在非线性关系。要创建多项式特征，我们需要确定哪些特征要组合以及使用哪个多项式度数。
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While determining the features to combine or the degree of the polynomial combination
    is not an easy task, keep in mind that high polynomial degrees will result in
    a lot of new features and may lead to overfitting. In general, we keep the degree
    low, to a maximum of 2 or 3.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定要组合的特征或多项式组合的次数并不容易，记住高次多项式将导致大量新特征的生成，可能会导致过拟合。一般来说，我们保持次数较低，最多为2或3。
- en: The `PolynomialFeatures()` transformer from `scikit-learn` creates polynomial
    combinations of the features with a degree less than or equal to a user-specified
    degree, automatically.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`scikit-learn`中的`PolynomialFeatures()`转换器会自动创建特征的多项式组合，其次数小于或等于用户指定的次数。'
- en: To follow up easily with this recipe, let’s first understand the output of `PolynomialFeatures()`
    when used to create second- and third-degree polynomial combinations of three
    variables.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了轻松跟进这个配方，让我们首先了解当使用`PolynomialFeatures()`创建三个变量的二次和三次多项式组合时的输出。
- en: 'Second-degree polynomial combinations of three variables – *a*, *b*, and *c*
    – will return the following new features:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 三个变量（*a*，*b*，*c*）的二次多项式组合将返回以下新特征：
- en: '*1, a, b, c, ab, ac, bc, a2,* *b2, c2*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*1, a, b, c, ab, ac, bc, a2, b2, c2*'
- en: From the previous features, *a*, *b*, and *c* are the original variables; *ab*,
    *ac*, and *bc* are the products of those features; and *a2*, *b2*, and *c2* are
    the squared values of the original features. `PolynomialFeatures()` also returns
    the bias term *1*, which we would probably exclude when creating features.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的特征来看，*a*，*b*，*c*是原始变量；*ab*，*ac*，*bc*是这些特征的乘积；而*a2*，*b2*，*c2*是原始特征的平方值。`PolynomialFeatures()`还会返回一个偏置项*1*，在创建特征时我们可能不会包含它。
- en: Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting features – *ab*, *ac*, and *bc* – are called **interactions**
    or feature interactions of **degree 2**. The degree reflects the number of variables
    combined. The result combines a maximum of two variables because we indicated
    a second-degree polynomial as the maximum allowed combination.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 生成特征——*ab*，*ac*，和*bc*——被称为**交互**或**2度**的特征交互。度数反映了组合的变量数量。结果组合了最多两个变量，因为我们指定了二次多项式为允许的最大组合。
- en: 'Third-degree polynomial combinations of the three variables – *a*, *b*, and
    *c* – will return the following new features:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 三个变量（*a*，*b*，*c*）的三次多项式组合将返回以下新特征：
- en: '*1, a, b, c, ab, ac, bc, abc, a2b, a2c, b2a, b2c, c2a, c2b, a3,* *b3, c3*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*1, a, b, c, ab, ac, bc, abc, a2b, a2c, b2a, b2c, c2a, c2b, a3, b3, c3*'
- en: Among the returned features, in addition to those returned by the second-degree
    polynomial combination, we now have the third-degree combinations of the features
    with themselves (*a3*, *b3*, and *c3*), the squared values of every feature combined
    linearly with a second feature (*a2b*, *a2c*, *b2a*, *b2c*, *c2a*, and *c2b*),
    and the product of the three features (*abc*). Note how we have all possible interactions
    of degrees 1, 2, and 3 and the bias term *1*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回的特征中，除了二次多项式组合返回的特征外，我们现在还有特征自身的三次组合（*a3*，*b3*，和*c3*），每个特征与第二个特征线性组合的平方值（*a2b*，*a2c*，*b2a*，*b2c*，*c2a*，和*c2b*），以及三个特征的乘积（*abc*）。注意我们包含了所有可能的1度、2度和3度交互以及偏置项*1*。
- en: Now that we understand the output of the polynomial expansion implemented by
    `scikit-learn`, let’s jump into the recipe.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`scikit-learn`实现的多项式展开的输出，让我们进入配方。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we will create features with polynomial expansion using a toy
    dataset to become familiar with the resulting variables. Creating features with
    the polynomial expansion of a real dataset is identical to what we will discuss
    in this recipe:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用一个玩具数据集通过多项式展开来创建特征，以便熟悉生成的变量。使用真实数据集的多项式展开创建特征与我们在本配方中将要讨论的相同：
- en: 'Let’s import the required libraries, classes, and data:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入所需的库、类和数据：
- en: '[PRE25]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s set `scikit-learn` library’s `set_output` API globally so that all transformers
    return a DataFrame as a result of the `transform()` method:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置`scikit-learn`库的`set_output` API全局，以便所有转换器在`transform()`方法的输出结果中返回一个DataFrame：
- en: '[PRE26]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s create a DataFrame containing one variable, with values from 1 to 10:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个包含一个变量的DataFrame，其值为1到10：
- en: '[PRE27]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s set up `PolynomialFeatures()` to create all possible combinations up
    to a third-degree polynomial of the single variable and exclude the bias term
    from the result – that is, we will exclude the value *1*:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置`PolynomialFeatures()`以创建单变量的所有可能组合，直到三次多项式，并从结果中排除偏置项——也就是说，我们将排除值*1*：
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let’s create the polynomial combinations:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建多项式组合：
- en: '[PRE29]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we execute `dft`, we’ll see a DataFrame with the original feature, followed
    by its values squared, and then its values to the power of three:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们执行 `dft`，我们将看到一个包含原始特征的DataFrame，其后是其值的平方，然后是其值的立方：
- en: '![Figure 8.6 – A DataFrame with the polynomial expansion of the third degree
    of a single variable](img/B22396_08_6.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 单个变量的三次多项式展开的DataFrame](img/B22396_08_6.jpg)'
- en: Figure 8.6 – A DataFrame with the polynomial expansion of the third degree of
    a single variable
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 单个变量的三次多项式展开的DataFrame
- en: If, instead of returning a DataFrame, `PolynomialFeatures()` returns a NumPy
    array and you want to obtain the names of the features in the array, you can do
    so by executing `poly.get_feature_names_out()`, which returns `array(['var', 'var^2',
    '``var^3'], dtype=object)`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `PolynomialFeatures()` 返回一个NumPy数组而不是DataFrame，并且你想获得数组中特征的名称，你可以通过执行 `poly.get_feature_names_out()`
    来实现，它返回 `array(['var', 'var^2', 'var^3'], dtype=object)`。
- en: 'Now, let’s plot the new feature values against the original variable:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将新的特征值与原始变量进行绘图：
- en: '[PRE30]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the following diagram, we can see the relationship between the polynomial
    features and the original variable:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下图中，我们可以看到多项式特征与原始变量之间的关系：
- en: '![Figure 8.7 – The relationship between the features resulting from polynomial
    expansion and the original variable](img/B22396_08_7.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 多项式展开产生的特征与原始变量之间的关系](img/B22396_08_7.jpg)'
- en: Figure 8.7 – The relationship between the features resulting from polynomial
    expansion and the original variable
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 多项式展开产生的特征与原始变量之间的关系
- en: 'Let’s add two additional variables to our toy dataset, with values from 1 to
    10:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在玩具数据集中添加两个额外的变量，其值从1到10：
- en: '[PRE31]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, let’s combine the three features in the dataset with polynomial expansion
    up to the second degree, but this time, we will only return features produced
    by combining at least two different variables – that is, the interaction features:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将数据集中的三个特征与多项式展开到二次方，但这次，我们只返回由至少两个不同变量组合产生的特征，即交互特征：
- en: '[PRE32]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we execute `dft`, we will see the features resulting from the polynomial
    expansion, which contain the original features, plus all possible combinations
    of the three variables but without the quadratic terms, as we set the transformer
    to return only the interaction between features:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们执行 `dft`，我们将看到多项式展开产生的特征，这些特征包含原始特征，以及三个变量的所有可能组合，但没有二次项，因为我们设置转换器只返回特征之间的交互：
- en: "![Figure 8.8 – A DataFrame with the result of creating features with polynomial\
    \ expansion but retaining only the interactio\uFEFFn between variables](img/B22396_08_8.jpg)"
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 – 使用多项式展开创建特征的结果，仅保留变量之间的交互](img/B22396_08_8.jpg)'
- en: Figure 8.8 – A DataFrame with the result of creating features with polynomial
    expansion but retaining only the interaction between variables
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 使用多项式展开创建特征的结果，仅保留变量之间的交互
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Go ahead and create third-degree polynomial combinations of the features, returning
    only the interactions or all possible features to get a better sense of the output
    of `PolynomialFeatures()`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建特征的第三次方多项式组合，只返回交互或所有可能特征，以更好地理解 `PolynomialFeatures()` 的输出。
- en: With that, we’ve learned how to create new features by combining existing variables
    with themselves or other features in data. Creating features via polynomial expansion
    using a real dataset is, in essence, identical.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学会了如何通过将现有变量与自身或其他特征结合来创建新特征。使用真实数据集通过多项式展开创建特征在本质上是一致的。
- en: 'If you want to combine only a subset of features, you can select the features
    to combine by utilizing `ColumnTransformer()`, as we will demonstrate in the *There’s
    more…* section ahead in this recipe, or by using `SklearnTransformerWrapper()`
    from `feature-engine`, as you can see in the accompanying GitHub repository: [https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch08-creation/Recipe3-PolynomialExpansion.ipynb](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch08-creation/Recipe3-PolynomialExpansion.ipynb).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想组合特征的一个子集，你可以通过使用`ColumnTransformer()`来选择要组合的特征，就像我们在本食谱后面的“还有更多...”部分中将要展示的那样，或者通过使用来自`feature-engine`的`SklearnTransformerWrapper()`，正如你在附带的GitHub仓库中可以看到的那样：[https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch08-creation/Recipe3-PolynomialExpansion.ipynb](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch08-creation/Recipe3-PolynomialExpansion.ipynb)。
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created features by using polynomial combinations of a feature
    with itself or among three variables. To create these polynomial features, we
    used `PolynomialFeatures()` from `scikit-learn`. By default, `PolynomialFeatures()`
    generates a new feature matrix consisting of all polynomial combinations of the
    features in the data, with a degree less than or equal to the user-specified `degree`.
    By setting `degree` to `3`, we created all possible polynomial combinations of
    a degree of 3 or smaller. To retain the combination of a feature with itself,
    we set the `interaction_only` parameter to `False`. To avoid returning the bias
    term, we set the `include_bias` parameter to `False`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们通过使用特征与其自身或三个变量之间的多项式组合来创建特征。为了创建这些多项式特征，我们使用了`scikit-learn`中的`PolynomialFeatures()`。默认情况下，`PolynomialFeatures()`生成一个新的特征矩阵，该矩阵包含数据中所有特征的所有多项式组合，其度数小于或等于用户指定的`degree`。通过将`degree`设置为`3`，我们创建了所有可能的三次或更小的多项式组合。为了保留特征与其自身的组合，我们将`interaction_only`参数设置为`False`。为了避免返回偏差项，我们将`include_bias`参数设置为`False`。
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Setting the `interaction_only` parameter to `True` returns the interaction terms
    only – that is, the variables resulting from combinations of two or more variables.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将`interaction_only`参数设置为`True`仅返回交互项 – 即由两个或更多变量的组合产生的变量。
- en: The `fit()` method determined all of the possible feature combinations based
    on the parameters specified. At this stage, the transformer did not perform actual
    mathematical computations. The `transform()` method performed the mathematical
    computations with the features to create the new variables. With the `get_feature_names()`
    method, we could identify the terms of the expansion – that is, how each new feature
    was calculated.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`fit()`方法根据指定的参数确定了所有可能的特征组合。在这个阶段，转换器没有执行实际的数学计算。`transform()`方法使用特征执行数学计算以创建新的变量。通过`get_feature_names()`方法，我们可以识别展开的项
    – 即每个新特征是如何计算的。'
- en: In *step 2*, we set `scikit-learn` library’s `set_output` API `pandas` DataFrames
    as a result of the `transform()` method. scikit-learn transformers return `NumPy`
    arrays by default. The new `set_output` API allows us to change the container
    of the result to a `pandas` or a `polars` DataFrame. We can set the output individually
    every time we set up a transformer – for example, by using `poly = PolynomialFeatures().set_output(transform="pandas")`.
    Alternatively, as we did in this recipe, we can set the global configuration,
    and then every time we set up a new transformer, it will return a `pandas` DataFrame.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 2**中，我们将`scikit-learn`库的`set_output` API的`pandas` DataFrame设置为`transform()`方法的结果。scikit-learn转换器默认返回`NumPy`数组。新的`set_output`
    API允许我们将结果容器的类型更改为`pandas`或`polars` DataFrame。每次设置转换器时，我们都可以单独设置输出 – 例如，使用`poly
    = PolynomialFeatures().set_output(transform="pandas")`。或者，就像在这个食谱中做的那样，我们可以设置全局配置，然后每次设置新的转换器时，它将返回一个`pandas`
    DataFrame。
- en: There’s more...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let’s create features by performing polynomial expansion on a subset of variables
    in the breast cancer dataset:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在乳腺癌数据集的变量子集上执行多项式展开来创建特征：
- en: 'First, import the necessary libraries, classes, and data:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入必要的库、类和数据：
- en: '[PRE33]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, load the data and separate it into train and test sets:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，加载数据并将其分为训练集和测试集：
- en: '[PRE34]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Make a list with the features to combine:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个要组合的特征列表：
- en: '[PRE35]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Set up `PolynomialFeatures()` to create all possible combinations up to the
    third degree:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`PolynomialFeatures()`以创建所有可能的三次或更小的组合：
- en: '[PRE36]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Set up the column transformer to create features only from those specified
    in *step 3*:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置列转换器以仅从*步骤3*中指定的列创建特征：
- en: '[PRE37]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create the polynomial features:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建多项式特征：
- en: '[PRE38]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: And that’s it. By executing `ct.get_feature_names_out()`, we obtain the names
    of the new features.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。通过执行`ct.get_feature_names_out()`，我们获得了新特征的名称。
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`ColumnTransformer()` will append the word `poly` to the resulting variables,
    which is the name we gave to the step within `ColumnTransformer()` in *step 5*.
    I am not a huge fan of this behavior because it makes data analysis harder, as
    you need to keep track of the variable name changes. To avoid variable name changes,
    you can use `feature-engine`’s `SklearnTransformerWrapper()` instead.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColumnTransformer()`将`poly`这个词添加到结果变量中，这是我们在*步骤5*中给`ColumnTransformer()`步骤取的名字。我不是特别喜欢这种行为，因为它使得数据分析变得更难，因为你需要跟踪变量名的变化。为了避免变量名变化，你可以使用`feature-engine`的`SklearnTransformerWrapper()`。'
- en: Combining features with decision trees
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将特征与决策树相结合
- en: In the winning solution of the **Knowledge Discovery and Data** Mining (**KDD**)
    competition in 2009, the authors created new features by combining two or more
    variables using decision trees. When examining the variables, they noticed that
    some features had a high level of mutual information with the target yet low correlation,
    indicating that the relationship with the target was not linear. While these features
    were predictive when used in tree-based algorithms, linear models could not take
    advantage of them. Hence, to use these features in linear models, they replaced
    the features with the outputs of decision trees trained on the individual features,
    or combinations of two or three variables, to return new features with a monotonic
    relationship with the target.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在2009年**知识发现与数据挖掘（KDD**）竞赛的获胜方案中，作者通过决策树将两个或多个变量组合起来创建新特征。在检查变量时，他们注意到一些特征与目标有很高的互信息，但相关性较低，这表明与目标的关系不是线性的。虽然这些特征在基于树的算法中使用时是预测性的，但线性模型无法利用它们。因此，为了在线性模型中使用这些特征，他们用训练在单个特征或两个或三个变量组合上的决策树输出的特征替换了这些特征，从而返回了与目标具有单调关系的新的特征。
- en: In short, combining features with decision trees is useful for creating features
    that show a monotonic relationship with the target, which is useful for making
    accurate predictions using linear models. The procedure consists of training a
    decision tree using a subset of the features – typically, one, two, or three at
    a time – and then using the prediction of the tree as a new feature.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，将特征与决策树相结合对于创建与目标具有单调关系的特征是有用的，这对于使用线性模型进行准确预测是有用的。该过程包括使用特征子集训练决策树——通常是每次一个、两个或三个——然后使用树的预测作为新的特征。
- en: Note
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more details about this procedure and the overall winning solution
    of the 2009 KDD data competition in this article: [http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf](http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这篇文章中找到关于此过程和2009年KDD数据竞赛整体获胜解决方案的更多详细信息：[http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf](http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf)。
- en: The good news is that we can automate the creation of features using trees,
    using `feature-engine`, and in this recipe, we will learn how to do so.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，我们可以使用`feature-engine`自动化使用树的特性创建，在这个菜谱中，我们将学习如何做到这一点。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we’ll combine features with decision trees, using the California
    housing dataset:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用加利福尼亚住房数据集将特征与决策树相结合：
- en: 'Let’s begin by importing `pandas` and the required functions, classes, and
    dataset:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入`pandas`以及所需的函数、类和数据集：
- en: '[PRE39]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let’s load the California housing dataset into a `pandas` DataFrame and remove
    the `Latitude` and `Longitude` variables:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将加利福尼亚住房数据集加载到`pandas` DataFrame中，并删除`Latitude`和`Longitude`变量：
- en: '[PRE40]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Separate the dataset into train and test sets:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据集分为训练集和测试集：
- en: '[PRE41]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Check out Pearson’s correlation coefficient between the features and the target,
    which is a measure of a linear relationship:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查特征与目标之间的皮尔逊相关系数，这是线性关系的度量：
- en: '[PRE42]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the following output, we can see that, apart from `MedInc`, most variables
    do not show a strong linear relationship with the target; the correlation coefficient
    is smaller than 0.5:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到，除了`MedInc`之外，大多数变量与目标之间没有显示出强烈的线性关系；相关系数小于0.5：
- en: '[PRE43]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a grid of hyperparameters to optimize each decision tree:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个超参数网格以优化每个决策树：
- en: '[PRE44]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `feature-engine` library’s `DecisionTreeFeatures()` allows us to add features
    resulting from the predictions of a decision tree, trained on one or more features.
    There are many ways in which we can instruct the transformer to combine the features.
    We’ll start by creating all possible combinations between two variables.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`feature-engine`库的`DecisionTreeFeatures()`允许我们添加由在单个或多个特征上训练的决策树预测出的特征。我们可以以多种方式指导转换器组合特征。我们将从创建两个变量之间的所有可能组合开始。'
- en: 'Make a list with the two features that we want to use as inputs:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出我们想要用作输入的两个功能：
- en: '[PRE45]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Set up `DecisionTreeFeatures()` to create all possible combinations between
    the features from *step 6*:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`DecisionTreeFeatures()`设置为创建来自*步骤6*中特征的所有可能组合：
- en: '[PRE46]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We set `regression` to `True` because the target in this dataset is continuous.
    If you have a binary target or are performing classification, set it to `False`.
    Make sure to select an evaluation metric (`scoring`) that is suitable for your
    model.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`regression`设置为`True`，因为在这个数据集中的目标是连续的。如果你有一个二元目标或正在执行分类，请将其设置为`False`。确保选择一个适合你模型的评估指标（`scoring`）。
- en: 'Fit the transformer so that it trains the decision trees on the input features:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拟合转换器，以便它在输入特征上训练决策树：
- en: '[PRE47]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you wonder which features have been used to train decision trees, you can
    inspect them like this:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想知道哪些特征被用于训练决策树，你可以像这样检查它们：
- en: '[PRE48]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the following output, we can see that `DecisionTreeFeatures()` has trained
    three decision trees – two by using the single features, `AveRooms` and `AveBedrms`,
    and one by using both features:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到`DecisionTreeFeatures()`已经训练了三个决策树——两个使用单个特征`AveRooms`和`AveBedrms`，一个使用这两个特征：
- en: '[PRE49]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`DecisionTreeFeatures()` also stores the decision trees. You can check them
    out by executing `dtf.estimators_`.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`DecisionTreeFeatures()`还存储决策树。你可以通过执行`dtf.estimators_`来检查它们。'
- en: 'Now, add the features to the training and testing sets:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将这些特征添加到训练和测试集中：
- en: '[PRE50]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Make a list with the name of the new features (the transformer appends the
    word `tree` to the feature names):'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出新特征的名称（转换器将单词`tree`附加到特征名称上）：
- en: '[PRE51]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, display the features that were added to the test set:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，显示添加到测试集中的特征：
- en: '[PRE52]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the following output, we can see the first five rows of the new features,
    resulting from the decision trees trained in *step 8*:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到由*步骤8*中训练的决策树产生的新特征的前五行：
- en: '![    Figure 8.9 – A portion of the testing set containing the features derived
    from the decision trees](img/B22396_08_9.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![    图8.9 – 包含从决策树中派生出的特征的测试集的一部分](img/B22396_08_9.jpg)'
- en: Figure 8.9 – A portion of the testing set containing the features derived from
    the decision trees
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 包含从决策树中派生出的特征的测试集的一部分
- en: 'To check the power of this transformation, calculate Pearson’s correlation
    coefficient between the new features and the target:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查这种转换的力量，计算新特征与目标之间的皮尔逊相关系数：
- en: '[PRE53]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the following output, we can see that the correlation between the new variables
    and the target is greater than the correlation shown by the original features
    (compare these values with those of *step 4*):'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到新变量与目标之间的相关性大于原始特征显示的相关性（将这些值与*步骤4*中的值进行比较）：
- en: '[PRE54]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you want to combine specific features instead of getting all possible combinations
    between variables, you can do so by specifying the input features in tuples.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想要组合特定的特征而不是获取变量之间的所有可能组合，你可以通过指定元组中的输入特征来实现。
- en: 'Create a tuple of tuples with the different features that we want to use as
    input for decision trees:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含我们想要用作决策树输入的不同特征的元组元组：
- en: '[PRE55]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we need to pass these tuples to the `features_to_combine` parameter of
    `DecisionTreeFeatures()`:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将这些元组传递给`DecisionTreeFeatures()`的`features_to_combine`参数：
- en: '[PRE56]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We fitted the transformer in the previous step, so we can go ahead and add
    the features to training and test sets:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在上一步骤中拟合了转换器，因此我们可以继续将特征添加到训练和测试集中：
- en: '[PRE57]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Display the new features:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示新功能：
- en: '[PRE58]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the following output, we can see the new features derived from predictions
    of decision trees in the test set:'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到来自测试集中决策树预测的新特征：
- en: '![    Figure 8.10 – A portion of the testing set containing the features derived
    from the decision trees](img/B22396_08_10.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![    图8.10 – 包含从决策树中派生出的特征的测试集的一部分](img/B22396_08_10.jpg)'
- en: Figure 8.10 – A portion of the testing set containing the features derived from
    the decision trees
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 包含从决策树中提取的特征的测试集的一部分
- en: To wrap up the recipe, we’ll compare the performance of a Lasso linear regression
    model trained using the original features with one using the features derived
    from the decision trees.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这个菜谱，我们将比较使用原始特征训练的Lasso线性回归模型和使用从决策树中提取的特征训练的模型的性能。
- en: 'Import `Lasso` and the `cross_validate` function from `scikit-learn`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`scikit-learn`导入`Lasso`和`cross_validate`函数：
- en: '[PRE59]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Set up a Lasso regression model:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Lasso回归模型：
- en: '[PRE60]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Train and evaluate the model using the original data with cross-validation,
    and then print out the resulting *r*-squared:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用交叉验证和原始数据训练和评估模型，然后打印出结果的*r*-squared：
- en: '[PRE61]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the following output, we can see the *r*-squared of the Lasso regression
    model trained using the original features:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的输出中，我们可以看到使用原始特征训练的Lasso回归模型的*r*-square值：
- en: '[PRE62]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, train a Lasso regression model with the features derived from the
    decision trees and evaluate it with cross-validation:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用从决策树中提取的特征训练Lasso回归模型，并使用交叉验证进行评估：
- en: '[PRE63]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the following output, we can see that the performance of the Lasso regression
    model trained based of the tree-derived features is better; the *r*-square is
    greater than that from *step 20*:'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的输出中，我们可以看到基于树衍生特征训练的Lasso回归模型的性能更好；其*r*-square值大于*步骤20*中的值：
- en: '[PRE64]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: I hope I’ve given you a flavor of the power of combining features with decision
    trees and how to do so with `feature-engine`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我已经给你展示了结合决策树和特征以及如何使用`feature-engine`做到这一点的力量。
- en: How it works...
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created new features based on the predictions of decision
    trees trained on one or more variables. We used `DecisionTreeFeatures()` from
    `Feature-engine` to automate the process of training the decision trees with cross-validation
    and hyperparameter optimization.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们基于在一个或多个变量上训练的决策树的预测创建了新的特征。我们使用`Feature-engine`中的`DecisionTreeFeatures()`来自动化使用交叉验证和超参数优化训练决策树的过程。
- en: '`DecisionTreeFeatures()` trains decision trees using grid-search under the
    hood. Hence, you can pass a grid of hyperparameters to optimize the tree, or the
    transformer will optimize just the depth, which, in any case, is the most important
    parameter in a decision tree. You can also change the metric you want to optimize
    through the `scoring` parameter and the cross-validation scheme you want to use
    through the `cv` parameter.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`DecisionTreeFeatures()`在底层使用网格搜索来训练决策树。因此，你可以传递一个超参数网格来优化树，或者转换器将仅优化深度，这在任何情况下都是决策树中最重要的参数。你还可以通过`scoring`参数更改你想要优化的度量，并通过`cv`参数更改你想要使用的交叉验证方案。'
- en: The most exciting feature of `DecisionTreeFeatures()` is its ability to infer
    the feature combinations to create tree-derived features, which is regulated through
    the `features_to_combine` parameter. If you pass an integer to this parameter
    – say, for example, `3`, `DecisionTreeFeatures()` will create all possible combinations
    of 1, 2, and 3 features and use these to train the decision trees. Instead of
    an integer, you can pass a list of integers – say, `[2,3]` – in which case, `DecisionTreeFeatures()`
    will create all possible combinations of 2 and 3 features. You can also specify
    which features you want to combine and how by passing the feature combinations
    in tuples, as we did in *step 14*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`DecisionTreeFeatures()`最令人兴奋的特性是其推断特征组合以创建树衍生特征的能力，这通过`features_to_combine`参数进行调节。如果你向这个参数传递一个整数——比如说，例如`3`，`DecisionTreeFeatures()`将创建所有可能的1、2和3个特征的组合，并使用这些组合来训练决策树。你也可以传递一个整数的列表——比如说，`[2,3]`——在这种情况下，`DecisionTreeFeatures()`将创建所有可能的2和3个特征的组合。你还可以通过传递元组中的特征组合来指定你想要组合的特征以及如何组合，就像我们在*步骤14*中所做的那样。'
- en: With `fit()`, `DecisionTreeFeatures()` finds the feature combinations and trains
    the decision trees. With `transform()`, `DecisionTreeFeatures()` adds the features
    resulting from the decision trees to the DataFrame.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fit()`，`DecisionTreeFeatures()`找到特征组合并训练决策树。使用`transform()`，`DecisionTreeFeatures()`将决策树产生的特征添加到DataFrame中。
- en: Note
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are training regression or multi-class classification, the new features
    will be either the prediction of the continuous target or the class. If you are
    training a binary classification model, the new features will result from the
    probability of class 1.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在训练回归或多类分类，新特征将是连续目标的预测或类别。如果你正在训练二元分类模型，新特征将来自类别1的概率。
- en: After adding the new features, we compared their relationship to the target
    by analyzing Pearson’s correlation coefficient, which returned a measure of linear
    association. We saw that the features derived from trees had a greater correlation
    coefficient.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新特征后，我们通过分析皮尔逊相关系数来比较它们与目标之间的关系，该系数返回线性关联的度量。我们发现从树中派生的特征具有更大的相关系数。
- en: See also
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'If you want to know more about what mutual information is and how to calculate
    it, check out this article: [https://www.blog.trainindata.com/mutual-information-with-python/](https://www.blog.trainindata.com/mutual-information-with-python/).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于互信息是什么以及如何计算它的信息，请查看这篇文章：[https://www.blog.trainindata.com/mutual-information-with-python/](https://www.blog.trainindata.com/mutual-information-with-python/).
- en: Creating periodic features from cyclical variables
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从周期性变量创建周期性特征
- en: Some features are periodic – for example, the hours in a day, the months in
    a year, and the days in a week. They all start at a certain value (say, January),
    go up to a certain other value (say, December), and then start over from the beginning.
    Some features are numeric, such as the hours, and some can be represented with
    numbers, such as the months, with values of 1 to 12\. Yet, this numeric representation
    does not capture the periodicity or cyclical nature of the variable. For example,
    December (12) is closer to January (1) than June (6); however, this relationship
    is not captured by the numerical representation of the feature. But we could change
    it if we transformed these variables with the sine and cosine, two naturally periodic
    functions.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一些特征是周期性的——例如，一天中的小时，一年中的月份，一周中的天数。它们都从一个特定的值（比如说，一月）开始，上升到另一个特定的值（比如说，十二月），然后从头开始。一些特征是数字的，比如小时，而一些可以用数字表示，比如月份，其值为1到12。然而，这种数字表示并没有捕捉到变量的周期性或循环性质。例如，十二月（12）比六月（6）更接近一月（1）；然而，这种关系并没有被特征的数值表示所捕捉。但如果我们用正弦和余弦函数，这两种自然周期函数来转换这些变量，我们就可以改变它。
- en: Encoding cyclical features with the sine and cosine functions allows linear
    models to leverage the cyclical nature of features and reduce their modeling error.
    In this recipe, we will create new features from periodic variables that capture
    the cyclical nature of time.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正弦和余弦函数对周期性特征进行编码允许线性模型利用特征的周期性并减少其建模误差。在本食谱中，我们将从捕获时间周期性的周期性变量中创建新特征。
- en: Getting ready
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Trigonometric functions, such as sine and cosine, are periodic, with values
    cycling between -1 and 1 every 2π cycles, as shown here:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 三角函数，如正弦和余弦，是周期性的，其值在每个2π周期内循环于-1和1之间，如下所示：
- en: '![Figure 8.11 – Sine and cosine functions](img/B22396_08_11.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – 正弦和余弦函数](img/B22396_08_11.jpg)'
- en: Figure 8.11 – Sine and cosine functions
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 正弦和余弦函数
- en: 'We can capture the periodicity of a cyclical variable by applying a trigonometric
    transformation after normalizing the variable values between 0 and 2π:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在将变量值归一化到0和2π之间后应用三角变换来捕捉周期性变量的周期性。
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>sin</mi><mfenced
    open="(" close=")"><mi>x</mi></mfenced><mo>=</mo><mi>sin</mi><mrow><mrow><mo>(</mo><mn>2</mn><mi>π</mi><mfrac><mi>X</mi><msub><mi>X</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mfrac><mo>)</mo></mrow></mrow></mrow></mrow></math>](img/37.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>sin</mi><mfenced
    open="(" close=")"><mi>x</mi></mfenced><mo>=</mo><mi>sin</mi><mrow><mrow><mo>(</mo><mn>2</mn><mi>π</mi><mfrac><mi>X</mi><msub><mi>X</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mfrac><mo>)</mo></mrow></mrow></mrow></mrow></math>](img/37.png)'
- en: Dividing the variable’s values by its maximum will normalize it between 0 and
    1 (assuming that the minimum value is 0), and multiplying it by 2π will rescale
    the variable between 0 and 2π.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量的值除以其最大值将使其在0和1之间归一化（假设最小值为0），然后乘以2π将变量重新缩放到0和2π之间。
- en: Should we use sine? Or should we use cosine? The thing is, we need to use both
    to encode all the values of the variables unequivocally. Since sine and cosine
    circle between 0 and 1, they will take a value of 0 for more than one value of
    *x*. For example, the sine of 0 returns 0, and so does the sine of π. So, if we
    encode a variable with just the sine, we wouldn’t be able to distinguish between
    the values 0 and π anymore. However, because the sine and the cosine are out of
    phase, the cosine of 0 returns 1, whereas the cosine of π returns -1\. Hence,
    by encoding the variable with the two functions, we are now able to distinguish
    between 0 and 1, which would take (0,1) and (0,-1) as values for the sine and
    cosine functions, respectively.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用正弦函数吗？还是应该使用余弦函数？问题是，我们需要两者并用以无歧义地编码变量的所有值。由于正弦和余弦函数在0和1之间循环，它们将对于多个x值取0。例如，0的正弦值为0，π的正弦值也为0。所以，如果我们只用正弦函数来编码变量，我们就无法再区分0和π的值了。然而，由于正弦和余弦函数相位不同，0的余弦值为1，而π的余弦值为-1。因此，通过使用两个函数来编码变量，我们现在能够区分0和1，正弦函数和余弦函数分别以(0,1)和(0,-1)作为值。
- en: How to do it…
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we will first transform the `hour` variable in a toy DataFrame
    with the sine and the cosine to get a sense of the new variable representation.
    Then, we will automate feature creation from multiple cyclical variables using
    `feature-engine`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将首先使用正弦和余弦将玩具DataFrame中的`hour`变量进行变换，以了解新的变量表示。然后，我们将使用`feature-engine`自动化从多个周期性变量中创建特征：
- en: 'Begin by importing the necessary libraries:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入必要的库：
- en: '[PRE65]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create a toy DataFrame with one variable – `hour` – with values between 0 and
    23:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含一个变量 – `hour` – 且值在0到23之间的玩具DataFrame：
- en: '[PRE66]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, create two features using the sine and cosine transformations, after
    normalizing the variable values between 0 and 2π:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在将变量值归一化到0和2π之间后，使用正弦和余弦变换创建两个特征：
- en: '[PRE67]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we execute `df.head()`, we will see the original and new features:'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们执行`df.head()`，我们将看到原始特征和新特征：
- en: "![Figure 8.12 – A DataFrame with the hour variable and the new features obtaine\uFEFF\
    d through the sine and cosine transformations](img/B22396_08_12.jpg)"
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12 – 包含小时变量和通过正弦和余弦变换获得的新特征的DataFrame](img/B22396_08_12.jpg)'
- en: Figure 8.12 – A DataFrame with the hour variable and the new features obtained
    through the sine and cosine transformations
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 包含小时变量和通过正弦和余弦变换获得的新特征的DataFrame
- en: 'Make a scatter plot between the hour and its sine-transformed values:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在小时和其正弦变换值之间制作散点图：
- en: '[PRE68]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the following plot, we can see how the values of the hour circle between
    -1 and 1, just like the sine function after the transformation:'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的图中，我们可以看到小时值的范围在-1和1之间，就像变换后的正弦函数一样：
- en: "![Figure 8.13 – A sca\uFEFFtter plot of th\uFEFFe hour versus its sine transformed\
    \ values](img/B22396_08_13.jpg)"
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13 – 小时与其正弦变换值的散点图](img/B22396_08_13.jpg)'
- en: Figure 8.13 – A scatter plot of the hour versus its sine transformed values
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 小时与其正弦变换值的散点图
- en: 'Now, make a scatter plot between the hour and its cosine transformation:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在小时和其余弦变换之间制作散点图：
- en: '[PRE69]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In the following plot, we can see how the values of the hour circle between
    -1 and 1, just like the cosine function after the transformation:'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的图中，我们可以看到小时值的范围在-1和1之间，就像变换后的余弦函数一样：
- en: '![Figure 8.14 – A scatter plot of the hour versus its cosine-transformed values](img/B22396_08_14.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14 – 小时与其余弦变换值的散点图](img/B22396_08_14.jpg)'
- en: Figure 8.14 – A scatter plot of the hour versus its cosine-transformed values
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – 小时与其余弦变换值的散点图
- en: Finally, we can reconstitute the cyclical nature of the hour, which is now captured
    by the two new features.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以重建小时的周期性，现在它被两个新的特征所捕捉。
- en: 'Plot the values of the sine versus the cosine of the hour, and overlay the
    original values of the hour using a color map:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制正弦值与小时余弦值的对比图，并使用颜色图叠加小时的原值：
- en: '[PRE70]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the following plot, we can see how the two trigonometric transformations
    of the hour reflect the cyclical nature of the hour, in a plot that reminds us
    of a clock:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的图中，我们可以看到小时的两个三角变换如何反映了小时的周期性，在一张让我们想起钟表的图中：
- en: '![Figure 8.15 – A scatter plot of the trigonometric transformation of the hour](img/B22396_08_15.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图8.15 – 小时的三角变换散点图](img/B22396_08_15.jpg)'
- en: Figure 8.15 – A scatter plot of the trigonometric transformation of the hour
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – 小时的三角变换散点图
- en: Note
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code implementation and idea for this plot were taken from scikit-learn’s
    documentation: [https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#trigonometric-features](https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#trigonometric-features).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表的代码实现和思路来源于scikit-learn的文档：[https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#trigonometric-features](https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#trigonometric-features)。
- en: Now that we understand the nature and effect of the transformation, let’s create
    new features using the sine and cosine transformations from multiple variables
    automatically. We will use the `feature-engine` library’s `CyclicalFeatures()`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了变换的性质和效果，让我们使用正弦和余弦变换自动从多个变量中创建新特征。我们将使用`feature-engine`库的`CyclicalFeatures()`。
- en: 'Import `CyclicalFeatures()`:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`CyclicalFeatures()`：
- en: '[PRE71]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let’s create a toy DataFrame that contains the `hour`, `month`, and `week`
    variables, whose values vary between 0 and 23, 1 and 12, and 0 and 6, respectively:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个包含`hour`、`month`和`week`变量的玩具DataFrame，这些变量的值分别在0到23、1到12和0到6之间：
- en: '[PRE72]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If we execute `df.head()`, we will see the first five rows of the toy DataFrame:'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们执行`df.head()`，我们将看到玩具DataFrame的前五行：
- en: "![Figure 8.16 – The\uFEFF toy DataFrame with three cyclical features](img/B22396_08_16.jpg)"
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图8.16 – 具有三个周期特征的玩具DataFrame](img/B22396_08_16.jpg)'
- en: Figure 8.16 – The toy DataFrame with three cyclical features
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 – 具有三个周期特征的玩具DataFrame
- en: 'Set up the transformer to create the sine and cosine features from these variables:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置转换器以从这些变量中创建正弦和余弦特征：
- en: '[PRE73]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By setting `variables` to `None`, `CyclicalFeatures()` will create trigonometric
    features from all numerical variables. To create trigonometric features from a
    subset of variables, we can pass the variables’ names in a list to the `variables`
    parameter. We can retain or drop the original variables after creating the cyclical
    features using the `drop_original` parameter.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`variables`设置为`None`，`CyclicalFeatures()`将从所有数值变量中创建三角特征。要创建变量子集的三角特征，我们可以将变量名列表传递给`variables`参数。在创建周期特征后，我们可以使用`drop_original`参数保留或删除原始变量。
- en: 'To finish, add the features to the DataFrame and capture the result in a new
    variable:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将特征添加到DataFrame中，并将结果捕获在新变量中：
- en: '[PRE74]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If we execute `dft.head()`, we will see the original and new features:'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们执行`dft.head()`，我们将看到原始特征和新特征：
- en: '![Figure 8.17 – DataFrame with cyclical features plus the features created
    through the sine and cosine functions](img/B22396_08_17.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图8.17 – 具有周期特征以及通过正弦和余弦函数创建的特征的DataFrame](img/B22396_08_17.jpg)'
- en: Figure 8.17 – DataFrame with cyclical features plus the features created through
    the sine and cosine functions
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 – 具有周期特征以及通过正弦和余弦函数创建的特征的DataFrame
- en: And that’s it – we’ve created features by using the sine and cosine transformation
    automatically from multiple variables and added them directly to the original
    DataFrame.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样 – 我们通过使用正弦和余弦变换自动从多个变量中创建特征，并将它们直接添加到原始DataFrame中。
- en: How it works…
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we encoded cyclical features with values obtained from the sine
    and cosine functions, applied to the normalized values of the variable. First,
    we normalized the variable values between 0 and 2 π. To do this, we divided the
    variable values by the variable maximum value, which we obtained with `pandas.max()`,
    to scale the variables between 0 and 1\. Then, we multiplied those values by 2π,
    using `numpy.pi`. Finally, we used `np.sin` and `np.cos` to apply the sine and
    cosine transformations, respectively.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用正弦和余弦函数从变量的归一化值中获取值来编码周期特征。首先，我们将变量值归一化到0和2π之间。为此，我们用`pandas.max()`获取变量最大值，将变量值除以变量最大值，以将变量缩放到0和1之间。然后，我们使用`numpy.pi`将这些值乘以2π。最后，我们使用`np.sin`和`np.cos`分别应用正弦和余弦变换。
- en: To automate this procedure for multiple variables, we used the `Feature-engine`
    library’s `CyclicalFeatures()`. With `fit()`, the transformer learned the maximum
    values of each variable, and with `transform()`, it added the features resulting
    from the sine and cosine transformations to the DataFrame.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化对多个变量的此过程，我们使用了`Feature-engine`库的`CyclicalFeatures()`。通过`fit()`，转换器学习了每个变量的最大值，通过`transform()`，它将正弦和余弦变换产生的特征添加到DataFrame中。
- en: Note
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In theory, to apply the sine and cosine transformation, we need to scale the
    original variable between 0 and 1\. Dividing by the maximum of the variable will
    only result in this scaling if the minimum value is 0\. scikit-learn’s documentation
    and `Feature-engine`’s current implementation divide the variable by its maximum
    value (or an arbitrary period), without paying too much attention to whether the
    variable starts at 0\. In practice, you won’t see a big difference in the resulting
    variables if you divide the hour feature by 23 or 24, or the month feature by
    12 or 11\. Discussions are underway on whether Feature-engine’s implementation
    should be updated, so the default behavior might change by the time this book
    is published. Check out the documentation for more details.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，为了应用正弦和余弦变换，我们需要将原始变量缩放到0到1之间。如果最小值是0，则除以变量的最大值只会得到这种缩放。scikit-learn的文档和`Feature-engine`当前的实现将变量除以其最大值（或任意周期），并没有过多关注变量是否从0开始。在实践中，如果你将小时特征除以23或24，或者将月份特征除以12或11，你不会在结果变量中看到很大的差异。目前正在讨论是否应该更新Feature-engine的实现，因此默认行为可能会在本书出版时发生变化。有关更多详细信息，请参阅文档。
- en: Creating spline features
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建样条特征
- en: Linear models expect a linear relationship between the predictor variables and
    the target. However, we can use linear models to model non-linear effects if we
    first transform the features. In the *Performing polynomial expansion* recipe,
    we saw how we can unmask linear patterns by creating features with polynomial
    functions. In this recipe, we will discuss the use of splines.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 线性模型期望预测变量和目标之间存在线性关系。然而，如果我们首先转换特征，我们可以使用线性模型来模拟非线性效应。在“执行多项式展开”的食谱中，我们看到了如何通过创建多项式函数的特征来揭示线性模式。在本食谱中，我们将讨论样条的使用。
- en: Splines are used to mathematically reproduce flexible shapes. They consist of
    piecewise low-degree polynomial functions. To create splines, we must place knots
    at several values of *x*. These knots indicate where the pieces of the function
    join. Then, we fit low-degree polynomials to the data between two consecutive
    knots.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 样条用于在数学上再现灵活的形状。它们由分段低次多项式函数组成。要创建样条，我们必须在*x*的几个值上放置节点。这些节点表示函数片段的连接点。然后，我们在两个连续节点之间拟合低次多项式。
- en: There are several types of splines, such as smoothing splines, regression splines,
    and B-splines. scikit-learn supports the use of B-splines to create features.
    The procedure to fit and, therefore, return the spline values for a certain variable,
    based on a polynomial degree and the number of knots, exceeds the scope of this
    recipe. For more details, check out the resources in the *See also* section of
    this recipe. In this recipe, we’ll get a sense of what splines are and how we
    can use them to improve the performance of linear models.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种样条类型，例如平滑样条、回归样条和B样条。scikit-learn支持使用B样条来创建特征。根据多项式度和节点数来拟合样条值，对于特定变量的过程超出了本食谱的范围。有关更多详细信息，请参阅本食谱的“也见”部分中的资源。在本食谱中，我们将了解样条是什么以及我们如何使用它们来提高线性模型的表现。
- en: Getting ready
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let’s get a sense of what splines are. In the following figure, on the left,
    we can see a spline with a degree of 1\. It consists of two linear pieces – one
    from 2.5 to 5 and the other from 5 to 7.5\. There are three knots – 2.5, 5, and
    7.5\. Outside the interval between 2.5 and 7.5, the spline takes a value of 0\.
    The latter is characteristic of splines; they are only non-negative between certain
    values. On the right panel of the figure, we can see three splines of degree 1\.
    We can construct as many splines as we want by introducing more knots:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解样条是什么。在下面的图中，左侧我们可以看到一个一阶样条。它由两个线性片段组成 – 一个从2.5到5，另一个从5到7.5。有三个节点 – 2.5，5和7.5。在2.5和7.5之间的区间外，样条取值为0。这是样条的特征；它们只在某些值之间为非负。在图的右侧面板中，我们可以看到三个一阶样条。我们可以通过引入更多的节点来构建我们想要的任意数量的样条：
- en: '![Figure 8.18 – The splines with a degree of 1](img/B22396_08_18.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图8.18 – 一阶样条](img/B22396_08_18.jpg)'
- en: Figure 8.18 – The splines with a degree of 1
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 – 一阶样条
- en: 'In the following figure, on the left, we can see a quadratic spline, also known
    as a spline with a degree of 2\. It is based on four adjacent knots – 0, 2.5,
    5, and 7.5\. On the right-hand side of the figure, we can see several splines
    of degree 2:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，左侧我们可以看到一个二次样条，也称为二阶样条。它基于四个相邻的节点 – 0，2.5，5和7.5。在图的右侧，我们可以看到几个二阶样条：
- en: '![Figure 8.19 – The splines with a degree of 2](img/B22396_08_19.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图8.19 – 二次样条](img/B22396_08_19.jpg)'
- en: Figure 8.19 – The splines with a degree of 2
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 – 二次样条
- en: We can use splines to model non-linear functions, and we will learn how to do
    this in the next section.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用样条来建模非线性函数，我们将在下一节中学习如何做到这一点。
- en: How to do it…
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In this recipe, we will use splines to model the sine function. Once we get
    a sense of what splines are and how we can use them to fit non-linear relationships
    through a linear model, we will use splines for regression in a real dataset:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用样条来建模正弦函数。一旦我们了解样条是什么以及我们如何通过线性模型拟合非线性关系，我们将在实际数据集中使用样条进行回归：
- en: Note
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The idea to model the sine function with splines was taken from scikit-learn’s
    documentation: [https://scikit-learn.org/stable/auto_examples/linear_model/plot_polynomial_interpolation.html](https://scikit-learn.org/stable/auto_examples/linear_model/plot_polynomial_interpolation.html).'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 将样条建模正弦函数的想法来自scikit-learn的文档：[https://scikit-learn.org/stable/auto_examples/linear_model/plot_polynomial_interpolation.html](https://scikit-learn.org/stable/auto_examples/linear_model/plot_polynomial_interpolation.html)。
- en: 'Let’s begin by importing the necessary libraries and classes:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先导入必要的库和类：
- en: '[PRE75]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create a training set, `X`, with 20 values between -1 and 11, and the target
    variable, `y`, which is the sine of `X`:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含-1和11之间20个值的训练集`X`，以及目标变量`y`，它是`X`的正弦值：
- en: '[PRE76]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Plot the relationship between `X` and `y`:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制`X`和`y`之间的关系图：
- en: '[PRE77]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In the following plot, we can see the sine function of `X`:'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的图中，我们可以看到`X`的正弦函数：
- en: "![Figure 8.20 – The relationship \uFEFFbetween the predictor and the target\
    \ variable, where y = sine(x)](img/B22396_08_20.jpg)"
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![图8.20 – 预测变量和目标变量之间的关系，其中y = sine(x)](img/B22396_08_20.jpg)'
- en: Figure 8.20 – The relationship between the predictor and the target variable,
    where y = sine(x)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 – 预测变量和目标变量之间的关系，其中y = sine(x)
- en: 'Fit a linear model to predict `y` from `X` by utilizing a Ridge regression,
    and then obtain the predictions of the model:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用岭回归预测`y`来自`X`，并获取模型的预测结果：
- en: '[PRE78]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, plot the relationship between `X` and `y`, and overlay the predictions:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，绘制`X`和`y`之间的关系图，并叠加预测结果：
- en: '[PRE79]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In the following figure, we can see that the linear model makes a very poor
    fit of the non-linear relationship between `X` and `y`:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的图中，我们可以看到线性模型对`X`和`y`之间的非线性关系拟合得非常差：
- en: '![Figure 8.21 – The linear fit between X and y](img/B22396_08_21.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图8.21 – X和y之间的线性拟合](img/B22396_08_21.jpg)'
- en: Figure 8.21 – The linear fit between X and y
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 – X和y之间的线性拟合
- en: 'Now, set up `SplineTransformer()` to obtain spline features from `X`, by utilizing
    third-degree polynomials and five knots at equidistant places within the values
    of `X`:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，设置`SplineTransformer()`以从`X`中获取样条特征，通过使用`X`值内的三次多项式和五个等距结点：
- en: '[PRE80]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Obtain the spline features and convert the NumPy array into a `pandas` DataFrame,
    adding the names of the spline basis functions:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取样条特征，并将NumPy数组转换为`pandas`数据框，添加样条基函数的名称：
- en: '[PRE81]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'By executing `X_df.head()`, we can see the spline features:'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过执行`X_df.head()`，我们可以看到样条特征：
- en: '![Figure 8.22 – A DataFrame with the splines](img/B22396_08_22.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图8.22 – 包含样条的数据框](img/B22396_08_22.jpg)'
- en: Figure 8.22 – A DataFrame with the splines
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 – 包含样条的数据框
- en: Note
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`SplineTransformer()` returns a feature matrix consisting of `n_splines = n_knots
    + degree –` `1`.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`SplineTransformer()`返回一个特征矩阵，由`n_splines = n_knots + degree – 1`组成。'
- en: 'Now, plot the splines against the values of `X`:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将样条与`X`的值进行绘图：
- en: '[PRE82]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In the following figure, we can see the relationship between the different
    splines and the values of the predictor variable, `X`:'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的图中，我们可以看到不同样条与预测变量`X`的值之间的关系：
- en: "![Figure 8.23 – Spli\uFEFFnes plotted against the values of the predictor variable,\
    \ X](img/B22396_08_23.jpg)"
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图8.23 – 样条与预测变量X的值绘制的图](img/B22396_08_23.jpg)'
- en: Figure 8.23 – Splines plotted against the values of the predictor variable,
    X
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 – 样条与预测变量X的值绘制的图
- en: 'Now, fit a linear model to predict `y` from the spline features obtained from
    `X`, by utilizing a Ridge regression, and then obtain the predictions of the model:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过使用从`X`获取的样条特征，利用岭回归拟合线性模型以预测`y`，然后获取模型的预测结果：
- en: '[PRE83]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, plot the relationship between `X` and `y`, and overlay the predictions:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，绘制`X`和`y`之间的关系图，并叠加预测结果：
- en: '[PRE84]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In the following figure, we can see that by utilizing spline features as input,
    the Ridge regression can better predict the shape of `y`:'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的图中，我们可以看到通过利用样条特征作为输入，岭回归可以更好地预测`y`的形状：
- en: '![Figure 8.24 – The predictions of a linear model, based on splines overlaid
    over the true relationship between X and y](img/B22396_08_24.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![图8.24 – 基于样条覆盖X和y之间真实关系的线性模型的预测](img/B22396_08_24.jpg)'
- en: Figure 8.24 – The predictions of a linear model, based on splines overlaid over
    the true relationship between X and y
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 – 基于样条覆盖X和y之间真实关系的线性模型的预测
- en: Note
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Increasing the number of knots or the degree of the polynomial increases the
    flexibility of the spline curves. Try creating splines from higher polynomial
    degrees and see how the Ridge regression predictions change.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 增加结点的数量或多项式的度数会增加样条曲线的灵活性。尝试从更高次的多项式创建样条，看看岭回归预测如何变化。
- en: Now that we understand what the spline features are and how we can use them
    to predict non-linear effects, let’s try them out on a real dataset.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了样条特征是什么以及我们如何使用它们来预测非线性效应，让我们在一个真实的数据集上尝试一下。
- en: 'Import some additional classes and functions from `scikit-learn`:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`scikit-learn`导入一些额外的类和函数：
- en: '[PRE85]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Load the California housing dataset and drop two of the variables, which we
    won’t use for modeling:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载加利福尼亚住房数据集并删除两个变量，我们不会用它们进行建模：
- en: '[PRE86]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'First, we will fit a Ridge regression to predict house prices based on the
    existing variables, by utilizing cross-validation, and then obtain the performance
    of the model to set up the benchmark:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将拟合一个岭回归来根据现有变量预测房价，通过使用交叉验证，然后获取模型的性能以设置基准：
- en: '[PRE87]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In the following output, we can see the model performance, where the values
    are the *R*-squared:'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的输出中，我们可以看到模型性能，其中数值是R平方：
- en: '[PRE88]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: spl = SplineTransformer(degree=3, n_knots=50)
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: spl = SplineTransformer(degree=3, n_knots=50)
- en: ct = ColumnTransformer(
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ct = ColumnTransformer(
- en: '[("splines", spl, ['
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[("splines", spl, ['
- en: '"AveRooms", "AveBedrms", "Population",'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"平均房间数"、"平均卧室数"、"人口",'
- en: '"AveOccup"]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"平均占用人数"'
- en: )],
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )],
- en: remainder="passthrough",
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: remainder="passthrough",
- en: )
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: ct.fit(X, y)
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ct.fit(X, y)
- en: '[PRE89]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that we need to use `ColumnTransformer()` to obtain features from a
    subset of variables in the data. With `remainder=passthrough`, we ensure that
    the variables that are not used as templates for the splines – that is, `MedInc`
    and `HouseAge` – are also returned in the resulting DataFrame. To check out the
    features resulting from this step, execute `ct.get_feature_names_out()`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们需要使用`ColumnTransformer()`来从数据的一组变量中获取特征。通过`remainder=passthrough`，我们确保那些不作为样条模板的变量——即`MedInc`和`HouseAge`——也被返回到结果DataFrame中。要检查这一步产生的特征，请执行`ct.get_feature_names_out()`。
- en: 'Now, fit a Ridge regression to predict house prices based on `MedInc`, `HouseAge`,
    and the spline features, using cross-validation, and then obtain the performance
    of the model:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，拟合一个岭回归来根据`MedInc`、`HouseAge`和样条特征预测房价，使用交叉验证，然后获取模型的性能：
- en: '[PRE90]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In the following output, we can see the model performance, where the values
    are the *R*-squared:'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的输出中，我们可以看到模型性能，其中数值是R平方：
- en: '[PRE91]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: As we can see, by using splines in place of some of the original variables,
    we can improve the performance of the linear regression model.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过使用样条代替一些原始变量，我们可以提高线性回归模型的性能。
- en: How it works…
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we created new features based on splines. First, we used a toy
    variable, with values from -1 to 11, and then we obtained splines from a real
    dataset. The procedure in both cases was identical – we used `SplineTransformer()`
    from `scikit-learn`. The `SplineTransformer()` transformer takes the `degree`
    property of the polynomial and the number of knots (`n_knots`) as input and returns
    the splines that better fit the data. The knots are placed at equidistant values
    of `X` by default, but through the `knots` parameter, we can choose to uniformly
    distribute them to the quantiles of `X` instead, or we can pass an array with
    the specific values of `X` that should be used as knots.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们基于样条创建了新的特征。首先，我们使用一个玩具变量，其值从-1到11，然后我们从真实数据集中获取样条。在这两种情况下，过程是相同的——我们使用了`scikit-learn`中的`SplineTransformer()`。`SplineTransformer()`转换器接受多项式的`degree`属性和结点的数量（`n_knots`）作为输入，并返回更好地拟合数据的样条。结点默认放置在`X`的等距值上，但通过`knots`参数，我们可以选择将它们均匀分布到`X`的十分位数上，或者我们可以传递一个包含应用作结点的`X`的特定值的数组。
- en: Note
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The number, spacing, and position of the knots are arbitrarily set by the user
    and are the parameters that influence the shape of the splines the most. When
    using splines in regression models, we can optimize these parameters in a randomized
    search with cross-validation.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的数量、间距和位置由用户任意设置，这些是影响样条曲线形状的最主要参数。当在回归模型中使用样条曲线时，我们可以通过交叉验证的随机搜索来优化这些参数。
- en: With `fit()`, the transformer computes the knots of the splines. With `transform()`,
    it returns the array of B-splines. The transformer returns `n_splines=n_knots
    + degree –` `1`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `fit()` 函数，转换器计算样条曲线的节点。使用 `transform()` 函数，它返回 B 样条曲线的数组。转换器返回 `n_splines=n_knots
    + degree – 1`。
- en: Remember that, like most scikit-learn transformers, `SplineTransformer()` also
    now has the option to return `pandas` and polars DataFrames in addition to NumPy
    arrays, a behavior that can be modified through the `set_output()` method.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，像大多数 scikit-learn 转换器一样，`SplineTransformer()` 现在也有选项返回 `pandas` 和 polars
    DataFrames，除了 NumPy 数组之外，这种行为可以通过 `set_output()` 方法进行修改。
- en: Finally, we used `ColumnTransformer()` to derive splines from a subset of features.
    Because we set `remainder` to `passthrough`, `ColumnTransformer()` concatenated
    the features that were not used to obtain splines to the resulting matrix of splines.
    By doing this, we fitted a Ridge regression with the splines, plus the `MedInc`
    and `HouseAge` variables, and managed to improve the linear model’s performance.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `ColumnTransformer()` 从特征子集中导出样条曲线。因为我们把 `remainder` 设置为 `passthrough`，所以
    `ColumnTransformer()` 将未用于获取样条曲线的特征连接到结果矩阵中。通过这种方式，我们使用样条曲线、`MedInc` 和 `HouseAge`
    变量拟合了岭回归，并成功提高了线性模型的表现。
- en: See also
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'To find out more about the math underlying B-splines, check out the following
    articles:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 B 样条背后的数学知识，请查看以下文章：
- en: Perperoglou, et al. *A review of spline function procedures in R* ([https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/s12874-019-0666-3](https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/s12874-019-0666-3)).
    BMC Med Res Methodol 19, 46 (2019).
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Perperoglou 等人. *R 中样条函数过程综述* ([https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/s12874-019-0666-3](https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/s12874-019-0666-3))。BMC
    Med Res Methodol 19, 46 (2019)。
- en: Eilers and Marx. *Flexible Smoothing with B-splines and* *Penalties* ([https://projecteuclid.org/journals/statistical-science/volume-11/issue-2/Flexible-smoothing-with-B-splines-and-penalties/10.1214/ss/1038425655.full](https://projecteuclid.org/journals/statistical-science/volume-11/issue-2/Flexible-smoothing-with-B-splines-and-penalties/10.1214/ss/1038425655.full)).
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eilers 和 Marx. *使用 B 样条和惩罚进行灵活平滑* ([https://projecteuclid.org/journals/statistical-science/volume-11/issue-2/Flexible-smoothing-with-B-splines-and-penalties/10.1214/ss/1038425655.full](https://projecteuclid.org/journals/statistical-science/volume-11/issue-2/Flexible-smoothing-with-B-splines-and-penalties/10.1214/ss/1038425655.full))。
- en: 'For an example of how to use B-splines to model time series data, check out
    the following page in the `scikit-learn` library’s documentation: [https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#periodic-spline-features](https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#periodic-spline-features).'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解如何使用 B 样条对时间序列数据进行建模的示例，请查看 `scikit-learn` 库文档中的以下页面：[https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#periodic-spline-features](https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#periodic-spline-features)。
