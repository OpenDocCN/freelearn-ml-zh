["```py\n    #include <opencv2/core.hpp> \n    #include <opencv2/imgproc.hpp> \n    #include <opencv2/highgui.hpp> \n\n```", "```py\n    #include <opencv2/core.hpp> \n    #include <opencv2/highgui.hpp> \n\n```", "```py\n    cv::Mat image; // create an empty image \n\n```", "```py\n    std::cout << \"This image is \" << image.rows << \" x \"  \n              << image.cols << std::endl; \n\n```", "```py\n    image=  cv::imread(\"puppy.bmp\"); // read an input image \n\n```", "```py\n    if (image.empty()) {  // error handling \n      // no image has been created... \n      // possibly display an error message \n      // and quit the application  \n      ... \n    } \n\n```", "```py\n    // define the window (optional) \n    cv::namedWindow(\"Original Image\"); \n    // show the image  \n    cv::imshow(\"Original Image\", image); \n\n```", "```py\n    cv::Mat result; // we create another empty image \n    cv::flip(image,result,1); // positive for horizontal \n                              // 0 for vertical, \n                              // negative for both \n\n```", "```py\n    cv::namedWindow(\"Output Image\");    // the output window \n    cv::imshow(\"Output Image\", result); \n\n```", "```py\n    cv::waitKey(0); // 0 to indefinitely wait for a key pressed \n                    // specifying a positive value will wait for \n                    // the given amount of msec \n\n```", "```py\n    cv::imwrite(\"output.bmp\", result); // save result \n\n```", "```py\n    using namespace cv; \n\n```", "```py\n    // read the input image as a gray-scale image \n    image=  cv::imread(\"puppy.bmp\", cv::IMREAD_GRAYSCALE); \n\n```", "```py\n    // read the input image as a 3-channel color image \n    image=  cv::imread(\"puppy.bmp\", cv::IMREAD_COLOR); \n\n```", "```py\n    std::cout << \"This image has \"  \n              << image.channels() << \" channel(s)\"; \n\n```", "```py\n    cv::flip(image,image,1); // in-place processing \n\n```", "```py\n    void onMouse( int event, int x, int y, int flags, void* param); \n\n```", "```py\n    cv::setMouseCallback(\"Original Image\", onMouse,  \n                          reinterpret_cast<void*>(&image)); \n\n```", "```py\n    void onMouse( int event, int x, int y, int flags, void* param)  { \n\n      cv::Mat *im= reinterpret_cast<cv::Mat*>(param); \n\n      switch (event) {  // dispatch the event \n\n        case cv::EVENT_LBUTTONDOWN: // left mouse button down event \n\n          // display pixel value at (x,y) \n          std::cout << \"at (\" << x << \",\" << y << \") value is: \"  \n                    << static_cast<int>(               \n                            im->at<uchar>(cv::Point(x,y))) << std::endl; \n          break; \n      } \n    } \n\n```", "```py\n    cv::circle(image,                // destination image  \n               cv::Point(155,110),   // center coordinate \n               65,                   // radius   \n               0,                    // color (here black) \n               3);                   // thickness \n\n```", "```py\n    cv::putText(image,                    // destination image \n                \"This is a dog.\",         // text \n                cv::Point(40,200),        // text position \n                cv::FONT_HERSHEY_PLAIN,   // font type \n                2.0,                      // font scale \n                255,                      // text color (here white) \n                2);                       // text thickness \n\n```", "```py\n    #include <iostream> \n    #include <opencv2/core.hpp> \n    #include <opencv2/highgui.hpp> \n\n    // test function that creates an image \n    cv::Mat function() { \n       // create image \n       cv::Mat ima(500,500,CV_8U,50); \n       // return it \n       return ima; \n    } \n\n    int main() { \n      // create a new image made of 240 rows and 320 columns \n      cv::Mat image1(240,320,CV_8U,100); \n\n      cv::imshow(\"Image\", image1); // show the image \n      cv::waitKey(0); // wait for a key pressed \n\n      // re-allocate a new image \n      image1.create(200,200,CV_8U); \n      image1= 200; \n\n      cv::imshow(\"Image\", image1); // show the image \n      cv::waitKey(0); // wait for a key pressed \n\n      // create a red color image \n      // channel order is BGR \n      cv::Mat image2(240,320,CV_8UC3,cv::Scalar(0,0,255)); \n\n      // or: \n      // cv::Mat image2(cv::Size(320,240),CV_8UC3); \n      // image2= cv::Scalar(0,0,255); \n\n      cv::imshow(\"Image\", image2); // show the image \n      cv::waitKey(0); // wait for a key pressed \n\n      // read an image \n      cv::Mat image3=  cv::imread(\"puppy.bmp\");  \n\n      // all these images point to the same data block \n      cv::Mat image4(image3); \n      image1= image3; \n\n      // these images are new copies of the source image \n      image3.copyTo(image2); \n      cv::Mat image5= image3.clone(); \n\n      // transform the image for testing \n      cv::flip(image3,image3,1);  \n\n      // check which images have been affected by the processing \n      cv::imshow(\"Image 3\", image3);  \n      cv::imshow(\"Image 1\", image1);  \n      cv::imshow(\"Image 2\", image2);  \n      cv::imshow(\"Image 4\", image4);  \n      cv::imshow(\"Image 5\", image5);  \n      cv::waitKey(0); // wait for a key pressed \n\n      // get a gray-level image from a function \n      cv::Mat gray= function(); \n\n      cv::imshow(\"Image\", gray); // show the image \n      cv::waitKey(0); // wait for a key pressed \n\n      // read the image in gray scale \n      image1= cv::imread(\"puppy.bmp\", CV_LOAD_IMAGE_GRAYSCALE);  \n      image1.convertTo(image2,CV_32F,1/255.0,0.0); \n\n      cv::imshow(\"Image\", image2); // show the image \n      cv::waitKey(0); // wait for a key pressed \n\n      return 0; \n    } \n\n```", "```py\n    // create a new image made of 240 rows and 320 columns \n    cv::Mat image1(240,320,CV_8U,100); \n\n```", "```py\n    // create a red color image \n    // channel order is BGR \n    cv::Mat image2(240,320,CV_8UC3,cv::Scalar(0,0,255)); \n\n```", "```py\n    // create a non-initialized color image  \n    cv::Mat image2(cv::Size(320,240),CV_8UC3); \n\n```", "```py\n    // re-allocate a new image \n    // (only if size or type are different) \n    image1.create(200,200,CV_8U); \n\n```", "```py\n    // all these images point to the same data block \n    cv::Mat image4(image3); \n    image1= image3; \n\n```", "```py\n    // these images are new copies of the source image \n    image3.copyTo(image2); \n    cv::Mat image5= image3.clone(); \n\n```", "```py\n    // convert the image into a floating point image [0,1] \n    image1.convertTo(image2,CV_32F,1/255.0,0.0); \n\n```", "```py\n    cv::Mat function() { \n\n      // create image \n      cv::Mat ima(240,320,CV_8U,cv::Scalar(100)); \n      // return it \n      return ima; \n   } \n\n```", "```py\n      // get a gray-level image \n      cv::Mat gray= function(); \n\n```", "```py\n    class Test { \n      // image attribute \n      cv::Mat ima; \n      public: \n        // constructor creating a gray-level image \n        Test() : ima(240,320,CV_8U,cv::Scalar(100)) {} \n\n        // method return a class attribute, not a good idea... \n        cv::Mat method() { return ima; } \n    }; \n\n```", "```py\n      // a 3x3 matrix of double \n      cv::Matx33d matrix(3.0, 2.0, 1.0, \n                         2.0, 1.0, 3.0, \n                         1.0, 2.0, 3.0); \n      // a 3x1 matrix (a vector) \n      cv::Matx31d vector(5.0, 1.0, 3.0); \n      // multiplication \n      cv::Matx31d result = matrix*vector; \n\n```", "```py\n    // define image ROI at image bottom-right \n    cv::Mat imageROI(image,  \n              cv::Rect(image.cols-logo.cols,   // ROI coordinates \n                       image.rows-logo.rows, \n                       logo.cols,logo.rows));  // ROI size \n\n    // insert logo \n    logo.copyTo(imageROI); \n\n```", "```py\n    imageROI= image(cv::Range(image.rows-logo.rows,image.rows),  \n                    cv::Range(image.cols-logo.cols,image.cols)); \n\n```", "```py\n    cv::Mat imageROI= image.rowRange(start,end); \n\n```", "```py\n    cv::Mat imageROI= image.colRange(start,end); \n\n```", "```py\n    // define image ROI at image bottom-right \n    imageROI= image(cv::Rect(image.cols-logo.cols, \n                             image.rows-logo.rows, \n                             logo.cols,logo.rows)); \n    // use the logo as a mask (must be gray-level) \n    cv::Mat mask(logo); \n\n    // insert by copying only at locations of non-zero mask \n    logo.copyTo(imageROI,mask); \n\n```"]