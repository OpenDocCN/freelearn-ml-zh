["```py\ncv::blur(image,result, cv::Size(5,5)); // size of the filter \n\n```", "```py\ncv::GaussianBlur(image, result,  \n                 cv::Size(5,5), // size of the filter \n                 1.5);          // parameter controlling \n                                // the shape of the Gaussian\n\n```", "```py\n[0.0 0.0 0.00026 0.10645 0.78657 0.10645 0.00026 0.0 0.0]\n```", "```py\n[0.0076 0.03608 0.1096 0.2135 0.2667 0.2135 0.1096 0.0361 0.0076 ]\n```", "```py\n    cv::Mat gauss= cv::getGaussianKernel(9, sigma,CV_32F); \n\n```", "```py\n    // first remove high frequency component \n    cv::GaussianBlur(image,image,cv::Size(11,11),2.0); \n    // keep only 1 of every 4 pixels \n    cv::Mat reduced(image.rows/4,image.cols/4,CV_8U); \n    for (int i=0; i<reduced.rows; i++) \n      for (int j=0; j<reduced.cols; j++) \n        reduced.at<uchar>(i,j)= image.at<uchar>(i*4,j*4); \n\n```", "```py\n    cv::Mat reducedImage;            // to contain reduced image \n    cv::pyrDown(image,reducedImage); // reduce image size by half \n\n```", "```py\n    cv::Mat resizedImage;                 // to contain resized image \n    cv::resize(image, resizedImage,\n               cv::Size(image.cols/4,image.rows/4)); // 1/4 resizing \n\n```", "```py\n    cv::resize(image, resizedImage,  \n               cv::Size(), 1.0/4.0, 1.0/4.0); // 1/4 resizing \n\n```", "```py\n    cv::resize(reduced, newImage, cv::Size(), 3, 3, cv::INTER_NEAREST); \n\n```", "```py\n    cv::resize(reduced, newImage, cv::Size(), 4, 4, cv::INTER_LINEAR); \n\n```", "```py\n    cv::medianBlur(image, result, 5);  \n    // last parameter is size of the filter \n\n```", "```py\n    cv::Sobel(image,     // input \n              sobelX,    // output \n              CV_8U,     // image type \n              1, 0,      // kernel specification \n              3,         // size of the square kernel \n              0.4, 128); // scale and offset \n\n```", "```py\n    cv::Sobel(image,     // input \n              sobelY,    // output \n              CV_8U,     // image type \n              0, 1,      // kernel specification \n              3,         // size of the square kernel \n              0.4, 128); // scale and offset \n\n```", "```py\n    // Compute norm of Sobel \n    cv::Sobel(image,sobelX,CV_16S,1,0); \n    cv::Sobel(image,sobelY,CV_16S,0,1); \n    cv::Mat sobel; \n    //compute the L1 norm \n    sobel= abs(sobelX)+abs(sobelY); \n\n```", "```py\n    // Find Sobel max value \n    double sobmin, sobmax; \n    cv::minMaxLoc(sobel,&sobmin,&sobmax); \n    // Conversion to 8-bit image \n    // sobelImage = -alpha*sobel + 255 \n    cv::Mat sobelImage; \n    sobel.convertTo(sobelImage,CV_8U,-255./sobmax,255); \n\n```", "```py\n    cv::threshold(sobelImage, sobelThresholded,  \n                  threshold, 255, cv::THRESH_BINARY); \n\n```", "```py\n    cv::Sobel(image,         // input \n              sobel,         // output \n              image_depth,   // image type \n              xorder,yorder, // kernel specification   \n              kernel_size,   // size of the square kernel \n              alpha, beta);  // scale and offset \n\n```", "```py\n    // compute the L1 norm \n    sobel= abs(sobelX)+abs(sobelY); \n\n```", "```py\n    // Sobel must be computed in floating points \n    cv::Sobel(image,sobelX,CV_32F,1,0); \n    cv::Sobel(image,sobelY,CV_32F,0,1); \n    // Compute the L2 norm and direction of the gradient \n    cv::Mat norm, dir; \n    // Cartesian to polar transformation to get magnitude and angle \n    cv::cartToPolar(sobelX,sobelY,norm,dir); \n\n```", "```py\n    cv::Sobel(image,sobelX,CV_16S,1,0, CV_SCHARR); \n\n```", "```py\n    cv::Scharr(image,scharrX,CV_16S,1,0,3); \n\n```", "```py\n    class LaplacianZC { \n\n      private: \n      // laplacian \n      cv::Mat laplace; \n      // Aperture size of the laplacian kernel \n      int aperture; \n\n      public: \n\n      LaplacianZC() : aperture(3) {} \n\n      // Set the aperture size of the kernel \n      void setAperture(int a) { \n        aperture= a; \n      } \n\n      // Compute the floating point Laplacian \n      cv::Mat computeLaplacian(const cv::Mat& image) { \n\n        // Compute Laplacian \n        cv::Laplacian(image,laplace,CV_32F,aperture); \n        return laplace; \n    } \n\n```", "```py\n    // Get the Laplacian result in 8-bit image \n    // zero corresponds to gray level 128 \n    // if no scale is provided, then the max value will be \n    // scaled to intensity 255 \n    // You must call computeLaplacian before calling this \n    cv::Mat getLaplacianImage(double scale=-1.0) { \n      if (scale<0) { \n        double lapmin, lapmax; \n        // get min and max laplacian values \n        cv::minMaxLoc(laplace,&lapmin,&lapmax); \n        // scale the laplacian to 127 \n        scale= 127/ std::max(-lapmin,lapmax); \n      } \n\n      // produce gray-level image \n      cv::Mat laplaceImage; \n      laplace.convertTo(laplaceImage,CV_8U,scale,128); \n      return laplaceImage; \n    } \n\n```", "```py\n    // Compute Laplacian using LaplacianZC class \n    LaplacianZC laplacian; \n    laplacian.setAperture(7); // 7x7 laplacian \n    cv::Mat flap= laplacian.computeLaplacian(image); \n    laplace= laplacian.getLaplacianImage(); \n\n```", "```py\n    // Get a binary image of the zero-crossings \n    // laplacian image should be CV_32F \n    cv::Mat getZeroCrossings(cv::Mat laplace) { \n      // threshold at 0 \n      // negative values in black \n      // positive values in white \n      cv::Mat signImage; \n      cv::threshold(laplace,signImage,0,255,cv::THRESH_BINARY); \n\n      // convert the +/- image into CV_8U \n      cv::Mat binary; \n      signImage.convertTo(binary,CV_8U); \n      // dilate the binary image of +/- regions \n      cv::Mat dilated; \n      cv::dilate(binary,dilated,cv::Mat()); \n\n      // return the zero-crossing contours \n      return dilated-binary; \n    } \n\n```", "```py\n    cv::GaussianBlur(image,gauss20,cv::Size(),2.0); \n    cv::GaussianBlur(image,gauss22,cv::Size(),2.2); \n\n    // Compute a difference of Gaussians \n    cv::subtract(gauss22, gauss20, dog, cv::Mat(), CV_32F); \n\n    // Compute the zero-crossings of DoG \n    zeros= laplacian.getZeroCrossings(dog); \n\n```"]