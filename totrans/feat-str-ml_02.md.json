["```py\n!pip install pandas\n```", "```py\nimport pandas as pd\n```", "```py\nretail_data = pd.read_csv('/content/OnlineRetail.csv', \n```", "```py\n                          encoding= 'unicode_escape')\n```", "```py\nretail_data.sample(5)\n```", "```py\n##Convert 'InvoiceDate' to of type datetime\n```", "```py\nretail_data['InvoiceDate'] = pd.to_datetime(\n```", "```py\n    retail_data['InvoiceDate'], errors = 'coerce')\n```", "```py\n##Extract year and month information from 'InvoiceDate'\n```", "```py\nretail_data['yyyymm']=retail_data['InvoiceDate'].dt.strftime('%Y%m')\n```", "```py\n##Calculate revenue generated per order\n```", "```py\nretail_data['revenue'] = retail_data['UnitPrice'] * retail_data['Quantity']\n```", "```py\n## Calculate monthly revenue by aggregating the revenue on year month column  \n```", "```py\nrevenue_df = retail_data.groupby(['yyyymm'])['revenue'].sum().reset_index()\n```", "```py\nrevenue_df.head()\n```", "```py\n!pip install plotly\n```", "```py\nimport plotly.express as px\n```", "```py\n##Sort rows on year-month column\n```", "```py\nrevenue_df.sort_values( by=['yyyymm'], inplace=True)\n```", "```py\n## plot a bar graph with year-month on x-axis and revenue on y-axis, update x-axis is of type category.\n```", "```py\nfig = px.bar(revenue_df, x=\"yyyymm\", y=\"revenue\", \n```", "```py\n             title=\"Monthly Revenue\") \n```", "```py\nfig.update_xaxes(type='category')\n```", "```py\nfig.show()\n```", "```py\nactive_customer_df = retail_data.groupby(['yyyymm'])['CustomerID'].nunique().reset_index()\n```", "```py\nactive_customer_df.columns = ['yyyymm', \n```", "```py\n                              'No of Active customers']\n```", "```py\nactive_customer_df.head()\n```", "```py\n## Plot bar graph from revenue data frame with yyyymm column on x-axis and No. of active customers on the y-axis.\n```", "```py\nfig = px.bar(active_customer_df, x=\"yyyymm\", \n```", "```py\n             y=\"No of Active customers\", \n```", "```py\n             title=\"Monthly Active customers\") \n```", "```py\nfig.update_xaxes(type='category')\n```", "```py\nfig.show()\n```", "```py\nimport pandas as pd\n```", "```py\nfrom datetime import datetime, timedelta, date\n```", "```py\nfrom sklearn.cluster import KMeans\n```", "```py\n##Read the data and filter out data that belongs to country other than UK\n```", "```py\nretail_data = pd.read_csv('/content/OnlineRetail.csv', \n```", "```py\n                           encoding= 'unicode_escape')\n```", "```py\nretail_data['InvoiceDate'] = pd.to_datetime(\n```", "```py\n    retail_data['InvoiceDate'], errors = 'coerce')\n```", "```py\nuk_data = retail_data.query(\"Country=='United Kingdom'\").reset_index(drop=True)\n```", "```py\n## Create 3months and 6 months data frames\n```", "```py\nt1 = pd.Timestamp(\"2011-06-01 00:00:00.054000\")\n```", "```py\nt2 = pd.Timestamp(\"2011-03-01 00:00:00.054000\")\n```", "```py\nt3 = pd.Timestamp(\"2011-12-01 00:00:00.054000\")\n```", "```py\nuk_data_3m = uk_data[(uk_data.InvoiceDate < t1) & (uk_data.InvoiceDate >= t2)].reset_index(drop=True)\n```", "```py\nuk_data_6m = uk_data[(uk_data.InvoiceDate >= t1) & (uk_data.InvoiceDate < t3)].reset_index(drop=True)\n```", "```py\n## Calculate RFM values.\n```", "```py\nuk_data_3m['revenue'] = uk_data_3m['UnitPrice'] * uk_data_3m['Quantity']\n```", "```py\n# Calculating the max invoice date in data (Adding additional day to avoid 0 recency value)\n```", "```py\nmax_date = uk_data_3m['InvoiceDate'].max() + timedelta(days=1)\n```", "```py\nrfm_data = uk_data_3m.groupby(['CustomerID']).agg({\n```", "```py\n        'InvoiceDate': lambda x: (max_date - x.max()).days,\n```", "```py\n        'InvoiceNo': 'count',\n```", "```py\n        'revenue': 'sum'})\n```", "```py\nrfm_data.rename(columns={'InvoiceDate': 'Recency',\n```", "```py\n                         'InvoiceNo': 'Frequency',\n```", "```py\n                         'revenue': 'MonetaryValue'}, \n```", "```py\n                         inplace=True)\n```", "```py\n## Calculate RFM groups of customers \n```", "```py\nr_grp = pd.qcut(rfm_data['Recency'], q=4, \n```", "```py\n                labels=range(3,-1,-1))\n```", "```py\nf_grp = pd.qcut(rfm_data['Frequency'], q=4, \n```", "```py\n                labels=range(0,4))\n```", "```py\nm_grp = pd.qcut(rfm_data['MonetaryValue'], q=4, \n```", "```py\n                labels=range(0,4))\n```", "```py\nrfm_data = rfm_data.assign(R=r_grp.values).assign(F=f_grp.values).assign(M=m_grp.values)\n```", "```py\nrfm_data['R'] = rfm_data['R'].astype(int)\n```", "```py\nrfm_data['F'] = rfm_data['F'].astype(int)\n```", "```py\nrfm_data['M'] = rfm_data['M'].astype(int)\n```", "```py\nrfm_data['RFMScore'] = rfm_data['R'] + rfm_data['F'] + rfm_data['M']\n```", "```py\nrfm_data.groupby('RFMScore')['Recency','Frequency','MonetaryValue'].mean()\n```", "```py\n# segment customers.\n```", "```py\nrfm_data['Segment'] = 'Low-Value'\n```", "```py\nrfm_data.loc[rfm_data['RFMScore']>4,'Segment'] = 'Mid-Value' \n```", "```py\nrfm_data.loc[rfm_data['RFMScore']>6,'Segment'] = 'High-Value' \n```", "```py\nrfm_data = rfm_data.reset_index()\n```", "```py\n# Calculate revenue using the six month dataframe.\n```", "```py\nuk_data_6m['revenue'] = uk_data_6m['UnitPrice'] * uk_data_6m['Quantity']\n```", "```py\nrevenue_6m = uk_data_6m.groupby(['CustomerID']).agg({\n```", "```py\n        'revenue': 'sum'})\n```", "```py\nrevenue_6m.rename(columns={'revenue': 'Revenue_6m'}, \n```", "```py\n                  inplace=True)\n```", "```py\nrevenue_6m = revenue_6m.reset_index()\n```", "```py\nrevenue_6m = revenue_6m.dropna()\n```", "```py\n# Merge the 6m revenue data frame with RFM data.\n```", "```py\nmerged_data = pd.merge(rfm_data, revenue_6m, how=\"left\")\n```", "```py\nmerged_data.fillna(0)\n```", "```py\n# Create LTV cluster groups\n```", "```py\nmerged_data = merged_data[merged_data['Revenue_6m']<merged_data['Revenue_6m'].quantile(0.99)]\n```", "```py\nkmeans = KMeans(n_clusters=3)\n```", "```py\nkmeans.fit(merged_data[['Revenue_6m']])\n```", "```py\nmerged_data['LTVCluster'] = kmeans.predict(merged_data[['Revenue_6m']])\n```", "```py\nmerged_data.groupby('LTVCluster')['Revenue_6m'].describe()\n```", "```py\nfeature_data = pd.get_dummies(merged_data)\n```", "```py\nfeature_data.head(5)\n```", "```py\nfrom sklearn.metrics import classification_report, confusion_matrix\n```", "```py\nimport xgboost as xgb\n```", "```py\nfrom sklearn.model_selection import KFold, cross_val_score, train_test_split\n```", "```py\n#Splitting data into train and test data set.\n```", "```py\nX = feature_data.drop(['CustomerID', 'LTVCluster',\n```", "```py\n                       'Revenue_6m'], axis=1)\n```", "```py\ny = feature_data['LTVCluster']\n```", "```py\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1)\n```", "```py\nxgb_classifier = xgb.XGBClassifier(max_depth=5, objective='multi:softprob')\n```", "```py\nxgb_model = xgb_classifier.fit(X_train, y_train)\n```", "```py\ny_pred = xgb_model.predict(X_test)\n```", "```py\nprint(classification_report(y_test, y_pred))\n```"]