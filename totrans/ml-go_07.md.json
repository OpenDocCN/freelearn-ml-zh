["```py\n$ head AirPassengers.csv \ntime,AirPassengers\n1949.0,112\n1949.08333333,118\n1949.16666667,132\n1949.25,129\n1949.33333333,121\n1949.41666667,135\n1949.5,148\n1949.58333333,148\n1949.66666667,136\n```", "```py\n// Open the CSV file.\npassengersFile, err := os.Open(\"AirPassengers.csv\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer passengersFile.Close()\n\n// Create a dataframe from the CSV file.\npassengersDF := dataframe.ReadCSV(passengersFile)\n\n// As a sanity check, display the records to stdout.\n// Gota will format the dataframe for pretty printing.\nfmt.Println(passengersDF)\n```", "```py\n$ go build\n$ ./myprogram \n[144x2] DataFrame\n\n    time        AirPassengers\n 0: 1949.000000 112          \n 1: 1949.083333 118          \n 2: 1949.166667 132          \n 3: 1949.250000 129          \n 4: 1949.333333 121          \n 5: 1949.416667 135          \n 6: 1949.500000 148          \n 7: 1949.583333 148          \n 8: 1949.666667 136          \n 9: 1949.750000 119          \n    ...         ...          \n    <float>     <int>   \n```", "```py\n// Open the CSV file.\npassengersFile, err := os.Open(\"AirPassengers.csv\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer passengersFile.Close()\n\n// Create a dataframe from the CSV file.\npassengersDF := dataframe.ReadCSV(passengersFile)\n\n// Extract the number of passengers column.\nyVals := passengersDF.Col(\"AirPassengers\").Float()\n\n// pts will hold the values for plotting.\npts := make(plotter.XYs, passengersDF.Nrow())\n\n// Fill pts with data.\nfor i, floatVal := range passengersDF.Col(\"time\").Float() {\n    pts[i].X = floatVal\n    pts[i].Y = yVals[i]\n}\n\n// Create the plot.\np, err := plot.New()\nif err != nil {\n    log.Fatal(err)\n}\np.X.Label.Text = \"time\"\np.Y.Label.Text = \"passengers\"\np.Add(plotter.NewGrid())\n\n// Add the line plot points for the time series.\nl, err := plotter.NewLine(pts)\nif err != nil {\n    log.Fatal(err)\n}\nl.LineStyle.Width = vg.Points(1)\nl.LineStyle.Color = color.RGBA{B: 255, A: 255}\n\n// Save the plot to a PNG file.\np.Add(l)\nif err := p.Save(10*vg.Inch, 4*vg.Inch, \"passengers_ts.png\"); err != nil {\n    log.Fatal(err)\n}\n```", "```py\n// acf calculates the autocorrelation for a series\n// at the given lag.\nfunc acf(x []float64, lag int) float64 {\n\n    // Shift the series.\n    xAdj := x[lag:len(x)]\n    xLag := x[0 : len(x)-lag]\n\n    // numerator will hold our accumulated numerator, and\n    // denominator will hold our accumulated denominator.\n    var numerator float64\n    var denominator float64\n\n    // Calculate the mean of our x values, which will be used\n    // in each term of the autocorrelation.\n    xBar := stat.Mean(x, nil)\n\n    // Calculate the numerator.\n    for idx, xVal := range xAdj {\n        numerator += ((xVal - xBar) * (xLag[idx] - xBar))\n    }\n\n    // Calculate the denominator.\n    for _, xVal := range x {\n        denominator += math.Pow(xVal-xBar, 2)\n    }\n\n    return numerator / denominator\n}\n```", "```py\n// Open the CSV file.\npassengersFile, err := os.Open(\"AirPassengers.csv\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer passengersFile.Close()\n\n// Create a dataframe from the CSV file.\npassengersDF := dataframe.ReadCSV(passengersFile)\n\n// Get the time and passengers as a slice of floats.\npassengers := passengersDF.Col(\"AirPassengers\").Float()\n\n// Loop over various values of lag in the series.\nfmt.Println(\"Autocorrelation:\")\nfor i := 1; i < 11; i++ {\n\n    // Shift the series.\n    adjusted := passengers[i:len(passengers)]\n    lag := passengers[0 : len(passengers)-i]\n\n    // Calculate the autocorrelation.\n    ac := stat.Correlation(adjusted, lag, nil)\n    fmt.Printf(\"Lag %d period: %0.2f\\n\", i, ac)\n}\n```", "```py\n$ go build\n$ ./myprogram \nAutocorrelation:\nLag 1 period: 0.95\nLag 2 period: 0.88\nLag 3 period: 0.81\nLag 4 period: 0.75\nLag 5 period: 0.71\nLag 6 period: 0.68\nLag 7 period: 0.66\nLag 8 period: 0.66\nLag 9 period: 0.67\nLag 10 period: 0.70\n```", "```py\n// Open the CSV file.\npassengersFile, err := os.Open(\"AirPassengers.csv\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer passengersFile.Close()\n\n// Create a dataframe from the CSV file.\npassengersDF := dataframe.ReadCSV(passengersFile)\n\n// Get the time and passengers as a slice of floats.\npassengers := passengersDF.Col(\"AirPassengers\").Float()\n\n// Create a new plot, to plot our autocorrelations.\np, err := plot.New()\nif err != nil {\n    log.Fatal(err)\n}\n\np.Title.Text = \"Autocorrelations for AirPassengers\"\np.X.Label.Text = \"Lag\"\np.Y.Label.Text = \"ACF\"\np.Y.Min = 0\np.Y.Max = 1\n\nw := vg.Points(3)\n\n// Create the points for plotting.\nnumLags := 20\npts := make(plotter.Values, numLags)\n\n// Loop over various values of lag in the series.\nfor i := 1; i <= numLags; i++ {\n\n    // Calculate the autocorrelation.\n    pts[i-1] = acf(passengers, i)\n}\n\n// Add the points to the plot.\nbars, err := plotter.NewBarChart(pts, w)\nif err != nil {\n    log.Fatal(err)\n} \nbars.LineStyle.Width = vg.Length(0)\nbars.Color = plotutil.Color(1)\n\n// Save the plot to a PNG file.\np.Add(bars)\nif err := p.Save(8*vg.Inch, 4*vg.Inch, \"acf.png\"); err != nil {\n    log.Fatal(err)\n}ï¿¼\n```", "```py\n// pacf calculates the partial autocorrelation for a series\n// at the given lag.\nfunc pacf(x []float64, lag int) float64 {\n\n    // Create a regresssion.Regression value needed to train\n    // a model using github.com/sajari/regression.\n    var r regression.Regression\n    r.SetObserved(\"x\")\n\n    // Define the current lag and all of the intermediate lags.\n    for i := 0; i < lag; i++ {\n        r.SetVar(i, \"x\"+strconv.Itoa(i))\n    }\n\n    // Shift the series.\n    xAdj := x[lag:len(x)]\n\n    // Loop over the series creating the data set\n    // for the regression.\n    for i, xVal := range xAdj {\n\n        // Loop over the intermediate lags to build up\n        // our independent variables.\n        laggedVariables := make([]float64, lag)\n        for idx := 1; idx <= lag; idx++ {\n\n            // Get the lagged series variables.\n            laggedVariables[idx-1] = x[lag+i-idx]\n        }\n\n        // Add these points to the regression value.\n        r.Train(regression.DataPoint(xVal, laggedVariables))\n    }\n\n    // Fit the regression.\n    r.Run()\n\n    return r.Coeff(lag)\n}\n```", "```py\n// Open the CSV file.        \npassengersFile, err := os.Open(\"AirPassengers.csv\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer passengersFile.Close()\n\n// Create a dataframe from the CSV file.\npassengersDF := dataframe.ReadCSV(passengersFile)\n\n// Get the time and passengers as a slice of floats.\npassengers := passengersDF.Col(\"AirPassengers\").Float()\n\n// Loop over various values of lag in the series.\nfmt.Println(\"Partial Autocorrelation:\")\nfor i := 1; i < 11; i++ {\n\n    // Calculate the partial autocorrelation.\n    pac := pacf(passengers, i)\n    fmt.Printf(\"Lag %d period: %0.2f\\n\", i, pac)\n}\n```", "```py\n$ go build\n$ ./myprogram \nPartial Autocorrelation:\nLag 1 period: 0.96\nLag 2 period: -0.33\nLag 3 period: 0.20\nLag 4 period: 0.15\nLag 5 period: 0.26\nLag 6 period: -0.03\nLag 7 period: 0.20\nLag 8 period: 0.16\nLag 9 period: 0.57\nLag 10 period: 0.29\n```", "```py\n// as slices of floats.\npassengerVals := passengersDF.Col(\"AirPassengers\").Float()\ntimeVals := passengersDF.Col(\"time\").Float()\n\n// pts will hold the values for plotting.\npts := make(plotter.XYs, passengersDF.Nrow()-1)\n\n// differenced will hold our differenced values\n// that will be output to a new CSV file.\nvar differenced [][]string\ndifferenced = append(differenced, []string{\"time\", \"differenced_passengers\"})\n\n// Fill pts with data.\nfor i := 1; i < len(passengerVals); i++ {\n    pts[i-1].X = timeVals[i]\n    pts[i-1].Y = passengerVals[i] - passengerVals[i-1]\n    differenced = append(differenced, []string{\n        strconv.FormatFloat(timeVals[i], 'f', -1, 64),\n        strconv.FormatFloat(passengerVals[i]-passengerVals[i-1], 'f', -1, 64),\n    })\n}\n\n// Create the plot.\np, err := plot.New()\nif err != nil {\n    log.Fatal(err)\n}\np.X.Label.Text = \"time\"\np.Y.Label.Text = \"differenced passengers\"\np.Add(plotter.NewGrid())\n\n// Add the line plot points for the time series.\nl, err := plotter.NewLine(pts)\nif err != nil {\n    log.Fatal(err)\n}\nl.LineStyle.Width = vg.Points(1)\nl.LineStyle.Color = color.RGBA{B: 255, A: 255}\n\n// Save the plot to a PNG file.\np.Add(l)\nif err := p.Save(10*vg.Inch, 4*vg.Inch, \"diff_passengers_ts.png\"); err != nil {\n    log.Fatal(err)\n}\n\n// Save the differenced data out to a new CSV.\nf, err := os.Create(\"diff_series.csv\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer f.Close()\n\nw := csv.NewWriter(f)\nw.WriteAll(differenced)\n\nif err := w.Error(); err != nil {\n    log.Fatal(err)\n}\n```", "```py\n// autoregressive calculates an AR model for a series\n// at a given order.\nfunc autoregressive(x []float64, lag int) ([]float64, float64) {\n\n    // Create a regresssion.Regression value needed to train\n    // a model using github.com/sajari/regression.\n    var r regression.Regression\n    r.SetObserved(\"x\")\n\n    // Define the current lag and all of the intermediate lags.\n    for i := 0; i < lag; i++ {\n        r.SetVar(i, \"x\"+strconv.Itoa(i))\n    }\n\n    // Shift the series.\n    xAdj := x[lag:len(x)]\n\n    // Loop over the series creating the data set\n    // for the regression.\n    for i, xVal := range xAdj {\n\n        // Loop over the intermediate lags to build up\n        // our independent variables.\n        laggedVariables := make([]float64, lag)\n        for idx := 1; idx <= lag; idx++ {\n\n            // Get the lagged series variables.\n            laggedVariables[idx-1] = x[lag+i-idx]\n         }\n\n         // Add these points to the regression value.\n         r.Train(regression.DataPoint(xVal, laggedVariables))\n    }\n\n    // Fit the regression.\n    r.Run()\n\n    // coeff hold the coefficients for our lags.\n    var coeff []float64\n    for i := 1; i <= lag; i++ {\n        coeff = append(coeff, r.Coeff(i))\n    }\n\n    return coeff, r.Coeff(0)\n}\n```", "```py\n// Open the CSV file.\npassengersFile, err := os.Open(\"log_diff_series.csv\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer passengersFile.Close()\n\n// Create a dataframe from the CSV file.\npassengersDF := dataframe.ReadCSV(passengersFile)\n\n// Get the time and passengers as a slice of floats.\npassengers := passengersDF.Col(\"log_differenced_passengers\").Float()\n\n// Calculate the coefficients for lag 1 and 2 and\n// our error.\ncoeffs, intercept := autoregressive(passengers, 2)\n\n// Output the AR(2) model to stdout.\nfmt.Printf(\"\\nlog(x(t)) - log(x(t-1)) = %0.6f + lag1*%0.6f + lag2*%0.6f\\n\\n\", intercept, coeffs[0], coeffs[1])\n```", "```py\n$ go build\n$ ./myprogram \n\nlog(x(t)) - log(x(t-1)) = 0.008159 + lag1*0.234953 + lag2*-0.173682\n```", "```py\n// Open the log differenced dataset file.\ntransFile, err := os.Open(\"log_diff_series.csv\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer transFile.Close()\n\n// Create a CSV reader reading from the opened file.\ntransReader := csv.NewReader(transFile)\n\n// Read in all of the CSV records\ntransReader.FieldsPerRecord = 2\ntransData, err := transReader.ReadAll()\nif err != nil {\n    log.Fatal(err)\n}\n\n// Loop over the data predicting the transformed\n// observations.\nvar transPredictions []float64\nfor i, _ := range transData {\n\n    // Skip the header and the first two observations\n    // (because we need two lags to make a prediction).\n    if i == 0 || i == 1 || i == 2 {\n        continue\n    }\n\n    // Parse the first lag.\n    lagOne, err := strconv.ParseFloat(transData[i-1][1], 64)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Parse the second lag.\n    lagTwo, err := strconv.ParseFloat(transData[i-2][1], 64)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Predict the transformed variable with our trained AR model.\n    transPredictions = append(transPredictions, 0.008159+0.234953*lagOne-0.173682*lagTwo)\n}\n```", "```py\n// Open the original dataset file.\norigFile, err := os.Open(\"AirPassengers.csv\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer origFile.Close()\n\n// Create a CSV reader reading from the opened file.\norigReader := csv.NewReader(origFile)\n\n// Read in all of the CSV records\norigReader.FieldsPerRecord = 2\norigData, err := origReader.ReadAll()\nif err != nil {\n    log.Fatal(err)\n}\n\n// pts* will hold the values for plotting.\nptsObs := make(plotter.XYs, len(transPredictions))\nptsPred := make(plotter.XYs, len(transPredictions))\n\n// Reverse the transformation and calculate the MAE.\nvar mAE float64\nvar cumSum float64\nfor i := 4; i <= len(origData)-1; i++ {\n\n    // Parse the original observation.\n    observed, err := strconv.ParseFloat(origData[i][1], 64)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Parse the original date.        \n    date, err := strconv.ParseFloat(origData[i][0], 64)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Get the cumulative sum up to the index in\n    // the transformed predictions.\n    cumSum += transPredictions[i-4]\n\n    // Calculate the reverse transformed prediction.\n    predicted := math.Exp(math.Log(observed) + cumSum)\n\n    // Accumulate the MAE.\n    mAE += math.Abs(observed-predicted) / float64(len(transPredictions))\n\n    // Fill in the points for plotting.\n    ptsObs[i-4].X = date\n    ptsPred[i-4].X = date\n    ptsObs[i-4].Y = observed\n    ptsPred[i-4].Y = predicted\n}\n```", "```py\n// Output the MAE to standard out.\nfmt.Printf(\"\\nMAE = %0.2f\\n\\n\", mAE)\n\n// Create the plot.\np, err := plot.New()\nif err != nil {\n    log.Fatal(err)\n}\np.X.Label.Text = \"time\"\np.Y.Label.Text = \"passengers\"\np.Add(plotter.NewGrid())\n\n// Add the line plot points for the time series.\nlObs, err := plotter.NewLine(ptsObs)\nif err != nil {\n    log.Fatal(err)\n}\nlObs.LineStyle.Width = vg.Points(1)\n\nlPred, err := plotter.NewLine(ptsPred)\nif err != nil {\n    log.Fatal(err)\n}\nlPred.LineStyle.Width = vg.Points(1)\nlPred.LineStyle.Dashes = []vg.Length{vg.Points(5), vg.Points(5)}\n\n// Save the plot to a PNG file.\np.Add(lObs, lPred)\np.Legend.Add(\"Observed\", lObs)\np.Legend.Add(\"Predicted\", lPred)\nif err := p.Save(10*vg.Inch, 4*vg.Inch, \"passengers_ts.png\"); err != nil {\n    log.Fatal(err)\n}\n```", "```py\n$ go build\n$ ./myprogram \n\nMAE = 355.20\n```", "```py\n// Initialize an AnomalyzerConf value with\n// configurations such as which anomaly detection\n// methods we want to use.\nconf := &anomalyzer.AnomalyzerConf{\n    Sensitivity: 0.1,\n    UpperBound:  5,\n    LowerBound:  anomalyzer.NA, // ignore the lower bound\n    ActiveSize:  1,\n    NSeasons:    4,\n    Methods:     []string{\"diff\", \"fence\", \"highrank\", \"lowrank\", \"magnitude\"},\n}\n\n// Create a time series of periodic observations\n// as a slice of floats.  This could come from a\n// database or file, as utilized in earlier examples.\nts := []float64{0.1, 0.2, 0.5, 0.12, 0.38, 0.9, 0.74}\n\n// Create a new anomalyzer based on the existing\n// time series values and configuration.\nanom, err := anomalyzer.NewAnomalyzer(conf, ts)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Supply a new observed value to the Anomalyzer.\n// The Anomalyzer will analyze the value in reference\n// to pre-existing values in the series and output\n// a probability of the value being anomalous.\nprob := anom.Push(15.2)\nfmt.Printf(\"Probability of 15.2 being anomalous: %0.2f\\n\", prob)\n\nprob = anom.Push(0.43)\nfmt.Printf(\"Probability of 0.33 being anomalous: %0.2f\\n\", prob)\n```", "```py\n$ go build\n$ ./myprogram\nProbability of 15.2 being anomalous: 0.98\nProbability of 0.33 being anomalous: 0.80\n```"]