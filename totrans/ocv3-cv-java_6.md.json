["```py\npublic interface VideoProcessor {\n  public Mat process(Mat inputImage);\n}\n```", "```py\nwhile (true){  \n  capture.read(currentImage);  \n  if( !currentImage.empty() ){\n    foregroundImage = videoProcessor.process(currentImage);\n    ... update Graphical User Interfaces ...\n    Thread.sleep(10);\n  }\n}\n```", "```py\nCore.absdiff(backgroundImage,inputImage , foregroundImage);\n```", "```py\npublic class AbsDifferenceBackground implements VideoProcessor {\n  private Mat backgroundImage;\n\n  public AbsDifferenceBackground(Mat backgroundImage) {\n    this.backgroundImage = backgroundImage;\n  }\n\n  public Mat process(Mat inputImage) {\n    Mat foregroundImage = new Mat();\n    Core.absdiff(backgroundImage,inputImage , foregroundImage);\n    return foregroundImage;\n  }\n\n}\n```", "```py\npublic Mat process(Mat inputImage) {\n  Mat foregroundThresh = new Mat();\n  // Firstly, convert to gray-level image, yields good results with performance\n  Imgproc.cvtColor(inputImage, inputGray, Imgproc.COLOR_BGR2GRAY);\n  // initialize background to 1st frame, convert to floating type\n  if (accumulatedBackground.empty())\n    inputGray.convertTo(accumulatedBackground, CvType.CV_32F);\n\n  // convert background to 8U, for differencing with input image\n  accumulatedBackground.convertTo(backImage,CvType.CV_8U);\n  // compute difference between image and background\n  Core.absdiff(backImage,inputGray,foreground);\n\n  // apply threshold to foreground image\n  Imgproc.threshold(foreground,foregroundThresh, threshold,255, Imgproc.THRESH_BINARY_INV);\n\n  // accumulate background\n  Mat inputFloating = new Mat();\n  inputGray.convertTo(inputFloating, CvType.CV_32F);\n  Imgproc.accumulateWeighted(inputFloating, accumulatedBackground,learningRate, foregroundThresh);\n\n  return negative(foregroundThresh);\n}\n\nprivate Mat negative(Mat foregroundThresh) {\n  Mat result = new Mat();\n  Mat white = foregroundThresh.clone();\n  white.setTo(new Scalar(255.0));\n  Core.subtract(white, foregroundThresh,  result);\n  return result;\n}\n```", "```py\npublic class MixtureOfGaussianBackground implements VideoProcessor {\n  privateBackgroundSubtractorMOG2 mog=  org.opencv.video.Video. createBackgroundSubtractorMOG2();\n  private Mat foreground = new Mat();\n  private double learningRate = 0.01;\n\n  public Mat process(Mat inputImage) {\n    mog.apply(inputImage, foreground, learningRate);\n    return foreground;\n  }\n}\n```", "```py\nVideo.createBackgroundSubtractorMOG2 (int history, double varThreshold, boolean detectShadows)\n```", "```py\npublic static void findContours(Mat image,\n                java.util.List<MatOfPoint> contours,\n                Mat hierarchy,\n                int mode,\n                int method)\n```", "```py\npublic static void drawContours(Mat image,\n                java.util.List<MatOfPoint> contours,\n                int contourIdx,\n                Scalar color)\n```", "```py\nprotected void drawContours() {\n  Mat contourMat = binary.clone();\n  List<MatOfPoint> contours = new ArrayList<MatOfPoint>();\n  int thickness = (fillFlag.equals(onFillString))?-1:2;\n\n  Imgproc.findContours(contourMat, contours, new Mat(),\n  Imgproc.CHAIN_APPROX_NONE,Imgproc.CHAIN_APPROX_SIMPLE);\n  for(int i=0;i<contours.size();i++){\n    MatOfPoint currentContour = contours.get(i);\n    double currentArea = Imgproc.contourArea(currentContour);\n\n    if(currentArea > areaThreshold){\n      Imgproc.drawContours(image, contours, i, new Scalar(0,255,0), thickness);\n      if(boundingBoxString.equals(enclosingType)){\n        drawBoundingBox(currentContour);\n      }\n      else if (circleString.equals(enclosingType)){\n      drawEnclosingCircle(currentContour);\n      }\n      else if (convexHullString.equals(enclosingType)){\n        drawConvexHull(currentContour);\n      }\n    }\n    else{\n      Imgproc.drawContours(image, contours, i, new Scalar(0,0,255), thickness);\n    }\n  }\n  updateView();\n}\n```", "```py\nprivate void drawBoundingBox(MatOfPoint currentContour) {\n  Rect rectangle = Imgproc.boundingRect(currentContour);\n  Imgproc.rectangle(image, rectangle.tl(), rectangle.br(), new Scalar(255,0,0),1);\n}\n\nprivate void drawEnclosingCircle(MatOfPoint currentContour) {\n  float[] radius = new float[1];\n  Point center = new Point();\n\n  MatOfPoint2f currentContour2f = new MatOfPoint2f();\n  currentContour.convertTo(currentContour2f, CvType.CV_32FC2);\n  Imgproc.minEnclosingCircle(currentContour2f, center, radius);\n  Imgproc.circle(image, center, (int) radius[0], new Scalar(255,0,0));\n}\n\nprivate void drawConvexHull(MatOfPoint currentContour) {\n  MatOfInt hull = new MatOfInt();\n  Imgproc.convexHull(currentContour, hull);\n\n  List<MatOfPoint> hullContours = new ArrayList<MatOfPoint>();\n  MatOfPoint hullMat = new MatOfPoint();\n  hullMat.create((int)hull.size().height,1,CvType.CV_32SC2);\n\n  for(int j = 0; j < hull.size().height ; j++){\n    int index = (int)hull.get(j, 0)[0];\n    double[] point = new double[] {\n      currentContour.get(index, 0)[0], currentContour.get(index, 0)[1]\n    };\n    hullMat.put(j, 0, point);\n  }\n  hullContours.add(hullMat);\n  Imgproc.drawContours(image, hullContours, 0, new Scalar(128,0,0), 2);\n}\n```", "```py\n    cmake -DBUILD_SHARED_LIBS=OFF ..\n\n    ```", "```py\n    cmake -DBUILD_SHARED_LIBS=OFF .. -D WITH_OPENNI\n    ```", "```py\n      Video I/O:\n        Video for Windows:           YES\n        DC1394 1.x:                  NO\n        DC1394 2.x:                  NO\n        FFMPEG:                      YES (prebuilt binaries)\n          codec:                     YES (ver 55.18.102)\n          format:                    YES (ver 55.12.100)\n          util:                      YES (ver 52.38.100)\n          swscale:                   YES (ver 2.3.100)\n          gentoo-style:              YES\n     OpenNI:                      YES (ver 1.5.7, build 10)\n     OpenNI PrimeSensor Modules:  YES (C:/Program Files (x86)/PrimeSense/Sensor/Bin/XnCore.dll)\n        PvAPI:                       NO\n        GigEVisionSDK:               NO\n        DirectShow:                  YES\n        Media Foundation:            NO\n        XIMEA:                       NO\n    ```", "```py\n<dependency>\n  <groupId>org.javaopencvbook</groupId>\n  <artifactId>opencvjar-kinect-runtime</artifactId>\n  <version>2.4.7</version>\n  <classifier>natives-windows-x86</classifier>\n</dependency>\n```", "```py\nVideoCapture capture = new VideoCapture(CV_CAP_OPENNI);\ncapture.grab();\ncapture.retrieve( depthMap,  CV_CAP_OPENNI_DEPTH_MAP);\ncapture.retrieve(colorImage, CV_CAP_OPENNI_BGR_IMAGE);\n```", "```py\nwhile(true){\n  capture.grab();\n  capture.retrieve( depthMap, CV_CAP_OPENNI_DISPARITY_MAP);\n  disparityImage = depthMap.clone();\n  capture.retrieve(colorImage, CV_CAP_OPENNI_BGR_IMAGE);\n  workingBackground = resizedBackground.clone();\n  Imgproc.threshold(disparityImage, disparityThreshold, gui.getLevel(), 255.0f, Imgproc.THRESH_BINARY);\n  maskedImage.setTo(new Scalar(0,0,0));\n  colorImage.copyTo(maskedImage,disparityThreshold);\n  maskedImage.copyTo(workingBackground,maskedImage);\n  renderOutputAccordingToMode(disparityImage, disparityThreshold,\n  colorImage, resizedBackground, workingBackground, gui);\n}\n```"]