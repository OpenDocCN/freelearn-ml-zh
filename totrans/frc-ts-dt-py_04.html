<html><head></head><body>
<div id="_idContainer108">
<h1 class="chapter-number" id="_idParaDest-52"><a id="_idTextAnchor197"/><a id="_idTextAnchor198"/><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-53"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.2.1">Handling Non-Daily Data</span></h1>
<p><span class="koboSpan" id="kobo.3.1">When Prophet was first released, it was assumed all data would be collected on a daily scale, with one row of data per day. </span><span class="koboSpan" id="kobo.3.2">It has since grown to handle many different granularities of data, but because of its historical conventions, there are a few things to be cautious of when working with non-daily data </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">in Prophet.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, you will look at monthly data (and in fact, this is applicable to any data that is measured in timeframes greater than a day) and see how to change the frequency of predictions to avoid unexpected results. </span><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.6.1">You will also look at hourly data and observe an additional component in the components plot. </span><span class="koboSpan" id="kobo.6.2">Finally, you will learn how to handle data that has regular gaps along the </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">time axis.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">This chapter will cover </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">Using </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">monthly data</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Using </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">sub-daily data</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Using data with </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">regular gaps</span></span></li>
</ul>
<h1 id="_idParaDest-54"><a id="_idTextAnchor202"/><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.16.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.17.1">The data files and code for examples in this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">at </span><a id="_idTextAnchor204"/></span><a href="https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition"><span class="No-Break"><span class="koboSpan" id="kobo.19.1">https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.20.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">Please refer to the </span><em class="italic"><span class="koboSpan" id="kobo.22.1">Preface</span></em><span class="koboSpan" id="kobo.23.1"> of this book for the technical requirements necessary to run the </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">code examples.</span></span></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor205"/><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.25.1">Using monthly data</span></h1>
<p><span class="koboSpan" id="kobo.26.1">In </span><a href="B19630_02.xhtml#_idTextAnchor104"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.27.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.28.1">, </span><em class="italic"><span class="koboSpan" id="kobo.29.1">Getting Started with Prophet</span></em><span class="koboSpan" id="kobo.30.1">, we built our first Prophet model using </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.31.1">the</span><a id="_idTextAnchor207"/> <strong class="source-inline"><span class="koboSpan" id="kobo.32.1">Mauna Loa</span></strong><span class="koboSpan" id="kobo.33.1"> dataset. </span><span class="koboSpan" id="kobo.33.2">The data was reported daily, which is what Prophet expects by default and is therefore why we did not need to change any of Prophet’s default parameters. </span><span class="koboSpan" id="kobo.33.3">In this next example, though, let’s take a look at a new set of data that is not reported every day, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">Air Passengers</span></strong><span class="koboSpan" id="kobo.35.1"> dataset, to see how Prophet handles this difference in </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">data granularity.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">This is a </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.38.1">classic time series dataset spanning 1949 through 1960. </span><span class="koboSpan" id="kobo.38.2">It counts the number of passengers on commercial airlines each month during that period of explosive growth in the industry. </span><span class="koboSpan" id="kobo.38.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">Air Passengers</span></strong><span class="koboSpan" id="kobo.40.1"> dataset, in contrast to the Mauna Loa dataset, has one observation per month. </span><span class="koboSpan" id="kobo.40.2">What happens if we attempt to predict </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">future dates?</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">Let’s create a model and plot the forecast to see what happens. </span><span class="koboSpan" id="kobo.42.2">We begin as we did with the Mauna Loa example, by importing the necessary libraries and loading our data into a properly </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">formatted DataFrame:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.44.1">
import pandas as pd
import matplotlib.pyplot as plt
from prophet import Prophe</span><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.45.1">t
df = pd.read_csv('AirPassengers.csv')
df['Month'] = pd.to_datetime(df['Month'])
df.columns = ['ds', 'y']</span></pre>
<p><span class="koboSpan" id="kobo.46.1">Before building ou</span><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.47.1">r model, let’s just take a look at the first few rows to ensure that our DataFrame looks </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">as expected:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.49.1">
df.head()</span></pre>
<p><span class="koboSpan" id="kobo.50.1">You should now see </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">this output:</span></span><a id="_idTextAnchor210"/></p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<span class="koboSpan" id="kobo.52.1"><img alt="Figure 4.1 – The Air Passengers DataFrame" src="image/Fig_4.1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.53.1">Figure 4.1 – The Air Passengers DataFrame</span></p>
<p><span class="koboSpan" id="kobo.54.1">The data </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.55.1">is reported on a monthly basis, with one measurement for each month. </span><span class="koboSpan" id="kobo.55.2">Passenger numbers are reported per thousand, which means that the first row indicates that 112,000 commercial passengers took to the skies during the month beginning January </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">1, 194</span><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.57.1">9.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">Just as we did with Mauna Loa in the previous chapter, we will next instantiate our model and fit it. </span><span class="koboSpan" id="kobo.58.2">With this </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">Air Passengers</span></strong><span class="koboSpan" id="kobo.60.1"> dataset, we will set </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">seasonality_mode</span></strong><span class="koboSpan" id="kobo.62.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">'multiplicative'</span></strong><span class="koboSpan" id="kobo.64.1">, but don’t concern yourself with this for now—we’l</span><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.65.1">l cover it in </span><a href="B19630_05.xhtml#_idTextAnchor254"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.66.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.67.1">, </span><em class="italic"><span class="koboSpan" id="kobo.68.1">Working with</span></em> <em class="italic"><span class="koboSpan" id="kobo.69.1">Seasonality</span></em><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">Next, we send our data to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">fit</span></strong><span class="koboSpan" id="kobo.72.1"> method and then make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">future</span></strong><span class="koboSpan" id="kobo.74.1"> DataFrame. </span><span class="koboSpan" id="kobo.74.2">Let’s forecast </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">5</span></strong><span class="koboSpan" id="kobo.76.1"> years. </span><span class="koboSpan" id="kobo.76.2">Finally, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">predict</span></strong><span class="koboSpan" id="kobo.78.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">future</span></strong><span class="koboSpan" id="kobo.80.1"> and then plot the forecast to see how </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">we did:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.82.1">
model = Prophet(seasonality_mode='multiplicative')
model.fit(df)
future = model.make_future_dataframe(periods=365 * 5)
forecast = model.predict(future)
fig = model.plot(forecast)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.83.1">As you can see, we created our </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">future</span></strong><span class="koboSpan" id="kobo.85.1"> DataFrame with </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">5</span></strong><span class="koboSpan" id="kobo.87.1"> years of daily data, having provided Prophet only with monthly data. </span><span class="koboSpan" id="kobo.87.2">Prophet is able to apply its seasonality calculations appropriately on the first day of each month, for which it has good training data. </span><span class="koboSpan" id="kobo.87.3">For the remaining days, though, it doesn’t quite know what to do and overfits its seasonality curve in wild and unpredictable ways, as can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">following graph:</span></span><a id="_idTextAnchor213"/></p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<span class="koboSpan" id="kobo.89.1"><img alt="Figure 4.2 – Future forecast with daily frequency" src="image/Fig_4.2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.90.1">Figure 4.2 – Future forecast with daily frequency</span></p>
<p><span class="koboSpan" id="kobo.91.1">We can fix </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.92.1">this by instructing Prophet to only forecast on a monthly scale, to match the monthly data it is trained on. </span><span class="koboSpan" id="kobo.92.2">We need to specify a frequency in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">make_future_dataframe</span></strong><span class="koboSpan" id="kobo.94.1"> method, an</span><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.95.1">d we do this by passing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">freq</span></strong><span class="koboSpan" id="kobo.97.1"> argument. </span><span class="koboSpan" id="kobo.97.2">We must also update </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">periods</span></strong><span class="koboSpan" id="kobo.99.1"> because although we are still forecasting </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">5</span></strong><span class="koboSpan" id="kobo.101.1"> years into the future, we only want </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">12</span></strong><span class="koboSpan" id="kobo.103.1"> entries per year, one for </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">each month:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.105.1">
model = Prophet(seasonality_mode='multiplicative')
model.fit(df)
future = model.make_future_dataframe(periods=12 * 5,
                                     freq='MS')
forecast = model.predict(future)
fig = model.plot(forecast)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.106.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">freq</span></strong><span class="koboSpan" id="kobo.108.1"> argument accepts anything that pandas identifies as a frequency string. </span><span class="koboSpan" id="kobo.108.2">In this case, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">'MS'</span></strong><span class="koboSpan" id="kobo.110.1">, meaning </span><em class="italic"><span class="koboSpan" id="kobo.111.1">month start</span></em><span class="koboSpan" id="kobo.112.1">. </span><span class="koboSpan" id="kobo.112.2">Here is the output of that code block, showing the </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.113.1">plotted forecast now that Prophet has been instructed to predict only on the first day of </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">each month</span><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.115.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<span class="koboSpan" id="kobo.116.1"><img alt="Figure 4.3 – Future forecast with monthly frequency" src="image/Fig_4.3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.117.1">Figure 4.3 – Future forecast with monthly frequency</span></p>
<p><span class="koboSpan" id="kobo.118.1">That’s muc</span><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.119.1">h better, exactly what we might expect the forecast to look like. </span><span class="koboSpan" id="kobo.119.2">By feeding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">freq</span></strong><span class="koboSpan" id="kobo.121.1"> argument to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">make_future_dataframe</span></strong><span class="koboSpan" id="kobo.123.1"> method, we do not make the mistake of asking Prophet to forecast dates for which it has no training knowledge. </span><span class="koboSpan" id="kobo.123.2">By default, the frequency is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">'D'</span></strong><span class="koboSpan" id="kobo.125.1">, for </span><em class="italic"><span class="koboSpan" id="kobo.126.1">daily</span></em><span class="koboSpan" id="kobo.127.1">, and our periods are the number of days we want to forecast. </span><span class="koboSpan" id="kobo.127.2">Whenever changing the frequency to some other setting, be sure to set your periods</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.128.1"> to the </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">same scale.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">Now let’s see what changes when we use data on a sub-daily scale. </span><span class="koboSpan" id="kobo.130.2">To do that, I’ll introduce a new </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">dataset: Divv</span><a id="_idTextAnchor217"/><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.132.1">y.</span></span></p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.133.1">Using sub-daily data</span></h1>
<p><span class="koboSpan" id="kobo.134.1">In this section, </span><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.135.1">we will be</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.136.1"> using data from the </span><em class="italic"><span class="koboSpan" id="kobo.137.1">Divvy bike share program</span></em><span class="koboSpan" id="kobo.138.1"> in Chicago, Illinois. </span><span class="koboSpan" id="kobo.138.2">The data contains the number of bicycle rides taken each hour from the beginning of 2014 through to the end of 2018 and exhibits a general increasing trend along with very strong yearly seasonality. </span><span class="koboSpan" id="kobo.138.3">Because it is hourly data and there are very few rides overnight (sometimes zero per hour), the data does show a density of measurements at the </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">low en</span><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.140.1">d:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<span class="koboSpan" id="kobo.141.1"><img alt="Figure 4.4 – ﻿Number of Divvy rides per hour" src="image/Fig_4.4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.142.1">Figure 4.4 – Number of Divvy rides per hour</span></p>
<p><span class="koboSpan" id="kobo.143.1">Using </span><strong class="bold"><span class="koboSpan" id="kobo.144.1">sub-daily data</span></strong><span class="koboSpan" id="kobo.145.1"> such as </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.146.1">this is much the same as using </span><strong class="bold"><span class="koboSpan" id="kobo.147.1">super-daily data</span></strong><span class="koboSpan" id="kobo.148.1">, requiring </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.149.1">what we did with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">Air Passengers</span></strong><span class="koboSpan" id="kobo.151.1"> data previously. </span><span class="koboSpan" id="kobo.151.2">You as the analyst need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">freq</span></strong><span class="koboSpan" id="kobo.153.1"> argument and adjust the periods in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">make_future_dataframe</span></strong><span class="koboSpan" id="kobo.155.1"> method, and Prophet will do the rest. </span><span class="koboSpan" id="kobo.155.2">If Prophet sees at least two days of data and the spacing between data is less than one day, it will fit </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">daily seasonality.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">Let’s see this in action by making a simple forecast. </span><span class="koboSpan" id="kobo.157.2">We already imported the necessary libraries in the previous example, so let’s continue by loading the new data and adding it to </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">our DataFrame:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.159.1">
data = pd.read_csv('divvy_hourly.csv')
df = pd.DataFrame({'ds': pd.to_datetime(data['date']),
                   'y': data['rides']})</span></pre>
<p><span class="koboSpan" id="kobo.160.1">Next, we continue as we did in the previous example by instantiating our model (again, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">seasonality_mode='multiplicative'</span></strong><span class="koboSpan" id="kobo.162.1">, and again, not worrying about it for now) before fitting our model. </span><span class="koboSpan" id="kobo.162.2">When we create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">future</span></strong><span class="koboSpan" id="kobo.164.1"> DataFrame, we again need to set a frequency but this time we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">'h'</span></strong><span class="koboSpan" id="kobo.166.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">for hourly.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">Now that our </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.169.1">frequen</span><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.170.1">cy is hourly, we need to adjust our period to match, so we multiply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">365</span></strong><span class="koboSpan" id="kobo.172.1">-day forecast we want by </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">24</span></strong><span class="koboSpan" id="kobo.174.1"> hours </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">per day:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.176.1">
model = Prophet(seasonality_mode='multiplicative')
model.fit(df)
future = model.make_future_dataframe(periods=365 * 24,
                                     freq='h')</span></pre>
<p><span class="koboSpan" id="kobo.177.1">Finally, we will predict our </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">future</span></strong><span class="koboSpan" id="kobo.179.1"> DataFrame. </span><span class="koboSpan" id="kobo.179.2">With our forecast complete, we will plot it with the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">plot</span></strong><span class="koboSpan" id="kobo.181.1"> function and then the components in the second </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">plot</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.183.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.184.1">
forecast = model.predict(future)
fig = model.plot(forecast)
plt.show()
fig2 = model.plot_components(forecast)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.185.1">The first of those two plots is the forecast </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">shown h</span><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.187.1">ere:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer100">
<span class="koboSpan" id="kobo.188.1"><img alt="Figure 4.5 – Divvy forecast plot" src="image/Fig_4.5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.189.1">Figure 4.5 – Divvy forecast plot</span></p>
<p><span class="koboSpan" id="kobo.190.1">The forecast </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.191.1">inclu</span><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.192.1">des a rather large amount of uncertainty. </span><span class="koboSpan" id="kobo.192.2">To understand why, we need to look at the components plot as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.193.1">Figure </span><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.194.1">4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.195.1">.6</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer101">
<span class="koboSpan" id="kobo.197.1"><img alt="Figure 4.6 – Divvy components plot" src="image/Fig_4.6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.198.1">Figure 4.6 – Divvy components plot</span></p>
<p><span class="koboSpan" id="kobo.199.1">There</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.200.1"> are a few things to note about this series of plots. </span><span class="koboSpan" id="kobo.200.2">Starting from the uppermost plot, the </span><strong class="bold"><span class="koboSpan" id="kobo.201.1">trend</span></strong><span class="koboSpan" id="kobo.202.1"> plot, we can see that it still exhibits annual periodicity. </span><span class="koboSpan" id="kobo.202.2">Why wasn’t this captured in the </span><strong class="bold"><span class="koboSpan" id="kobo.203.1">yearly</span></strong><span class="koboSpan" id="kobo.204.1"> seasonality plot? </span><span class="koboSpan" id="kobo.204.2">Unfortunately, this data contains some very complex seasonalities that Prophet is unable to </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">fully model.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">In particular, the </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">daily</span></strong><span class="koboSpan" id="kobo.208.1"> seasonality itself is seasonal within the year. </span><span class="koboSpan" id="kobo.208.2">It’s seasonality within seasonality. </span><span class="koboSpan" id="kobo.208.3">The daily seasonality rises in the day and falls in the night, but the amount of the increase is dependent upon the time of year, and Prophet is not built to capture this type of seasonality.</span><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.209.1"> This is what causes so much forecast uncertainty. </span><span class="koboSpan" id="kobo.209.2">In later chapters, we will learn a few techniques to </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">control this.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">Next, we look at the </span><strong class="bold"><span class="koboSpan" id="kobo.212.1">weekly</span></strong><span class="koboSpan" id="kobo.213.1"> seasonality plot. </span><span class="koboSpan" id="kobo.213.2">In contrast to the Mauna Loa example in </span><a href="B19630_02.xhtml#_idTextAnchor104"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.214.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.215.1">, </span><em class="italic"><span class="koboSpan" id="kobo.216.1">Getting Started with Prophet</span></em><span class="koboSpan" id="kobo.217.1"> (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.218.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.219.1">.5</span></em><span class="koboSpan" id="kobo.220.1">), this plot displays a single curved line. </span><span class="koboSpan" id="kobo.220.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">Mauna Loa</span></strong><span class="koboSpan" id="kobo.222.1"> plot featured several straight-line segments. </span><span class="koboSpan" id="kobo.222.2">Also, the plot goes from Sunday to Sunday, whereas the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">Mauna Loa</span></strong><span class="koboSpan" id="kobo.224.1"> plot went from Sunday to Saturday. </span><span class="koboSpan" id="kobo.224.2">Both of these changes reflect the more continuous nature of </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">hourly data.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">When we only had daily data, as we did with Mauna Loa, the weekly seasonality only needed to show the effect of each day (although, under the hood, it was still a continuous model). </span><span class="koboSpan" id="kobo.226.2">But now that we have hourly data, it is important to see the continuous effect. </span><span class="koboSpan" id="kobo.226.3">We are shown 12:00:00 a.m. </span><span class="koboSpan" id="kobo.226.4">on Sunday through 11:59:59 p.m. </span><span class="koboSpan" id="kobo.226.5">on Saturday, which is 1 second shy of 8 days. </span><span class="koboSpan" id="kobo.226.6">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">Mauna Loa</span></strong><span class="koboSpan" id="kobo.228.1"> plot in essence showed the daily effect at a single moment each day, exactly 7 days, hence the difference between the </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">two plots.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">Now take a look at the </span><strong class="bold"><span class="koboSpan" id="kobo.231.1">yearly</span></strong><span class="koboSpan" id="kobo.232.1"> seasonality. </span><span class="koboSpan" id="kobo.232.2">It’s quite </span><em class="italic"><span class="koboSpan" id="kobo.233.1">wavy</span></em><span class="koboSpan" id="kobo.234.1">. </span><span class="koboSpan" id="kobo.234.2">Just take note of that for now. </span><span class="koboSpan" id="kobo.234.3">We’ll talk about it in </span><a href="B19630_05.xhtml#_idTextAnchor254"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.235.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.236.1">, </span><em class="italic"><span class="koboSpan" id="kobo.237.1">Working with Seasonality</span></em><span class="koboSpan" id="kobo.238.1">, when we learn </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.239.1">about the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.240.1">Fourier order</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">Finally, the </span><strong class="bold"><span class="koboSpan" id="kobo.243.1">daily</span></strong><span class="koboSpan" id="kobo.244.1"> seasonality plot. </span><span class="koboSpan" id="kobo.244.2">This is new and only appears when Prophet models sub-daily data. </span><span class="koboSpan" id="kobo.244.3">It’s quite revealing with this dataset, though. </span><span class="koboSpan" id="kobo.244.4">It seems that riders in the Divvy network ride a lot around 8 a.m., possibly commuting to work. </span><span class="koboSpan" id="kobo.244.5">There is an even larger spike just after 5 p.m., possibly riders returning home. </span><span class="koboSpan" id="kobo.244.6">And finally, there’s a small hump just after midnight. </span><span class="koboSpan" id="kobo.244.7">These must be the night owls, who spent the evening out with friends and are returning home </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">to bed.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">I also want to</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.247.1"> mention one more thing about the forecast: the model predicts some negative values, although it’s impossible for Divvy to have a negative number of rides taken during any given hour. </span><span class="koboSpan" id="kobo.247.2">The Prophet developers are actively working on this issue and will release a solution in a </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">future update.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">In the last two sections, you learned that super-daily data and sub-daily data pose no difficult issues to overc</span><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.250.1">ome; we can simply adjust the frequency of future predictions. </span><span class="koboSpan" id="kobo.250.2">But now suppose that Divvy had only been collecting data from 8 a.m. </span><span class="koboSpan" id="kobo.250.3">until 6 p.m. </span><span class="koboSpan" id="kobo.250.4">each day. </span><span class="koboSpan" id="kobo.250.5">The last topic to cover in this chapter is how to handle data with </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">regula</span><a id="_idTextAnchor228"/><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.252.1">r gaps.</span></span></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.253.1">Using data with regular gaps</span></h1>
<p><span class="koboSpan" id="kobo.254.1">Througho</span><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.255.1">ut your career, you may encounter datasets with regul</span><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.256.1">ar gaps in reporting, particularly </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.257.1">when the data was collected by humans who</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.258.1"> have working hours, personal hours, and sleeping hours. </span><span class="koboSpan" id="kobo.258.2">It simply may not be possible to collect measurements with </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">perfect periodicity.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">As you will see when we look at outliers in a later chapter, Prophet is robust in handling missing values. </span><span class="koboSpan" id="kobo.260.2">However, when that missing data occurs at regular intervals, Prophet will have no training data at all during those gaps to make estimations with. </span><span class="koboSpan" id="kobo.260.3">The seasonality will be constrained during periods where data exists but unconstrained during the gaps, and Prophet’s predictions can exhibit much larger fluctuations than the actual data displays. </span><span class="koboSpan" id="kobo.260.4">Let’s see this </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">in action.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">Suppose that Divvy’s data had only been collected between the hours of 8 a.m. </span><span class="koboSpan" id="kobo.262.2">and 6 p.m. </span><span class="koboSpan" id="kobo.262.3">each day. </span><span class="koboSpan" id="kobo.262.4">We can simulate this by removing the data from outside these hours from </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">our DataFrame:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.264.1">
df = df[(df['ds'].dt.hour &gt;= 8) &amp; \
        (df['ds'].dt.hour &lt; 18)]</span></pre>
<p><span class="koboSpan" id="kobo.265.1">Now compare the following plot of this new DataFrame with the full dataset, which we saw in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.266.1">Fig</span><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.267.1">ure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.268.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer102">
<span class="koboSpan" id="kobo.270.1"><img alt="Figure 4.7 – Divvy rides per hour between 8 a.m. and 6 p.m." src="image/Fig_4.7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.271.1">Figure 4.7 – Divvy rides per hour between 8 a.m. </span><span class="koboSpan" id="kobo.271.2">and 6 p.m.</span></p>
<p><span class="koboSpan" id="kobo.272.1">This plot is much</span><a id="_idTextAnchor234"/><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.273.1"> sparser than </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.274.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.275.1">.4</span></em><span class="koboSpan" id="kobo.276.1">, particularly at </span><a id="_idIndexMarker160"/><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.277.1">low </span><em class="italic"><span class="koboSpan" id="kobo.278.1">y</span></em><span class="koboSpan" id="kobo.279.1">-axis values. </span><span class="koboSpan" id="kobo.279.2">We lost all overnight data, from when ridership is down. </span><span class="koboSpan" id="kobo.279.3">Each day only has 10 data points now, one for each hour between 8 a.m. </span><span class="koboSpan" id="kobo.279.4">and 6 p.m. </span><span class="koboSpan" id="kobo.279.5">Now, let’s build a forecast model exactly as we did in the previous section, making our </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">future</span></strong><span class="koboSpan" id="kobo.281.1"> DataFrame with one year of hourly frequency, but taking no </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">extra precautions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.283.1">
model = Prophet(seasonality_mode='multiplicative')
model.fit(df)
future = model.make_future_dataframe(periods=365 * 24,
                                     freq='h')
forecast = model.predict(future)
fig = model.plot(forecast)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.284.1">The plotted </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.285.1">forecast shows much wider daily fluctuations</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.286.1"> in the future period than the historical </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">tra</span><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.288.1">ining data:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer103">
<span class="koboSpan" id="kobo.289.1"><img alt="Figure 4.8 – Divvy forecast with regular gaps" src="image/Fig_4.8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.290.1">Figure 4.8 – Divvy forecast with regular gaps</span></p>
<p><span class="koboSpan" id="kobo.291.1">Here, we are seeing unconstrained estimates in the future period causing wide fluctuations in predictio</span><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.292.1">ns. </span><span class="koboSpan" id="kobo.292.2">This is the same effect that we observed with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Air Passengers</span></strong><span class="koboSpan" id="kobo.294.1"> data when we predicted daily forecasts with monthly data. </span><span class="koboSpan" id="kobo.294.2">We can zoom in on just 3 days in August 2018 to see more clearly what’s going on by replotting and using Matplotlib to constrain the limits of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">x</span></strong><span class="koboSpan" id="kobo.296.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">y</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.298.1"> axes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
fig = model.plot(forecast)
plt.xlim(pd.to_datetime(['2018-08-01', '2018-08-04']))
plt.ylim(-2000, 4000)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.300.1">Whereas the forecast plot from before showed 5 years of predictions, this plot shows just 3 days, so you can fully see what’s</span><a id="_idTextAnchor238"/> <span class="No-Break"><span class="koboSpan" id="kobo.301.1">going on:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer104">
<span class="koboSpan" id="kobo.302.1"><img alt="Figure 4.9 – Divvy forecast over 3 days" src="image/Fig_4.9.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.303.1">Figure 4.9 – Divvy forecast over 3 days</span></p>
<p><span class="koboSpan" id="kobo.304.1">In the </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.305.1">previous section, when we looked at </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.306.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.307.1">.6</span></em><span class="koboSpan" id="kobo.308.1">, we </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.309.1">noted that the daily seasonali</span><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.310.1">ty component showed ridership picking up befor</span><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.311.1">e 8 a.m. </span><span class="koboSpan" id="kobo.311.2">and hitting a local peak right at 8 a.m. </span><span class="koboSpan" id="kobo.311.3">There was a slump at midday and then a large peak right after 6 p.m. </span><span class="koboSpan" id="kobo.311.4">We are seeing the same thing in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.312.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.313.1">.9</span></em><span class="koboSpan" id="kobo.314.1">, except that Prophet is making wild predictions before 8 a.m. </span><span class="koboSpan" id="kobo.314.2">and after 6 p.m., where it has no training data. </span><span class="koboSpan" id="kobo.314.3">This area is unconstrained and can follow almost any pattern as long as the equations work out for the midday period where </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">data exists.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">The solution to this problem is to simply modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">future</span></strong><span class="koboSpan" id="kobo.318.1"> DataFrame to exclude those times for which our training data had regular gaps. </span><span class="koboSpan" id="kobo.318.2">We don’t even need to instantiate a new model or refit; we can just reuse our previous work. </span><span class="koboSpan" id="kobo.318.3">So, continuing on, we create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">future2</span></strong><span class="koboSpan" id="kobo.320.1"> DataFrame, remove those times earlier than 8 a.m. </span><span class="koboSpan" id="kobo.320.2">and later than 6 p.m., and then predict our forecast and plot </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">the results:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.322.1">
future2 = future[(future['ds'].dt.hour &gt;= 8) &amp;
                 (future['ds'].dt.hour &lt; 18)]
forecast2 = model.predict(future2)
fig = model.plot(forecast2)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.323.1">Now we see a </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">goo</span><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.325.1">d forecast:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer105">
<span class="koboSpan" id="kobo.326.1"><img alt="Figure 4.10 – Divvy with regular gap﻿s fixed" src="image/Fig_4.10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.327.1">Figure 4.10 – Divvy with regular gap</span><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.328.1">s fixed</span></p>
<p><span class="koboSpan" id="kobo.329.1">The daily</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.330.1"> flu</span><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.331.1">ctuations in the predicted future are of the same </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.332.1">magnitude as our historical training data. </span><span class="koboSpan" id="kobo.332.2">Contrast that with </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.333.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.334.1">.8</span></em><span class="koboSpan" id="kobo.335.1">, where the future period showed a much wider range of predictions. </span><span class="koboSpan" id="kobo.335.2">Let’s again plot those same 3 days in August to compare the output with </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.336.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.337.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.339.1">
fig = model.plot(forecast2, figsize=(10, 4))
plt.xlim(pd.to_datetime(['2018-08-01', '2018-08-04']))
plt.ylim(-2000, 4000)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.340.1">We see the same curve as before for the hours between 8 a.m. </span><span class="koboSpan" id="kobo.340.2">and 6 p.m., but this time, Prophet simply connects them with a straight line. </span><span class="koboSpan" id="kobo.340.3">There is, in fact, no data in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">forecast</span></strong><span class="koboSpan" id="kobo.342.1"> DataFrame for these time periods; Prophet simply </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">i</span><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.344.1">gnores them:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer106">
<span class="koboSpan" id="kobo.345.1"><img alt="Figure 4.11 – Divvy 3-day forecast with regular gaps fixed" src="image/Fig_4.11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.346.1">Figure 4.11 – Divvy 3-day forecast with regular gaps fixed</span></p>
<p><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.347.1">Prophet is a</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.348.1"> continuous time model, so although the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">forecast</span></strong><span class="koboSpan" id="kobo.350.1"> DataFrame ignores those excluded times, the equations that underpin the model are defined </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.351.1">continuously. </span><span class="koboSpan" id="kobo.351.2">We can o</span><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.352.1">bserve this by plotting the daily seasonality with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">plot_seasonality</span></strong><span class="koboSpan" id="kobo.354.1"> function. </span><span class="koboSpan" id="kobo.354.2">This function is contained within Prophet’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">plot</span></strong><span class="koboSpan" id="kobo.356.1"> package, so we need to import it first. </span><span class="koboSpan" id="kobo.356.2">It takes two required arguments, the model and a string identifying the seasonality to plot, and we also pass an optional argument to change the </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">figure size:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.358.1">
from prophet.plot import plot_seasonality
plot_seasonality(model, 'daily', figsize=(10, 3))
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.359.1">Remember that we did not create a new model to solve the regular gap problem; we only removed those empty periods from our </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">forecast</span></strong><span class="koboSpan" id="kobo.361.1"> DataFrame the second time around. </span><span class="koboSpan" id="kobo.361.2">As we used only one model in these two examples, of course the components are the same. </span><span class="koboSpan" id="kobo.361.3">So, the daily seasonality we plotted is the same for </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">b</span><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.363.1">oth versions:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer107">
<span class="koboSpan" id="kobo.364.1"><img alt="Figure 4.12 – Divvy daily seasonality" src="image/Fig_4.12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.365.1">Figure 4.12 – Divvy daily seasonality</span></p>
<p><span class="koboSpan" id="kobo.366.1">As you can se</span><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.367.1">e, the</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.368.1"> period from 8 a.m. </span><span class="koboSpan" id="kobo.368.2">until </span><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.369.1">6 p.m. </span><span class="koboSpan" id="kobo.369.2">matches both </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.370.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.371.1">.9</span></em><span class="koboSpan" id="kobo.372.1"> and </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.373.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.374.1">.11</span></em><span class="koboSpan" id="kobo.375.1">, even though those two plots showed wildly different results </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.376.1">overnight. </span><span class="koboSpan" id="kobo.376.2">As we have no training or future data for times outside that range, those times on the daily seasonality plot can be ignored. </span><span class="koboSpan" id="kobo.376.3">They are merely mathematical artifacts of the equations that created th</span><a id="_idTextAnchor250"/><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.377.1">e </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">midday curve.</span></span></p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.379.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.380.1">In this chapter, you took the lessons learned from the basic </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">Mauna Loa</span></strong><span class="koboSpan" id="kobo.382.1"> model you built in </span><a href="B19630_02.xhtml#_idTextAnchor104"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.383.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.384.1">, </span><em class="italic"><span class="koboSpan" id="kobo.385.1">Getting Started with Prophet</span></em><span class="koboSpan" id="kobo.386.1">, and learned what changes you need to make when the periodicity of your data is not daily. </span><span class="koboSpan" id="kobo.386.2">Specifically, you used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">Air Passengers</span></strong><span class="koboSpan" id="kobo.388.1"> dataset to model monthly data and used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">freq</span></strong><span class="koboSpan" id="kobo.390.1"> argument when making your </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">future</span></strong><span class="koboSpan" id="kobo.392.1"> DataFrame in order to hold back Prophet from making </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">daily predictions.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">Then, you used the hourly data from Divvy’s bike share program to set the future frequency to hourly so that Prophet would increase the granularity of its prediction timescale. </span><span class="koboSpan" id="kobo.394.2">Finally, you simulated periodic missing data in the Divvy dataset and learned a different way to match the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">future</span></strong><span class="koboSpan" id="kobo.396.1"> DataFrame’s schedule to that of the training data, in order to prevent Prophet from making </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">unconstrained predictions.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">Now that you know how to handle the different datasets you will encounter in this book, you’re ready for the next topic! </span><span class="koboSpan" id="kobo.398.2">In the next chapter, you will learn all about seasonality. </span><span class="koboSpan" id="kobo.398.3">Seasonality is at the heart of Prophet’s power and it’s a big</span><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.399.1"> topic, so </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">prepare yourself!</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer109">
</div>
</div>
</body></html>