<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;The R Environment" id="aid-KVCC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. The R Environment</h1></div></div></div><p>R is<a id="id47" class="indexterm"/> currently one of the most popular programming environments for statistical computing. It was evolved as an open source language from the S programming language developed at Bell Labs. The main creators of R are two academicians, Robert Gentleman and Ross Ihaka, from the University of Auckland in New Zealand.</p><p>The main reasons for the popularity of R, apart from free software under GNU General Public License, are the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">R is very easy to use. It is an interpreted language and at the same time can be used for procedural programming.</li><li class="listitem">R supports both functional and object-oriented paradigms. It has very strong graphical and data visualization capabilities.</li><li class="listitem">Through its LaTex-like documentation support, R can be used for making high-quality documentation.</li><li class="listitem">Being an open source software, R has a large number of contributed packages that makes almost all statistical modeling possible in this environment.</li></ul></div><p>This chapter is intended to give a basic introduction to R so that any reader who is not familiar with the language can follow the rest of the book by reading through this chapter. It is not possible to give a detailed description of the R language in one chapter and the interested reader should consult books specially written in R programming. I would recommend <span class="emphasis"><em>The Art of R Programming</em></span> (reference 1 in the <span class="emphasis"><em>References</em></span> section of this chapter) and <span class="emphasis"><em>R Cookbook</em></span> (reference 2 in the <span class="emphasis"><em>References</em></span> section of this chapter) for those users who are mainly interested in using R for analyzing and modeling data. For those who are interested in learning about the advanced features of R, for example, for writing complex programs or R packages, <span class="emphasis"><em>Advanced R</em></span> (reference 3 in the <span class="emphasis"><em>References</em></span> section of this chapter) is an excellent book.</p><div class="section" title="Setting up the R environment and packages"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Setting up the R environment and packages</h1></div></div></div><p>R is a free <a id="id48" class="indexterm"/>software under GNU open source license. R comes with a basic package and also has a large number of user-contributed packages for advanced <a id="id49" class="indexterm"/>analysis and modeling. It also has a nice graphics user interface-based editor called <a id="id50" class="indexterm"/>RStudio. In this section, we will learn how to download R, set up the R environment in your computer, and write a simple R program.</p><div class="section" title="Installing R and RStudio"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Installing R and RStudio</h2></div></div></div><p>
<span class="strong"><strong>The Comprehensive R Archive Network</strong></span> (<span class="strong"><strong>CRAN</strong></span>) hosts all <a id="id51" class="indexterm"/>releases of R and the<a id="id52" class="indexterm"/> contributed packages. R for Windows can be installed by downloading the binary of the base package from <a class="ulink" href="http://cran.r-project.org">http://cran.r-project.org</a>; a standard installation should be sufficient. For Linux and Mac OS X, the webpage gives instructions on how to download and install the software. At the time of writing this book, the latest release was version 3.1.2. Various packages need to be installed separately from the package page. One can install any package from the R command prompt using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>install.packages("package name")</strong></span>
</pre></div><p>After installing the package, one needs to load the package before using it with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>library("package name")</strong></span>
</pre></div><p>A very useful <a id="id53" class="indexterm"/>
<span class="strong"><strong>integrated development environment</strong></span> (<span class="strong"><strong>IDE</strong></span>) for R is RStudio. It can be downloaded freely<a id="id54" class="indexterm"/> from <a class="ulink" href="http://www.rstudio.com/">http://www.rstudio.com/</a>. RStudio <a id="id55" class="indexterm"/>works on Windows, Linux, and Mac platforms. It has both a desktop version and also a server version that can be used for writing R programs through a browser interface on a remote server. After installing R and RStudio, it is useful to set the default working directory to the directory of your choice. RStudio reads and writes files containing R codes into the working directory. To find out what the current directory is, use the R command <code class="literal">getwd( )</code>. To change the working directory to a directory of your preference, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>setwd("directory path")</strong></span>
</pre></div><p>You can also set this from the menu bar of RStudio by clicking on <span class="strong"><strong>Session</strong></span> | <span class="strong"><strong>Set Working Directory</strong></span>.</p></div><div class="section" title="Your first R program"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Your first R program</h2></div></div></div><p>Let us<a id="id56" class="indexterm"/> write a simple program to add two integers <code class="literal">x</code> and <code class="literal">y</code> resulting in their sum <code class="literal">z</code>. On the command prompt in RStudio, type the following commands and press <span class="emphasis"><em>Enter</em></span>:</p><div class="informalexample"><pre class="programlisting">&gt;x &lt;-2
&gt;y &lt;-3
&gt;z &lt;-x+y
&gt;print(z)
[1]  5</pre></div><p>Now, you can assign different values to <code class="literal">x</code> and <code class="literal">y</code> and print <code class="literal">z</code> to see how <code class="literal">z</code> changes. Instead of <code class="literal">print(z)</code>, you can also simply enter <code class="literal">z</code> to print its values.</p></div></div></div>
<div class="section" title="Managing data in R"><div class="titlepage" id="aid-LTSU2"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Managing data in R</h1></div></div></div><p>Before <a id="id57" class="indexterm"/>we start any serious programming in R, we need to learn how to import data into an R environment and which data types R supports. Often, for <a id="id58" class="indexterm"/>a particular analysis, we will not use the entire dataset. Therefore, we need to also learn how to select a subset of the data for any analysis. This section will cover these aspects.</p><div class="section" title="Data Types in R"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Data Types in R</h2></div></div></div><p>R has<a id="id59" class="indexterm"/> five basic data types as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Integer</li><li class="listitem">Numeric (real)</li><li class="listitem">Complex</li><li class="listitem">Character</li><li class="listitem">Logical (True/False)</li></ul></div><p>The default representation of numbers in R is double precision real number (numeric). If you want an integer <a id="id60" class="indexterm"/>representation explicitly, you need to add the suffix <code class="literal">L</code>. For example, simply entering <code class="literal">1</code> on<a id="id61" class="indexterm"/> the command prompt will store <code class="literal">1</code> as a numeric <a id="id62" class="indexterm"/>object. To store <code class="literal">1</code> as an integer, you <a id="id63" class="indexterm"/>need to enter <code class="literal">1L</code>. The command <code class="literal">class(x)</code> will give <a id="id64" class="indexterm"/>the class (type) of the object <code class="literal">x</code>. Therefore, entering <code class="literal">class(1)</code> on command prompt will give the answer <code class="literal">numeric</code> whereas entering <code class="literal">class(1L)</code> will give the answer <code class="literal">integer</code>.</p><p>R also has a special number <code class="literal">Inf</code> that represents Infinity. The number <code class="literal">NaN</code> (<span class="emphasis"><em>not a number</em></span>) is used to represent an undefined value such as 0/0. Missing values are represented by using the symbol <code class="literal">NA</code>.</p></div><div class="section" title="Data structures in R"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Data structures in R</h2></div></div></div><p>The data structures<a id="id65" class="indexterm"/> in R can be classified as either homogeneous (all elements containing the same data type) or heterogeneous (elements containing different data types). Furthermore, each of these have different structures depending <a id="id66" class="indexterm"/>upon the number of dimensions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Homogeneous:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Atomic vector</strong></span>: one-dimensional</li><li class="listitem"><span class="strong"><strong>Matrix</strong></span>: two-dimensional</li><li class="listitem"><span class="strong"><strong>Array</strong></span>: N-dimensional</li></ul></div></li><li class="listitem">Heterogeneous:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>List</strong></span>: one-dimensional</li><li class="listitem"><span class="strong"><strong>Data frame</strong></span>: two-dimensional</li></ul></div></li></ul></div><p>The most basic object in <a id="id67" class="indexterm"/>R is a vector. To create an empty integer vector of size 10, enter the following command on the R prompt:</p><div class="informalexample"><pre class="programlisting">&gt;v &lt;-vector("integer",10)
&gt;v
[1]  0000000000</pre></div><p>You can assign the value <span class="emphasis"><em>m</em></span> to <span class="emphasis"><em>n</em></span>th component of the vector using the following command:</p><div class="informalexample"><pre class="programlisting">&gt; v[5] &lt;-1
&gt; v
[1]  0000100000</pre></div><p>Readers should note that unlike in many programming languages, the array index in R starts with 1 and not 0.</p><p>Whereas a vector can only contain objects of the same type, a list, although similar to the vector, can contain objects of different types. The following command will create a list containing integers, real numbers, and characters:</p><div class="informalexample"><pre class="programlisting">&gt; l &lt;-list(1L, 2L, 3, 4, "a", "b")
&gt; str(l)
List of 6
$: int 1
$: int 2
$: num 3
$: num 4
$: chr "a"
$: chr "b"</pre></div><p>Here, we used<a id="id68" class="indexterm"/> the <code class="literal">str()</code> function in R that shows the structure of any R object.</p><p>R has a special function <code class="literal">c()</code> to combine multiple numbers of basic data into a vector or list. For example, <code class="literal">c(1,3,6,2,-1)</code> will produce a vector containing numbers from 1,2,3,6,-1:</p><div class="informalexample"><pre class="programlisting">&gt; c(1, 3, 6, 2, -1)
[1]  1 3 6 2 -1</pre></div><p>A matrix is the generalization of a vector into two dimensions. Consider the following command:</p><div class="informalexample"><pre class="programlisting">&gt;m &lt;-matrix(c(1:9),nrow=3,ncol=3)</pre></div><p>This command will generate a matrix <code class="literal">m</code> of size 3 x 3 containing numbers from 1 to 9.</p><p>The most common data structure used for storing data in R is a data frame. A data frame, like the list, can contain data of different types (numeric, integer, Boolean, or character). It is essentially a list of vectors of equal length. Therefore, it has the same two-dimensional structure as a matrix. The length (found using <code class="literal">length( )</code>) of a data frame is the length of the underlying list that is the number of columns in the data frame. There are simple commands <code class="literal">nrow( )</code> and <code class="literal">ncol( )</code> for finding the number of rows and columns of a data frame. The other two attributes of a data frame are <code class="literal">rownames( )</code> and <code class="literal">colnames( )</code> that can be used to either set or find the names of rows or columns.</p></div><div class="section" title="Importing data into R"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Importing data into R</h2></div></div></div><p>Data that is<a id="id69" class="indexterm"/> in the form of a table can be easily loaded into R using the <code class="literal">read.table(…)</code> function. It has several arguments to make the import very flexible. Some of the useful arguments are the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">file</code>: The name of a file or a complete URL</li><li class="listitem"><code class="literal">header</code>: A logical value indicating whether the file has a header line containing names of the variables</li><li class="listitem"><code class="literal">sep</code>: A character indicating the column separator field</li><li class="listitem"><code class="literal">row.names</code>: A vector of row names</li><li class="listitem"><code class="literal">col.names</code>: A vector of names for variables</li><li class="listitem"><code class="literal">skip</code>: The number of lines in the data file to be skipped before reading the data</li><li class="listitem"><code class="literal">nrows</code>: The number of rows in the dataset</li><li class="listitem"><code class="literal">stringsASFactors</code>: A logical value indicating if the character variables can be coded as factors or not</li></ul></div><p>For small<a id="id70" class="indexterm"/> datasets, one can use <code class="literal">read.table("filename.txt")</code> without specifying other arguments; the rest R will figure out itself. Another useful function is <code class="literal">read.csv()</code> for reading CSV files only.</p><p>In addition to loading data from text files, data can be imported into R by connecting to external databases through various interfaces. One such popular interface is <a id="id71" class="indexterm"/>
<span class="strong"><strong>Open Database Connectivity</strong></span> (<span class="strong"><strong>ODBC</strong></span>). The <span class="strong"><strong>RODBC</strong></span> package in R <a id="id72" class="indexterm"/>provides access to different databases through the ODBC interface. This package contains different functions for connecting with a database and performing various operations. Some of the important functions<a id="id73" class="indexterm"/> in the RODBC package are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">odbcConnect(dsn, uid="user_name", pwd="password")</code>: Used to open a connection to an ODBC database having registered data source name <code class="literal">dsn</code>.</li><li class="listitem"><code class="literal">sqlFetch(channel, sqtable)</code>: Used to read a table from an ODBC database to a data frame.</li><li class="listitem"><code class="literal">sqlQuery(channel, query)</code>: Used to submit a query to an ODBC database and return the results.</li><li class="listitem"><code class="literal">sqlSave(channel, mydf, tablename = sqtable, append = FALSE)</code>: Used to write or update (<code class="literal">append = TRUE</code>) a data frame to a table in the ODBC database.</li><li class="listitem"><code class="literal">close(channel)</code>: Used<a id="id74" class="indexterm"/> to close the connection. Here, <code class="literal">channel</code> is the connection handle as returned by <code class="literal">odbcConnect</code>.</li></ul></div></div><div class="section" title="Slicing and dicing datasets"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Slicing and dicing datasets</h2></div></div></div><p>Often, in data <a id="id75" class="indexterm"/>analysis, one needs to slice and dice the full data frame to select a few variables or observations. This is called subsetting. R has <a id="id76" class="indexterm"/>some powerful and fast methods for doing this.</p><p>To extract subsets of R objects, one can use the following three operators:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Single bracket [ ]</strong></span>: This<a id="id77" class="indexterm"/> returns an object of the same class as the original. The single bracket operator can be used to select more than one element of an object. Some examples are as follows:<div class="informalexample"><pre class="programlisting">&gt;x &lt;-c(10,20,30,40,50)
&gt;x[1:3]
[1]  10 20 30

&gt;x[x &gt;25]
[1]  30 40 50

&gt;f &lt;-x &gt;30
&gt;x[f]
[1]  40 50

&gt;m &lt;-matrix(c(1:9),nrow=3,ncol=3)
&gt;m[1 ,] #select the entire first row
[1]  1 4 7

&gt;m[  ,2] #select the entire second column
[1]  4 5 6</pre></div></li><li class="listitem"><span class="strong"><strong>Double bracket [[ ]]</strong></span>: This is <a id="id78" class="indexterm"/>used to extract a single element of a list or data frame. The returned object need not be the same type as the initial object. Some examples are as follows:<div class="informalexample"><pre class="programlisting">&gt;y &lt;-list("a", "b", "c", "d", "e")

&gt;y[1]
[[1]]
[1]  "a"

&gt;class(y[1])
[1]  "list"

&gt;y[[1]]
[1]  "a"

&gt;class(y[[1]])
[1]  "character"</pre></div></li><li class="listitem"><span class="strong"><strong>Dollar sign $</strong></span>: This is used to<a id="id79" class="indexterm"/> extract elements of a list or data frame by name. Some examples are as follows:<div class="informalexample"><pre class="programlisting">&gt;z &lt;-list(John = 12 ,Mary = 18,Alice = 24 ,Bob = 17 ,Tom = 21)

&gt;z$Bob
[1] 17</pre></div></li><li class="listitem"><span class="strong"><strong>Use of negative index values</strong></span>: This is <a id="id80" class="indexterm"/>used to drop a particular index or column—one subset with a negative sign for the corresponding index. For example, to drop Mary and Bob from the preceding list, use the following code:<div class="informalexample"><pre class="programlisting">&gt; y &lt;-z[c(-2, -4)]
&gt; y</pre></div></li></ul></div></div><div class="section" title="Vectorized operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Vectorized operations</h2></div></div></div><p>In R, many <a id="id81" class="indexterm"/>operations, such as arithmetical operations involving vectors and matrices, can be done very efficiently using vectorized operations. For example, if you are adding two vectors <code class="literal">x</code> and <code class="literal">y</code>, their elements are added in parallel. This also makes the code more concise and easier to understand. For example, one does not need a <code class="literal">for( )</code> loop to add two vectors in the code:</p><div class="informalexample"><pre class="programlisting">&gt;x &lt;-c(1,2,3,4,5)

&gt;y &lt;-c(10,20,30,40,50)

&gt;z &lt;-x+y

&gt;z
[1]  11 22 33 44 55

&gt;w &lt;-x*y

&gt;w
[1]  10 40 90 160 250</pre></div><p>Another very useful example of vectorized operations is in the case of matrices. If <code class="literal">X</code> and <code class="literal">Y</code> are two matrices, the<a id="id82" class="indexterm"/> following operations can be carried out in R in a vectorized form:</p><div class="informalexample"><pre class="programlisting">&gt;X*Y  ## Element-wise multiplication
&gt;X/Y  ## Element-wise division
&gt;X  %*%  Y  ## Standard matrix multiplication</pre></div></div></div>
<div class="section" title="Writing R programs" id="aid-MSDG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Writing R programs</h1></div></div></div><p>Although much<a id="id83" class="indexterm"/> data analysis in R can be carried out in an interactive manner using command prompt, often for more complex tasks, one needs to write R scripts. As mentioned in the introduction, R has both the perspective of a functional and object-oriented programming language. In this section, some of the standard syntaxes of the programming in R are described.</p><div class="section" title="Control structures"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Control structures</h2></div></div></div><p>Control structures <a id="id84" class="indexterm"/>are meant for controlling the flow of execution of a program. The standard control structures are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">if</code> and <code class="literal">else</code>: To test a condition</li><li class="listitem"><code class="literal">for</code>: To loop over a set of statements for a fixed number of times</li><li class="listitem"><code class="literal">while</code>: To loop over a set of statements while a condition is true</li><li class="listitem"><code class="literal">repeat</code>: To execute an infinite loop</li><li class="listitem"><code class="literal">break</code>: To break the execution of a loop</li><li class="listitem"><code class="literal">next</code>: To skip an iteration of a loop</li><li class="listitem"><code class="literal">return</code>: To exit a function</li></ul></div></div><div class="section" title="Functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Functions</h2></div></div></div><p>If one wants <a id="id85" class="indexterm"/>to use R for more serious programming, it is essential to know how to write functions. They make the language more powerful and elegant. R has many built-in functions, such as <code class="literal">mean()</code>, <code class="literal">sort()</code>, <code class="literal">sin()</code>, <code class="literal">plot()</code>, and many more, which are written using R commands.</p><p>A function is defined as follows:</p><div class="informalexample"><pre class="programlisting">&gt;fname&lt;-function(arg1,arg2,   ){
        R Expressions
   }</pre></div><p>Here, <code class="literal">fname</code> is the name of the function; <code class="literal">arg1</code>, <code class="literal">arg2</code>, and so on, are arguments passed to the function. Note that unlike in other languages, functions in R do not end with a return statement. By default, the last statement executed inside the body of the function is returned by the function.</p><p>Once a function is defined, it is executed simply by entering the function name with the values for the arguments:</p><div class="informalexample"><pre class="programlisting">&gt;fname(arg1,arg2,…)</pre></div><p>The important properties of functions in R are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Functions are first-class citizens</li><li class="listitem">Functions can be passed as arguments to other functions</li><li class="listitem">One can define a function inside another function (nesting)</li><li class="listitem">The arguments of the functions can be matched by position or name</li></ul></div><p>Let's consider a simple example of a function, which given an input vector <code class="literal">x</code>, calculates its mean. To write this function, open a new window in RStudio for R script from the menu bar through <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New File</strong></span> | <span class="strong"><strong>R Script</strong></span>. In this R script, enter the following lines of code:</p><div class="informalexample"><pre class="programlisting">myMean &lt;-function(x){
    s &lt;-sum(x)
    l &lt;-length(x)
    mean &lt;-s/l
    mean
}</pre></div><p>Select the entire code and use the keys <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Enter</em></span> to execute the script. This completes the definition of <a id="id86" class="indexterm"/>the <code class="literal">myMean</code> function. To use this function on the command prompt, enter the following:</p><div class="informalexample"><pre class="programlisting">&gt;x &lt;-c(10,20,30,40,50)
&gt;myMean(x)</pre></div><p>This will generate the following result:</p><div class="informalexample"><pre class="programlisting">&gt;myMean(x)
[1]  30</pre></div></div><div class="section" title="Scoping rules"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Scoping rules</h2></div></div></div><p>In<a id="id87" class="indexterm"/> programming languages, it is very important to understand the scopes of all variables to avoid errors during execution. There are two types of scoping of a variable in a function: lexical scoping and dynamic scoping. In the case of lexical scoping, the value of a variable in a function is looked up in the environment in which the function was defined. Generally, this is the global environment. In the case of dynamic scoping, the value of a variable is looked up in the environment in which the function was called (the calling environment).</p><p>R uses lexical scoping that makes it possible to write functions inside a function. This is illustrated with the following example:</p><div class="informalexample"><pre class="programlisting">&gt;x &lt;-0.1
&gt;f &lt;-function(y){
          x*y
    }
&gt;g &lt;-function(y){
          x&lt;-5
          x-f(y)
    }
&gt;g(10)
[1]  4</pre></div><p>The answer is <code class="literal">4</code> because while evaluating function <code class="literal">f</code>, the value of <code class="literal">x</code> is taken from the global environment, which is <code class="literal">0.1</code>, whereas while evaluating function <code class="literal">g</code>, the value of <code class="literal">x</code> is taken from the local environment of <code class="literal">g</code>, which is <code class="literal">5</code>.</p><p>Lexical scoping has some disadvantages. Since the value of a variable is looked up from the environment in which the function is defined, all functions must carry a pointer to their respective defining environments. Also, all objects must be stored in memory during the execution of the program.</p></div><div class="section" title="Loop functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Loop functions</h2></div></div></div><p>Often, we <a id="id88" class="indexterm"/>have a list containing some objects and we want to apply a function to every element of the list. For example, we have a list of results of a survey, containing <span class="emphasis"><em>m</em></span> questions from <span class="emphasis"><em>n</em></span> participants. We would like to find the average response for each question (assuming that all questions have a response as numeric values). One<a id="id89" class="indexterm"/> could use a <code class="literal">for</code> loop over the set of questions and find an average among <span class="emphasis"><em>n</em></span> users using the <code class="literal">mean()</code> function in R. Loop functions come in handy in such situations and one can do such computations in a more compact way. These are like iterators in other languages such as Java.</p><p>The following are the standard loop functions in R:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">lapply</code>: To loop over a list and evaluate a function on each element</li><li class="listitem"><code class="literal">sapply</code>: The same as <code class="literal">lapply</code>, but with the output in a more simpler form</li><li class="listitem"><code class="literal">mapply</code>: A multivariate version of <code class="literal">sapply</code></li><li class="listitem"><code class="literal">apply</code>: To apply functions over array margins</li><li class="listitem"><code class="literal">tapply</code>: To apply a function to each cell of a ragged array</li></ul></div><div class="section" title="lapply"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>lapply</h3></div></div></div><p>The <code class="literal">lapply()</code> function <a id="id90" class="indexterm"/>is used in the following manner:</p><div class="informalexample"><pre class="programlisting">&gt;lapply(X,FUN,   )</pre></div><p>Here, <code class="literal">X</code> is a list or vector containing data. The <code class="literal">FUN</code> is the name of a function that needs to be applied on each element of the list or vector. The last argument represents optional arguments. The result of using <code class="literal">lapply</code> is always a list, regardless of the type of input.</p><p>As an example, consider the quarterly revenue of four companies in billions of dollars (not real data). We would like to compute the yearly average revenue of all four companies as follows:</p><div class="informalexample"><pre class="programlisting">&gt;X&lt;-list(HP=c(12.5,14.3,16.1,15.4),IBM=c(22,24.5,23.7,26.2),Dell=c(8.9,9.7,10.8,11.5),Oracle=c(20.5,22.7,21.8,24.4)  )
&gt;lapply(X,mean)
$HP
[1]  14.575

$IBM
[1]  24.1

$Dell
[1]  10.225

$Oracle
[1]  22.35</pre></div></div><div class="section" title="sapply"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>sapply</h3></div></div></div><p>The <code class="literal">sapply()</code> function is<a id="id91" class="indexterm"/> similar to <code class="literal">lapply()</code> with the additional option of simplifying the output into a desired form. For example, <code class="literal">sapply()</code> can be used in the previous dataset as follows:</p><div class="informalexample"><pre class="programlisting">&gt; sapply(X,mean,simplify="array")
     HP       IBM       Dell      Oracle
   14.575    24.100    10.225     22.350</pre></div></div><div class="section" title="mapply"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>mapply</h3></div></div></div><p>The <code class="literal">lapply()</code> and <code class="literal">sapply()</code> functions<a id="id92" class="indexterm"/> can only have one argument. If you want to apply a function with multiple variable arguments, then <code class="literal">mapply()</code> becomes handy. Here is how it is used:</p><div class="informalexample"><pre class="programlisting">&gt;mapply(FUN,L1,L2,   ,Ln,SIMPLIFY=TRUE)</pre></div><p>Here, <span class="inlinemediaobject"><img src="../Images/image00250.jpeg" alt="mapply"/></span> are the lists to which the function <code class="literal">FUN</code> needs to be applied. For example, consider the following list generation command:</p><div class="informalexample"><pre class="programlisting">&gt;rep(x=10,times=5)
[1] 10 10 10 10 10</pre></div><p>Here, the <code class="literal">rep</code> function repeats the value of <code class="literal">x</code> five times. Suppose we want to create a list where the number 10 occurs 1 time, the number 20 occurs 2 times, and so on, we can use <code class="literal">mapply</code> as follows:</p><div class="informalexample"><pre class="programlisting">&gt;mapply(rep,x=c(10,20,30,40,50),times=1:5)</pre></div></div><div class="section" title="apply"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>apply</h3></div></div></div><p>The <code class="literal">apply()</code> function<a id="id93" class="indexterm"/> is useful for applying a function to the margins of an array or matrix. The form of the function is as follows:</p><div class="informalexample"><pre class="programlisting">&gt;apply(X,MARGIN,FUN,   )</pre></div><p>Here, <code class="literal">MARGIN</code> is a vector giving the subscripts that the function will be applied over. For example, in the <a id="id94" class="indexterm"/>case of a matrix, <code class="literal">1</code> indicates rows and <code class="literal">2</code> indicates columns, and <code class="literal">c(1,2)</code> indicates rows and columns. Consider the following example as an illustration:</p><div class="informalexample"><pre class="programlisting">&gt;Y &lt;-matrix(1:9,nrow=3,ncol=3)
&gt;Y
          [,1]        [,2]          [,3]
[1,]        1           4             7
[2,]        2           5             8
[1,]        3           6             9
&gt;apply(Y,1,sum) #sum along the row
[1]  12 15 18
&gt;apply(Y,2,sum) #sum along the column
[1]  6 15 24</pre></div></div><div class="section" title="tapply"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>tapply</h3></div></div></div><p>The <code class="literal">tapply()</code> function<a id="id95" class="indexterm"/> is used to apply a function over the subsets of a vector. The function description is as follows:</p><div class="informalexample"><pre class="programlisting">&gt;tapply(X,INDEX,FUN,SIMPLIFY=TRUE)</pre></div><p>Let us consider the earlier example of the quarterly revenue of five companies:</p><div class="informalexample"><pre class="programlisting">&gt;X&lt;-X(HP=c(12.5,14.3,16.1,15.4),IBM=c(22,24.5,23.7,26.2),Dell=c(8.9,9.7,10.8,11.5),Oracle=c(20.5,22.7,21.8,24.4)  )</pre></div><p>Using <code class="literal">lapply()</code>, we found the average yearly revenue of each company. Suppose we want to find the revenue per quarter averaged over all four companies, we can use <code class="literal">tapply()</code> as follows; here we use the function <code class="literal">c</code> instead of the list to create <code class="literal">X</code>:</p><div class="informalexample"><pre class="programlisting">&gt;X&lt;-c(HP=c(12.5,14.3,16.1,15.4),IBM=c(22,24.5,23.7,26.2),Dell=c(8.9,9.7,10.8,11.5),Oracle=c(20.5,22.7,21.8,24.4)  )

&gt;f&lt;-factor(rep(c("Q1","Q2","Q3","Q4"),times=4) ) 
&gt;f
[1]  Q1 Q2 Q3 Q4 Q1 Q2 Q3 Q4 Q1 Q2 Q3 Q4 Q1 Q2 Q3 Q4
Levels Q1 Q2 Q3 Q4

&gt;tapply(X,f,mean,simplify=TRUE)
Q1           Q2         Q3        Q4
15.97      17.80      18.10     19.37</pre></div><p>By creating the factor list with levels as quarter values, we can apply the <code class="literal">mean</code> function for each quarter using <code class="literal">tapply()</code>.</p></div></div></div>
<div class="section" title="Data visualization"><div class="titlepage" id="aid-NQU22"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Data visualization</h1></div></div></div><p>One of the<a id="id96" class="indexterm"/> powerful features of R is its functions for generating high-quality plots and visualize data. The graphics functions in R can be divided into three groups:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">High-level plotting functions to create new plots, add axes, labels, and titles.</li><li class="listitem">Low-level plotting functions to add more information to an existing plot. This includes adding extra points, lines, and labels.</li><li class="listitem">Interactive graphics functions to interactively add information to, or extract information from, an existing plot.</li></ul></div><p>The R base package itself contains several graphics functions. For more advanced graph applications, one can use packages such as <a id="id97" class="indexterm"/>
<span class="strong"><strong>ggplot2</strong></span>, <span class="strong"><strong>grid</strong></span>, or <span class="strong"><strong>lattice</strong></span>. In particular, ggplot2 is very useful for<a id="id98" class="indexterm"/> generating visually appealing, multilayered graphs. It is based on the concept<a id="id99" class="indexterm"/> of <span class="emphasis"><em>grammar of graphics</em></span>. Due to lack of space, we are not covering these packages in this book. Interested readers should consult the book by Hadley Wickham (reference 4 in the <span class="emphasis"><em>References</em></span> section of this chapter).</p><div class="section" title="High-level plotting functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>High-level plotting functions</h2></div></div></div><p>Let us <a id="id100" class="indexterm"/>start with the most basic plotting functions in R <a id="id101" class="indexterm"/>as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">plot( )</code>: This is the most common plotting function in R. It is a generic function where the output depends on the type of the first argument.</li><li class="listitem"><code class="literal">plot(x, y)</code>: This produces a scatter plot of <code class="literal">y</code> versus <code class="literal">x</code>.</li><li class="listitem"><code class="literal">plot(x)</code>: If <code class="literal">x</code> is a real value vector, the output will be a plot of the value of <code class="literal">x</code> versus its index on the <span class="emphasis"><em>X</em></span> axis. If <code class="literal">x</code> is a complex number, then it will plot the real part versus the imaginary part.</li><li class="listitem"><code class="literal">plot(f, y)</code>: Here, <code class="literal">f</code> is a factor object and <code class="literal">y</code> is a numeric vector. The function produces box plots of <code class="literal">y</code> for each level of <code class="literal">f</code>.</li><li class="listitem"><code class="literal">plot(y ~ expr)</code>: Here, <code class="literal">y</code> is any object and <code class="literal">expr</code> is a list of object names separated by <span class="emphasis"><em>+</em></span> (for example, <span class="emphasis"><em>p + q + r</em></span>). The function plots <code class="literal">y</code> against every object named in <code class="literal">expr</code>.</li></ul></div><p>There are two useful functions in R for visualizing multivariate data:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">pairs(X)</code>: If <code class="literal">X</code> is a data frame containing numeric data, then this function produces a pair-wise scatter plot matrix of the variables defined by the columns of <code class="literal">X</code>.</li><li class="listitem"><code class="literal">coplot(y ~ x | z)</code>: If <code class="literal">y</code> and <code class="literal">x</code> are numeric vectors and <code class="literal">z</code> is a factor object, then this function plots <code class="literal">y</code> versus <code class="literal">x</code> for every level of <code class="literal">z</code>.</li></ul></div><p>For <a id="id102" class="indexterm"/>plotting<a id="id103" class="indexterm"/> distributions of data, one can use the following functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">hist(x)</code>: This produces a histogram of the numeric vector <code class="literal">x</code>.</li><li class="listitem"><code class="literal">qqplot(x, y)</code>: This plots the quantiles of <code class="literal">x</code> versus the quantiles of <code class="literal">y</code> to compare their respective distributions.</li><li class="listitem"><code class="literal">qqnorm(x)</code>: This plots the numeric vector <code class="literal">x</code> against the expected normal order scores.</li></ul></div></div><div class="section" title="Low-level plotting commands"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Low-level plotting commands</h2></div></div></div><p>To add points <a id="id104" class="indexterm"/>and lines to a plot, the following <a id="id105" class="indexterm"/>commands can be used:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">points(x, y)</code>: This adds point (x, y) to the current plot.</li><li class="listitem"><code class="literal">lines(x, y)</code>: This adds a connecting line to the current plot.</li><li class="listitem"><code class="literal">abline(a, b)</code>: This adds a line of the slope <code class="literal">b</code> and intercepts <code class="literal">a</code> to the current plot.</li><li class="listitem"><code class="literal">polygon(x, y, …)</code>: This draws a polygon defined by the ordered vertices (x, y, …).</li></ul></div><p>To add the text to a plot, use the following functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">text(x, y, labels)</code>: This adds text to the current plot at point (x, y).</li><li class="listitem"><code class="literal">legend(x, y, legend)</code>: This adds a legend to the current plot at point (x, y).</li><li class="listitem"><code class="literal">title(main, sub)</code>: This adds a title <code class="literal">main</code> at the top of the current plot in a large font and a subtitle <code class="literal">sub</code> at the bottom in a smaller font.</li><li class="listitem"><code class="literal">axis(side, …)</code>: This adds an axis to the current plot on the side given by the first argument. The <code class="literal">side</code> can take values from 1 to 4 counting clockwise from the bottom.</li></ul></div><p>The following example shows how to plot a scatter plot and add a trend line. For this, we will use the famous Iris dataset, created by R. A. Fisher, that is available in R itself:</p><div class="informalexample"><pre class="programlisting">data(iris)
str(iris)
plot(iris$Petal.Width, iris$Petal.Length, col = "blue", xlab = "X", ylab = "Y")
title(main = "Plot of Iris Data", sub = "Petal Length (Y) Vs Petal Width (X)")
fitlm &lt;- lm(iris$Petal.Length ~ iris$Petal.Width)
abline(fitlm[1], fitlm[2], col = "red")</pre></div><div class="mediaobject"><img src="../Images/image00251.jpeg" alt="Low-level plotting commands"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Interactive graphics functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Interactive graphics functions</h2></div></div></div><p>There <a id="id106" class="indexterm"/>are <a id="id107" class="indexterm"/>functions in R that enable users to add or extract information from a plot using the mouse in an interactive manner:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">locator (n , type)</code>: This waits for the user to select the <code class="literal">n</code> locations on the current plot using the left-mouse button. Here, type is one of <code class="literal">n</code>, <code class="literal">p</code>, <code class="literal">l</code> or <code class="literal">o</code> to plot points or lines at these locations. For example, to place a legend <span class="emphasis"><em>Outlier</em></span> near an outlier point, use the following code:<div class="informalexample"><pre class="programlisting">&gt;text(locator(1),"Outlier" ,adj=0")</pre></div></li><li class="listitem"><code class="literal">identify(x, y, label)</code>: This allows the user to highlight any of the points, <code class="literal">x</code> and <code class="literal">y</code>, selected using the left-mouse button by placing the label nearby.</li></ul></div></div></div>
<div class="section" title="Sampling" id="aid-OPEK1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Sampling</h1></div></div></div><p>Often, we<a id="id108" class="indexterm"/> would be interested in creating a representative dataset, for some analysis or design of experiments, by sampling from a population. This is particularly the case for Bayesian inference, as we will see in the later chapters, where samples are drawn from posterior distribution for inference. Therefore, it would be useful to learn how to sample <span class="emphasis"><em>N</em></span> points from some well-known distributions in this chapter.</p><p>Before we use any particular sampling methods, readers should note that R, like any other computer program, uses pseudo random number generators for sampling. It is useful to supply a starting seed number to get reproducible results. This can be done using the <code class="literal">set.seed(n)</code> command with an integer <code class="literal">n</code> as the seed.</p><div class="section" title="Random uniform sampling from an interval"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Random uniform sampling from an interval</h2></div></div></div><p>To<a id="id109" class="indexterm"/> generate <span class="emphasis"><em>n</em></span> random numbers (numeric) that are uniformly distributed in the interval <span class="emphasis"><em>[a, b]</em></span>, one can use the <code class="literal">runif()</code> function:</p><div class="informalexample"><pre class="programlisting">&gt;runif(5,1,10)  #generates 5 random numbers between 1 and 10
[1]  7.416    9.846    3.093   2.656   1.561</pre></div><p>Without any arguments, <code class="literal">runif()</code> will generate uniform random numbers between 0 and 1.</p><p>If we want to generate random integers uniformly distributed in an interval, the function to use is <code class="literal">sample()</code>:</p><div class="informalexample"><pre class="programlisting">&gt;sample(1:100,10,replace=T)   #generates 10 random integers between 1 and 100
[1]  24 51 46 87 30 86 50 45 53 62</pre></div><p>The option <code class="literal">replace=T</code> indicates that the repetition is allowed.</p></div><div class="section" title="Sampling from normal distribution"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Sampling from normal distribution</h2></div></div></div><p>Often, we<a id="id110" class="indexterm"/> may want to generate data that is distributed according to a particular distribution, say normal distribution. In the case of univariate distributions, R has several in-built functions for this. For sampling data from a normal distribution, the function to be used is <code class="literal">rnorm()</code>. For example, consider the following code:</p><div class="informalexample"><pre class="programlisting">&gt;rnorm(5,mean=0,sd=1)
[1]  0.759  -1.676   0.569  0.928 -0.609</pre></div><p>This generates five random numbers distributed according to a normal distribution with mean 0 and standard deviation 1.</p><p>Similarly, one can use the <code class="literal">rbinom()</code> function for sampling from a binomial distribution, <code class="literal">rpois()</code> to sample from a Poisson distribution, <code class="literal">rbeta()</code> to sample from a Beta distribution, and <code class="literal">rgamma()</code> to sample from a Gamma distribution to mention a few other distributions.</p></div></div>
<div class="section" title="Exercises" id="aid-PNV61"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Exercises</h1></div></div></div><p>For the following<a id="id111" class="indexterm"/> exercises in this chapter, we use the Auto MPG dataset from the UCI Machine Learning repository (references 5 and 6 in the <span class="emphasis"><em>References</em></span> section of this chapter). The dataset can be downloaded from <a class="ulink" href="https://archive.ics.uci.edu/ml/datasets.html">https://archive.ics.uci.edu/ml/datasets.html</a>. The dataset contains the fuel consumption of cars in the US measured during 1970-1982. Along with consumption values, there are attribute variables, such as the number of cylinders, displacement, horse power, weight, acceleration, year, origin, and the name of the car:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Load the dataset into R using the <code class="literal">read.table()</code> function.</li><li class="listitem">Produce a box plot of mpg values for each car name.</li><li class="listitem">Write a function that will compute the scaled value (subtract the mean and divide by standard deviation) of a column whose name is given as an argument of the function.</li><li class="listitem">Use the <code class="literal">lapply()</code> function to compute scaled values for all variables.</li><li class="listitem">Produce a scatter plot of mgp versus acceleration for each car name using <code class="literal">coplot()</code>. Use legends to annotate the graph.</li></ul></div></div>
<div class="section" title="References" id="aid-QMFO1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>References</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Matloff N. <span class="emphasis"><em>The Art of R Programming – A Tour of Statistical Software Design</em></span>. No Starch Press. 2011. ISBN-10: 1593273843</li><li class="listitem">Teetor P. <span class="emphasis"><em>R Cookbook</em></span>. O'Reilly Media. 2011. ISBN-10: 0596809158</li><li class="listitem">Wickham H. <span class="emphasis"><em>Advanced R</em></span>. Chapman &amp; Hall/CRC The R Series. 2015. ISBN-10: 1466586966</li><li class="listitem">Wickham H. <span class="emphasis"><em>ggplot2: Elegant Graphics for Data Analysis (Use R!)</em></span>. Springer. 2010. ISBN-10: 0387981403</li><li class="listitem">Auto MPG Data Set, UCI Machine Learning repository, <a class="ulink" href="https://archive.ics.uci.edu/ml/datasets/Auto+MPG">https://archive.ics.uci.edu/ml/datasets/Auto+MPG</a></li><li class="listitem">Quinlan R. "Combining Instance-Based and Model-Based Learning". In: Tenth International Conference of Machine Learning. 236-243. University of Massachusetts, Amherst. Morgan Kaufmann. 1993</li></ol><div style="height:10px; width: 1px"/></div><div class="note" title="Note"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div>
<div class="section" title="Summary" id="aid-RL0A1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter, you were introduced to the R environment. After reading through this chapter, you learned how to import data into R, make a selection of subsets of data for their analysis, and write simple R programs using functions and control structures. Also, you should now be familiar with the graphical capabilities of R and some advanced capabilities, such as loop functions. In the next chapter, we will begin the central theme of this book, Bayesian inference.</p></div></body></html>