- en: Managing Machine Learning Services for SQL Server 2017 and R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will tackle managing R Services and the steps necessary to get
    R Services running from a SQL Server database. In detail, this chapter will cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing SQL Server with R services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the environment and installing **R Tools for Visual Studio** (**RTVS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource Governor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sessions and logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing new R packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing SQL Server R services with PowerShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know the `sp_execute_external_script` external procedure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With SQL Server 2017 installation, configuration, and setting up the working
    environment aren't that much different, compared with how SQL Server 2016 operated
    when R was originally introduced. If there are differences between the versions,
    they will be pointed out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing SQL Server with machine learning R Services using SQL Server 2016
    and 2017 has minimal hardware requirements that depend on the edition of SQL Server
    you will be installing. SQL Server comes in several editions. More information
    is available on the Microsoft webpage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.microsoft.com/en-us/sql-server/sql-server-2017-editions](https://www.microsoft.com/en-us/sql-server/sql-server-2017-editions)'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basic R integration is available in almost all SQL Server editions, except
    the Express edition (unless it is Express with Advanced Services). This means
    that a standard SQL Server will support R services to the extent of using vanilla
    and native R code, but no advanced R integration or pushing computations to other
    computational contexts. The same logic will apply to SQL Server 2017 (at the time
    of writing), and editions and features are already made public at the following
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/sql/sql-server/editions-and-components-of-sql-server-2017](https://docs.microsoft.com/en-us/sql/sql-server/editions-and-components-of-sql-server-2017)'
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the operating system, many Microsoft OS versions (such as Windows
    Server 2012 and higher, Windows 8 and higher) are supported and, starting with
    SQL Server 2016 and higher, Linux is also supported. To have R Services running,
    a minimum of 1 GB is required, but 4 GB would be recommended, and 2.0 GHz or a
    faster processor (x64 processor type) speed would do the job. In addition, 6 GB
    hard drive space would do for the principal installation, but more disk space
    will be required based on any additional features or SQL Server services.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the edition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL Server is no longer just a database, but has grown into a database platform
    - an ecosystem -  which consists of many additional services (such as SSRS, SSAS,
    and SSIS) that supports and also extends the capabilities of modern database usage.
    When installing Machine Learning R Services (in a database), one should think
    about the ecosystem environment and which additional services would be used along
    with R Services. If the business need requires advanced R (or Python) integration
    and analytics, the Enterprise edition is the right one. If only basic R integration
    is needed, the standard version will cover the needs. Also, think along the lines
    of other analytical tools if you need analysis services or reporting services,
    and which developments tools would also be needed for that (for example, MDX on
    top of OLAP cubes and running R code against the same data mart).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have decided on the version, download the ISO or CAB installation
    file of SQL Server 2017(or 2016) and start the installation. I will install the
    Developer edition of SQL Server 2017 (which is, from the installation perspective,
    almost the same as the 2016 version):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Installation type of SQL Server'
  prefs: []
  type: TYPE_NORMAL
- en: Installing a new installation of SQL Server will guarantee that the Machine
    Learning Services with R (or in-database service) are correctly installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, the installation features must be installed. To have R Services
    installed, a tick must be placed on R for SQL Server Services (in-database), while
    for SQL Server 2017, a tick must be placed on R in the Machine Learning Services
    (in-database) section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: Feature selection for SQL Server'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following server configuration step, you must check the users and accounts
    that will have access to services. For R Services (in-database), the SQL Server
    Launchpad service will be installed and automatically started. This service can
    be started or stopped after the installation through Windows Application-Services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Server configuration for SQL Server'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the database engine is configured, you will be prompted to accept the
    agreement to install Microsoft R Open, making sure that you are aware of the fact
    that R is under GNU License. By requesting this consent, Microsoft just wants
    to make sure that the administrator agrees and that all new updates and patches
    to R Open version will be in accordance with the SQL Server update preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Prompting the content for installing Microsoft R Open'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to agreeing to R's agreement, please note that the life cycle of
    Microsoft R Server is two years. If MRS 8.0 was released in January 2016, the
    official support ended in January 2018; to be more precise, security and critical
    updates will come in for a period of one year (until January 2017) and, after
    that, only the security updates will continue until January 2018\. During the
    year, upgrades will also be received. Please note that it is relevant for the
    standalone product-Microsoft Machine Learning Server, but it is worth mentioning
    how long the support timeline will be held.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are also installing Python, the same consent will be requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Prompting the content to install Python'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have selected all of the features, configurations, and consents, you
    will be presented with an overview of the services and features to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Selected features ready to be installed'
  prefs: []
  type: TYPE_NORMAL
- en: Once the installation is completed, you will have the R Engine for Machine Learning
    Services and Microsoft Machine Learning Server with R (if selected) installed.
    Please note that R Engine for R Services (in-database) will have a different R
    installation, as the standalone Microsoft R Server, and also all the installed
    packages will be different, under different paths, rights, and security settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: Completing the installation process'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the postinstallation process, database configuration will be the next
    task. Think about database collation, because the R language is case-sensitive,
    and it matters what kind of data you will be feeding to SQL Server engine and
    pushing onward to Launchpad.Some languages differentiate the small from capital
    caps (for example, the Turkish language; the letter L in particular) and this
    might be an additional challenge when pairing SQL Server and R data types. In
    addition, based on your ecosystem, authentication should also play an important
    role in setting up the environment.
  prefs: []
  type: TYPE_NORMAL
- en: With real-time data scoring available with SQL Server 2016 and improved in SQL
    Server 2017, it is worth giving it a try. Also, for any extended use of Machine
    Learning Services, file database might be a very useful and powerful way to store
    graphs and results for later analysis, or results that can be exposed to Power
    BI, SSRS, or external applications. If you have a filestream included for tackling
    unstructured data in your business, this is also another service where the database
    configuration needs additional attention.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the environment and installing R Tools for Visual Studio (RTVS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the installation is completed, there are some post installation processes
    that need to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The external script server must be enabled so that stored procedures can call
    external script. In order to do so, run the following command against your SQL
    Server instance, where you have installed R Services (in-database):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are running this for the first time, it is disabled by default so enabling
    it is a must; otherwise, running the `sp_execute_external_script` procedure will
    not be possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can always check whether the `run_value` of external scripts enabled is
    set to 1, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: Setting up sp_configure'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the server configuration does not take effect, you need to restart the SQL
    Server service.Under services, find your `MSSQLSERVER` Service name and restart
    it (Stop and Start):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: Checking MSSQLSERVER service'
  prefs: []
  type: TYPE_NORMAL
- en: Restarting the `MSSQLSERVER` service will automatically restart all the dependent
    services, along with the `MSSQLLaunchpad` service. After the restart of the server,
    the external script will be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: After the post installation process has finished, security can be set. It is
    optional, as the default database readers are already set, but, based on your
    company's environment you are advised to look into this and set it up properly.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you will need to install **R Tools for Visual Studio** (**RTVS**).
    To do this, Visual Studio 2015 or higher is needed and, once VS2015+ is installed,
    you need to download the RTVS itself from the Visual Studio website ([https://www.visualstudio.com/vs/rtvs/](https://www.visualstudio.com/vs/rtvs/)).
    The installation process from that point is straightforward and does not need
    any further instructions now.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After configuring the database and any other additional settings used in your
    ecosystem, you will want to think about security, in terms of who will have access
    to run `sp_execute_external_script`.
  prefs: []
  type: TYPE_NORMAL
- en: You can directly create security settings on the external procedure. In this
    case, you will need to add database permissions to execute external script to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple SQL login will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s start the external procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And the error message will be, that the user `RR1` does not have permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You also have to grant the database a datareader role in order to execute the
    `sp_execute_external_script` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also check that executing external scripts is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After setting the database role and granting execute permissions, rerun the
    `sp_execute_external_script` procedure and the result of executing the external
    script should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: The results of the external procedure'
  prefs: []
  type: TYPE_NORMAL
- en: How to manage user authentication (Windows or SQL) and primary security principles;
    it should be aligned using local DBA, SysAdmin, and architect to help you delegate
    who will have access to the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A rule of thumb is to prepare stored procedures for dealing with different
    levels of data manipulation and granting access on the level of the stored procedure.
    Clean the data using this commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Resource Governor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resource Governor is a very welcome feature of R Services (in-database), as
    it enables the Govern workload against the server with a simple dataset that is
    available with the accompanying code-database `RevoTestDB`, it needs to be restored
    first**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After the restore, we will see the loads against the database and how to govern
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With this test query on my computer, the whole running time was 21 seconds and
    with elapsed time returned from R Engine, of 1.43 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up the Resource Governer to tackle picks and spikes. To have execution
    operations running faster when needed or when running a higher amount of data,
    we need to configure the external resource pool and the resource pool to grant
    the resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last step, a classification function must be created and reconfigured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, I can run the same query again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the end, the comparison in performance is obvious. In the case of my test
    environment, because I dedicated more CPU and RAM resources to executing R code,
    I get a running time of three seconds with an R elapsed time of 0.63 seconds.
    Results on your client might be different, but the change from the default resource
    governor settings to new settings should be very obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Installing new R packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An R package is a container of functions that serve a particular purpose with
    the relevant binary source code (usually C, C++, or Fortran), documentation, and
    sample data. A package is a collection of these files that reside in a library
    folder. If you navigate to your R library folder, you will see all the packages
    installed for your R Engine. A package might also be called a binary package or
    a tarball, depending on the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: A package is not equivalent to a library, nor should it be mistaken for one.
    In the R language, when installing a package the command `install.packages` is
    used. A `library()` is a function that loads functions in particular packages
    into your R environment. Deriving from the Windows OS, shared objects are called
    **Dynamic-link **library's (**DLLs**). Hence, the word library is used and refers
    to common and shared objects. So, to load a package into your R environment, the
    function `library()` is used, with the name of the package specified in brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Referring to an R library in an R script is super easy; simply add the library
    or use the `require()` method. But in the system, the library must be, in the
    first place, installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Libraries are installed by installing packages available in common repositories,
    such as CRAN, Biocondutor, GitHub, and MRAN in the case of the Microsoft repository.
    In the R language, a library is installed by invoking the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In SQL Server 2016, the installation of such packages was not possible by running
    an R script with an external stored procedure and the code returned an error,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This T-SQL code returns an error, saying that this package is not available
    for my R version. However, we will later see how to install the same package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: Warning message while installing AUC package'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can extend the original stored procedure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do this, we will be able to calculate the statistical significance for
    the correlation between two variables. The point here is that we are referring
    to the R function `library(Hmisc)` with the appropriate package name. The following
    is the detailed part of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When referring to a library, we need to have the package already preinstalled;
    otherwise, you will receive an error stating that the package does not exist.
    The same error will be received if you misspell the package name and, since the
    R language is case-sensitive, in the case of the `Hmisc` package, an error will
    occur when mistyping it as `hmisc` (without the capital letter `H`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12
  prefs: []
  type: TYPE_NORMAL
- en: Package information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packages are always saved in the `library` folder but, depending on your version
    of R (Open, Client, or Server), SQL Server instance names and paths can be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the Client or Server versions will store your libraries on your
    main drive. For the Client version, the default path is `C:\Program Files\Microsoft\R
    Client\R_SERVER\library`. You can see the folder contents in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13
  prefs: []
  type: TYPE_NORMAL
- en: 'In the R Server version, you will find libraries on the path of your default
    SQL Server instance: `C:\Program Files\Microsoft SQL Server\MSSQL14.MSSQLSERVER\R_SERVICES\library`.
    The following are the contents of a Server installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14
  prefs: []
  type: TYPE_NORMAL
- en: 'Sub-folders represent the name of installed and available packages. To find
    the default path to your packages, you can execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In my case, the following is the default path for R packages in the R Server
    edition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15
  prefs: []
  type: TYPE_NORMAL
- en: 'Much more information can be retrieved using the R function `installed.packages()`.
    In this example, we extract much more information on packages and insert the information
    into a SQL Server table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'By querying this table, you get information on library dependencies, versions,
    imports, and builds in one execution of `sp_execute_external_script`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16
  prefs: []
  type: TYPE_NORMAL
- en: In the following, we will explore how to install missing R packages. With SQL
    Server 2016 there were several ways (official or unofficial) which will be addressed
    and with SQL Server 2017, we have an elegant way of using `rxInstall` package
    or creating an external library. Both new ways introduced in SQL Server 2017 are
    far better, safer, and faster ways to install missing packages.
  prefs: []
  type: TYPE_NORMAL
- en: Using R Tools for Visual Studio (RTVS) 2015 or higher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With SQL Server 2016, Microsoft recommended installing missing packages through
    RTVS. The user should have installed RTVS ([https://www.visualstudio.com/vs/rtvs/](https://www.visualstudio.com/vs/rtvs/))
    on a client in order to install packages. Check the default paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This also returns the paths to the library folders on my machine-for R Server
    (by default `C:/Program Files/Microsoft SQL Server/MSSQL14.MSSQLSERVER/R_SERVICES/library`)
    and for the user (`C:/Users/Tomaz/Documents/R/win-library/3.2`) who is currently
    using RTVS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking the Options... section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18
  prefs: []
  type: TYPE_NORMAL
- en: 'Then select R Tools | Advanced (as shown next):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19
  prefs: []
  type: TYPE_NORMAL
- en: You will see that the R Engine has a path defined. This path is the root path
    for installing R packages. R packages are installed under the subfolder-library
    (`C:\Program Files\Microsoft SQL Server\MSSQL14.MSSQLSERVER\R_SERVICES\Library`).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, by running `install.packages("AUC")`, I can see that the server path was
    ignored and the library was installed into the user specified folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the package in the R Server folder, you need to have administrator-level
    access or have an administrator do it for you. Microsoft has discussed this issue
    on MSDN ([https://docs.microsoft.com/en-us/sql/advanced-analytics/r/installing-and-managing-r-packages](https://docs.microsoft.com/en-us/sql/advanced-analytics/r/installing-and-managing-r-packages)).
    Running Visual Studio and RTVS as an administrator does not change the result.
    To avoid this problem, you need to declare the path to the library folder of the
    R Server where you want package to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The package will automatically be installed in the R Server repository folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21
  prefs: []
  type: TYPE_NORMAL
- en: Using R.exe in CMD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When executing `R.exe` as an administrator in the binary folder of R Server
    (`C:\Program Files\Microsoft SQL Server\MSSQL14.MSSQLSERVER\R_SERVICES\bin`),
    you will be prompted with a command window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 22
  prefs: []
  type: TYPE_NORMAL
- en: From there, the user can always install the missing package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using XP_CMDSHELL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method is by far the fastest and is very useful when sharing T-SQL code,
    but it compromises using the command shell and many users and DBAs are not keen
    on this. By enabling `xp_cmdshell` in configurations and using this stored procedure,
    you can install any missing package. Using code with the `-e` switch, you can
    easily install the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will install the missing package on the R Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Running Vanilla R and adding the `install.packages()` function can be done
    if the user has been granted the permission. The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23
  prefs: []
  type: TYPE_NORMAL
- en: Using CMD and the `-e` switch, the deployment and computation of R code can
    be executed and simplified, but since this is not an official way I would not
    suggest using this, since it exposes security issues.
  prefs: []
  type: TYPE_NORMAL
- en: Copying files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copying files may sound a bit strange at first glance but, for the majority
    of packages, copying the complete library folder to the destination folder will
    also do the job. Imagine being a system administrator responsible for configuring
    a new R environment or sandbox. In this scenario, you don't want to run hundreds
    of lines of code to install all the needed packages; so, you would just copy/paste
    the folders from an image or backup. This would be a hundred times faster and
    much more convenient. Also, the packages would be already tested with R Engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a simple copy/paste, drag, and drop opretion, I copied and installed
    the, `acepack` package in my R Client environment (copied from R Server):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24
  prefs: []
  type: TYPE_NORMAL
- en: Using the rxInstallPackages function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the new version of SQL Server R Services for SQL Server 2017, a very much
    needed R function-in the `RevoScaleR` package-has been made publicly available.
    With the `rxInstallPackages` function, a user will be capable of installing any
    additional R package for a desired computational context.
  prefs: []
  type: TYPE_NORMAL
- en: With the following code, one can really speed up the installation of packages,
    without worrying about workarounds, opening additional tools, or anything else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running code from RTVS looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the same code from SQL Server is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is way too easy to be true, but it is. Make sure to do couple of things
    prior to running this code:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the compute environment to where your packages are installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the correct permissions and access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check up on the TCP/IP protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `rxInstallPackages` function, use the `computeContext` parameter to set
    either `Local` or your `SqlServer` environment; you can also use scope as shared
    or private (the difference is that, if you install a package as shared, it can
    be used by different users across different databases). You can also specify the
    owner if you are running this command out of the `db_owner` role.
  prefs: []
  type: TYPE_NORMAL
- en: Managing SQL Server R Services with PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell is very useful for managing remote machines, virtual machines, or
    even Azure VM machines. Besides this common administrative work, it has many other
    positive and useful benefits.
  prefs: []
  type: TYPE_NORMAL
- en: One can list, schedule, or work with any task-scheduled jobs or SQL Server jobs,
    based on what jobs you need to be running, and how, let's say daily for fetching
    data or recalculating and initializing predictive models, to even running models.
  prefs: []
  type: TYPE_NORMAL
- en: Another very useful aspect of PowerShell can be API communication within different
    environments and systems.
  prefs: []
  type: TYPE_NORMAL
- en: For system administrators, PowerShell will be very useful for distributing and
    maintaining any additional R packages among client machines or even among R Server
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the sp_execute_external_script external procedure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SP_EXECUTE_EXTERNAL_SCRIPT` is a stored procedure that executes a provided
    script as an argument on an external script to a provided language (in this case,
    the R language). With SQL Server 2017, Python is also supported and it is said
    that, in the future, other languages, such as Java, C#, and C++, will be supported
    (through Launchpad).'
  prefs: []
  type: TYPE_NORMAL
- en: '`sp_execute_external_script` is a system procedure that evokes and sends the
    passed code to an external engine and returns the result to SQL Server in the
    form of a table. Script has a set of arguments that will navigate to T-SQL code
    and data to R Engine, with R code included.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following arguments are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`@language`: This specifies which language will be used in the external procedure.
    For SQL Server 2016, the R language is available and with SQL Server 2017 Python
    is available. The argument is of the `sysname` build-in data type and has a limit
    of 128 Unicode characters. This is why we use N in front of the value, to denote
    the `nvarchar` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@script`: Native R or Python code is passed with this argument to the Launchpad
    service. This external code (external to SQL Server) must be validated and properly
    formatted (only in the case of Python), since SSMS or RTVS will not validate this
    argument. Therefore, the easiest way to do this is to use Visual Studio and validate
    your R code in RTVS or your Python code with **Python Tools for Visual Studio **(**PTVS**).
    This field is of the `nvarchar` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@input_data_1`: This takes your T-SQL code as the source of data for an external
    procedure. This code will be validated and checked by SSMS or VS. This field is
    also the `nvarchar` type and can execute literally any T-SQL code. There are a
    few limitations as to what data types can be inputted, because of external engine
    (the R language) limitations. The R language itself supports fewer data types
    as compared with SQL Server 2016\. Data types supported are logical, numeric,
    integer, complex, character, and raw. So immediately, one can see that the following
    data types (unless converted to the R data type) will deliver some problems. Let''s
    just state a few SQL Server data types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cursor`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Timestamp` (hash format not date time format)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Datetime2`, `datetimeoffset`, `time`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All Unicode text data types: `nvarchar`, `nchar`, `ntext`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sql_variant`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Text`, `image`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XML` (includingJSON, as it is an XML datatype format in SQL Server 2017)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hierarchy`, `geometry`, `geography`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Any CLR or assembly bound data type built using the .NET framework or any Launchpad
    service-supported language
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to some of the data types'' limitations, there are also T-SQL clauses
    and statements that cannot be used as part of the input data argument. These are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Stored procedure (UDF, Table value functions))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical `IF` and `WHILE`, `FOR` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporary variables or tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No updates, inserts, or deletes (only select)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GO` statements or semicolons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OUTPUT` clauses from and DML statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referencing any CURSORS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following statements (besides the `SELECT` statement) can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT` with multiple `JOINS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WITH`commontable expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNION`, `UNIONALL`, `EXCEPT`, `INTERSECT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any `SET`, `STRING`, `LOGICAL`, `COMPARISON`, `BITWISE`, `ARITHMETIC`, `COMPOUND`
    operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COLLATE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As already mentioned DML statements, `@input_data_1` argument also does not
    support any DDL statement or clause.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid the data type collisions between the T-SQL language and external scripts,
    the best practice is to do as much data preparation, wrangling, and optimization
    as possible prior to throwing the desired dataset into the argument. Also, many
    restrictions can be compromised with conversion to the R closed data type.
  prefs: []
  type: TYPE_NORMAL
- en: '`@input_data_1_name`:This holds the name of the dataset that will be used in
    the R script as an input dataset. By default, the external procedure `sp_execute_external_script`
    will be using the following:-`InputDataSet` for inputting data and-`OutputDataSet`
    for returning result data (both are default values). Please note that the R language
    is case-sensitive, so the name of your dataset provided in this argument must
    be written in the same manner also in R code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@output_data_1_name`:This argument holds the definition of the returned result
    from an external script as a variable returned to any stored procedure. The returned
    dataset must be in the `data.frame` format in the R language. Data.frame is a
    set of vectors and is a representation of a table, which T-SQL Server can import
    and use further with any other T-SQL clause or statement: or it can store the
    results directly into SQL Server table. This argument is a `sysname` data type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@parallel`:This is an argument that will explicitly tell the R Engine to parallelize
    computations in R. This parameter has been introduced with later versions of SQL
    Server 2016 (SP/CU) and is very welcome for any type of R code, functions, or
    packages that do not use parallelism for `RevoScaleR` computational functions.
    Of course, this is true in relation to trivial R scripts and in the case of large
    input datasets. R functions from a particular R package will deliver much better
    performance results if the package itself is written in C++ (and not the original
    Fortran) and, if the R script does not include relatively complex data wrangling/munching
    instructions, in particular and of `plyr`/`dplyr` or `data.table` function. Just
    remember the simpler, the better.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To check whether the workload can be distributed in parallel, simply observe
    the execution plans and look for degrees of parallelism in the plan when running
    T-SQL code. Also note that any local setting of MAXDOP will also have an effect
    on the desired parallelism. In other words, if MAXDOP is turned off, and you set
    your argument `@parallel = 1`, do not expect much of a distributed workload, since
    parallelism is by default turned off.
  prefs: []
  type: TYPE_NORMAL
- en: When running and using any of the computational functions available in the `RevoScaleR`
    package, Launchpad will automatically take care of parallelism, using distribute
    R functions, available in R Server or SQL Server R Services.
  prefs: []
  type: TYPE_NORMAL
- en: '`@params`: This is an argument where any additional variable can be declared
    and specified as a variable(s) that can be used in the R script. The parameters
    can be specified as input or output and are very handy when feeding the predictive
    model to your R code or when exporting additional information from R code (besides
    the specified results set). Using this parameter as an output can return a single
    value/column and not a table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@parameter1`: This is an argument where the values of the parameters are specified
    and used within the R script in the form of an input or output variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered the installation of Machine Learning Services (in-database),
    the configuration of the services and how to administrate the services. It has
    also explored the installation of missing packages and covered security and the
    resource governor. In the last section, the chapter also gives an explanation
    of how to use external procedures and the `sp_execute_external_script` with all
    arguments. Several examples have been covered through digging into security issues
    and the installation of missing packages. The installation of missing packages
    was heavily dependent on the article in SQLServerCentral.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to machine learning services and using an external procedure
    will be the foundation for all of the following chapters, which will all heavily
    rely on a good understanding of configuring and using this procedure.
  prefs: []
  type: TYPE_NORMAL
