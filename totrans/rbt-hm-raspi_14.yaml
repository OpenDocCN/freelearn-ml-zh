- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing Your Journey – Your Next Robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, you’ve learned how to plan, design, build, and program
    a robot. We’ve covered many fundamental topics with some hands-on experience,
    examples demonstrating the basics, and ideas for improving them. In this chapter,
    we will briefly recap our knowledge to take it further.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about your next robot, we’ll answer questions such as the following
    – how would you plan and design it? What skills might you need to research and
    experiment with? What would you build?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A summary of what you have learned in this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning to extend this robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning your next robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further suggested areas to learn about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Diagramming tools such as a pen or pencil and paper to sketch ideas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cardboard, a ruler, and cutting tools to make a test fit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A computer with internet access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sketching tools such as [https://app.diagrams.net/](https://app.diagrams.net/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A summary of what you have learned in this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a robot builder, you have started from the basic plan for a robot. You learned
    about skills useful for robotics, designing, building with tools, programming,
    interfacing electronics, or integrating systems combining all of these, so let’s
    dive deeper.
  prefs: []
  type: TYPE_NORMAL
- en: Basic robotics with Raspberry Pi Pico
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the first chapter, we learned about Raspberry Pi Pico, why it’s a great
    controller for robots, and how it stacks against others, considering the trade-offs
    between Pico and its larger Raspberry Pi family.
  prefs: []
  type: TYPE_NORMAL
- en: We covered ways in which Raspberry Pi Pico can be programmed and chose CircuitPython
    for it. CircuitPython has excellent access to hardware, with a growing library
    of support for many electronics modules used in robotics.
  prefs: []
  type: TYPE_NORMAL
- en: 'We took a tour of concepts such as the interface ports:'
  prefs: []
  type: TYPE_NORMAL
- en: GPIO to control or interface externally from Pico.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UART, SPI, and I2C form data buses to send and receive data from devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unique **Programmable Input/Output** (**PIO**) peripheral lets you adapt
    or build interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then planned a robot around Raspberry Pi Pico, considering its size, type,
    and complexity. We calculated the power requirements and specified a driver board
    to control motor power. We thought about the sensors we might want to use and
    how all these decisions are trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: We considered the GPIO pin usage, ensuring that all the chosen devices would
    be usable on Raspberry Pi Pico together.
  prefs: []
  type: TYPE_NORMAL
- en: We then used simple cardboard templating to test-fit our basic robot design
    to see whether it was a viable plan to take to the next stage.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at places to shop for parts, drew up a parts list to shop for, and
    bought the components and tools needed to build the moving robot.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B18001_03.xhtml#_idTextAnchor055) and [*Chapter 4*](B18001_04.xhtml#_idTextAnchor080),
    after designing a robot using FreeCAD in 3D, we then built the robot using sheet
    plastic and simple tools.
  prefs: []
  type: TYPE_NORMAL
- en: After building the robot platform, in [*Chapter 5*](B18001_05.xhtml#_idTextAnchor098),
    we used GPIO to control the motors, demonstrating the initial movements of the
    robot. Then, we used this to drive along a planned path, demonstrating that we
    can control it in sequence and observing some of the shortcomings of control without
    sensors.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we looked at the initial sensors on the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Extending a Raspberry Pi Pico robot with sensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We were able to add sensors and learned how to make use of them. In [*Chapter
    6*](B18001_06.xhtml#_idTextAnchor115), we used encoder sensors that were part
    of the motor assembly, and then in [*Chapter 7*](B18001_07.xhtml#_idTextAnchor139),
    we specified additional sensors – where we would fit them, the modifications we’d
    need to make to the chassis, and which sensors to buy. Adding sensors is where
    block diagrams of the robot’s hardware came in handy to see what was connected
    where.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the sensors we used in our robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – The sensors on our robot ](img/Figure_14.01_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – The sensors on our robot
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram shows the sensors we used on the Raspberry Pi Pico robot.
    The sensors are numbered:'
  prefs: []
  type: TYPE_NORMAL
- en: The encoders can measure the movement of the robot’s motors and, by extension,
    the robot’s wheels. We can use these to measure distance or speed. We covered
    using Raspberry Pi Pico’s PIO system to read these sensors continuously so that
    our code would not miss encoder steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The distance sensors (from [*Chapter 8*](B18001_08.xhtml#_idTextAnchor166))
    can detect how far away objects in front of the robot are. We interfaced these
    using I2C and looked at how to mount them and wire them in and at the programs
    used to fetch distance information from them. We learned how these sensors work
    by bouncing a signal off objects to sense them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bluetooth (from [*Chapter 9*](B18001_09.xhtml#_idTextAnchor189)) is not a sensor
    but more of a communication system. We were able to build a shelf to fit the Bluetooth
    LE module, wire it in, and write code so we could communicate between Raspberry
    Pi Pico and a smartphone. We could use the phone to control the robot and display
    or plot data from the robot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We added an **Inertial Measurement Unit** (**IMU**) in [*Chapter 12*](B18001_12.xhtml#_idTextAnchor252)
    and learned how to use it to sense the robot’s orientation by combining results
    from an accelerometer, gyroscope, and magnetometer. First, we looked at how to
    connect this with I2C and then how to calibrate (set up and orient) the sensor
    and get initial readings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As well as adding the sensors, we began exploring what our robot could do with
    them and wrote behaviors utilizing them.
  prefs: []
  type: TYPE_NORMAL
- en: Writing CircuitPython behavior code for Raspberry Pi Pico
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We wrote programs that made the robot use sensor inputs to drive its motors
    in smart ways, defining these kinds of programs as behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: The first behaviors (from [*Chapter 5*](B18001_05.xhtml#_idTextAnchor098)) followed
    a pre-planned path with motors only; however, without sensors, this wasn’t very
    accurate. In [*Chapter 6*](B18001_06.xhtml#_idTextAnchor115), we learned about
    the encoder sensor and measuring encoder counts, and then saw how to use them
    to stop driving at a fixed count. This code introduced sensor loops, with feedback
    from the sensors used to control the motors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, starting from [*Chapter 7*](B18001_07.xhtml#_idTextAnchor139),
    we specified more peripherals to add. We started with the distance sensor in [*Chapter
    8*](B18001_08.xhtml#_idTextAnchor166), where we learned how to make a behavior
    to avoid colliding with walls.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B18001_09.xhtml#_idTextAnchor189), we linked up the Bluetooth
    device, which opened more exciting and complex behaviors by letting us observe
    and plot sensor data.
  prefs: []
  type: TYPE_NORMAL
- en: The scope of sensor feedback loops became more interesting when we learned about
    the **Proportional-Integral-Derivative** (**PID**) algorithm in [*Chapter 10*](B18001_10.xhtml#_idTextAnchor210),
    letting us set up smooth motor responses to stimuli. We demonstrated this with
    distance sensors to keep at a known distance from an object. We then used the
    same technique to follow walls, which was most satisfying to test with a few boxes
    in the middle of the room, watching the robot navigate autonomously around them.
  prefs: []
  type: TYPE_NORMAL
- en: The PID algorithm prompted us to revisit the encoders in [*Chapter 11*](B18001_11.xhtml#_idTextAnchor233).
    We converted counts into standard speed units and then used the PID algorithm
    to control the motor and wheel speeds to meet a value in meters per second. This
    refinement allowed the robot to travel in a straight line, and controlled its
    motion to drive it for a known distance at a desired speed; for example, we could
    instruct a robot to travel 1 m in a straight line at 0.17 m/s.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of the IMU in [*Chapter 12*](B18001_12.xhtml#_idTextAnchor252),
    once we had connected and calibrated it, we learned how to use the IMU to get
    the robot’s orientation. We then connected that with a PID algorithm to make the
    robot turn to face north, regardless of its initial heading.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how to use the IMU to make a precise turn – 90 degrees or
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 13*](B18001_13.xhtml#_idTextAnchor274), we learned about Monte
    Carlo simulation, with which we simulated many potential poses for the robot,
    using the encoders to track movements. We used sensor input to give each pose
    a likelihood weight. The weights were used in a resample algorithm to select the
    most likely poses. A combination of sensor fusion and statistics makes a robot
    feel smart as it estimates its position in an arena. We also demonstrated two
    behaviors running together, with collision avoidance running alongside Monte Carlo
    simulation.
  prefs: []
  type: TYPE_NORMAL
- en: This robot has some interesting capabilities, but where do we take them next?
  prefs: []
  type: TYPE_NORMAL
- en: Planning to extend this robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I rarely view robot projects as complete, especially those that are learning
    and development platforms. There are always new sensors to try, new programming
    algorithms to make, or simply bugs and quirks to iron out. On the other hand,
    there are ways to make robots more robust and cope with rougher environments,
    making the chassis lighter or the electronics simpler, so let’s start by considering
    some ideas for this robot and hopefully inspire some of your own.
  prefs: []
  type: TYPE_NORMAL
- en: Sensors you could add
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first exciting way to extend this robot is to add more sensors. Sensors
    are fun to program to get data from. This means you may have to figure out how
    to incorporate them into existing behaviors and mount them, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows a selection of sensor extensions that could be interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Robot sensor extensions ](img/Figure_14.02_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Robot sensor extensions
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure shows a selection of sensors that would be great to extend
    this robot and the things you could get it to do. The sensor types are numbered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line detectors** or **reflectance sensors**: These light up with an **Infrared**
    (**IR**) LED and then detect how much light reflects from an object that they
    point toward, or how bright/dark it is. Makers mount these under the robot as
    a line-following sensor. Some sensors, such as the *SunFounder 5-channel line
    sensor*, come with arrays of light detectors, which can be used with code to follow
    a line drawn on a floor. An example of a single sensor type is a TCRT5000.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bump switches**: Makers use these less in modern robots, and distance sensors
    should mean they aren’t needed. However, you could use them so that if a robot
    surpasses a safe distance and bumps into something, it will immediately disengage
    or move back. They tend to be simple on-off switches with long lever arms to extend
    the edge along which they sense.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Additional distance sensors**: We’ve used two sensors and moved them around.
    A set of four sensors would allow the different existing behaviors to be enhanced.
    It also offers more information for Monte Carlo simulation and could be used for
    a maze-following behavior.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A camera**: There are camera sensors that we could use with Pico, such as
    OV7670 camera modules. They are complicated to connect and may require an additional
    Raspberry Pi Pico. Using downscaling and running edge detection or ML algorithms
    on it, it is possible to match objects. A good alternative is cameras with onboard
    processing, such as the HuskyLens ([https://bit.ly/3Dzurrb](https://bit.ly/3Dzurrb)).
    Another type of camera is a FLIR IR heat camera.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**LIDAR sensors**: These scan and return the depths of objects in their field
    of view. Having many distance sensors could extend the accuracy of Monte Carlo
    simulation. However, these produce a lot of data quickly and may need a more powerful
    CPU to control them. Solid-state sensors are low-power, small, and cheap. Pictured
    in *Figure 14**.2* is an LDRobot LD-07 solid-state LIDAR.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Light sensors can read how much light falls on them. You could use these to
    program behaviors that move toward or away from light or more complex interactions
    with light.
  prefs: []
  type: TYPE_NORMAL
- en: A robot can have internal sensors, such as thermal, current, and voltage monitors,
    to monitor its batteries and motors so that the code can respond to low-battery
    or high-current scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Optical flow sensors, such as the PAA5100JE, facilitate odometry based on the
    flow of the ground below a robot and can be used to detect the overall speed of
    the robot; this can compensate for issues such as wheels slipping, which encoders
    would miss.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve covered some sensor ideas for our robot, but another way to get information
    to and from a robot is through user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the robot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The robot in this book doesn’t have many options for user interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Human interaction I/O ](img/Figure_14.03_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – Human interaction I/O
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14**.3* shows many ways to improve human interaction with the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Buttons**: Add buttons for starting and stopping a behavior on a robot.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**LED lights**: Some LED lights, perhaps with different colors, can be good
    to show a little feedback on what is running. Big LEDs can also be used as headlights.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**RGB LED displays**: These come in strips or panels, and each LED can be set
    to a different color. They can provide more debugging and can make cute eyes or
    faces too. They use multiple interfaces, a custom one-pin system, and SPI or I2C.
    The Pimoroni PIM435 pictured uses I2C.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**OLED screens**: These can show pictures, dials, menus, text, or graphics
    right on the robot. These come in mono or color varieties and are frequently I2C-controlled.
    One such mono I2C device is the Velleman WPI438 I2C screen.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Game joypads**: A game joypad controller would be a nice way to control a
    robot. However, it may require a more advanced Bluetooth setup to interface with
    Raspberry Pi Pico.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A phone web app**: We’ve been using the BlueFruit app, but by swapping Bluetooth
    for Wi-Fi (such as with Raspberry Pi Pico-W), you can write far more interactive
    phone control. This will require writing more code for a frontend. At the time
    of writing, a system for graphing on a smartphone requires a fair amount of code
    to produce over Wi-Fi, and a convenient app, such as BlueFruit LE Connect, doesn’t
    yet exist.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A beeper**: These can make beeping and buzzing sounds for the robot. You
    can drive some of these directly from GPIO pins, with musical tones indicating
    the program’s state or making interesting sounds.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A microphone**: There are UART-capable voice control modules suitable for
    Raspberry Pi Pico. They have a small set of commands to start behaviors, and,
    with LED or beeper feedback, could be a novel way to interact with the robot.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User interactions can manipulate behaviors, but we need somewhere good to mount
    these LEDs. What can we do to the robot’s chassis to improve and extend it?
  prefs: []
  type: TYPE_NORMAL
- en: Chassis and form enhancements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The robot’s chassis is simple and light, but we could take this much further,
    making it a more robust or aesthetically pleasing robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Chassis enhancements ](img/Figure_14.04_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – Chassis enhancements
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14**.4* has examples of two ways to improve the robot or its sensors
    with an outer shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14**.4* (*1*) shows a lunchbox adapted into a robot. A lunchbox, ice
    cream tub, or roller paint tray with holes cut into it can be made into the fairing
    for the robot, enclosing the electronics and holding its wiring and electronics.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 14**.4* (*2*) shows a robot with sensor mounts that have been 3D-printed.
    Custom fairings and brackets can be made this way or through vacuum forming or
    laser cutting. See the *Design and manufacturing* section later in this chapter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whichever method you choose, it needs to be lightweight and easy to remove so
    that the electronics are accessible and you can change the batteries. It could
    be held in place by bolts or Velcro.
  prefs: []
  type: TYPE_NORMAL
- en: You‘ll need to consider how to make controls accessible – such as putting switches
    and charging ports on the outside. Having a fairing invites more decoration, the
    use of color, and style paneling. Combining this with the RGB LEDs could make
    for an interesting-looking robot. You could take style cues from your favorite
    sci-fi robot and use a similar color scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Electronics enhancements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The electronics we’ve used so far have been composed of modules tethered together
    with connector cables, using breadboards to assemble them. Breadboards are great
    for prototyping but take up a lot of space and weight and are susceptible to movement
    and vibration, with wires quickly coming loose or forming poor connections. They
    also look messy. What could we research to upgrade this?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some sturdiness enhancements we can make to the robot electronics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Improving robot electronics ](img/Figure_14.05_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Improving robot electronics
  prefs: []
  type: TYPE_NORMAL
- en: 'Electronics in the robot could be made smaller, lighter, and tidier. Try these
    ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Pictured in *Figure 14**.5* (*1*) is an Inventor 2040 W from Pimoroni ([https://shop.pimoroni.com/products/inventor-2040-w](https://shop.pimoroni.com/products/inventor-2040-w)).
    Motor and robot boards for Raspberry Pi Pico or incorporating an RP2040 will reduce
    the amount of wiring. The Inventor 2040 W includes motor control, lights, and
    servo connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Soldered boards will be tidier. An intermediate option is using a stripboard
    or perfboard. These pre-made printed circuit boards can mimic the wiring arrangement
    of breadboard strips, allowing you to transfer breadboard designs onto them. You
    can then solder parts and wires into them. Wires going to external parts, such
    as motors and sensors, will have their connectors soldered into the board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 14**.5* (*2*) shows a custom **Printed Circuit Board** (**PCB**) from
    [https://github.com/uwrobotics/MarsRoverHardware](https://github.com/uwrobotics/MarsRoverHardware).
    You can download or design your own using software such as KiCad. This is complicated
    but gives you lots of options for customization. You use a PCB view to lay out
    a circuit board and route connections between parts. Using PCBs allows you to
    make small, light, and tidy robot designs. In addition, it opens your designs
    to using surface mount electronics, which makes more components available. You
    can use **design rules** to ensure that the connections are all made and tracks
    are not touching. After this, you can then prepare the part for manufacture. You
    can take these designs to a board house, such as Seeed Studio ([https://www.seeedstudio.com/](https://www.seeedstudio.com/)),
    that prints the board for you.'
  prefs: []
  type: TYPE_NORMAL
- en: Some board houses offer a **Printed Circuit Board with Assembly** (**PCBA**)
    service, where, at additional cost, they will solder on components, sockets, and
    connectors before sending the part to you. Using a PCBA service means you just
    need to plug in the external sensors and perhaps a Pico into a socket on receiving
    the board. That means that you do not need to solder surface mount parts yourself.
    Just be aware that this will take experience, and you may produce boards that
    aren’t right the first time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Tidying wiring ](img/Figure_14.06_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – Tidying wiring
  prefs: []
  type: TYPE_NORMAL
- en: You can tidy robot cabling using 6 mm spiral wrap and cable clips, as shown
    in *Figure 14**.6* (*3*), or just masking tape, as shown in *Figure 14**.6* (*4*).
    Wiring can be aesthetically pleasing if you make an effort to route it nicely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For connectors, we have used Dupont connectors due to their convenience. However,
    once you are on a soldered circuit board, you can consider locking connectors,
    such as JST or Molex PicoBlade connectors. These lock cables in place so that
    they will not vibrate loose or easily be pulled out, and add further protection
    by being polarized. You will need to get practice with a crimping tool to use
    these effectively, but it will be worth it for better robot builds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With a robust chassis and tidier electronics, perhaps you can get more ambitious
    with further outputs. Let’s see things you could make the robot’s outputs do.
  prefs: []
  type: TYPE_NORMAL
- en: Outputs you could add
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Outputs mean a robot could do more to move or alter its surroundings. Additional
    motors, such as servo motors, can be used to make interesting mechanical devices,
    for example, those shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7 – Motors and outputs in use ](img/Figure_14.07_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – Motors and outputs in use
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14**.7* shows a few interesting ways to use further motors to extend
    the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A gripper** – This could grasp items and move them around. The Pololu Micro
    Gripper Kit uses a single servo to open or close the jaws. These are fun to attach
    to the front of a robot.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A pan-and-tilt mechanism** – Putting sensors on this means you can direct
    a sensor at a particular point of interest or use the head to sweep with a sensor.
    One servo motor rotates the head left and right (panning), and the other tilts
    the head up and down. The Adafruit Mini Pan-Tilt Kit is a good example of this.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A lift-and-lower mechanism** – These use a motor to lift and lower a platform,
    like a forklift. This could be combined with the gripper to make a robot that
    can stack objects.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A ball launcher** – A launcher would be fun so that a robot could aim at
    targets. Robotics competitions such as PiWars have events that involve using these.
    Motors are required to direct the aim, and a motor or actuator is required for
    launching the ball.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are just a few examples; there are plenty more mechanisms you can either
    buy or build. You could even add a whole arm with a kit such as the MeArm Servo
    Robot Arm Kit.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen some outputs, perhaps we can better use these sensors and
    outputs with more behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the code and behaviors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The robot’s code and behaviors are what bring the robot to life. However, there
    are many ways we could improve the code on this robot, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8 – Behavior suggestions ](img/Figure_14.08_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – Behavior suggestions
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14**.8* depicts some suggestions; the following list covers these and
    more:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line-following**: Using the line detection sensors previously mentioned in
    the section on sensors, you could program a robot to follow lines drawn on the
    floor. Line-following can use *if-then, bang-bang* control, or a PID algorithm
    for smooth line-following.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A menu system**: You can combine all the behaviors in a menu for selection.
    Consider how each program would be tidied up so another can take over. A variation
    of this is using a voice control module, along with beeps, to indicate the current
    robot mode.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Driving with a camera**: Adding a camera and serving it to a phone web app
    means you could drive the robot with a camera view – a robot periscope.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Maze solving**: With more distance sensors, the robot would be able to look
    for openings and find its way around a maze. Depending on the complexity of the
    maze, simple rules such as always turning left might work, or the robot might
    have a map of the maze and use the Monte Carlo method with precision navigation.
    For example, a turning-left method using the encoders might be able to memorize
    what turns it took and where, backtrack, and try other routes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Camera navigation**: Camera images can be scaled to low resolutions, and
    algorithms can be used to pick out features where image intensity or colors have
    changed over a threshold. The detected feature locations can then be combined
    with a PID algorithm to orient the robot relative to such features.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Camera recognition**: Recognition is considerably more complex and may require
    looking at a machine learning system such as TinyML. See [https://bit.ly/3xy3twx](https://bit.ly/3xy3twx)
    for news on TinyML ports for CircuitPython. You can use similar techniques with
    microphones for speech recognition, but this may be intensive enough that multiple
    Raspberry Pi Pico boards would be required.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following suggestions are not pictured but represent advanced behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simultaneous Location and Mapping** (**SLAM**): A robot can use its sensors
    to build up a map of its location and then keep track of its pose relative to
    what it has already mapped. This technique would use several sensors together
    and benefit from the LIDAR sensors that we have already mentioned. However, this
    advanced technique can be a deep rabbit hole!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task planning** and **motion planning**: Combining controlled turns, controlled
    movements, and location tracking with a hopper or gripper would mean you could
    make behaviors to seek out, collect items, and place them in a collection point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These suggestions should hopefully inspire some creative behaviors. There are
    endless possibilities for combinations of code, sensors, and outputs, which you
    can use to improve your knowledge, solve problems with a robot, and extend your
    toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: So far, though, these suggestions have been focused on extending the existing
    platform. So, what happens when we extend to thinking about your next robot platform?
  prefs: []
  type: TYPE_NORMAL
- en: Planning your next robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015), *Planning a Robot with Raspberry
    Pi Pico*, we saw a few styles under the *What style of robot is suitable?* section.
    Now, inviting a greater level of imagination, let’s revisit how different a robot
    can be.
  prefs: []
  type: TYPE_NORMAL
- en: Form, shape, and chassis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll start by considering the styles from [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015)
    again and how you might get there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.9 – Different robot styles ](img/Figure_14.09_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.9 – Different robot styles
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure shows four styles of robots. We can now imagine more variations
    on these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A larger wheeled platform** to hold more sensors and electronics, perhaps
    with a more interesting wheel arrangement.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A hexapod robot** with six legs – for exploring walking and gaits. This will
    use lots of servo motors.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A robot arm**, such as the MeArm mentioned previously. These can be servo
    motor-based or stepper motor-based.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A quadcopter drone** is super-light, but involves more interesting IMU and
    PID use.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram shows a few other robot ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10 – More robot types ](img/Figure_14.10_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.10 – More robot types
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14**.10* shows a few more types of robots you could consider for your
    next project; these are potentially more ambitious as far as the ideas go:'
  prefs: []
  type: TYPE_NORMAL
- en: A **snake robot** is made of multiple robot segments with distributed electronics.
    The segments can flex like carriages on a train, with power and control running
    along between the segments. You can use servo motors to control the flex, and
    motors on segments driving wheels or tracks provide traction to pull the snake
    along with sensors. The front segment usually carries forward-facing sensors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **submarine robot** would be fun to use to explore lakes or ponds. These require
    thinking about how you would power an immersed motor, how you might safely retrieve
    a robot if it loses power, and how you would control it through water, which can
    block RF signals such as Bluetooth or Wi-Fi. A tether cord may be necessary. You’ll
    need to think about weighting, ballasts, and movable thrusters. A fun variation
    may be an amphibious floating robot that can drive on land, move in the water,
    and dive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*A*n **XY** or **gantry-type robot** frequently uses stepper motors, arranged
    so one set moves along each axis. 3D printers, CNC mills, and laser cutters frequently
    use this type. They can also be used to plot images or with a grabber to pick
    up objects and place them somewhere.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These robot variations should inspire you. Next, let’s look at a few variations
    on the wheeled platform.
  prefs: []
  type: TYPE_NORMAL
- en: Variations on wheels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The wheeled platform is still a practical and straightforward robot style.
    However, you can extend those wheels in many exciting ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Caterpillar tracks** can offer more traction than wheels and deal with uneven
    surfaces. They also look attractive. Some types use a single rubber molded track,
    such as the tracks on the tiny Zumo chassis, and others use tracks made of links,
    such as those on the Devastator robot chassis. Depending on these types, you may
    run into problems with friction when trying to turn, and may need more torque
    depending on the surface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mecanum wheels** are unique. As well as moving forward/back and turning,
    mecanum platforms can also “*crab-walk*” sideways and drive in almost any direction;
    you will need four independent motors and some specialized control algorithms
    for this implementation. See [https://bit.ly/3y1Kjzp](https://bit.ly/3y1Kjzp)
    for an example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tristar wheels** are clusters of three wheels set up so that either individual
    wheels can turn or whole clusters can turn; this allows them to climb up steps
    depending on their relative size. They are mechanically complicated, but you can
    drive them like regular wheels. They should be a four- or six-wheel drive combination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independent drive** uses individually steerable wheel pods; the Mars Discovery
    rover has these, with a stepper or servo motor turning each wheel assembly, and
    each wheel being individually drivable too; they can both crab-walk and steer.
    These are more complicated than mecanum wheels but are robust.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we have some idea of the next robot’s form and ways we could build on the
    simple wheeled chassis. What process would you use to design the robot?
  prefs: []
  type: TYPE_NORMAL
- en: Design stages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You would design a robot such as this by starting with sketches and simple cardboard
    parts as we did in [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015), *Planning
    a Robot with Raspberry Pi Pico*, and then take the design to CAD as you become
    clearer on what it is you want.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at some of the electronics further, but you’ll want to incorporate
    those into the CAD designs so you are clear on the dimensions and where to attach
    things before fabricating any parts for a robot.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the electronics.
  prefs: []
  type: TYPE_NORMAL
- en: Electronics and sensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to adapt the electronics for each form and use case. For example,
    larger robots with larger motors will naturally need larger motor controllers
    and power systems capable of handling more significant power requirements. Larger
    motor drivers include the LM2575, capable of handling 15 A motors at 36 V.
  prefs: []
  type: TYPE_NORMAL
- en: Robots with servo motors will need controllers such as the Adafruit 16 servo
    controller to handle the power and control of many servo motors. Robots with stepper
    motors may need similar breakouts for stepper motors, although depending on the
    precision needed, a DC motor controller with four channels can also drive stepper
    motors.
  prefs: []
  type: TYPE_NORMAL
- en: Submarine robots need to be waterproof, and quadcopters need high efficiency.
    For these, brushless motors are most suitable, and they will need to be driven
    by **Electronic Speed Controllers** (**ESCs**). Some wheeled robots also use brushless
    motors for their great efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: An integrated motor controller such as the Pimoroni Inventor 2040 W (seen in
    the *Electronics enhancements* section) or the Pimoroni Servo 2040 might make
    sense for smaller robots. For example, the Servo 2040 can control 18 motors, making
    it ideal for a 6-legged hexapod robot.
  prefs: []
  type: TYPE_NORMAL
- en: Where more battery power is required, you may need an upgrade from AA batteries
    to Li-ion or LiPo technology. In addition, you will need to carefully consider
    battery management systems that prevent catastrophic events and ensure you have
    chargers for them. The Lipo SHIM from Pimoroni will help charge these and power
    Raspberry Pi Pico.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of sensors, you can consider the full range described previously. When
    planning them, consider which Raspberry Pi Pico pins will be in use. [https://pico.pinout.xyz/](https://pico.pinout.xyz/)
    is an excellent resource for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: As you use more pins and sensors, you may have to use more I2C sensors, which
    may require I2C multiplexers, such as TCA9548A modules. If the sensors are not
    I2C and simply need GPIO pins, then a PCF8574 adds other GPIO pins over I2C. If
    you need to add more complex sensors, a second Raspberry Pi Pico or RP2040-based
    board might be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: You can also consider adding I2S audio amplifiers for speakers for sounds more
    interesting than beeps and microphones for sound recognition on Pico.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth considering whether the robot application requires a powerful
    CPU such as a full Raspberry Pi, and reserving Raspberry Pi Pico as an IO coprocessor.
  prefs: []
  type: TYPE_NORMAL
- en: For a robot such as a snake robot, you may consider how you’d need to wire the
    modules throughout the segments. If you build a submarine robot, how will you
    protect electronics against water getting in?
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the kind of code you might try with these designs.
  prefs: []
  type: TYPE_NORMAL
- en: Code and behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Choosing the code has a few factors:'
  prefs: []
  type: TYPE_NORMAL
- en: What control code do you need for the sensors, outputs, and mechanisms?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How smart does the robot need to be to solve specific problems?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What safety factors might be needed, and how will this interact with the form
    and shape? For example, what control system might you need to stop a robot quickly?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The control mechanism for a legged robot may need code to group servo motors
    into legs with multiple joints and then smoothly move between positions defined
    by gaits – walking strategies. These are generally sequenced patterns; they may
    adjust or carry on following a sequence depending on feedback from the legs or
    foot sensors. Usually, the gait code controls the movement, with another program
    steering this gait code in a **horse-and-rider** configuration.
  prefs: []
  type: TYPE_NORMAL
- en: With a robot arm or snake robot, researching **inverse kinematic** algorithms
    would help to position parts of the robot relative to other parts, choosing the
    angles at which the servos along the arm or the snake need to be to reach this
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Robots that use a more powerful CPU running Linux may justify going beyond simple
    Python scripts into **Robot Operating** **System** (**ROS**).
  prefs: []
  type: TYPE_NORMAL
- en: If speed is an issue, you can consider a fast controller such as a Teensy, a
    powerful controller such as Raspberry Pi, or explore other programming languages
    such as C and Rust. You can use C to extend CircuitPython and Python to glue together
    different robot functions.
  prefs: []
  type: TYPE_NORMAL
- en: If you start to need multiple RP2040 controllers, how will they communicate
    and interact with each other? Via an I2C bus or UART? You may need to research
    and consider a protocol for them to send requests to each other.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now considered the robot’s form and chassis, the electronics it might
    need, and the code you will want. Learning about more ways to build robots or
    situations in which to test and demonstrate code can help you build these new
    robot designs.
  prefs: []
  type: TYPE_NORMAL
- en: Further suggested areas to learn about
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have some ideas for a future robot (or even a few future robots) that you
    want to build. Learning about some other skills will allow you to take those designs
    further and get more creative. Let’s dive in.
  prefs: []
  type: TYPE_NORMAL
- en: Electronics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the *Electronics enhancements* section earlier in this chapter for
    inspiration here. To recap, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about designing circuits with stripboard or veroboard and further soldering
    skills.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more about designing PCBs with tools such as KiCad. You place parts such
    as Raspberry Pi Pico (or, if you are braver, an RP2040) into the schematic editor
    to work out their connections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider how to keep the cabling tidy, perhaps designing cable routing into
    drawings and CAD designs for a very tidy robot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use connectors that reduce vibration and connect only one way to reduce mistakes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are further ways to extend your robots toolbox:'
  prefs: []
  type: TYPE_NORMAL
- en: Oscilloscopes to view circuit waveforms, great for looking at PWM (see the section
    *An introduction to pulse width modulation speed control* in [*Chapter 5*](B18001_05.xhtml#_idTextAnchor098))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic analyzers to debug data buses and logic systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bench power supplies to test electronics without worrying about batteries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More advanced soldering stations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clamps to hold boards and components in place and test those connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stock of electronic components, such as diodes, resistors, capacitors, and
    wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some standard chips, such as op-amps and regulators, along with motor spares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another advanced electronic capability is to look at **Field-Programmable Gate
    Arrays** (**FPGAs**). These devices allow you to program digital circuitry into
    them, allowing fast I/O helpers beyond PIO and even small CPU cores. They are
    not cheap or easy to use, but they offer huge flexibility in interfacing and prototyping
    new chips.
  prefs: []
  type: TYPE_NORMAL
- en: We can look at advanced manufacturing techniques now that you’ve seen some advanced
    electronics techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Design and manufacturing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve used hand tools to build this robot. However, some techniques allow you
    to create far more intricate robot shapes. We touched on them in the *Chassis
    and form enhancements* section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The gateway to many of these is practicing using 3D CAD and learning about Blender
    to create more organic forms. It is worth experimenting with 3D CAD alternatives
    to FreeCAD, such as Solvespace or Fusion 360, and seeing which work for you. Finally,
    it is worth learning about the Inkscape program for 2D drawing or making decals
    to place on the 3D forms. During design, you should also be clear on how to assemble
    the parts when they arrive.
  prefs: []
  type: TYPE_NORMAL
- en: 'All fabrication methods require considering the limitations of the systems
    at design: for example, minimum cut widths, part thickness to avoid breaking,
    and how a cutting tool might access the different surfaces in a part.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a list of how you can manufacture parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Laser cutting** is a natural extension of how we’ve been cutting parts. The
    CAD output is precision shapes to be cut into a 2D sheet of material. Designs
    are assembled like flat-pack furniture or using stand-offs. You can make impressive
    designs with this fabrication system. The MeArm ([https://mearm.com/](https://mearm.com/))
    robot arm or OhBot robot head ([https://www.ohbot.co.uk/](https://www.ohbot.co.uk/))
    are made with laser cutting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CNC milling** lets you make cuts into material with a robotically controlled
    cutting part, and can cut wood, plastic, and metal. It can cut out parts with
    different depths forming complicated shapes, but mostly operate from above and
    cannot make cuts from the side or below.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3D printing** presents the possibility of fully 3D intricate parts, especially
    when they may be one-off parts for a single robot design. You can iterate with
    these, printing refinements to parts as you improve a design. Desktop 3D printers
    are inexpensive and can make sense in a home lab.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vacuum forming** is where a plastic sheet is pulled against a mold (or a
    buck) to create a shell. This technique allows for thin yet single-part plastic
    areas and may be perfect for robot shells (fairings). You can use the other techniques
    mentioned to make the buck.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metal techniques** such as welding, cutting, and using sheet metal may be
    useful for large robots or those that might be handled roughly. However, most
    small hobby robots will not need this. Some metal construction can be made simply
    by using aluminum extrusion, a hacksaw, and t-slot bolt heads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where can you get these manufactured? Many of these machines are large and expensive.
    If you do not have the space at home, you can consider sending designs to a company
    and have them cut them for you, such as [https://razorlab.online/](https://razorlab.online/).
    If you are part of a school, college, or university, it may have these devices
    in its labs. Otherwise, see the *Places to build robots* section later in this
    chapter for information about maker spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding techniques will let you make interesting and varied robot designs,
    improving on parts and exploring different shapes. Access to these techniques
    and people to help you learn about them becomes easier if you get involved in
    robotics communities.
  prefs: []
  type: TYPE_NORMAL
- en: Robotic competitions and communities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many robotics communities. This section does not aim to be exhaustive
    but to get you started with getting involved with them.
  prefs: []
  type: TYPE_NORMAL
- en: Social media
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This book has a Discord community at [https://discord.gg/2VHYY3FkXV](https://discord.gg/2VHYY3FkXV).
    You can use this to ask me questions and discuss your robotics with other robot
    builders.
  prefs: []
  type: TYPE_NORMAL
- en: Adafruit has a Discord community for discussing robotics, electronics, and CircuitPython
    – find out more at [https://blog.adafruit.com/2019/02/05/adafruit-community-server-on-discord-now-included-in-the-open-source-listings-discordapp-discord-opensource-circuitpython/](https://blog.adafruit.com/2019/02/05/adafruit-community-server-on-discord-now-included-in-the-open-source-listings-discordapp-discord-opensource-circuitpython/).
  prefs: []
  type: TYPE_NORMAL
- en: There is a lively robotics community on Twitter. I am on there as `@orionrobots`,
    and I regularly share and boost robotics tweets; I will answer robotics questions
    and introduce robot builders into the community.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the following communities have Twitter handles or tags, which are worth
    checking out. Twitter also has a `#MakersHour` tag for people talking about making
    anything, including robots.
  prefs: []
  type: TYPE_NORMAL
- en: I am also available on YouTube at [http://youtube.com/orionrobots](http://youtube.com/orionrobots),
    where you can see the robots I’ve been building, on Mastodon at [https://fosstodon.org/@orionrobots](mailto:https://fosstodon.org/@orionrobots),
    and on Facebook at [https://www.facebook.com/orionrobots](https://www.facebook.com/orionrobots).
  prefs: []
  type: TYPE_NORMAL
- en: The robot builder James Bruton showcases inspiring robot builds as `@XRobotsUk`
    at [https://twitter.com/XRobotsUK](https://twitter.com/XRobotsUK) and on YouTube
    at [https://bit.ly/3RYScxp](https://bit.ly/3RYScxp).
  prefs: []
  type: TYPE_NORMAL
- en: Another great robot builder with a community is Kevin McAleer at [https://www.youtube.com/c/kevinmcaleer28](https://www.youtube.com/c/kevinmcaleer28).
    In addition, he has a lively Facebook robot community at [https://www.facebook.com/groups/smallrobots](https://www.facebook.com/groups/smallrobots)
    for discussing exactly the kinds of robots we have built in this book and extending
    far past this.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PiWars event is a competition held in the UK for robot builders using Raspberry
    Pi to compete in autonomous and manually driven challenges, showing off and improving
    robot building, robot driving, and coding skills. The community is global, welcoming,
    and happy to share techniques. You can find its website at [https://piwars.org/](https://piwars.org/).
    PiWars also has a [https://twitter.com/piwarsrobotics](https://twitter.com/piwarsrobotics)
    account and a PiWars Discord server at [https://discord.gg/sjABKje](https://discord.gg/sjABKje).
  prefs: []
  type: TYPE_NORMAL
- en: The **UK Micromouse and Robotics Society** (**UKMARS**) community runs robotics
    competitions, with Micromouse being the oldest. Micromouse is a maze-running robot
    challenge running in the UK, with a lively community of robot builders. Visit
    [https://ukmars.org/](https://ukmars.org/) for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The **First Robotics Competition** (**FRC**) at [https://bit.ly/3BnWOWG](https://bit.ly/3BnWOWG)
    inspires people to build robotics and compete at robotics globally. The events
    occur in some local areas, with championships eventually taking place in Houston,
    Texas. The regional events mean that in-person competitions and collaboration
    can take place with teams long before traveling to Texas.
  prefs: []
  type: TYPE_NORMAL
- en: Maker faires are events held all over the world, and there may be some taking
    place in your country. Makers come to exhibit, talk about, and celebrate their
    creations. These are based around maker communities and provide great inspiration
    and contact between makers of all kinds, including robot builders. See [https://makerfaire.com/](https://makerfaire.com/)
    for details, including a search for maker faires near you.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you build these robots if you need more help, tools, or space than
    you can get home?
  prefs: []
  type: TYPE_NORMAL
- en: Places to build robots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tools and experience are important for building robots. While talking online
    can help, little is as useful as working with people experienced in the use of
    certain tools. Where can you find a space like the one in the following figure?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.11 – A maker space ](img/Figure_14.11_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.11 – A maker space
  prefs: []
  type: TYPE_NORMAL
- en: Maker spaces, hackspaces, or **Fabrication Laboratories** (**Fab Labs**) such
    as the one illustrated in *Figure 14**.11* are places where you can come and gain
    access to advanced tools such as 3D printers, laser cutters, and CNC machines,
    along with arrays of hand tools, electronics equipment, and large workbenches
    for them. They are usually accessible via membership and a small donation.
  prefs: []
  type: TYPE_NORMAL
- en: These spaces are usually well lit. Knowledgeable people maintain the tools and
    can also help you with your builds, with advice and training for the tools. An
    expert may also suggest a different manufacturing technique that may get you the
    results you want in a better way (quicker, cheaper, or stronger).
  prefs: []
  type: TYPE_NORMAL
- en: These spaces also tend to have safety systems, such as fume or dust removal,
    which is essential when soldering electronics or cutting materials such as wood.
    You will also find that these spaces usually have components or materials to hand
    that are needed to try a new technique. Using a small amount of material or borrowing
    a tool is essential if you want to try a technique before buying a lot of equipment.
    Searching for a Fab Lab, maker space, or hackerspace near you is strongly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Some coder dojos offer robotics programming as part of their courses. Coder
    dojos will focus more on the code and algorithms and less on building the robots.
    Schools that run code clubs or STEM clubs may also be amenable to robot programming
    and building.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen some communities, what further areas are there to explore
    in the code area?
  prefs: []
  type: TYPE_NORMAL
- en: Robotics systems and code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The software that runs on robots has a huge potential for exploration. With
    the ability to add additional controllers and memory or expand to larger and more
    powerful controllers, there are few limitations in this area.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen in [*Chapter 13*](B18001_13.xhtml#_idTextAnchor274), *Determining
    Position Using Monte Carlo Localization*, how a robot can use simulation to help
    the robot understand its world, so you may even consider expanding upon that in
    a virtual environment too. While that is appropriate for algorithms on the robot,
    extending this to full visualization and 3D would be reinventing the wheel. Simulation
    using systems such as the Godot game engine or the ROS Gazebo system will let
    you start to test robot algorithms away from the actual robot, letting you improve
    planning and SLAM techniques using sensor data. You can build 3D, physics-enabled
    worlds for a robot and test code there. There are considerations about being able
    to transfer code between the languages used in the simulations and CircuitPython
    that you’ll need to resolve. However, you may consider languages other than CircuitPython
    as you move to larger projects. You may be able to tune some things, but be aware
    that PID algorithm values will likely change when you attempt to try the same
    robot code in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Building on the idea of location mapping concepts are goal-based algorithms
    and task planning (mentioned in the *Extending the code and behaviors* section).
    These consist of planning how a robot can reach one location from another and
    what a robot may need to do if it has to move items to complete that operation.
    For example, the PiWars eco-disaster ([https://bit.ly/3xBPIwz](https://bit.ly/3xBPIwz))
    challenge required planning how to move barrels to a specific location without
    knocking over others. With random barrel locations, this is a good challenge to
    use to learn about these advanced robot algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve briefly mentioned machine learning before. There are a few different techniques,
    with variations on neural networks being the most popular type at the time of
    writing. Deep learning offers image and sound recognition results with TensorFlow
    on big controllers and TinyML on small ones such as Raspberry Pi Pico. These extend
    to image analysis, as well as image classification. Combining this with advanced
    computer vision techniques and navigating with a camera or two as the sensors
    become possible. However, LIDAR sensors are still a reliable source of distance
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting technique is clustered robots, a group of robots working
    as a single system. These would need to communicate with each other using RF,
    such as Wi-Fi, Bluetooth, or IR. You will need code that can plan how multiple
    robots will solve a problem. I recommend researching bird flocking and other artificial
    life subjects to build up to solving this, along with the planning techniques
    mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now seen algorithms to extend your learning about robotics further. Let’s
    recap what we have seen.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have gone back over what we have learned in *Raspberry Pi
    Pico Robotics for Workbench Wizards* and the robot we’ve built using these skills.
  prefs: []
  type: TYPE_NORMAL
- en: We then investigated how we could extend this robot, building additional features
    such as sensors, outputs, and a more interesting or robust chassis, and extending
    the code to do amazing things.
  prefs: []
  type: TYPE_NORMAL
- en: We branched out further, providing ideas and inspiration or areas of research
    for your next robot, things you could design and build with a clean slate.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we dove into advanced techniques in electronics, ways to manufacture
    far more intricate parts, the robot communities and spaces you could be part of,
    and where robotics programming can go. This last section should provide plenty
    of inspiration for continuing to build robots!
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following exercises will deepen your understanding of these topics and
    make the robot’s code better:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider an interesting improvement to the current robot, plan it, and get started.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join a robotics community and get involved with robots on Discord, Facebook,
    Twitter, or Mastodon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plan and build your next robot or robotics-related gadget. Then, share it with
    the communities!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your robotics journey is just starting now. I look forward to seeing you in
    the robotics community, along with the machines you create!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can continue your robot-building journey with the following books and reading
    areas:'
  prefs: []
  type: TYPE_NORMAL
- en: In *Learn Robotics Programming* by *Danny Staple*, *Packt Publishing*, I have
    written about building robots with Raspberry Pi, with another wheeled robot build,
    visual processing, and speech control covered, along with a different power system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Python Robotics Projects* by *Prof. Diwakar Vaish*, *Packt Publishing*, shows
    you how to build several small robots, explores the code in them, and has machine
    learning projects to try with them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
