<html><head></head><body>
		<div id="_idContainer022">
			<h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Importance of MSA and Machine Learning in Enterprise Systems</h1>
			<p>In today’s market, the competition has never been fiercer, and user requirements for IT systems are constantly increasing. To be able to keep<a id="_idIndexMarker000"/> up with customer requirements and market demands, the need for a shorter <strong class="bold">time-to-market</strong> (<strong class="bold">TTM</strong>) for IT systems has never been more important, all of which has pushed for agile deployment and the need to streamline the development process and leverage as much code reuse <span class="No-Break">as possible.</span></p>
			<p><strong class="bold">Microservices architecture</strong> (<strong class="bold">MSA</strong>) addresses these concerns and tries to deliver<a id="_idIndexMarker001"/> a more competitive, reliable, and rapid deployment and update delivery while maintaining an efficient, stable <span class="No-Break">system operation.</span></p>
			<p>In this chapter, we will learn more details about how microservices help build a modern, flexible, scalable, and resilient enterprise system. The chapter will go over key concepts in MSA and discuss the common enterprise system architectures, how each architecture is different from MSA, why they are different, and what you gain or lose when you adopt one or more architectures over <span class="No-Break">the others.</span></p>
			<p>We will cover the following areas as we go over <span class="No-Break">the chapter:</span></p>
			<ul>
				<li>What MSA is <span class="No-Break">and why</span></li>
				<li>MSA versus monolithic <span class="No-Break">enterprise systems</span></li>
				<li>Service-driven architecture, <strong class="bold">event-driven architecture</strong> (<strong class="bold">EDA</strong>), and how to incorporate that <span class="No-Break">in MSA</span></li>
				<li>Challenges of deploying and operating MSA <span class="No-Break">enterprise systems</span></li>
				<li>Why it is important to embrace <strong class="bold">DevOps</strong> in <span class="No-Break">building MSA</span></li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Why microservices? Pros and cons</h1>
			<p>Microservices<a id="_idIndexMarker002"/> is often likened to MSA. MSA refers to the way in which a complex system is built from a collection of smaller applications, where each application is designed for a specific limited-scope function. These small applications (or services, or microservices) are independently developed and can be <span class="No-Break">independently deployed.</span></p>
			<p>Each microservice has an API interface for communicating with other microservices in the system. The way all these individual microservices are organized together forms the larger <span class="No-Break">system function.</span></p>
			<p>In order to understand the value of microservices and the challenges one faces in designing an MSA, it is imperative to understand how microservices communicate and interact with <span class="No-Break">each other.</span></p>
			<p>Microservices can communicate together in a linear or non-linear fashion. In a linear microservices pipeline, each microservice communicates with another microservice, processing data across the system in a sequential manner. The input is always passed to the first microservice, and the output is always generated by the last microservice in <span class="No-Break">the system:</span></p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B18934_01_1.jpg" alt="Figure 1.1: Linear microservices pipeline"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1: Linear microservices pipeline</p>
			<p>Practically, however, most existing<a id="_idIndexMarker003"/> systems are formed using a non-linear microservices pipeline. In a non-linear microservices pipeline, data is distributed across different functions in the system. You can pass the input to any function in the system, and the output can be generated from any function in the system. You can therefore have multiple pipelines with multiple inputs, serving multiple functions and producing <span class="No-Break">multiple outputs:</span></p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B18934_01_2.jpg" alt="Figure 1.2: Non-linear microservices pipeline"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2: Non-linear microservices pipeline</p>
			<p>Consider the following diagram<a id="_idIndexMarker004"/> of a simplified order fulfillment process<a id="_idIndexMarker005"/> in a typical e-commerce system. Each function within the <strong class="bold">Placing an Order</strong> process represents a microservice. Once an order is placed by a customer, an API call is triggered to the <strong class="bold">Add/Update Customer Information</strong> microservice to save that customer’s information or update it if needed. This microservice sole responsibility is just that: manage customer information based on the data input it receives from the <span class="No-Break">API caller.</span></p>
			<p>Another API call is issued at the same time to the <strong class="bold">Verify Payment</strong> part of the process. The call will be directed to either the <strong class="bold">Process PayPal Payment</strong> or the <strong class="bold">Process Credit Card Payment</strong> microservice depending on the payment type of the API call. Notice here how the payment verification process is broken down into two different microservices—each is specifically designed and developed for a specific payment function. This enables the flexibility and portability of these microservices to other parts of the system or to another system <span class="No-Break">if needed.</span></p>
			<p>After payment is processed, API calls are triggered simultaneously to other microservices in the system to fulfill <span class="No-Break">the order:</span></p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B18934_01_3.jpg" alt="Figure 1.3: A non-linear microservices pipeline example – customer order"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3: A non-linear microservices pipeline example – customer order</p>
			<p>The order placement example<a id="_idIndexMarker006"/> shows how modular and flexible designing an MSA enterprise system can be. We will often use this example to show some of the advantages and challenges one may face when designing, deploying, and operating an MSA <span class="No-Break">enterprise system.</span></p>
			<p>It is essential that we go over some of the advantages and disadvantages of building enterprise systems using MSA to help decide whether MSA is a better option for your organization <span class="No-Break">or not.</span></p>
			<p>Note that some of the advantages listed next could also be considered disadvantages in other situations (and <span class="No-Break">vice versa).</span></p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Advantages of microservices</h2>
			<p>There is some significant <a id="_idIndexMarker007"/>value to implementing MSA. The following are some of the advantages we see applicable to <span class="No-Break">today’s market.</span></p>
			<h3>Autonomy</h3>
			<p>One of the biggest advantages of microservices is their autonomy—it is the keystone for many of the other advantages of MSA. And because of their autonomy, microservices have their own technology stack, which means that each system service can be developed with completely different tools, libraries, frameworks, or programming languages than any other system service, yet they integrate with each <span class="No-Break">other smoothly.</span></p>
			<p>Microservices can be developed and tested independently of any other application within the system, which enables each microservice to have its own life cycle, including <strong class="bold">quality assurance</strong> (<strong class="bold">QA</strong>), change management, upgrades, updates, and so on, which in return greatly minimizes <span class="No-Break">application dependencies.</span></p>
			<h3>Portability</h3>
			<p>Microservices’ autonomy<a id="_idIndexMarker008"/> enables them to be portable across platforms, operating systems, and different systems, all independent of the coding language in which these services <span class="No-Break">were written.</span></p>
			<h3>Reuse</h3>
			<p>When reusing microservices, you don’t need to reinvent the wheel. Because of their autonomy, microservices can be reused without the need to add additional coding, changes, or testing. Each service can be reused as needed, which largely increases system flexibility and scalability, significantly reduces the development time, cost, and deployment time, and reduces the <span class="No-Break">system’s TTM.</span></p>
			<h3>Loosely coupled, highly modular, flexible, and scalable</h3>
			<p>Microservices form the main building blocks of an MSA enterprise system. Each block is loosely coupled with the other blocks in the system. Just like Lego blocks, the manner in which these blocks are organized together can form a complex enterprise MSA system building a specific <span class="No-Break">business solution.</span></p>
			<p>The following diagram shows an example of how we can build three different systems with <span class="No-Break">multiple microservices.</span></p>
			<p>The diagram shows nine services, and seven out of these services are organized in such a manner to reuse and build three different systems—system <strong class="bold">A</strong>, system <strong class="bold">B</strong>, and system <strong class="bold">C</strong>. This shows how loose coupling enables flexibility in MSA in such a way that you can reuse each service to build a different <span class="No-Break">system function.</span></p>
			<p>You can build a system with minimal development added to existing microservices either acquired by a third party or previously developed in house. This largely enables rapid system development, new feature releases, very short TTM, and reliable, flexible, and much more stable hot updates<a id="_idIndexMarker009"/> and upgrades. All of this increases <strong class="bold">business continuity</strong> (<strong class="bold">BC</strong>) and makes the enterprise system much <span class="No-Break">more scalable:</span></p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B18934_01_4.jpg" alt="Figure 1.4: Flexibility and modularity in microservices"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4: Flexibility and modularity in microservices</p>
			<h3>Shorter release cycle and TTM</h3>
			<p>Because of the individual<a id="_idIndexMarker010"/> and independent services features we previously mentioned, the deployment of microservices becomes much easier and faster to perform. Automation can play a great role in reducing time-of-service testing and deployment, as we will discuss later in <span class="No-Break">this chapter.</span></p>
			<h3>Fault tolerance and fault isolation</h3>
			<p>Each microservice has its own separate fault domain. Failures in one microservice will be contained within that microservice, hence it is easier to troubleshoot and faster to fix and bring back the system to <span class="No-Break">full operations.</span></p>
			<p>Consider the order fulfillment example we mentioned earlier; the system can still be functional if the <strong class="bold">Message/Email Customer</strong> microservice—for example—experiences any failures. And because of the nature of the failure and the small fault domain, it will be easy<a id="_idIndexMarker011"/> to pinpoint where that failure is and how to fix it. <strong class="bold">Mean Time to Resolution</strong> (<strong class="bold">MTTR</strong>) is therefore significantly reduced, and BC is <span class="No-Break">greatly enhanced.</span></p>
			<p>Architects are sometimes<a id="_idIndexMarker012"/> able to build the system with high embedded tolerance to prevent these failures to begin with or have other backup microservices on standby to take over once a failure is detected in the primary microservice. One of the primary objectives of this book, as we will see later, is to be able to design a system with high enough intelligence to provide the desired <span class="No-Break">high resilience.</span></p>
			<p>What software architects have to bear in mind, however, is that, with too many system components in the MSA, too many things can go wrong. Architects and developers, therefore, have to have solid fallback and error handling to manage the <span class="No-Break">system’s resilience.</span></p>
			<p>The communication between the different microservices, for example, can simply time out for whatever reason; it could be a network issue, a server issue, or too many API calls at the receiving microservices or at the event-handling mechanism developed in the system, overwhelming this system component and causing failures or <span class="No-Break">delayed response.</span></p>
			<p>There are many data flow streams and data processing points in the system that all need to be synchronized. A single failure, if not taken care of properly by the system, can create system-cascading failures, and accordingly could cause a failure to the <span class="No-Break">entire system.</span></p>
			<p>How fault tolerance is designed will be a big factor in how system performance and reliability <span class="No-Break">are impacted.</span></p>
			<h3>Reliability and the Single Responsibility Principle (SRP)</h3>
			<p>If you come from the programming<a id="_idIndexMarker013"/> world, you are probably familiar with the SRP in <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>): <em class="italic">A class should have one, and only one, reason to change</em>. Every object, class, or function in the system should have a responsibility over only that functionality of the system, and hence that class, once developed, should only change for the reason it was originally created for. This principle is one of the main drivers of increased system reliability and BC <span class="No-Break">in MSA.</span></p>
			<p>At the initial phases of developing an MSA enterprise system, and during the phase of developing new microservices from scratch, the MSA enterprise system may not be fully tested or fully matured yet, and reliability may still be building up. When the system matures, changes to individual microservices are minimal—if any— and microservices’ code reliability is, therefore, higher, the operation is more stable, fault domains are contained, fault tolerance is high, and the system’s reliability thus becomes much higher than similar systems with a monolithic architecture. Reliability is highly contingent on how well the system is designed, developed, <span class="No-Break">and deployed.</span></p>
			<h3>Reducing system development and operational cost</h3>
			<p>Reusing microservices largely reduces the development efforts and time needed to bring the system to life. The more microservices you can reuse, the lower the development time and cost <span class="No-Break">will become.</span></p>
			<p>Microservices do not have to be developed from scratch; you can purchase already developed microservices that you may need to plug into your MSA enterprise system, cutting the development <span class="No-Break">time significantly.</span></p>
			<p>When these microservices are stable and mature, reliability is higher, MTTR is much shorter, and hence system faults are lower and BC is higher. All these factors can play a major role in reducing the development cost, operational cost, and <strong class="bold">total cost of </strong><span class="No-Break"><strong class="bold">ownership</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">TCO</strong></span><span class="No-Break">).</span></p>
			<p>Automation and operational<a id="_idIndexMarker014"/> orchestration are ideal for microservices; this enables agile development and can also decrease operational <span class="No-Break">costs significantly.</span></p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Disadvantages of microservices</h2>
			<p>Microservices <a id="_idIndexMarker015"/>come with a set of challenges that need to be taken into consideration before considering an MSA in your organization. The good news is that many of these challenges—if not all—can effectively be addressed to have in the end a robust MSA <span class="No-Break">enterprise system.</span></p>
			<p>Mentioned here are some of the challenges of microservices, and we will later in this chapter talk about some of the methodologies that help address <span class="No-Break">these challenges.</span></p>
			<h3>Complexity</h3>
			<p>MSA systems contain many components that must work together and communicate together to form the overall solution. The system’s microservices in most cases are built with different frameworks, programming languages, and <span class="No-Break">data structures.</span></p>
			<p>Communication between microservices<a id="_idIndexMarker016"/> has to be in perfect synchronization for the system to properly function. Interface calls could at times overwhelm the microservice itself or the system as a whole, and therefore, system architects and developers have to continuously look for mechanisms to efficiently handle interface calls and try to eliminate dependencies as much as <span class="No-Break">they can.</span></p>
			<p>Designing the system to handle call loads, data flows, and data synchronization, along with the operational aspects of it, could be a very daunting process and creates layers of complexity that are hard <span class="No-Break">to overlook.</span></p>
			<p>Complexity is one of the main trade-off factors in implementing and running an MSA <span class="No-Break">enterprise system.</span></p>
			<h3>Initial cost</h3>
			<p>MSA systems usually require a large number of resources to be able to handle the individual processing needs of each microservice, the high level of communication between microservices, and the different development and staging environments for developing <span class="No-Break">these microservices.</span></p>
			<p>If these microservices are being developed from scratch, the initial cost of building an MSA system would therefore be too high. You have to account for the cost of the many individual development environments, the many microservices to develop and test, and the different teams to do all these tasks and integrate all these components. All this adds to the cost of the initial <span class="No-Break">system development.</span></p>
			<h3>Tight API control</h3>
			<p>Each microservice has its own API calls to be able to integrate with other microservices in the system. Any change in the API command reference set—such as updates in any API call arguments, deprecated APIs, or changes in the return values—may require a change in how other microservices handle the data flow from and to that updated microservice. This can pose a <span class="No-Break">real challenge.</span></p>
			<p>Developers have to either maintain backward compatibility (which can be a big constraint at times) or change the API calls’ code of every other component in the system that interacts with the <span class="No-Break">updated microservice.</span></p>
			<p>System architects and developers have therefore to maintain very tight control over API changes in order to maintain <span class="No-Break">system stability.</span></p>
			<h3>Data structure control and consistency</h3>
			<p>The drawback of having independent applications<a id="_idIndexMarker017"/> within the enterprise system is that each microservice will have to maintain its own data structure, which creates a challenge in maintaining data consistency across <span class="No-Break">your system.</span></p>
			<p>If we take the earlier example of customer order fulfillment, the <strong class="bold">Add/Update Customer Information</strong> microservice should have its own database totally independent from any other database in the system. Similarly, the <strong class="bold">Update Item Inventory</strong> microservice should be the microservice responsible for the item information database, the <strong class="bold">Update Orders Database</strong> microservice should have the orders database, and <span class="No-Break">so on.</span></p>
			<p>The challenge now is that the shipping database will need to be in sync with the customer information database, and the orders database will have to contain some of the customer information. Also, the <strong class="bold">Message/Email Customer</strong> microservice has to have a way to access customer information (or receive customer information through API calls), and so on. In a larger system, the process of keeping data consistent across the different microservices becomes problematic. The more microservices we have, the more complex the data <span class="No-Break">synchronization becomes.</span></p>
			<p>Once again, designing and developing a system with all that work in mind becomes another burden on the system architects <span class="No-Break">and developers.</span></p>
			<h3>Performance</h3>
			<p>As we mentioned earlier, microservices have to communicate with each other to perform the entire system function. This communication, data flows, error handling, and fault-tolerance design—among many other factors—are susceptible to network latency, network congestions, network errors, application data processing time, database processing time, and data synchronization issues. All these factors greatly impact <span class="No-Break">system performance.</span></p>
			<p>Performance is another major trade-off factor in adopting and running an MSA <span class="No-Break">enterprise system.</span></p>
			<h3>Security</h3>
			<p>Because of microservices’ autonomy<a id="_idIndexMarker018"/> and their loose coupling, a high number of data exchanges between the different services is necessary for the MSA to function. This data flow, data storage within each microservice, data processing, the API call itself, and transaction logging all significantly increase the system attack surface and develop considerable <span class="No-Break">security concerns.</span></p>
			<h3>Organizational culture</h3>
			<p>Each microservice in the MSA has its own development cycle and therefore has its silo of architects, developers, testers, and the entire development and release cycle teams, all to maintain the main objective of microservices: <span class="No-Break">their autonomy.</span></p>
			<p>MSA enterprise systems are built from a large number of microservices and mechanisms to manage the interaction between the different system components. Developers have to therefore have system operational knowledge, and the operational teams need to have <span class="No-Break">development knowledge.</span></p>
			<p>Testing such complex distributed environments that one will have in the MSA system becomes a very daunting process that needs a different set <span class="No-Break">of expertise.</span></p>
			<p>The traditional organizational structure of one big development team solely focused on development, one QA team only doing basic testing, and so on is no longer sufficient for the way MSA is structured <span class="No-Break">and operated.</span></p>
			<p>Agile development and DevOps methodologies are very well suited for microservices development. You need agile processes to help maintain the fast development and release cycles MSA promises to deliver. You need DevOps teams who are very familiar with the end-to-end process of designing the application itself and how it fits in the big picture, testing the application, testing how it functions within the entire system, the release cycle, and how to monitor the application <span class="No-Break">post release.</span></p>
			<p>All this requires a cultural shift and significant organizational transformation that can enable DevOps and <span class="No-Break">agile development.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">We rarely see a failure in MSA adoption because of technical limitations; rather, failure in adopting MSA is almost always due to a failure to shift the organization’s culture toward a true DevOps and <span class="No-Break">agile culture.</span></p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>The benefits outweigh the detriments</h2>
			<p>The main questions<a id="_idIndexMarker019"/> you need to answer now are: Is building an MSA worth it? Can we make it happen given the current organizational culture? How long will it take the organization to transform and be ready for MSA? Do we have the luxury of waiting? Can we do both the organizational transformation and the building of the MSA enterprise system at the same time? Do we have the resources and the caliber necessary for the new organizational structure? Is cost an issue, and do I have the budget to <span class="No-Break">cover that?</span></p>
			<p>Well, first of all, if you are planning to build a large enterprise system, and you have the budget and necessary resources for starting this project, building the system as MSA is definitely worth it. All initial costs endured and time spent will eventually be offset by the long-term cost and time-saving benefits of having an <span class="No-Break">MSA system.</span></p>
			<p>Nevertheless, you are still the one to best address all these previous questions. There are overwhelming and compelling advantages to adopting MSA, but as we have seen, this is not a simple undertaking; so, whether an organization is willing to walk that path or not is something it—and only <span class="No-Break">it—can answer.</span></p>
			<p>Now we know what the advantages of deploying an MSA are, and the challenges that come with MSA adoption, we will now go over different enterprise architecture styles, what they are, and the differences between <span class="No-Break">each other.</span></p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Loosely versus tightly coupled monolithic systems</h1>
			<p>Traditional applications<a id="_idIndexMarker020"/> back in the day were mostly built<a id="_idIndexMarker021"/> using a monolithic architecture, in which the entire application was one big code base. All system components and functions were tightly coupled together to deliver the <span class="No-Break">business solution.</span></p>
			<p>As shown in the following diagram, system functions are all part of the same code, tightly coupled with centralized governance. Each system function has to be developed within the same framework of <span class="No-Break">the application.</span></p>
			<p>In an MSA system, however, each function preserves its own anonymity—that is, loosely coupled with decentralized<a id="_idIndexMarker022"/> governance, giving each team <a id="_idIndexMarker023"/>the ability to work with its own preferred technology stack, with whichever tools, framework, and programming language <span class="No-Break">it desires:</span></p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B18934_01_5.jpg" alt="Figure 1.5: Monolithic versus microservices systems"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5: Monolithic versus microservices systems</p>
			<p>All functions in the monolithic architecture<a id="_idIndexMarker024"/> application are wrapped into the application itself. In the MSA, these functions are developed, packaged, and deployed separately. Therefore, we can run these services in multiple locations’ on-premises infrastructure, in the public cloud, or across both on-premises and the cloud in a <span class="No-Break">hybrid-cloud fashion.</span></p>
			<p>In monolithic systems, and because of the tight coupling, synchronizing the different system function changes is a development and operational nightmare. If one application (for whatever reason) becomes unstable, it could cause a failure to the entire system, and bringing the system back to a stable point becomes a <span class="No-Break">real pain.</span></p>
			<p>In the case of microservices, however, since each of these microservices is loosely coupled, changes and troubleshooting are limited to that particular microservice, as long as the microservice interface does <span class="No-Break">not change.</span></p>
			<p>One large piece of code, in the case of monolithic<a id="_idIndexMarker025"/> architecture, is very hard<a id="_idIndexMarker026"/> to manage and maintain. It is also hard to understand, especially in large organizations where multiple developers are <span class="No-Break">working together.</span></p>
			<p>In many cases such as employee turnover, for example, a developer may need to troubleshoot someone else’s code, and when the application is written in a single big piece of code, things tend to be complicated, hard to trace and understand, and hard to reverse engineer and fix. Code maintenance becomes a serious problem, while in the microservices case, this humongous line of code is broken into smaller chunks of code that are easier to read, understand, troubleshoot, and fix, totally independent of the other components of <span class="No-Break">the system.</span></p>
			<p>When code changes are needed in monolithic architecture, a single change to part of the code may need changes to many other parts of the application, and accordingly, change updates will likely require a rewrite and a recompile of the <span class="No-Break">entire application.</span></p>
			<p>We can also reuse and package different applications together in a workflow to form a specific service, as shown previously in <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">.</span></p>
			<p>It is just common sense to break down a complex application into multiple modules or microservices, each performing a specific function in the entire ecosystem for better scalability, higher portability, and more efficient development <span class="No-Break">and operations.</span></p>
			<p>For small, simple, and short-lived systems, monolithic applications may be a better fit for your organization, easier to design and deploy, cheaper to develop, and faster to release. As the business needs grow, MSA becomes a better <span class="No-Break">long-term approach.</span></p>
			<p>Since monolithic systems are tightly coupled, there is no need for API communication between the different system functions; this significantly decreases the security surface of your system, lowering system security risks and increasing the system’s <span class="No-Break">overall performance.</span></p>
			<p>Think of the deployment difference between both monolithic and MSA as the difference between an economy car<a id="_idIndexMarker027"/> and a Boeing 787. The car is a better, cheaper, and faster tool for traveling<a id="_idIndexMarker028"/> between two cities 50 miles apart, with no need for the security checks you experience in airports before boarding your flight. As the distance increases, however, driving the car becomes more hassle. At 5,000 miles, the Boeing 787 is likely to become a better, cheaper, and faster way to get to your destination, and you will likely be willing to put up with the hassle of security checks you have to undergo to be able to board <span class="No-Break">your flight.</span></p>
			<p>The following is a comparison summary<a id="_idIndexMarker029"/> between both monolithic and <span class="No-Break">microservices applications:</span></p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body"/>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Monolithic</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">MSA</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Architecture</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Highly autonomous. System functions are split into independent loosely coupled chunks of <span class="No-Break">smaller code.</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>No autonomy. System functions are all tightly coupled into one big piece <span class="No-Break">of code.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Portability</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Highly portable</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Very <span class="No-Break">limited portability</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Reuse</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Highly reusable</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Very limited ability to <span class="No-Break">reuse code</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p>Modularity <span class="No-Break">and Scalability</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Highly modular <span class="No-Break">and scalable</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Limited modularity and hard <span class="No-Break">to scale</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Initial TTM</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Highly dependent on the readiness of individual system services. The more code reuses, the shorter the <span class="No-Break">TTM is.</span></p>
							<p>If the system microservices are being designed and developed from scratch, TTM is usually longer for <span class="No-Break">monolithic architecture.</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Long TTM, especially in large systems. Shorter TTM in small and <span class="No-Break">simple systems.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Release Cycle</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Very short release cycle, super-fast to deploy changes and <span class="No-Break">patch updates</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Long and usually very time-consuming release cycles and <span class="No-Break">patch updates</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Initial Cost</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Usually high. Depends on the <span class="No-Break">system size.</span></p>
							<p>The initial cost is offset by operational <span class="No-Break">cost savings.</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Usually low. The initial size becomes higher in large <span class="No-Break">enterprise systems.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Operational Cost</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Low. Easier to maintain <span class="No-Break">and operate.</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>High. Hard to maintain <span class="No-Break">and operate.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Complexity</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">High</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Low</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">API Control</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">High</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Low</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p>Data <span class="No-Break">Structure Consistency</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Decentralized databases, hence data consistency is harder <span class="No-Break">to maintain</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>A centralized database, hence easier to maintain data consistency across <span class="No-Break">the system</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Performance</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Usually lower</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Usually higher</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Security</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Many <span class="No-Break">security concerns</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Lower <span class="No-Break">security concerns</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Organizational Adoption</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Hard to adopt depending on the organizational structure. Requires adoption of agile development and DevOps. Organizational transformation may be required and may take a long time <span class="No-Break">to achieve.</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Easy to adopt. Minimal organizational transformation <span class="No-Break">needed—if any.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Fault Tolerance</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Usually higher</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Usually lower</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.1: Summary of the differences between monolithic and MSA systems</p>
			<p>We covered in this section<a id="_idIndexMarker030"/> the different aspects of a monolithic system; next, we go over service-driven architecture and EDA, and how to combine these architectural styles within MSA to address some of the MSA challenges <span class="No-Break">discussed earlier.</span></p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Service-driven, EDA, and MSA hybrid model architecture</h1>
			<p>People often<a id="_idIndexMarker031"/> get mixed up between MSA and <strong class="bold">service-driven architecture</strong> (aka <strong class="bold">service-oriented architecture</strong> or <strong class="bold">SOA</strong>). Both types of architecture<a id="_idIndexMarker032"/> try to break down the monolithic architecture<a id="_idIndexMarker033"/> system into smaller services. However, in MSA, the system<a id="_idIndexMarker034"/> services decomposition is extremely granular, breaking down the system into very fine specialized independent services. In the SOA, the system services decomposition is instead coarse-grained to the <span class="No-Break">domain level.</span></p>
			<p>All domains, as shown in the following diagram, share the same centralized database and may actually share other resources in between, creating some level of coupling and system dependencies that are non-existent in MSA. Data storage is a key difference between both <span class="No-Break">architectural styles:</span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B18934_01_6.jpg" alt="Figure 1.6: SOA architecture split into functional domains"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6: SOA architecture split into functional domains</p>
			<p>In the case of the simplified MSA customer ordering example discussed earlier, there are eight different microservices. A similar implementation in SOA is likely to have all these microservices built together and tightly coupled in a single domain. Other domains within the system could be Cart Handling, Catalog Browsing and Suggestions, and <span class="No-Break">so on.</span></p>
			<p>SOA has a holistic enterprise view, while in a microservice, development looks into the function itself in total isolation of the enterprise system in which the microservice is intended to <span class="No-Break">be used.</span></p>
			<p>EDA is another architectural style that is largely adopted. While MSA’s main focus is on function and SOA emphasizes the domain, EDA instead focuses on <span class="No-Break">system events.</span></p>
			<p>EDA is usually complemented by another main system architecture, such as SOA or MSA. In EDA, services are decoupled at a granularity level determined by its main architecture (MSA or SOA) and then communicate with each other through event-based transactions. In our order placement example, these events could be <strong class="bold">Order Created</strong>, <strong class="bold">Order Canceled</strong>, <strong class="bold">Order Shipped</strong>, and <span class="No-Break">so on.</span></p>
			<p>In order to maintain event synchronization and data consistency across the enterprise system, these events must be handled by a message broker. The message broker’s sole responsibility is to guarantee the delivery of these events to different services across the system. Therefore, it has to be highly available, highly responsive, fault-tolerant, and scalable and must be able to function under <span class="No-Break">heavy load.</span></p>
			<p>When EDA is adopted within the MSA enterprise system, the message broker in that case will be handling events, API calls, and API <span class="No-Break">calls’ responses.</span></p>
			<p>The message broker<a id="_idIndexMarker035"/> has to be able to queue messages when a specific service<a id="_idIndexMarker036"/> is down or under heavy load and deliver that message whenever that service <span class="No-Break">becomes available.</span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>ACID transactions</h2>
			<p>Any system with some form<a id="_idIndexMarker037"/> of data storage always needs to ensure the integrity, reliability, and consistency of that data. In MSA, systems store and consume data across the workflow transactions, and for individual services to ensure integrity and reliability for the MSA system as a whole, data stored within the entire system have to comply with a certain set of principles called <strong class="bold">Atomicity, Consistency, Isolation, and </strong><span class="No-Break"><strong class="bold">Durability</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">ACID</strong></span><span class="No-Break">):</span></p>
			<ul>
				<li><strong class="bold">Atomicity</strong>: All-or-nothing transactions. Either all transactions in the workflow are successfully executed and committed or they all fail and <span class="No-Break">are canceled.</span></li>
				<li><strong class="bold">Consistency</strong>: Any data change in one service has to maintain its integrity across the system or <span class="No-Break">be canceled.</span></li>
				<li><strong class="bold">Isolation</strong>: Each data transaction has its own sovereignty and should not impact or be impacted by other transactions in <span class="No-Break">the system.</span></li>
				<li><strong class="bold">Durability</strong>: Committed transactions<a id="_idIndexMarker038"/> are forever permanent, even in the case of a <span class="No-Break">system failure.</span></li>
			</ul>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Saga patterns</h2>
			<p>One of the main challenges<a id="_idIndexMarker039"/> in MSA is distributed transactions, where data flow spans across multiple microservices in the system. This flow of data across the services creates a risk of violating the microservice autonomy. Data has to be managed within the microservice itself in total isolation from any other service in <span class="No-Break">the system</span><span class="No-Break">.</span></p>
			<p>If you look at our order placement example again, you find that customer data (or part of it) spans across the different microservices in the example, which could create undesired dependencies in the MSA, and should be avoided at <span class="No-Break">all costs.</span></p>
			<p>What if, for whatever reason, the <strong class="bold">Update Item Inventory</strong> service fails, or it just happens that the service reports back that the item is no longer available? The system in that case will need to roll back and update all individual services’ databases to ensure ACID transactions for <span class="No-Break">the workflow.</span></p>
			<p>The <strong class="bold">saga pattern</strong> manages the entire workflow of transactions. It sees all sets of transactions performed in a specific process as a workflow and ensures that all these transactions in that workflow are either successfully executed and committed or rolled back in case the workflow breaks for whatever reason, to maintain data consistency across <span class="No-Break">the system.</span></p>
			<p>A saga participant service would have a <strong class="bold">local transaction</strong> part of that workflow. A local transaction is a transaction<a id="_idIndexMarker040"/> performed within the service itself and produces an event upon execution to trigger the next local transaction in the workflow. These transactions must comply with ACID principles. If one<a id="_idIndexMarker041"/> of these local transactions fails, the saga service initiates a set of <strong class="bold">compensating transactions</strong> to roll back any changes caused by the already executed local transactions in <span class="No-Break">the workflow.</span></p>
			<p>Each local transaction should have corresponding compensating transactions to be executed to roll back actions caused by the local transaction, as shown in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B18934_01_7.jpg" alt="Figure 1.7: Processing of local and compensating transactions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7: Processing of local and compensating transactions</p>
			<p>There are two ways<a id="_idIndexMarker042"/> to coordinate<a id="_idIndexMarker043"/> transactions’ workflow in a saga service: <strong class="bold">choreography</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">orchestration</strong></span><span class="No-Break">.</span></p>
			<p>In choreography, saga participant<a id="_idIndexMarker044"/> services exchange events without the need for a centralized manager. As in EDA, a message broker is needed to handle event exchanges between services, as illustrated in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B18934_01_8.jpg" alt="Figure 1.8: Choreography in a saga service"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8: Choreography in a saga service</p>
			<p>In orchestration, a saga<a id="_idIndexMarker045"/> pattern-centralized controller is introduced: an <strong class="bold">orchestrator</strong>. The workflow is configured in the orchestrator<a id="_idIndexMarker046"/> and the orchestrator sends requests to each saga participant service on which local transaction it needs to execute, receives events from saga participant services, checks the status of each request, and handles any local transaction failures by executing the necessary compensating transactions, as illustrated in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B18934_01_9.jpg" alt="Figure 1.9: Orchestration in a saga service"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9: Orchestration in a saga service</p>
			<p>Orchestrators become the brain of the enterprise system and the single source for all steps that need to be taken<a id="_idIndexMarker047"/> to execute a specific system workflow. The orchestrator, therefore, must be implemented in a way to be highly resilient and <span class="No-Break">highly available.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Command Query Responsibility Segregation (CQRS)</h2>
			<p>It is very common in traditional<a id="_idIndexMarker048"/> systems, and especially in monolithic applications, to have a common relational database deployed in the backend<a id="_idIndexMarker049"/> and accessed by a frontend application. That centralized database is accessed with <strong class="bold">Create-Read-Update-Delete</strong> (<span class="No-Break"><strong class="bold">CRUD</strong></span><span class="No-Break">) operations.</span></p>
			<p>In modern architecture, especially as the application scales, this traditional implementation poses a problem. With multiple CRUD requests being processed on the database, table joins are created with a high likelihood of database locking happening. Table locks introduce latency and resource competition, and greatly impact overall <span class="No-Break">system performance.</span></p>
			<p>Complex queries have a large number of table joins and can lock the tables, preventing any write or update operations on them till the query is done and the database unlocks the tables. Database<a id="_idIndexMarker050"/> read operations are typically multiple times more than write operations, and in heavy transaction systems, the problem <span class="No-Break">can multiply.</span></p>
			<p>You can see a comparison<a id="_idIndexMarker051"/> of CRUD and CQRS <span class="No-Break">patterns here:</span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B18934_01_10.jpg" alt=""/>
				</div>
			</div>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B18934_01_10b.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10: CRUD versus CQRS patterns</p>
			<p>With CQRS, you simply separate one object into two objects. So, rather than doing both commands and queries on one object, we separate that object into two objects—one for the command, and one for the query. A command is an operation that changes the state of the object, while a query does not change the state of the system but instead returns <span class="No-Break">a result.</span></p>
			<p>In our case, the object here is the system database, and that database separation could be either physical or logical. Although it is a best practice to have two physical databases for CQRS, you can still use the same physical database for both commands and queries. You can, for example, split the database into two logical views—one for commands and one <span class="No-Break">for queries.</span></p>
			<p>A replica is created from the master database when two physical databases are used in CQRS. The replica will, of course, need to be synchronized with the master for data consistency. The synchronization can be accomplished by implementing EDA where a message broker is handling all system events. The replica subscribes to the message broker, and whenever the master database publishes an event to the message broker, the replica database will synchronize that <span class="No-Break">specific change.</span></p>
			<p>There will be a delay between the exact time at which the master database was actually changed and when that change is reflected in the replica; the two databases are not 100% consistent during that period<a id="_idIndexMarker052"/> of time but will be eventually consistent. In CQRS, this synchronization is called eventual <span class="No-Break">consistency synchronization.</span></p>
			<p>When applying CQRS design in MSA, database processing latency is greatly reduced, and hence communication between individual services’ performance is greatly enhanced, resulting in an overall <span class="No-Break">system-enhanced performance.</span></p>
			<p>The database used can be of any type, depending on the business case of that particular service in the MSA. It may very well be a <strong class="bold">relational database</strong> (<strong class="bold">RDB</strong>), document database, graph database, and so on. A NoSQL database could also be an <span class="No-Break">excellent choice.</span></p>
			<p>We discussed previously the MSA<a id="_idIndexMarker053"/> from a design and architecture perspective. Operating the MSA system is another aspect that the entire organization must consider for a successful business delivery process. In the next section, we discuss DevOps, how it fits into the MSA life cycle, and why it is important for a successful MSA adoption <span class="No-Break">and operation.</span></p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>DevOps in MSA</h1>
			<p>DevOps revolves<a id="_idIndexMarker054"/> around a set of operational guidelines<a id="_idIndexMarker055"/> in the software development and release cycles. The traditional development engineer is no longer living in their confined environment where all the focus is to convert functional specifications into code; rather, they should have an end-to-end awareness of <span class="No-Break">the application.</span></p>
			<p>A DevOps engineer would oversee, understand, and be involved in the entire pipeline from the moment the entire application is planned out, converting business functions into code, building the application, testing it, releasing it, monitoring its operations, and coming back with the feedback necessary for enhancements <span class="No-Break">and updates.</span></p>
			<p>That does not necessarily mean that a DevOps engineer would be responsible for all development and operational task details. Individual responsibilities within the application team<a id="_idIndexMarker056"/> may vary in a way to guarantee a smooth <strong class="bold">continuous integration and continuous deployment</strong> (<strong class="bold">CI/CD</strong>) pipeline of <span class="No-Break">the application:</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B18934_01_11.jpg" alt="Figure 1.11: DevOps CI/CD pipeline"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11: DevOps CI/CD pipeline</p>
			<p>One of the main objectives of DevOps is to speed up the CI/CD pipeline; that’s why there is a lot of emphasis on automation in DevOps. Automation is essential to efficiently perform <span class="No-Break">the pipeline.</span></p>
			<p>Automation<a id="_idIndexMarker057"/> can help at every step of the way. In DevOps, many test<a id="_idIndexMarker058"/> cases that are part of your QA plan are automated, which significantly speeds up the QA process. The release management and monitoring of your application are also automated to provide high visibility, continuous learning, and quick fixes whenever needed. All of this will help organizations improve productivity, predictability, <span class="No-Break">and scalability.</span></p>
			<p>DevOps is a holistic view of how the application is developed and managed. It is not a function for only the development team or operational team to adopt; rather, the entire organization should adopt it. It is therefore imperative for the organizational structure and the organization’s vision and goal to all align with the set of procedural and functional changes necessary to shift from the traditional way of <span class="No-Break">developing software.</span></p>
			<p>Just to give you a gist of how traditional and DevOps models differ in terms of application development and release cycles, take a look at the following <span class="No-Break">comparison table:</span></p>
			<table id="table002" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body"/>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Traditional</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">DevOps</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Planning</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Months</span></p>
							<p>Long time to plan due to the large application size and tight coupling between different <span class="No-Break">application components</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Days <span class="No-Break">to weeks</span></p>
							<p>Very short planning time since the application is broken down into small individual loosely <span class="No-Break">coupled services</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Development</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Months</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Days to weeks, and even shorter in the case of patches <span class="No-Break">and fixes</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Testing</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Weeks <span class="No-Break">to months</span></p>
							<p>Mostly manually intensive QA use case testing, which may sometimes jeopardize the reliability of the <span class="No-Break">test’s outcome</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Days</span></p>
							<p>Mostly automated QA use case execution that brings high reliability to <span class="No-Break">the application</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Release, Deploy</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Days</span></p>
							<p>Usually long manual work and more susceptible to <span class="No-Break">human errors</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Hours</span></p>
							<p><span class="No-Break">Mostly automated</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Operate, Monitor</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Metrics reporting is mostly manually pulled <span class="No-Break">and analyzed</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Metrics are monitored and analyzed automatically and can even fix the problem in seconds. Moreover, <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>) tools can be used to enhance operations <span class="No-Break">even further.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.2: Traditional operational style versus DevOps</p>
			<p>In traditional development <a id="_idIndexMarker059"/>environments, you have a big piece of code<a id="_idIndexMarker060"/> to write, maintain, and change when needed. Because of the code size, it is only normal to have a long release cycle, and it can only be feasible to deploy patches or new releases when only major changes or high-severity fixes are needed, as illustrated in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B18934_01_12.jpg" alt="Figure 1.12: Traditional development environment versus MSA DevOps"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12: Traditional development environment versus MSA DevOps</p>
			<p>In MSA, teams are separated based on applications that do not function. That big chunk of code is split into a collection of much smaller code (microservices), and since teams are split to work independently for each team to focus on a specialized microservice, the development and release cycles are <span class="No-Break">much shorter.</span></p>
			<p>Similarly, in DevOps, the application<a id="_idIndexMarker061"/> is broken down into smaller pieces to enable the CI/CD<a id="_idIndexMarker062"/> pipeline, which makes DevOps the perfect model that <span class="No-Break">fits MSA.</span></p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Why ML?</h2>
			<p>Using ML tools and algorithms<a id="_idIndexMarker063"/> in your MSA enterprise system can further enhance and accelerate your DevOps CI/CD pipeline. With ML, you can find patterns in your tests, monitor phases of your pipeline, automatically analyze where the faults may be, and suggest a resolution or automatically fix operational issues <span class="No-Break">whenever possible.</span></p>
			<p>ML can greatly shorten your MSA enterprise system’s TTM and make it more intelligent, self-healing, resilient, <span class="No-Break">and supportable.</span></p>
			<p>We will in this book discuss two aspects of ML: first, we’ll explain in detail how to add CI/CD pipeline<a id="_idIndexMarker064"/> intelligence to your MSA enterprise system, and second, we’ll look at how to build an ML enterprise system with MSA <span class="No-Break">in mind:</span></p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B18934_01_13.jpg" alt="Figure 1.13: Using ML in CI/CD pipeline"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13: Using ML in CI/CD pipeline</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Summary</h1>
			<p>In this chapter, we covered the concepts of MSA and how MSA is different from traditional monolithic architecture. By now, you should also have a clear understanding of the advantages of MSA and the challenges organizations may experience when <span class="No-Break">adopting MSA.</span></p>
			<p>We also covered the key concept of methodologies to consider when designing MSA, such as ACID, the saga pattern, and CQRS. All these concepts are essential to help overcome synchronization challenges and to maintain <span class="No-Break">microservices anonymity.</span></p>
			<p>We now understand the basics of DevOps and why it is important in MSA design, deployment, and operations, as well as how ML integration in MSA enterprise systems can help enhance <span class="No-Break">system operations.</span></p>
			<p>In the next chapter, we will go over common methodologies that organizations pursue to transition from running traditional monolithic systems to MSA systems. We will discuss how to break down the existing system into services that form the new MSA <span class="No-Break">enterprise system.</span></p>
		</div>
</body></html>