<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Adding Specialized Searches"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Adding Specialized Searches</h1></div></div></div><p>The previous chapter explored the relationship between academic papers and journals, and we learned how to search for academic papers. This chapter moves on to the last of the top-level APIs, Search. In this chapter, we will learn how to search for web content. We will see how we can search for the latest news with certain keywords or categories. Further on, we will search for images and videos, and learn how to automatically suggest search queries for the end user. By the end of this chapter, we will be introduced to Bing Visual Search and find out how to create customized search experiences by using Bing Custom Search.</p><p>In this chapter, we will learn about the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to search for web pages and documents</li><li class="listitem" style="list-style-type: disc">How to search for news articles</li><li class="listitem" style="list-style-type: disc">How to search for images and videos</li><li class="listitem" style="list-style-type: disc">How to add autosuggestions in applications</li><li class="listitem" style="list-style-type: disc">How to filter search results based on safe search policies</li></ul></div><div class="section" title="Searching the web using the smart-house application"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec59"/>Searching the web using the smart-house application</h1></div></div></div><p>The Bing Web Search API provides us <a class="indexterm" id="id474"/>with a search experience similar to what we find at <a class="ulink" href="http://bing.com/search">http://bing.com/search</a>. It returns results that are <a class="indexterm" id="id475"/>relevant to any queries.</p><p>A response for any request to this API will contain web pages, images, videos, and news articles. In a typical scenario, this is the API you would use for any of these searches.</p><p>Note that, in a real-life scenario, all requests should be made from a server-side application, not from a client, as we do in this example.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>If you have not already done so, sign up for the Bing Web Search API at <a class="ulink" href="https://portal.azure.com">https://portal.azure.com</a>. You can read more on the API at <a class="ulink" href="https://azure.microsoft.com/en-us/services/cognitive-services/bing-web-search-api/">https://azure.microsoft.com/en-us/services/cognitive-services/bing-web-search-api/</a>.</p></div></div><div class="section" title="Preparing the application for web searches"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec65"/>Preparing the application for web searches</h2></div></div></div><p>Before diving <a class="indexterm" id="id476"/>into the required technicalities for web searches, we are going to prepare our smart-house application.</p><p>Add a new View <a class="indexterm" id="id477"/>in the <code class="literal">Views</code> folder called <code class="literal">BingSearchView.xaml</code>. At the very least, this should contain two <code class="literal">Combobox</code> elements, one for the search type and one for the search filter. We need one <code class="literal">TextBox</code> element for our search query, as well as one <code class="literal">Button</code> element to execute the search. Finally, we need a <code class="literal">TextBox</code> element to display the search result.</p><p>To accompany the search types and search filter, we need to add a new file, called <code class="literal">BingSearchTypes.cs</code>, in the <code class="literal">Model</code> folder. Add the following two <code class="literal">enums</code>:</p><div class="informalexample"><pre class="programlisting">    public enum BingSearchType {
        Web, News, NewsCategory
    }

    public enum SafeSearch {
        Strict, Moderate, Off
    }</pre></div><p>Adding this allows us to use both the Bing Web Search and Bing News Search APIs. The latter will be discussed later. The second <code class="literal">enum</code>, <code class="literal">SafeSearch</code>, will also be discussed in more detail later.</p><p>We need a new ViewModel. Add a new file called <code class="literal">BingSearchViewModel.cs</code>, to the <code class="literal">ViewModels</code> folder. In this, we need to add two <code class="literal">string</code> properties for our search query and the search results. We will also need one property of type <code class="literal">BingSearchType</code> to represent the selected search type. Also needed is a property of type <code class="literal">SafeSearch</code> to represent the selected safe-search filter. An <code class="literal">ICommand</code> property is needed for our button.</p><p>In addition, we need to be able to display the values from the previously created <code class="literal">SafeSearch enums</code>. This can be achieved by adding the following properties:</p><div class="informalexample"><pre class="programlisting">public IEnumerable&lt;BingSearchType&gt; AvailableSearchTypes  { 
    get { 
        return Enum.GetValues (typeof(BingSearchType)).Cast&lt;BingSearchType&gt;(); 
    } 
}

public IEnumerable&lt;SafeSearch&gt; SafeSearchFilter {
    get { 
        return Enum.GetValues(typeof(SafeSearch)).Cast&lt;SafeSearch&gt;(); 
    } 
}</pre></div><p>We get all the values from each <code class="literal">enum</code>, and return them as an <code class="literal">IEnumerable</code>.</p><p>At the time of <a class="indexterm" id="id478"/>writing, none of the search APIs have any NuGet client packages, so we need to make the web requests ourselves. Copy the <code class="literal">WebRequest.cs</code> file we used in earlier chapters <a class="indexterm" id="id479"/>into the <code class="literal">Model</code> folder. Rename the file <code class="literal">BingWebRequest.cs</code> and the class <code class="literal">BingWebRequest</code>.</p><p>As all API calls are <code class="literal">GET</code> requests, we can simplify this class a bit. Remove the URL parameter from the constructor, and remove the <code class="literal">_endpoint</code> member completely. Doing so allows us to simplify the <code class="literal">MakeRequest</code> function, as follows:</p><div class="informalexample"><pre class="programlisting">public async Task&lt;TResponse&gt; MakeRequest&lt;TResponse&gt;(string url) {
    try {
        var request = new HttpRequestMessage(HttpMethod.Get, url);
                
        HttpResponseMessage response = await _httpClient.SendAsync(request);

        if (response.IsSuccessStatusCode) {
            string responseContent = null;

            if (response.Content != null)
                responseContent = await response.Content.ReadAsStringAsync();
                    
            if (!string.IsNullOrWhiteSpace(responseContent))
                return JsonConvert.DeserializeObject&lt;TResponse&gt; (responseContent, _settings);

            return default(TResponse);
        }</pre></div><p>We do not need a request body, and have removed the <code class="literal">TRequest</code> and corresponding code. We have also hardcoded the HTTP method, and said that we will specify the complete URL endpoint when calling the function. The rest of the function should stay the same.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>Remember to add references to <code class="literal">System.Web</code> and <code class="literal">System.Runtime.Serialization</code>.</p></div></div><p>With that in place, we can move on. Make sure that the code compiles and executes before continuing.</p></div><div class="section" title="Searching the web"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec66"/>Searching the web</h2></div></div></div><p>To be able to use Bing Web <a class="indexterm" id="id480"/>Search, we need to create a new class. Add a new file called <code class="literal">BingSearch.cs</code>, to the <code class="literal">Model</code> folder.</p><p>We need to add a member of type <code class="literal">BingWebRequest</code>, which we will create in the constructor:</p><div class="informalexample"><pre class="programlisting">    private BingWebRequest _webRequest;

    public BingSearch() {
        _webRequest = new BingWebRequest("API_KEY_HERE");
    }</pre></div><p>Create a new function called <code class="literal">SearchWeb</code>. This should accept two parameters, a string for the search query and a <code class="literal">SafeSearch</code> parameter. The function should be marked as <code class="literal">async</code> and return a <code class="literal">Task&lt;WebSearchResponse&gt;</code>. <code class="literal">WebSearchResponse</code> is a data contract we will learn more about presently:</p><div class="informalexample"><pre class="programlisting">public async Task&lt;WebSearchResponse&gt; SearchWeb(string query, SafeSearch safeSearch)
{
    string endpoint = string.Format("{0}{1}&amp;safeSearch={2} &amp;count=5&amp;mkt=en-US","https://api.cognitive.microsoft.com/bing/v7.0/search?q=", query, safeSearch.ToString());</pre></div><p>First, we construct our endpoint, which points us to the web search service. We make sure that we specify the query, <code class="literal">q</code>, the <code class="literal">safeSearch</code> selection, and the market, <code class="literal">mkt</code>. The latter two will be discussed presently in this chapter.</p><p>The only required parameter is the query string. This should not exceed a length of 1,500 characters. Other optional parameters are described in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Parameter</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">responseFilter</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A<span class="strong"><strong> comma-delimited</strong></span> list of the result types to include in the response. If not specified, results will contain all types. Legal values include <code class="literal">Computation</code>, <code class="literal">Images</code>, <code class="literal">News</code>, <code class="literal">RelatedSearches</code>, <code class="literal">SpellSuggestions</code>, <code class="literal">TimeZone</code>, <code class="literal">Videos</code>, and <code class="literal">WebPages</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">setLang</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A two-letter language code to specify the language for user interface strings.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">textDecorations</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Specifies whether or not the query term is highlighted in the results. Defaults to false.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">textFormat</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The type of formatting to apply to display strings. Can be either raw or HTML, with raw being the default.</p>
</td></tr></tbody></table></div><p>There are a few more parameters apart from these ones. They are, however, common to all searches and will be discussed at the end of this chapter.</p><p>With the endpoint in place, we can move on:</p><div class="informalexample"><pre class="programlisting">    try {
        WebSearchResponse response = await _webRequest.MakeRequest&lt;WebSearchResponse&gt;(endpoint);

        return response;
    }
    catch (Exception ex) {
        Debug.WriteLine(ex.Message);
    }
return null;</pre></div><p>With the newly constructed <a class="indexterm" id="id481"/>endpoint, we call <code class="literal">MakeRequest</code> on the <code class="literal">_webRequest</code> object. We specify the API key and endpoint as parameters to this call, and we expect a <code class="literal">WebSearchResponse</code> object as a response.</p><p>
<code class="literal">WebSearchResponse</code> is a data contract, which we get by deserializing the JSON response from the API service. The top-level object will contain objects with the different result types. Look in the code samples provided in the file called <code class="literal">BingSearchResponse.cs</code> for a complete data contract.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>For a complete list of response objects from Bing Web Search, visit <a class="ulink" href="https://msdn.microsoft.com/en-us/library/dn760794.aspx#searchresponse">https://msdn.microsoft.com/en-us/library/dn760794.aspx#searchresponse</a>.</p></div></div><p>Heading back to the <code class="literal">BingSearchViewModel.cs</code> file, we can add <code class="literal">BingSearch</code> as a member. The constructor should look as follows:</p><div class="informalexample"><pre class="programlisting">    public BingSearchViewModel() {
        _bingSearch = new BingSearch(); 
        SearchCommand = new DelegateCommand(Search, CanSearch);
    }</pre></div><p>The <code class="literal">CanSearch</code> parameter should return true if we have any text entered into the search query text field. <code class="literal">Search</code> should, for now, look as follows:</p><div class="informalexample"><pre class="programlisting">    private async void Search(object obj) {
        switch (SelectedSearchType) { 
            case BingSearchType.Web:
                var webResponse = await _bingSearch.SearchWeb(SearchQuery, SelectedSafeSearchFilter);
                ParseWebSearchResponse(webResponse as WebSearchResponse);
                break;
            default:
                break;
        }
    }</pre></div><p>We call the <code class="literal">SearchWeb</code> function on the <code class="literal">_bingSearch</code> object, passing on the <code class="literal">SearchQuery</code> and <code class="literal">SelectedSafeSearchFilter</code> properties as parameters. With a successful response, we send the response to a new function, <code class="literal">ParseWebSearch</code>:</p><div class="informalexample"><pre class="programlisting">private void ParseWebSearchResponse(WebSearchResponse webSearchResponse) {
    StringBuilder sb = new StringBuilder();

    Webpages webPages = webSearchResponse.webPages;

    foreach (WebValue website in webPages.value)
    {
        sb.AppendFormat("{0}\n", website.name);
        sb.AppendFormat("URL: {0}\n", website.displayUrl);
        sb.AppendFormat("About: {0}\n\n", website.snippet);
    }

    SearchResults = sb.ToString();
}</pre></div><p>When we interpret the results <a class="indexterm" id="id482"/>from a web search, we are interested in the resulting <code class="literal">webPages</code>. For each web page, we want to output the name, the display URL, and a descriptive snippet.</p><p>A successful test run with the web search should present us with the following result:</p><div class="mediaobject"><img alt="Searching the web" src="graphics/B12373_09_01.jpg"/></div><p>Result objects from a <a class="indexterm" id="id483"/>web search contain a <code class="literal">RankingResponse</code> object. This will identify how the results will typically be displayed on a search website, ordered in a mainline and sidebar. In a production system, you should always aim to display results in the order specified by <code class="literal">RankingResponse</code>.</p><p>This can be done in two ways. One is to use the specified ID field to rank all of the results. The other way is a bit more complex. It involves splitting the results based on answer types and the result index.</p><p>Apart from the queries we have seen up to now, we can also query for computations (for instance, 2 + 2), time zone <a class="indexterm" id="id484"/>calculations, and related searches. These queries will result in JSON responses, which is a bit different from a regular web search.</p></div></div></div>
<div class="section" title="Getting the news"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec60"/>Getting the news</h1></div></div></div><p>Using the Bing News <a class="indexterm" id="id485"/>Search API, we can search for news in several ways. There are three endpoints we can use for this API:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">/news</code>: Get top news articles, based on category</li><li class="listitem" style="list-style-type: disc"><code class="literal">/news/search</code>: Get news articles based on a search query</li><li class="listitem" style="list-style-type: disc"><code class="literal">/news/trendingtopics</code>: Get top trending news topics</li></ul></div><p>In our smart-house application, we will add the first two, while we will only cover the last one theoretically.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>If you have not already done so, sign up for the Bing News Search API at <a class="ulink" href="https://portal.azure.com">https://portal.azure.com</a>.</p></div></div><div class="section" title="News from queries"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec67"/>News from queries</h2></div></div></div><p>A lot of the groundwork for <a class="indexterm" id="id486"/>query-based news searches has already been done in the web search sample. To search for news based on given queries, we need to add a new function in the <code class="literal">BingSearch</code> class.</p><p>Open the <code class="literal">BingSearch.cs</code> file and add a new function called <code class="literal">SearchNews</code>. This should accept a <code class="literal">string</code> and a <code class="literal">SafeSearch</code> parameter. The function should be marked as <code class="literal">async</code>, and return a <code class="literal">Task&lt;BingNewsResponse&gt;</code> object:</p><div class="informalexample"><pre class="programlisting">public async Task&lt;BingNewsResponse&gt; SearchNews(string query, SafeSearch safeSearch)
{
    string endpoint = string.Format("{0}{1}&amp;safeSearch={2}&amp;count=5&amp;mkt=en-US","https://api.cognitive.microsoft.com/bing/v7.0/news/search?q=", query,safeSearch.ToString());</pre></div><p>We will construct an endpoint consisting of the URL, the search query, and the <code class="literal">safeSearch</code> parameter. Notice how we specify the market, <code class="literal">mkt</code>, while limiting the <code class="literal">count</code> to 5. Both of these parameters will be described presently in this chapter.</p><p>The only required parameter is the query string, <code class="literal">q</code>. Apart from parameters described for web searches (<code class="literal">setLang</code>, <code class="literal">textDecorations</code>, and <code class="literal">textFormat</code>), we can also specify a parameter called <code class="literal">originalImg</code>. This is a Boolean value, which, if set to true, will provide a URL to the original image (for any image in the article). If that is set to false, which is the default, a URL for the thumbnail is provided.</p><p>With an endpoint in place, we can call the API:</p><div class="informalexample"><pre class="programlisting">    try {
        BingNewsResponse response = await _webRequest.MakeRequest&lt;BingNewsResponse&gt;(endpoint);

        return response;
    }
catch (Exception ex) {
        Debug.WriteLine(ex.Message);
    }

    return null;</pre></div><p>We call <code class="literal">MakeRequest</code>, on the <code class="literal">_webRequest</code> object, passing on the endpoint as a parameter.</p><p>A successful call will result in <a class="indexterm" id="id487"/>a JSON response, which we deserialize into a <code class="literal">BingNewsResponse</code> object. This object needs to be created as a data contract.</p><p>The <code class="literal">BingNewsResponse</code> object will contain an array of news articles. Each item in this array will contain the article name, URL, image, description, publishing date, and more.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>For full details of each item in the news article array, visit <a class="ulink" href="https://msdn.microsoft.com/en-us/library/dn760793.aspx#newsarticle">https://msdn.microsoft.com/en-us/library/dn760793.aspx#newsarticle</a>.</p></div></div><p>With that in place, we can head back into the <code class="literal">BingSearchViewModel.cs</code> file and modify the <code class="literal">Search</code> function. We do so by adding a case for <code class="literal">BingSearchType.News</code> inside the <code class="literal">switch</code> statement:</p><div class="informalexample"><pre class="programlisting">    case BingSearchType.News:
        var newsResponse = await _bingSearch.SearchNews(SearchQuery, SelectedSafeSearchFilter);
        ParseNewsResponse(newsResponse as BingNewsResponse);
        break;</pre></div><p>A successful response will be parsed and displayed in the UI:</p><div class="informalexample"><pre class="programlisting">private void ParseNewsResponse(BingNewsResponse bingNewsResponse) {
    StringBuilder sb = new StringBuilder();

    foreach(Value news in bingNewsResponse.value) { 
        sb.AppendFormat("{0}\n", news.name);
        sb.AppendFormat("Published: {0}\n", news.datePublished);
        sb.AppendFormat("{0}\n\n", news.description);
    }

    SearchResults = sb.ToString();
}</pre></div><p>We are mostly interested in the <a class="indexterm" id="id488"/>news article name, the date it is published, and a description.</p><p>A good test run of this should present us with the following result:</p><div class="mediaobject"><img alt="News from queries" src="graphics/B12373_09_02.jpg"/></div></div><div class="section" title="News from categories"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec68"/>News from categories</h2></div></div></div><p>When we want to get the top articles for certain categories, we go through a similar procedure as we did for <a class="indexterm" id="id489"/>regular news queries. The difference lies in the endpoint we construct.</p><p>Let's create a new function, <code class="literal">SearchNewsCategory</code>, in the <code class="literal">BingSearch</code> class:</p><div class="informalexample"><pre class="programlisting">public async Task&lt;BingNewsResponse&gt; SearchNewsCategory(string query)
{
    string endpoint = string.Format("{0}{1}&amp;mkt=en-US", "https://api.cognitive.microsoft.com/bing/v5.0/news?category=", query);</pre></div><p>Here, we have a category parameter, with the topic we wish to search for. This is an optional parameter. If it is empty, we will get the top news article for all categories.</p><p>For this search, we can specify two different markets, <code class="literal">en-GB</code> and <code class="literal">en-US</code>. Each of these comes with a list of pre-defined categories that are currently supported:</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>For a complete list of supported categories, visit <a class="ulink" href="https://msdn.microsoft.com/en-us/library/dn760793.aspx#categoriesbymarket">https://msdn.microsoft.com/en-us/library/dn760793.aspx#categoriesbymarket</a>.</p></div></div><div class="informalexample"><pre class="programlisting">    try {
        BingNewsResponse response = await _webRequest.MakeRequest&lt;BingNewsResponse&gt;(endpoint);

        return response;
    }
catch (Exception ex) {
        Debug.WriteLine(ex.Message);
    }

    return null;</pre></div><p>With the newly constructed endpoint, we call <code class="literal">MakeRequest</code> on the <code class="literal">_webRequest</code> object. This should result in the <a class="indexterm" id="id490"/>same response object as for regular news queries. In our ViewModel, we add a <code class="literal">case</code> for this search type in the <code class="literal">Search</code> function. With the response, we utilize the already created <code class="literal">ParseNewsResponse</code> to get the data we want.</p></div><div class="section" title="Trending news"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec69"/>Trending news</h2></div></div></div><p>The search for trending <a class="indexterm" id="id491"/>news is only available for the <code class="literal">en-US</code> and <code class="literal">zh-CN</code> markets. To execute this search, make a request to the following URL: <a class="ulink" href="https://api.cognitive.microsoft.com/bing/v7.0/news/trendingtopics">https://api.cognitive.microsoft.com/bing/v7.0/news/trendingtopics</a>.</p><p>No parameters are required by this call, but you can add filters, such as the common filters we will discuss later. The only exception is the <code class="literal">freshness</code> filter, which will not work for this request.</p><p>A successful call to this endpoint will result in a <code class="literal">TrendingTopicAnswer</code> object that will contain an array of trending topics. Each item in this array will contain the following data:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Data field</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">image</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A link to a related image</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">isBreakingNews</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A Boolean indicating whether this topic is considered breaking news</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">name</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The title of the topic</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">query</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A query string that will return this topic</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">webSearchUrl</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A URL to the Bing search results for this topic</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">webSearchUrlPingSuffix</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A query string fragment to identify the <code class="literal">webSearchUrl</code>
</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="Searching for images and videos"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec61"/>Searching for images and videos</h1></div></div></div><p>The Bing Image <a class="indexterm" id="id492"/>Search API and Bing Video Search API allow us to search directly for images or videos. These APIs <a class="indexterm" id="id493"/>should be used only if you need image or video content. There is a possibility that calling these APIs will affect performance and relevance negatively, and as such, one should aim to use the Bing Web Search API.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>If you have not already done so, sign up for the Bing Image Search API and the Bing Video Search API at <a class="ulink" href="https://portal.azure.com">https://portal.azure.com</a>.</p></div></div><div class="section" title="Using a common user interface"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec70"/>Using a common user interface</h2></div></div></div><p>As we do not need image or video search in our smart-house application, we will go on to create a <a class="indexterm" id="id494"/>new project. Create this project using the MVVM template that we created in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Microsoft Cognitive Services">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Microsoft Cognitive Services</em></span>.</p><p>These <a class="indexterm" id="id495"/>APIs do not come with any client packages. Like we did previously, we should really make these calls from the server-side <a class="indexterm" id="id496"/>application not the client application. In any case, we need to copy the <code class="literal">BingWebRequest.cs</code> file from the smart-house <a class="indexterm" id="id497"/>application to the <code class="literal">Model</code> folder. Make sure to change the namespace.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Remember to add references to <code class="literal">System.Web</code> and <code class="literal">System.Runtime.Serialization</code>.</p></div></div><p>We will need to install the <code class="literal">Newtonsoft.Json</code> NuGet package for our deserialization to work. Do so through the NuGet package manager.</p><p>As we will output some of the results as text, we can get away with one common user interface.</p><p>Open the <code class="literal">MainView.xaml</code> file. Add two <code class="literal">TextBox</code> elements, one for the search query and one for the result. We need a <code class="literal">ComboBox</code> element to select between search types. Finally, we need to add a <code class="literal">Button</code> element for our search command.</p><p>In the <code class="literal">MainViewModel.xaml</code> file, we need to add an <code class="literal">enum</code> with the search types. Add the following at the bottom of the file, beneath the class:</p><div class="informalexample"><pre class="programlisting">    public enum SearchType {
        ImageSearch,
        VideoSearch,
    }  </pre></div><p>We are only <a class="indexterm" id="id498"/>interested in image and video searches with queries. In addition to these search forms, both APIs can search for trending images and videos. The <a class="indexterm" id="id499"/>Bing Video Search API also allows us to get more detail on any given video we have already searched for.</p><p>In the <code class="literal">MainViewModel</code> class, we <a class="indexterm" id="id500"/>need to add two <code class="literal">string</code> properties corresponding to our <code class="literal">TextBox</code> elements. We will also need a property of type <code class="literal">SearchType</code> to indicate the selected search type. To indicate what search <a class="indexterm" id="id501"/>types we have available, we add an <code class="literal">IEnumerable</code> property, as follows:</p><div class="informalexample"><pre class="programlisting">public IEnumerable&lt;SearchType&gt; SearchTypes {
    get { 
        return Enum.GetValues(typeof(SearchType)).Cast&lt;SearchType&gt;();
    }
}</pre></div><p>The last property we need to add to our ViewModel is the <code class="literal">ICommand</code> property, which will be bound to our <code class="literal">Button</code> element.</p><p>Now, we need to create a new class, so create a new file called <code class="literal">BingSearch.cs</code>, in the <code class="literal">Model</code> folder. This will be responsible for constructing the correct endpoints and executing both search types.</p><p>We will need to add a member of type <code class="literal">BingWebRequest</code>. This should be created in the constructor:</p><div class="informalexample"><pre class="programlisting">private BingWebRequest _webRequest;

public BingSearch() {
    _webRequest = new BingWebRequest("API_KEY_HERE");
}</pre></div><p>That is all we need to do here for now.</p><p>Back in the ViewModel, we need to add a member of type <code class="literal">BingSearch</code>. With that in place, we can create our constructor:</p><div class="informalexample"><pre class="programlisting">public MainViewModel() {
    _bingSearch = new BingSearch();

    SearchCommand = new DelegateCommand(Search);

    SelectedSearchType = SearchTypes.FirstOrDefault();
}</pre></div><p>With the ViewModel in place, we can do some searches.</p></div><div class="section" title="Searching for images"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec71"/>Searching for images</h2></div></div></div><p>For our example, we will only be executing the image search based on user queries. To allow for this, we will <a class="indexterm" id="id502"/>need to add a function in the <code class="literal">BingSearch</code> class. Call the function <code class="literal">SearchImages</code> and let it accept a string as a parameter. The function should return <code class="literal">Task&lt;ImageSearchResponse&gt;</code> and be marked as <code class="literal">async</code>. <code class="literal">ImageSearchResponse</code> will, in this case, be a data contract object, with data deserialized from our response:</p><div class="informalexample"><pre class="programlisting">public async Task&lt;ImageSearchResponse&gt; SearchImages(string query)
{
    string endpoint = string.Format("{0}{1}","https://api.cognitive.microsoft.com/bing/v5.0/images/search?q=", query);</pre></div><p>We will start by constructing our endpoint. In this case, we only specify the query parameter, <code class="literal">q</code>. This is a required parameter.</p><p>Apart from the common query parameters, which we will see presently, we can also add the following parameters:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Parameter</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">cab</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Bottom coordinate of the region to crop, in a value from 0.0 to 1.0. Measured from the top-left corner.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">cal</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The left coordinate of the region to crop, in a value from 0.0 to 1.0.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">car</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The right coordinate of the region to crop, in a value from 0.0 to 1.0.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">cat</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The top coordinate of the region to crop, in a value from 0.0 to 1.0.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ct</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The crop type to use. Currently, the only legal value is 0 - Rectangular.</p>
</td></tr></tbody></table></div><p>In addition, we can specify the following parameters as filters:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Filter name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">aspect</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Filter images by aspect ratio. Legal values are <code class="literal">Square</code>, <code class="literal">Wide</code>, <code class="literal">Tall</code>, and <code class="literal">All</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">color</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Filter images by specific colors.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">imageContent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Filter images by image content. Legal values are <code class="literal">Face</code> and <code class="literal">Portrait</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">imageType</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Filter images by image types. Legal values are <code class="literal">AnimatedGif</code>, <code class="literal">Clipart</code>, <code class="literal">Line</code>, <code class="literal">Photo</code>, and <code class="literal">Shopping</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">license</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Filter images by license that apply to the image. Legal values are <code class="literal">Public</code>, <code class="literal">Share</code>, <code class="literal">ShareCommercially</code>, <code class="literal">Modify</code>, <code class="literal">ModifyCommercially</code>, and <code class="literal">All</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">size</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Filter images by size. Legal values are <code class="literal">Small</code> (&lt; 200 x 200 pixels), <code class="literal">Medium</code> (200 x 200 to 500 x 500 pixels), <code class="literal">Large</code> (&gt;500 x 500 pixels), <code class="literal">Wallpaper</code>, and <code class="literal">All</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">height</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Only get results with a specific height.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">width</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Only get results with a specific width.</p>
</td></tr></tbody></table></div><p>With the endpoint in place, we can execute the request:</p><div class="informalexample"><pre class="programlisting">    try {
       ImageSearchResponse response = await _webRequest.MakeRequest&lt;ImageSearchResponse&gt;(endpoint);

        return response;
    } 
    catch (Exception ex) {
        Debug.WriteLine(ex.Message);
    }

    return null;</pre></div><p>We will call <code class="literal">MakeRequest</code> on the <code class="literal">_webRequest</code> object, passing on the endpoint as a parameter. A successful call <a class="indexterm" id="id503"/>will result in an <code class="literal">ImageSearchResponse</code>, which is the deserialized data contract object from the JSON response.</p><p>The resulting object will contain a lot of data. Among that data is an array that contains information about images. Each item in that array contains data, such as an image name, date published, URL, and image ID.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>For a complete list of the data available in a response, visit <a class="ulink" href="https://msdn.microsoft.com/en-us/library/dn760791.aspx#images">https://msdn.microsoft.com/en-us/library/dn760791.aspx#images</a>.</p></div></div><p>Heading over to <code class="literal">MainViewModel.cs</code>, we can now create the <code class="literal">Search</code> function:</p><div class="informalexample"><pre class="programlisting">    private async void Search(object obj) {
        SearchResult = string.Empty;
switch(SelectedSearchType) {
            case SearchType.ImageSearch:
                var imageResponse = await _bingSearch.SearchImages(SearchQuery);
                ParseImageResponse(imageResponse);
                break;
            default:
                break;
        }
    }</pre></div><p>With a successful response, we parse the <code class="literal">imageResponse</code>. Normally, this would mean displaying images in a list or <a class="indexterm" id="id504"/>similar, but we will take the easier option by outputting textual information:</p><div class="informalexample"><pre class="programlisting">private void ParseImageResponse(ImageSearchResponse imageResponse)
{
    StringBuilder sb = new StringBuilder();
    sb.Append("Image search results:\n\n");
    sb.AppendFormat("# of results: {0}\n\n", imageResponse.totalEstimatedMatches);

    foreach (Value image in imageResponse.value) {
        sb.AppendFormat("\tImage name: {0}\n\tImage size: {1}\n\tImage host: {2}\n\tImage URL:{3}\t\n\n", image.name, image.contentSize, image.hostPageDisplayUrl, image.contentUrl);
    }

    SearchResult = sb.ToString();
}</pre></div><p>We will print out the number of matches in the search. Then, we will loop through the image array, printing the name, size, host, and URL of each image.</p><p>A successful test run should present us with the following screen:</p><div class="mediaobject"><img alt="Searching for images" src="graphics/B12373_09_03.jpg"/></div><p>In addition to the query-based <a class="indexterm" id="id505"/>image search, we can also search for trending images. To do so, you will have to call the following endpoint: <a class="ulink" href="https://api.cognitive.microsoft.com/bing/v7.0/images/trending">https://api.cognitive.microsoft.com/bing/v7.0/images/trending</a>.</p><p>Currently, this is only available for the following markets: <code class="literal">en-US</code>, <code class="literal">en-CA</code>, and <code class="literal">en-AU</code>. A successful call to this endpoint will result in an array of categories. Each item in this array will contain an array of trending images, as well as the title of the category.</p></div><div class="section" title="Searching for videos"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec72"/>Searching for videos</h2></div></div></div><p>Searching for videos is nearly the same process as for images. The only real difference is how we construct the <a class="indexterm" id="id506"/>endpoint and the response we get.</p><p>We are going to add a new function in the <code class="literal">BingSearch</code> class to accompany a video search:</p><div class="informalexample"><pre class="programlisting">public async Task&lt;VideoSearchResponse&gt; SearchVideos(string query)
{
    string endpoint = string.Format("{0}{1}", "https://api.cognitive.microsoft.com/bing/v7.0/videos/search?q=", query);</pre></div><p>As you can see, there is only one required parameter: the query string, <code class="literal">q</code>. We can also specify a few optional parameters that are common to all the search APIs, which will be described later.</p><p>Aside from common filters, video can also filter results based on the following filters:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Filter</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">pricing</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Filter videos by price. Legal values are Free, Paid, and All.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">resolution</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Filter by resolution. Legal values are 480p, 720p, 1080p, and All.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">videoLength</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Filter videos by length. Legal values is <code class="literal">Short</code> (&lt; 5 minutes), <code class="literal">Medium</code> (5 to 20 minutes), <code class="literal">Long</code> (&gt; 20 minutes), and <code class="literal">All</code>.</p>
</td></tr></tbody></table></div><p>With the endpoint in place, we call the API:</p><div class="informalexample"><pre class="programlisting">try {
   VideoSearchResponse response = await _webRequest.MakeRequest&lt;VideoSearchResponse&gt;(endpoint);

    return response;
}
catch (Exception ex) {
    Debug.WriteLine(ex.Message);
}

return null;</pre></div><p>We will call <code class="literal">MakeRequest</code> on the <code class="literal">_webRequest</code> object, passing on the endpoint as a parameter. A successful call will result in a <code class="literal">VideoSearchResponse</code> object. This is a data contract, deserialized from the JSON response.</p><p>Among other data, it will contain an array of videos. Each item in this array contains a video name, description, publisher, duration, URL, and more.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>For a complete list of data available in the search response, visit <a class="ulink" href="https://msdn.microsoft.com/en-US/library/dn760795.aspx#videos">https://msdn.microsoft.com/en-US/library/dn760795.aspx#videos</a>.</p></div></div><p>To be able to search for videos, we add a new case in the <code class="literal">Search</code> function, in <code class="literal">MainViewModel</code>:</p><div class="informalexample"><pre class="programlisting">case SearchType.VideoSearch:
  var videoResponse = await _bingSearch.SearchVideos(SearchQuery);
  ParseVideoResponse(videoResponse);
  break;</pre></div><p>We call the newly <a class="indexterm" id="id507"/>created <code class="literal">SearchVideos</code>, passing on the search query as a parameter. If the call succeeds, we go on to parse the video:</p><div class="informalexample"><pre class="programlisting">private void ParseVideoResponse(VideoSearchResponse videoResponse)
{
    StringBuilder sb = new StringBuilder();
    sb.Append("Video search results:\n\n");
    sb.AppendFormat("# of results: {0}\n\n",
    videoResponse.totalEstimatedMatches);

    foreach (VideoValue video in videoResponse.value) {
        sb.AppendFormat("\tVideo name: {0}\n\tVideo duration: {1}\n\tVideo URL: {2}\t\n",video.name, video.duration, video.contentUrl);

        foreach(Publisher publisher in video.publisher) { 
            sb.AppendFormat("\tPublisher: {0}\n", publisher.name);
        }

        sb.Append("\n");
    }
    SearchResult = sb.ToString();
}</pre></div><p>As for images, we just show video information textually. In our example, we choose to show the video name, duration, URL, and all publishers of a video.</p><p>A successful video search should give the following result:</p><div class="mediaobject"><img alt="Searching for videos" src="graphics/B12373_09_04.jpg"/></div><p>In addition to the <a class="indexterm" id="id508"/>query-based video search, we can also search for trending videos. To do so, you would have to call the following endpoint: <a class="ulink" href="https://api.cognitive.microsoft.com/bing/v7.0/videos/trending">https://api.cognitive.microsoft.com/bing/v7.0/videos/trending</a>.</p><p>Currently, this is only available for the following markets: <code class="literal">en-US</code>, <code class="literal">en-CA</code>, and <code class="literal">en-AU</code>. A successful call to this endpoint will result in an array of categories and tiles. Each item in the category array will contain a title and an array of subcategories. Each subcategory will contain an array of tiles and the title. Each item in a tile array will contain the video thumbnail and a query to use to get the specific video.</p><p>If we want to get more information about any video, we can query the following endpoint: <a class="ulink" href="https://api.cognitive.microsoft.com/bing/v7.0/videos/details">https://api.cognitive.microsoft.com/bing/v7.0/videos/details</a>.</p><p>This requires us to specify an <code class="literal">id</code> so that we can identify a video. We can also specify the <code class="literal">modulesRequested</code>. This is a comma-separated list of the details we want. Currently, the legal values are <code class="literal">All</code>, <code class="literal">RelatedVideos</code>, and <code class="literal">VideoResult</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>For a complete list of data available in the response from a details query, visit <a class="ulink" href="https://msdn.microsoft.com/en-US/library/dn760795.aspx#video">https://msdn.microsoft.com/en-US/library/dn760795.aspx#video</a>.</p></div></div></div></div>
<div class="section" title="Helping the user with autosuggestions"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec62"/>Helping the user with autosuggestions</h1></div></div></div><p>Autosuggestions are a <a class="indexterm" id="id509"/>great way to enhance user experience. The typical use case is where, whenever a user enters some text into a text field, a list of suggested words is displayed.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>If you have not already done so, sign up for the Bing Autosuggest API at <a class="ulink" href="https://portal.azure.com">https://portal.azure.com</a>.</p></div></div><div class="section" title="Adding autosuggest to the user interface"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec73"/>Adding autosuggest to the user interface</h2></div></div></div><p>As textboxes in WPF do not contain any autosuggestion features, we need to add some on our own. We are <a class="indexterm" id="id510"/>going to use a third-party package, so install the <code class="literal">WPFTextBoxAutoComplete</code> package through the NuGet package manager, in our example project.</p><p>In the <code class="literal">MainView.xaml</code> file, add the following attribute to the starting <code class="literal">Window</code> tag:</p><div class="informalexample"><pre class="programlisting">    </pre></div><p>We will also need to make sure that the <code class="literal">TextBox</code> binding for our search query updates whenever the user enters data. This <a class="indexterm" id="id511"/>can be done by making sure that the <code class="literal">Text</code> attribute looks as follows:</p><div class="informalexample"><pre class="programlisting">Text="{Binding SearchQuery, UpdateSourceTrigger=PropertyChanged}"</pre></div><p>In the same <code class="literal">TextBox</code> element, add the following:</p><div class="informalexample"><pre class="programlisting">behaviors:AutoCompleteBehavior.AutoCompleteItemsSource = "{Binding Suggestions}"</pre></div><p>In the ViewModel, in the <code class="literal">MainViewModel.cs</code> file, we need the corresponding property. This should be an <code class="literal">IEnumerable&lt;string&gt;</code> object. This will be updated with the result from the autosuggest query we will perform presently.</p></div><div class="section" title="Suggesting queries"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec74"/>Suggesting queries</h2></div></div></div><p>To get autosuggestions, we first add a new class. Add a new file called <code class="literal">BingAutoSuggest.cs</code>, to the <code class="literal">Model</code> folder. The <code class="literal">BingAutoSuggest</code> class should have a member of type <code class="literal">BingWebRequest</code>, which should be created in the constructor.</p><p>Create a new <a class="indexterm" id="id512"/>function called <code class="literal">Suggest</code>. This should accept a <code class="literal">string</code> as a parameter, returning a <code class="literal">Task&lt;List&lt;string&gt;&gt;</code> object. Mark the function as <code class="literal">async</code>.</p><p>We will start by constructing an endpoint, where we specify the query string, <code class="literal">q</code>. This field is required. We also specify the market, <code class="literal">mkt</code>, although this is not required. We do not need any other parameters. Before we execute the API call, we will create a list of suggestions, which we will return to the caller:</p><div class="informalexample"><pre class="programlisting">public async Task&lt;List&lt;string&gt;&gt; Suggest(string query) {
   string endpoint = string.Format("{0}{1}&amp;mkt=en-US", "https://api.cognitive.microsoft.com/bing/v7.0/suggestions/?q=", query);

    List&lt;string&gt; suggestionResult = new List&lt;string&gt;();</pre></div><p>We will make a call to <code class="literal">MakeRequest</code> on the <code class="literal">_webRequest</code> object, passing on the endpoint as a parameter. If the call succeeds, we expect the JSON response to deserialize into a <code class="literal">BingAutoSuggestResponse</code> object. This object will contain an array of <code class="literal">suggestionGroups</code>, where each item contains an array of <code class="literal">SearchSuggestions</code>.</p><p>Each item of <code class="literal">SearchSuggestion</code> contains a URL, display text, a query string, and a search kind. We are interested in the display text, which we add to the <code class="literal">suggestionResult</code> list. This list is returned to the caller:</p><div class="informalexample"><pre class="programlisting">try  {
    BingAutoSuggestResponse response = await _webRequest.MakeRequest&lt;BingAutoSuggestResponse&gt;(endpoint);

    if (response == null || response.suggestionGroups.Length == 0)
        return suggestionResult;
foreach(Suggestiongroup suggestionGroup in response.suggestionGroups) {
foreach(Searchsuggestion suggestion in suggestionGroup.searchSuggestions) {
suggestionResult.Add(suggestion.displayText);
        }
    }
} 
catch(Exception ex) {
    Debug.WriteLine(ex.Message);
}

return suggestionResult;</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>For a complete description of response data, go to <a class="ulink" href="https://msdn.microsoft.com/en-us/library/mt711395.aspx#suggestions">https://msdn.microsoft.com/en-us/library/mt711395.aspx#suggestions</a>.</p></div></div><p>In the <code class="literal">MainViewModel.cs</code> file, we want to get suggestions as we type. We will create a new function, as follows:</p><div class="informalexample"><pre class="programlisting">private async void GetAutosuggestions() {
var results = await _autoSuggest.Suggest(SearchQuery);

    if (results == null || results.Count == 0) return;

    Suggestions = results;
}</pre></div><p>This will call the newly <a class="indexterm" id="id513"/>created <code class="literal">Suggest</code> function, with the current value of the <code class="literal">SearchQuery</code>. If any results are returned, we assign them to the <code class="literal">SuggestionsIEnumerable</code> that we created earlier. Make sure to call this function when we set the value in the <code class="literal">SearchQuery</code> property.</p><p>In the UI, this will have the first suggestion automatically populated in the search-query field. This is not ideal for users, but it will do for our test example.</p></div></div>
<div class="section" title="Search commonalities"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec63"/>Search commonalities</h1></div></div></div><p>For all the APIs we <a class="indexterm" id="id514"/>have covered, there are a few similarities. We will cover these now.</p><div class="section" title="Languages"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec75"/>Languages</h2></div></div></div><p>It is highly recommended to specify which market you want results for. Searches will typically return results for the local market and language of the user, based on the current location. As you <a class="indexterm" id="id515"/>can imagine, this is not always what the user wants. By specifying the market, you can tailor the search results for the user.</p><p>How you choose to solve this technically is dependent on the requirements of your application. For a smart-house application, you would probably allow the user to set the market in the settings. For a web application created only for French users in France, you would probably not allow the user to change the market.</p><p>Specifying the market is done by adding the <code class="literal">mkt</code> parameter to the <code class="literal">GET</code> request. This should then specify the market code, for example, <code class="literal">en-US</code> for English in the United States.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>While any API may support a specific market, some features may not support a given market.</p></div></div><p>A subset of the languages supported is English, Spanish, German, Dutch, French, Portuguese, Traditional Chinese, Italian, Russian, and Arabic.</p><p>In addition, we can <a class="indexterm" id="id516"/>specify a <code class="literal">cc</code> parameter to the <code class="literal">GET</code> request. This specifies a country (typically, the country the user is in). This parameter should be in the form of a two-letter country code, for instance, GB for United Kingdom.</p><p>A wide variety of countries can be specified, and the list is continuously subject to change.</p></div><div class="section" title="Pagination"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec76"/>Pagination</h2></div></div></div><p>Some searches may yield a large number of results. In these cases, you may want to perform pagination. This <a class="indexterm" id="id517"/>can be achieved by specifying the <code class="literal">count</code> and <code class="literal">offset</code> parameters in the GET request.</p><p>If you want 10 results per page, you would start by setting the count to 10, and the offset to 0 for the first page. When the user navigates to the next page, you would keep the <code class="literal">count</code> at 10, but increase the <code class="literal">offset</code> to 10. For the next page, you would increase the <code class="literal">offset</code> to 20, and so on.</p><p>The maximum number of results returned in each query (the count parameter) varies for each API. See the following table for the current maximum count per API:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>API</p>
</th><th style="text-align: left" valign="bottom">
<p>Maximum search results</p>
</th><th style="text-align: left" valign="bottom">
<p>Default search results</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Bing News Search</p>
</td><td style="text-align: left" valign="top">
<p>100</p>
</td><td style="text-align: left" valign="top">
<p>10</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Bing Web Search</p>
</td><td style="text-align: left" valign="top">
<p>50</p>
</td><td style="text-align: left" valign="top">
<p>10</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Bing Image Search</p>
</td><td style="text-align: left" valign="top">
<p>150</p>
</td><td style="text-align: left" valign="top">
<p>35</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Bing Video Search</p>
</td><td style="text-align: left" valign="top">
<p>105</p>
</td><td style="text-align: left" valign="top">
<p>35</p>
</td></tr></tbody></table></div></div><div class="section" title="Filters"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec77"/>Filters</h2></div></div></div><p>We have seen some <a class="indexterm" id="id518"/>filters for individual APIs. In addition to these, there are a couple of filters which can be applied <a class="indexterm" id="id519"/>to all searches.</p><div class="section" title="Safe search"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec51"/>Safe search</h3></div></div></div><p>The safe search filter <a class="indexterm" id="id520"/>can be used to filter search results for adult content. This parameter is added in the request URL.</p><p>The <code class="literal">safeSearch</code> parameter can be one of the following values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Off</strong></span>: All result items will be returned</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Moderate</strong></span>: Result items can contain adult text, but no adult images or videos will be included</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Strict</strong></span>: No adult text, images, or videos are included in the result items</li></ul></div><p>Note that, if the IP address of the user indicates a location that requires the Strict safe search, this setting will be ignored. Bing will, in this case, default to the Strict policy.</p><p>If the parameter has not been set, it defaults to moderate.</p></div><div class="section" title="Freshness"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec52"/>Freshness</h3></div></div></div><p>By adding the <code class="literal">freshness</code> parameter <a class="indexterm" id="id521"/>to a request, you can filter search results based on the age of result items. The values that can be specified are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Day</strong></span>: Results from the last 24 hours</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Week</strong></span>: Results from the last 7 days</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Month</strong></span>: Results from the last 30 days</li></ul></div></div></div><div class="section" title="Errors"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec78"/>Errors</h2></div></div></div><p>Among all the APIs we <a class="indexterm" id="id522"/>have covered, there are a few possible <a class="indexterm" id="id523"/>response codes that you may receive for each request. The following table describes all of the possible response codes:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Code</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">200</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Successful request.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">400</code>
</p>
</td><td style="text-align: left" valign="top">
<p>One or more required query parameters are missing, or one of the parameters is invalid. More details are described in the <code class="literal">ErrorResponse</code> field.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">401</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The provided subscription key is invalid or missing.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">403</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Typically returned if the monthly quota is exceeded. Can also be used if the caller does not have permission to access the requested resource.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">410</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The HTTP protocol has been used instead of HTTPS, which is the only supported protocol.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">429</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The quota per second has been exceeded.</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="Searching for visual content using Bing Visual Search"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec64"/>Searching for visual content using Bing Visual Search</h1></div></div></div><p>Using the <span class="strong"><strong>Bing Visual Search</strong></span> API, one can interpret <a class="indexterm" id="id524"/>images. This API allows us to gain <a class="indexterm" id="id525"/>insights about images. This <a class="indexterm" id="id526"/>includes finding visually similar images, searches, and shopping sources. It can also identify people, places, and objects, as well as text.</p><div class="section" title="Sending a request"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec79"/>Sending a request</h2></div></div></div><p>You will <a class="indexterm" id="id527"/>typically upload an image to the API to retrieve insights on it. In addition, you can pass on an URL to an image.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>The endpoint you should use to query the Bing Visual Search API is <a class="ulink" href="https://api.cognitive.microsoft.com/bing/v7.0/images/visualsearch">https://api.cognitive.microsoft.com/bing/v7.0/images/visualsearch</a>.</p></div></div><p>In either scenario, the following query parameters can be added:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>cc</strong></span>: The two-letter language code of the country where the results should come from.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>mkt</strong></span>: The market where the results come from. This should always be specified.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>safeSearch</strong></span>: The filter used to filter adult content. Can be <span class="emphasis"><em>Off</em></span>, <span class="emphasis"><em>Moderate</em></span>, or <span class="emphasis"><em>Strict</em></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>setLang</strong></span>: The language to use for user interface strings, that is, a two-letter language code.</li></ul></div><p>In addition, two content headers must be specified. These are <code class="literal">Content-Type</code> and <code class="literal">Ocp-Apim-Subscription-Key</code>. The first one must be set to <code class="literal">multipart/form-data;boundary={BOUNDARY}</code>. The latter must specify the API key.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>For more information on content headers, please visit <a class="ulink" href="https://docs.microsoft.com/en-us/azure/cognitive-services/bing-visual-search/overview#content-form-types">https://docs.microsoft.com/en-us/azure/cognitive-services/bing-visual-search/overview#content-form-types</a>.</p></div></div></div><div class="section" title="Receiving a response"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec80"/>Receiving a response</h2></div></div></div><p>Once the request has gone through, a JSON object will be returned as a response.</p><p>This object will <a class="indexterm" id="id528"/>contain two objects: an array of <code class="literal">tags</code> and an <code class="literal">image</code> string. The image string is simply the insights token for the image. The list of <code class="literal">tags</code> contains a <code class="literal">tag</code> name and a list of <code class="literal">actions</code> (insights). A tag, in this context, means category. For instance, if an actor is recognized in the image, the tag for this might be <span class="emphasis"><em>Actor</em></span>.</p><p>Each action, or insight, describes something of the image. It might describe text in the image or different products discovered in the image. Each action includes a whole variety of data.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>To see a full list of default insights, please visit <a class="ulink" href="https://docs.microsoft.com/en-us/azure/cognitive-services/bing-visual-search/default-insight">https://docs.microsoft.com/en-us/azure/cognitive-services/bing-visual-search/default-insights-tag</a>.</p></div></div></div></div>
<div class="section" title="Adding a custom search"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec65"/>Adding a custom search</h1></div></div></div><p>Bing Custom <a class="indexterm" id="id529"/>Search gives you the opportunity to add a powerful, tailored search experience to your own applications. It allows you to search specifically for topics you care about.</p><p>By using the portal at <a class="ulink" href="https://www.customsearch.ai/">https://www.customsearch.ai/</a>, you can create a custom view of the web.</p><div class="section" title="Typical workflow"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec81"/>Typical workflow</h2></div></div></div><p>If you want to build a <a class="indexterm" id="id530"/>custom search web page, the following steps describe the typical workflow.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>Create a custom search instance</strong></span>: This can be done at the portal linked in the previous section.</li><li class="listitem"><span class="strong"><strong>Add active entries</strong></span>: This is a list of sites that should be included in the search results.</li><li class="listitem"><span class="strong"><strong>Add blocked entries</strong></span>: This is a list of sites that should be excluded from the search results.</li><li class="listitem"><span class="strong"><strong>Add pinned entries</strong></span>: If any search term should have websites pinned to the top of the search result, it should be specified in the pinned entries section.</li><li class="listitem"><span class="strong"><strong>Configure hosted UI</strong></span>: Set the layout, color theme, and other options for the hosted UI.</li><li class="listitem"><span class="strong"><strong>Publish the search instance</strong></span>: Publish the custom search instance.</li></ol></div><div class="section" title="Consuming the search instance"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec53"/>Consuming the search instance</h3></div></div></div><p>There are three ways to consume the custom search instance.</p><p>The first, and easiest <a class="indexterm" id="id531"/>option, is to integrate a JavaScript snippet. Once you have published the search instance, you will be provided with a pre-configured JavaScript snippet, rendering the hosted UI. This can be pasted into your existing web page. This will render the search form on your website.</p><p>Another option is to link to the custom HTML site directly. This is the link used in a JavaScript snippet, but it is only used directly.</p><p>The last option is to use the REST API directly from your own code. We will not go into deeper details on this in this book.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec66"/>Summary</h1></div></div></div><p>In this chapter, we have looked at the different Bing Search APIs. We started by looking at how we can use the Bing Web Search API to search for all kinds of content. Next, we found the latest news, based on query strings and categories. From there, we moved on to image and video searches. In addition, we looked at how to enhance the user experience by adding autosuggestions. We did this by using the Bing Autosuggestion API. Finally, we briefly introduced you to Bing Visual Search and Bing Custom Search.</p><p>In the next and final chapter, we will wrap things up. We will complete our smart-house application by connecting the pieces. We will also take a look at the road ahead.</p></div></body></html>