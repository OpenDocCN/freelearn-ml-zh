- en: An Introduction to the Basics of OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After covering OpenCV installation on different operating systems in [Chapter
    1](96b225d4-84bc-4d49-b8b3-079b15f05cf0.xhtml), *Getting Started with OpenCV*,
    we are going to introduce the basics of OpenCV development in this chapter. It
    begins with showing how to create our project using CMake. We are going to introduce
    the basic image data structures and matrices, along with other structures that
    are required to work in our projects. We are going to introduce how to save our
    variables and data into files using the XML/YAML persistence OpenCV functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring projects with CMake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading/writing images from/to disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading videos and accessing camera devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main image structures (for example, matrices)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other important and basic structures (for example, vectors and scalars)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to basic matrix operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File storage operations with XML/YAML persistence OpenCV API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires familiarity with the basic C++ programming language. All
    the code used in this chapter can be downloaded from the following GitHub link: [https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_02](https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_02). The
    code can be executed on any operating system, though it is only tested on Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2QxhNBa](http://bit.ly/2QxhNBa)'
  prefs: []
  type: TYPE_NORMAL
- en: Basic CMake configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To configure and check all the requisite dependencies for our project, we are
    going to use CMake, but it is not the only way that this can be done; we can configure
    our project in any other tool or IDE, such as **Makefiles** or **Visual Studio**,
    but CMake is a more portable way to configure multiplatform **C++** projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake uses configuration files called `CMakeLists.txt`, where the compilation
    and dependencies process is defined. For a basic project based on an executable
    built from a single source code file, a `CMakeLists.txt` file comprising three
    lines is all that is required. The file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line defines the minimum version of CMake required. This line is mandatory
    in our `CMakeLists.txt` file and allows us to use the functionality of CMake defined from
    a specific version; in our case, we require a minimum of CMake 3.0\. The second
    line defines the project name. This name is saved in a variable called `PROJECT_NAME`.
  prefs: []
  type: TYPE_NORMAL
- en: The last line creates an executable command (`add_executable()`) from the `main.cpp`
    file, gives it the same name as our project (`${PROJECT_NAME}`), and compiles
    our source code into an executable called **CMakeTest** which is the name that
    we set up as a project name. The `${}` expression allows access to any variable
    defined in our environment. Then, we can use the `${PROJECT_NAME}` variable as
    an executable output name.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CMake allows us to create libraries used by the OpenCV build system. Factorizing
    shared code among multiple applications is a common and useful practice in software
    development. In big applications, or common code shared in multiple applications,
    this practice is very useful. In this case, we do not create a binary executable,
    but instead we create a compiled file that includes all the functions, classes,
    and so on. We can then share this library file with other applications without
    sharing our source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake includes the `add_library` function to this end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The lines starting with `#` add comments and are ignored by CMake. The `add_library` (`Hello
    hello.cpp hello.h`) command defines the source files of our library and its name,
    where `Hello` is the library name and `hello.cpp` and `hello.h` are the source
    files. We add the header file too to allow IDEs such as Visual Studio to link
    to the header files. This line is going to generate a shared (`.so` for Mac OS
    X, and Unix or `.dll` for Windows) or static library (`.a` for Mac OS X, and Unix
    or `.lib` for Windows) file, depending on whether we add a `SHARED` or `STATIC`
    word between library name and source files. `target_link_libraries(executable
    Hello)` is the function that links our executable to the desired library, in our
    case, the `Hello` library.
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CMake has the ability to search our dependencies and external libraries, giving
    us the ability to build complex projects, depending on the external components
    in our projects, and add some requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, the most important dependency is, of course, OpenCV, and we will
    add it to all of our projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s understand the working of the script from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line defines the minimum CMake version, and the second line tells
    CMake to use the new behavior of CMake to facilitate recognition of the correct
    numbers and Boolean constants without dereferencing variables with such names;
    this policy was introduced in CMake 2.8.0, and CMake warns when the policy is
    not set from version 3.0.2\. Finally, the last line defines the project title.
    After defining the project name, we have to define the requirements, libraries,
    and dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here is where we search for our OpenCV dependency. `FIND_PACKAGE` is the function
    that allows us to find our dependencies, the minimum version required, and whether
    this dependency is required or optional. In this sample script, we look for OpenCV
    in version 4.0.0 or greater and state that it is a required package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FIND_PACKAGE` command includes all OpenCV submodules, but you can specify
    the submodules that you want to include in the project by executing your application
    smaller and faster. For example, if we are only going to work with the basic OpenCV
    types and core functionality, we can use the following command: `FIND_PACKAGE(OpenCV
    4.0.0 REQUIRED core)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If CMake does not find it, it returns an error and does not prevent us from
    compiling our application. The `MESSAGE` function shows a message in the terminal
    or CMake GUI. In our case, we are showing the OpenCV version as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `${OpenCV_VERSION}` is a variable where CMake stores the OpenCV package
    version.  `include_directories()` and `link_directories()` add to our environment
    the headers and the directory of the specified library. OpenCV CMake''s module
    saves this data in the `${OpenCV_INCLUDE_DIRS}` and `${OpenCV_LIB_DIR}` variables.
    These lines are not required in all platforms, such as Linux, because these paths
    normally are in the environment, but it''s recommended to have more than one OpenCV
    version to choose the correct link and include directories. Now is the time to
    include our developed sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This last line creates the executable and links the executable with the OpenCV
    library, as we saw in the previous section, *Creating a library*. There is a new
    function in this piece of code, `SET`; this function creates a new variable and
    adds to it any value that we need. In our case, we incorporate the `main.cpp` value in
    the `SRC` variable. We can add more and more values to the same variable, as can
    be seen in the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Making the script more complex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are showing a more complex script that includes subfolders,
    libraries, and executables; all told, just two files and a few lines, as demonstrated
    in this script. It's not mandatory to create multiple `CMakeLists.txt` files,
    because we can specify everything in the main `CMakeLists.txt` file. However,
    it is more common to use different `CMakeLists.txt` files for each project subfolder,
    thereby making it more flexible and portable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example has a code structure folder, which contains one folder for a `utils`
    library and the root folder, which contains the main executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to define two `CMakeLists.txt` files, one in the root folder
    and the other in the `utils` folder. The `CMakeLists.txt` root folder file has
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Almost all lines are described in previous sections, except some functions which
    we will explain. `add_subdirectory()` tells CMake to analyze `CMakeLists.txt`
    of a desired subfolder. Before continuing with the main `CMakeLists.txt` file
    explanation, we are going to explain the `CMakeLists.txt` file in `utils`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CMakeLists.txt` file of the `utils` folders, we are going to write
    a new library to include in our main project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This CMake script file defines a variable, `UTILS_LIB_SRC`, where we add all
    source files included in our library, generate the library with the `add_library`
    function, and use the `target_include_directories` function to allow our main
    project to detect all header files. Leaving the `utils` subfolder and continuing
    with the root CMake script, the Option function creates a new variable, in our
    case `WITH_LOG`, with a small description attached. This variable could be changed
    through the `ccmake` command line or CMake GUI interface, where the description
    appears, and a check that allows users to enable or disable this option. This
    function is very useful for allowing the user to decide about compile-time features,
    such as whether we want enabling or disabling logs or not, compiling with Java
    or Python support, just as OpenCV does, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we use this option to enable a logger in our application. To enable
    the logger, we use a pre-compiler definition in our code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This LOG macro can be defined in our `CMakeLists.txt` through a call to the
    `add_definitions` function (`-DLOG`), which itself can be run or hidden by the
    CMake variable `WITH_LOG` with a simple condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to create our CMake script files to compile our computer vision
    projects in any operating system. Then, we are going to continue with the OpenCV
    basics before starting with a sample project.
  prefs: []
  type: TYPE_NORMAL
- en: Images and matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most important structure in computer vision is, without doubt, the images.
    The image in a computer vision is the representation of the physical world captured
    with a digital device. This picture is only a sequence of numbers stored in a
    matrix format (refer to the following diagram). Each number is a measurement of
    the light intensity for the considered wavelength (for example, red, green, or
    blue in color images) or for a wavelength range (for panchromatic devices). Every
    point in an image is called a **pixel** (for a picture element), and each pixel
    can store one or more values depending on whether it is a black and white image
    (also referred to as a binary image) that stores only one value, such as `0` or
    `1`, a grayscale-level image that stores two values, or a color image that stores
    three values. These values are usually between `0` and `255` in an integer number,
    but you can use other ranges, for example `0` to `1` in floating point numbers,
    as in **h****igh dynamic range imaging** (**HDRI**) or thermal images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3fbe085-1348-4509-b06e-19b81bd90ff2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The image is stored in a matrix format, where each pixel has a position in
    it and can be referenced by the number of the column and row. OpenCV uses the
    `Mat` class for this purpose. In the case of a grayscale image, a single matrix
    is used, as demonstrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eaa7307-485b-4c00-920c-214e393189f5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the case of a color image, such as the following diagram, we use a matrix
    of width x height x the number of color channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e7d1b24-152c-4bd4-a135-a25dab51c9af.png)'
  prefs: []
  type: TYPE_IMG
- en: But the `Mat` class is not only for storing images; it also enables you to store
    any type of matrix and different sizes. You can use it as an algebraic matrix
    and perform operations with it. In the following sections, we are going to describe
    the most important matrix operations, such as addition,  multiplication, diagonalization.
    But, before that, it's important to know how the matrix is stored internally in
    the computer memory, because it is always more efficient to access the memory
    slots instead of accessing each pixel with the OpenCV functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In memory, the matrix is saved as an array or sequence of values ordered by
    columns and rows. The following table shows the sequence of pixels in **BGR**
    image format:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Row 0 | Row 1 | Row 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Col 0 | Col 1 | Col 2 | Col 0 | Col 1 | Col 2 | Col 0 | Col 1 | Col 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Pixel  1 | Pixel 2 | Pixel 3 | Pixel 4 | Pixel 5 | Pixel 6 | Pixel 7 | Pixel
    8 | Pixel 9 |'
  prefs: []
  type: TYPE_TB
- en: '| B | G | R | B | G | R | B | G | R | B | G | R | B | G | R | B | G | R | B
    | G | R | B | G | R | B | G | R |'
  prefs: []
  type: TYPE_TB
- en: 'With this order, we can access any pixel by observing the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: OpenCV functions are quite optimized for random access, but sometimes, direct
    access to the memory (work with pointer arithmetic) is more efficient, for example,
    when we have to access all pixels in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Reading/writing images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following the introduction to matrices, we are going to start with the OpenCV
    code basics. The first thing that we have to learn is how to read and write images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now move on to understanding the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we have to include the declarations of the functions that we need in
    our sample. These functions come from `core` (basic image data handling) and `highgui`
    (cross-platform I/O functions provided by OpenCV are `core` and `highui;`; the
    first includes the basic classes, such as matrices, while the second includes
    the functions to read, write, and show images with graphical interfaces). Now
    it is time to read images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`imread` is the main function for reading images. This function opens an image
    and stores it in a matrix format. `imread` accepts two parameters. The first parameter
    is a string containing the image''s path, while the second is optional and, by
    default, loads the image as a color image. The second parameter allows the following
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cv::IMREAD_UNCHANGED`: If set, this returns a 16-bit/32-bit image when the
    input has the corresponding depth, otherwise it converts it to 8-bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cv::IMREAD_COLOR`: If set, this always converts an image to a color one (BGR,
    8-bit unsigned)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cv::IMREAD_GRAYSCALE`: If set, this always converts an image to a grayscale
    one (8-bit unsigned)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To save images, we can use the `imwrite` function, which stores a matrix image
    in our computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is the path where we want to save the image with the extension
    format that we desire. The second parameter is the matrix image that we want to
    save. In our code sample, we create and store a gray version of the image and
    then save it as a `.jpg` file. The gray image that we loaded will be stored in
    the gray variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `.cols` and `.rows` attributes of a matrix, we can get access to
    the number of columns and rows in an image, or, in other words, the width and
    height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To access one pixel of the image, we use the template function `cv::Mat::at<typename
    t>(row,col)` from the `Mat` OpenCV class. The template parameter is the desired
    return type. A type name in an 8-bit color image is a `Vec3b` class that stores
    three unsigned char data (Vec = vector, 3 = number of components, and b = 1 byte).
    In the case of the gray image, we can directly use the unsigned character, or
    any other number format used in the image, such as `uchar pixel= color.at<uchar>(myRow,
    myCol)`. Finally, in order to show the images, we can use the `imshow` function,
    which creates a window with a title as a first parameter and the image matrix
    as a second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If we want to stop the application from waiting, we can use the OpenCV function
    `waitKey`, with a parameter of the number of milliseconds we want to wait for
    a key press. If we set up the parameter to `0`, then the function will wait until
    a key is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the preceding code is demonstrated in the following image. The
    left-hand image is a color image, and the right-hand image is a grayscale image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34f29b0b-0443-4a78-8b77-a21936798f0a.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, by way of an example for the following samples, we are going to create
    the `CMakeLists.txt` file and see how to compile the code using the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code describes the `CMakeLists.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile our code using this `CMakeLists.txt` file, we have to carry out the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `build` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `build` folder, execute CMake or open CMake GUI app in Windows, choose
    the `source` and `build` folders, and press the Configure and Generate buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are on Linux or macOS, generate a Makefile as usual, and then compile
    the project using the `make` command. If you are on Windows, open the project
    using the editor selected in step 2 and then compile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, after compiling our application, we will have an executable called
    `app` in the build folder that we can execute.
  prefs: []
  type: TYPE_NORMAL
- en: Reading videos and cameras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section introduces you to video and camera reading using this simple example.
    Before explaining how to read videos or camera input, we want to introduce a new,
    very useful class that helps us to manage the input command-line parameters. This
    new class was introduced in OpenCV version 3.0, and is the `CommandLineParser`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that we have to do for `CommandLineParser` is define what parameters
    we need or allow in a constant `char` vector; each line has the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`name_param` can be preceded with `@`, which defines this parameter as a default
    input. We can use more than one `name_param`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor will get the inputs of the main function and the key constants
    defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.has` class method checks the existence of the parameter. In the sample,
    we check whether the user adds the parameter `help` or `?`, and then use the class
    function `printMessage` to show all the description parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `.get<typename>(parameterName)` function, we can access and read any
    of input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After obtaining all the requisite parameters, we can check whether these parameters
    are parsed correctly and show an error message if one of the parameters was not
    parsed, for example, add a string instead of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The class for video reading and camera reading is the same: the `VideoCapture`
    class that belongs to the `videoio` submodule instead of the `highgui` submodule,
    as in the previous version of OpenCV. After creating the object, we check whether
    the input command-line parameter `videoFile` has a path filename. If it''s empty,
    then we try to open a web camera; if it has a filename, then open the video file.
    To do this, we use the `open` function, giving as a parameter the video filename
    or the index camera that we want to open. If we have a single camera, we can use
    `0` as a parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether we can read the video filename or the camera, we use the `isOpened`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we create a window to show the frames with the `namedWindow` function
    and, with an infinite loop, we grab each frame using the `>>` operation and show
    the frame with the `imshow` function if we retrieve the frame correctly. In this
    case, we don't want to stop the application, but will wait 30 milliseconds to
    check whether any users want to stop the application execution with any key using
    `waitKey(30)`.
  prefs: []
  type: TYPE_NORMAL
- en: The time required to wait for the next frame using camera access is calculated
    from the camera speed and our spent algorithm time. For example, if a camera works
    at 20 fps, and our algorithm spent 10 milliseconds, a great waiting value is *30*
    = (*1000*/*20*) - *10* milliseconds. This value is calculated considering a wait
    of a sufficient amount of time to ensure that the next frame is in the buffer.
    If our camera takes 40 milliseconds to take each image, and we use 10 milliseconds
    in our algorithm, then we only need to stop with waitKey 30 milliseconds, because
    30 milliseconds of wait time, plus 10 milliseconds of our algorithm, is the same
    amount of time for which each frame of the camera is accessible.
  prefs: []
  type: TYPE_NORMAL
- en: When the user wants to finish the application, all they have to do is press
    any key and then we have to release all video resources using the release function.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to release all resources that we use in a computer vision
    application. If we do not, we can consume all RAM memory. We can release the matrices
    using the `release` function.
  prefs: []
  type: TYPE_NORMAL
- en: The result of the previous code is a new window showing a video or web camera
    in BGR format.
  prefs: []
  type: TYPE_NORMAL
- en: Other basic object types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned about the `Mat` and `Vec3b` classes, but there are many more
    classes that we have to learn.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will learn the most basic object types required in the
    majority of projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Vec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scalar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Point`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Size`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rect`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RotatedRect`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vec object type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Vec` is a template class mainly for numerical vectors. We can define any type
    of vector and the number of components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use any of the predefined types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'All the following vector operations are also implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1 = v2 + v3`'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1 = v2 - v3`'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1 = v2 * scale`'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1 = scale * v2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1 = -v2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1 += v2`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other augmenting operations implemented are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1 == v2, v1 != v2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`norm(v1) (euclidean norm)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Scalar object type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Scalar` object type is a template class derived from `Vec` with four elements.
    The `Scalar` type is widely used in OpenCV to pass and read pixel values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access `Vec` and `Scalar` values, we use the `[]` operator, which can be
    initialized from another scalar, vector, or value by value, as in the following
    sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Point object type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very common class template is `Point`. This class defines a 2D point
    specified by its coordinates `x` and `y`.
  prefs: []
  type: TYPE_NORMAL
- en: Like `Point`, there is a `Point3` template class for 3D point support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the `Vec` class, OpenCV defines the following `Point` aliases for our
    convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Size object type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another template class that is very important and widely used in OpenCV is
    the template class for specifying the size of an image or rectangle—`Size`. This
    class adds two members, width and height, and the useful `area()` function. In
    the following sample, we can see a number of ways of using size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Rect object type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Rect` is another important template class for defining 2D rectangles defined
    by the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The coordinates of the upper-left corner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The width and height of a rectangle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Rect` template class can be used to define a **region of interest** (**ROI**)
    of an image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: RotatedRect object type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last useful class is a particular rectangle called `RotatedRect`. This
    class represents a rotated rectangle specified by a center point, the width and
    height of a rectangle, and the rotation angle in degrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting function of this class is `boundingBox`. This function returns
    `Rect`, which contains the rotated rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41cc5cdd-ba17-4332-8a06-456a685c7664.png)'
  prefs: []
  type: TYPE_IMG
- en: Basic matrix operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn a number of basic and important matrix operations
    that we can apply to images or any matrix data. We learned how to load an image
    and store it in a `Mat` variable, but we can create `Mat` manually. The most common
    constructor is giving the matrix a size and type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create a new matrix linking with a stored buffer from third-party libraries
    without copying data using this constructor: `Mat(size, type, pointer_to_buffer)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The types supported depend on the type of number you want to store and the
    number of channels. The most common types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can create any type of matrix using `CV_number_typeC(n)`, where the `number_type`
    is 8 bits unsigned (8U) to 64 float (64F), and where `(n)` is the number of channels;
    the number of channels permitted ranges from `1` to `CV_CN_MAX`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initialization does not set up the data values, and hence you can get undesirable
    values. To avoid undesirable values, you can initialize the matrix with `0` or
    `1` values with their respective functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of the preceding matrix are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9060dc5f-9679-40b5-9c50-cb5169b7b9a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A special matrix initialization is the eye function that creates an identity
    matrix with the specified type and size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34066e0f-e427-405f-b8c2-5eb43384b04a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'All matrix operations are allowed in OpenCV''s `Mat` class. We can add or subtract
    two matrices of the same size using the `+` and `-` operators, as demonstrated
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of the preceding operations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8611f073-1b05-4c37-94be-bf1281099d44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can multiply by a scalar using the `*` operator or a matrix per element
    using the `mul` function, and we can perform matrix multiplication using the  `*`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of the preceding operations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/505d4ca1-d9a4-4a09-be73-4716a1eaea21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Other common mathematical matrix operations are **transposition** and **matrix
    inversion**, defined by the `t()` and `inv()` functions, respectively. Other interesting
    functions that OpenCV provides are array operations in matrix, for example, counting
    the nonzero elements. This is useful for counting the pixels or areas of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'OpenCV provides some statistical functions. Mean and standard deviation by
    channel can be calculated using the `meanStdDev` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful statistical function is `minMaxLoc`. This function finds the
    minimum and the maximum of a matrix or array, and returns the location and value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here `src` is the input matrix, `minVal` and `maxVal` are double values detected,
    and `minLoc` and `maxLoc` are `Point` values detected.
  prefs: []
  type: TYPE_NORMAL
- en: Other core and useful functions are described in detail at: [http://docs.opencv.org/modules/core/doc/core.html](https://docs.opencv.org/master/dc/d84/group__core__basic.html).
  prefs: []
  type: TYPE_NORMAL
- en: Basic data persistence and storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before finishing this chapter, we will explore the OpenCV functions to store
    and read our data. In many applications, such as calibration or machine learning,
    when we finish performing a number of calculations, we need to save these results
    to retrieve them in subsequent operations. OpenCV provides an XML/YAML persistence
    layer to this end.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to FileStorage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To write a file with some OpenCV or other numeric data, we can use the `FileStorage`
    class, using a streaming `<<` operator such as STL streaming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a file storage where we save the data, we only need to call the constructor,
    giving a path filename with the extension format desired (XML or YAML), and the
    second parameter set to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to save data, we only need to use the stream operator by giving
    an identifier in the first stage, and later the matrix or value that we want to
    save. For example, to save an `int` variable, we only have to write the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we can write/save `mat` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code is a YAML format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading from a file storage to read a file saved previously is very similar
    to the `save` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The first stage is to open a saved file with the `FileStorage` constructor
    using the appropriate parameters, path, and `FileStorage::READ`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To read any stored variable, we only need to use the common stream operator
    `>>` using our `FileStorage` object and the identifier with the `[]` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basics and the most important types and operations
    of OpenCV, access to images and videos, and how they are stored in matrices. We
    learned the basic matrix operations and other basic OpenCV classes to store pixels,
    vectors, and so on. Finally, we learned how to save our data in files to allow
    them to be read in other applications or other executions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to create our first application,
    learning the basics of graphical user interfaces that OpenCV provides. We will
    create buttons and sliders, and introduce some image processing basics.
  prefs: []
  type: TYPE_NORMAL
