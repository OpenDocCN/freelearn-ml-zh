- en: An Introduction to the Basics of OpenCV
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCV基础知识简介
- en: After covering OpenCV installation on different operating systems in [Chapter
    1](96b225d4-84bc-4d49-b8b3-079b15f05cf0.xhtml), *Getting Started with OpenCV*,
    we are going to introduce the basics of OpenCV development in this chapter. It
    begins with showing how to create our project using CMake. We are going to introduce
    the basic image data structures and matrices, along with other structures that
    are required to work in our projects. We are going to introduce how to save our
    variables and data into files using the XML/YAML persistence OpenCV functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](96b225d4-84bc-4d49-b8b3-079b15f05cf0.xhtml)“OpenCV入门”中介绍了在不同操作系统上安装OpenCV之后，我们将在本章介绍OpenCV开发的基础。它从展示如何使用CMake创建我们的项目开始。我们将介绍基本图像数据结构和矩阵，以及其他在我们项目中工作所需的结构。我们将介绍如何使用XML/YAML持久化的OpenCV函数将我们的变量和数据保存到文件中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Configuring projects with CMake
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CMake配置项目
- en: Reading/writing images from/to disk
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从/到磁盘读取/写入图像
- en: Reading videos and accessing camera devices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取视频和访问相机设备
- en: The main image structures (for example, matrices)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要图像结构（例如，矩阵）
- en: Other important and basic structures (for example, vectors and scalars)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他重要且基本的结构（例如，向量和标量）
- en: An introduction to basic matrix operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本矩阵运算简介
- en: File storage operations with XML/YAML persistence OpenCV API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XML/YAML持久化的OpenCV API进行文件存储操作
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires familiarity with the basic C++ programming language. All
    the code used in this chapter can be downloaded from the following GitHub link: [https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_02](https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_02). The
    code can be executed on any operating system, though it is only tested on Ubuntu.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求熟悉基本的C++编程语言。本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_02](https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_02)。代码可以在任何操作系统上执行，尽管它仅在Ubuntu上进行了测试。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：
- en: '[http://bit.ly/2QxhNBa](http://bit.ly/2QxhNBa)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2QxhNBa](http://bit.ly/2QxhNBa)'
- en: Basic CMake configuration file
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本CMake配置文件
- en: To configure and check all the requisite dependencies for our project, we are
    going to use CMake, but it is not the only way that this can be done; we can configure
    our project in any other tool or IDE, such as **Makefiles** or **Visual Studio**,
    but CMake is a more portable way to configure multiplatform **C++** projects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置和检查我们项目所需的所有依赖项，我们将使用CMake，但这不是唯一的方法；我们可以在任何其他工具或IDE中配置我们的项目，例如**Makefiles**或**Visual
    Studio**，但CMake是配置多平台**C++**项目的更便携方式。
- en: 'CMake uses configuration files called `CMakeLists.txt`, where the compilation
    and dependencies process is defined. For a basic project based on an executable
    built from a single source code file, a `CMakeLists.txt` file comprising three
    lines is all that is required. The file looks as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: CMake使用名为`CMakeLists.txt`的配置文件，其中定义了编译和依赖关系过程。对于一个基于单个源代码文件构建的可执行文件的基本项目，所需的`CMakeLists.txt`文件仅包含三行。文件看起来如下：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line defines the minimum version of CMake required. This line is mandatory
    in our `CMakeLists.txt` file and allows us to use the functionality of CMake defined from
    a specific version; in our case, we require a minimum of CMake 3.0\. The second
    line defines the project name. This name is saved in a variable called `PROJECT_NAME`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了所需的CMake最低版本。这一行在我们的`CMakeLists.txt`文件中是强制性的，它允许我们使用从特定版本定义的CMake功能；在我们的情况下，我们需要至少CMake
    3.0。第二行定义了项目名称。这个名称保存在一个名为`PROJECT_NAME`的变量中。
- en: The last line creates an executable command (`add_executable()`) from the `main.cpp`
    file, gives it the same name as our project (`${PROJECT_NAME}`), and compiles
    our source code into an executable called **CMakeTest** which is the name that
    we set up as a project name. The `${}` expression allows access to any variable
    defined in our environment. Then, we can use the `${PROJECT_NAME}` variable as
    an executable output name.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行从 `main.cpp` 文件创建一个可执行命令（`add_executable()`），将其命名为我们的项目（`${PROJECT_NAME}`），并将我们的源代码编译成一个名为
    **CMakeTest** 的可执行文件，这是我们设置的项目名称。`${}` 表达式允许访问我们环境中定义的任何变量。然后，我们可以使用 `${PROJECT_NAME}`
    变量作为可执行文件的输出名称。
- en: Creating a library
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建库
- en: CMake allows us to create libraries used by the OpenCV build system. Factorizing
    shared code among multiple applications is a common and useful practice in software
    development. In big applications, or common code shared in multiple applications,
    this practice is very useful. In this case, we do not create a binary executable,
    but instead we create a compiled file that includes all the functions, classes,
    and so on. We can then share this library file with other applications without
    sharing our source code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 允许我们创建由 OpenCV 构建系统使用的库。在软件开发中，将共享代码分解到多个应用程序中是一种常见且有用的实践。在大型应用程序或多个应用程序中共享的通用代码中，这种做法非常有用。在这种情况下，我们不会创建一个二进制可执行文件，而是创建一个包含所有函数、类等的编译文件。然后我们可以将这个库文件与其他应用程序共享，而无需共享我们的源代码。
- en: 'CMake includes the `add_library` function to this end:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 包含了 `add_library` 函数来实现这一点：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The lines starting with `#` add comments and are ignored by CMake. The `add_library` (`Hello
    hello.cpp hello.h`) command defines the source files of our library and its name,
    where `Hello` is the library name and `hello.cpp` and `hello.h` are the source
    files. We add the header file too to allow IDEs such as Visual Studio to link
    to the header files. This line is going to generate a shared (`.so` for Mac OS
    X, and Unix or `.dll` for Windows) or static library (`.a` for Mac OS X, and Unix
    or `.lib` for Windows) file, depending on whether we add a `SHARED` or `STATIC`
    word between library name and source files. `target_link_libraries(executable
    Hello)` is the function that links our executable to the desired library, in our
    case, the `Hello` library.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `#` 开头的行添加注释，并被 CMake 忽略。`add_library` (`Hello hello.cpp hello.h`) 命令定义了库的源文件及其名称，其中
    `Hello` 是库名称，`hello.cpp` 和 `hello.h` 是源文件。我们还添加了头文件，以便允许像 Visual Studio 这样的 IDE
    链接到头文件。这一行将根据我们是否在库名称和源文件之间添加 `SHARED` 或 `STATIC` 单词来生成共享（Mac OS X 的 `.so`、Unix
    或 Windows 的 `.dll`）或静态库（Mac OS X 的 `.a`、Unix 或 Windows 的 `.lib`）文件。`target_link_libraries(executable
    Hello)` 是将我们的可执行文件链接到所需库的函数，在我们的例子中，是 `Hello` 库。
- en: Managing dependencies
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理依赖项
- en: CMake has the ability to search our dependencies and external libraries, giving
    us the ability to build complex projects, depending on the external components
    in our projects, and add some requirements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 有能力搜索我们的依赖项和外部库，这使我们能够构建复杂的项目，根据项目中的外部组件添加一些需求。
- en: 'In this book, the most important dependency is, of course, OpenCV, and we will
    add it to all of our projects:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，最重要的依赖项当然是 OpenCV，我们将将其添加到所有我们的项目中：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s understand the working of the script from the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从以下内容了解脚本的运行机制：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first line defines the minimum CMake version, and the second line tells
    CMake to use the new behavior of CMake to facilitate recognition of the correct
    numbers and Boolean constants without dereferencing variables with such names;
    this policy was introduced in CMake 2.8.0, and CMake warns when the policy is
    not set from version 3.0.2\. Finally, the last line defines the project title.
    After defining the project name, we have to define the requirements, libraries,
    and dependencies:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了最低的 CMake 版本，第二行告诉 CMake 使用 CMake 的新行为来简化对正确数字和布尔常量的识别，而无需解引用具有此类名称的变量；此策略是在
    CMake 2.8.0 中引入的，从版本 3.0.2 开始，CMake 会警告当策略未设置时。最后，最后一行定义了项目标题。在定义项目名称后，我们必须定义需求、库和依赖项：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here is where we search for our OpenCV dependency. `FIND_PACKAGE` is the function
    that allows us to find our dependencies, the minimum version required, and whether
    this dependency is required or optional. In this sample script, we look for OpenCV
    in version 4.0.0 or greater and state that it is a required package.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们搜索 OpenCV 依赖项的地方。`FIND_PACKAGE` 是一个函数，允许我们查找依赖项、所需的最小版本以及此依赖项是必需的还是可选的。在这个示例脚本中，我们寻找版本
    4.0.0 或更高版本的 OpenCV，并声明这是一个必需的包。
- en: 'The `FIND_PACKAGE` command includes all OpenCV submodules, but you can specify
    the submodules that you want to include in the project by executing your application
    smaller and faster. For example, if we are only going to work with the basic OpenCV
    types and core functionality, we can use the following command: `FIND_PACKAGE(OpenCV
    4.0.0 REQUIRED core)`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`FIND_PACKAGE`命令包括所有OpenCV子模块，但你可以通过执行应用程序来指定你想要在项目中包含的子模块，使应用程序更小、更快。例如，如果我们只将使用基本的OpenCV类型和核心功能，我们可以使用以下命令：`FIND_PACKAGE(OpenCV
    4.0.0 REQUIRED core)`。'
- en: 'If CMake does not find it, it returns an error and does not prevent us from
    compiling our application. The `MESSAGE` function shows a message in the terminal
    or CMake GUI. In our case, we are showing the OpenCV version as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CMake找不到它，它会返回一个错误，但不会阻止我们编译我们的应用程序。`MESSAGE`函数在终端或CMake GUI中显示消息。在我们的例子中，我们如下显示OpenCV版本：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `${OpenCV_VERSION}` is a variable where CMake stores the OpenCV package
    version.  `include_directories()` and `link_directories()` add to our environment
    the headers and the directory of the specified library. OpenCV CMake''s module
    saves this data in the `${OpenCV_INCLUDE_DIRS}` and `${OpenCV_LIB_DIR}` variables.
    These lines are not required in all platforms, such as Linux, because these paths
    normally are in the environment, but it''s recommended to have more than one OpenCV
    version to choose the correct link and include directories. Now is the time to
    include our developed sources:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`${OpenCV_VERSION}`是一个变量，其中CMake存储OpenCV包的版本。`include_directories()`和`link_directories()`将指定的库的头文件和目录添加到我们的环境中。OpenCV
    CMake模块将这些数据保存到`${OpenCV_INCLUDE_DIRS}`和`${OpenCV_LIB_DIR}`变量中。这些行在所有平台上都不是必需的，例如Linux，因为这些路径通常在环境中，但建议有多个OpenCV版本以选择正确的链接和包含目录。现在是时候包含我们开发的源代码了：'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This last line creates the executable and links the executable with the OpenCV
    library, as we saw in the previous section, *Creating a library*. There is a new
    function in this piece of code, `SET`; this function creates a new variable and
    adds to it any value that we need. In our case, we incorporate the `main.cpp` value in
    the `SRC` variable. We can add more and more values to the same variable, as can
    be seen in the following script:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一行创建了可执行文件，并将其与OpenCV库链接起来，正如我们在上一节中看到的，*创建库*。在这段代码中有一个新函数`SET`；这个函数创建一个新变量并向其中添加任何我们需要的值。在我们的例子中，我们将`main.cpp`的值合并到`SRC`变量中。我们可以向同一个变量添加更多值，如下面的脚本所示：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Making the script more complex
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使脚本更加复杂
- en: In this section, we are showing a more complex script that includes subfolders,
    libraries, and executables; all told, just two files and a few lines, as demonstrated
    in this script. It's not mandatory to create multiple `CMakeLists.txt` files,
    because we can specify everything in the main `CMakeLists.txt` file. However,
    it is more common to use different `CMakeLists.txt` files for each project subfolder,
    thereby making it more flexible and portable.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了一个更复杂的脚本，该脚本包括子文件夹、库和可执行文件；总共只有两个文件和几行，如脚本所示。创建多个`CMakeLists.txt`文件不是强制性的，因为我们可以在主`CMakeLists.txt`文件中指定所有内容。然而，更常见的是为每个项目子文件夹使用不同的`CMakeLists.txt`文件，从而使它更加灵活和便携。
- en: 'This example has a code structure folder, which contains one folder for a `utils`
    library and the root folder, which contains the main executable:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例有一个代码结构文件夹，其中包含一个用于`utils`库的文件夹和根文件夹，其中包含主可执行文件：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we have to define two `CMakeLists.txt` files, one in the root folder
    and the other in the `utils` folder. The `CMakeLists.txt` root folder file has
    the following content:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须定义两个`CMakeLists.txt`文件，一个在根文件夹中，另一个在`utils`文件夹中。根文件夹的`CMakeLists.txt`文件包含以下内容：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Almost all lines are described in previous sections, except some functions which
    we will explain. `add_subdirectory()` tells CMake to analyze `CMakeLists.txt`
    of a desired subfolder. Before continuing with the main `CMakeLists.txt` file
    explanation, we are going to explain the `CMakeLists.txt` file in `utils`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有行都在前面的章节中有所描述，除了我们将解释的一些函数。`add_subdirectory()`告诉CMake分析所需子文件夹的`CMakeLists.txt`。在继续解释主`CMakeLists.txt`文件之前，我们将解释`utils`中的`CMakeLists.txt`文件。
- en: 'In the `CMakeLists.txt` file of the `utils` folders, we are going to write
    a new library to include in our main project folder:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`utils`文件夹的`CMakeLists.txt`文件中，我们将编写一个新的库并将其包含到我们的主项目文件夹中：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This CMake script file defines a variable, `UTILS_LIB_SRC`, where we add all
    source files included in our library, generate the library with the `add_library`
    function, and use the `target_include_directories` function to allow our main
    project to detect all header files. Leaving the `utils` subfolder and continuing
    with the root CMake script, the Option function creates a new variable, in our
    case `WITH_LOG`, with a small description attached. This variable could be changed
    through the `ccmake` command line or CMake GUI interface, where the description
    appears, and a check that allows users to enable or disable this option. This
    function is very useful for allowing the user to decide about compile-time features,
    such as whether we want enabling or disabling logs or not, compiling with Java
    or Python support, just as OpenCV does, and so on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此CMake脚本文件定义了一个变量`UTILS_LIB_SRC`，我们将所有包含在我们的库中的源文件添加到其中，使用`add_library`函数生成库，并使用`target_include_directories`函数允许我们的主项目检测所有头文件。在`utils`子文件夹中留下并继续使用根CMake脚本，`Option`函数创建了一个新变量，在我们的例子中是`WITH_LOG`，并附有一个简短的描述。这个变量可以通过`ccmake`命令行或CMake
    GUI界面进行更改，其中描述出现，并有一个检查框允许用户启用或禁用此选项。这个函数对于允许用户决定编译时特性非常有用，例如是否想要启用或禁用日志，是否编译带有Java或Python支持，就像OpenCV所做的那样，等等。
- en: 'In our case, we use this option to enable a logger in our application. To enable
    the logger, we use a pre-compiler definition in our code, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们使用此选项来在我们的应用程序中启用日志记录器。要启用日志记录器，我们在代码中使用预编译定义，如下所示：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This LOG macro can be defined in our `CMakeLists.txt` through a call to the
    `add_definitions` function (`-DLOG`), which itself can be run or hidden by the
    CMake variable `WITH_LOG` with a simple condition:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此LOG宏可以通过对`add_definitions`函数的调用（`-DLOG`）在`CMakeLists.txt`中定义，该函数本身可以通过CMake变量`WITH_LOG`通过简单条件来运行或隐藏：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now we are ready to create our CMake script files to compile our computer vision
    projects in any operating system. Then, we are going to continue with the OpenCV
    basics before starting with a sample project.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建我们的CMake脚本文件，以便在任何操作系统上编译我们的计算机视觉项目。然后，我们将继续介绍OpenCV的基础知识，然后再开始一个示例项目。
- en: Images and matrices
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像和矩阵
- en: 'The most important structure in computer vision is, without doubt, the images.
    The image in a computer vision is the representation of the physical world captured
    with a digital device. This picture is only a sequence of numbers stored in a
    matrix format (refer to the following diagram). Each number is a measurement of
    the light intensity for the considered wavelength (for example, red, green, or
    blue in color images) or for a wavelength range (for panchromatic devices). Every
    point in an image is called a **pixel** (for a picture element), and each pixel
    can store one or more values depending on whether it is a black and white image
    (also referred to as a binary image) that stores only one value, such as `0` or
    `1`, a grayscale-level image that stores two values, or a color image that stores
    three values. These values are usually between `0` and `255` in an integer number,
    but you can use other ranges, for example `0` to `1` in floating point numbers,
    as in **h****igh dynamic range imaging** (**HDRI**) or thermal images:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机视觉中，无疑最重要的是图像结构。计算机视觉中的图像是使用数字设备捕获的物理世界的表示。这幅图只是一个存储在矩阵格式中的数字序列（参见图示）。每个数字是考虑的波长的光强度测量（例如，彩色图像中的红色、绿色或蓝色）或波长范围（对于全色设备）。图像中的每个点称为一个**像素**（对于图像元素），每个像素可以存储一个或多个值，具体取决于它是否是只存储一个值（如`0`或`1`）的黑白图像（也称为二值图像），灰度级图像存储两个值，或彩色图像存储三个值。这些值通常在整数中介于`0`和`255`之间，但您可以使用其他范围，例如在浮点数中使用`0`到`1`，如在**高动态范围成像**（**HDRI**）或热图像中：
- en: '![](img/b3fbe085-1348-4509-b06e-19b81bd90ff2.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b3fbe085-1348-4509-b06e-19b81bd90ff2.png)'
- en: 'The image is stored in a matrix format, where each pixel has a position in
    it and can be referenced by the number of the column and row. OpenCV uses the
    `Mat` class for this purpose. In the case of a grayscale image, a single matrix
    is used, as demonstrated in the following diagram:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图像以矩阵格式存储，其中每个像素都有一个位置，可以通过列和行的编号来引用。OpenCV使用`Mat`类来完成这个目的。对于灰度图像，使用单个矩阵，如下面的图示所示：
- en: '![](img/3eaa7307-485b-4c00-920c-214e393189f5.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3eaa7307-485b-4c00-920c-214e393189f5.png)'
- en: 'In the case of a color image, such as the following diagram, we use a matrix
    of width x height x the number of color channels:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在彩色图像的情况下，例如以下图示，我们使用宽度 x 高度 x 颜色通道数的矩阵：
- en: '![](img/0e7d1b24-152c-4bd4-a135-a25dab51c9af.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e7d1b24-152c-4bd4-a135-a25dab51c9af.png)'
- en: But the `Mat` class is not only for storing images; it also enables you to store
    any type of matrix and different sizes. You can use it as an algebraic matrix
    and perform operations with it. In the following sections, we are going to describe
    the most important matrix operations, such as addition,  multiplication, diagonalization.
    But, before that, it's important to know how the matrix is stored internally in
    the computer memory, because it is always more efficient to access the memory
    slots instead of accessing each pixel with the OpenCV functions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但`Mat`类不仅用于存储图像；它还允许您存储任何类型的矩阵和不同的大小。您可以使用它作为代数矩阵，并对其进行操作。在接下来的章节中，我们将描述最重要的矩阵操作，如加法、乘法、对角化。但在那之前，了解矩阵在计算机内存中的内部存储方式是很重要的，因为始终访问内存槽比使用OpenCV函数访问每个像素更有效。
- en: 'In memory, the matrix is saved as an array or sequence of values ordered by
    columns and rows. The following table shows the sequence of pixels in **BGR**
    image format:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，矩阵按列和行的顺序保存为一个数组或值序列。以下表格显示了**BGR**图像格式中像素的顺序：
- en: '| Row 0 | Row 1 | Row 2 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 行 0 | 行 1 | 行 2 |'
- en: '| Col 0 | Col 1 | Col 2 | Col 0 | Col 1 | Col 2 | Col 0 | Col 1 | Col 2 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 列 0 | 列 1 | 列 2 | 列 0 | 列 1 | 列 2 | 列 0 | 列 1 | 列 2 |'
- en: '| Pixel  1 | Pixel 2 | Pixel 3 | Pixel 4 | Pixel 5 | Pixel 6 | Pixel 7 | Pixel
    8 | Pixel 9 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 像素 1 | 像素 2 | 像素 3 | 像素 4 | 像素 5 | 像素 6 | 像素 7 | 像素 8 | 像素 9 |'
- en: '| B | G | R | B | G | R | B | G | R | B | G | R | B | G | R | B | G | R | B
    | G | R | B | G | R | B | G | R |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| B | G | R | B | G | R | B | G | R | B | G | R | B | G | R | B | G | R | B
    | G | R | B | G | R | B | G | R |'
- en: 'With this order, we can access any pixel by observing the following formula:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个顺序，我们可以通过观察以下公式来访问任何像素：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: OpenCV functions are quite optimized for random access, but sometimes, direct
    access to the memory (work with pointer arithmetic) is more efficient, for example,
    when we have to access all pixels in a loop.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV函数在随机访问方面进行了相当优化，但有时，直接访问内存（使用指针算术）会更高效，例如，当我们需要在循环中访问所有像素时。
- en: Reading/writing images
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取/写入图像
- en: 'Following the introduction to matrices, we are going to start with the OpenCV
    code basics. The first thing that we have to learn is how to read and write images:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍矩阵之后，我们将从OpenCV代码基础开始。我们首先必须学习的是如何读取和写入图像：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s now move on to understanding the code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在继续理解代码：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First, we have to include the declarations of the functions that we need in
    our sample. These functions come from `core` (basic image data handling) and `highgui`
    (cross-platform I/O functions provided by OpenCV are `core` and `highui;`; the
    first includes the basic classes, such as matrices, while the second includes
    the functions to read, write, and show images with graphical interfaces). Now
    it is time to read images:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须包含我们样本中需要的函数的声明。这些函数来自`core`（基本图像数据处理）和`highgui`（OpenCV提供的跨平台I/O函数是`core`和`highui`；第一个包含基本类，如矩阵，而第二个包含读取、写入和通过图形界面显示图像的函数）。现在是我们读取图像的时候了：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`imread` is the main function for reading images. This function opens an image
    and stores it in a matrix format. `imread` accepts two parameters. The first parameter
    is a string containing the image''s path, while the second is optional and, by
    default, loads the image as a color image. The second parameter allows the following
    options:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`imread`是读取图像的主要函数。此函数打开图像并将其存储为矩阵格式。`imread`接受两个参数。第一个参数是包含图像路径的字符串，而第二个参数是可选的，默认情况下，将图像加载为彩色图像。第二个参数允许以下选项：'
- en: '`cv::IMREAD_UNCHANGED`: If set, this returns a 16-bit/32-bit image when the
    input has the corresponding depth, otherwise it converts it to 8-bit'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv::IMREAD_UNCHANGED`: 如果设置，当输入具有相应的深度时，返回16位/32位图像，否则将其转换为8位'
- en: '`cv::IMREAD_COLOR`: If set, this always converts an image to a color one (BGR,
    8-bit unsigned)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv::IMREAD_COLOR`: 如果设置，始终将图像转换为彩色图像（BGR，8位无符号）'
- en: '`cv::IMREAD_GRAYSCALE`: If set, this always converts an image to a grayscale
    one (8-bit unsigned)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv::IMREAD_GRAYSCALE`: 如果设置，始终将图像转换为灰度图像（8位无符号）'
- en: 'To save images, we can use the `imwrite` function, which stores a matrix image
    in our computer:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存图像，我们可以使用`imwrite`函数，该函数将矩阵图像存储在我们的计算机上：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first parameter is the path where we want to save the image with the extension
    format that we desire. The second parameter is the matrix image that we want to
    save. In our code sample, we create and store a gray version of the image and
    then save it as a `.jpg` file. The gray image that we loaded will be stored in
    the gray variable:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们想要保存图像的路径，以及我们想要的扩展格式。第二个参数是我们想要保存的矩阵图像。在我们的代码示例中，我们创建并存储图像的灰度版本，然后将其保存为`.jpg`文件。我们加载的灰度图像将被存储在`gray`变量中：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using the `.cols` and `.rows` attributes of a matrix, we can get access to
    the number of columns and rows in an image, or, in other words, the width and
    height:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矩阵的`.cols`和`.rows`属性，我们可以获取图像中的列数和行数，换句话说，宽度和高度：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To access one pixel of the image, we use the template function `cv::Mat::at<typename
    t>(row,col)` from the `Mat` OpenCV class. The template parameter is the desired
    return type. A type name in an 8-bit color image is a `Vec3b` class that stores
    three unsigned char data (Vec = vector, 3 = number of components, and b = 1 byte).
    In the case of the gray image, we can directly use the unsigned character, or
    any other number format used in the image, such as `uchar pixel= color.at<uchar>(myRow,
    myCol)`. Finally, in order to show the images, we can use the `imshow` function,
    which creates a window with a title as a first parameter and the image matrix
    as a second parameter:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问图像中的一个像素，我们使用`Mat` OpenCV类的模板函数`cv::Mat::at<typename t>(row,col)`。模板参数是期望的返回类型。在8位彩色图像中，类型名是一个存储三个无符号字符数据的`Vec3b`类（Vec
    = vector，3 = component数量，b = 1字节）。在灰度图像的情况下，我们可以直接使用无符号字符，或者使用图像中使用的任何其他数字格式，例如`uchar
    pixel= color.at<uchar>(myRow, myCol)`。最后，为了显示图像，我们可以使用`imshow`函数，该函数以标题作为第一个参数，以图像矩阵作为第二个参数创建一个窗口：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If we want to stop the application from waiting, we can use the OpenCV function
    `waitKey`, with a parameter of the number of milliseconds we want to wait for
    a key press. If we set up the parameter to `0`, then the function will wait until
    a key is pressed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要停止应用程序等待，我们可以使用OpenCV函数`waitKey`，该函数有一个参数，表示我们希望等待多少毫秒来等待按键。如果我们将参数设置为`0`，那么函数将一直等待直到按键被按下。
- en: 'The result of the preceding code is demonstrated in the following image. The
    left-hand image is a color image, and the right-hand image is a grayscale image:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果在以下图像中展示。左侧图像是彩色图像，右侧图像是灰度图像：
- en: '![](img/34f29b0b-0443-4a78-8b77-a21936798f0a.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34f29b0b-0443-4a78-8b77-a21936798f0a.png)'
- en: Finally, by way of an example for the following samples, we are going to create
    the `CMakeLists.txt` file and see how to compile the code using the file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为以下示例的示例，我们将创建`CMakeLists.txt`文件，并查看如何使用该文件编译代码。
- en: 'The following code describes the `CMakeLists.txt` file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码描述了`CMakeLists.txt`文件：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To compile our code using this `CMakeLists.txt` file, we have to carry out the
    following steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此`CMakeLists.txt`文件编译我们的代码，我们必须执行以下步骤：
- en: Create a `build` folder.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`build`文件夹。
- en: Inside the `build` folder, execute CMake or open CMake GUI app in Windows, choose
    the `source` and `build` folders, and press the Configure and Generate buttons.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build`文件夹中，在Windows上执行CMake或打开CMake GUI应用程序，选择`source`和`build`文件夹，然后按下“Configure”和“Generate”按钮。
- en: If you are on Linux or macOS, generate a Makefile as usual, and then compile
    the project using the `make` command. If you are on Windows, open the project
    using the editor selected in step 2 and then compile.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用Linux或macOS，像往常一样生成Makefile，然后使用`make`命令编译项目。如果你使用Windows，使用步骤2中选择的编辑器打开项目，然后编译。
- en: Finally, after compiling our application, we will have an executable called
    `app` in the build folder that we can execute.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在编译我们的应用程序后，我们将在`build`文件夹中有一个名为`app`的可执行文件，我们可以执行它。
- en: Reading videos and cameras
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取视频和摄像头
- en: 'This section introduces you to video and camera reading using this simple example.
    Before explaining how to read videos or camera input, we want to introduce a new,
    very useful class that helps us to manage the input command-line parameters. This
    new class was introduced in OpenCV version 3.0, and is the `CommandLineParser`
    class:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本节通过这个简单的示例向您介绍视频和摄像头读取。在解释如何读取视频或摄像头输入之前，我们想要介绍一个新且非常有用的类，该类帮助我们管理输入命令行参数。这个新类是在OpenCV版本3.0中引入的，即`CommandLineParser`类：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first thing that we have to do for `CommandLineParser` is define what parameters
    we need or allow in a constant `char` vector; each line has the following pattern:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`CommandLineParser`，我们首先要做的是在常量`char`向量中定义我们需要的或允许的参数；每一行都有以下模式：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`name_param` can be preceded with `@`, which defines this parameter as a default
    input. We can use more than one `name_param`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`name_param`可以前面加上`@`，这定义了这个参数为默认输入。我们可以使用多个`name_param`：'
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The constructor will get the inputs of the main function and the key constants
    defined previously:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将获取主函数的输入和之前定义的关键常量：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `.has` class method checks the existence of the parameter. In the sample,
    we check whether the user adds the parameter `help` or `?`, and then use the class
    function `printMessage` to show all the description parameters:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`.has`类方法检查参数的存在。在示例中，我们检查用户是否添加了参数`help`或`?`，然后使用类函数`printMessage`显示所有描述参数：'
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the `.get<typename>(parameterName)` function, we can access and read any
    of input parameters:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.get<typename>(parameterName)`函数，我们可以访问和读取任何输入参数：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After obtaining all the requisite parameters, we can check whether these parameters
    are parsed correctly and show an error message if one of the parameters was not
    parsed, for example, add a string instead of a number:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得所有必需的参数后，我们可以检查这些参数是否正确解析，如果其中一个参数没有被解析，例如，添加一个字符串而不是一个数字，则显示错误信息：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The class for video reading and camera reading is the same: the `VideoCapture`
    class that belongs to the `videoio` submodule instead of the `highgui` submodule,
    as in the previous version of OpenCV. After creating the object, we check whether
    the input command-line parameter `videoFile` has a path filename. If it''s empty,
    then we try to open a web camera; if it has a filename, then open the video file.
    To do this, we use the `open` function, giving as a parameter the video filename
    or the index camera that we want to open. If we have a single camera, we can use
    `0` as a parameter.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 视频读取和摄像头读取的类是相同的：使用属于`videoio`子模块的`VideoCapture`类，而不是像OpenCV前一个版本中那样使用`highgui`子模块。创建对象后，我们检查输入的命令行参数`videoFile`是否包含路径文件名。如果它是空的，那么我们尝试打开一个网络摄像头；如果包含文件名，则打开视频文件。为此，我们使用`open`函数，将视频文件名或我们想要打开的摄像头索引作为参数。如果我们只有一个摄像头，我们可以使用`0`作为参数。
- en: 'To check whether we can read the video filename or the camera, we use the `isOpened`
    function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查我们是否可以读取视频文件名或摄像头，我们使用`isOpened`函数：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finally, we create a window to show the frames with the `namedWindow` function
    and, with an infinite loop, we grab each frame using the `>>` operation and show
    the frame with the `imshow` function if we retrieve the frame correctly. In this
    case, we don't want to stop the application, but will wait 30 milliseconds to
    check whether any users want to stop the application execution with any key using
    `waitKey(30)`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`namedWindow`函数创建一个窗口来显示帧，并通过无限循环使用`>>`操作符抓取每一帧，如果正确检索到帧，则使用`imshow`函数显示帧。在这种情况下，我们不希望停止应用程序，而是等待30毫秒以检查是否有用户想要通过按任何键来停止应用程序的执行，使用`waitKey(30)`。
- en: The time required to wait for the next frame using camera access is calculated
    from the camera speed and our spent algorithm time. For example, if a camera works
    at 20 fps, and our algorithm spent 10 milliseconds, a great waiting value is *30*
    = (*1000*/*20*) - *10* milliseconds. This value is calculated considering a wait
    of a sufficient amount of time to ensure that the next frame is in the buffer.
    If our camera takes 40 milliseconds to take each image, and we use 10 milliseconds
    in our algorithm, then we only need to stop with waitKey 30 milliseconds, because
    30 milliseconds of wait time, plus 10 milliseconds of our algorithm, is the same
    amount of time for which each frame of the camera is accessible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用摄像头访问等待下一帧所需的时间是从摄像头速度和我们的算法消耗时间计算得出的。例如，如果一个摄像头以20 fps的速度工作，而我们的算法消耗了10毫秒，一个很大的等待值是*30*
    = (*1000*/*20*) - *10*毫秒。这个值是在考虑了足够的时间等待以确保下一帧在缓冲区中的情况下计算的。如果我们的摄像头需要40毫秒来捕捉每一张图像，而我们算法中使用了10毫秒，那么我们只需要使用`waitKey`停止30毫秒，因为30毫秒的等待时间加上我们算法中的10毫秒，与摄像头每一帧可访问的时间相同。
- en: When the user wants to finish the application, all they have to do is press
    any key and then we have to release all video resources using the release function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户想要结束应用程序时，他们只需要按任何键，然后我们必须使用`release`函数释放所有视频资源。
- en: It is very important to release all resources that we use in a computer vision
    application. If we do not, we can consume all RAM memory. We can release the matrices
    using the `release` function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机视觉应用程序中释放我们使用的所有资源非常重要。如果不这样做，我们可能会消耗所有RAM内存。我们可以使用`release`函数释放矩阵。
- en: The result of the previous code is a new window showing a video or web camera
    in BGR format.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的结果是一个新窗口，显示 BGR 格式的视频或网络摄像头。
- en: Other basic object types
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他基本对象类型
- en: We have learned about the `Mat` and `Vec3b` classes, but there are many more
    classes that we have to learn.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了 `Mat` 和 `Vec3b` 类，但还有许多其他类我们必须学习。
- en: 'In this section, we will learn the most basic object types required in the
    majority of projects:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习在大多数项目中所需的最基本的对象类型：
- en: '`Vec`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vec`'
- en: '`Scalar`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scalar`'
- en: '`Point`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Point`'
- en: '`Size`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`大小`'
- en: '`Rect`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rect`'
- en: '`RotatedRect`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RotatedRect`'
- en: Vec object type
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Vec` 对象类型'
- en: '`Vec` is a template class mainly for numerical vectors. We can define any type
    of vector and the number of components:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vec` 是一个主要用于数值向量的模板类。我们可以定义任何类型的向量及其组件数量：'
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can also use any of the predefined types:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用任何预定义的类型：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'All the following vector operations are also implemented:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的以下向量运算也都已实现：
- en: '`v1 = v2 + v3`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 = v2 + v3`'
- en: '`v1 = v2 - v3`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 = v2 - v3`'
- en: '`v1 = v2 * scale`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 = v2 * scale`'
- en: '`v1 = scale * v2`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 = scale * v2`'
- en: '`v1 = -v2`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 = -v2`'
- en: '`v1 += v2`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 += v2`'
- en: 'Other augmenting operations implemented are the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的其他增强操作如下：
- en: '`v1 == v2, v1 != v2`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 == v2, v1 != v2`'
- en: '`norm(v1) (euclidean norm)`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`norm(v1) (欧几里得范数)`.'
- en: Scalar object type
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Scalar` 对象类型'
- en: The `Scalar` object type is a template class derived from `Vec` with four elements.
    The `Scalar` type is widely used in OpenCV to pass and read pixel values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scalar` 对象类型是从 `Vec` 派生出的模板类，具有四个元素。`Scalar` 类型在 OpenCV 中被广泛用于传递和读取像素值。'
- en: 'To access `Vec` and `Scalar` values, we use the `[]` operator, which can be
    initialized from another scalar, vector, or value by value, as in the following
    sample:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 `Vec` 和 `Scalar` 值，我们使用 `[]` 操作符，它可以从另一个标量、向量或值初始化，如下面的示例所示：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Point object type
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点对象类型
- en: Another very common class template is `Point`. This class defines a 2D point
    specified by its coordinates `x` and `y`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常常见的类模板是 `Point`。这个类定义了一个由坐标 `x` 和 `y` 指定的 2D 点。
- en: Like `Point`, there is a `Point3` template class for 3D point support.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Point` 类似，还有一个 `Point3` 模板类用于 3D 点支持。
- en: 'Like the `Vec` class, OpenCV defines the following `Point` aliases for our
    convenience:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Vec` 类类似，OpenCV 为我们的方便定义了以下 `Point` 别名：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Size object type
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Size` 对象类型'
- en: 'Another template class that is very important and widely used in OpenCV is
    the template class for specifying the size of an image or rectangle—`Size`. This
    class adds two members, width and height, and the useful `area()` function. In
    the following sample, we can see a number of ways of using size:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要且在 OpenCV 中广泛使用的模板类是用于指定图像或矩形大小的模板类——`Size`。这个类添加了两个成员，宽度和高度，以及有用的 `area()`
    函数。在下面的示例中，我们可以看到使用大小的多种方法：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Rect object type
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Rect` 对象类型'
- en: '`Rect` is another important template class for defining 2D rectangles defined
    by the following parameters:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rect` 是另一个重要的模板类，用于定义由以下参数指定的 2D 矩形：'
- en: The coordinates of the upper-left corner
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上角坐标
- en: The width and height of a rectangle
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩形的宽度和高度
- en: 'The `Rect` template class can be used to define a **region of interest** (**ROI**)
    of an image, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rect` 模板类可以用来定义图像的 **感兴趣区域**（**ROI**），如下所示：'
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: RotatedRect object type
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`RotatedRect` 对象类型'
- en: 'The last useful class is a particular rectangle called `RotatedRect`. This
    class represents a rotated rectangle specified by a center point, the width and
    height of a rectangle, and the rotation angle in degrees:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个有用的类是一个特定的矩形，称为 `RotatedRect`。这个类表示一个由中心点、矩形的宽度和高度以及旋转角度（以度为单位）指定的旋转矩形：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'An interesting function of this class is `boundingBox`. This function returns
    `Rect`, which contains the rotated rectangle:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的一个有趣的功能是 `boundingBox`。这个函数返回一个包含旋转矩形的 `Rect`：
- en: '![](img/41cc5cdd-ba17-4332-8a06-456a685c7664.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41cc5cdd-ba17-4332-8a06-456a685c7664.png)'
- en: Basic matrix operations
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本矩阵运算
- en: 'In this section, we will learn a number of basic and important matrix operations
    that we can apply to images or any matrix data. We learned how to load an image
    and store it in a `Mat` variable, but we can create `Mat` manually. The most common
    constructor is giving the matrix a size and type, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习许多基本且重要的矩阵运算，这些运算可以应用于图像或任何矩阵数据。我们学习了如何加载图像并将其存储在 `Mat` 变量中，但我们也可以手动创建
    `Mat`。最常见的构造函数是给矩阵指定大小和类型，如下所示：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can create a new matrix linking with a stored buffer from third-party libraries
    without copying data using this constructor: `Mat(size, type, pointer_to_buffer)`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此构造函数创建一个新矩阵，该矩阵通过第三方库的存储缓冲区链接，而不需要复制数据：`Mat(size, type, pointer_to_buffer)`。
- en: 'The types supported depend on the type of number you want to store and the
    number of channels. The most common types are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的类型取决于您想要存储的数字类型和通道数。最常见类型如下：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can create any type of matrix using `CV_number_typeC(n)`, where the `number_type`
    is 8 bits unsigned (8U) to 64 float (64F), and where `(n)` is the number of channels;
    the number of channels permitted ranges from `1` to `CV_CN_MAX`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `CV_number_typeC(n)` 创建任何类型的矩阵，其中 `number_type` 是 8 位无符号 (8U) 到 64 位浮点
    (64F)，并且 `(n)` 是通道数；允许的通道数范围从 `1` 到 `CV_CN_MAX`。
- en: 'The initialization does not set up the data values, and hence you can get undesirable
    values. To avoid undesirable values, you can initialize the matrix with `0` or
    `1` values with their respective functions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化不会设置数据值，因此您可能会得到不希望的结果。为了避免不希望的结果，您可以使用各自的函数用 `0` 或 `1` 值初始化矩阵：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The results of the preceding matrix are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 前面矩阵的结果如下：
- en: '![](img/9060dc5f-9679-40b5-9c50-cb5169b7b9a3.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9060dc5f-9679-40b5-9c50-cb5169b7b9a3.png)'
- en: 'A special matrix initialization is the eye function that creates an identity
    matrix with the specified type and size:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的矩阵初始化是 eye 函数，它使用指定的类型和大小创建一个单位矩阵：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/34066e0f-e427-405f-b8c2-5eb43384b04a.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34066e0f-e427-405f-b8c2-5eb43384b04a.png)'
- en: 'All matrix operations are allowed in OpenCV''s `Mat` class. We can add or subtract
    two matrices of the same size using the `+` and `-` operators, as demonstrated
    in the following code block:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 的 `Mat` 类允许所有矩阵操作。我们可以使用 `+` 和 `-` 运算符添加或减去相同大小的两个矩阵，如下面的代码块所示：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The results of the preceding operations are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 前面操作的结果如下：
- en: '![](img/8611f073-1b05-4c37-94be-bf1281099d44.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8611f073-1b05-4c37-94be-bf1281099d44.png)'
- en: 'We can multiply by a scalar using the `*` operator or a matrix per element
    using the `mul` function, and we can perform matrix multiplication using the  `*`
    operator:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `*` 运算符乘以一个标量，或者使用 `mul` 函数按元素乘以一个矩阵，并且我们可以使用 `*` 运算符执行矩阵乘法：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The results of the preceding operations are as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前面操作的结果如下：
- en: '![](img/505d4ca1-d9a4-4a09-be73-4716a1eaea21.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/505d4ca1-d9a4-4a09-be73-4716a1eaea21.png)'
- en: 'Other common mathematical matrix operations are **transposition** and **matrix
    inversion**, defined by the `t()` and `inv()` functions, respectively. Other interesting
    functions that OpenCV provides are array operations in matrix, for example, counting
    the nonzero elements. This is useful for counting the pixels or areas of objects:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见的数学矩阵操作是 **转置** 和 **矩阵求逆**，分别由 `t()` 和 `inv()` 函数定义。OpenCV 提供的其他有趣的功能包括矩阵中的数组操作，例如计算非零元素的数量。这对于计算对象的像素或面积很有用：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'OpenCV provides some statistical functions. Mean and standard deviation by
    channel can be calculated using the `meanStdDev` function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 提供了一些统计函数。可以使用 `meanStdDev` 函数计算按通道的均值和标准差：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Another useful statistical function is `minMaxLoc`. This function finds the
    minimum and the maximum of a matrix or array, and returns the location and value:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的统计函数是 `minMaxLoc`。此函数找到矩阵或数组的最小值和最大值，并返回位置和值：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here `src` is the input matrix, `minVal` and `maxVal` are double values detected,
    and `minLoc` and `maxLoc` are `Point` values detected.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里 `src` 是输入矩阵，`minVal` 和 `maxVal` 是检测到的双精度值，而 `minLoc` 和 `maxLoc` 是检测到的 `Point`
    值。
- en: Other core and useful functions are described in detail at: [http://docs.opencv.org/modules/core/doc/core.html](https://docs.opencv.org/master/dc/d84/group__core__basic.html).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其他核心和有用的函数在以下位置有详细描述：[http://docs.opencv.org/modules/core/doc/core.html](https://docs.opencv.org/master/dc/d84/group__core__basic.html)。
- en: Basic data persistence and storage
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本数据持久化和存储
- en: Before finishing this chapter, we will explore the OpenCV functions to store
    and read our data. In many applications, such as calibration or machine learning,
    when we finish performing a number of calculations, we need to save these results
    to retrieve them in subsequent operations. OpenCV provides an XML/YAML persistence
    layer to this end.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章之前，我们将探索 OpenCV 中用于存储和读取数据的函数。在许多应用中，例如校准或机器学习，当我们完成一系列计算后，我们需要将这些结果保存起来，以便在后续操作中检索。为此，OpenCV
    提供了一个 XML/YAML 持久化层。
- en: Writing to FileStorage
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入到 FileStorage
- en: 'To write a file with some OpenCV or other numeric data, we can use the `FileStorage`
    class, using a streaming `<<` operator such as STL streaming:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一些 OpenCV 或其他数值数据写入文件，我们可以使用 `FileStorage` 类，使用类似于 STL 流的流式 `<<` 运算符：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To create a file storage where we save the data, we only need to call the constructor,
    giving a path filename with the extension format desired (XML or YAML), and the
    second parameter set to write:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个保存数据的文件存储，我们只需要调用构造函数，提供一个带有所需扩展格式（XML或YAML）的路径文件名，并将第二个参数设置为写入：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we want to save data, we only need to use the stream operator by giving
    an identifier in the first stage, and later the matrix or value that we want to
    save. For example, to save an `int` variable, we only have to write the following
    lines of code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要保存数据，我们只需要在第一阶段提供一个标识符，然后使用流操作符来保存我们想要保存的矩阵或值。例如，要保存一个`int`变量，我们只需要写下以下几行代码：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Otherwise, we can write/save `mat` as shown:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们可以像下面这样写入/保存`mat`：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The result of the preceding code is a YAML format:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果是YAML格式：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Reading from a file storage to read a file saved previously is very similar
    to the `save` functions:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件存储中读取以读取先前保存的文件与`save`函数非常相似：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The first stage is to open a saved file with the `FileStorage` constructor
    using the appropriate parameters, path, and `FileStorage::READ`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段是使用`FileStorage`构造函数打开一个保存的文件，使用适当的参数，路径，以及`FileStorage::READ`：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To read any stored variable, we only need to use the common stream operator
    `>>` using our `FileStorage` object and the identifier with the `[]` operator:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取任何已存储的变量，我们只需要使用常见的流操作符`>>`，通过我们的`FileStorage`对象和带有`[]`操作符的标识符：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the basics and the most important types and operations
    of OpenCV, access to images and videos, and how they are stored in matrices. We
    learned the basic matrix operations and other basic OpenCV classes to store pixels,
    vectors, and so on. Finally, we learned how to save our data in files to allow
    them to be read in other applications or other executions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了OpenCV的基础知识、最重要的类型和操作，图像和视频的访问，以及它们如何在矩阵中存储。我们学习了基本的矩阵操作和其他基本的OpenCV类，用于存储像素、向量等。最后，我们学习了如何将我们的数据保存到文件中，以便在其他应用程序或其他执行中读取。
- en: In the next chapter, we are going to learn how to create our first application,
    learning the basics of graphical user interfaces that OpenCV provides. We will
    create buttons and sliders, and introduce some image processing basics.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何创建我们的第一个应用程序，了解OpenCV提供的图形用户界面的基础知识。我们将创建按钮和滑块，并介绍一些图像处理的基本知识。
