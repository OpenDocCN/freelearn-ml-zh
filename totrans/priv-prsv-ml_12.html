<html><head></head><body>
<div id="_idContainer114" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-150"><a id="_idTextAnchor158" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-151" class="calibre5"><a id="_idTextAnchor159" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.2.1">Homomorphic Encryption and Secure Multiparty Computation</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Homomorphic encryption is a cryptographic technique that allows computation on encrypted data without decrypting it. </span><span class="kobospan" id="kobo.3.2">It has the potential to revolutionize data privacy and security, enabling the secure computation of sensitive data without revealing the data itself. </span><span class="kobospan" id="kobo.3.3">In this chapter, you will learn about homomorphic encryption and secure </span><span><span class="kobospan" id="kobo.4.1">multiparty computation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">We will cover the following main topics in </span><span><span class="kobospan" id="kobo.6.1">this chapter:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.7.1">Encryption, anonymization, </span><span><span class="kobospan" id="kobo.8.1">and de-identification</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.9.1">Homomorphic encryption and the </span><span><span class="kobospan" id="kobo.10.1">mathematics behind</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.11.1">Open source Python frameworks for homomorphic encryption and </span><span><span class="kobospan" id="kobo.12.1">Paillier schemes</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.13.1">Machine learning using homomorphic </span><span><span class="kobospan" id="kobo.14.1">encryption (HE)</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.15.1">Federated learning with </span><strong class="bold"><span class="kobospan" id="kobo.16.1">Partially homomorphic </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.17.1">encryption</span></strong></span><span> </span><span><strong class="bold"><span class="kobospan" id="kobo.18.1">PHE</span></strong></span></li><li class="calibre11"><span class="kobospan" id="kobo.19.1">Limitations of </span><span><span class="kobospan" id="kobo.20.1">homomorphic encryption</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.21.1">Secure Multiparty Computation</span></strong><span class="kobospan" id="kobo.22.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.23.1">SMC</span></strong><span class="kobospan" id="kobo.24.1">) and its </span><span><span class="kobospan" id="kobo.25.1">use cases</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.26.1">A use case implementation using the </span><strong class="bold"><span class="kobospan" id="kobo.27.1">Private Set Interaction</span></strong><span class="kobospan" id="kobo.28.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.29.1">PSI</span></strong><span class="kobospan" id="kobo.30.1">) </span><span><span class="kobospan" id="kobo.31.1">SMC technique</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.32.1">A high-level overview of </span><span><span class="kobospan" id="kobo.33.1">zero-knowledge proofs</span></span></li>
</ul>
<h1 id="_idParaDest-152" class="calibre5"><a id="_idTextAnchor160" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.34.1">Encryption, anonymization, and de-identification</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.35.1">Encryption, anonymization, and de-identification are all techniques used to protect sensitive data, but they differ in their approach </span><span><span class="kobospan" id="kobo.36.1">and limitations.</span></span></p>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.37.1">Encryption</span></strong></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.38.1">Encryption is the process </span><a id="_idIndexMarker744" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.39.1">of transforming data into a form that can only be read by authorized parties with access to a decryption key. </span><span class="kobospan" id="kobo.39.2">The purpose of encryption is to ensure the confidentiality and integrity of data. </span><span class="kobospan" id="kobo.39.3">Encrypted data remains readable by those who have the appropriate decryption key, but it is unintelligible to anyone who intercepts it without the key. </span><span class="kobospan" id="kobo.39.4">Encryption is widely used to protect sensitive data in transit and data at rest, such as credit card numbers, passwords, and personally </span><span><span class="kobospan" id="kobo.40.1">identifiable information.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.41.1">Here’s some simple Python code to implement </span><span><span class="kobospan" id="kobo.42.1">basic encryption</span></span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.43.1">Source </span></em><span><em class="italic"><span class="kobospan" id="kobo.44.1">code: Encryption_Example.ipynb</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.45.1">Develop a function to encrypt the given text using a basic </span><span><span class="kobospan" id="kobo.46.1">encryption algorithm.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.47.1">
def simple_encryption(text, shift):
    """
    Encrypts the given text using the Caesar Cipher algorithm.
</span><span class="kobospan1" id="kobo.47.2">    """
    result = ""
# Loop through each character in the text
    for i in range(len(text)):
        char = text[i]
# If the character is a letter, shift its position in the alphabet
        if char.isalpha():
            if char.isupper():
                result += chr((ord(char) + shift - 65) % 26 + 65)
            else:
                result += chr((ord(char) + shift - 97) % 26 + 97)
        else:
            result += char
    return result
simple_encryption("Privacy Preserved Machine Learning",5)</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.48.1">The output of the preceding code is </span><span><span class="kobospan" id="kobo.49.1">as follows:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.50.1">
'Uwnafhd Uwjxjwaji Rfhmnsj Qjfwsnsl'</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.51.1">This function takes two arguments: </span><strong class="source-inline"><span class="kobospan" id="kobo.52.1">text</span></strong><span class="kobospan" id="kobo.53.1">, which is the plaintext to be encrypted, and </span><strong class="source-inline"><span class="kobospan" id="kobo.54.1">shift</span></strong><span class="kobospan" id="kobo.55.1">, which is the </span><a id="_idIndexMarker745" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.56.1">number of positions by which each letter in the plaintext should be shifted in the alphabet. </span><span class="kobospan" id="kobo.56.2">The function returns the </span><span><span class="kobospan" id="kobo.57.1">encrypted text.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.58.1">For example, if you call simple_encryption (“Privacy Preserved Machine Learning “, 5), then the function will return the string “Uwnafhd Uwjxjwaji Rfhmnsj Qjfwsnsl”, which is the encrypted version of “Privacy Preserved Machine Learning” with a shift </span><span><span class="kobospan" id="kobo.59.1">of 5.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.60.1">Encryption algorithms</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.61.1">There are many popular encryption algorithms used </span><a id="_idIndexMarker746" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.62.1">today for securing data and communications. </span><span class="kobospan" id="kobo.62.2">The most common are </span><span><span class="kobospan" id="kobo.63.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.64.1">Advanced Encryption Standard</span></strong><span class="kobospan" id="kobo.65.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.66.1">AES</span></strong><span class="kobospan" id="kobo.67.1">): A symmetric-key</span><a id="_idIndexMarker747" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.68.1"> encryption algorithm widely used for </span><a id="_idIndexMarker748" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.69.1">securing data in transit and </span><span><span class="kobospan" id="kobo.70.1">at rest</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.71.1">Rivest-Shamir-Adleman</span></strong><span class="kobospan" id="kobo.72.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.73.1">RSA</span></strong><span class="kobospan" id="kobo.74.1">): An asymmetric-key encryption algorithm used for secure communication and </span><a id="_idIndexMarker749" class="pcalibre1 calibre6 pcalibre"/><span><span class="kobospan" id="kobo.75.1">digital signatures</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.76.1">Data Encryption Standard</span></strong><span class="kobospan" id="kobo.77.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.78.1">DES</span></strong><span class="kobospan" id="kobo.79.1">): A symmetric-key encryption algorithm widely used in the past, but now</span><a id="_idIndexMarker750" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.80.1"> considered </span><span><span class="kobospan" id="kobo.81.1">less </span></span><span><a id="_idIndexMarker751" class="pcalibre1 calibre6 pcalibre"/></span><span><span class="kobospan" id="kobo.82.1">secure</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.83.1">Blowfish</span></strong><span class="kobospan" id="kobo.84.1">: A symmetric-key </span><a id="_idIndexMarker752" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.85.1">encryption algorithm designed for</span><a id="_idIndexMarker753" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.86.1"> high-speed and efficient encryption of large amounts </span><span><span class="kobospan" id="kobo.87.1">of data</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.88.1">Twofish</span></strong><span class="kobospan" id="kobo.89.1">: A symmetric-key</span><a id="_idIndexMarker754" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.90.1"> encryption algorithm that is a successor to </span><a id="_idIndexMarker755" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.91.1">Blowfish, designed for higher security </span><span><span class="kobospan" id="kobo.92.1">and flexibility</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.93.1">ChaCha20</span></strong><span class="kobospan" id="kobo.94.1">: A symmetric-key</span><a id="_idIndexMarker756" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.95.1"> encryption algorithm that is </span><a id="_idIndexMarker757" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.96.1">becoming increasingly popular due to its high security </span><span><span class="kobospan" id="kobo.97.1">and performance</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.98.1">Elliptic Curve Cryptography</span></strong><span class="kobospan" id="kobo.99.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.100.1">ECC</span></strong><span class="kobospan" id="kobo.101.1">): An asymmetric-key</span><a id="_idIndexMarker758" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.102.1"> encryption algorithm that uses elliptic curves instead of </span><a id="_idIndexMarker759" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.103.1">prime numbers, resulting in smaller key sizes and </span><span><span class="kobospan" id="kobo.104.1">faster performance</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.105.1">These are just a few of the most popular encryption algorithms. </span><span class="kobospan" id="kobo.105.2">There are many others, and new ones are constantly being developed as computing power and security </span><span><span class="kobospan" id="kobo.106.1">needs evolve.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.107.1">Encryption example using AES</span></h3>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.108.1">Source </span></em><span><em class="italic"><span class="kobospan" id="kobo.109.1">code: Encryption_Example.ipynb</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.110.1">Develop a function to encrypt the given</span><a id="_idIndexMarker760" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.111.1"> text using the AES </span><span><span class="kobospan" id="kobo.112.1">encryption algorithm:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.113.1">
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
def aes_encrypt(key, plaintext):
# initialization vector to random bytes
    ini_vec = get_random_bytes(AES.block_size)
# Create the AES cipher object with the given key
    aes_ciper = AES.new(key, AES.MODE_CBC, ini_vec)
# Pad the plaintext to a multiple of the block size
    plaintext = pad_plain_text(plaintext, AES.block_size)
# Encrypt the plaintext using the AES cipher object
    ciphertext = aes_ciper.encrypt(plaintext)
    return ini_vec + ciphertext
def aes_decrypt(key, ciphertext):
    ini_vec = ciphertext[:AES.block_size]
    cipher = AES.new(key, AES.MODE_CBC, ini_vec)
    plaintext = cipher.decrypt(ciphertext[AES.block_size:])
    plaintext = unpad_decrypted_text(plaintext, AES.block_size)
    return plaintext.decode('utf-8')
def pad_plain_text(data, block_size):
    padding_length = block_size – (len(data) % block_size)
    padding = bytes([padding_length] * padding_length)
    return data + padding
def unpad_decrypted_text(data, block_size):
    padding_length = data[-1]
    if padding_length &lt; 1 or padding_length &gt; block_size:
        raise ValueError("Padding is not Valid ")
    padding = data[-padding_length:]
    if not all(padding[i] == padding_length for i in range(padding_length)):
        raise ValueError("Padding is not Valid ")
    return data[:-padding_length]
key = b'ThisIsASecretKey'
plaintext = b'Privacy Preserved Machine Learning'
ciphertext = aes_encrypt(key, plaintext)
print('Encrypted message:', ciphertext)
decrypted_plaintext = aes_decrypt(key, ciphertext)
print('Decrypted message:', decrypted_plaintext)</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.114.1">This results in the </span><a id="_idIndexMarker761" class="pcalibre1 calibre6 pcalibre"/><span><span class="kobospan" id="kobo.115.1">following output:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.116.1">
Encrypted message: b'\xe3\x00\xe8\x10\xc6E\x0cn\x1bO,\x89-\x8d\xee\xb3\xc6\x1a\xbf\x95\\l\x0e\x8d\xb0\xaa\x93\xf4_$?h\x1a`O\xf4N\x89!4\xf7(\xd3\x8e\xde\xc7\xf7\xb8\x87\xea\n5W\x8e\xa5D\xec]\x80\xa8+\x92?\xa9'
Decrypted message: Privacy Preserved Machine Learning</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.117.1">In this example program, we used the PyCrypto library to</span><a id="_idIndexMarker762" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.118.1"> implement AES encryption with </span><strong class="bold"><span class="kobospan" id="kobo.119.1">cipher-block chaining</span></strong><span class="kobospan" id="kobo.120.1"> (</span><span><strong class="bold"><span class="kobospan" id="kobo.121.1">CBC</span></strong></span><span><span class="kobospan" id="kobo.122.1">) mode.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.123.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.124.1">aes_encrypt</span></strong><span class="kobospan" id="kobo.125.1"> function takes a 128-bit key and plaintext message as the input and returns the encrypted ciphertext. </span><span class="kobospan" id="kobo.125.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.126.1">aes_decrypt</span></strong><span class="kobospan" id="kobo.127.1"> function takes a key and ciphertext as input and returns the decrypted plaintext message. </span><span class="kobospan" id="kobo.127.2">We used the PKCS7 padding scheme to pad the </span><a id="_idIndexMarker763" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.128.1">plaintext to a multiple of the block size and to remove the padding after decryption. </span><span class="kobospan" id="kobo.128.2">It generates a random initialization vector for each encryption operation to add an additional layer </span><span><span class="kobospan" id="kobo.129.1">of security.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.130.1">Limitations of encryption</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.131.1">Encryption doesn’t provide </span><a id="_idIndexMarker764" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.132.1">anonymity or de-identification of data. </span><span class="kobospan" id="kobo.132.2">Encrypted data may contain sensitive information that could be used to identify individuals. </span><span class="kobospan" id="kobo.132.3">Encryption only protects data while it is being transmitted (data in motion) or stored (data at rest, i.e., in a persistent store), but it doesn’t control who has access to it or how it is used </span><span><span class="kobospan" id="kobo.133.1">once decrypted.</span></span></p>
<h2 id="_idParaDest-153" class="calibre7"><a id="_idTextAnchor161" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.134.1">Data anonymization</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.135.1">Anonymization is the process of removing</span><a id="_idIndexMarker765" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.136.1"> identifiable information from data so that individuals cannot be identified. </span><span class="kobospan" id="kobo.136.2">The main purpose of anonymization is to protect the privacy of individuals while still allowing the data to be used for analysis or research </span><span><span class="kobospan" id="kobo.137.1">use cases.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.138.1">Here’s some example Python code for </span><span><span class="kobospan" id="kobo.139.1">data anonymization:</span></span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.140.1">Source </span></em><span><em class="italic"><span class="kobospan" id="kobo.141.1">code: Example_Data_annomization.ipynb</span></em></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.142.1">
import hashlib
import random
# Example dataset
dataset = [
    {"name": "Alice", "age": 23, "email": "alice@example.com"},
    {"name": "Bob", "age": 32, "email": "bob@example.com"},
    {"name": "Gandhi", "age": 55, "email": "gandhi@example.com"},
]
# Create a random salt value for anonymization
salt = str(random.getrandbits(128))
# Loop through the dataset and anonymize each record
for record in dataset:
# Hash the name and email using the salt value name_hash = hashlib.sha256((record['name'] +salt).encode()).hexdigest() email_hash = hashlib.sha256((record['email'] + salt).encode()).hexdigest()
# Replace the original name and email with the hashed values
record['name'] = name_hash
record['email'] = email_hash
print(dataset)</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.143.1">This results in the </span><a id="_idIndexMarker766" class="pcalibre1 calibre6 pcalibre"/><span><span class="kobospan" id="kobo.144.1">following output:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.145.1">
[{'name': 'e807ef3ca985de8ef481ddf8af4d3ac4c34089519cf225a7863306ced0a691fa', 'age': 23, 'email': '474f2b3dce2701b08651d64364ab5e83575e9bd8ff7e0e14d654afbdf19f6683'}, {'name': '36cbc209f7afaba2a3a4d8830c2b85b3813f467f4bf442bb439b3f112be00bd0', 'age': 32, 'email': '6a7b3de0488fc3a81436b5c70e943ca7139c93d1832430db2e6bac3f2c25cce5'}, {'name': '096aca9f2b7872c89b9c71ff1a649e7fe53fc7eb1a04354792ea58aaee3bbecf', 'age': 55, 'email': 'e15e4e48f0161e7a64b8ef604e6d9bd5d9d6f2da3c8d848268aeec0ff5da2ef8'}]</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.146.1">In the preceding code, we used Python’s </span><strong class="source-inline"><span class="kobospan" id="kobo.147.1">hashlib</span></strong><span class="kobospan" id="kobo.148.1"> library to hash the name and email fields of each record in the dataset using a random salt value. </span><span class="kobospan" id="kobo.148.2">The hashed values are then stored in place of the original values. </span><span class="kobospan" id="kobo.148.3">This technique can be used to protect the privacy of sensitive information</span><a id="_idIndexMarker767" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.149.1"> in </span><span><span class="kobospan" id="kobo.150.1">a dataset.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.151.1">Is anonymization alone sufficient to protect sensitive data? </span><span class="kobospan" id="kobo.151.2">In short, no, it is not sufficient, as we’ll see in the following case study from the </span><span><span class="kobospan" id="kobo.152.1">real world.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.153.1">Real-world case study (Netflix user data anonymization)</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.154.1">Our Netflix data anonymization </span><a id="_idIndexMarker768" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.155.1">case study dates back to 2006 when Netflix launched the Netflix Prize, a competition aimed at improving the accuracy of the company’s </span><span><span class="kobospan" id="kobo.156.1">recommendation algorithm.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.157.1">As part of the competition, Netflix released a dataset containing the viewing history of 500,000 subscribers, with personally identifiable information removed. </span><span class="kobospan" id="kobo.157.2">The dataset was made available to researchers to develop better algorithms. </span><span class="kobospan" id="kobo.157.3">In 2009, researchers published a paper that showed that it was possible to re-identify individuals in the Netflix dataset by using information </span><a id="_idIndexMarker769" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.158.1">from the </span><strong class="bold"><span class="kobospan" id="kobo.159.1">Internet Movie Database</span></strong><span class="kobospan" id="kobo.160.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.161.1">IMDb</span></strong><span class="kobospan" id="kobo.162.1">). </span><span class="kobospan" id="kobo.162.2">The researchers were able to match the anonymized viewing history with the reviews that users had posted on IMDb, allowing them to re-identify individuals with </span><span><span class="kobospan" id="kobo.163.1">high accuracy.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.164.1">Following this discovery, Netflix took steps to improve its anonymization techniques, but in 2010, researchers once again showed that it was possible to re-identify individuals in the Netflix dataset. </span><span class="kobospan" id="kobo.164.2">This time, researchers used external data sources such as social networks and movie rating websites to </span><span><span class="kobospan" id="kobo.165.1">re-identify individuals.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.166.1">In response to these privacy concerns, Netflix stopped releasing anonymized datasets to researchers in 2010. </span><span class="kobospan" id="kobo.166.2">Instead, the company created an internal research program where researchers could analyze Netflix data without any personally identifiable information being shared. </span><span class="kobospan" id="kobo.166.3">However, in 2020, a group of researchers from the University of Texas at Austin and the University of California, Irvine showed that they could still re-identify Netflix users by analyzing their viewing history and correlating it with publicly available datasets. </span><span class="kobospan" id="kobo.166.4">The researchers were able to accurately re-identify users even when no personally identifiable information was present in the </span><span><span class="kobospan" id="kobo.167.1">Netflix dataset.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.168.1">These findings showed that the </span><a id="_idIndexMarker770" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.169.1">anonymization techniques alone were not enough to protect users’ privacy as they are prone to data linkage attacks, which we learned about in </span><a href="B16573_01.xhtml#_idTextAnchor015" class="pcalibre1 calibre6 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.170.1">Chapter 1</span></em></span></a><span><span class="kobospan" id="kobo.171.1">.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.172.1">Limitations of anonymization</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.173.1">Anonymization may not completely eliminate the risk of re-identification. </span><span class="kobospan" id="kobo.173.2">If enough data is available, it may be possible to</span><a id="_idIndexMarker771" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.174.1"> identify individuals by linking the anonymized data with other available information such as </span><span><span class="kobospan" id="kobo.175.1">public datasets.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.176.1">Anonymization may result in loss of data quality or accuracy, as certain data elements may be removed or masked in </span><span><span class="kobospan" id="kobo.177.1">the process.</span></span></p>
<h2 id="_idParaDest-154" class="calibre7"><a id="_idTextAnchor162" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.178.1">De-identification</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.179.1">De-identification is the process of removing or masking identifiable information in data so that it cannot be used to identify individuals. </span><span class="kobospan" id="kobo.179.2">The purpose of de-identification is to protect the privacy of individuals</span><a id="_idIndexMarker772" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.180.1"> while still allowing the data to be used for research, analysis, or other applications. </span><span class="kobospan" id="kobo.180.2">De-identified data may be used for healthcare research, marketing analysis, financial use cases, IoT use cases, and other applications where sensitive data </span><span><span class="kobospan" id="kobo.181.1">is required.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.182.1">De-identification algorithms</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.183.1">One-way hashing algorithms can be used to </span><a id="_idIndexMarker773" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.184.1">run de-identification processes on data. </span><span class="kobospan" id="kobo.184.2">One-way hashing algorithms, also known as cryptographic hash functions, are mathematical </span><a id="_idIndexMarker774" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.185.1">functions that take an input message of any length and generate a fixed-size output, which is referred to as a hash or message digest. </span><span class="kobospan" id="kobo.185.2">The key property of one-way hash algorithms is that they are designed such that it should be computationally infeasible to reverse-engineer the original input message from the </span><span><span class="kobospan" id="kobo.186.1">hash value.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.187.1">There are many different hashing </span><a id="_idIndexMarker775" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.188.1">algorithms, and new ones are continually </span><span><span class="kobospan" id="kobo.189.1">being developed.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.190.1">The following are some of the most widely used </span><span><span class="kobospan" id="kobo.191.1">hashing algorithms:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.192.1">Message Digest 5</span></strong><span class="kobospan" id="kobo.193.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.194.1">MD5</span></strong><span class="kobospan" id="kobo.195.1">): This is a widely</span><a id="_idIndexMarker776" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.196.1"> used hashing </span><a id="_idIndexMarker777" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.197.1">algorithm that produces a 128-bit hash value. </span><span class="kobospan" id="kobo.197.2">It is now considered to be insecure due to vulnerabilities in </span><span><span class="kobospan" id="kobo.198.1">its design.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.199.1">Secure Hash Algorithm 1 </span></strong><span class="kobospan" id="kobo.200.1">(</span><strong class="bold"><span class="kobospan" id="kobo.201.1">SHA-1</span></strong><span class="kobospan" id="kobo.202.1">): This is another widely used hashing algorithm that produces a</span><a id="_idIndexMarker778" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.203.1"> 160-bit hash value. </span><span class="kobospan" id="kobo.203.2">It is also</span><a id="_idIndexMarker779" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.204.1"> now considered to </span><span><span class="kobospan" id="kobo.205.1">be insecure.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.206.1">Secure Hash Algorithm 2</span></strong><span class="kobospan" id="kobo.207.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.208.1">SHA-2</span></strong><span class="kobospan" id="kobo.209.1">): This is </span><a id="_idIndexMarker780" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.210.1">a family of hashing algorithms that includes SHA-224, SHA-256, SHA-384, and SHA-512. </span><span class="kobospan" id="kobo.210.2">These </span><a id="_idIndexMarker781" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.211.1">algorithms produce hash values of 224, 256, 384, and 512 </span><span><span class="kobospan" id="kobo.212.1">bits, respectively.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.213.1">Secure Hash Algorithm 3</span></strong><span class="kobospan" id="kobo.214.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.215.1">SHA-3</span></strong><span class="kobospan" id="kobo.216.1">): This is a family of hashing algorithms that includes SHA3-224, SHA3-256, SHA3-384, and SHA3-512. </span><span class="kobospan" id="kobo.216.2">These algorithms are designed as a replacement</span><a id="_idIndexMarker782" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.217.1"> for SHA-2 and </span><a id="_idIndexMarker783" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.218.1">produce hash values of 224, 256, 384, and 512 </span><span><span class="kobospan" id="kobo.219.1">bits, respectively.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.220.1">BLAKE2</span></strong><span class="kobospan" id="kobo.221.1">: This is a family of </span><a id="_idIndexMarker784" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.222.1">hashing algorithms that includes BLAKE2b </span><a id="_idIndexMarker785" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.223.1">and BLAKE2s. </span><span class="kobospan" id="kobo.223.2">These algorithms were designed to be faster than SHA-3 while still providing </span><span><span class="kobospan" id="kobo.224.1">strong security.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.225.1">RACE Integrity Primitives Evaluation Message Digest</span></strong><span class="kobospan" id="kobo.226.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.227.1">RIPEMD</span></strong><span class="kobospan" id="kobo.228.1">): This is a family of hashing</span><a id="_idIndexMarker786" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.229.1"> algorithms that includes RIPEMD-128, RIPEMD-160, RIPEMD-256, and RIPEMD-320. </span><span class="kobospan" id="kobo.229.2">These algorithms were designed as a replacement for the </span><a id="_idIndexMarker787" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.230.1">MD4 and MD5 algorithms and produce hash values of 128, 160, 256, and 320 </span><span><span class="kobospan" id="kobo.231.1">bits, respectively.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.232.1">Whirlpool</span></strong><span class="kobospan" id="kobo.233.1">: This is a hashing</span><a id="_idIndexMarker788" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.234.1"> algorithm that produces a 512-bit hash value. </span><span class="kobospan" id="kobo.234.2">It was designed to be an alternative to the SHA-2 family </span><span><span class="kobospan" id="kobo.235.1">of algorithms.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.236.1">These are some of the examples </span><a id="_idIndexMarker789" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.237.1">of hashing algorithms available. </span><span class="kobospan" id="kobo.237.2">The choice of which algorithm to use will depend on the specific application and the desired balance between security, speed, and </span><span><span class="kobospan" id="kobo.238.1">other factors.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.239.1">Example Python code to de-identify the data</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.240.1">As discussed, De-identification is the</span><a id="_idIndexMarker790" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.241.1"> process of removing or masking identifiable information in data so that it cannot be used to identify the original data. </span><span class="kobospan" id="kobo.241.2">In the code below, let’s de-identify a given data (in this case a string) using the SHA256 </span><span><span class="kobospan" id="kobo.242.1">hashing algorithm.</span></span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.243.1">Source code:  </span></em><span><em class="italic"><span class="kobospan" id="kobo.244.1">De-Identify_Exmple.ipynb</span></em></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.245.1">
import hashlib
# Define a function to hash a given string using SHA256 Algorithm
def hash_string(s):
    return hashlib.sha256(s.encode()).hexdigest()
# Define a function to de-identify a given input data
def deidentify_data(data):
# Remove leading/trailing whitespace and convert to lowercase
    data = data.strip().lower()
# Hash the name using SHA-256
    hashed_data = hash_string(name)
# Return the hashed data
    return hashed_data
# input
person_name = "Sundar P"
hashed_name = deidentify_data(person_name)
print(hashed_name)</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.246.1">This results in the </span><span><span class="kobospan" id="kobo.247.1">following output:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.248.1">
"6cea57c2fb6cbc2a40411135005760f241fffc3e5e67ab99882726431037f908""</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.249.1">In this example, the </span><strong class="source-inline"><span class="kobospan" id="kobo.250.1">hashlib</span></strong><span class="kobospan" id="kobo.251.1"> library is used to compute a SHA-256 hash of a given input string. </span><span class="kobospan" id="kobo.251.2">We define a </span><strong class="source-inline"><span class="kobospan" id="kobo.252.1">deidentify_data</span></strong><span class="kobospan" id="kobo.253.1"> function that takes data as input, removes any leading/trailing whitespace, converts the data to lowercase, and then hashes it using the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.254.1">hash_string</span></strong></span><span><span class="kobospan" id="kobo.255.1"> function.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.256.1">This ensures that the same</span><a id="_idIndexMarker791" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.257.1"> input name will always produce the same output hash. </span><span class="kobospan" id="kobo.257.2">Note that because one-way hashing is an irreversible process, there is no way to retrieve the original name from the </span><span><span class="kobospan" id="kobo.258.1">hashed value.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.259.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.260.1">hashlib</span></strong><span class="kobospan" id="kobo.261.1"> library in Python provides a collection of hashing algorithms. </span><span class="kobospan" id="kobo.261.2">The following methods are available in the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.262.1">hashlib</span></strong></span><span><span class="kobospan" id="kobo.263.1"> library:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.264.1">hashlib.md5()</span></strong><span class="kobospan" id="kobo.265.1">: This method returns an MD5 </span><span><span class="kobospan" id="kobo.266.1">hash object</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.267.1">hashlib.sha1()</span></strong><span class="kobospan" id="kobo.268.1">: This method returns a SHA-1 </span><span><span class="kobospan" id="kobo.269.1">hash object</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.270.1">hashlib.sha224()</span></strong><span class="kobospan" id="kobo.271.1">: This method returns a SHA-224 </span><span><span class="kobospan" id="kobo.272.1">hash object</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.273.1">hashlib.sha256()</span></strong><span class="kobospan" id="kobo.274.1">: This method returns a SHA-256 </span><span><span class="kobospan" id="kobo.275.1">hash object</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.276.1">hashlib.sha384()</span></strong><span class="kobospan" id="kobo.277.1">: This method returns a SHA-384 </span><span><span class="kobospan" id="kobo.278.1">hash object</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.279.1">hashlib.sha512()</span></strong><span class="kobospan" id="kobo.280.1">: This method returns a SHA-512 </span><span><span class="kobospan" id="kobo.281.1">hash object</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.282.1">hashlib.blake2s()</span></strong><span class="kobospan" id="kobo.283.1">: This method returns a BLAKE2s </span><span><span class="kobospan" id="kobo.284.1">hash object</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.285.1">hashlib.blake2b()</span></strong><span class="kobospan" id="kobo.286.1">: This method returns a BLAKE2b </span><span><span class="kobospan" id="kobo.287.1">hash object</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.288.1">hashlib.sha3_224()</span></strong><span class="kobospan" id="kobo.289.1">: This method returns a SHA3-224 </span><span><span class="kobospan" id="kobo.290.1">hash object</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.291.1">hashlib.sha3_256()</span></strong><span class="kobospan" id="kobo.292.1">: This method returns a SHA3-256 </span><span><span class="kobospan" id="kobo.293.1">hash object</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.294.1">hashlib.sha3_384()</span></strong><span class="kobospan" id="kobo.295.1">: This method returns a SHA3-384 </span><span><span class="kobospan" id="kobo.296.1">hash object</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.297.1">hashlib.sha3_512()</span></strong><span class="kobospan" id="kobo.298.1">: This method returns a SHA3-512 </span><span><span class="kobospan" id="kobo.299.1">hash object</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.300.1">The purpose of de-identification is to make it difficult or impossible to identify individuals based on their </span><a id="_idIndexMarker792" class="pcalibre1 calibre6 pcalibre"/><span><span class="kobospan" id="kobo.301.1">personal information.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.302.1">Limitations of de-identification</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.303.1">De-identification may not completely eliminate the risk of re-identification. </span><span class="kobospan" id="kobo.303.2">If enough data is available, it may be possible to identify individuals based on other available information. </span><span class="kobospan" id="kobo.303.3">De-identification</span><a id="_idIndexMarker793" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.304.1"> may result in the loss of data quality or accuracy, as certain data elements may be removed or masked in </span><span><span class="kobospan" id="kobo.305.1">the process.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.306.1">In summary, each technique has its own strengths and limitations, and the appropriate technique should be selected based on the specific use case and requirements. </span><span class="kobospan" id="kobo.306.2">Encryption is the most secure way to protect data, but it does not provide anonymity or de-identification. </span><span class="kobospan" id="kobo.306.3">Anonymization and de-identification can both provide privacy protection, but they may not be sufficient in all cases and may result in data quality or </span><span><span class="kobospan" id="kobo.307.1">accuracy issues.</span></span></p>
<h1 id="_idParaDest-155" class="calibre5"><a id="_idTextAnchor163" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.308.1">Exploring Homomorphic encryption</span></h1>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.309.1">Homomorphic Encryption</span></strong><span class="kobospan" id="kobo.310.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.311.1">HE</span></strong><span class="kobospan" id="kobo.312.1">) is a cryptographic technique that allows computation on encrypted data without decrypting it. </span><span class="kobospan" id="kobo.312.2">In other words, it is possible to perform operations on ciphertexts, generating new ciphertexts that are decrypted to the result of the</span><a id="_idIndexMarker794" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.313.1"> operation on the plaintexts. </span><span class="kobospan" id="kobo.313.2">HE has the potential to revolutionize data privacy and security, enabling secure computation of sensitive data without revealing the data itself. </span><span class="kobospan" id="kobo.313.3">HE is based on mathematical concepts such as algebraic structures, number theory, and polynomial theory. </span><span class="kobospan" id="kobo.313.4">The most common types of HE are based on the following </span><span><span class="kobospan" id="kobo.314.1">algebraic structures.</span></span></p>
<h2 id="_idParaDest-156" class="calibre7"><a id="_idTextAnchor164" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.315.1">Ring-based</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.316.1">In the context of cryptography, an algebraic structure refers to a set of mathematical operations that can be </span><a id="_idIndexMarker795" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.317.1">performed on elements of the set in a specific way. </span><span class="kobospan" id="kobo.317.2">In the case of a ring, the set of elements is closed under addition and multiplication, and</span><a id="_idIndexMarker796" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.318.1"> the operations satisfy certain properties, such as associativity, commutativity, and the existence of an identity element and inverse elements. </span><span class="kobospan" id="kobo.318.2">In the context of HE, an algebraic structure is used to perform computations on encrypted data without first decrypting it. </span><span class="kobospan" id="kobo.318.3">The underlying algebraic structure is a ring, which is a set of elements with two binary operations (addition and multiplication) that </span><a id="_idIndexMarker797" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.319.1">satisfy certain properties. </span><span class="kobospan" id="kobo.319.2">The most widely used ring-based HE is the </span><strong class="bold"><span class="kobospan" id="kobo.320.1">Brakerski-Gentry-Vaikuntanathan</span></strong><span class="kobospan" id="kobo.321.1"> (</span><span><strong class="bold"><span class="kobospan" id="kobo.322.1">BGV</span></strong></span><span><span class="kobospan" id="kobo.323.1">) scheme.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.324.1">The BGV scheme is a </span><strong class="bold"><span class="kobospan" id="kobo.325.1">fully homomorphic encryption</span></strong><span class="kobospan" id="kobo.326.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.327.1">FHE</span></strong><span class="kobospan" id="kobo.328.1">) scheme based </span><a id="_idIndexMarker798" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.329.1">on the </span><strong class="bold"><span class="kobospan" id="kobo.330.1">learning with errors</span></strong><span class="kobospan" id="kobo.331.1"> (</span><span><strong class="bold"><span class="kobospan" id="kobo.332.1">LWE</span></strong></span><span><span class="kobospan" id="kobo.333.1">) problem.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.334.1">Let’s now examine a mathematical </span><a id="_idIndexMarker799" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.335.1">description of </span><span><span class="kobospan" id="kobo.336.1">the scheme.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.337.1">Key generation</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.338.1">To generate a public key, the following </span><a id="_idIndexMarker800" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.339.1">steps </span><span><span class="kobospan" id="kobo.340.1">are performed:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.341.1">Choose two integers n and q, where q is a </span><span><span class="kobospan" id="kobo.342.1">prime number.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.343.1">Generate a random matrix A with integer entries in the range [-</span><span><span class="kobospan" id="kobo.344.1">q/2, q/2].</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.345.1">Generate a random vector with integer entries in the range [-</span><span><span class="kobospan" id="kobo.346.1">q/2, q/2].</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.347.1">Compute the vector b = As + e, where e is a random vector with entries in the range [-B/2, B/2] for some </span><span><span class="kobospan" id="kobo.348.1">integer B.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.349.1">Set the public key to be (</span><span><span class="kobospan" id="kobo.350.1">A, b).</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.351.1">To generate a secret key, a random vector s is chosen with integer entries in the range [-</span><span><span class="kobospan" id="kobo.352.1">q/2, q/2].</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.353.1">Encryption</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.354.1">To encrypt a message m, the</span><a id="_idIndexMarker801" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.355.1"> following steps </span><span><span class="kobospan" id="kobo.356.1">are performed:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.357.1">Represent the message m as a polynomial m(x) with integer coefficients </span><span><span class="kobospan" id="kobo.358.1">modulo q.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.359.1">Choose a random polynomial r(x) with integer coefficients </span><span><span class="kobospan" id="kobo.360.1">modulo q.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.361.1">Compute c = (A*r + b + m(x)*t)/q, where t is a scaling factor that controls the noise in </span><span><span class="kobospan" id="kobo.362.1">the ciphertext.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.363.1">The resulting ciphertext c consists of a matrix and </span><span><span class="kobospan" id="kobo.364.1">a polynomial.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.365.1">Decryption</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.366.1">To decrypt a ciphertext c, the following</span><a id="_idIndexMarker802" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.367.1"> steps </span><span><span class="kobospan" id="kobo.368.1">are performed:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.369.1">Compute c’ = </span><span><span class="kobospan" id="kobo.370.1">c*s/q.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.371.1">Round each entry of c’ to the </span><span><span class="kobospan" id="kobo.372.1">nearest integer.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.373.1">Recover the polynomial m(x) by subtracting A*r </span><span><span class="kobospan" id="kobo.374.1">from c’.</span></span></li>
</ul>
<h3 class="calibre9"><span class="kobospan" id="kobo.375.1">Homomorphic operations</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.376.1">The BGV scheme allows homomorphic </span><a id="_idIndexMarker803" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.377.1">addition and multiplication on ciphertexts. </span><span class="kobospan" id="kobo.377.2">These operations are performed </span><span><span class="kobospan" id="kobo.378.1">as follows:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.379.1">Homomorphic addition: To add two ciphertexts c1 and c2, add their corresponding polynomials modulo q, and add their matrices element-wise </span><span><span class="kobospan" id="kobo.380.1">modulo q.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.381.1">Homomorphic multiplication: To multiply two ciphertexts c1 and c2, compute their product modulo q using the polynomial multiplication algorithm, and multiply their matrices using matrix </span><a id="_idIndexMarker804" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.382.1">multiplication </span><span><span class="kobospan" id="kobo.383.1">modulo q.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.384.1">Bootstrapping</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.385.1">To perform more than one</span><a id="_idIndexMarker805" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.386.1"> homomorphic multiplication, the BGV scheme uses a technique called bootstrapping to “refresh” the ciphertext. </span><span class="kobospan" id="kobo.386.2">The bootstrapping process involves </span><a id="_idIndexMarker806" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.387.1">decoding the ciphertext, performing a homomorphic operation, and then re-encrypting the result with a new set of keys. </span><span class="kobospan" id="kobo.387.2">The bootstrapping process allows an arbitrary number of homomorphic operations to be performed on the ciphertext while still maintaining the security of </span><span><span class="kobospan" id="kobo.388.1">the scheme.</span></span></p>
<h2 id="_idParaDest-157" class="calibre7"><a id="_idTextAnchor165" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.389.1">Lattice-based</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.390.1">HE based on lattices uses the </span><a id="_idIndexMarker807" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.391.1">mathematical concept of lattices, which are </span><a id="_idIndexMarker808" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.392.1">geometric structures in higher dimensions that allow the efficient computation of certain types of problems. </span><span class="kobospan" id="kobo.392.2">The most widely used lattice-based HE is the </span><span><span class="kobospan" id="kobo.393.1">FHE scheme.</span></span></p>
<h2 id="_idParaDest-158" class="calibre7"><a id="_idTextAnchor166" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.394.1">Elliptic curve-based</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.395.1">HE based on elliptic curves </span><a id="_idIndexMarker809" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.396.1">uses elliptic curves over finite fields to create the cryptographic scheme. </span><span class="kobospan" id="kobo.396.2">This type </span><a id="_idIndexMarker810" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.397.1">of HE is relatively new, and not as widely used as the other </span><span><span class="kobospan" id="kobo.398.1">two types.</span></span></p>
<h1 id="_idParaDest-159" class="calibre5"><a id="_idTextAnchor167" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.399.1">Exploring the mathematics behind HE</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.400.1">The mathematics</span><a id="_idIndexMarker811" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.401.1"> behind HE is based on two main concepts: encryption </span><span><span class="kobospan" id="kobo.402.1">and homomorphism.</span></span></p>
<h2 id="_idParaDest-160" class="calibre7"><a id="_idTextAnchor168" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.403.1">Encryption</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.404.1">Encryption is the process of transforming</span><a id="_idIndexMarker812" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.405.1"> plaintext into ciphertext using an encryption algorithm and a secret key. </span><span class="kobospan" id="kobo.405.2">The ciphertext can then be transmitted over a network or stored in a database without fear of unauthorized access. </span><span class="kobospan" id="kobo.405.3">To decrypt the ciphertext and obtain the plaintext, the recipient must possess the secret key that was used to encrypt </span><span><span class="kobospan" id="kobo.406.1">the data.</span></span></p>
<h2 id="_idParaDest-161" class="calibre7"><a id="_idTextAnchor169" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.407.1">Homomorphism</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.408.1">Homomorphism is a mathematical property that allows an operation to be performed on ciphertexts, generating a new ciphertext that is the result of the operation on the plaintexts. </span><span class="kobospan" id="kobo.408.2">This means that if we</span><a id="_idIndexMarker813" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.409.1"> have two plaintexts x and y, and their respective ciphertexts C(x) and C(y), we can perform an operation on C(x) and C(y) to obtain a new ciphertext C(x+y), which can be decrypted to obtain the result of the operation on x </span><span><span class="kobospan" id="kobo.410.1">and y.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.411.1">The most commonly used homomorphic operations are addition and multiplication, but other operations such as subtraction and division can also be performed. </span><span class="kobospan" id="kobo.411.2">The level of homomorphism determines how many operations can be performed on the ciphertexts before the noise introduced during the encryption process becomes too high and the ciphertext </span><span><span class="kobospan" id="kobo.412.1">becomes unusable.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.413.1">HE is based on the concept of adding noise to the ciphertext to make it impossible to recover the plaintext without the secret key. </span><span class="kobospan" id="kobo.413.2">The noise is added in such a way that homomorphic operations can be performed on the ciphertext without revealing the plaintext. </span><span class="kobospan" id="kobo.413.3">The amount of noise added determines the level of security of the encryption. </span><span class="kobospan" id="kobo.413.4">The noise is also the reason why the level of homomorphism is limited in HE, as too many homomorphic operations can cause the noise to become too high and the ciphertext to </span><span><span class="kobospan" id="kobo.414.1">become unusable.</span></span></p>
<h1 id="_idParaDest-162" class="calibre5"><a id="_idTextAnchor170" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.415.1">Types of HE</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.416.1">There are three </span><a id="_idIndexMarker814" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.417.1">types of implementation for HE. </span><span class="kobospan" id="kobo.417.2">Let’s examine </span><span><span class="kobospan" id="kobo.418.1">them now.</span></span></p>
<h2 id="_idParaDest-163" class="calibre7"><a id="_idTextAnchor171" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.419.1">Fully Homomorphic Encryption (FHE)</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.420.1">FHE is a type of encryption that allows computation to be performed on encrypted data without decrypting it. </span><span class="kobospan" id="kobo.420.2">It means that the ciphertext can be used as input for a computation and the result will be </span><a id="_idIndexMarker815" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.421.1">a ciphertext as well, which can be decrypted to get the result of the computation. </span><span class="kobospan" id="kobo.421.2">FHE is a </span><a id="_idIndexMarker816" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.422.1">powerful tool that can be used in various applications such as cloud computing, machine learning, and secure outsourcing. </span><span class="kobospan" id="kobo.422.2">One of the main challenges of FHE is its computational complexity, which makes it impractical for many applications. </span><span class="kobospan" id="kobo.422.3">However, recent advancements in FHE have led to the development of more efficient algorithms that reduce the computational overhead </span><span><span class="kobospan" id="kobo.423.1">of FHE.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.424.1">The Gentry scheme is one of the earliest and most well-known FHE schemes, but it has a high computational cost. </span><span class="kobospan" id="kobo.424.2">More recent schemes, such</span><a id="_idIndexMarker817" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.425.1"> as the CKKS scheme and the BFV scheme, offer more efficient FHE algorithms that are suitable for </span><span><span class="kobospan" id="kobo.426.1">practical applications.</span></span></p>
<h2 id="_idParaDest-164" class="calibre7"><a id="_idTextAnchor172" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.427.1">Somewhat Homomorphic Encryption (SHE)</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.428.1">SHE is a type of encryption that allows</span><a id="_idIndexMarker818" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.429.1"> limited computations on encrypted data. </span><span class="kobospan" id="kobo.429.2">Unlike FHE, SHE cannot perform arbitrary </span><a id="_idIndexMarker819" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.430.1">computations on encrypted data. </span><span class="kobospan" id="kobo.430.2">Instead, it can only perform a limited set of operations, such as addition and multiplication, on the encrypted data. </span><span class="kobospan" id="kobo.430.3">While SHE is less powerful than FHE, it is still useful in many applications, such as secure voting, secure messaging, and secure database queries. </span><span class="kobospan" id="kobo.430.4">SHE is less computationally intensive than FHE, which makes it more practical for </span><span><span class="kobospan" id="kobo.431.1">certain applications.</span></span></p>
<h2 id="_idParaDest-165" class="calibre7"><a id="_idTextAnchor173" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.432.1">Partially Homomorphic Encryption (PHE)</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.433.1">PHE is a type of encryption that allows </span><a id="_idIndexMarker820" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.434.1">for computations on encrypted data, but only for one type of operation, either addition or multiplication. </span><span class="kobospan" id="kobo.434.2">PHE is less powerful than both FHE and SHE but is still useful in some applications, such as secure key generation, secure function evaluation, and secure scalar product calculation. </span><span class="kobospan" id="kobo.434.3">PHE is less computationally intensive than both FHE and SHE, which</span><a id="_idIndexMarker821" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.435.1"> makes it more practical for some applications. </span><span class="kobospan" id="kobo.435.2">However, its limited functionality means that it is less flexible than FHE and SHE and cannot be used in as </span><span><span class="kobospan" id="kobo.436.1">many applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.437.1">FHE, SHE, and PHE are three related encryption schemes that provide different levels of functionality and computational complexity. </span><span class="kobospan" id="kobo.437.2">FHE is the most powerful but also the most computationally intensive, while PHE is the least powerful but also the least computationally intensive. </span><span class="kobospan" id="kobo.437.3">SHE provides a middle ground between FHE and PHE in terms of functionality and </span><span><span class="kobospan" id="kobo.438.1">computational complexity.</span></span></p>
<h2 id="_idParaDest-166" class="calibre7"><a id="_idTextAnchor174" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.439.1">Paillier scheme</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.440.1">The Paillier scheme is a public key cryptosystem that is used for the encryption and decryption of data. </span><span class="kobospan" id="kobo.440.2">It is based on the mathematical assumption i.e </span><strong class="bold"><span class="kobospan" id="kobo.441.1">decisional composite residuality assumption</span></strong><span class="kobospan" id="kobo.442.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.443.1">DCRA</span></strong><span class="kobospan" id="kobo.444.1">), which is a </span><a id="_idIndexMarker822" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.445.1">hard computational problem. </span><span class="kobospan" id="kobo.445.2">The scheme is named after its creator, Pascal Paillier, who introduced it </span><span><span class="kobospan" id="kobo.446.1">in 1999.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.447.1">The Paillier scheme is an asymmetric encryption algorithm, which means that it uses two different keys: a public key </span><a id="_idIndexMarker823" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.448.1">for encryption and a private key for</span><a id="_idIndexMarker824" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.449.1"> decryption. </span><span class="kobospan" id="kobo.449.2">The scheme is designed to be probabilistic, which means that each encryption of a given plaintext results in a different ciphertext. </span><span class="kobospan" id="kobo.449.3">The scheme is also homomorphic, which means that it supports certain types of operations on the </span><span><span class="kobospan" id="kobo.450.1">encrypted data.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.451.1">Key generation</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.452.1">To use the Paillier scheme, a user first generates a </span><a id="_idIndexMarker825" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.453.1">public key and a corresponding private key. </span><span class="kobospan" id="kobo.453.2">The public key consists of two large prime numbers, p and q, which are kept secret. </span><span class="kobospan" id="kobo.453.3">The user then calculates n = p * q and lambda = LCM(p - 1, q - 1), where LCM is the least common multiple function. </span><span class="kobospan" id="kobo.453.4">The value of lambda is used to generate the </span><span><span class="kobospan" id="kobo.454.1">private key.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.455.1">Encryption</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.456.1">To encrypt a message, the sender uses the recipient’s public key. </span><span class="kobospan" id="kobo.456.2">The plaintext message is represented as an integer m, where 0 &lt;= m &lt; n. </span><span class="kobospan" id="kobo.456.3">The sender then chooses a random number r, where 0 &lt;= r &lt; n, and </span><a id="_idIndexMarker826" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.457.1">computes c = g^m * r^n mod n^2, where g is a random generator modulo n^2. </span><span class="kobospan" id="kobo.457.2">The ciphertext c is then sent to </span><span><span class="kobospan" id="kobo.458.1">the recipient.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.459.1">Decryption</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.460.1">To decrypt the ciphertext, the</span><a id="_idIndexMarker827" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.461.1"> recipient uses their private key. </span><span class="kobospan" id="kobo.461.2">The recipient first computes the </span><span><span class="kobospan" id="kobo.462.1">value of</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.463.1">mu = (L(g^lambda mod n^2)^-1 mod n)^(lambda^-1 </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.464.1">mod n)</span></strong></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.465.1">where</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.466.1">L(x) = (x - 1) / n</span></strong></p>
<p class="calibre3"><span class="kobospan" id="kobo.467.1">The value of mu is used to calculate the plaintext message m </span><span><span class="kobospan" id="kobo.468.1">as follows:</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.469.1">m = L(c^lambda mod n^2) * mu </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.470.1">mod n</span></strong></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.471.1">The recipient can then recover the original message </span><span><span class="kobospan" id="kobo.472.1">from m.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.473.1">Homomorphic properties</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.474.1">The Paillier scheme supports two homomorphic properties: additive </span><span><span class="kobospan" id="kobo.475.1">and multiplicative.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.476.1">The additive property allows the recipient to </span><a id="_idIndexMarker828" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.477.1">perform addition on the encrypted data. </span><span class="kobospan" id="kobo.477.2">Given two ciphertexts c1 and c2 that correspond to plaintext messages m1 and m2, the recipient can compute a new ciphertext c3 that corresponds to the sum of m1 and m2 by multiplying c1 * c2 </span><span><span class="kobospan" id="kobo.478.1">mod n^2.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.479.1">The multiplicative property allows the recipient to perform multiplication on the encrypted data. </span><span class="kobospan" id="kobo.479.2">Given a ciphertext c that corresponds to a plaintext message m, the recipient can compute a new ciphertext c’ that corresponds to the product of m and a constant k by raising c to the power of k </span><span><span class="kobospan" id="kobo.480.1">mod n^2.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.481.1">Security</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.482.1">The Paillier scheme is also resistant to known plaintext attacks and chosen plaintext attacks. </span><span class="kobospan" id="kobo.482.2">The scheme is used in various applications, including electronic voting, privacy-preserving data mining, and secure </span><span><span class="kobospan" id="kobo.483.1">multiparty computation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.484.1">Python frameworks</span><a id="_idIndexMarker829" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.485.1"> for HE the following section, we will cover the open source Python frameworks that are used to implement HE. </span><span class="kobospan" id="kobo.485.2">We will implement a few examples in detail to understand homomorphic operations in a </span><span><span class="kobospan" id="kobo.486.1">better way.</span></span></p>
<h2 id="_idParaDest-167" class="calibre7"><a id="_idTextAnchor175" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.487.1">Pyfhel</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.488.1">Pyfhel is a Python library for FHE. </span><span class="kobospan" id="kobo.488.2">It </span><a id="_idIndexMarker830" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.489.1">provides an easy-to-use</span><a id="_idIndexMarker831" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.490.1"> interface for performing FHE operations on </span><span><span class="kobospan" id="kobo.491.1">encrypted data.</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.492.1">URL: </span></span><a href="https://pyfhel.readthedocs.io/en/latest/" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.493.1">https://pyfhel.readthedocs.io/en/latest/</span></span></a></p>
<h2 id="_idParaDest-168" class="calibre7"><a id="_idTextAnchor176" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.494.1">SEAL Python</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.495.1">SEAL Python is a Python wrapper for the </span><strong class="bold"><span class="kobospan" id="kobo.496.1">Simple Encrypted Arithmetic Library</span></strong><span class="kobospan" id="kobo.497.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.498.1">SEAL</span></strong><span class="kobospan" id="kobo.499.1">) C++ library. </span><span class="kobospan" id="kobo.499.2">SEAL Python provides a</span><a id="_idIndexMarker832" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.500.1"> high-level interface</span><a id="_idIndexMarker833" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.501.1"> for performing HE</span><a id="_idIndexMarker834" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.502.1"> and decryption operations on data using the Brakerski/Fan-Vercauteren (BFV) and Cheon-Kim-Kim-Song (</span><span><span class="kobospan" id="kobo.503.1">CKKS) schemes.</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.504.1">URL: </span></span><a href="https://github.com/Huelse/SEAL-Python" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.505.1">https://github.com/Huelse/SEAL-Python</span></span></a></p>
<h2 id="_idParaDest-169" class="calibre7"><a id="_idTextAnchor177" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.506.1">TenSEAL</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.507.1">TenSEAL is a Python library</span><a id="_idIndexMarker835" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.508.1"> for homomorphic encryption on </span><em class="italic"><span class="kobospan" id="kobo.509.1">n</span></em><span class="kobospan" id="kobo.510.1"> tensors, built on top of Microsoft SEAL and using the CKKS scheme. </span><span class="kobospan" id="kobo.510.2">It provides an easy-to-use interface for performing FHE operations on encrypted data with support for </span><a id="_idIndexMarker836" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.511.1">batching and </span><span><span class="kobospan" id="kobo.512.1">batching rotations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.513.1">The main features offered</span><a id="_idIndexMarker837" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.514.1"> by TenSEAL are </span><span><span class="kobospan" id="kobo.515.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.516.1">Encryption/decryption of the vectors of integers </span><span><span class="kobospan" id="kobo.517.1">using BFV</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.518.1">Encryption/decryption of the vectors of real numbers </span><span><span class="kobospan" id="kobo.519.1">using CKKS</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.520.1">Element-wise addition, subtraction, and multiplication of encrypted-encrypted vectors and </span><span><span class="kobospan" id="kobo.521.1">encrypted-plain vectors</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.522.1">Dot product and </span><a id="_idIndexMarker838" class="pcalibre1 calibre6 pcalibre"/><span><span class="kobospan" id="kobo.523.1">vector-matrix multiplication</span></span></li>
</ul>
<p class="calibre3"><span><span class="kobospan" id="kobo.524.1">URL: </span></span><a href="https://github.com/OpenMined/TenSEAL" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.525.1">https://github.com/OpenMined/TenSEAL</span></span></a></p>
<h2 id="_idParaDest-170" class="calibre7"><a id="_idTextAnchor178" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.526.1">phe</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.527.1">phe is a Python library for </span><strong class="bold"><span class="kobospan" id="kobo.528.1">partially homomorphic encryption</span></strong><span class="kobospan" id="kobo.529.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.530.1">PHE</span></strong><span class="kobospan" id="kobo.531.1">) using the Paillier scheme. </span><span class="kobospan" id="kobo.531.2">It provides an API for performing PHE operations on </span><span><span class="kobospan" id="kobo.532.1">encrypted data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.533.1">It is a simple and easy-to-use</span><a id="_idIndexMarker839" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.534.1"> library. </span><span class="kobospan" id="kobo.534.2">It only supports three </span><a id="_idIndexMarker840" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.535.1">operations (addition, subtraction, and scalar </span><a id="_idIndexMarker841" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.536.1">multiplication) on HE out of </span><span><span class="kobospan" id="kobo.537.1">four operations.</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.538.1">URL: </span></span><a href="https://pypi.org/project/phe/" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.539.1">https://pypi.org/project/phe/</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.540.1">The homomorphic properties of the Paillier cryptographic system work </span><span><span class="kobospan" id="kobo.541.1">as follows.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.542.1">Encrypted numbers can be </span><span><span class="kobospan" id="kobo.543.1">added together:</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.544.1">Enc(m1)+Enc(m2)</span></span><span><span class="kobospan" id="kobo.545.1">≡</span></span><span><span class="kobospan" id="kobo.546.1">Enc(m1+m2)</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer107">
<span class="kobospan" id="kobo.547.1"><img alt="Figure 8.1 – Homomorphic addition" src="image/B16573_08_01.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.548.1">Figure 8.1 – Homomorphic addition</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.549.1">Encrypted numbers</span><a id="_idIndexMarker842" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.550.1"> can be subtracted from </span><span><span class="kobospan" id="kobo.551.1">each other:</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.552.1">Enc(m1)-Enc(m2)</span></span><span><span class="kobospan" id="kobo.553.1">≡</span></span><span><span class="kobospan" id="kobo.554.1">Enc(m1-m2)</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer108">
<span class="kobospan" id="kobo.555.1"><img alt="Figure 8.2 – Homomorphic subtraction" src="image/B16573_08_02.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.556.1">Figure 8.2 – Homomorphic subtraction</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.557.1">Encrypted numbers can be </span><a id="_idIndexMarker843" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.558.1">multiplied by a </span><span><span class="kobospan" id="kobo.559.1">non-encrypted scalar:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.560.1">n⋅Enc(m) ≡ </span><span><span class="kobospan" id="kobo.561.1">Enc(n*m)</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer109">
<span class="kobospan" id="kobo.562.1"><img alt="Figure 8.3 – Homomorphic-encrypted nu﻿mber multiplied by a non-encrypted scalar" src="image/B16573_08_03.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.563.1">Figure 8.3 – Homomorphic-encrypted nu</span><a id="_idTextAnchor179" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.564.1">mber multiplied by a non-encrypted scalar</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.565.1">Encrypted </span><a id="_idIndexMarker844" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.566.1">numbers can be </span><a id="_idIndexMarker845" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.567.1">added to </span><span><span class="kobospan" id="kobo.568.1">non-encrypted scalars:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.569.1">n+Enc(m) ≡ </span><span><span class="kobospan" id="kobo.570.1">Enc(n+m)</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer110">
<span class="kobospan" id="kobo.571.1"><img alt="Figure 8.4 – Homomorphic-encrypted number added to a non-encrypted scalar" src="image/B16573_08_04.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.572.1">Figure 8.4 – Homomorphic-encrypted number added to a non-encrypted scalar</span></p>
<h1 id="_idParaDest-171" class="calibre5"><a id="_idTextAnchor180" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.573.1">Implementing HE</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.574.1">To implement HE, choose a suitable HE library from those outlined previously. </span><span class="kobospan" id="kobo.574.2">Make sure your choice is appropriate</span><a id="_idIndexMarker846" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.575.1"> based on your specific use case, then perform the </span><span><span class="kobospan" id="kobo.576.1">following steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.577.1">Generate the public and private keys required for the </span><span><span class="kobospan" id="kobo.578.1">encryption scheme.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.579.1">Convert the plaintext data that needs to be encrypted into a suitable format for the encryption scheme, such as </span><span><span class="kobospan" id="kobo.580.1">a polynomial.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.581.1">Encrypt the plaintext data using the public key generated in </span><span><em class="italic"><span class="kobospan" id="kobo.582.1">step 2</span></em></span><span><span class="kobospan" id="kobo.583.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.584.1">Perform the homomorphic operations on the ciphertext data without </span><span><span class="kobospan" id="kobo.585.1">decrypting it.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.586.1">Decrypt the resulting ciphertext data using the private key generated in </span><em class="italic"><span class="kobospan" id="kobo.587.1">step 2</span></em><span class="kobospan" id="kobo.588.1"> to obtain the result of the homomorphic operations on the </span><span><span class="kobospan" id="kobo.589.1">plaintext data.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.590.1">Implementing HE can be complex and requires expertise in cryptography and mathematics. </span><span class="kobospan" id="kobo.590.2">It is important to ensure that the implementation is secure and efficient, as HE can be </span><span><span class="kobospan" id="kobo.591.1">computationally</span></span><span><a id="_idIndexMarker847" class="pcalibre1 calibre6 pcalibre"/></span><span><span class="kobospan" id="kobo.592.1"> intensive.</span></span></p>
<h2 id="_idParaDest-172" class="calibre7"><a id="_idTextAnchor181" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.593.1">Implementing PHE</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.594.1">We will implement an </span><a id="_idIndexMarker848" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.595.1">example of Paillier PHE using the open source </span><strong class="source-inline"><span class="kobospan" id="kobo.596.1">phe</span></strong> <span><span class="kobospan" id="kobo.597.1">Python library.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.598.1">First, we install the </span><strong class="source-inline"><span class="kobospan" id="kobo.599.1">phe</span></strong><span class="kobospan" id="kobo.600.1"> library </span><span><span class="kobospan" id="kobo.601.1">as follows:</span></span></p>
<pre class="source-code">
<span class="no-break"><span class="kobospan1" id="kobo.602.1">pip3 install phe</span></span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.603.1">Then we implement the </span><span><span class="kobospan" id="kobo.604.1">following steps:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.605.1">Generate the public and private keys using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.606.1">generate_paillier_keypair</span></strong><span class="kobospan" id="kobo.607.1"> method from </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.608.1">phe.paillier</span></strong></span><span><span class="kobospan" id="kobo.609.1"> class.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.610.1">Encrypt the plaintext data (15 in this example) using the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.611.1">encrypt</span></strong></span><span><span class="kobospan" id="kobo.612.1"> method.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.613.1">Perform homomorphic operations on the </span><span><span class="kobospan" id="kobo.614.1">ciphertext data:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.615.1">ciphertext1 = ciphertext * 3   // encrypted number multiplied by </span><span><span class="kobospan" id="kobo.616.1">a scalar</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.617.1"> ciphertext2 = ciphertext + ciphertext1 // adding two </span><span><span class="kobospan" id="kobo.618.1">encrypted numbers</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.619.1">ciphertext3 = ciphertext1 + 250  // adding scalar to a </span><span><span class="kobospan" id="kobo.620.1">encrypted number</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.621.1">ciphertext4 = ciphertext3 - </span><span><span class="kobospan" id="kobo.622.1">ciphertext2</span></span></li></ul></li>
<li class="calibre11"><span class="kobospan" id="kobo.623.1">Finally, decrypt the resulting ciphertext data using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.624.1">decrypt</span></strong><span class="kobospan" id="kobo.625.1"> method and print the </span><span><span class="kobospan" id="kobo.626.1">decrypted results.</span></span></li>
</ul>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.627.1">Source </span></em><span><em class="italic"><span class="kobospan" id="kobo.628.1">code: FHE-Example.ipynb</span></em></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.629.1">
import phe as paillier
pubkey, privkey = paillier.generate_paillier_keypair(n_length=1024)
print("public key",pubkey)
print("private key", privkey)
public key &lt;PaillierPublicKey 18dced683d&gt;
private key &lt;PaillierPrivateKey for &lt;PaillierPublicKey 18dced683d&gt;&gt;
plaintext = 15
ciphertext = pubkey.encrypt(plaintext)
# Perform homomorphic operations on the ciphertext data
ciphertext1 = ciphertext * 3
ciphertext2 = ciphertext + ciphertext1
ciphertext3 = ciphertext1 + 250
ciphertext4 = ciphertext3 - ciphertext2
# Decrypt the resulting ciphertext data
decrypted1 = privkey.decrypt(ciphertext1)
decrypted2 = privkey.decrypt(ciphertext2)
decrypted3 = privkey.decrypt(ciphertext3)
decrypted4 = privkey.decrypt(ciphertext4)
# Print the decrypted results
print("ciphertext1 decrypted: ", decrypted1)
print("ciphertext2 decrypted: ", decrypted2)
print("ciphertext3 decrypted: ", decrypted3)
print("ciphertext4 decrypted: ", decrypted4)
ciphertext1 decrypted:  45
ciphertext2 decrypted:  60
ciphertext3 decrypted:  295
ciphertext3 decrypted:  235
ciphertext1 : &lt;phe.paillier.EncryptedNumber object at 0x7fd51856afa0&gt;
ciphertext2 : &lt;phe.paillier.EncryptedNumber object at 0x7fd5185c3580&gt;
ciphertext3 : &lt;phe.paillier.EncryptedNumber object at 0x7fd51856ac70&gt;
ciphertext4 : &lt;phe.paillier.EncryptedNumber object at 0x7fd5185c3460&gt;</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.630.1">How about multiplying</span><a id="_idIndexMarker849" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.631.1"> an encrypted number with another </span><span><span class="kobospan" id="kobo.632.1">encrypted number?</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.633.1">Will the following work </span><span><span class="kobospan" id="kobo.634.1">with PHE?</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.635.1">Enc(m1) * </span><span><span class="kobospan" id="kobo.636.1">Enc(m2)</span></span><span><span class="kobospan" id="kobo.637.1">≡</span></span><span><span class="kobospan" id="kobo.638.1">Enc(m1* m2)</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.639.1">Let’s try this and </span><span><span class="kobospan" id="kobo.640.1">find out:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.641.1">
m1=15
m2=20
pubkey.encrypt(m1) * pubkey.encrypt(m2)
File ~/Library/Python/3.8/lib/python/site-packages/phe/paillier.py:508, in EncryptedNumber.__mul__(self, other)
    506 """Multiply by an int, float, or EncodedNumber."""
</span><span class="kobospan1" id="kobo.641.2">    507 if isinstance(other, EncryptedNumber):
--&gt; 508 raise NotImplementedError('Good luck with that...')
    510 if isinstance(other, EncodedNumber):
    511     encoding = other
NotImplementedError: Good luck with that...</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.642.1">It throws </span><em class="italic"><span class="kobospan" id="kobo.643.1">NotImplementedError</span></em><span class="kobospan" id="kobo.644.1">, which basically means that phe doesn’t support this (multiplying an encrypted number with another encrypted number) property </span><span><span class="kobospan" id="kobo.645.1">of HE.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.646.1">When your requirements call for developing applications involving tensors, matrices, arrays, and all homomorphic </span><a id="_idIndexMarker850" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.647.1">operations, TenSEAL is the best framework </span><span><span class="kobospan" id="kobo.648.1">to use.</span></span></p>
<h2 id="_idParaDest-173" class="calibre7"><a id="_idTextAnchor182" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.649.1">Implementing HE using the TenSEAL library</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.650.1">We will implement an example </span><a id="_idIndexMarker851" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.651.1">of HE using the open</span><a id="_idIndexMarker852" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.652.1"> source TenSEAL </span><span><span class="kobospan" id="kobo.653.1">Python library.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.654.1">First, we install the TenSEAL library </span><span><span class="kobospan" id="kobo.655.1">as follows:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.656.1">
pip3 install tenseal</span></pre>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.657.1">Source </span></em><span><em class="italic"><span class="kobospan" id="kobo.658.1">code :TenSeal_Example.ipynb</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.659.1">Develop the sample applictions in the </span><span><span class="kobospan" id="kobo.660.1">following way.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.661.1">
import tenseal as ts
# Step 1: Create context
context = ts.context(
              ts.SCHEME_TYPE.CKKS,
              poly_modulus_degree=8192,
              coeff_mod_bit_sizes=[60, 40, 40, 60]
        )
context.generate_galois_keys()
context.global_scale = 2**40
# Step 2: Create and encrypt data
data1 = [1.0, 2.0, 3.0, 4.0]
data2 = [5.0, 6.0, 7.0, 8.0]
encrypted_data1 = ts.ckks_vector(context, data1)
encrypted_data2 = ts.ckks_vector(context, data2)
# Step 3: Perform operations on encrypted data
encrypted_sum = encrypted_data1 + encrypted_data2
encrypted_product = encrypted_data1 * encrypted_data2
encrypted_dot_product = encrypted_data1.dot(encrypted_data2)
matrix_a = [[73],[69],[87],[45],]
mat_product = encrypted_data1.matmul(matrix_a)
# Step 4: Decrypt result
sum_result = encrypted_sum.decrypt()
product_result = encrypted_product.decrypt()
dot_product_result = encrypted_dot_product.decrypt()
mat_result = mat_product.decrypt()
print("Sum: ", sum_result)
print("Product: ", product_result)
print("Dot product: ", dot_product_result)
print("Matrix Multiplication : ", mat_result)
Sum: [6.000000000650802, 8.000000001433328, 10.0000000008995, 12.000000000314097]
Product: [5.000000671234171, 12.000001615240716, 21.000002823083314, 32.000004292130704]
Dot product: [70.00000937472286]
Matrix Multiplication : [652.000087556169]</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.662.1">In the preceding example code, we first create a context using the CKKS scheme with a polynomial modulus degree of 8,192 and four coefficient modulus bit sizes of 60, 40, 40, and 60. </span><span class="kobospan" id="kobo.662.2">Then, we create two CKKS vectors and encrypt our data. </span><span class="kobospan" id="kobo.662.3">Next, we perform two operations on our encrypted data: addition and multiplication. </span><span class="kobospan" id="kobo.662.4">Finally, we decrypt the results of these operations </span><a id="_idIndexMarker853" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.663.1">and print </span><span><span class="kobospan" id="kobo.664.1">them out.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.665.1">This library also supports creating context using the BFV scheme as well in the same manner and the homomorphic operations using the BFV Scheme </span><span><span class="kobospan" id="kobo.666.1">as well.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.667.1">This is a simple example, and in practice, HE can be computationally intensive and requires specialized hardware or cloud resources. </span><span class="kobospan" id="kobo.667.2">It is also important to ensure that the implementation is secure and that no encrypted data leaks out during </span><span><span class="kobospan" id="kobo.668.1">the computation.</span></span></p>
<h1 id="_idParaDest-174" class="calibre5"><a id="_idTextAnchor183" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.669.1">Comparison of HE frameworks</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.670.1">Let’s review a</span><a id="_idIndexMarker854" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.671.1"> comparison of some of the most popular HE frameworks </span><span><span class="kobospan" id="kobo.672.1">in Python.</span></span></p>
<h2 id="_idParaDest-175" class="calibre7"><a id="_idTextAnchor184" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.673.1">Pyfhel</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.674.1">Pyfhel is a Python-based fully HE library that supports operations on encrypted integers and vectors. </span><span class="kobospan" id="kobo.674.2">It is built on top of the HElib C++ library and offers a simplified interface for Python developers. </span><span class="kobospan" id="kobo.674.3">Pyfhel has good</span><a id="_idIndexMarker855" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.675.1"> performance and can handle large integers and vectors efficiently. </span><span class="kobospan" id="kobo.675.2">However, it does not yet support operations on </span><span><span class="kobospan" id="kobo.676.1">floating-point numbers.</span></span></p>
<h2 id="_idParaDest-176" class="calibre7"><a id="_idTextAnchor185" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.677.1">TenSEAL</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.678.1">TenSEAL is a Python-based</span><a id="_idIndexMarker856" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.679.1"> library for HE that supports both FHE and PHE. </span><span class="kobospan" id="kobo.679.2">It uses the CKKS and BFV encryption schemes and offers APIs for encrypted operations on floating-point numbers and matrices. </span><span class="kobospan" id="kobo.679.3">TenSEAL is designed to be easy to use and has a simpler API compared to some other HE libraries. </span><span class="kobospan" id="kobo.679.4">It has a relatively high performance for encrypted operations on </span><span><span class="kobospan" id="kobo.680.1">floating-point numbers.</span></span></p>
<h2 id="_idParaDest-177" class="calibre7"><a id="_idTextAnchor186" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.681.1">PALISADE</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.682.1">PALISADE is a C++ library for HE that has Python bindings. </span><span class="kobospan" id="kobo.682.2">It supports both FHE and PHE and offers a wide range of encryption</span><a id="_idIndexMarker857" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.683.1"> schemes, including CKKS, BFV, and GSW. </span><span class="kobospan" id="kobo.683.2">PALISADE is designed for performance and can handle large plaintexts and ciphertexts efficiently. </span><span class="kobospan" id="kobo.683.3">The Python bindings are relatively new, and the API can be more complex compared to other Python-based </span><span><span class="kobospan" id="kobo.684.1">HE libraries.</span></span></p>
<h2 id="_idParaDest-178" class="calibre7"><a id="_idTextAnchor187" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.685.1">PySEAL</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.686.1">PySEAL is a Python-based library for HE that </span><a id="_idIndexMarker858" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.687.1">supports FHE operations on encrypted integers and vectors. </span><span class="kobospan" id="kobo.687.2">It is built on top of the SEAL C++ library and provides a simplified Python interface. </span><span class="kobospan" id="kobo.687.3">PySEAL has good performance for integer and vector operations and can handle large plaintexts and ciphertexts. </span><span class="kobospan" id="kobo.687.4">However, it does not yet support operations on </span><span><span class="kobospan" id="kobo.688.1">floating-point numbers.</span></span></p>
<h2 id="_idParaDest-179" class="calibre7"><a id="_idTextAnchor188" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.689.1">TFHE</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.690.1">TFHE is a C++ library for HE that has</span><a id="_idIndexMarker859" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.691.1"> Python bindings. </span><span class="kobospan" id="kobo.691.2">It supports PHE operations on encrypted integers and booleans and is designed for high performance. </span><span class="kobospan" id="kobo.691.3">TFHE can handle large ciphertexts efficiently and has a relatively simple API. </span><span class="kobospan" id="kobo.691.4">The Python bindings are relatively new, and the documentation can </span><span><span class="kobospan" id="kobo.692.1">be limited.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.693.1">The following table offers a high-level summary of the comparisons between the preceding </span><span><span class="kobospan" id="kobo.694.1">HE libraries:</span></span></p>
<table class="no-table-style" id="table001-8">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.695.1">Operations</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.696.1">PySEAL</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.697.1">TenSEAL</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.698.1">Paillier</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.699.1">Pyfhel</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.700.1">Addition</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.701.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.702.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.703.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.704.1">Yes</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.705.1">Subtraction</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.706.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.707.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.708.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.709.1">No</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.710.1">Multiplication</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.711.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.712.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.713.1">No</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.714.1">Yes</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.715.1">Division</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.716.1">No</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.717.1">No</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.718.1">No</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.719.1">No</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.720.1">Comparison (&lt;, &gt;, &lt;=, &gt;=, </span><span><span class="kobospan" id="kobo.721.1">and ==)</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.722.1">No</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.723.1">No</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.724.1">No</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.725.1">No</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.726.1">Support for vector operations (addition, dot </span><span><span class="kobospan" id="kobo.727.1">product, etc.)</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.728.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.729.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.730.1">No</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.731.1">No</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.732.1">Matrix operations</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.733.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.734.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.735.1">No</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.736.1">No</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.737.1">Encrypted number added to scalar (</span><span><span class="kobospan" id="kobo.738.1">non-encrypted number)</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.739.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.740.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.741.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.742.1">Yes</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.743.1">Encrypted number multiplied by scalar (</span><span><span class="kobospan" id="kobo.744.1">non-encrypted number)</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.745.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.746.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.747.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.748.1">Yes</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.749.1">Table 8.1 – High-level comparison of HE frameworks</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.750.1">Each HE framework has its own set of strengths and weaknesses, and the best choice will depend on your specific </span><a id="_idIndexMarker860" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.751.1">use case and requirements. </span><span class="kobospan" id="kobo.751.2">Pyfhel and PySEAL are good choices for FHE operations on integers and vectors, while TenSEAL is a good choice for FHE operations on floating-point numbers and matrices. </span><span class="kobospan" id="kobo.751.3">PALISADE offers a wide range of encryption schemes and is designed for performance, while TFHE is a good choice for PHE operations on integers </span><span><span class="kobospan" id="kobo.752.1">and booleans.</span></span></p>
<h1 id="_idParaDest-180" class="calibre5"><a id="_idTextAnchor189" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.753.1">Machine learning with HE</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.754.1">HE can be used in </span><strong class="bold"><span class="kobospan" id="kobo.755.1">Machine Learning</span></strong><span class="kobospan" id="kobo.756.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.757.1">ML</span></strong><span class="kobospan" id="kobo.758.1">) models to encrypt the training data, test data, or even the complete model itself to achieve </span><span><span class="kobospan" id="kobo.759.1">model security.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.760.1">The following are some of the </span><a id="_idIndexMarker861" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.761.1">options to implement ML models </span><span><span class="kobospan" id="kobo.762.1">with HE:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.763.1">Encrypt the weights (model parameters) and intercept, and make use of them to calculate the accuracy of the model on the </span><span><span class="kobospan" id="kobo.764.1">test data.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.765.1">Encrypt the test data and make use of the encrypted data with an encrypted model to find out </span><span><span class="kobospan" id="kobo.766.1">the accuracy.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.767.1">Build the models with training data encrypted and without the encryption.Calculate the accuracy of the clear text model as well as the model with encrypted </span><span><span class="kobospan" id="kobo.768.1">training data.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.769.1">Encrypt the training data and train the model on encrypted data, then run the inference and decrypt </span><span><span class="kobospan" id="kobo.770.1">the results.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.771.1">In this example, we will </span><a id="_idIndexMarker862" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.772.1">encrypt the model parameters and do </span><span><span class="kobospan" id="kobo.773.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.774.1">Using the fraud detection </span><span><span class="kobospan" id="kobo.775.1">model example:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.776.1">Load the fraud </span><span><span class="kobospan" id="kobo.777.1">transaction data</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.778.1">Split the data as train </span><span><span class="kobospan" id="kobo.779.1">and test</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.780.1">Use the logistic regression model to train </span><span><span class="kobospan" id="kobo.781.1">the data</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.782.1">From the model, find out the intercept and coefficients ( </span><span><span class="kobospan" id="kobo.783.1">weights)</span></span></li></ul></li>
<li class="calibre11"><span class="kobospan" id="kobo.784.1">Using the Paillier PHE library, do </span><span><span class="kobospan" id="kobo.785.1">the following:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.786.1">Perform HE on the model parameters (i.e., the intercept values and model weights) using the </span><span><span class="kobospan" id="kobo.787.1">public key</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.788.1">Find out the predictions using the encrypted intercept and encrypted </span><span><span class="kobospan" id="kobo.789.1">model weights:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.790.1">Calculate the score by doing the homomorphic operations  (encrypted weights multiplied by test feature data and the addition of </span><span><span class="kobospan" id="kobo.791.1">encrypted numbers)</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.792.1">Decrypt the calculated score using homomorphic decryption and find out the </span><span><span class="kobospan" id="kobo.793.1">error/accuracy rates</span></span></li></ul></li></ul></li>
</ul>
<div class="calibre2">
<div class="img---figure" id="_idContainer111">
<span class="kobospan" id="kobo.794.1"><img alt="Figure 8.5 – Encryption of model parameters using HE" src="image/B16573_08_05.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.795.1">Figure 8.5 – Encryption of model parameters using HE</span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.796.1">Source </span></em><span><em class="italic"><span class="kobospan" id="kobo.797.1">code: FHE_Logistic.ipynb</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.798.1">Following code implements the steps</span><a id="_idIndexMarker863" class="pcalibre1 calibre6 pcalibre"/> <span><span class="kobospan" id="kobo.799.1">mentioned above.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.800.1">
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
url="fraud_transactions.csv"
df_actual = pd.read_csv(url, sep=",")
df_actual.head()
df_transactions = df_actual[['CUSTOMER_ID','TERMINAL_ID','TX_AMOUNT','TX_FRAUD']]
df_transactions
from sklearn.model_selection import train_test_split
from sklearn.model_selection import StratifiedShuffleSplit
X = df_transactions.drop('TX_FRAUD', axis=1)
y = df_transactions['TX_FRAUD']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
X_train = X_train.values
X_test = X_test.values
y_train = y_train.values
y_test = y_test.values
from sklearn.model_selection import cross_val_score
logreg = LogisticRegression(random_state=0)
logreg.fit(X_train, y_train)
training_score = cross_val_score(logreg, X_train, y_train, cv=2)
print('Logistic Regression Cross Validation Score: ', round(training_score.mean() * 100, 2).astype(str) + '%')
import numpy as np
np.sum(logreg.predict(X_test) == y_test)/X_test.shape[0]
logreg.intercept_[0], logreg.coef_[0]</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.801.1">This results in the</span><a id="_idIndexMarker864" class="pcalibre1 calibre6 pcalibre"/> <span><span class="kobospan" id="kobo.802.1">following output:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.803.1">
(-1168.308115256604,
 array([-2.47724513e-05, 3.17749573e-06, 1.54748556e+01]))
### Encrypt the Weights and Bias ( intercept) using paillier encryption
import phe as paillier
pubkey, privkey = paillier.generate_paillier_keypair(n_length=1024)
coef = logreg.coef_[0, :]
encrypted_weights = [pubkey.encrypt(coef[i]) for i in range(coef.shape[0])]
encrypted_intercept =pubkey.encrypt(logreg.intercept_[0])
print(encrypted_weights)
[&lt;phe.paillier.EncryptedNumber object at 0x7ff005a9c9d0&gt;, &lt;phe.paillier.EncryptedNumber object at 0x7fefe3b2c520&gt;, &lt;phe.paillier.EncryptedNumber object at 0x7ff010760cd0&gt;]
print(encrypted_intercept)
&lt;phe.paillier.EncryptedNumber at 0x7fefb812f100&gt;
### calculate score using encrypted weights for the 100 sample in the tests data and calculate the accuracy
y=np.zeros(100)
for i in range(1,100):
    c1 = X_test[i][0]
    c2 = X_test[i][1]
    c3 = X_test[i][2]
    score = encrypted_intercept
    score += c1 * encrypted_weights[0] + c2 * encrypted_weights[1] + c3 * encrypted_weights[2]
    dscore = privkey.decrypt(score)
    y[i] = dscore
print(y[0],y_test[0])
error = np.mean(np.sign(y) != y_test[1:100])
print(error)
Output:
0.0 0
1.0</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.804.1">In this way, ML engineers are able to share the</span><a id="_idIndexMarker865" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.805.1"> public key generated using HE, along with the encrypted model weights, with others while retaining the security of their </span><span><span class="kobospan" id="kobo.806.1">ML models.</span></span></p>
<h1 id="_idParaDest-181" class="calibre5"><a id="_idTextAnchor190" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.807.1">Encrypted evaluation of ML models and inference</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.808.1">In order to perform encrypted evaluations</span><a id="_idIndexMarker866" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.809.1"> and inference, follow </span><span><span class="kobospan" id="kobo.810.1">these steps:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.811.1">Encrypt the training data using the public key (i.e., the </span><span><span class="kobospan" id="kobo.812.1">HE key).</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.813.1">Train the model with the </span><span><span class="kobospan" id="kobo.814.1">encrypted data.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.815.1">Get the </span><span><span class="kobospan" id="kobo.816.1">encrypted results.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.817.1">Decrypt the results</span><a id="_idIndexMarker867" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.818.1"> with the secret key (i.e., the </span><span><span class="kobospan" id="kobo.819.1">private key).</span></span></li>
</ul>
<div class="calibre2">
<div class="img---figure" id="_idContainer112">
<span class="kobospan" id="kobo.820.1"><img alt="Figure 8.6 – Encrypted evaluation of ML model and inference" src="image/B16573_08_06.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.821.1">Figure 8.6 – Encrypted evaluation of ML model and inference</span></p>
<h1 id="_idParaDest-182" class="calibre5"><a id="_idTextAnchor191" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.822.1">Limitations of HE</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.823.1">HE is a powerful cryptographic</span><a id="_idIndexMarker868" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.824.1"> technique that allows computations to be performed on encrypted data without the need for decryption. </span><span class="kobospan" id="kobo.824.2">While HE has several benefits, it also has some limitations, which we’ll take a look </span><span><span class="kobospan" id="kobo.825.1">at now:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.826.1">Performance</span></strong><span class="kobospan" id="kobo.827.1">: HE is computationally intensive and can be slow, especially when working with large amounts of data. </span><span class="kobospan" id="kobo.827.2">The overhead associated with encryption and decryption can significantly impact the performance of </span><span><span class="kobospan" id="kobo.828.1">the system.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.829.1">Limited functionality</span></strong><span class="kobospan" id="kobo.830.1">: HE is still a developing field, and current implementations have limited functionality. </span><span class="kobospan" id="kobo.830.2">Complex computations are often difficult to perform using HE, and not all types of computations can be performed using current </span><span><span class="kobospan" id="kobo.831.1">HE techniques.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.832.1">Key management</span></strong><span class="kobospan" id="kobo.833.1">: HE requires the management of large cryptographic keys, which can be challenging, especially </span><a id="_idIndexMarker869" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.834.1">in distributed systems. </span><span class="kobospan" id="kobo.834.2">The key management problem becomes more complex as the number of parties involved in the </span><span><span class="kobospan" id="kobo.835.1">computation increases.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.836.1">Security assumptions</span></strong><span class="kobospan" id="kobo.837.1">: HE is based on certain security assumptions, and if these assumptions are violated, the security of the system can be compromised. </span><span class="kobospan" id="kobo.837.2">For example, the security of the system can be compromised if the attacker has access to the secret key or the encrypted data </span><span><span class="kobospan" id="kobo.838.1">is leaked.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.839.1">Storage requirements</span></strong><span class="kobospan" id="kobo.840.1">: HE can result in large ciphertexts that require more storage space than plaintext. </span><span class="kobospan" id="kobo.840.2">This can be a challenge in systems where storage space </span><span><span class="kobospan" id="kobo.841.1">is limited.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.842.1">The aforementioned limitations need to be taken into account when considering the use of HE in a system. </span><span class="kobospan" id="kobo.842.2">While HE has the potential to provide a secure and privacy-preserving solution, it is essential to carefully evaluate the limitations and trade-offs before using it in a </span><span><span class="kobospan" id="kobo.843.1">real-world system.</span></span></p>
<h1 id="_idParaDest-183" class="calibre5"><a id="_idTextAnchor192" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.844.1">Secure Multiparty Computation</span></h1>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.845.1">Secure Multiparty Computation</span></strong><span class="kobospan" id="kobo.846.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.847.1">SMC</span></strong><span class="kobospan" id="kobo.848.1">) is a cryptographic </span><a id="_idIndexMarker870" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.849.1">technique that enables two or more parties to jointly compute a function on their private data without revealing their data to </span><span><span class="kobospan" id="kobo.850.1">each other.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.851.1">SMC is an important tool in privacy-preserving computation, where parties may not trust each other or a central authority and may have sensitive data that they do not want to share with </span><span><span class="kobospan" id="kobo.852.1">other parties.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.853.1">In this section, we will learn about </span><a id="_idIndexMarker871" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.854.1">the basic principles of SMC, its applications, and some techniques used </span><span><span class="kobospan" id="kobo.855.1">for SMC.</span></span></p>
<h2 id="_idParaDest-184" class="calibre7"><a id="_idTextAnchor193" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.856.1">Basic principles of SMC</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.857.1">The basic principle of SMC is that each party has</span><a id="_idIndexMarker872" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.858.1"> private data that they want to keep secret from other parties, but they want to compute a function on the common joint data. </span><span class="kobospan" id="kobo.858.2">SMC enables multiple parties to do this securely by dividing the computation into smaller, less sensitive sub-computations, which are performed locally on each party’s private data. </span><span class="kobospan" id="kobo.858.3">Then, the parties communicate with each other to reveal only the final output of </span><span><span class="kobospan" id="kobo.859.1">the computation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.860.1">SMC ensures that no party learns any information about the other parties’ data, except for what is necessary to compute the final output. </span><span class="kobospan" id="kobo.860.2">The computations performed in SMC are designed such that no party can learn anything about other parties’ data by analyzing the messages sent during </span><span><span class="kobospan" id="kobo.861.1">the computation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.862.1">The security of SMC relies on cryptographic techniques such as secret sharing, HE, and oblivious transfer. </span><span class="kobospan" id="kobo.862.2">These techniques ensure that each party only sees a small portion of the input data and that the output is computed in such a way that no party can determine the input data of </span><span><span class="kobospan" id="kobo.863.1">other parties.</span></span></p>
<h2 id="_idParaDest-185" class="calibre7"><a id="_idTextAnchor194" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.864.1">Applications of SMC</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.865.1">SMC has several applications in various domains, including healthcare, finance, and data privacy. </span><span class="kobospan" id="kobo.865.2">We’ll examine these in </span><a id="_idIndexMarker873" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.866.1">more </span><span><span class="kobospan" id="kobo.867.1">detail now:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.868.1">Data analysis</span></strong><span class="kobospan" id="kobo.869.1">: In many scenarios, data is distributed across different parties, and it is not possible or desirable to centralize the data in one location. </span><span class="kobospan" id="kobo.869.2">SMC can be used to enable the parties to perform computations on their private data without revealing their data to </span><span><span class="kobospan" id="kobo.870.1">each other.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.871.1">ML</span></strong><span class="kobospan" id="kobo.872.1">: SMC can be used to enable multiple parties to jointly train ML models on their private data without sharing their data with each other. </span><span class="kobospan" id="kobo.872.2">This can be useful in scenarios where data privacy is a concern, such as in healthcare or </span><span><span class="kobospan" id="kobo.873.1">financial services.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.874.1">Privacy-preserving</span></strong> <strong class="bold"><span class="kobospan" id="kobo.875.1">authentication</span></strong><span class="kobospan" id="kobo.876.1">: SMC can be used to enable multiple parties to authenticate themselves without revealing their identity to each other. </span><span class="kobospan" id="kobo.876.2">For example, a group of users can use SMC to authenticate themselves with a service provider without revealing their identities to </span><span><span class="kobospan" id="kobo.877.1">each other.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.878.1">Fraud detection</span></strong><span class="kobospan" id="kobo.879.1">: SMC can be used to enable different parties to detect fraudulent activity without revealing any sensitive information. </span><span class="kobospan" id="kobo.879.2">For example, multiple banks can use SMC</span><a id="_idIndexMarker874" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.880.1"> to compute the intersection of their transaction lists to detect fraudulent transactions without revealing any customer data. </span><span class="kobospan" id="kobo.880.2">We have already covered using federated learning with differential privacy, but the same use case, that is, detection of fraudulent transactions, can be applied with SMC </span><span><span class="kobospan" id="kobo.881.1">as well.</span></span></li>
</ul>
<h2 id="_idParaDest-186" class="calibre7"><a id="_idTextAnchor195" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.882.1">Techniques used for SMC</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.883.1">SMC can be performed using various </span><a id="_idIndexMarker875" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.884.1">techniques, including secret sharing, HE, and oblivious transfer. </span><span class="kobospan" id="kobo.884.2">Let’s review these </span><span><span class="kobospan" id="kobo.885.1">techniques now:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.886.1">Secret sharing</span></strong><span class="kobospan" id="kobo.887.1">: This is a cryptographic technique that divides a secret into multiple shares, where each share is given to a</span><a id="_idIndexMarker876" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.888.1"> different party. </span><span class="kobospan" id="kobo.888.2">The secret can only be reconstructed when a sufficient number of shares are combined. </span><span class="kobospan" id="kobo.888.3">In SMC, secret sharing can be used to divide the input data into multiple shares, which are then used to perform computations locally on each </span><span><span class="kobospan" id="kobo.889.1">party’s data.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.890.1">HE</span></strong><span class="kobospan" id="kobo.891.1">: This is a type of encryption that allows computations to be performed on ciphertexts without decrypting them. </span><span class="kobospan" id="kobo.891.2">In SMC, HE can be used to compute the intermediate values of the</span><a id="_idIndexMarker877" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.892.1"> computation without revealing the parties’ data. </span><span class="kobospan" id="kobo.892.2">HE is computationally expensive, so it is not suitable for all </span><span><span class="kobospan" id="kobo.893.1">SMC applications.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.894.1">Oblivious transfer</span></strong><span class="kobospan" id="kobo.895.1">: This is a cryptographic</span><a id="_idIndexMarker878" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.896.1"> protocol where a sender has multiple messages, and a </span><a id="_idIndexMarker879" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.897.1">receiver selects one of the messages without revealing the </span><span><span class="kobospan" id="kobo.898.1">other messages.</span></span></li>
</ul>
<h2 id="_idParaDest-187" class="calibre7"><a id="_idTextAnchor196" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.899.1">Implementing SMC – high-level steps</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.900.1">The following is a high-level overview of the steps required to </span><span><span class="kobospan" id="kobo.901.1">implement SMC:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.902.1">Define the computation</span></strong><span class="kobospan" id="kobo.903.1">: The first step in implementing SMC is to define the computation that needs to</span><a id="_idIndexMarker880" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.904.1"> be performed on the private data. </span><span class="kobospan" id="kobo.904.2">This computation should be divided into smaller sub-computations, each of which can be performed locally on each party’s </span><span><span class="kobospan" id="kobo.905.1">private data.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.906.1">Secure communication</span></strong><span class="kobospan" id="kobo.907.1">: The parties involved in the SMC computation need to communicate securely with each other to exchange messages without revealing their private data. </span><span class="kobospan" id="kobo.907.2">This can be achieved using secure communication protocols such as SSL </span><span><span class="kobospan" id="kobo.908.1">or TLS.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.909.1">Secret sharing</span></strong><span class="kobospan" id="kobo.910.1">: The input data needs to be divided into shares, which are distributed among the parties. </span><span class="kobospan" id="kobo.910.2">Each party holds a share of the input data, and computations are performed locally on each party’s share. </span><span class="kobospan" id="kobo.910.3">Secret sharing can be implemented using cryptographic techniques such as Shamir’s Secret </span><span><span class="kobospan" id="kobo.911.1">Sharing Scheme.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.912.1">Computation</span></strong><span class="kobospan" id="kobo.913.1">: Once the input data has been shared among the parties, the computation can be performed locally on each party’s share of the data. </span><span class="kobospan" id="kobo.913.2">The intermediate values of the computation need to be encrypted using HE to prevent any party from learning anything about the other </span><span><span class="kobospan" id="kobo.914.1">parties’ data.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.915.1">Reveal the output</span></strong><span class="kobospan" id="kobo.916.1">: After the computation is complete, the parties reveal only the final output of the computation to each other. </span><span class="kobospan" id="kobo.916.2">The output can be reconstructed by combining</span><a id="_idIndexMarker881" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.917.1"> the shares of the output that each </span><span><span class="kobospan" id="kobo.918.1">party holds.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.919.1">SMC requires expertise in cryptography, programming, and network security. </span><span class="kobospan" id="kobo.919.2">It is a complex process that requires careful design and implementation to ensure the security and privacy of the </span><span><span class="kobospan" id="kobo.920.1">parties involved.</span></span></p>
<h2 id="_idParaDest-188" class="calibre7"><a id="_idTextAnchor197" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.921.1">Python frameworks that can be used to implement SMC</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.922.1">The following are a number of Python frameworks that can be used to </span><span><span class="kobospan" id="kobo.923.1">implement SMC:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.924.1">PySyft</span></strong><span class="kobospan" id="kobo.925.1"> is an open source framework </span><a id="_idIndexMarker882" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.926.1">for SMC and federated learning. </span><span class="kobospan" id="kobo.926.2">It provides tools for secure </span><a id="_idIndexMarker883" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.927.1">multi-party computation, differential privacy, and homomorphic encryption. </span><span class="kobospan" id="kobo.927.2">It is built on top of PyTorch and provides a simple and easy-to-use interface for </span><span><span class="kobospan" id="kobo.928.1">implementing SMC.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.929.1">Obliv-C</span></strong><span class="kobospan" id="kobo.930.1"> is a language and framework </span><a id="_idIndexMarker884" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.931.1">for implementing SMC in C and Python. </span><span class="kobospan" id="kobo.931.2">It provides a high-level programming interface for implementing SMC, as well as low-level primitives for building </span><span><span class="kobospan" id="kobo.932.1">custom protocols.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.933.1">Charm</span></strong><span class="kobospan" id="kobo.934.1"> is a Python library for </span><a id="_idIndexMarker885" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.935.1">cryptography that provides support for SMC, HE, and other cryptographic primitives. </span><span class="kobospan" id="kobo.935.2">It provides a high-level programming interface for implementing SMC, as well as low-level primitives for building </span><span><span class="kobospan" id="kobo.936.1">custom protocols.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.937.1">MPyC</span></strong><span class="kobospan" id="kobo.938.1"> is a Python library for SMC that </span><a id="_idIndexMarker886" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.939.1">provides a high-level programming interface for implementing secure computations. </span><span class="kobospan" id="kobo.939.2">It is built on top of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.940.1">asyncio</span></strong><span class="kobospan" id="kobo.941.1"> library, which provides support for </span><span><span class="kobospan" id="kobo.942.1">asynchronous programming.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.943.1">SecureML</span></strong><span class="kobospan" id="kobo.944.1"> is a Python library for implementing</span><a id="_idIndexMarker887" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.945.1"> SMC and other privacy-preserving ML techniques. </span><span class="kobospan" id="kobo.945.2">It provides a high-level programming interface for implementing SMC, as well as support for other privacy-preserving techniques such as differential privacy and </span><span><span class="kobospan" id="kobo.946.1">federated learning.</span></span></li>
</ul>
<h2 id="_idParaDest-189" class="calibre7"><a id="_idTextAnchor198" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.947.1">Implementing Private Set Interaction (PSI) SMC – case study</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.948.1">Private Set Intersection</span></strong><span class="kobospan" id="kobo.949.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.950.1">PSI</span></strong><span class="kobospan" id="kobo.951.1">) is a cryptographic technique that allows two or more parties to securely compute the intersection </span><a id="_idIndexMarker888" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.952.1">of their private sets without disclosing any other information about their sets. </span><span class="kobospan" id="kobo.952.2">PSI can be used in various fintech applications where sensitive financial data needs to be </span><a id="_idIndexMarker889" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.953.1">shared between parties while </span><span><span class="kobospan" id="kobo.954.1">preserving privacy.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.955.1">Let’s now examine an example case study concerning the implementation of PSI SMC for fraud detection in the </span><span><span class="kobospan" id="kobo.956.1">fintech sector.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.957.1">Fraud Detection</span></strong><span class="kobospan" id="kobo.958.1">: In the fintech industry, fraud detection is a critical task that requires sharing information between banks, financial institutions, and payment processors to identify fraudulent transactions. </span><span class="kobospan" id="kobo.958.2">However, sharing customer data between these entities can violate their customers’ privacy. </span><span class="kobospan" id="kobo.958.3">To overcome this problem, PSI can be used to enable the secure sharing of data between different entities without disclosing any </span><span><span class="kobospan" id="kobo.959.1">sensitive information.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.960.1">For example, suppose a bank wants to share its list of suspicious transactions with another bank without revealing the details of the transactions or customers involved. </span><span class="kobospan" id="kobo.960.2">PSI can be used to compute the intersection of the two banks’ transaction lists. </span><span class="kobospan" id="kobo.960.3">The bank’s transaction list would form one subset, and the other bank’s transaction list would form the other subset. </span><span class="kobospan" id="kobo.960.4">By using PSI, both banks can securely compute the intersection of their transaction lists without revealing any sensitive information about their transactions </span><span><span class="kobospan" id="kobo.961.1">or customers.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.962.1">To implement PSI SMC in this use case, SMC techniques can be used. </span><span class="kobospan" id="kobo.962.2">SMC ensures that the parties involved can jointly compute the intersection of their datasets without revealing any other information</span><a id="_idIndexMarker890" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.963.1"> about their datasets. </span><span class="kobospan" id="kobo.963.2">The computation can be performed using techniques such as </span><strong class="bold"><span class="kobospan" id="kobo.964.1">Oblivious Transfer</span></strong><span class="kobospan" id="kobo.965.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.966.1">OT</span></strong><span class="kobospan" id="kobo.967.1">) or </span><strong class="bold"><span class="kobospan" id="kobo.968.1">Garbled Circuits</span></strong><span class="kobospan" id="kobo.969.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.970.1">GC</span></strong><span class="kobospan" id="kobo.971.1">) to ensure the privacy</span><a id="_idIndexMarker891" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.972.1"> and security of </span><span><span class="kobospan" id="kobo.973.1">the computation.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer113">
<span class="kobospan" id="kobo.974.1"><img alt="Figure 8.7 – Example of secure multiparty computation with shared keys" src="image/B16573_08_07.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.975.1">Figure 8.7 – Example of secure multiparty computation with shared keys</span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.976.1">Source </span></em><span><em class="italic"><span class="kobospan" id="kobo.977.1">code: PSI-SMC_Example.ipynb</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.978.1">Let’s implement a simple SMC example </span><a id="_idIndexMarker892" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.979.1">to understand </span><span><span class="kobospan" id="kobo.980.1">the steps:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.981.1">
import random
# Define two parties
Bank1_data = [0.1, 0.2, 0.3]
Bank2_data = [0.5, 0.6, 0.7]
# Define the computation
def compute(x, y):
# Multiply the input data element-wise
    z = [x[i] * y[i] for i in range(len(x))]
# Sum the result
    result = sum(z)
    return result
# Randomly generate private keys for the parties
Bank1_key = random.randint(0, 1000)
Bank2_key = random.randint(0, 1000)
# Bank1 encrypts their data using Bank1 private key
Bank1_encrypted_data = [x + Bank1_key for x in Bank1_data]
# Bank2 encrypts their data using Bank2 private key
Bank2_encrypted_data = [x + Bank2_key for x in Bank2_data]
# The parties send their encrypted data to each other
Bank1_received_data = Bank2_encrypted_data
Bank2_received_data = Bank1_encrypted_data
# The parties compute the multiplication of their data
Bank1_result = compute(Bank1_data, Bank2_received_data)
print(Bank1_result)
Bank2_result = compute(Bank2_data, Bank1_received_data)
print(Bank2_result)
# The parties add their private keys to the result
final_result = Bank1_result + Bank1_key + Bank2_result + Bank2_key
print("Result:", final_result)
output this program as follows :
31.34
1669.6999999999998
Result: 2680.04</span></pre>
<h1 id="_idParaDest-190" class="calibre5"><a id="_idTextAnchor199" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.982.1">Zero-knowledge proofs</span></h1>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.983.1">Zero-Knowledge Proofs</span></strong><span class="kobospan" id="kobo.984.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.985.1">ZKPs</span></strong><span class="kobospan" id="kobo.986.1">) are a type of cryptographic protocol that allows one party (the Prover) to demonstrate to another party (the Verifier) that they possess knowledge of a particular piece of information, without revealing any other information about that knowledge. </span><span class="kobospan" id="kobo.986.2">The concept of zero knowledge was first introduced by Goldwasser, Micali, and Rackoff in 1985. </span><span class="kobospan" id="kobo.986.3">Since</span><a id="_idIndexMarker893" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.987.1"> then, zero-knowledge protocols have been widely used in cryptography, particularly in </span><span><span class="kobospan" id="kobo.988.1">privacy-preserving protocols.</span></span></p>
<h2 id="_idParaDest-191" class="calibre7"><a id="_idTextAnchor200" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.989.1">Basic concepts</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.990.1">The concept of zero knowledge is based on the idea of interactive proof systems. </span><span class="kobospan" id="kobo.990.2">In an interactive proof system, a</span><a id="_idIndexMarker894" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.991.1"> Prover tries to convince a Verifier that a statement is true by sending a series of messages to the Verifier. </span><span class="kobospan" id="kobo.991.2">The Verifier examines each message and either accepts or rejects the statement. </span><span class="kobospan" id="kobo.991.3">In a zero-knowledge proof, the Prover can convince the Verifier of the truth of the statement without revealing any other information beyond the fact that they know the statement to be true. </span><span class="kobospan" id="kobo.991.4">The central idea behind ZKPs is to show that a Prover has knowledge of some secret information, without revealing any details about </span><span><span class="kobospan" id="kobo.992.1">that information.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.993.1">For example, imagine that Alice wants to prove to Bob that she knows the value of a secret number x, without revealing the value of x itself. </span><span class="kobospan" id="kobo.993.2">With a ZKP, Alice can prove to Bob that she knows x by interacting with him in such a way that he becomes convinced that she knows the value of x, but learns nothing else </span><span><span class="kobospan" id="kobo.994.1">about it.</span></span></p>
<h2 id="_idParaDest-192" class="calibre7"><a id="_idTextAnchor201" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.995.1">Types of ZKPs</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.996.1">There are three </span><a id="_idIndexMarker895" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.997.1">main types </span><span><span class="kobospan" id="kobo.998.1">of ZPKs:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.999.1">Zero-Knowledge Proof of Knowledge</span></strong><span class="kobospan" id="kobo.1000.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1001.1">ZKPK</span></strong><span class="kobospan" id="kobo.1002.1">): In a ZKPK, the Prover proves to the Verifier that they know a particular secret without revealing any information about that secret. </span><span class="kobospan" id="kobo.1002.2">An example of this is proving that you know the password to an account without revealing the </span><span><span class="kobospan" id="kobo.1003.1">password itself.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1004.1">Zero-Knowledge Proof of Possession</span></strong><span class="kobospan" id="kobo.1005.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1006.1">ZKPP</span></strong><span class="kobospan" id="kobo.1007.1">): In a ZKPP, the Prover proves to the Verifier that they </span><a id="_idIndexMarker896" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1008.1">possess a particular item without revealing any information about the item. </span><span class="kobospan" id="kobo.1008.2">An example of this is proving that you have a valid driver’s license without revealing any personal information beyond what is already printed on </span><span><span class="kobospan" id="kobo.1009.1">the license.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1010.1">Zero-Knowledge Proof of Identity</span></strong><span class="kobospan" id="kobo.1011.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1012.1">ZKPI</span></strong><span class="kobospan" id="kobo.1013.1">): In a ZKPI, the Prover proves to the Verifier that they </span><a id="_idIndexMarker897" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1014.1">are the same person or entity that was previously identified without revealing any other information about themselves. </span><span class="kobospan" id="kobo.1014.2">An </span><a id="_idIndexMarker898" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1015.1">example of this is proving that you are the same person who previously registered for an online service without revealing any other </span><span><span class="kobospan" id="kobo.1016.1">personal information.</span></span></li>
</ul>
<h2 id="_idParaDest-193" class="calibre7"><a id="_idTextAnchor202" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1017.1">Applications of ZKPs</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1018.1">ZKPs have numerous</span><a id="_idIndexMarker899" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1019.1"> applications in cryptography, including </span><span><span class="kobospan" id="kobo.1020.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1021.1">Privacy-preserving authentication</span></strong><span class="kobospan" id="kobo.1022.1">: ZKPs can be used to authenticate a user without revealing their identity or any other </span><span><span class="kobospan" id="kobo.1023.1">personal information.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1024.1">Secure messaging</span></strong><span class="kobospan" id="kobo.1025.1">: ZKPs can be used to ensure the confidentiality and integrity of messages exchanged between two parties without revealing the content of </span><span><span class="kobospan" id="kobo.1026.1">the messages.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1027.1">Secure computation</span></strong><span class="kobospan" id="kobo.1028.1">: ZKPs can be used to prove that a computation was performed correctly without revealing any details about the computation or </span><span><span class="kobospan" id="kobo.1029.1">the inputs.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1030.1">Cryptocurrency</span></strong><span class="kobospan" id="kobo.1031.1">: ZKPs are used in some cryptocurrencies (such as Zcash) to ensure the privacy and anonymity </span><span><span class="kobospan" id="kobo.1032.1">of transactions.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1033.1">ZKPs are a powerful tool in cryptography </span><a id="_idIndexMarker900" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1034.1">that allow secure and private communication and computation. </span><span class="kobospan" id="kobo.1034.2">They have numerous applications in various fields, including finance, healthcare, and online identity verification. </span><span class="kobospan" id="kobo.1034.3">As technology continues to advance, the use of ZKPs is likely to become more widespread, helping to protect the privacy and security of individuals and </span><span><span class="kobospan" id="kobo.1035.1">organizations alike.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1036.1">The following is an example Python program that implements a ZKPK for a simple scenario where a Prover wants to prove to a Verifier that they know the value of a </span><span><span class="kobospan" id="kobo.1037.1">secret number:</span></span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.1038.1">Source </span></em><span><em class="italic"><span class="kobospan" id="kobo.1039.1">code: ZNP_Example.ipynb</span></em></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1040.1">
import random
# Set up the scenario
secret_number = 42 # The secret number the Prover wants to prove knowledge of
upper_bound = 100  # The upper bound of the possible values for the secret number
# Generate random values for the parameters used in the ZKPK
a = random.randint(1, upper_bound)  # Random value for the first parameter
b = random.randint(1, upper_bound)  # Random value for the second parameter
r = random.randint(1, upper_bound)  # Random value for the blinding factor
# Calculate the commitments
commitment_x = (a * secret_number + b) % upper_bound
commitment_r = (a * r + b) % upper_bound
# Send the commitments to the Verifier
print("Prover sends commitments: ", commitment_x, commitment_r)
# Verifier sends a random challenge value to the Prover
challenge = random.randint(0, 1)
# Prover responds with the value of the secret number or the blinding factor, depending on the challeng
if challenge == 0:
    response = secret_number
else:
    response = r
# Verifier checks the response against the commitments
if challenge == 0:
    if (a * response + b) % upper_bound == commitment_x:
        print("Prover has proven knowledge of the secret number!")
    else:
        print("Prover has failed to prove knowledge of the secret number.")
else:
    if (a * response + b) % upper_bound == commitment_r:
        print("Prover has proven knowledge of the blinding factor!")
    else:
        print("Prover has failed to prove knowledge of the blinding factor.")
Prover sends commitments: 39 94
Prover has proven knowledge of the blinding factor!</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.1041.1">In the preceding example, the Prover generates two commitments based on the secret number and a random blinding factor and sends them to the Verifier. </span><span class="kobospan" id="kobo.1041.2">The Verifier then sends a random challenge value to the Prover, and the Prover responds with either the secret number or the blinding factor, depending on the challenge. </span><span class="kobospan" id="kobo.1041.3">The Verifier checks the response against the</span><a id="_idIndexMarker901" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1042.1"> commitments and determines whether the Prover has successfully proven knowledge of the </span><span><span class="kobospan" id="kobo.1043.1">secret number.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1044.1">The following are some popular Python frameworks </span><span><span class="kobospan" id="kobo.1045.1">for ZKPs:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1046.1">PyZPK</span></strong><span class="kobospan" id="kobo.1047.1">: A Python library for constructing and verifying </span><strong class="bold"><span class="kobospan" id="kobo.1048.1">Zero-Knowledge Succinct Non-interactive Arguments of Knowledge</span></strong><span class="kobospan" id="kobo.1049.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1050.1">zk-SNARK</span></strong><span class="kobospan" id="kobo.1051.1">s) scheme. </span><span class="kobospan" id="kobo.1051.2">It provides a simple and intuitive</span><a id="_idIndexMarker902" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1052.1"> interface for building ZKPs and is designed to work well </span><a id="_idIndexMarker903" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1053.1">with other Python libraries, such as NumPy </span><span><span class="kobospan" id="kobo.1054.1">and SciPy.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1055.1">Bulletproofs-Builder</span></strong><span class="kobospan" id="kobo.1056.1">: A Python library for building and verifying bulletproofs. </span><span class="kobospan" id="kobo.1056.2">It provides a high-level interface </span><a id="_idIndexMarker904" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1057.1">for creating range proofs and other types of ZKPs. </span><span class="kobospan" id="kobo.1057.2">It is designed to be easy to use and </span><a id="_idIndexMarker905" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1058.1">can easily integrate with other </span><span><span class="kobospan" id="kobo.1059.1">Python libraries.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1060.1">starkware-libs</span></strong><span class="kobospan" id="kobo.1061.1">: A collection of Python libraries for building and verifying Scalable Transparent Argument </span><a id="_idIndexMarker906" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1062.1">of Knowledge (STARKs). </span><span class="kobospan" id="kobo.1062.2">It includes libraries for constructing STARK-friendly </span><a id="_idIndexMarker907" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1063.1">hash functions, building </span><a id="_idIndexMarker908" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1064.1">constraint systems, and performing </span><strong class="bold"><span class="kobospan" id="kobo.1065.1">Fast Fourier Transform</span></strong><span class="kobospan" id="kobo.1066.1"> (</span><span><strong class="bold"><span class="kobospan" id="kobo.1067.1">FFT</span></strong></span><span><span class="kobospan" id="kobo.1068.1">) operations.</span></span></li>
</ul>
<h1 id="_idParaDest-194" class="calibre5"><a id="_idTextAnchor203" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1069.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1070.1">In summary, in this chapter, we have covered encryption, anonymization, and de-identification techniques in detail, along with some example Python implementations and a discussion of their limitations. </span><span class="kobospan" id="kobo.1070.2">We learned about the foundations and types of HE and secure multiparty computation and saw how they help in achieving privacy when working with ML models (including applications such as the encryption of training data, test data, models, model parameters, and </span><span><span class="kobospan" id="kobo.1071.1">inference results).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1072.1">In the next chapter, we will learn more about confidential computing, why it is needed, and how it helps to protect us from privacy threats facing data in memory. </span><span class="kobospan" id="kobo.1072.2">We will also learn about securing ML models through trusted </span><span><span class="kobospan" id="kobo.1073.1">execution environments.</span></span></p>
</div>
</body></html>