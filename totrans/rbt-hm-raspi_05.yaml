- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Driving Motors with Raspberry Pi Pico
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our robot is looking ready to run. The first real test of a robot chassis is
    getting its motors to drive. This chapter will bring the robot to life, testing
    the wiring and motors, using **CircuitPython** on Raspberry Pi Pico. We will start
    with simple tests for each motor and then use them together to make movements.
    Finally, we will learn more sophisticated code to control their speed and end
    the chapter by making a path.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Driving forward and back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steering with two motors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to PWM speed control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driving along a planned path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First is the built robot, as made in the previous chapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 x fresh AA batteries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PC or laptop with a USB micro cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mu software to write our code and upload it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear floor space with a meter or so in each direction to test the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All code examples are on GitHub at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-05](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-05).
  prefs: []
  type: TYPE_NORMAL
- en: Driving forward and back
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our motors are attached, and the robot is looking ready to power up. First,
    we’ll use CircuitPython to make test code to try each motor in turn. Then, when
    we have demonstrated the motors running, we’ll make simple code to drive the motors
    straight forward and then back.
  prefs: []
  type: TYPE_NORMAL
- en: Testing each motor with CircuitPython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start driving our robot by looking at how we connected our Raspberry
    Pi Pico to our motors in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Motor connections from Raspberry Pi Pico ](img/Figure_5.01_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Motor connections from Raspberry Pi Pico
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.1* shows a closer look at the robot motor connections. On the left
    is Raspberry Pi Pico with four connections to the motor controller. They are on
    GPIO 16, 17, 18, and 19\. These connections result in the motor controller powering
    the motor via one of the motor wires. Testing each of the Pico pins should cause
    a motor to do something.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try this with some code, setting up one motor, and making it drive in
    a single direction. This example is called `motors_test_1_pin.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code looks very similar to the LED code from [*Chapter 2*](B18001_02.xhtml#_idTextAnchor041),
    *Preparing Raspberry Pi Pico*. We set `board.GP17`, connected to the `AIN1` pin
    on the motor controller, to a digital output.
  prefs: []
  type: TYPE_NORMAL
- en: The code sets `GP17` to `True`, turning it on, then waits for 0.3 seconds, and
    sets the motor pin to `False` to turn it off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type this code into `Mu` and save it to `CIRCUITPY`. For this test, prop the
    robot up so that the wheels do not contact anything. To start this file, create
    a `code.py` module too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you recall from [*Chapter 2*](B18001_02.xhtml#_idTextAnchor041), *Preparing
    Raspberry Pi Pico*, Raspberry Pi Pico will run the content of `code.py` when the
    robot starts or when you change a file on `CIRCUITPY`.
  prefs: []
  type: TYPE_NORMAL
- en: When you start this code, a motor moves for a short time and stops. The motor
    should run forward. If not, swap the motor output pins on this side. Repeat this
    exercise with `GP18` and check whether the other motor runs forward too.
  prefs: []
  type: TYPE_NORMAL
- en: How do you test this?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For all the remaining examples in the chapter, use the following procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: On the Pico (the `CIRCUITPY` drive), ensure the `code.py` file is empty; otherwise,
    it will rerun the old program until you update it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write your program and save it on your computer. You don’t want to lose it!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the program (and supporting files that have changed; we will be adding
    `robot.py` soon) onto the Pico.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the power switch is on and batteries are installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have the robot propped up on something so that the wheels don’t contact anything.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `code.py` to import the name of your program without the `.``py` extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first test of the code is seeing it run this way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run it for real, disconnect the Pico and turn off the power.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, put the robot in a clear space (the carpet or floor) and power it on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be prepared to pick it up and turn it off if it does something unexpected –
    the robot can damage itself if it drives into an obstacle without stopping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also press *Ctrl* + *C* from the REPL at any time to stop a program
    running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are some ways this could go wrong. Let’s check a few here:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `import` in `code.py` and your `motors_test_1_pin` filename do not match,
    you’ll likely get an error in the REPL and nothing will happen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the robot’s UBEC is connected but the batteries are powered down, the robot
    may try to take too much power from the USB port. If you intend to test the motors,
    ensure the robot is powered on. If not, it may be good to disconnect the UBEC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If nothing still happens, disconnect the robot, turn it off, and check the wiring
    thoroughly – there should be no hot parts in the robot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know how to test your code and make a simple example work, you
    are ready for more complicated examples.
  prefs: []
  type: TYPE_NORMAL
- en: Testing multiple pins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s extend this code to test all the motor pins in `motors_test_all_pins.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code extends the first code example to test all the motor pins. Update
    `code.py` to import this instead, and you should see each wheel turn one way and
    then the other. If you do not see movement like this, please turn off the power/disconnect
    the robot and go back to [*Chapter 4*](B18001_04.xhtml#_idTextAnchor080), *Building
    a Robot around Pico*, to carefully check the wiring.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use these motors a lot. To save us from copying all the setup code
    each time, we can put it in a new file called `robot.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you won’t have to type that again. We can rewrite `motors_test_1_pin.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can run this (remember to change `code.py`) and apply the same change to
    `motors_test_all_pins.py`.
  prefs: []
  type: TYPE_NORMAL
- en: This code demonstrates that we can move the motors, but how do we use them together?
  prefs: []
  type: TYPE_NORMAL
- en: Driving wheels in a straight line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In terms of motor direction, each motor pin controls this. Look at the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Controlling motor direction ](img/Figure_5.02_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Controlling motor direction
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows a box representing the connection to the motor and
    its pins. Beside each is **True** or **False**, signifying the state of the controlling
    pin on a Raspberry Pi Pico. The arrows show the conventional current direction
    of power to the motor. With one pin high, current flows from this pin; if it is
    low, current flows back. When we set motor pins to opposite values, current will
    flow between the motor controller outputs and a motor turns. If the motor pins
    are both low, there is no current, and the motor is turned off and can coast.
    If they are both high, the motor will stop, like brakes.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In electronics, we describe current in two ways. **Conventional current** describes
    electricity flowing from the positive terminal of a power source to the negative
    terminal. However, the actual physics shows that negatively charged electrons
    flow the other way. We will stick to using conventional current to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can put this to use driving in a straight line. When we drive both motors
    together, a robot drives in a line forward or back. For example, look at the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Driving in a straight line ](img/Figure_5.03_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Driving in a straight line
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.3* shows a forward arrow from each wheel showing the motors are
    going forward. The combined wheel movement results in the robot driving forward
    – shown by the wide arrow in front of the robot.'
  prefs: []
  type: TYPE_NORMAL
- en: The lines aren’t quite straight as motors are slightly different, and it goes
    off slightly; we call this **veer**. We’ll see how to correct this later in the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make code to drive forward – `motors_forward.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code sets both motors forward by enabling (setting to `True`) the `A1`
    and `B1` pins. It waits for 0.3 seconds (300 ms) and then stops both motors. To
    drive for longer, you can increase the time. Using time to approximately control
    distance is not very accurate though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going backward means using the `A2` and `B2` pins instead (`motors_backward.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Other than changing the pins, this code is identical.
  prefs: []
  type: TYPE_NORMAL
- en: We can now drive forward and backward, but how do we make turns?
  prefs: []
  type: TYPE_NORMAL
- en: Steering with two motors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we move one motor and not the other, the robot turns toward the wheel that
    isn’t moving. For example, look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Steering a robot with motors ](img/Figure_5.04_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Steering a robot with motors
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.4* shows two turning robots. There is a forward arrow above the
    left wheel in the first panel, showing the wheel is driving forward. The right
    wheel is stopped. A transparent arrow superimposed on this shows the turn direction
    and that this turn pivots on the right wheel. The right robot shows an opposite
    turn. A robot can turn backward in the same way by reversing a single motor instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will do more with motors, we’ll extend `robot.py` so that we can stop
    them all. Add this code at the end of `robot.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Ensure you copy this new version onto the Pico.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use our turn principle in some code – `motors_1_motor_turn.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code example is very similar to the one-pin motor test. Only the `stop()`
    command is new. We roughly control the angle of turn by timing. It is tricky but
    possible to get 90-degree turns, but they won’t be exact. Using different pins,
    we can turn using the motor on the other side, or reverse the current motor using
    the same principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about using two motors? If we drive one motor forward and the other back,
    we can make a faster tighter turn and spin on the spot. Look at the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Spinning with two motors ](img/Figure_5.05_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Spinning with two motors
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.5* shows the robot with an arrow going forward from one motor and
    back from the other. I’ve included a rotation arrow between the two wheels, showing
    the pivot for this turn. Let’s see this in code; I suggest calling it `motors_2_motor_turn.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code sets two pins high, `A1` and `B2` – you could say, diagonally opposite
    pairs. Driving `A2` and `B1` would spin the other way. Again, the timing controls
    the angle, and then we stop all the motors.
  prefs: []
  type: TYPE_NORMAL
- en: We can now move our motors, but they are on or off. However, we aren’t controlling
    the speed, and we seem to be able to do one motor turn or full spin – what about
    gentler sweeping turns? The following section will get into pulse width modulation
    and how this controls motor speeds.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to pulse width modulation speed control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pulse Width Modulation** (**PWM**) is how we control motor speeds from a
    digital control system. Instead of varying the voltage supplied to a motor, we
    use pulses to control it. The pulses are usually at a fixed rate, but the ratio
    of time-on to time-off changes. We call this the **duty cycle**. Controlling how
    much time per cycle the signal is on versus off will control the power getting
    to a motor. If the pulse is on for longer, the motor will go faster. The motor
    will go slower if the pulse is on for less time. So, at 50% time-on, the motor
    will be about 50% of its maximum speed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows visual examples of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – PWM signals ](img/Figure_5.06_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – PWM signals
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows graphs of PWM signals. The top is a signal for driving
    a motor at half speed. The pulses on and off time are the same. The *X* axis is
    the level, and the *Y* axis is for time, with a solid line for the PWM signal
    and a dashed line for the power going to the motor. This panel shows a signal
    at half speed, with the duty cycle on for half the cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The second graph shows control signals, ranging from 0 to completely on. When
    there are no pulses, this is equivalent to 0\. When it is entirely on with no
    break, this is equivalent to 100%.
  prefs: []
  type: TYPE_NORMAL
- en: PWM can be fine-grained, with the bottom graph showing a sine wave along with
    the equivalent PWM signal for this. However, it’s not smooth, as it can only change
    when there is a new pulse, and the levels also have a resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Driving fast and slow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can take advantage of this PWM system to drive the robot at different speeds.
    Let’s see how this works on a single wheel in `motors_pwm_drive_slower.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’ve gone back to setting up a pin from the board, but this
    time using `pwmio.PWMOut` instead of `DigitalIO`. We are using the motor `A1`
    pin.
  prefs: []
  type: TYPE_NORMAL
- en: We then set `duty_cycle`, the amount of on-time to its highest value. It is
    a 16-bit value, so we use 2 to the power of 16 and subtract 1 – we don’t need
    to do this calculation ourselves and can let the computer do it. This value will
    cause the motor to drive, as before, at full speed.
  prefs: []
  type: TYPE_NORMAL
- en: The code sleeps and then sets the duty cycle to 2 to the power of 15, half of
    our previous value. The motor will go at 50% speed here.
  prefs: []
  type: TYPE_NORMAL
- en: We let it run for 0.3 seconds and then set the `duty_cycle` to 0, which will
    turn off the motor. You can experiment with different values, but you may find
    the motor stalls (doesn’t move) and beeps at values lower than half speed.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the robot library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will need to apply changes to our robot library, where we set up motor pins
    as `DigitalIO` pins. We now need to use `PWMOut` to set the pins up. Here is a
    new `robot.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code swaps the `Digital IO` setup we used before and uses `PWMOut` instead.
    The `stop` function now sets the pins `duty_cycle` to zero to stop all motor pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use this to demonstrate the robot moving in `motors_convert_speed.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We use our refreshed `robot` class to set things up in this demonstration. First,
    we set a `max_speed` variable to hold the maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: Having `max_speed` makes things more convenient, as we can then multiply it
    by a fraction between 0 and 1 to get a duty cycle value – here, we set the motor
    to 80% speed for 0.3 seconds and stop. We must use the `int()` function to convert
    the result to an integer (whole number).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can move this multiplication up into the robot library. Add this code after
    the motor pins in `robot.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'First, there is max speed, as seen before, and then two variables to group
    our pins as respective motors. It means we can use pairs of pins, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This function will accept a motor (or pair of pins) as defined previously and
    then a speed between `-1` (going in reverse) and `1` (going forward).
  prefs: []
  type: TYPE_NORMAL
- en: It checks whether the speed is negative and, if so, sets a `direction` variable
    with the motor pins swapped and makes the speed positive; otherwise, it just stores
    the current motor pins as a pair in `direction`.
  prefs: []
  type: TYPE_NORMAL
- en: The next line uses the `min()` function, which returns the minimum of two values.
    Putting in `speed` and `1` will limit the speed to no more than `1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the pins stored in the `direction` variable, setting the first pin’s
    `duty_cycle` to the converted speed and the other pin to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add two more functions on `robot.py` to make this more convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These wrap the `set_speed` function, and they can now be used in your code with
    calls such as `robot.set_left(1.0)` and `robot.set_right(0.8)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use these and try a few different speeds in `motors_pwm_multispeed.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The previous example uses a `for` loop, looping over the numbers 5 to 10\. This
    means we get a `speed` variable in each loop. We divide this by 10, so we now
    get 0.5 to 1.0 and use the `robot.set_...` methods to set both motors to this
    `speed`. The program then sleeps for 0.3 seconds and loops to the next item.
  prefs: []
  type: TYPE_NORMAL
- en: It is wrapped in `try…finally` so that the program will always call `robot.stop()`,
    even if something fails in our loop; this ensures that the motors don’t keep driving.
  prefs: []
  type: TYPE_NORMAL
- en: The robot will start slowly and then speed up and stop when you run this example.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the variable motor speeds to make gentle sweeping turns too. Let’s
    see how in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Turning while moving
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can make gentle, sweeping turns by sending different speeds to each motor
    using PWM. For example, look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Robots making sweeping turns ](img/Figure_5.07_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Robots making sweeping turns
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.7* shows robots making gentle sweeping turns to the right and the
    left. The speed difference between the motor’s controls where the turn’s pivot
    is. The closer the speeds are, the wider the turn radius is. This is demonstrated
    in `motors_pwm_gentle_turn.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This example uses the same `try…finally` construct as before. It sets the left
    motor to full speed and the right to half speed, making a wide arc to the right
    for half a second. The robot then stops.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to control a robot’s motor speeds with PWM and make different
    turns. Finally, we are ready to put some of this together to make the robot drive
    in a pre-determined path on the floor.
  prefs: []
  type: TYPE_NORMAL
- en: Driving along a planned path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use our straight-line driving motions and curved turns to make an almost
    square path on the floor. We can use the helper functions we’ve made to keep this
    short.
  prefs: []
  type: TYPE_NORMAL
- en: Putting line and turn moves together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to put some of our learning together to make a simple square pattern,
    as the following diagram shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Driving a square path ](img/Figure_5.08_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Driving a square path
  prefs: []
  type: TYPE_NORMAL
- en: The figure shows a square made up of four straight lines and four turns. These
    eight instructions are four repeating sets of a straight line and then a turn.
    We will have to adjust the timing of the turn to make it close to 90 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start this code with some helpers for our motions – in `pwm_drive_square.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `straight()` function just puts both motors going forward (or back) for
    the duration. The `left()` function stops one motor and drives the other at speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use these in a main `for` loop to get the four turns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our loop counts four times using the `range()` function. We then use the `straight`
    and `left` functions with speed and duration.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the performance of this will vary greatly, depending on how fresh
    the batteries are and which surface you drive on – friction will slow motors down.
    You will likely need to adjust the relative times of the `straight` and `left`
    function uses to try and get a square.
  prefs: []
  type: TYPE_NORMAL
- en: The flaw with driving this way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ll notice that the path we planned is not quite the plan we got. Even after
    some time adjusting it, you probably got a path like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – What your path might look like ](img/Figure_5.09_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – What your path might look like
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.9* shows an exaggerated version of what you may have got. Even
    after much tweaking, the robot may have made turns slightly above or below 90
    degrees. The robot may also have veered slightly while making the straight lines.
    In the next chapter, we will pick up our first sensor, the encoders, which can
    be used for more accurate turning and to correct for veer.'
  prefs: []
  type: TYPE_NORMAL
- en: The moment you change surfaces or the batteries degrade, the robot will go off
    course further. Drawing a path like this is a start, but later in the book, we’ll
    see how to use sensors to improve the accuracy of such motion.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how a controller such as Raspberry Pi Pico uses
    a motor controller to drive motors. We saw how to control motor directions to
    drive in a straight(ish) line or make a robot turn.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned about PWM control and how to vary motor speeds, creating a handy
    `robot` Python library for our robot in the process. Next, we used this to make
    sweeping curves and build a multi-step path example with our robot. This path
    code did, however, show up some accuracy shortcomings.
  prefs: []
  type: TYPE_NORMAL
- en: We have used time to estimate how much we move our motors. However, motors don’t
    start immediately, and they can sometimes stick. In addition, some motors are
    slower than others. Therefore, we are working only with approximates. In the next
    chapter, we will look at how to measure how much the motors have turned to get
    a more accurate estimation of the robot’s movement.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now you’ve had a taste of driving the robot motors, perhaps you can practice
    your skills with the following challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: Can you make other shapes with this method, such as a triangle, or, by using
    gentle turns, drive in a circle?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the lowest PWM value before the robot stalls on two motors?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the preceding value change on one motor?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does the robot’s driving behave on a different surface, such as carpet or
    wood?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These additional resources will help you learn more about the concepts covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A great YouTube video by Afrotechmods shows more about PWM: [https://www.youtube.com/watch?v=YmPziPfaByw](https://www.youtube.com/watch?v=YmPziPfaByw).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sparkfun has an explanation of PWM at [https://learn.sparkfun.com/tutorials/pulse-width-modulation/all](https://learn.sparkfun.com/tutorials/pulse-width-modulation/all)
    where, in addition to its use of motors and servo motors, it shows how you can
    use the technique to control LED brightness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adafruit, the team that created CircuitPython, has a PWM programming tutorial
    at [https://learn.adafruit.com/circuitpython-essentials/circuitpython-pwm](https://learn.adafruit.com/circuitpython-essentials/circuitpython-pwm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My book *Learn Robotics Programming, Second Edition*, also published by Packt,
    has a chapter covering motor steering mechanisms, including the one seen here,
    with Python code for Raspberry Pi.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Interfacing Raspberry Pi Pico with Simple Sensors and Outputs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will build upon the basic Raspberry Pi Pico knowledge, adding
    more complicated devices and code to interface them. We will see how sensors can
    interface our robot more with the real world. We will add Bluetooth LE to link
    with a computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18001_06.xhtml#_idTextAnchor115), *Measuring Movement with Encoders
    on Raspberry Pi Pico*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18001_07.xhtml#_idTextAnchor139), *Planning and Shopping for
    More Devices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18001_08.xhtml#_idTextAnchor166), *Sensing Distances to Detect
    Objects with Pico*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18001_09.xhtml#_idTextAnchor189), *Teleoperating a Raspberry
    Pi Pico Robot with Bluetooth LE*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
