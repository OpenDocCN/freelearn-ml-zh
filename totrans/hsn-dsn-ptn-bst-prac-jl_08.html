<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Reusability Patterns</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will learn about several patterns related to software reusability. As you may recall from <a href="b33529b9-aabc-46cf-88eb-5d2ac885b732.xhtml">Chapter 1</a>, <em>Design Patterns and Related Principles</em>, reusability is one of the four software quality objectives that is required for building large-scale applications. Nobody wants to reinvent the wheel. The ability to reuse an existing software component saves both time and energy—an overall humanity gain! The patterns in this chapter are proven techniques that can help us improve application design, reuse existing code, and reduce overall code size.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The delegation pattern</li>
<li>The holy traits pattern</li>
<li>The parametric type pattern</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The sample source code for this chapter is located at <a href="https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter05">https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter05</a>.</p>
<p>The code in this chapter has been tested in a Julia 1.3.0 environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The delegation pattern</h1>
                </header>
            
            <article>
                
<p class="mce-root">Delegation is a pattern that is commonly applied in software engineering. The primary objective is to leverage the capabilities of an existing component by wrapping it via a <em>has-a</em> relationship.</p>
<p class="mce-root"/>
<p class="mce-root">The delegation pattern is widely adopted, even in the object-oriented programming community. In the early days of object-oriented programming, people thought that code reuse could be achieved beautifully using inheritance. However, people came to realize that this promise couldn't be completely fulfilled due to a variety of issues related to inheritance. Since then, many software engineers prefer composition over inheritance. The concept of composition is to wrap one object within another. In order to reuse existing functions, we must delegate functions calls to the wrapped object. This section will explain how delegation can be implemented in Julia.</p>
<p class="mce-root">The concept of composition is to wrap one object within another. In order to reuse existing functions, we must delegate functions calls to the wrapped object.</p>
<p class="mce-root">One way is to enhance an existing component with new features. This may sound good, but it could be challenging in practice. Consider the following situations:</p>
<ul>
<li class="mce-root">The existing component comes from a vendor product and the source code is not available. Even if the code is available, the vendor's license may not allow us to make custom changes.</li>
<li>The existing component is developed and used by another team for a mission-critical system and changes are neither welcome nor applicable for that system. </li>
<li>The existing component contains a lot of legacy code and new changes may compromise the component's stability and require a lot of testing effort.</li>
</ul>
<p>If modifying an existing component's source code is not an option, then we should at least be able to use the component via its published programming interface. That is the virtue of the delegation pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying the delegation pattern to a banking use case</h1>
                </header>
            
            <article>
                
<p><span>The delegation pattern is the idea of creating a new object by wrapping an existing one called the <em>parent</em> object. In order to reuse the object's features, the functions that have been defined for the new object can be delegated (also known as forwarded) to the parent.</span></p>
<p>Suppose that we have access to a banking library that provides some basic account management functionality. To understand how it works, let's take a look at the source code. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>A bank account has been designed with the following mutable data structure:</p>
<pre>mutable struct Account<br/>    account_number::String<br/>    balance::Float64<br/>    date_opened::Date<br/>end</pre>
<p>As part of the programming interface, the library also provides the field accessors (see <a href="6b565339-641f-444c-ad42-f8ff7998001b.xhtml">Chapter 8</a>, <em>Robustness Patterns</em>) and functions for making deposits, withdrawals, and transfers, as follows:</p>
<pre># Accessors<br/><br/>account_number(a::Account) = a.account_number<br/>balance(a::Account) = a.balance<br/>date_opened(a::Account) = a.date_opened<br/><br/># Functions<br/><br/>function deposit!(a::Account, amount::Real)<br/>    a.balance += amount<br/>    return a.balance<br/>end<br/><br/>function withdraw!(a::Account, amount::Real)<br/>    a.balance -= amount<br/>    return a.balance<br/>end<br/><br/>function transfer!(from::Account, to::Account, amount::Real)<br/>    withdraw!(from, amount)<br/>    deposit!(to, amount)<br/>    return amount<br/>end</pre>
<p>Of course, in practice, such a banking library has to be a lot more complex than what is seen here. I suspect that when money goes in and out of a bank account, there are many downstream effects such as logging an audit trail, making the new balance available on a website, sending emails to the customer, and so on.</p>
<p>Let's move on and learn how we can utilize the delegation pattern. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composing a new type that contains an existing type</h1>
                </header>
            
            <article>
                
<p>As part of a new initiative, the bank wants us to support a new savings account product, which provides daily interest for customers. Since the existing account management's functionality is critical to the bank's business and is maintained by a different team, we have decided to reuse its functionality without touching any of the existing source code.</p>
<p>First, let's create our own <kbd>SavingsAccount</kbd> data type, as follows:</p>
<pre>struct SavingsAccount<br/>    acct::Account<br/>    interest_rate::Float64<br/>    <br/>    SavingsAccount(account_number, balance, date_opened, interest_rate) = new(<br/>        Account(account_number, balance, date_opened),<br/>        interest_rate<br/>    )<br/>end</pre>
<p><span>The first field, </span><kbd>acct</kbd><span>, is used to hold an </span><kbd>Account</kbd><span> object, while the second field, </span><kbd>interest_rate</kbd><span>, contains the interest rate per annum for the account. A constructor is also defined to instantiate the object.</span></p>
<p>In order to use the underlying <kbd>Account</kbd> object, we can use a technique called <em>Delegation</em>, or <em>Method Forwarding</em>. This is where we implement the same API in <kbd>SavingsAccount</kbd> and forward the call to the underlying <kbd>Account</kbd> object whenever we want to reuse the existing functions from the underlying object. In this case, we can just forward all the field accessor functions and mutating functions from the <kbd>Account</kbd> object, as follows:</p>
<pre># Forward assessors<br/>account_number(sa::SavingsAccount) = account_number(sa.acct)<br/>balance(sa::SavingsAccount) = balance(sa.acct)<br/>date_opened(sa::SavingsAccount) = date_opened(sa.acct)<br/><br/># Forward methods<br/>deposit!(sa::SavingsAccount, amount::Real) = deposit!(sa.acct, amount)<br/><br/>withdraw!(sa::SavingsAccount, amount::Real) = withdraw!(sa.acct, amount)<br/><br/>transfer!(sa1::SavingsAccount, sa2::SavingsAccount, amount::Real) = transfer!(<br/>    sa1.acct, sa2.acct, amount)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>So far, we have successfully reused the <kbd>Account</kbd> data type, but let's not forget that we actually want to build new features in the first place. A savings account should accrue interest overnight on a daily basis. So, for the <kbd>SavingsAccount</kbd> object, we can implement a new accessor for the <kbd>interest_rate</kbd> field and a new mutating function called <kbd>accrue_daily_interest!</kbd>:</p>
<pre># new accessor<br/>interest_rate(sa::SavingsAccount) = sa.interest_rate<br/><br/># new behavior<br/>function accrue_daily_interest!(sa::SavingsAccount) <br/>    interest = balance(sa.acct) * interest_rate(sa) / 365<br/>    deposit!(sa.acct, interest)<br/>end</pre>
<p>At this time, we have created a new <kbd>SavingsAccount</kbd> object that works just like the original <kbd>Account</kbd> object, except it has the additional capability of accruing interest!</p>
<p>However, the sheer volume of these forwarding methods makes us feel a little unsatisfied. It would be nice if we didn't have to write all this code manually. Perhaps there's a better way...</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reducing boilerplate code for forwarding methods</h1>
                </header>
            
            <article>
                
<p class="mce-root">You may wonder how it would ever be worth the effort to write so much code just to forward the method calls to the parent object. Indeed, the forwarding methods serve no purpose other than passing the exact same arguments to the parent. If programmers were paid by lines of code, then this would be quite an expensive proposition, wouldn't it?</p>
<p>Fortunately, this kind of boilerplate code can be reduced greatly using macros. There are several open source solutions that can help with this situation. For demonstration purposes, we can utilize the <kbd>@forward</kbd> macro from the <kbd>Lazy.jl</kbd> package. Let's replace all the forwarding methods, as follows:</p>
<pre>using Lazy: @forward<br/><br/># Forward assessors and functions<br/>@forward SavingsAccount.acct account_number, balance, date_opened<br/>@forward SavingsAccount.acct deposit!, withdraw!<br/><br/>transfer!(from::SavingsAccount, to::SavingsAccount, amount::Real) = transfer!(<br/>    from.acct, to.acct, amount)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The usage of <kbd>@forward</kbd> is fairly straightforward. It takes two expressions as arguments. The first argument is the <kbd>SavingsAccount.acct</kbd> object that you want to forward to, while the second argument is just a tuple of function names that you wish to forward to, for example, <kbd>account_number</kbd>, <kbd>balance</kbd>, and <kbd>date_opened</kbd>. </p>
<p>Note that we are able to forward mutating functions such as <kbd>deposit!</kbd> and <kbd>withdraw!</kbd>, but we cannot do the same for <kbd>transfer!</kbd>. This is because <kbd>transfer!</kbd> requires that we forward its first and second arguments. In this case, we just keep the manual forwarding method. Nevertheless, we were able to forward five out of the six functions using just two lines of code. It's still a pretty good deal!</p>
<div class="packt_infobox">It would be possible to make more forwarding macros that take two or three arguments. In fact, there are other open source packages that support such scenarios, such as the <kbd>TypedDelegation.jl</kbd> package.</div>
<p>So, how does the <kbd>@forward</kbd> macro work? We can examine how the code gets expanded using the <kbd>@macroexpand</kbd> macro. The following is the result of the line number nodes being removed. Basically, for each method that is being forwarded (<kbd>balance</kbd> and <kbd>deposit!</kbd>), it creates the corresponding function definition with all the arguments splatted with the <kbd>args...</kbd> notation. It also throws in an <kbd>@inline</kbd> node to give the compiler a hint for better performance:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/88ad9266-859f-4b4d-933f-c516b8314b11.png" style="width:48.08em;height:23.17em;"/></p>
<p class="mce-root"/>
<div class="packt_tip packt_infobox">Inlining is a compiler optimization where a function call is <em>inlined</em> as if the code had been interpolated into the current code. It may improve performance by reducing the overhead of allocating a call stack when functions are called repeatedly.<br/>
<br/>
The <kbd>@forward</kbd> macro was implemented with only a few lines of code. You are encouraged to take a look at the source code if you are interested in metaprogramming.</div>
<p>You might be wondering why there are several funny variable names such as <kbd>#41#x</kbd> or <kbd>#42#args</kbd>. We can treat those as if they are normal variables. They are automatically generated by the compiler, and their special naming convention is chosen to avoid conflicts with other variables in the current scope.</p>
<p>Finally, it is important to understand that we may not always want to forward all the function calls to the object. What if we don't want to use 100% of the underlying features? Believe it or not, there are cases like that. For example, let's imagine that we have to support another kind of account, such as a certificate of deposits, also known as CDs. A CD is a short-term investment product that pays a higher interest than a savings account, but the funds cannot be withdrawn during the term of investment. Generally, the term of a CD could be 3 months, 6 months, or longer. Going back to our code, if we create a new <kbd>CertificateOfDepositAccount</kbd> object and reuse the <kbd>Account</kbd> object again, we wouldn't want to forward the <kbd>withdraw!</kbd> and <kbd>transfer!</kbd> methods because they are not features of CDs.</p>
<div class="packt_infobox">You might wonder how delegation differs from class inheritance in object-oriented programming languages. For example, in the Java language, all the public and protected methods from the parent class are inherited automatically. This is analogous to auto-forwarding all the methods from the parent class.<br/>
<br/>
The inability to choose what to inherit is actually one of the reasons why delegation is preferred over inheritance. For a more in-depth discussion, see <a href="97049a94-ad30-452a-bbb0-296d9438c886.xhtml">Chapter 12</a>, <em>Inheritance and Variance</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reviewing some real-life examples</h1>
                </header>
            
            <article>
                
<p>The delegation pattern is used extensively in open source packages. For example, many packages in the JuliaArrays GitHub organization implement the <kbd>AbstractArray</kbd> interface. The special array types usually contain a regular <kbd>AbstractArray</kbd> object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example 1 – the OffsetArrays.jl package</h1>
                </header>
            
            <article>
                
<p>The <kbd>OffsetArrays.jl</kbd> package allows us to define arrays with arbitrary indices rather than the standard linear or cartesian style indices. A fun example is to use a zero-based array, just like the ones you may find in other programming languages:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5a5a0185-28a8-431b-9b7c-ebc902f501f5.png" style="width:37.83em;height:13.33em;"/></p>
<p>To understand how this works, we need to dig into the source code. Let's keep things concise and review just a portion of the code:</p>
<pre>struct OffsetArray{T,N,AA&lt;:AbstractArray} &lt;: AbstractArray{T,N}<br/>    parent::AA<br/>    offsets::NTuple{N,Int}<br/>end<br/><br/>Base.parent(A::OffsetArray) = A.parent<br/><br/>Base.size(A::OffsetArray) = size(parent(A))<br/>Base.size(A::OffsetArray, d) = size(parent(A), d)<br/><br/>Base.eachindex(::IndexCartesian, A::OffsetArray) = CartesianIndices(axes(A))<br/>Base.eachindex(::IndexLinear, A::OffsetVector) = axes(A, 1)</pre>
<p><span>The </span><kbd>OffsetArray</kbd><span> data type is composed of the </span><kbd>parent</kbd><span> and </span><kbd>offsets</kbd><span> fields. In order to satisfy the </span><kbd>AbstractArray</kbd><span> interface, it implements some of the basic functions, such as </span><kbd>Base.size</kbd><span>, </span><kbd>Base.eachindex</kbd><span>, and so on. Since these functions are simple enough, the code just forwards the call to the parent object manually.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example 2 – the ScikitLearn.jl package</h1>
                </header>
            
            <article>
                
<p>Let's also take a look at the <kbd>ScikitLearn.jl</kbd> package, which defines a consistent API for fitting machine learning models and doing prediction. </p>
<p class="mce-root"/>
<p>The following is how the <kbd>FitBit</kbd> type is defined:</p>
<pre>""" `FitBit(model)` will behave just like `model`, but also supports<br/>`isfit(fb)`, which returns true IFF `fit!(model, ...)` has been called """<br/>mutable struct FitBit<br/>    model<br/>    isfit::Bool<br/>    FitBit(model) = new(model, false)<br/>end<br/><br/>function fit!(fb::FitBit, args...; kwargs...)<br/>    fit!(fb.model, args...; kwargs...)<br/>    fb.isfit = true<br/>    fb<br/>end<br/><br/>isfit(fb::FitBit) = fb.isfit</pre>
<p>Here, we can see that the <kbd>FitBit</kbd> object contains a <kbd>model</kbd> object and that it adds a new functionality that keeps track of whether a model has been fitted or not:</p>
<pre><br/>@forward FitBit.model transform, predict, predict_proba, predict_dist, get_classes</pre>
<p>It uses<span> the </span><kbd>@forward</kbd><span> </span>macro to delegate all the major functions, that is, <kbd>transform</kbd>, <kbd>predict</kbd>, <span>and so on</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Considerations</h1>
                </header>
            
            <article>
                
<p>You should keep in mind that the delegation pattern introduces a new level of indirection, which can increase code complexity and make the code more difficult to understand. We should consider some factors when deciding to use the <span>delegation</span> pattern.</p>
<p>First, how much code can you reuse from the existing component? Is it 20%, 50%, or 80%? This ought to be the very first question you ask before you consider reusing an existing component. Let's call the amount of reuse the utilization rate. Obviously, the higher the utilization rate, the better it is from a reuse perspective.</p>
<p>Second, how much development effort can be saved by reusing an existing component? <span>I</span><span>f the cost of developing the same functionality is low, then it may not be worth the effort to reuse the component and increase the complexity of extra indirection. </span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span>From the opposite angle, we should also review if</span> there is any critical business logic in the existing component. If we decide to not reuse the component, then we could end up implementing the same logic again, violating the <strong>Don't Repeat Yourself</strong> (<strong><span>DRY</span></strong>) <span>principle</span>. This means it can be a maintenance nightmare to not reuse the component.</p>
<p>Given these considerations, we should just to make a good judgment about using the delegation pattern or not. </p>
<p>Next, we will learn how to implement traits in Julia.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The holy traits pattern</h1>
                </header>
            
            <article>
                
<p>The holy traits pattern has an interesting name. Some people also call it the <strong>Tim Holy Traits Trick</strong> (<strong>THTT</strong>). As you might have guessed the pattern is named after Tim Holy, who is a long-time contributor to the Julia language and ecosystem.</p>
<p>What are traits? In a nutshell, a trait corresponds to the behavior of an object. For example, birds and butterflies can fly, so they both have the <em>CanFly</em> trait. Dolphins and turtles can swim, so they both have the <em>CanSwim</em> trait. A duck can fly and swim, so it has both the <em>CanFly</em> and <em>CanSwim</em> traits. Traits are typically binary <span>–</span> you either exhibit the trait or not <span>–</span> although that is not a mandatory requirement.</p>
<p>Why do we want traits? Traits can be used as a formal contract about how a data type can be used. For example, if an object has the <em>CanFly</em> trait, then we would be quite confident that the object has some kind of <em>fly</em> method defined. Likewise, if an object has the <em>CanSwim</em> trait, then we can probably call some kind of <em>swim</em> function.</p>
<p>Let's get back to programming. The Julia language doesn't have any built-in support for traits. However, the language is versatile enough for developers to use traits with the help of the multiple dispatch system. In this section, we will look into how this can be done with the special technique known as holy traits.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Revisiting the personal asset management use case</h1>
                </header>
            
            <article>
                
<p class="mce-root">When designing reusable software, we often create abstractions as data types and associate behaviors with them. One way to model behaviors is to leverage a type hierarchy. Following the Liskov Substitution Principle, we should be able to substitute a type with a subtype when a function is called.</p>
<p class="mce-root"/>
<p>Let's revisit the abstract type hierarchy of managing personal assets from <a href="48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml">Chapter 2</a>, <em>Modules, Packages, and Type Concepts</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/70edf4cf-52b8-4465-befc-a192a4e5473e.png" style="width:42.75em;height:18.00em;"/></p>
<p>We can define a function called <kbd>value</kbd> for determining the value of any asset. Such a function can be applied to all the types in the <kbd>Asset</kbd> hierarchy if we assume that all the asset types have some kind of monetary value attached to them. Following that line of thought, we can say that almost every asset exhibits the <em>HasValue</em> trait.</p>
<p>Sometimes, behaviors can only be applied to certain types in the hierarchy. For example, what if we want to define a <kbd>trade</kbd> function that only works with liquid investments? In that case, we would define <kbd>trade</kbd> functions for <kbd>Investment</kbd> and <kbd>Cash</kbd> but not for <kbd>House</kbd> and <kbd>Apartments</kbd>.</p>
<div class="packt_infobox">A liquid investment refers to a security instrument that can be traded easily in the open market. The investor can quickly convert a liquid instrument into cash and vice versa. In general, most investors would like a portion of their investment to be liquid in the case of an emergency.<br/>
<br/>
Investments that are not liquid are called illiquid.</div>
<p><span>Programmatically, how do we know which asset types are liquid? One way is to check the type of the object against a list of types that represent liquid investments. </span><span>Suppose that we have an array of assets and need to find out which one can be traded quickly for cash. In this situation, the code may look something like this:</span></p>
<pre>function show_tradable_assets(assets::Vector{Asset})<br/>    for asset in assets<br/>        if asset isa Investment || asset isa Cash<br/>            println("Yes, I can trade ", asset)<br/>        else<br/>            println("Sorry, ", asset, " is not tradable")<br/>        end<br/>    end<br/>end</pre>
<p>The <kbd>if</kbd> condition in the preceding code is a bit ugly, even in this toy example. If we have more types in the condition, then it gets worse. Of course, we can create a union type to make it a little better:</p>
<pre>const LiquidInvestments = Union{Investment, Cash}<br/><br/>function show_tradable_assets(assets::Vector{Asset})<br/>    for asset in assets<br/>        if asset isa LiquidInvestments<br/>            println("Yes, I can trade ", asset)<br/>        else<br/>            println("Sorry, ", asset, " is not tradable")<br/>        end<br/>    end<br/>end</pre>
<p>There are a few issues with this approach:</p>
<ul>
<li>The union type has to be updated whenever we add a new liquid asset type. This kind of maintenance is bad from a design perspective because the programmer must remember to update this union type whenever a new type is added to the system.</li>
<li>This union type is not available for extension. If other developers want to reuse our trading library, then they may want to add new asset types. However, they cannot change our definition of the union type because they do not own the source code. </li>
<li>The if-then-else logic may be repeated in many places in our source, whenever we need to do things differently for liquid and illiquid assets.</li>
</ul>
<p>These problems can be solved using the holy traits pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the holy traits pattern</h1>
                </header>
            
            <article>
                
<p>To illustrate the concept of this pattern, we will implement some functions for the personal asset data types that we developed in <a href="48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml">Chapter 2</a>, <em>Modules, Packages, and Data Type Concepts</em>. As you may recall, the abstract types for the asset type hierarchy are defined as follows:</p>
<pre>abstract type Asset end<br/><br/>abstract type Property &lt;: Asset end<br/>abstract type Investment &lt;: Asset end<br/>abstract type Cash &lt;: Asset end<br/><br/>abstract type House &lt;: Property end<br/>abstract type Apartment &lt;: Property end<br/><br/>abstract type FixedIncome &lt;: Investment end<br/>abstract type Equity &lt;: Investment end</pre>
<p><span>The <kbd>Asset</kbd> type is at the top of the hierarchy and has the <kbd>Property</kbd>, <kbd>Investment</kbd>, and <kbd>Cash</kbd> subtypes. At the next level, <kbd>House</kbd> and <kbd>Apartment</kbd> are subtypes of <kbd>Property</kbd>, while <kbd>FixedIncome</kbd> and <kbd>Equity</kbd> are subtypes of <kbd>Investment</kbd>.</span></p>
<p>Now, let's define some concrete types:</p>
<pre>struct Residence &lt;: House<br/>    location<br/>end<br/><br/>struct Stock &lt;: Equity<br/>    symbol<br/>    name<br/>end<br/><br/>struct TreasuryBill &lt;: FixedIncome<br/>    cusip<br/>end<br/><br/>struct Money &lt;: Cash<br/>    currency<br/>    amount<br/>end</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>What do we have here? Let's take a look at these concepts in more detail:</p>
<ul>
<li><span>A </span><kbd>Residence</kbd><span> is a house that someone lives in and has a location. </span></li>
<li><span>A </span><kbd>Stock</kbd><span> is an equity investment, and it is identified by a trading symbol and the name of the company. </span></li>
<li><span>A </span><kbd>TreasuryBill</kbd><span> is a short-term government-issued form of security in the United States, and it is defined with a standard identifier called CUSIP.</span></li>
<li><kbd>Money</kbd><span> is just cash, but we want to store the currency and respective amount here.</span></li>
</ul>
<p><span>Note that we have not annotated the types for the fields because they aren't important for illustrating the trait concept here.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the trait type</h1>
                </header>
            
            <article>
                
<p>When it comes to investments, we can distinguish between ones that can be sold for cash <span>easily </span>in the open market and ones that take considerably more effort and time to convert into cash. Things that can easily be converted into cash within several days are known as being <em>liquid</em>, while the hard-to-sell ones are known as being <em>illiquid</em>. For example, stocks are liquid while a residence is not.</p>
<p>The first thing we want to do is define the traits themselves:</p>
<pre>abstract type LiquidityStyle end<br/>struct IsLiquid &lt;: LiquidityStyle end<br/>struct IsIlliquid &lt;: LiquidityStyle end</pre>
<p>Traits are nothing but data types in Julia! The overall concept of the <kbd><span>LiquidityStyle</span></kbd> trait is that it's an abstract type. The specific traits here, <span><kbd>IsLiquid</kbd> and <kbd>IsIlliquid</kbd></span>, have been set up as concrete types without any fields.</p>
<div class="packt_tip">There is no standard naming convention for traits, but my research seems to indicate that package authors tend to use either <kbd>Style</kbd> or <kbd>Trait</kbd> as the suffix for trait types.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identifying traits</h1>
                </header>
            
            <article>
                
<p>The next step is to assign data types to these traits. Conveniently, Julia allows us to bulk-assign traits to an entire subtype tree using the <kbd>&lt;:</kbd> operator in the function signature:</p>
<pre># Default behavior is illiquid<br/>LiquidityStyle(::Type) = IsIlliquid()<br/><br/># Cash is always liquid<br/>LiquidityStyle(::Type{&lt;:Cash}) = IsLiquid()<br/><br/># Any subtype of Investment is liquid<br/>LiquidityStyle(::Type{&lt;:Investment}) = IsLiquid()</pre>
<p>Let's take a look at how we can interpret these three lines of code:</p>
<ul>
<li>We have chosen to make all the types illiquid by default. Note that we could have done this the other way around and made everything liquid by default. This decision is arbitrary and depends on the specific use case.</li>
<li>We have chosen to make all the subtypes of <kbd>Cash</kbd> liquid, which includes the concrete <kbd>Money</kbd><span> type. The notation of </span><kbd>::Type{&lt;:Cash}</kbd><span> indicates all the subtypes of </span><kbd>Cash</kbd><span>. </span></li>
<li>We have chosen to make all the subtypes of <kbd>Investment</kbd> liquid. This includes all the subtypes of <span><span><kbd>FixedIncome</kbd></span></span> and <kbd>Equity</kbd>, which covers <kbd>Stock</kbd> in this example.</li>
</ul>
<div class="packt_infobox"><span>You might be wondering why we don't take <kbd>::Type{&lt;: Asset}</kbd> as an argument for the default trait function. Doing so makes it more restrictive as the default value would only be available for types that are defined under the <kbd>Asset</kbd> type hierarchy.</span> <span>This may or may not be desirable, depending on how the trait is used. Either way should be fine.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing trait behavior</h1>
                </header>
            
            <article>
                
<p>Now that we can tell which types are liquid and which are not, we can define methods that take objects with those traits. First, let's do something really simple:</p>
<pre># The thing is tradable if it is liquid<br/>tradable(x::T) where {T} = tradable(LiquidityStyle(T), x)<br/>tradable(::IsLiquid, x) = true<br/>tradable(::IsIlliquid, x) = false</pre>
<p>In Julia, types are first-class citizens. The <kbd>tradable(x::T) where {T}</kbd> signature captures the type of argument as <kbd>T</kbd>. Since we have already defined the <kbd>LiquidityStyle</kbd> function, we can derive whether the passed argument exhibits the <kbd>IsLiquid</kbd> or <kbd>IsIlliquid</kbd> trait. So, the first <kbd>tradable</kbd> method simply takes the return value of <kbd>LiquidityStyle(T)</kbd> and passes it as the first argument for the other two <kbd>tradable</kbd> methods. This simple example demonstrates the dispatch effect.</p>
<p class="mce-root"/>
<p>Now, let's look at a more interesting function that exploits the same trait. Since liquid assets are easily tradable in the market, we should be able to discover their market price quickly as well. For stocks, we may call a pricing service from the stock exchange. For cash, the market price is just the currency amount. Let's see how this is coded:</p>
<pre># The thing has a market price if it is liquid<br/>marketprice(x::T) where {T} = marketprice(LiquidityStyle(T), x)<br/>marketprice(::IsLiquid, x) = error("Please implement pricing function for ", typeof(x))<br/>marketprice(::IsIlliquid, x) = error("Price for illiquid asset $x is not available.")</pre>
<p>The code's structure is the same as the <kbd>tradable</kbd> function. One method is used to determine the trait, while the other two methods implement different behaviors for the liquid and illiquid instruments. Here, both <kbd>marketprice</kbd> functions just raise an exception by calling the error function. Of course, that's not what we really want. What we should really have is a specific pricing function for the <kbd>Stock</kbd> and <kbd>Money</kbd> types. Okay; let's do just that:</p>
<pre># Sample pricing functions for Money and Stock<br/>marketprice(x::Money) = x.amount<br/>marketprice(x::Stock) = rand(200:250)</pre>
<p><span>Here, the <kbd>marketprice</kbd> method for the <kbd>Money</kbd> type just returns the amount. This is quite a simplification since, in practice, we may calculate the amount in the local currency (for example, US Dollars) from the currency and amount. As for <kbd>Stock</kbd>, we just return a random number for the purpose of testing. In reality, we would have attached this function to a stock pricing service.</span></p>
<p>For illustration purposes, we have developed the following test functions:</p>
<pre>function trait_test_cash()<br/>    cash = Money("USD", 100.00)<br/>    @show tradable(cash)<br/>    @show marketprice(cash)<br/>end<br/><br/>function trait_test_stock()<br/>    aapl = Stock("AAPL", "Apple, Inc.")<br/>    @show tradable(aapl)<br/>    @show marketprice(aapl)<br/>end<br/><br/>function trait_test_residence()<br/>    try <br/>        home = Residence("Los Angeles")<br/>        @show tradable(home) # returns false<br/>        @show marketprice(home) # exception is raised<br/>    catch ex<br/>        println(ex)<br/>    end<br/>    return true<br/>end<br/><br/>function trait_test_bond()<br/>    try<br/>        bill = TreasuryBill("123456789")<br/>        @show tradable(bill)<br/>        @show marketprice(bill) # exception is raised<br/>    catch ex<br/>        println(ex)<br/>    end<br/>    return true<br/>end<br/><br/></pre>
<p>Here's the result from the Julia REPL:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6a259e07-c52c-4a71-a10a-c2ad9bf7c6ff.png" style="width:43.58em;height:17.25em;"/></p>
<p><em>Perfect!</em> The <kbd>tradable</kbd> function has correctly identified that cash, stock, and bond are liquid and that residence is illiquid. For cash and stocks, the <kbd>marketprice</kbd> function was able to return a value, as expected. Because residence is not liquid, an error was raised. Finally, while treasury bills are liquid, an error was raised because the <kbd>marketprice</kbd> function has not been defined for the instrument.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using traits with a different type of hierarchy</h1>
                </header>
            
            <article>
                
<p>The best part of the holy trait pattern is that we can use it with any object, even when its type belongs to a different abstract type hierarchy. Let's explore the case of literature, where we may define its own type hierarchy as follows:</p>
<pre>abstract type Literature end<br/><br/>struct Book &lt;: Literature<br/>    name<br/>end</pre>
<p>Now, we can make it obey the <kbd>LiquidityStyle</kbd> trait, as follows:</p>
<pre># assign trait<br/>LiquidityStyle(::Type{Book}) = IsLiquid()<br/><br/># sample pricing function<br/>marketprice(b::Book) = 10.0</pre>
<p>Now, we can trade books, just like other tradable assets.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reviewing some common usages</h1>
                </header>
            
            <article>
                
<p>The holy traits pattern is commonly used in open source packages. Let's take a look at some examples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example 1 – Base.IteratorSize</h1>
                </header>
            
            <article>
                
<p>The Julia Base library uses traits quite extensively. An example of such a trait is<span> </span><kbd>Base.IteratorSize</kbd>. Its definition can be found using <kbd>generator.jl</kbd>:</p>
<pre>abstract type IteratorSize end<br/>struct SizeUnknown &lt;: IteratorSize end<br/>struct HasLength &lt;: IteratorSize end<br/>struct HasShape{N} &lt;: IteratorSize end<br/>struct IsInfinite &lt;: IteratorSize end</pre>
<p class="mce-root"/>
<p>This trait is slightly different from what we have learned about so far because it is not binary. The <kbd>IteratorSize</kbd> trait can be <kbd>SizeUnknown</kbd>, <kbd>HasLength</kbd>, <kbd>HasShape{N}</kbd>, or <kbd>IsInfinite</kbd>. The <kbd>IteratorSize</kbd> function is defined as follows:</p>
<pre>"""<br/>    IteratorSize(itertype::Type) -&gt; IteratorSize<br/>"""<br/>IteratorSize(x) = IteratorSize(typeof(x))<br/>IteratorSize(::Type) = HasLength() # HasLength is the default<br/><br/>IteratorSize(::Type{&lt;:AbstractArray{&lt;:Any,N}}) where {N} = HasShape{N}()<br/>IteratorSize(::Type{Generator{I,F}}) where {I,F} = IteratorSize(I)<br/><br/>IteratorSize(::Type{Any}) = SizeUnknown()</pre>
<p>Let's focus on the <kbd>IsInfinite</kbd> trait since it looks quite interesting. A few functions have been defined in <kbd>Base.Iterators</kbd> that generate infinite sequences. For example, the<span> </span><kbd>Iterators.repeated</kbd><span> </span>function can be used to generate the same value forever, and we can use the<span> </span><kbd>Iterators.take</kbd><span> </span>function to pick up the values from the sequence. Let's see how this works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6815ffba-683e-498d-ac76-7a51a6bcf17d.png" style="width:31.67em;height:9.00em;"/></p>
<p>If you look at the source code, you'll see that <kbd>Repeated</kbd> is the type of the iterator and that it is assigned the <kbd>IteratorSize</kbd> trait with <kbd>IsInfinite</kbd>:</p>
<pre>IteratorSize(::Type{&lt;:Repeated}) = IsInfinite()</pre>
<p>We can quickly test it out like so:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dc4235c2-b523-405d-92f7-dc03defe94b1.png" style="width:29.58em;height:3.83em;"/></p>
<p class="mce-root"/>
<p><em>Voila!</em> <span>It is infinite, just as we expected! </span>But how is this trait utilized? To find out how, we can look into the<span> </span><kbd>BitArray</kbd><span> </span>from the Base library, which is a space-efficient Boolean array implementation. Its constructor function can take any iterable object, such as an array:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/767f0b76-afa1-486f-a216-879594fe2b43.png" style="width:23.25em;height:9.25em;"/></p>
<p>Perhaps it isn't hard to understand that the constructor can't really work with something that is infinite in nature! Therefore, the implementation of<span> the </span><kbd>BitArray</kbd><span> </span>constructor has to take that into account. Because we can dispatch based upon the<span> </span><kbd>IteratorSize</kbd><span> </span>trait, the constructor of <kbd>BitArray</kbd> happily throws an exception when such an iterator is passed:</p>
<pre>BitArray(itr) = gen_bitarray(IteratorSize(itr), itr)<br/><br/>gen_bitarray(::IsInfinite, itr) = throw(ArgumentError("infinite-size iterable used in BitArray constructor"))</pre>
<p>To see it in action, we can call the <kbd>BitArray</kbd> constructor with the <kbd>Repeated</kbd> iterator, like so:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ed1237a4-d2f8-4272-ae10-090cc54eee43.png" style="width:36.25em;height:2.50em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example 2 – AbstractPlotting.jl ConversionTrait</h1>
                </header>
            
            <article>
                
<p><kbd>AbstractPlotting.jl</kbd> is an abstract plotting library that is part of the Makie plotting system. The source code for this library can be found at <a href="https://github.com/JuliaPlots/AbstractPlotting.jl">https://github.com/JuliaPlots/AbstractPlotting.jl</a>.</p>
<p>Let's take a look at a trait that's related to data conversion:</p>
<pre>abstract type ConversionTrait end<br/><br/>struct NoConversion &lt;: ConversionTrait end<br/>struct PointBased &lt;: ConversionTrait end<br/>struct SurfaceLike &lt;: ConversionTrait end<br/><br/># By default, there is no conversion trait for any object<br/>conversion_trait(::Type) = NoConversion()<br/>conversion_trait(::Type{&lt;: XYBased}) = PointBased()<br/>conversion_trait(::Type{&lt;: Union{Surface, Heatmap, Image}}) = SurfaceLike()</pre>
<p>It defines a <kbd>ConversionTrait</kbd> that can be used for the <kbd>convert_arguments</kbd> function. As it stands, the conversion logic can be applied to three different scenarios:</p>
<ol>
<li>No conversion. This is handled by the default trait type of <kbd>NoConversion</kbd>.</li>
<li><kbd>PointBased</kbd> conversion.</li>
<li><kbd>SurfaceLike</kbd> conversion.</li>
</ol>
<p><span>By default, the </span><kbd>convert_arguments</kbd><span> function just returns the arguments untouched when conversion is not required:</span></p>
<pre># Do not convert anything if there is no conversion trait<br/>convert_arguments(::NoConversion, args...) = args</pre>
<p>Then, various <kbd>convert_arguments</kbd> functions are defined. Here is the function for 2D plotting:</p>
<pre><em>"""</em><br/><em>    convert_arguments(P, x, y)::(Vector)</em><br/><br/><em>Takes vectors `x` and `y` and turns it into a vector of 2D points of the values</em><br/><em>from `x` and `y`.</em><br/><br/><em>`P` is the plot Type (it is optional).</em><br/><em>"""</em><br/>convert_arguments(::PointBased, x::RealVector, y::RealVector) = (Point2f0.(x, y),)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the SimpleTraits.jl package</h1>
                </header>
            
            <article>
                
<p>The <span><kbd>SimpleTraits.jl</kbd> package (<a href="https://github.com/mauro3/SimpleTraits.jl">https://github.com/mauro3/SimpleTraits.jl</a>) may be used to make programming traits a little easier.</span></p>
<p>Let's try to redo the <kbd>LiquidityStyle</kbd> example using SimpleTraits. First, define a trait called <kbd>IsLiquid</kbd>, as follows:</p>
<pre>@traitdef IsLiquid{T}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The syntax may look a little awkward since the <kbd>T</kbd> seems to be doing nothing, but it is actually required because the trait is applicable for a specific type <kbd>T</kbd>. The next thing is to assign types to this trait:</p>
<pre>@traitimpl IsLiquid{Cash}<br/>@traitimpl IsLiquid{Investment}</pre>
<p>Then, a special syntax with four colons can be used to define functions that take objects exhibiting the trait:</p>
<pre class="mce-root">@traitfn marketprice(x::::IsLiquid) = error("Please implement pricing function for ", typeof(x))<br/>@traitfn marketprice(x::::(!IsLiquid)) = error("Price for illiquid asset $x is not available.")</pre>
<p>The positive case has the argument annotated with <kbd>x::::IsLiquid</kbd>, while the negative case has the argument annotated with <kbd>x::::(!IsLiquid)</kbd>. Note that the parentheses is required so that the code can be parsed correctly. Now, we can test the functions as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f2801aeb-d3fe-4f84-907b-2b8a47ea9993.png" style="width:37.08em;height:5.25em;"/></p>
<p>As expected, both default implementations throw an error. Now, we can implement the pricing function for <kbd>Stock</kbd> and quickly test again:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/99c18709-dced-40da-9ebc-66a3cb818fe8.png" style="width:27.25em;height:7.08em;"/></p>
<p><em>Looks great!</em> As we can see, the <kbd>SimpleTrait.jl</kbd> package simplifies the process of creating traits.</p>
<p>Using traits can make your code more extendable. We must keep in mind, however, that it takes some effort to design proper traits. Documentation is also important so that anyone who wants to extend the code can understand how to utilize the predefined traits.</p>
<p>Next, we will go over parametric types, which are commonly used to extends data types easily.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The parametric type pattern</h1>
                </header>
            
            <article>
                
<p>Parametric type is a core language feature that's used to materialize data types with parameters. It is a very powerful technique because the same object structure can be reused for different data types in its fields. In this section, we will demonstrate how parametric types can be applied effectively.</p>
<p class="mce-root">When designing applications, we often create composite types to conveniently hold multiple field elements. In its simplest form, composite types only serve as the containers of fields. As we create more and more composite types, it may become clear that some of these types look almost the same. Furthermore, the functions that operate on these types may be very similar as well. <span>We could end up with a lot of boilerplate code. Wouldn't it be cool to have a template that allows us to customize a general composite type for a specific use? </span></p>
<p>Consider a trading application that supports buying and selling stocks. In the very first version, we may have the following design:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d2beab74-e6a2-48d3-bde2-3ed1e8814cbd.png" style="width:34.50em;height:10.25em;"/></p>
<div class="packt_infobox">Please beware that the notation in the preceding diagram may look a lot like <strong><span>Unified Modeling Language</span></strong> (<strong>UML</strong>). However, because Julia is not an object-oriented language, we may make certain exceptions when illustrating design concepts with these diagrams.</div>
<p>The corresponding code is as follows:</p>
<pre># Abstract type hierarchy for personal assets<br/>abstract type Asset end<br/>abstract type Investment &lt;: Asset end<br/>abstract type Equity &lt;: Investment end<br/><br/># Equity Instruments Types <br/>struct Stock &lt;: Equity<br/>    symbol::String<br/>    name::String<br/>end<br/><br/># Trading Types<br/>abstract type Trade end<br/><br/># Types (direction) of the trade<br/>@enum LongShort Long Short<br/><br/>struct StockTrade &lt;: Trade<br/>    type::LongShort<br/>    stock::Stock<br/>    quantity::Int<br/>    price::Float64<br/>end</pre>
<p>The data types we defined in the preceding code are fairly straightforward. The <kbd>LongShort</kbd> enum type is used to indicate the direction of trade—buying stock would be long, while selling stock would be short. The <kbd>@enum</kbd> macro is conveniently used to define the <kbd>Long</kbd> and <kbd>Short</kbd> constants.</p>
<p>Now, suppose that we were asked to support stock options in our next version of the software. Naively, we could define more data types, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/640576eb-5f4e-4893-b048-adb57d01372a.png" style="width:36.92em;height:16.25em;"/></p>
<p>The code is updated with additional data types, like so:</p>
<pre># Types of stock options<br/>@enum CallPut Call Put<br/><br/>struct StockOption &lt;: Equity<br/>    symbol::String<br/>    type::CallPut<br/>    strike::Float64<br/>    expiration::Date<br/>end<br/><br/>struct StockOptionTrade &lt;: Trade<br/>    type::LongShort<br/>    option::StockOption<br/>    quantity::Int<br/>    price::Float64<br/>end</pre>
<p>You might have noticed that the <kbd>StockTrade</kbd> and <kbd>StockOptionTrade</kbd> types are very similar. Such repetition is somewhat unsatisfying. It looks even worse when we define functions for these data types, as follows:</p>
<pre># Regardless of the instrument being traded, the direction of <br/># trade (long/buy or short/sell) determines the sign of the <br/># payment amount.<br/>sign(t::StockTrade) = t.type == Long ? 1 : -1<br/>sign(t::StockOptionTrade) = t.type == Long ? 1 : -1<br/><br/># market value of a trade is simply quantity times price<br/>payment(t::StockTrade) = sign(t) * t.quantity * t.price<br/>payment(t::StockOptionTrade) = sign(t) * t.quantity * t.price</pre>
<p>Both the <kbd>sign</kbd> and <kbd>payment</kbd> methods are strikingly similar for both the <kbd>StockTrade</kbd> and <kbd>StockOptionTrade</kbd> types. Perhaps it isn't hard to imagine that this cannot scale very well when we add more tradable types to the application. There has to be a better way to do this. This is where the parametric type comes to the rescue!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utilizing remove text parametric type for the stock trading app</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the trading application we described previously, we could utilize parametric types to simplify the code and make it more reusable when adding future trading instruments.</p>
<p>It is quite clear that <kbd>SingleStockTrade</kbd> and <kbd>SingleStockOptionTrade</kbd> are almost the same. In fact, even the function definitions of <kbd>sign</kbd> and <kbd>payment</kbd> are identical. In this very simple example, we only have two functions for each type. In practice, we could have many more functions, and it would become quite messy.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing parametric types</h1>
                </header>
            
            <article>
                
<p>To simplify this design, we can parameterize the type of the thing being traded. What is the thing? We can leverage the abstract type here. The supertype of <kbd>Stock</kbd> is <kbd>Equity</kbd>, while the supertype of <kbd>Equity</kbd> is <kbd>Investment</kbd>. Since we want to keep the code generic and buying/selling investment products is similar, we can choose to accept any type that is a subtype of <kbd>Investment</kbd>:</p>
<pre>struct SingleTrade{T &lt;: Investment} &lt;: Trade<br/>    type::LongShort<br/>    instrument::T<br/>    quantity::Int<br/>    price::Float64<br/>end</pre>
<p>Now, we have defined a new type called <kbd>SingleTrade</kbd>, where the underlying instrument has a type, <kbd>T</kbd><span>, where </span><kbd>T</kbd><span> can be any subtype of </span><kbd>Investment</kbd><span>. At this point, we can create trades with different kinds of instruments:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a30de09b-b1ce-4663-9c3b-89c9da1cf202.png" style="width:35.75em;height:12.75em;"/></p>
<p>These objects actually have different types—<kbd>SingleTrade{Stock}</kbd> and <kbd>SingleTrade{StockOption}</kbd>. How do they relate to each other? They are also subtypes of <kbd>SingleTrade</kbd>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1814a36b-4c1d-4615-81c7-90376daa6655.png" style="width:23.75em;height:6.17em;"/></p>
<p>Since both types are subtypes of <kbd>SingleTrade</kbd>, this allows us to define functions that apply to both types, as we will see in the next section.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing parametric methods</h1>
                </header>
            
            <article>
                
<p>In order to fully utilize the compiler's specialization feature, we should define parametric methods that also make use of the parametric type, like so:</p>
<pre># Return + or - sign for the direction of trade<br/>function sign(t::SingleTrade{T}) where {T} <br/>    return t.type == Long ? 1 : -1<br/>end<br/><br/># Calculate payment amount for the trade<br/>function payment(t::SingleTrade{T}) where {T} <br/>    return sign(t) * t.quantity * t.price<br/>end</pre>
<p>Let's test this out:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b512eb66-22b2-4aee-8e1b-94ced5c18faa.png" style="width:30.83em;height:6.67em;"/></p>
<p>But hey, we just found a little bug. The option of $3.50 seems too good to be true! When looking at buying/selling options, each option contract actually represents 100 shares of the underlying stock. Therefore, the payment amount for stock option trades needs to be multiplied by 100. To fix this, we can just implement a more specific payment method:</p>
<pre># Calculate payment amount for option trades (100 shares per contract)<br/>function payment(t::SingleTrade{StockOption})<br/>    return sign(t) * t.quantity * 100 * t.price<br/>end</pre>
<p>Now, we can test again. Due to this, the new method is only dispatched for option trades:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dc69da3d-b3d0-4159-975e-5494046a2ebf.png" style="width:28.42em;height:6.00em;"/></p>
<p><em>Voila! </em>Isn't it beautiful? We will look at a more elaborate example in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using multiple parametric type arguments</h1>
                </header>
            
            <article>
                
<p>So far, we're quite happy with our refactoring. However, our boss just called and said we have to support <em>pair trading</em> in the next release. This new request is adding yet another twist to our design!</p>
<div class="packt_infobox">Pair <span><span>trading can be used to implement a specific trading strategy, such as market-neutral trades or option strategies such as covered calls.<br/>
<br/></span></span> <strong>Market neutral</strong> trading involves buying one stock and short-selling another one at the same time. The idea is to neutralize the market's effects so that the investor can focus on picking the stocks that over-perform or under-perform relative to their peers.<br/>
<br/>
<strong>Covered call strategy</strong> involves buying a stock but selling a call option that strikes at a higher price. This allows the investor to earn an additional premium in exchange for the limited upside potential of the underlying stock.</div>
<p>This can be handled easily with parametric types. Let's create a new type called <kbd>PairTrade</kbd>:</p>
<pre>struct PairTrade{T &lt;: Investment, S &lt;: Investment} &lt;: Trade<br/>    leg1::SingleTrade{T}<br/>    leg2::SingleTrade{S}<br/>end</pre>
<p>Note that the two legs from the trade can have different types, <kbd>T</kbd> and <kbd>S</kbd>, and that they can be any subtype of <kbd>Investment</kbd>. Because we expect every <kbd>Trade</kbd> type to support the <kbd>payment</kbd> function, we can implement this easily, as follows:</p>
<pre>payment(t::PairTrade) = payment(t.leg1) + payment(t.leg2)</pre>
<p>We can reuse the <kbd>stock</kbd> and <kbd>option</kbd> objects from the previous session and create a pair trade transaction where we buy 100 shares of the stock and sell 1 option contract. The expected payment amount is $18,800 - $350 = $18,450:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a4545117-e2e8-4181-bf90-ef8c216cbd6d.png" style="width:41.92em;height:14.08em;"/></p>
<p>To appreciate how much parametric types simplified our design, imagine how many functions you would have to write if you had to create separate concrete types. In this example, since we have two possible trades in a pair trade transaction and each trade can be a stock trade or option trade, we have to support 2 x 2 = 4 different scenarios:</p>
<ul>
<li><kbd>payment(PairTradeWithStockAndStock)</kbd></li>
<li><kbd>payment(PairTradeWithStockAndStockOption)</kbd></li>
<li><kbd>payment(PairTradeWithStockOptionAndStock)</kbd></li>
<li><kbd>payment(PairTradeWithStockOptionAndStockOption)</kbd></li>
</ul>
<p>Using parametric types, we only need a single payment function that covers all scenarios.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Real-life examples</h1>
                </header>
            
            <article>
                
<p>You can find the use of parametric types in almost any open source packages. Let's go over some examples.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example 1 – the ColorTypes.jl package</h1>
                </header>
            
            <article>
                
<p><kbd>ColorTypes.jl</kbd> is a package that defines various data types that represent colors. In practice, there are many ways in which a color can be defined: <strong><span>Red-Green-Blue</span></strong> (<strong>RGB</strong>), <strong><span>Hue-Saturation-Value</span></strong> (<strong>HSV</strong>), <span>and so on</span>. Most of the time, a color can be defined using three real numbers. In the case of grayscale, only a single number is required to represent the level of darkness. To support transparent colors, an additional value can be used to store an opacity value. First, let's take a look at the type definitions:</p>
<pre><em><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">`Colorant{T,N}` is the abstract super-type of all types in ColorTypes,</span>
<span class="pl-s">and refers to both (opaque) colors and colors-with-transparency (alpha</span>
<span class="pl-s">channel) information. `T` is the element type (extractable with</span>
<span class="pl-s">`eltype`) and `N` is the number of *meaningful* entries (extractable</span>
<span class="pl-s">with `length`), that is, the number of arguments you would supply to the</span>
<span class="pl-s">constructor.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span></em>
<span class="pl-k">abstract type</span> Colorant{T,N} <span class="pl-k">end<br/><br/></span><em><span class="pl-c"># Colors (without transparency)</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">`Color{T,N}` is the abstract supertype for a color (or</span>
<span class="pl-s">grayscale) with no transparency.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span></em>
<span class="pl-k">abstract type</span> Color{T, N} <span class="pl-k">&lt;:</span> <span class="pl-c1">Colorant{T,N}</span> <span class="pl-k">end<br/><br/></span><em><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">`AbstractRGB{T}` is an abstract supertype for red/green/blue color types that</span>
<span class="pl-s">can be constructed as `C(r, g, b)` and for which the elements can be</span>
<span class="pl-s">extracted as `red(c)`, `green(c)`, `blue(c)`. You should *not* make</span>
<span class="pl-s">assumptions about internal storage order, the number of fields, or the</span>
<span class="pl-s">representation. One `AbstractRGB` color-type, `RGB24`, is not</span>
<span class="pl-s">parametric and does not have fields named `r`, `g`, `b`.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span></em>
<span class="pl-k">abstract type</span> AbstractRGB{T}      <span class="pl-k">&lt;:</span> <span class="pl-c1">Color{T,3}</span> <span class="pl-k">end</span></pre>
<p>The <kbd>Colorant{T,N}</kbd> type can represent all kinds of colors, with or without transparency. The <kbd>T</kbd> parameter represents the type of each individual value in the color definition; for example, Int, Float64, <span>and so on</span>. The <kbd>N</kbd> parameter represents the number of values in the color definition, which is usually three. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><kbd>Color{T,N}</kbd> is a subtype of <kbd>Colorant{T,N}</kbd> and represents non-transparent colors. Finally, <kbd>AbstractRGB{T}</kbd> is a subtype of <kbd>Color{T,N}</kbd>. Note that the <kbd>N</kbd> parameter is no longer needed as a parameter in <kbd>AbstractRGB{T}</kbd> because it is already defined with N=3. Now, the concrete parametric type, <kbd>RGB{T}</kbd>, is defined as follows:</p>
<pre><span class="pl-k">const</span> Fractional <span class="pl-k">=</span> Union{AbstractFloat, FixedPoint}<br/><br/><em><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">`RGB` is the standard Red-Green-Blue (sRGB) colorspace. Values of the</span>
<span class="pl-s">individual color channels range from 0 (black) to 1 (saturated). If</span>
<span class="pl-s">you want "Integer" storage types (for example, 255 for full color), use `N0f8(1)`</span>
<span class="pl-s">instead (see FixedPointNumbers).</span>
<span class="pl-s"><span class="pl-pds">"""</span></span></em>
<span class="pl-k">struct</span> RGB{T<span class="pl-k">&lt;:</span><span class="pl-c1">Fractional</span>} <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractRGB{T}</span>
    r<span class="pl-k">::</span><span class="pl-c1">T</span> <span class="pl-c"># Red [0,1]</span>
    g<span class="pl-k">::</span><span class="pl-c1">T</span> <span class="pl-c"># Green [0,1]</span>
    b<span class="pl-k">::</span><span class="pl-c1">T</span> <span class="pl-c"># Blue [0,1]</span>
    <span class="pl-en">RGB</span><span class="pl-c1">{T}</span>(r<span class="pl-k">::</span><span class="pl-c1">T</span>, g<span class="pl-k">::</span><span class="pl-c1">T</span>, b<span class="pl-k">::</span><span class="pl-c1">T</span>) <span class="pl-k">where</span> {T} <span class="pl-k">=</span> <span class="pl-c1">new</span><span class="pl-c1">{T}</span>(r, g, b)
<span class="pl-k">end<br/></span></pre>
<p>The definition of <kbd>RGB{T &lt;: Fractional}</kbd> is fairly straightforward. It contains three values of type <kbd>T</kbd>, which can be a subtype of <kbd>Fractional</kbd>. Since the <kbd>Fractional</kbd> type is defined as a union of <kbd>AbstractFloat</kbd> and <kbd>FixedPoint</kbd>, the <kbd>r</kbd>, <kbd>g</kbd>, and <kbd>b</kbd> fields may be used as any subtype of <kbd>AbstractFloat</kbd>, such as <kbd>Float64</kbd> and <kbd>Float32</kbd>, or any of the <kbd>FixedPoint</kbd> number types.</p>
<div class="packt_infobox"><kbd>FixedPoint</kbd> is a type that's defined in the <kbd>FixedPointNumbers.jl</kbd> package. Fixed-point numbers is a different way to represent real numbers than the floating-point format. More information can be found at <a href="https://github.com/JuliaMath/FixedPointNumbers.jl">https://github.com/JuliaMath/FixedPointNumbers.jl</a>.</div>
<p>If you examine the source code further, you will find that many types are defined in a similar fashion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example 2 – the NamedDims.jl package</h1>
                </header>
            
            <article>
                
<p>The <kbd>NamedDims.jl</kbd> package adds names to each dimension of a multi-dimensional array. The source code can be found at <a href="https://github.com/invenia/NamedDims.jl">https://github.com/invenia/NamedDims.jl</a>.</p>
<p class="mce-root"/>
<p>Let's take a look at the definition of <kbd>NamedDimsArray</kbd>:</p>
<pre>"""<br/>The `NamedDimsArray` constructor takes a list of names as `Symbol`s,<br/>one per dimension, and an array to wrap.<br/>"""<br/>struct NamedDimsArray{L, T, N, A&lt;:AbstractArray{T, N}} &lt;: AbstractArray{T, N}<br/>    # `L` is for labels, it should be an `NTuple{N, Symbol}`<br/>    data::A<br/>end</pre>
<p>Don't be intimidated by the signature. It is actually quite straightforward.</p>
<p><kbd>NamedDimsArray</kbd> is a subtype of the abstract array type <kbd>AbstractArray{T, N}</kbd>. It only contains a single field, <kbd>data</kbd>, which keeps track of the underlying data. Because <kbd>T</kbd> and <kbd>N</kbd> are already parameters in <kbd>A</kbd>, they also need to be specified in the signature of <kbd>NamedDimsArray</kbd>. The <kbd>L</kbd> parameter is used to keep track of the names of the dimensions. Note that <kbd>L</kbd> is not used in any of the fields but that it is conveniently stored in the type signature itself.</p>
<p>The primary constructor is defined as follows:</p>
<pre>function NamedDimsArray{L}(orig::AbstractArray{T, N}) where {L, T, N}<br/>    if !(L isa NTuple{N, Symbol})<br/>        throw(ArgumentError(<br/>            "A $N dimensional array, needs a $N-tuple of dimension names. Got: $L"<br/>        ))<br/>    end<br/>    return NamedDimsArray{L, T, N, typeof(orig)}(orig)<br/>end</pre>
<p>The function only needs to take an <kbd>AbstractArray{T,N}</kbd> that is an N-dimensional array with an element type of <kbd>T</kbd>. First, it checks if <kbd>L</kbd> contains a tuple of <kbd>N</kbd> symbols. Because type parameters are first-class, they can be examined in the body of the function. Assuming that <kbd>L</kbd> contains the right number of symbols, it just instantiates a <kbd>NamedDimsArray</kbd> using the known parameters <kbd>L</kbd>, <kbd>T</kbd>, <kbd>N</kbd>, as well as the type of the array argument.</p>
<p>It may be easier to see how it's used, so let's take a look:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/73f8eff3-cf02-4877-a6b3-839f8bb81887.png" style="width:30.58em;height:16.75em;"/></p>
<p>In the output, we can see that the type signature is <span><kbd>NamedDimsArray{(:x, :y),Int64,2,Array{Int64,2}}</kbd></span>. Matching this with the signature of the <kbd>NamedDimsArray</kbd> type, we can see that <kbd>L</kbd> is just the two-symbol tuple <kbd>(:x, :y)</kbd>, <kbd>T</kbd> is <kbd>Int64</kbd>, <kbd>N</kbd> is 2, and the underlying data is of the <kbd>Array{Int64, 2}</kbd> type.</p>
<p>Let's take a look at the <kbd>dimnames</kbd> function, which is defined as follows:</p>
<pre>dimnames(::Type{&lt;:NamedDimsArray{L}}) where L = L</pre>
<p>This function returns the dimensions tuple:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2c6ddde2-b646-4361-9ea0-1edd673a4b03.png" style="width:12.00em;height:3.25em;"/></p>
<p>Now, things are getting a little more interesting. What is <span><kbd>NamedDimsArray{L}</kbd>? Didn't we need four parameters in this type? </span>It is worth noting that a type such as <kbd>NamedDimsArray{L, T, N, A}</kbd> is actually a subtype of <kbd>NamedDimsArray{L}</kbd>. We can prove this as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9706e903-e25c-4c50-95f5-9f7458cf079a.png" style="width:39.50em;height:6.08em;"/></p>
<p class="mce-root"/>
<p>If we really want to see what <span><kbd>NamedDimsArray{L}</kbd> is, we can try the following:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9da06100-4702-4f92-a19c-01e6fe22b765.png" style="width:37.08em;height:11.58em;"/></p>
<p>What seems to be happening is that <kbd>NamedDimsArray{(:x, :y)}</kbd> is just shorthand for <kbd>NamedDimsArray{(:x, :y),T,N,A} where A&lt;:AbstractArray{T,N} where N where T</kbd>. Because this is a more general type with three unknown parameters, we can see why <kbd>NamedDimsArray{(:x, :y),Int64,2,Array{Int64,2}}</kbd> is a subtype of <span><kbd>NamedDimsArray{(:x, :y)}</kbd>.</span></p>
<p>Using parametric types is very good if we wish to reuse functionalities. We can almost view each type parameter as a "dimension". When a parametric type has two type parameters, we would have many possible subtypes based upon various combinations of each type parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have explored several patterns related to reusability. These patterns are highly valuable and can be utilized in many places within an application. In addition, people coming from an object-oriented background will probably find this chapter indispensable when it comes to designing Julia applications.</p>
<p>First, we went into great detail about the delegation pattern, which can be used to create new capabilities and lets us reuse functions from an existing object. The general technique involves defining a new data type that contains a parent object. Then, forwarding functions are defined so that we can reuse the functionalities of the parent object. We learned implementing delegation can be largely simplified by using <kbd>@forward</kbd>, which is provided by the <kbd>Lazy.jl</kbd> package.</p>
<p>Then, we examined the holy trait pattern, which is a formal way to define the behavior of objects. The idea is to define traits as native types and utilize Julia's built-in dispatch mechanism to call the right method implementation. We realize that traits are useful in making the code more extensible. We also learned that macros from the <kbd>SimpleTraits.jl</kbd> package can make trait coding easier.</p>
<p>Finally, we looked into the parametric types pattern and how it can be utilized to simplify the design of code. We learned that parametric types can reduce the size of our code. We also saw that parameters can be used in the bodies of parametric functions.</p>
<p>In the next chapter, we will discuss an important subject that attracts a lot of people to the Julia programming language <span>–</span> performance patterns!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>How does the delegation pattern work?</li>
<li>What is the purpose of traits?</li>
<li>Are traits always binary?</li>
<li>Can traits be used for objects from a different type hierarchy?</li>
<li>What are the benefits of parametric types?</li>
<li>How do we store the information of a parametric type?</li>
</ol>


            </article>

            
        </section>
    </body></html>