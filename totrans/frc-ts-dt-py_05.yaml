- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Seasonality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One quality that sets time series apart from other datasets is that very often
    – but not always – the data has a certain rhythm to it. That rhythm may be yearly,
    possibly due to the Earth’s rotation around the Sun, or daily, if rooted in the
    Earth’s rotation around its axis. The tidal cycle follows the Moon’s rotation
    around the Earth.
  prefs: []
  type: TYPE_NORMAL
- en: Traffic congestion follows the human activity cycle throughout the day and the
    5-day workweek, followed by the 2-day weekend; financial activity follows the
    quarterly business cycle. Your own body follows cycles due to your heartbeat,
    breathing rate, and circadian rhythm. On very small physical and very short temporal
    scales, the vibration of atoms is a cause of periodicity in data. Prophet calls
    these cycles **seasonalities**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about all the different types of seasonalities
    Prophet fits by default, how to add new ones, and how to control them. In particular,
    we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding additive versus multiplicative seasonality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling seasonality with the Fourier order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom seasonalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding conditional seasonalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularizing seasonality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data files and code for the examples in this chapter can be found at [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding additive versus multiplicative seasonality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our Mauna Loa example in [*Chapter 2*](B19630_02.xhtml#_idTextAnchor104),
    *Getting Started with Prophet*, the yearly seasonality was constant at all values
    along the trend line. We added the values predicted by the seasonality curve to
    the values predicted by the trend curve to arrive at our forecast. There is an
    alternative mode of seasonality, though, where we can multiply the trend curve
    by the seasonality. Take a look at this figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Additive versus multiplicative seasonality](img/Fig_5.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Additive versus multiplicative seasonality
  prefs: []
  type: TYPE_NORMAL
- en: The upper curve demonstrates additive seasonality – the dashed lines that trace
    the bounds of the seasonality are parallel because the magnitude of seasonality
    does not change, only the trend does. In the lower curve, though, these two dashed
    lines are not parallel. Where the trend is low, the spread caused by seasonality
    is low; but where the trend is high, the spread caused by seasonality is high.
    This can be modeled with multiplicative seasonality.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a concrete example using the Air Passengers dataset introduced
    in the previous chapter. This data records the number of commercial airline passengers
    per month from 1949 to 1960\. We will first model it using Prophet’s default `seasonality_mode`,
    the additive mode that we used with the Mauna Loa example, and then contrast it
    with the multiplicative mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin just as we did in the previous chapter, by importing the necessary
    libraries and loading the data into a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s continue building our model. I am calling this one `model_a` to indicate
    that it is our additive model; I’ll call the next model `model_m`, for multiplicative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When we instantiated the Prophet object, we explicitly declared `seasonality_mode`
    as `'additive'` for clarity’s sake. By default, if no `seasonality_mode` is stated,
    then Prophet will automatically select `'additive'`. Also, note that we set `yearly_seasonality=4`.
    This merely sets the **Fourier order** for the curve, but don’t worry about this
    for now – we’ll go over it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the Prophet model, we fit and predicted it just as before in
    the Mauna Loa example, and then plotted the forecast. Note that in this example,
    though, we never created a future DataFrame – if no future DataFrame is sent to
    the `predict` method, it simply creates predicted values for the historical data
    it received in the `fit` method but no future predicted values. As we are only
    interested in seeing how Prophet has handled the seasonality, we don’t need a
    future forecast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the figure we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Air passengers with additive seasonality](img/Fig_5.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Air passengers with additive seasonality
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, early in the data, in **1949**, **1951**, and **1952**, Prophet’s
    predicted values (the solid line) have large seasonal swings that are more extreme
    than the data (the dots) indicates. Later in the series, in **1958**, **1959**,
    and **1960**, Prophet’s predicted seasonality is less extreme than the data indicates.
    The seasonal spread of the data is increasing, but we have predicted it to be
    constant. That’s the mistake of choosing additive seasonality when multiplicative
    seasonality is required. Let’s run the model again, but this time, we will use
    multiplicative seasonality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We do everything the same as in the previous example, except this time, we
    set `seasonality_mode=''multiplicative''`. We can see this change reflected in
    the figure we have produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Air passengers with multiplicative seasonality](img/Fig_5.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Air passengers with multiplicative seasonality
  prefs: []
  type: TYPE_NORMAL
- en: That’s a much better fit! Now, Prophet matches the growth of the seasonality
    swings with the growth of the overall trend. Also, compare the error estimates
    between *Figure 5**.2* and *Figure 5**.3* (the light-shaded area surrounding the
    solid line). Prophet shows wider uncertainty intervals when it attempts to fit
    additive seasonality to a series of data containing multiplicative seasonality.
    Prophet knows that it does not have a good fit in the former model and is less
    certain about its predictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one last thing here I want you to note. Let me show you what it is
    by plotting the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This plots the components for `model_a` with additive seasonality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Components plot with additive seasonality](img/Fig_5.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Components plot with additive seasonality
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, let’s plot the components for `model_m`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the following plot with the plot shown in *Figure 5**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Components plot with multiplicative seasonality](img/Fig_5.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Components plot with multiplicative seasonality
  prefs: []
  type: TYPE_NORMAL
- en: They look almost identical. The trend is the same, starting in **1949** just
    above **100** and rising to just below **500** by **1961**, with a slight kink
    in **1954** where the trend accelerates. The yearly seasonality behaves as we
    might expect, with the peak number of air passengers occurring in the summer and
    smaller local peaks over the Christmas holidays and spring break. The difference
    between the two charts is the *y a*xis of the seasonality curve.
  prefs: []
  type: TYPE_NORMAL
- en: In the additive model, the *y*-axis values are absolute numbers. In the multiplicative
    model, they are a percentage. This is because, in the additive seasonality mode,
    the seasonality is modeled as an additional factor to the trend, with values simply
    being added to or subtracted from it. But in the multiplicative seasonality mode,
    the seasonality represents a relative deviation from the trend, so the magnitude
    of the seasonality effect will depend on what value the trend is predicting at
    that point; the seasonality effect is a percentage of the trend.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When your data represents a count of something over time, such as the count
    of airline passengers each month, you will very often model it with multiplicative
    seasonality. Using additive seasonality can cause negative values to be predicted
    (negative 100 passengers per month, for example, is not possible), whereas multiplicative
    seasonality will merely shrink values closer to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing additive versus multiplicative seasonality can be a bit tricky at first,
    but if you just remember the insight that the seasonality may be an absolute factor
    or a relative factor and observe whether the *spread* of the data is constant
    or not, you should have no trouble with your models.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the difference between these two seasonality modes,
    let’s apply it to a new dataset, the Divvy bike share, and continue learning about
    seasonality in Prophet.
  prefs: []
  type: TYPE_NORMAL
- en: In many examples throughout this book, we will be creating examples using data
    from the Divvy bike share program in Chicago. In the previous chapter, we used
    hourly Divvy data, but in this section, we will use daily data.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We used the hourly Divvy data in [*Chapter 4*](B19630_04.xhtml#_idTextAnchor197),
    *Handling Non-Daily Data*, to demonstrate both the *daily* component plot and
    how to work with regular gaps in data; we will use the hourly data again in this
    chapter when we look at conditional seasonalities. But otherwise, throughout this
    book, we will be using the daily Divvy data, which is presented here. In these
    cases, we don’t need the extra granularity of the hourly data, and changing to
    daily data reduces the processing time from minutes down to seconds. Furthermore,
    the daily dataset has associated weather and temperature columns, which are lacking
    in the hourly dataset, which we will use in [*Chapter 9*](B19630_09.xhtml#_idTextAnchor599),
    *Including* *Additional Regressors*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the daily Divvy data looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Number of rides per day on Divvy](img/Fig_5.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Number of rides per day on Divvy
  prefs: []
  type: TYPE_NORMAL
- en: This is count data because it represents the number of rides each day, and you
    can also see that the magnitude of the seasonality is growing with the trend (if
    we plotted those dotted lines from *Figure 5**.1*, tracing the upper and lower
    bounds of the data, the lines would diverge). As we just learned, these are an
    indication of multiplicative seasonality, so let’s be sure to set that when instantiating
    our model. We imported the necessary Python libraries in the previous example,
    so we can begin this example by loading the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This dataset contains some additional columns for weather and temperature conditions,
    which we will use to enrich our forecast in [*Chapter 9*](B19630_09.xhtml#_idTextAnchor599),
    *Including Additional Regressors*. Once we have loaded the data, we can see these
    additional columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this command in a Jupyter notebook or IPython instance reveals the
    following DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The Divvy DataFrame](img/Fig_5.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The Divvy DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, though, we only need the `date` and `rides` columns. Let’s load those
    into our Prophet DataFrame with the appropriate column names. We will work with
    `weather` and `temperature` in [*Chapter 9*](B19630_09.xhtml#_idTextAnchor599),
    *Including* *Additional Regressors*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we need to create an instance of the Prophet class before calling
    the `fit` method. Note that we are setting `seasonality_mode` to `''multiplicative''`
    because we noticed when plotting the raw data that the seasonality fluctuations
    grew with the increasing trend. After fitting the model, we will again create
    a future DataFrame, with a 1-year forecast, and then call `predict` to create
    the `forecast` DataFrame and send it to the `plot` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After running that code, you should find that Prophet has created the following
    plot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.8 – Divvy f\uFEFForecast](img/Fig_5.8.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Divvy forecast
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the predicted trend is indeed increasing along with the actual
    data and that the yearly seasonality also matches. Now, let’s plot our components
    and see what they reveal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the output plot, Prophet has isolated three components in
    this dataset: **trend**, **weekly** seasonality, and **yearly** seasonality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Divvy components plot](img/Fig_5.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Divvy components plot
  prefs: []
  type: TYPE_NORMAL
- en: By default, Prophet will identify a `'ds'` column contains at least 2 full years
    of data. `'ds'` column was less than 1 day (which does not apply in this case).
  prefs: []
  type: TYPE_NORMAL
- en: The trend linearly increases relatively rapidly for the first 2 years but then
    bends and slows slightly for the remaining 2 years, and the forecasted year continues
    to follow this slope. We can see that the Divvy network has grown in average usage
    over this period from about 3,500 rides per day in 2014 to about 8,500 per day
    by the end of 2018.
  prefs: []
  type: TYPE_NORMAL
- en: The weekly seasonality shows that there are about 30% fewer rides per day on
    the weekends – maybe all these riders are work commuters – with rides on the weekdays
    being 10-20% higher than the trend would indicate. This fits our intuition that
    weekdays and weekends could reasonably show a different pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Now, looking at the yearly seasonality reveals that rides in the summer are
    about 60% higher than the trend, while rides in the winter are 80% lower. Again,
    this also intuitively makes sense. Those work commuters are going to drive or
    take public transport when the weather gets cold and rainy.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that this yearly seasonality curve is quite *wavy*, just as we
    noticed in the previous chapter with the hourly Divvy data. You may have expected
    a much smoother curve, not one with so many inflection points. This is a result
    of our yearly seasonality being too flexible – it has too many **degrees of freedom**
    or too many mathematical parameters controlling the curve. In Prophet, the number
    of parameters controlling the seasonality curve is called the **Fourier order**.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling seasonality with the Fourier order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Seasonality is at the heart of how Prophet works, and Fourier series are used
    to model seasonality. To understand what a Fourier series is, and how the Fourier
    order relates to it, I’ll use an analogy from linear regression.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may know that increasing the order of a polynomial equation in linear regression
    will always improve your goodness of fit. For example, the simple linear regression
    equation is ![](img/B19630_05_F01.png) , with ![](img/019630_05_F02.png) being
    the slope of the line and ![](img/019630_05_F03.png) being the ![](img/019630_05_F04.png)-intercept.
    Increasing the order of your equation to, say, ![](img/019630_05_F05.png) will
    always improve your fit, at the risk of overfitting and capturing noise. You can
    always achieve an ![](img/019630_05_F06.png) value of 1 (perfect fit) by arbitrarily
    increasing the order of your polynomial equation higher and higher. The following
    figure illustrates how higher-order fits start to become quite unrealistic and
    overfit, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Linear regression with higher-order polynomials](img/Fig_5.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Linear regression with higher-order polynomials
  prefs: []
  type: TYPE_NORMAL
- en: The **Linear** solid line does get the upward trend of the data correct, but
    it seems to be missing some subtle detail. The **Quadratic** dashed line is a
    better fit (indeed, this data was simulated from a quadratic equation with random
    noise). However, the **Quintic** and **Decic** curves are overfitting to the random
    noise. If we sample some more data points from this distribution, they will most
    likely cause the **Quintic** and **Decic** curves to radically change to fit the
    new data, whereas the **Linear** and **Quadratic** curves will only shift slightly.
    We may say that the order of a polynomial is proportional to the number of bends
    the curve can have to fit the data.
  prefs: []
  type: TYPE_NORMAL
- en: A Fourier series is simply a sum of sine waves. By changing the shape of these
    individual sine waves – the amplitude, or height of the wave; the period, or distance
    from peak to peak; and the phase, or where along the length of the wave the cycle
    begins – we can create a new and very complex wave shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the linear domain, we changed the order of the polynomial to control the
    amount of flexibility the curve has, and we changed the *β* coefficients to control
    the actual shape of the curve. Similarly, in the periodic domain, we change the
    number of sine waves in our Fourier series – this is the Fourier order – to control
    the flexibility of the final curve and we (or, more accurately, Prophet’s fitting
    equations) change the amplitude, period, and phase of the individual waves to
    control the actual shape of our final curve. You can see how this summation works
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Fourier series of order 4](img/Fig_5.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Fourier series of order 4
  prefs: []
  type: TYPE_NORMAL
- en: The solid line is simply the sum of each of the four sine waves. By arbitrarily
    increasing the Fourier order in our model, we can always achieve a perfect fit
    for any set of data. But just as in the linear domain, this approach will inevitably
    lead to overfitting.
  prefs: []
  type: TYPE_NORMAL
- en: Remember in *Figure 5**.9* when we plotted the components of the Divvy forecast
    and the yearly seasonality was too wavy? This is the result of the Fourier order
    being too high. By default, Prophet fits yearly seasonality with an order of 10,
    weekly seasonality with an order of 3, and daily seasonality (if sub-daily data
    is provided, of course) with an order of 4\. Usually, these defaults work very
    well and no tuning is needed. However, in Divvy’s case, we do need to reduce the
    Fourier order of the yearly seasonality to achieve a better fit with the data.
    Let’s see how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: We already have our necessary libraries imported and the data loaded into our
    `df` DataFrame from the previous example, so to continue, we need to instantiate
    a new Prophet object with a modified yearly seasonality. As before, we will set
    the seasonality mode to multiplicative, but this time, we will include the `yearly_seasonality`
    argument and set it to `4`. This is where we set the Fourier order.
  prefs: []
  type: TYPE_NORMAL
- en: You may experiment with different values on your own; I have found `4` to provide
    a clean curve without much flexibility in most cases, which is what I want here.
    Similarly, if we wanted to change the Fourier order of `weekly_seasonality` or
    `daily_seasonality`, we would do so here.
  prefs: []
  type: TYPE_NORMAL
- en: 'After instantiating our model, we merely need to fit it to the data to plot
    the seasonality. There is no need to predict in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use a new function here to plot just the yearly component – the `plot_yearly`
    function from Prophet’s `plot` package. We need to import it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is also a `plot_weekly` function, which operates much the same
    way. Both functions require the first argument to be the model; here, we will
    also include the optional figure size argument so that it matches the scale of
    our previous plot contained in *Figure 5**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare this output with the yearly seasonality curve in *Figure 5**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Divvy yearly seasonality with a Fourier order of 4](img/Fig_5.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Divvy yearly seasonality with a Fourier order of 4
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully eliminated the waviness of our previous attempt, while
    still maintaining the clear shape of the seasonality. This seems much more reasonable!
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have only been working with Prophet’s default seasonalities. However,
    there are many cyclic datasets out there with periods that don’t fall neatly into
    the yearly, weekly, or daily seasonality bins. Prophet supports custom seasonalities
    precisely for this purpose. Let’s check them out in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom seasonalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, the only seasonalities we have worked with are the defaults in Prophet:
    yearly, weekly, and daily. But there is no reason to limit ourselves to these
    seasonalities. If your data contains a cycle that is either longer or shorter
    than the 365.25-day yearly cycle, the 7-day weekly cycle, or the 1-day daily cycle,
    Prophet makes it easy to model this seasonality yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: A great example of a non-standard seasonality is the 11-year cycle of sunspots.
    Sunspots are regions on the Sun’s surface that temporarily exhibit a much-reduced
    temperature, and hence appear much darker than surrounding areas.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning in approximately 1609, Galileo Galilei began systematic observation
    of sunspots and over the last 400+ years, this phenomenon has been constantly
    recorded. Sunspots represent the longest continuously recorded time series of
    any natural phenomenon. Through these observations, scientists have identified
    a quasi-periodic cycle of 11 years during which the frequency of sunspot occurrences
    varies. They say *quasi*-periodic because the cycle length seems to vary from
    cycle to cycle – it isn’t perfectly 11 years each time. The average cycle length
    is 11 years, though, so that is what we will use to model it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Solar Influences Data analysis Center** (**SIDC**), a department of the
    Royal Observatory of Belgium in Brussels, provides a dataset of sunspot activity
    from 1750 to the present day in their **World Data Center – Sunspot Index and
    Long-term Solar Observations** (**WDC-SILSO**) project. This dataset will be a
    good demonstration of how to add a new seasonality to Prophet. We will begin by
    loading our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s visualize this data to see how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Number of sunspots per month](img/Fig_5.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Number of sunspots per month
  prefs: []
  type: TYPE_NORMAL
- en: The data appears rather noisy; there appear to be several outliers and the cycle
    is not perfectly clean. There is quite a lot of variation in the peak of each
    cycle. To see how Prophet will handle this data, we first need to instantiate
    our model. This is count data, so we will choose multiplicative seasonality.
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration we will take is that the Sun is so large that it hardly
    feels the minuscule tug of Earth’s gravity as we orbit around our star; therefore,
    the Sun does not experience what we would call a yearly seasonality at all. We
    will instruct Prophet not to attempt to fit a yearly seasonality. Prophet won’t
    attempt a weekly or daily seasonality because we are providing monthly data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned how to adjust the Fourier order of the yearly seasonality earlier
    in this chapter by passing an integer to the `yearly_seasonality` argument. This
    is the same argument we use to turn off a default seasonality; simply pass a Boolean
    instead. We pass `yearly_seasonality=False` to instruct Prophet not to fit yearly
    seasonality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once our model has been instantiated, we can add seasonalities. We can do this
    with the `add_seasonality` method. This method requires that we pass arguments
    for the name of the seasonality (we’ll call this one `''11-year cycle''`), the
    period (11 years times 365.25 days, as `period` is stated in days), and the Fourier
    order (we’ll use `5` in this case, but feel free to experiment). This is how it
    all looks together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Stating the period can be tricky; just remember that it is always counted in
    days. So, a seasonality longer than a day will have a number greater than 1 and
    a seasonality shorter than a day will have a period less than 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of this example is exactly as in previous ones; we fit on the training
    DataFrame, create a future DataFrame, and then predict on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s inspect the components plot to see what we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Sunspots components plot](img/Fig_5.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Sunspots components plot
  prefs: []
  type: TYPE_NORMAL
- en: The plot shows just the trend and the 11-year cycle, which is exactly what we
    expected. The trend has a sawtooth shape; in fact, scientists have named that
    trough around **1814** the *Dalton Minimum*, named after the English meteorologist
    John Dalton. The peak during the 1950s is called the *Modern Maximum*. But it’s
    the 11-year cycle that we’re interested in here.
  prefs: []
  type: TYPE_NORMAL
- en: With this irregular cycle, Prophet plots the *x* axis in days, so each tick
    is about 1.5 years later than the previous tick. The whole cycle is indeed 11
    years. We can see that the low point is a bit *flatter* than the high point and
    has about 60% fewer sunspots than the average. The high point sees about 80% more
    sunspots than average.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see all of the seasonalities that your model currently has, as well as the
    parameters controlling that seasonality, simply call the `seasonalities` attribute
    of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs a dictionary where the keys are the names of the seasonalities
    and the values are the parameters. In this example, where we only have one seasonality,
    this is the output dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When specifying a period for your seasonality, it is always specified in days.
    So, a 10-year seasonality will have a period of 10 (years) x 365.25 (days per
    year) = 3652.5 days. An hourly seasonality would be 1 (day) / 24 (hours per day)
    = 0.04167 days.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to confuse the period of seasonality with the period used in
    `make_future_dataframe`. The period in seasonality is always specified in days,
    while the period in `make_future_dataframe` is specified by the `freq` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a seasonality to Prophet that doesn’t exist in the data can cause Prophet
    to be very slow to fit, as it struggles to find a pattern where none exists. This
    can harm your forecast as Prophet will eventually fit the non-existent seasonality
    to noise. However, other seasonalities you may find yourself frequently adding
    include an hourly seasonality, if your data is measured per minute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Seasonality for the quarterly business cycle would be created in the following
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That’s how you add custom seasonalities! We’ll be using this `add_seasonality`
    method a bit more in this chapter, starting with the next section about seasonalities
    that depend on other factors.
  prefs: []
  type: TYPE_NORMAL
- en: Adding conditional seasonalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose you work for a utility company in a college town and are tasked with
    forecasting the electricity usage for the coming year. The electricity usage is
    going to depend on the population of the town to some extent, and as a college
    town, thousands of students are only temporary residents! How do you set up Prophet
    to handle this scenario? Conditional seasonalities exist for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional seasonalities are those that are, in effect, for only a portion
    of the dates in the training and future DataFrames. A **conditional seasonality**
    must have a cycle that is shorter than the period in which it is active. So, for
    example, it wouldn’t make sense to have a yearly seasonality that is active for
    just a few months.
  prefs: []
  type: TYPE_NORMAL
- en: Forecasting electricity usage in the college town would require you to set up
    either daily or weekly seasonalities – and possibly even both; depending on the
    usage patterns, one daily/weekly seasonality for the summer months when students
    have returned to their hometowns and another daily/weekly seasonality for the
    rest of the year. Ideally, the conditional seasonality would have at least two
    full cycles each time it is active.
  prefs: []
  type: TYPE_NORMAL
- en: To learn how to build a conditional seasonality, we will go back to the hourly
    Divvy data that we explored in the previous chapter. Based on the weekly seasonality
    we observed in that example, we know ridership is significantly lower on weekends
    than on weekdays, suggesting most riders are commuting to work.
  prefs: []
  type: TYPE_NORMAL
- en: We saw in the daily seasonality plot that ridership has usage peaks around 8
    a.m. and 6 p.m., during the morning and evening rush hours. This may lead you
    to suspect that the usage throughout the day will follow different patterns on
    a weekday versus the weekend. That is, maybe those peaks we see at 8 a.m.
  prefs: []
  type: TYPE_NORMAL
- en: and 6 p.m. and the midday trough will all disappear on weekends, with activity
    levels more even throughout the day. To test this hypothesis, let’s build a forecast
    model using different daily seasonalities for weekends than for weekdays.
  prefs: []
  type: TYPE_NORMAL
- en: The basic procedure for adding this conditional seasonality is to add new Boolean
    columns to your training DataFrame (and later, matching columns in the future
    DataFrame) indicating whether that row is a weekend or weekday. Then, disable
    the default weekly seasonality and add two new weekly seasonalities that specify
    those new Boolean columns as conditions. Let’s see how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the necessary libraries already loaded, so to begin, we need to create
    our Prophet DataFrame using the Divvy hourly data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this is where we identify the condition for our seasonality. Let’s create
    a function that outputs `True` if the given date is on a weekend and `False` otherwise.
    Then, we’ll use the `apply` method from `pandas` to create a new column for weekends
    and use the tilde (`~`) operator to take the inverse results for another new column
    for weekdays. Finally, let’s output the first few rows of our DataFrame at this
    point just so that we can see what we’ve got:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If your functions correctly identified the days, you should see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – The Divvy conditional seasonality DataFrame](img/Fig_5.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – The Divvy conditional seasonality DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'January 1, 2014 was a Wednesday, so that output matches what we would expect.
    Next, we need to instantiate our model. Using what we learned earlier in this
    chapter, we will set the seasonality mode to `multiplicative`, as this Divvy data
    represents count values. We will also set the Fourier order of both yearly and
    weekly seasonalities to `6`; my testing showed that to be a good value on this
    dataset. Finally, because we are adding conditional daily seasonalities, we will
    disable the default daily seasonality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To create conditional seasonalities, we will use the same `add_seasonality`
    method that we learned about while modeling the sunspot cycle, but in this case,
    we will use the optional `condition_name` argument to specify that the new seasonality
    is conditional.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `condition_name` argument must be passed the name of a column in the training
    DataFrame and consist of Boolean values identifying which rows to apply the seasonality
    to – our `weekend` and `weekday` columns. Just as we did in the sunspots example,
    we also need to name the seasonality and identify both the period and Fourier
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That’s it for setting up the model! Next, we will fit the model on our training
    data and create the `future` DataFrame just as before, being careful to set the
    frequency to *hourly* now that we are using hourly data. The last step in setting
    up conditional seasonalities is to identify where in the future DataFrame the
    condition will apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already created the `is_weekend` function and applied it to our training
    DataFrame, `df`. We simply need to repeat that procedure on the `future` DataFrame
    before calling `predict` to create our forecast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We named our two conditional seasonalities `''daily_weekend''` and `''daily_weekday''`,
    so let’s import the `plot_seasonality` function, which we discovered in the previous
    chapter, and plot these two seasonalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything ran correctly, you should have two new plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Daily weekday component plot](img/Fig_5.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – Daily weekday component plot
  prefs: []
  type: TYPE_NORMAL
- en: 'On weekdays, the trend appears much the same as we saw when we used the default
    daily seasonality – a peak around 8 a.m., another peak around 6 p.m., and a small
    hump just after midnight. We hypothesized that weekends would see a much different
    pattern, though. Let’s look at the plot to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Daily weekend component plot](img/Fig_5.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Daily weekend component plot
  prefs: []
  type: TYPE_NORMAL
- en: And indeed, we do see a difference! As your intuition might have suggested,
    on the weekends, Divvy riders tend to get a later start than on weekdays, with
    a gradual increase in ridership up until noon and then a gradual decrease to midnight.
    There is no midday slump as we saw on working days.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far in this chapter, you used the Air Passengers data to learn the difference
    between additive and multiplicative seasonality. Later, you used the Divvy data
    to learn how to add custom seasonalities and conditional seasonalities. You also
    used the Divvy data to discover the Fourier order and learned how to control the
    flexibility of the seasonality curve. However, there is another lever Prophet
    makes available to you to control seasonality: regularization.'
  prefs: []
  type: TYPE_NORMAL
- en: Regularizing seasonality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, when solving a problem with machine learning, the data involved is so
    complex that a simple model just isn’t powerful enough to capture the full subtlety
    of the patterns to be found. The simple model tends to **underfit** the data.
    In contrast, a more complicated model with many parameters and great flexibility
    can tend to **overfit** the data. It is not always easy, or possible, to use a
    simpler model. In these cases, **regularization** is a good technique to use to
    control overfitting.
  prefs: []
  type: TYPE_NORMAL
- en: Prophet is such a powerful forecasting tool that without care, it can sometimes
    be very easy to overfit the data. That’s why understanding Prophet’s regularization
    parameters can be quite useful.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: A model is said to be *underfit* if it does not fully capture the true relationship
    between the input features and the output features. Performance is low on both
    the training data and any unseen testing data.
  prefs: []
  type: TYPE_NORMAL
- en: A model is said to be *overfit* if it goes beyond capturing the true relationship
    and begins to capture random trends in the noise of the data. Performance can
    be very high on the training data but low on the unseen testing data.
  prefs: []
  type: TYPE_NORMAL
- en: A model with a good fit will perform equally well on both training and testing
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regularization is a technique for controlling overfitting by forcing a model
    to be less flexible. For example, in *Figure 5**.18*, I simulated a set of points
    with random noise (the true relationship I used is ![](img/019630_05_F07.png)))
    and fit two lines using 8th-degree polynomial regression (in reality, you would
    rarely choose such a high order for a regression model; I am using it here merely
    to exaggerate the point). One line is not regularized at all, and the other is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Regularization effects](img/Fig_5.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – Regularization effects
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the plot, the unregularized line is overfit and wiggles around
    the true relationship while attempting to fit to the noise. By regularizing, in
    contrast, the flexibility of the line is constrained and it is forced to trace
    out a much smoother curve. With the true curve essentially being ![](img/019630_05_F08.png)
    , it is clear that the regularized line, while still not perfect, does a better
    job of approximating the relationship and will perform better on new data.
  prefs: []
  type: TYPE_NORMAL
- en: The full Prophet package has several adjustable parameters for regularization.
    For seasonality, that parameter is called the prior scale.
  prefs: []
  type: TYPE_NORMAL
- en: In statistics, you may have an uncertain quantity that you intend to find the
    value of. The **prior probability distribution**, often just called a prior, of
    that quantity is the probability distribution of values you would expect *prior
    to* learning additional information.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say I ask you to guess the height of a specific human male.
    In your mind, you imagine all the likely heights of males. That range of heights
    is the prior probability distribution. Next, I tell you that the male is an NBA
    basketball player. You know basketball players are typically much taller than
    the average male, so you update that distribution to skew more toward tall heights
    because the additional information I provided you with better informs your guess.
  prefs: []
  type: TYPE_NORMAL
- en: The prior is your starting point, what you believe to be true before receiving
    additional information. Let’s learn how to apply this idea to seasonality in Prophet.
  prefs: []
  type: TYPE_NORMAL
- en: Global seasonality regularization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first way to apply seasonality regularization is globally, which affects
    all the seasonalities in your model equally. `seasonality_prior_scale` is an attribute
    of your Prophet model instance and is set when you instantiate your model. If
    you do not set it, the default will be `10`. Reducing this number will apply more
    regularization, which will rein in your model’s seasonalities. Let’s see this
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the Divvy daily data in this example, so we need to begin by loading
    it into our Prophet DataFrame, as the necessary libraries should already be loaded
    from previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to instantiate our model, setting the seasonality mode to `multiplicative`.
    While learning about Fourier order, you went through a forecast with this dataset
    using the default `seasonality_prior_scale` value of `10`. So, let’s use a prior
    scale this time around of `0.01`. We also found the yearly seasonality to be better
    modeled with a Fourier order of `4`, so we’ll set that as well. You can refer
    back to *Figure 5**.8* and *Figure 5**.9* to see the unregularized model for comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With the regularization set, all that is left to do is complete the model,
    as we did earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we will look at the forecast, and then the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Regularized forecast](img/Fig_5.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – Regularized forecast
  prefs: []
  type: TYPE_NORMAL
- en: Comparing *Figure 5**.19* with *Figure 5**.8* shows that the seasonal swings
    in our forecast have indeed been dampened. Both the annual seasonality and the
    weekly seasonality show less variation. The uncertainty intervals between the
    two models are roughly the same, though, because the variance in the data is now
    handled in the Prophet model’s noise term instead of the seasonality term.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the components plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Regularized components plot](img/Fig_5.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – Regularized components plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparing this figure with *Figure 5**.9*, we can see that the trend is very
    similar. We only constrained the seasonality, not the trend. The trend did change
    a bit (the peak value is a bit higher) because Prophet is attempting to capture
    some of the seasonal variations with the trend, but the shape is nearly identical.
    The weekly and yearly seasonalities appear the same, but their *y* axes show that
    the magnitudes have been reduced in the range of one-third to one-quarter of their
    regularized levels. This is the effect of seasonality regularization: it reduces
    the magnitude of the curve’s values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the effect of different seasonality prior scales, let’s compare
    the yearly and weekly seasonality curves of this dataset when modeled with different
    prior scales. First, here is the yearly seasonality plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Yearly seasonality with different prior scales](img/Fig_5.21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – Yearly seasonality with different prior scales
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is the weekly seasonality plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Weekly seasonality with different prior scales](img/Fig_5.22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22 – Weekly seasonality with different prior scales
  prefs: []
  type: TYPE_NORMAL
- en: The solid line in both plots is the default scale of `10`; the dashed line and
    dashed-dotted line show increasing regularization amounts. Whereas modifying the
    Fourier order helped control the seasonality curve by reducing the number of bends
    it was allowed to take, modifying the seasonality prior scale helps control seasonality
    by reducing the amount of variation it can achieve.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to regularize all seasonalities at the same
    time. Next, learn see how to regularize the seasonalities individually.
  prefs: []
  type: TYPE_NORMAL
- en: Local seasonality regularization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say that you are happy with the yearly seasonality curve with the default
    regularization setting, but your weekly curve is too extreme and overfitting.
    In that case, you can use the `add_seasonality` method to create a new weekly
    seasonality with a custom prior scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue and instantiate a new model, again with `multiplicative` seasonality
    and a Fourier order of `4` applied to the yearly seasonality. This time, though,
    we will be adding a new weekly seasonality, so let’s remove the default by setting
    it to `False` while instantiating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you learned in the *Adding custom seasonalities* section, we will now add
    a seasonality with a period of `7` days and name it `''weekly''`. We are happy
    with the default weekly Fourier order of `4`, so we’ll use that again here, but
    we want more regularization than is the default, so we will use the `prior_scale`
    argument to set it to `0.01`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as I hope is becoming second nature to you, we will fit the model and
    predict on the future DataFrame. Let’s just plot the components this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this plot, which looks nearly identical to *Figure 5**.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Weekly regularized components plot](img/Fig_5.23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.23 – Weekly regularized components plot
  prefs: []
  type: TYPE_NORMAL
- en: You’ll now see that the magnitude of the unregularized yearly seasonality matches
    that of *Figure 5**.9*, but the regularized weekly seasonality is reduced by about
    half, as expected. All of your seasonalities can have different regularization
    strengths applied, simply with repeated `add_seasonality` calls. Reasonable values
    for these prior scales range from about 10 down to around 0.01.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Seasonality truly is the heart of Prophet. This chapter covered a lot of ground;
    the foundations you learned here will be used throughout the remaining chapters
    of this book. Indeed, almost any model you build in Prophet will have seasonality
    considerations, whereas many of the upcoming chapters cover special cases that
    may or may not apply to your specific problem.
  prefs: []
  type: TYPE_NORMAL
- en: You started this chapter by learning the difference between additive and multiplicative
    seasonality, and how to identify whether your dataset features one or the other.
    We then briefly discussed the Fourier series and demonstrated how a partial Fourier
    sum can build a very complex periodic curve. Using these ideas, you learned how
    setting the Fourier order of a seasonality can be used to control its shape by
    allowing either more or less freedom to bend along its path.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you modeled the 11-year cycle of sunspots and learned how to add custom
    seasonalities. These custom seasonalities came into use again when you learned
    how to model the different weekday and weekend behaviors of riders on Divvy’s
    network using conditional seasonalities. Finally, we looked at regularization
    techniques, both globally as applied to all seasonalities together and locally,
    using yet again the custom seasonalities lesson to apply regularization to just
    the weekly seasonality alone.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn all about holidays in the Prophet package,
    which, among many other topics, will also include more detail about regularization
    as it applies to Prophet.
  prefs: []
  type: TYPE_NORMAL
