- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Seasonality
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One quality that sets time series apart from other datasets is that very often
    – but not always – the data has a certain rhythm to it. That rhythm may be yearly,
    possibly due to the Earth’s rotation around the Sun, or daily, if rooted in the
    Earth’s rotation around its axis. The tidal cycle follows the Moon’s rotation
    around the Earth.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Traffic congestion follows the human activity cycle throughout the day and the
    5-day workweek, followed by the 2-day weekend; financial activity follows the
    quarterly business cycle. Your own body follows cycles due to your heartbeat,
    breathing rate, and circadian rhythm. On very small physical and very short temporal
    scales, the vibration of atoms is a cause of periodicity in data. Prophet calls
    these cycles **seasonalities**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about all the different types of seasonalities
    Prophet fits by default, how to add new ones, and how to control them. In particular,
    we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Understanding additive versus multiplicative seasonality
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling seasonality with the Fourier order
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom seasonalities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding conditional seasonalities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularizing seasonality
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data files and code for the examples in this chapter can be found at [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Understanding additive versus multiplicative seasonality
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our Mauna Loa example in [*Chapter 2*](B19630_02.xhtml#_idTextAnchor104),
    *Getting Started with Prophet*, the yearly seasonality was constant at all values
    along the trend line. We added the values predicted by the seasonality curve to
    the values predicted by the trend curve to arrive at our forecast. There is an
    alternative mode of seasonality, though, where we can multiply the trend curve
    by the seasonality. Take a look at this figure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Additive versus multiplicative seasonality](img/Fig_5.1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Additive versus multiplicative seasonality
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The upper curve demonstrates additive seasonality – the dashed lines that trace
    the bounds of the seasonality are parallel because the magnitude of seasonality
    does not change, only the trend does. In the lower curve, though, these two dashed
    lines are not parallel. Where the trend is low, the spread caused by seasonality
    is low; but where the trend is high, the spread caused by seasonality is high.
    This can be modeled with multiplicative seasonality.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a concrete example using the Air Passengers dataset introduced
    in the previous chapter. This data records the number of commercial airline passengers
    per month from 1949 to 1960\. We will first model it using Prophet’s default `seasonality_mode`,
    the additive mode that we used with the Mauna Loa example, and then contrast it
    with the multiplicative mode.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin just as we did in the previous chapter, by importing the necessary
    libraries and loading the data into a DataFrame:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s continue building our model. I am calling this one `model_a` to indicate
    that it is our additive model; I’ll call the next model `model_m`, for multiplicative:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we instantiated the Prophet object, we explicitly declared `seasonality_mode`
    as `'additive'` for clarity’s sake. By default, if no `seasonality_mode` is stated,
    then Prophet will automatically select `'additive'`. Also, note that we set `yearly_seasonality=4`.
    This merely sets the **Fourier order** for the curve, but don’t worry about this
    for now – we’ll go over it in the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: After creating the Prophet model, we fit and predicted it just as before in
    the Mauna Loa example, and then plotted the forecast. Note that in this example,
    though, we never created a future DataFrame – if no future DataFrame is sent to
    the `predict` method, it simply creates predicted values for the historical data
    it received in the `fit` method but no future predicted values. As we are only
    interested in seeing how Prophet has handled the seasonality, we don’t need a
    future forecast.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the figure we just created:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Air passengers with additive seasonality](img/Fig_5.2.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Air passengers with additive seasonality
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, early in the data, in **1949**, **1951**, and **1952**, Prophet’s
    predicted values (the solid line) have large seasonal swings that are more extreme
    than the data (the dots) indicates. Later in the series, in **1958**, **1959**,
    and **1960**, Prophet’s predicted seasonality is less extreme than the data indicates.
    The seasonal spread of the data is increasing, but we have predicted it to be
    constant. That’s the mistake of choosing additive seasonality when multiplicative
    seasonality is required. Let’s run the model again, but this time, we will use
    multiplicative seasonality:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We do everything the same as in the previous example, except this time, we
    set `seasonality_mode=''multiplicative''`. We can see this change reflected in
    the figure we have produced:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Air passengers with multiplicative seasonality](img/Fig_5.3.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Air passengers with multiplicative seasonality
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: That’s a much better fit! Now, Prophet matches the growth of the seasonality
    swings with the growth of the overall trend. Also, compare the error estimates
    between *Figure 5**.2* and *Figure 5**.3* (the light-shaded area surrounding the
    solid line). Prophet shows wider uncertainty intervals when it attempts to fit
    additive seasonality to a series of data containing multiplicative seasonality.
    Prophet knows that it does not have a good fit in the former model and is less
    certain about its predictions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one last thing here I want you to note. Let me show you what it is
    by plotting the components:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This plots the components for `model_a` with additive seasonality:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Components plot with additive seasonality](img/Fig_5.4.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Components plot with additive seasonality
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, let’s plot the components for `model_m`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Compare the following plot with the plot shown in *Figure 5**.4*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Components plot with multiplicative seasonality](img/Fig_5.5.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Components plot with multiplicative seasonality
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: They look almost identical. The trend is the same, starting in **1949** just
    above **100** and rising to just below **500** by **1961**, with a slight kink
    in **1954** where the trend accelerates. The yearly seasonality behaves as we
    might expect, with the peak number of air passengers occurring in the summer and
    smaller local peaks over the Christmas holidays and spring break. The difference
    between the two charts is the *y a*xis of the seasonality curve.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: In the additive model, the *y*-axis values are absolute numbers. In the multiplicative
    model, they are a percentage. This is because, in the additive seasonality mode,
    the seasonality is modeled as an additional factor to the trend, with values simply
    being added to or subtracted from it. But in the multiplicative seasonality mode,
    the seasonality represents a relative deviation from the trend, so the magnitude
    of the seasonality effect will depend on what value the trend is predicting at
    that point; the seasonality effect is a percentage of the trend.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: When your data represents a count of something over time, such as the count
    of airline passengers each month, you will very often model it with multiplicative
    seasonality. Using additive seasonality can cause negative values to be predicted
    (negative 100 passengers per month, for example, is not possible), whereas multiplicative
    seasonality will merely shrink values closer to zero.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Choosing additive versus multiplicative seasonality can be a bit tricky at first,
    but if you just remember the insight that the seasonality may be an absolute factor
    or a relative factor and observe whether the *spread* of the data is constant
    or not, you should have no trouble with your models.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the difference between these two seasonality modes,
    let’s apply it to a new dataset, the Divvy bike share, and continue learning about
    seasonality in Prophet.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: In many examples throughout this book, we will be creating examples using data
    from the Divvy bike share program in Chicago. In the previous chapter, we used
    hourly Divvy data, but in this section, we will use daily data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: We used the hourly Divvy data in [*Chapter 4*](B19630_04.xhtml#_idTextAnchor197),
    *Handling Non-Daily Data*, to demonstrate both the *daily* component plot and
    how to work with regular gaps in data; we will use the hourly data again in this
    chapter when we look at conditional seasonalities. But otherwise, throughout this
    book, we will be using the daily Divvy data, which is presented here. In these
    cases, we don’t need the extra granularity of the hourly data, and changing to
    daily data reduces the processing time from minutes down to seconds. Furthermore,
    the daily dataset has associated weather and temperature columns, which are lacking
    in the hourly dataset, which we will use in [*Chapter 9*](B19630_09.xhtml#_idTextAnchor599),
    *Including* *Additional Regressors*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第4章*](B19630_04.xhtml#_idTextAnchor197)中使用了小时级的Divvy数据，*处理非每日数据*，以展示*每日*成分图以及如何处理数据中的常规间隔；在本章中，当我们查看条件季节性时，我们还将再次使用小时级数据。但除此之外，在本书的其余部分，我们将使用每日的Divvy数据，如下所示。在这些情况下，我们不需要小时级数据的额外粒度，改为每日数据可以将处理时间从分钟减少到秒。此外，每日数据集还包含相关的天气和温度列，这些列在小时级数据集中缺失，我们将在[*第9章*](B19630_09.xhtml#_idTextAnchor599)中包括*额外的回归因子*。
- en: 'Here is what the daily Divvy data looks like:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每日Divvy数据的样子：
- en: '![Figure 5.6 – Number of rides per day on Divvy](img/Fig_5.6.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6 – Divvy每日骑行次数](img/Fig_5.6.jpg)'
- en: Figure 5.6 – Number of rides per day on Divvy
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – Divvy每日骑行次数
- en: This is count data because it represents the number of rides each day, and you
    can also see that the magnitude of the seasonality is growing with the trend (if
    we plotted those dotted lines from *Figure 5**.1*, tracing the upper and lower
    bounds of the data, the lines would diverge). As we just learned, these are an
    indication of multiplicative seasonality, so let’s be sure to set that when instantiating
    our model. We imported the necessary Python libraries in the previous example,
    so we can begin this example by loading the data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种计数数据，因为它代表了每天的骑行次数，你也可以看到季节性的幅度随着趋势的增长而增长（如果我们从*图5.1*中绘制那些虚线，追踪数据的上下界限，线条将会发散）。正如我们刚刚学到的，这些都是乘法季节性的指示，所以让我们确保在实例化我们的模型时设置这一点。在先前的例子中，我们已经导入了必要的Python库，因此我们可以从这个例子开始加载数据。
- en: 'This dataset contains some additional columns for weather and temperature conditions,
    which we will use to enrich our forecast in [*Chapter 9*](B19630_09.xhtml#_idTextAnchor599),
    *Including Additional Regressors*. Once we have loaded the data, we can see these
    additional columns:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据集包含一些额外的天气和温度条件列，我们将使用这些列在[*第9章*](B19630_09.xhtml#_idTextAnchor599)中丰富我们的预测，包括*额外的回归因子*。一旦我们加载了数据，我们就可以看到这些额外的列：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running this command in a Jupyter notebook or IPython instance reveals the
    following DataFrame:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jupyter笔记本或IPython实例中运行此命令将显示以下DataFrame：
- en: '![Figure 5.7 – The Divvy DataFrame](img/Fig_5.7.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – Divvy DataFrame](img/Fig_5.7.jpg)'
- en: Figure 5.7 – The Divvy DataFrame
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – Divvy DataFrame
- en: 'For now, though, we only need the `date` and `rides` columns. Let’s load those
    into our Prophet DataFrame with the appropriate column names. We will work with
    `weather` and `temperature` in [*Chapter 9*](B19630_09.xhtml#_idTextAnchor599),
    *Including* *Additional Regressors*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需要`date`和`rides`列。让我们将这些列加载到我们的Prophet DataFrame中，并使用适当的列名。我们将在[*第9章*](B19630_09.xhtml#_idTextAnchor599)中处理`weather`和`temperature`，包括*额外的回归因子*：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As before, we need to create an instance of the Prophet class before calling
    the `fit` method. Note that we are setting `seasonality_mode` to `''multiplicative''`
    because we noticed when plotting the raw data that the seasonality fluctuations
    grew with the increasing trend. After fitting the model, we will again create
    a future DataFrame, with a 1-year forecast, and then call `predict` to create
    the `forecast` DataFrame and send it to the `plot` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在调用`fit`方法之前，我们需要创建Prophet类的实例。请注意，我们将`seasonality_mode`设置为`'multiplicative'`，因为我们注意到在绘制原始数据时，季节性波动随着趋势的增加而增长。在拟合模型后，我们将再次创建一个包含1年预测的未来DataFrame，然后调用`predict`来创建`forecast`
    DataFrame并将其发送到`plot`方法：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After running that code, you should find that Prophet has created the following
    plot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码后，你应该会发现Prophet创建了以下图表：
- en: "![Figure 5.8 – Divvy f\uFEFForecast](img/Fig_5.8.jpg)"
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – Divvy预测](img/Fig_5.8.jpg)'
- en: Figure 5.8 – Divvy forecast
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – Divvy预测
- en: 'We can see that the predicted trend is indeed increasing along with the actual
    data and that the yearly seasonality also matches. Now, let’s plot our components
    and see what they reveal:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，预测趋势确实随着实际数据增加，年度季节性也与之匹配。现在，让我们绘制我们的组件图，看看它们揭示了什么：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see in the output plot, Prophet has isolated three components in
    this dataset: **trend**, **weekly** seasonality, and **yearly** seasonality:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在输出图中所见，Prophet已将此数据集中的三个组件隔离出来：**趋势**、**每周**季节性和**年度**季节性：
- en: '![Figure 5.9 – Divvy components plot](img/Fig_5.9.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – Divvy组件图](img/Fig_5.9.jpg)'
- en: Figure 5.9 – Divvy components plot
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – Divvy组件图
- en: By default, Prophet will identify a `'ds'` column contains at least 2 full years
    of data. `'ds'` column was less than 1 day (which does not apply in this case).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Prophet会识别一个包含至少2年完整数据的`'ds'`列。`'ds'`列少于1天（在此情况下不适用）。
- en: The trend linearly increases relatively rapidly for the first 2 years but then
    bends and slows slightly for the remaining 2 years, and the forecasted year continues
    to follow this slope. We can see that the Divvy network has grown in average usage
    over this period from about 3,500 rides per day in 2014 to about 8,500 per day
    by the end of 2018.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势在前两年内线性增长相对较快，但随后弯曲并略微放缓，剩余两年，预测年份继续遵循这一斜率。我们可以看到，Divvy网络在此期间的平均使用量从2014年的每天约3500次增长到2018年底的每天约8500次。
- en: The weekly seasonality shows that there are about 30% fewer rides per day on
    the weekends – maybe all these riders are work commuters – with rides on the weekdays
    being 10-20% higher than the trend would indicate. This fits our intuition that
    weekdays and weekends could reasonably show a different pattern.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每周的季节性表明，周末每天的骑行次数大约减少了30%——也许所有这些骑行者都是上班族——而工作日的骑行次数比趋势高10-20%。这符合我们的直觉，即工作日和周末可能表现出不同的模式。
- en: Now, looking at the yearly seasonality reveals that rides in the summer are
    about 60% higher than the trend, while rides in the winter are 80% lower. Again,
    this also intuitively makes sense. Those work commuters are going to drive or
    take public transport when the weather gets cold and rainy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，观察年度季节性可以发现，夏季的骑行次数比趋势高约60%，而冬季的骑行次数低80%。同样，这也符合直觉。那些上班族在天气寒冷和下雨时会开车或乘坐公共交通。
- en: You’ll notice that this yearly seasonality curve is quite *wavy*, just as we
    noticed in the previous chapter with the hourly Divvy data. You may have expected
    a much smoother curve, not one with so many inflection points. This is a result
    of our yearly seasonality being too flexible – it has too many **degrees of freedom**
    or too many mathematical parameters controlling the curve. In Prophet, the number
    of parameters controlling the seasonality curve is called the **Fourier order**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到这个年度季节性曲线相当**波动**，就像我们在上一章中注意到的小时Divvy数据一样。您可能期望得到一条更平滑的曲线，而不是有这么多拐点的曲线。这是由于我们的年度季节性过于灵活——它有太多的**自由度**或太多的数学参数控制曲线。在Prophet中，控制季节性曲线的参数数量称为**傅里叶阶数**。
- en: Controlling seasonality with the Fourier order
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用傅里叶阶数控制季节性
- en: Seasonality is at the heart of how Prophet works, and Fourier series are used
    to model seasonality. To understand what a Fourier series is, and how the Fourier
    order relates to it, I’ll use an analogy from linear regression.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 季节性是Prophet工作原理的核心，傅里叶级数用于模拟季节性。为了理解傅里叶级数是什么，以及傅里叶阶数如何与之相关，我将使用线性回归的一个类比。
- en: 'You may know that increasing the order of a polynomial equation in linear regression
    will always improve your goodness of fit. For example, the simple linear regression
    equation is ![](img/B19630_05_F01.png) , with ![](img/019630_05_F02.png) being
    the slope of the line and ![](img/019630_05_F03.png) being the ![](img/019630_05_F04.png)-intercept.
    Increasing the order of your equation to, say, ![](img/019630_05_F05.png) will
    always improve your fit, at the risk of overfitting and capturing noise. You can
    always achieve an ![](img/019630_05_F06.png) value of 1 (perfect fit) by arbitrarily
    increasing the order of your polynomial equation higher and higher. The following
    figure illustrates how higher-order fits start to become quite unrealistic and
    overfit, though:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Linear regression with higher-order polynomials](img/Fig_5.10.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Linear regression with higher-order polynomials
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The **Linear** solid line does get the upward trend of the data correct, but
    it seems to be missing some subtle detail. The **Quadratic** dashed line is a
    better fit (indeed, this data was simulated from a quadratic equation with random
    noise). However, the **Quintic** and **Decic** curves are overfitting to the random
    noise. If we sample some more data points from this distribution, they will most
    likely cause the **Quintic** and **Decic** curves to radically change to fit the
    new data, whereas the **Linear** and **Quadratic** curves will only shift slightly.
    We may say that the order of a polynomial is proportional to the number of bends
    the curve can have to fit the data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: A Fourier series is simply a sum of sine waves. By changing the shape of these
    individual sine waves – the amplitude, or height of the wave; the period, or distance
    from peak to peak; and the phase, or where along the length of the wave the cycle
    begins – we can create a new and very complex wave shape.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'In the linear domain, we changed the order of the polynomial to control the
    amount of flexibility the curve has, and we changed the *β* coefficients to control
    the actual shape of the curve. Similarly, in the periodic domain, we change the
    number of sine waves in our Fourier series – this is the Fourier order – to control
    the flexibility of the final curve and we (or, more accurately, Prophet’s fitting
    equations) change the amplitude, period, and phase of the individual waves to
    control the actual shape of our final curve. You can see how this summation works
    in the following figure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Fourier series of order 4](img/Fig_5.11.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Fourier series of order 4
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The solid line is simply the sum of each of the four sine waves. By arbitrarily
    increasing the Fourier order in our model, we can always achieve a perfect fit
    for any set of data. But just as in the linear domain, this approach will inevitably
    lead to overfitting.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Remember in *Figure 5**.9* when we plotted the components of the Divvy forecast
    and the yearly seasonality was too wavy? This is the result of the Fourier order
    being too high. By default, Prophet fits yearly seasonality with an order of 10,
    weekly seasonality with an order of 3, and daily seasonality (if sub-daily data
    is provided, of course) with an order of 4\. Usually, these defaults work very
    well and no tuning is needed. However, in Divvy’s case, we do need to reduce the
    Fourier order of the yearly seasonality to achieve a better fit with the data.
    Let’s see how to do that.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: We already have our necessary libraries imported and the data loaded into our
    `df` DataFrame from the previous example, so to continue, we need to instantiate
    a new Prophet object with a modified yearly seasonality. As before, we will set
    the seasonality mode to multiplicative, but this time, we will include the `yearly_seasonality`
    argument and set it to `4`. This is where we set the Fourier order.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: You may experiment with different values on your own; I have found `4` to provide
    a clean curve without much flexibility in most cases, which is what I want here.
    Similarly, if we wanted to change the Fourier order of `weekly_seasonality` or
    `daily_seasonality`, we would do so here.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'After instantiating our model, we merely need to fit it to the data to plot
    the seasonality. There is no need to predict in this case:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will use a new function here to plot just the yearly component – the `plot_yearly`
    function from Prophet’s `plot` package. We need to import it first:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that there is also a `plot_weekly` function, which operates much the same
    way. Both functions require the first argument to be the model; here, we will
    also include the optional figure size argument so that it matches the scale of
    our previous plot contained in *Figure 5**.9*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Compare this output with the yearly seasonality curve in *Figure 5**.9*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Divvy yearly seasonality with a Fourier order of 4](img/Fig_5.12.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Divvy yearly seasonality with a Fourier order of 4
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully eliminated the waviness of our previous attempt, while
    still maintaining the clear shape of the seasonality. This seems much more reasonable!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have only been working with Prophet’s default seasonalities. However,
    there are many cyclic datasets out there with periods that don’t fall neatly into
    the yearly, weekly, or daily seasonality bins. Prophet supports custom seasonalities
    precisely for this purpose. Let’s check them out in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom seasonalities
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, the only seasonalities we have worked with are the defaults in Prophet:
    yearly, weekly, and daily. But there is no reason to limit ourselves to these
    seasonalities. If your data contains a cycle that is either longer or shorter
    than the 365.25-day yearly cycle, the 7-day weekly cycle, or the 1-day daily cycle,
    Prophet makes it easy to model this seasonality yourself.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: A great example of a non-standard seasonality is the 11-year cycle of sunspots.
    Sunspots are regions on the Sun’s surface that temporarily exhibit a much-reduced
    temperature, and hence appear much darker than surrounding areas.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非标准季节性的好例子是太阳黑子的11年周期。太阳黑子是太阳表面暂时表现出大幅降低温度的区域，因此看起来比周围区域要暗得多。
- en: Beginning in approximately 1609, Galileo Galilei began systematic observation
    of sunspots and over the last 400+ years, this phenomenon has been constantly
    recorded. Sunspots represent the longest continuously recorded time series of
    any natural phenomenon. Through these observations, scientists have identified
    a quasi-periodic cycle of 11 years during which the frequency of sunspot occurrences
    varies. They say *quasi*-periodic because the cycle length seems to vary from
    cycle to cycle – it isn’t perfectly 11 years each time. The average cycle length
    is 11 years, though, so that is what we will use to model it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 大约从1609年开始，伽利略·伽利莱开始系统地观测太阳黑子，在过去的400多年里，这一现象一直被持续记录。太阳黑子代表了任何自然现象中连续记录时间最长的时序数据。通过这些观测，科学家们确定了一个11年的准周期循环，在此期间太阳黑子出现的频率会变化。他们称之为“准周期”是因为循环长度似乎在周期之间有所变化——并不是每次都是完美的11年。然而，平均周期长度是11年，因此我们将使用这个数字来建模。
- en: 'The **Solar Influences Data analysis Center** (**SIDC**), a department of the
    Royal Observatory of Belgium in Brussels, provides a dataset of sunspot activity
    from 1750 to the present day in their **World Data Center – Sunspot Index and
    Long-term Solar Observations** (**WDC-SILSO**) project. This dataset will be a
    good demonstration of how to add a new seasonality to Prophet. We will begin by
    loading our data:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**太阳影响数据分析中心**（**SIDC**），位于布鲁塞尔的比利时皇家天文台的部门，在其**世界数据中心——太阳黑子指数和长期太阳观测**（**WDC-SILSO**）项目中提供了从1750年到现在的太阳黑子活动数据集。这个数据集将很好地展示如何向Prophet添加新的季节性。我们将首先加载数据：'
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s visualize this data to see how it looks:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们可视化这些数据，看看它的样子：
- en: '![Figure 5.13 – Number of sunspots per month](img/Fig_5.13.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图5.13 – 每月太阳黑子数量](img/Fig_5.13.jpg)'
- en: Figure 5.13 – Number of sunspots per month
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13 – 每月太阳黑子数量
- en: The data appears rather noisy; there appear to be several outliers and the cycle
    is not perfectly clean. There is quite a lot of variation in the peak of each
    cycle. To see how Prophet will handle this data, we first need to instantiate
    our model. This is count data, so we will choose multiplicative seasonality.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 数据看起来相当嘈杂；似乎有几个异常值，循环并不完全干净。每个周期的峰值变化很大。为了看看Prophet如何处理这些数据，我们首先需要实例化我们的模型。这是计数数据，因此我们将选择乘法季节性。
- en: Another consideration we will take is that the Sun is so large that it hardly
    feels the minuscule tug of Earth’s gravity as we orbit around our star; therefore,
    the Sun does not experience what we would call a yearly seasonality at all. We
    will instruct Prophet not to attempt to fit a yearly seasonality. Prophet won’t
    attempt a weekly or daily seasonality because we are providing monthly data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将考虑的一个因素是，太阳如此之大，以至于在我们围绕我们的恒星轨道运行时几乎感觉不到地球引力的微小牵引；因此，太阳根本不会体验到我们所说的年季节性。我们将指示Prophet不要尝试拟合年季节性。由于我们提供的是月度数据，Prophet不会尝试拟合周或日季节性。
- en: 'We learned how to adjust the Fourier order of the yearly seasonality earlier
    in this chapter by passing an integer to the `yearly_seasonality` argument. This
    is the same argument we use to turn off a default seasonality; simply pass a Boolean
    instead. We pass `yearly_seasonality=False` to instruct Prophet not to fit yearly
    seasonality:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们学习了如何通过传递整数给`yearly_seasonality`参数来调整年季节性的傅里叶阶数。这是我们用来关闭默认季节性的参数；只需传递一个布尔值即可。我们传递`yearly_seasonality=False`来指示Prophet不要拟合年季节性：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once our model has been instantiated, we can add seasonalities. We can do this
    with the `add_seasonality` method. This method requires that we pass arguments
    for the name of the seasonality (we’ll call this one `''11-year cycle''`), the
    period (11 years times 365.25 days, as `period` is stated in days), and the Fourier
    order (we’ll use `5` in this case, but feel free to experiment). This is how it
    all looks together:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的模型被实例化，我们就可以添加季节性。我们可以使用`add_seasonality`方法来做这件事。此方法要求我们传递季节性的名称（我们将称之为`'11-year
    cycle'`），周期（11年乘以365.25天，因为`period`是以天为单位的），以及傅里叶阶数（在这种情况下我们将使用`5`，但请随意实验）。这就是所有内容看起来是什么样的：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Stating the period can be tricky; just remember that it is always counted in
    days. So, a seasonality longer than a day will have a number greater than 1 and
    a seasonality shorter than a day will have a period less than 1.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of this example is exactly as in previous ones; we fit on the training
    DataFrame, create a future DataFrame, and then predict on it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s inspect the components plot to see what we created:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Sunspots components plot](img/Fig_5.14.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Sunspots components plot
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The plot shows just the trend and the 11-year cycle, which is exactly what we
    expected. The trend has a sawtooth shape; in fact, scientists have named that
    trough around **1814** the *Dalton Minimum*, named after the English meteorologist
    John Dalton. The peak during the 1950s is called the *Modern Maximum*. But it’s
    the 11-year cycle that we’re interested in here.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: With this irregular cycle, Prophet plots the *x* axis in days, so each tick
    is about 1.5 years later than the previous tick. The whole cycle is indeed 11
    years. We can see that the low point is a bit *flatter* than the high point and
    has about 60% fewer sunspots than the average. The high point sees about 80% more
    sunspots than average.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'To see all of the seasonalities that your model currently has, as well as the
    parameters controlling that seasonality, simply call the `seasonalities` attribute
    of the model:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This outputs a dictionary where the keys are the names of the seasonalities
    and the values are the parameters. In this example, where we only have one seasonality,
    this is the output dictionary:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Important note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: When specifying a period for your seasonality, it is always specified in days.
    So, a 10-year seasonality will have a period of 10 (years) x 365.25 (days per
    year) = 3652.5 days. An hourly seasonality would be 1 (day) / 24 (hours per day)
    = 0.04167 days.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to confuse the period of seasonality with the period used in
    `make_future_dataframe`. The period in seasonality is always specified in days,
    while the period in `make_future_dataframe` is specified by the `freq` argument.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a seasonality to Prophet that doesn’t exist in the data can cause Prophet
    to be very slow to fit, as it struggles to find a pattern where none exists. This
    can harm your forecast as Prophet will eventually fit the non-existent seasonality
    to noise. However, other seasonalities you may find yourself frequently adding
    include an hourly seasonality, if your data is measured per minute, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Seasonality for the quarterly business cycle would be created in the following
    manner:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That’s how you add custom seasonalities! We’ll be using this `add_seasonality`
    method a bit more in this chapter, starting with the next section about seasonalities
    that depend on other factors.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Adding conditional seasonalities
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose you work for a utility company in a college town and are tasked with
    forecasting the electricity usage for the coming year. The electricity usage is
    going to depend on the population of the town to some extent, and as a college
    town, thousands of students are only temporary residents! How do you set up Prophet
    to handle this scenario? Conditional seasonalities exist for this purpose.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Conditional seasonalities are those that are, in effect, for only a portion
    of the dates in the training and future DataFrames. A **conditional seasonality**
    must have a cycle that is shorter than the period in which it is active. So, for
    example, it wouldn’t make sense to have a yearly seasonality that is active for
    just a few months.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Forecasting electricity usage in the college town would require you to set up
    either daily or weekly seasonalities – and possibly even both; depending on the
    usage patterns, one daily/weekly seasonality for the summer months when students
    have returned to their hometowns and another daily/weekly seasonality for the
    rest of the year. Ideally, the conditional seasonality would have at least two
    full cycles each time it is active.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: To learn how to build a conditional seasonality, we will go back to the hourly
    Divvy data that we explored in the previous chapter. Based on the weekly seasonality
    we observed in that example, we know ridership is significantly lower on weekends
    than on weekdays, suggesting most riders are commuting to work.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: We saw in the daily seasonality plot that ridership has usage peaks around 8
    a.m. and 6 p.m., during the morning and evening rush hours. This may lead you
    to suspect that the usage throughout the day will follow different patterns on
    a weekday versus the weekend. That is, maybe those peaks we see at 8 a.m.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: and 6 p.m. and the midday trough will all disappear on weekends, with activity
    levels more even throughout the day. To test this hypothesis, let’s build a forecast
    model using different daily seasonalities for weekends than for weekdays.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The basic procedure for adding this conditional seasonality is to add new Boolean
    columns to your training DataFrame (and later, matching columns in the future
    DataFrame) indicating whether that row is a weekend or weekday. Then, disable
    the default weekly seasonality and add two new weekly seasonalities that specify
    those new Boolean columns as conditions. Let’s see how to do this.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the necessary libraries already loaded, so to begin, we need to create
    our Prophet DataFrame using the Divvy hourly data:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, this is where we identify the condition for our seasonality. Let’s create
    a function that outputs `True` if the given date is on a weekend and `False` otherwise.
    Then, we’ll use the `apply` method from `pandas` to create a new column for weekends
    and use the tilde (`~`) operator to take the inverse results for another new column
    for weekdays. Finally, let’s output the first few rows of our DataFrame at this
    point just so that we can see what we’ve got:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If your functions correctly identified the days, you should see this output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – The Divvy conditional seasonality DataFrame](img/Fig_5.15.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – The Divvy conditional seasonality DataFrame
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'January 1, 2014 was a Wednesday, so that output matches what we would expect.
    Next, we need to instantiate our model. Using what we learned earlier in this
    chapter, we will set the seasonality mode to `multiplicative`, as this Divvy data
    represents count values. We will also set the Fourier order of both yearly and
    weekly seasonalities to `6`; my testing showed that to be a good value on this
    dataset. Finally, because we are adding conditional daily seasonalities, we will
    disable the default daily seasonality:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To create conditional seasonalities, we will use the same `add_seasonality`
    method that we learned about while modeling the sunspot cycle, but in this case,
    we will use the optional `condition_name` argument to specify that the new seasonality
    is conditional.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The `condition_name` argument must be passed the name of a column in the training
    DataFrame and consist of Boolean values identifying which rows to apply the seasonality
    to – our `weekend` and `weekday` columns. Just as we did in the sunspots example,
    we also need to name the seasonality and identify both the period and Fourier
    order:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That’s it for setting up the model! Next, we will fit the model on our training
    data and create the `future` DataFrame just as before, being careful to set the
    frequency to *hourly* now that we are using hourly data. The last step in setting
    up conditional seasonalities is to identify where in the future DataFrame the
    condition will apply.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'We already created the `is_weekend` function and applied it to our training
    DataFrame, `df`. We simply need to repeat that procedure on the `future` DataFrame
    before calling `predict` to create our forecast:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We named our two conditional seasonalities `''daily_weekend''` and `''daily_weekday''`,
    so let’s import the `plot_seasonality` function, which we discovered in the previous
    chapter, and plot these two seasonalities:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If everything ran correctly, you should have two new plots:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Daily weekday component plot](img/Fig_5.16.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – Daily weekday component plot
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'On weekdays, the trend appears much the same as we saw when we used the default
    daily seasonality – a peak around 8 a.m., another peak around 6 p.m., and a small
    hump just after midnight. We hypothesized that weekends would see a much different
    pattern, though. Let’s look at the plot to see:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Daily weekend component plot](img/Fig_5.17.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Daily weekend component plot
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: And indeed, we do see a difference! As your intuition might have suggested,
    on the weekends, Divvy riders tend to get a later start than on weekdays, with
    a gradual increase in ridership up until noon and then a gradual decrease to midnight.
    There is no midday slump as we saw on working days.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'So far in this chapter, you used the Air Passengers data to learn the difference
    between additive and multiplicative seasonality. Later, you used the Divvy data
    to learn how to add custom seasonalities and conditional seasonalities. You also
    used the Divvy data to discover the Fourier order and learned how to control the
    flexibility of the seasonality curve. However, there is another lever Prophet
    makes available to you to control seasonality: regularization.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Regularizing seasonality
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, when solving a problem with machine learning, the data involved is so
    complex that a simple model just isn’t powerful enough to capture the full subtlety
    of the patterns to be found. The simple model tends to **underfit** the data.
    In contrast, a more complicated model with many parameters and great flexibility
    can tend to **overfit** the data. It is not always easy, or possible, to use a
    simpler model. In these cases, **regularization** is a good technique to use to
    control overfitting.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Prophet is such a powerful forecasting tool that without care, it can sometimes
    be very easy to overfit the data. That’s why understanding Prophet’s regularization
    parameters can be quite useful.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: A model is said to be *underfit* if it does not fully capture the true relationship
    between the input features and the output features. Performance is low on both
    the training data and any unseen testing data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: A model is said to be *overfit* if it goes beyond capturing the true relationship
    and begins to capture random trends in the noise of the data. Performance can
    be very high on the training data but low on the unseen testing data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: A model with a good fit will perform equally well on both training and testing
    data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Regularization is a technique for controlling overfitting by forcing a model
    to be less flexible. For example, in *Figure 5**.18*, I simulated a set of points
    with random noise (the true relationship I used is ![](img/019630_05_F07.png)))
    and fit two lines using 8th-degree polynomial regression (in reality, you would
    rarely choose such a high order for a regression model; I am using it here merely
    to exaggerate the point). One line is not regularized at all, and the other is:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Regularization effects](img/Fig_5.18.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – Regularization effects
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the plot, the unregularized line is overfit and wiggles around
    the true relationship while attempting to fit to the noise. By regularizing, in
    contrast, the flexibility of the line is constrained and it is forced to trace
    out a much smoother curve. With the true curve essentially being ![](img/019630_05_F08.png)
    , it is clear that the regularized line, while still not perfect, does a better
    job of approximating the relationship and will perform better on new data.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The full Prophet package has several adjustable parameters for regularization.
    For seasonality, that parameter is called the prior scale.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In statistics, you may have an uncertain quantity that you intend to find the
    value of. The **prior probability distribution**, often just called a prior, of
    that quantity is the probability distribution of values you would expect *prior
    to* learning additional information.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say I ask you to guess the height of a specific human male.
    In your mind, you imagine all the likely heights of males. That range of heights
    is the prior probability distribution. Next, I tell you that the male is an NBA
    basketball player. You know basketball players are typically much taller than
    the average male, so you update that distribution to skew more toward tall heights
    because the additional information I provided you with better informs your guess.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The prior is your starting point, what you believe to be true before receiving
    additional information. Let’s learn how to apply this idea to seasonality in Prophet.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Global seasonality regularization
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first way to apply seasonality regularization is globally, which affects
    all the seasonalities in your model equally. `seasonality_prior_scale` is an attribute
    of your Prophet model instance and is set when you instantiate your model. If
    you do not set it, the default will be `10`. Reducing this number will apply more
    regularization, which will rein in your model’s seasonalities. Let’s see this
    in action.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the Divvy daily data in this example, so we need to begin by loading
    it into our Prophet DataFrame, as the necessary libraries should already be loaded
    from previous examples:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we need to instantiate our model, setting the seasonality mode to `multiplicative`.
    While learning about Fourier order, you went through a forecast with this dataset
    using the default `seasonality_prior_scale` value of `10`. So, let’s use a prior
    scale this time around of `0.01`. We also found the yearly seasonality to be better
    modeled with a Fourier order of `4`, so we’ll set that as well. You can refer
    back to *Figure 5**.8* and *Figure 5**.9* to see the unregularized model for comparison:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With the regularization set, all that is left to do is complete the model,
    as we did earlier:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'First, we will look at the forecast, and then the components:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Regularized forecast](img/Fig_5.19.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – Regularized forecast
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Comparing *Figure 5**.19* with *Figure 5**.8* shows that the seasonal swings
    in our forecast have indeed been dampened. Both the annual seasonality and the
    weekly seasonality show less variation. The uncertainty intervals between the
    two models are roughly the same, though, because the variance in the data is now
    handled in the Prophet model’s noise term instead of the seasonality term.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the components plot:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Regularized components plot](img/Fig_5.20.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – Regularized components plot
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparing this figure with *Figure 5**.9*, we can see that the trend is very
    similar. We only constrained the seasonality, not the trend. The trend did change
    a bit (the peak value is a bit higher) because Prophet is attempting to capture
    some of the seasonal variations with the trend, but the shape is nearly identical.
    The weekly and yearly seasonalities appear the same, but their *y* axes show that
    the magnitudes have been reduced in the range of one-third to one-quarter of their
    regularized levels. This is the effect of seasonality regularization: it reduces
    the magnitude of the curve’s values.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the effect of different seasonality prior scales, let’s compare
    the yearly and weekly seasonality curves of this dataset when modeled with different
    prior scales. First, here is the yearly seasonality plot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Yearly seasonality with different prior scales](img/Fig_5.21.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – Yearly seasonality with different prior scales
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is the weekly seasonality plot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Weekly seasonality with different prior scales](img/Fig_5.22.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22 – Weekly seasonality with different prior scales
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The solid line in both plots is the default scale of `10`; the dashed line and
    dashed-dotted line show increasing regularization amounts. Whereas modifying the
    Fourier order helped control the seasonality curve by reducing the number of bends
    it was allowed to take, modifying the seasonality prior scale helps control seasonality
    by reducing the amount of variation it can achieve.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to regularize all seasonalities at the same
    time. Next, learn see how to regularize the seasonalities individually.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Local seasonality regularization
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say that you are happy with the yearly seasonality curve with the default
    regularization setting, but your weekly curve is too extreme and overfitting.
    In that case, you can use the `add_seasonality` method to create a new weekly
    seasonality with a custom prior scale.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue and instantiate a new model, again with `multiplicative` seasonality
    and a Fourier order of `4` applied to the yearly seasonality. This time, though,
    we will be adding a new weekly seasonality, so let’s remove the default by setting
    it to `False` while instantiating:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you learned in the *Adding custom seasonalities* section, we will now add
    a seasonality with a period of `7` days and name it `''weekly''`. We are happy
    with the default weekly Fourier order of `4`, so we’ll use that again here, but
    we want more regularization than is the default, so we will use the `prior_scale`
    argument to set it to `0.01`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, as I hope is becoming second nature to you, we will fit the model and
    predict on the future DataFrame. Let’s just plot the components this time:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should see this plot, which looks nearly identical to *Figure 5**.20*:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Weekly regularized components plot](img/Fig_5.23.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Figure 5.23 – Weekly regularized components plot
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: You’ll now see that the magnitude of the unregularized yearly seasonality matches
    that of *Figure 5**.9*, but the regularized weekly seasonality is reduced by about
    half, as expected. All of your seasonalities can have different regularization
    strengths applied, simply with repeated `add_seasonality` calls. Reasonable values
    for these prior scales range from about 10 down to around 0.01.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Seasonality truly is the heart of Prophet. This chapter covered a lot of ground;
    the foundations you learned here will be used throughout the remaining chapters
    of this book. Indeed, almost any model you build in Prophet will have seasonality
    considerations, whereas many of the upcoming chapters cover special cases that
    may or may not apply to your specific problem.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: You started this chapter by learning the difference between additive and multiplicative
    seasonality, and how to identify whether your dataset features one or the other.
    We then briefly discussed the Fourier series and demonstrated how a partial Fourier
    sum can build a very complex periodic curve. Using these ideas, you learned how
    setting the Fourier order of a seasonality can be used to control its shape by
    allowing either more or less freedom to bend along its path.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Next, you modeled the 11-year cycle of sunspots and learned how to add custom
    seasonalities. These custom seasonalities came into use again when you learned
    how to model the different weekday and weekend behaviors of riders on Divvy’s
    network using conditional seasonalities. Finally, we looked at regularization
    techniques, both globally as applied to all seasonalities together and locally,
    using yet again the custom seasonalities lesson to apply regularization to just
    the weekly seasonality alone.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn all about holidays in the Prophet package,
    which, among many other topics, will also include more detail about regularization
    as it applies to Prophet.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
