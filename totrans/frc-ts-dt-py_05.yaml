- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Working with Seasonality
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与季节性一起工作
- en: One quality that sets time series apart from other datasets is that very often
    – but not always – the data has a certain rhythm to it. That rhythm may be yearly,
    possibly due to the Earth’s rotation around the Sun, or daily, if rooted in the
    Earth’s rotation around its axis. The tidal cycle follows the Moon’s rotation
    around the Earth.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列与其他数据集区别开来的一个特点是，数据往往具有某种节奏，但这种节奏并非总是存在的。这种节奏可能是年度的，可能由于地球围绕太阳旋转，或者是日度的，如果它根植于地球围绕其轴的旋转。潮汐周期遵循月球围绕地球的旋转。
- en: Traffic congestion follows the human activity cycle throughout the day and the
    5-day workweek, followed by the 2-day weekend; financial activity follows the
    quarterly business cycle. Your own body follows cycles due to your heartbeat,
    breathing rate, and circadian rhythm. On very small physical and very short temporal
    scales, the vibration of atoms is a cause of periodicity in data. Prophet calls
    these cycles **seasonalities**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 交通拥堵遵循全天和 5 天工作周的人类活动周期，随后是 2 天的周末；金融活动遵循季度商业周期。你的身体由于心跳、呼吸速率和昼夜节律而遵循周期。在非常小的物理和非常短的时间尺度上，原子的振动是数据周期性的原因。Prophet
    将这些周期称为 **季节性**。
- en: 'In this chapter, you will learn about all the different types of seasonalities
    Prophet fits by default, how to add new ones, and how to control them. In particular,
    we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解 Prophet 默认拟合的所有不同类型的季节性，如何添加新的季节性，以及如何控制它们。特别是，我们将涵盖以下主题：
- en: Understanding additive versus multiplicative seasonality
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解加法与乘法季节性
- en: Controlling seasonality with the Fourier order
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用傅里叶阶数控制季节性
- en: Adding custom seasonalities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义季节性
- en: Adding conditional seasonalities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加条件季节性
- en: Regularizing seasonality
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则化季节性
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The data files and code for the examples in this chapter can be found at [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中示例的数据文件和代码可以在[https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition)找到。
- en: Understanding additive versus multiplicative seasonality
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解加法与乘法季节性
- en: 'In our Mauna Loa example in [*Chapter 2*](B19630_02.xhtml#_idTextAnchor104),
    *Getting Started with Prophet*, the yearly seasonality was constant at all values
    along the trend line. We added the values predicted by the seasonality curve to
    the values predicted by the trend curve to arrive at our forecast. There is an
    alternative mode of seasonality, though, where we can multiply the trend curve
    by the seasonality. Take a look at this figure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 *第 2 章* [Mauna Loa 示例](B19630_02.xhtml#_idTextAnchor104)中，*使用 Prophet 入门*，年度季节性在趋势线上的所有值都是恒定的。我们将季节性曲线预测的值添加到趋势曲线预测的值中，以得出我们的预测。然而，还有一种季节性的替代模式，我们可以将趋势曲线乘以季节性。看看这个图：
- en: '![Figure 5.1 – Additive versus multiplicative seasonality](img/Fig_5.1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 加法季节性与乘法季节性](img/Fig_5.1.jpg)'
- en: Figure 5.1 – Additive versus multiplicative seasonality
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 加法季节性与乘法季节性
- en: The upper curve demonstrates additive seasonality – the dashed lines that trace
    the bounds of the seasonality are parallel because the magnitude of seasonality
    does not change, only the trend does. In the lower curve, though, these two dashed
    lines are not parallel. Where the trend is low, the spread caused by seasonality
    is low; but where the trend is high, the spread caused by seasonality is high.
    This can be modeled with multiplicative seasonality.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上曲线展示了加法季节性——追踪季节性边界的虚线是平行的，因为季节性的幅度没有变化，只有趋势在变化。然而，在下曲线中，这两条虚线并不平行。当趋势低时，季节性引起的扩散低；但当趋势高时，季节性引起的扩散高。这可以用乘法季节性来建模。
- en: Let’s look at a concrete example using the Air Passengers dataset introduced
    in the previous chapter. This data records the number of commercial airline passengers
    per month from 1949 to 1960\. We will first model it using Prophet’s default `seasonality_mode`,
    the additive mode that we used with the Mauna Loa example, and then contrast it
    with the multiplicative mode.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用上一章中引入的 Air Passengers 数据集来具体看一下。这些数据记录了从 1949 年到 1960 年每月的商业航空公司乘客数量。我们首先将使用
    Prophet 的默认 `seasonality_mode` 来建模它，即我们在 Mauna Loa 示例中使用的加法模式，然后将其与乘法模式进行对比。
- en: 'We will begin just as we did in the previous chapter, by importing the necessary
    libraries and loading the data into a DataFrame:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像上一章那样开始，导入必要的库并将数据加载到 DataFrame 中：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s continue building our model. I am calling this one `model_a` to indicate
    that it is our additive model; I’ll call the next model `model_m`, for multiplicative:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续构建我们的模型。我将这个命名为 `model_a` 以表明它是一个加法模型；下一个模型我将命名为 `model_m`，表示乘法模型：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we instantiated the Prophet object, we explicitly declared `seasonality_mode`
    as `'additive'` for clarity’s sake. By default, if no `seasonality_mode` is stated,
    then Prophet will automatically select `'additive'`. Also, note that we set `yearly_seasonality=4`.
    This merely sets the **Fourier order** for the curve, but don’t worry about this
    for now – we’ll go over it in the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化 Prophet 对象时，我们明确声明 `seasonality_mode` 为 `'additive'` 以便清晰。默认情况下，如果没有声明
    `seasonality_mode`，Prophet 将自动选择 `'additive'`。此外，请注意我们设置了 `yearly_seasonality=4`。这仅仅设置了曲线的**傅里叶阶数**，但现在不用担心这个问题
    – 我们将在下一节中讨论它。
- en: After creating the Prophet model, we fit and predicted it just as before in
    the Mauna Loa example, and then plotted the forecast. Note that in this example,
    though, we never created a future DataFrame – if no future DataFrame is sent to
    the `predict` method, it simply creates predicted values for the historical data
    it received in the `fit` method but no future predicted values. As we are only
    interested in seeing how Prophet has handled the seasonality, we don’t need a
    future forecast.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Prophet 模型后，我们就像在 Mauna Loa 示例中那样拟合并预测它，然后绘制了预测图。注意，然而，在这个例子中，我们从未创建一个未来的
    DataFrame – 如果没有将未来的 DataFrame 发送到 `predict` 方法，它将仅创建在 `fit` 方法中接收到的历史数据的预测值，但没有未来的预测值。由于我们只对查看
    Prophet 如何处理季节性感兴趣，我们不需要未来的预测。
- en: 'Here is the figure we just created:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们刚刚创建的图：
- en: '![Figure 5.2 – Air passengers with additive seasonality](img/Fig_5.2.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 具有加法季节性的航空旅客](img/Fig_5.2.jpg)'
- en: Figure 5.2 – Air passengers with additive seasonality
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 具有加法季节性的航空旅客
- en: 'As you can see, early in the data, in **1949**, **1951**, and **1952**, Prophet’s
    predicted values (the solid line) have large seasonal swings that are more extreme
    than the data (the dots) indicates. Later in the series, in **1958**, **1959**,
    and **1960**, Prophet’s predicted seasonality is less extreme than the data indicates.
    The seasonal spread of the data is increasing, but we have predicted it to be
    constant. That’s the mistake of choosing additive seasonality when multiplicative
    seasonality is required. Let’s run the model again, but this time, we will use
    multiplicative seasonality:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在数据早期，在 **1949**、**1951** 和 **1952** 年，Prophet 的预测值（实线）具有比数据（点）指示更极端的季节性波动。在序列后期，在
    **1958**、**1959** 和 **1960** 年，Prophet 的预测季节性比数据指示的更不极端。数据的季节性分布正在增加，但我们预测它将是恒定的。这就是在需要乘法季节性时选择加法季节性的错误。让我们再次运行模型，但这次我们将使用乘法季节性：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We do everything the same as in the previous example, except this time, we
    set `seasonality_mode=''multiplicative''`. We can see this change reflected in
    the figure we have produced:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与上一个例子中的操作完全相同，只是这次我们将 `seasonality_mode` 设置为 `'multiplicative'`。我们可以在我们生成的图中看到这种变化：
- en: '![Figure 5.3 – Air passengers with multiplicative seasonality](img/Fig_5.3.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 具有乘法季节性的航空旅客](img/Fig_5.3.jpg)'
- en: Figure 5.3 – Air passengers with multiplicative seasonality
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 具有乘法季节性的航空旅客
- en: That’s a much better fit! Now, Prophet matches the growth of the seasonality
    swings with the growth of the overall trend. Also, compare the error estimates
    between *Figure 5**.2* and *Figure 5**.3* (the light-shaded area surrounding the
    solid line). Prophet shows wider uncertainty intervals when it attempts to fit
    additive seasonality to a series of data containing multiplicative seasonality.
    Prophet knows that it does not have a good fit in the former model and is less
    certain about its predictions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更好的拟合！现在，Prophet 与整体趋势的增长匹配了季节性波动的增长。此外，比较 *图 5*.*2* 和 *图 5*.*3*（围绕实线的浅色区域）之间的误差估计。当
    Prophet 尝试将加法季节性拟合到包含乘法季节性的数据序列时，它显示更宽的不确定性区间。Prophet 知道在先前的模型中拟合不佳，并且对其预测不太确定。
- en: 'There’s one last thing here I want you to note. Let me show you what it is
    by plotting the components:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有最后一件事我想让你注意。让我通过绘制成分来展示给你看：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This plots the components for `model_a` with additive seasonality:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图展示了 `model_a` 的加法季节性成分：
- en: '![Figure 5.4 – Components plot with additive seasonality](img/Fig_5.4.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 带有加法季节性的组件图](img/Fig_5.4.jpg)'
- en: Figure 5.4 – Components plot with additive seasonality
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 带有加法季节性的组件图
- en: 'And now, let’s plot the components for `model_m`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们绘制`model_m`的组件图：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Compare the following plot with the plot shown in *Figure 5**.4*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下图表与*图5.4*中显示的图表进行比较：
- en: '![Figure 5.5 – Components plot with multiplicative seasonality](img/Fig_5.5.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 带有乘法季节性的组件图](img/Fig_5.5.jpg)'
- en: Figure 5.5 – Components plot with multiplicative seasonality
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 带有乘法季节性的组件图
- en: They look almost identical. The trend is the same, starting in **1949** just
    above **100** and rising to just below **500** by **1961**, with a slight kink
    in **1954** where the trend accelerates. The yearly seasonality behaves as we
    might expect, with the peak number of air passengers occurring in the summer and
    smaller local peaks over the Christmas holidays and spring break. The difference
    between the two charts is the *y a*xis of the seasonality curve.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它们看起来几乎完全相同。趋势相同，从**1949年**开始略高于**100**，到**1961年**时刚好低于**500**，在**1954年**有一个轻微的转折点，趋势加速。年季节性表现正如我们所预期的那样，夏季乘客数量达到峰值，圣诞节假期和春季假期的局部峰值较小。两个图表之间的区别在于季节性曲线的*Y*轴。
- en: In the additive model, the *y*-axis values are absolute numbers. In the multiplicative
    model, they are a percentage. This is because, in the additive seasonality mode,
    the seasonality is modeled as an additional factor to the trend, with values simply
    being added to or subtracted from it. But in the multiplicative seasonality mode,
    the seasonality represents a relative deviation from the trend, so the magnitude
    of the seasonality effect will depend on what value the trend is predicting at
    that point; the seasonality effect is a percentage of the trend.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在加法模型中，*Y*轴的值是绝对数值。在乘法模型中，它们是百分比。这是因为，在加法季节性模式中，季节性被建模为趋势的附加因素，值只是简单地加到或从它中减去。但在乘法季节性模式中，季节性代表相对于趋势的相对偏差，因此季节性效应的大小将取决于趋势在该点预测的值；季节性效应是趋势的百分比。
- en: Tip
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When your data represents a count of something over time, such as the count
    of airline passengers each month, you will very often model it with multiplicative
    seasonality. Using additive seasonality can cause negative values to be predicted
    (negative 100 passengers per month, for example, is not possible), whereas multiplicative
    seasonality will merely shrink values closer to zero.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的数据表示随时间变化的某种计数，例如每月的航空公司乘客计数时，你通常会使用乘法季节性来建模。使用加法季节性可能会导致预测出负值（例如，每月负100名乘客是不可能的），而乘法季节性只会将值缩小到接近零。
- en: Choosing additive versus multiplicative seasonality can be a bit tricky at first,
    but if you just remember the insight that the seasonality may be an absolute factor
    or a relative factor and observe whether the *spread* of the data is constant
    or not, you should have no trouble with your models.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 选择加法或乘法季节性可能一开始有点棘手，但如果你只是记住季节性可能是一个绝对因素或相对因素，并观察数据是否具有恒定的*分布*，你应该不会在模型上遇到任何麻烦。
- en: Now that you understand the difference between these two seasonality modes,
    let’s apply it to a new dataset, the Divvy bike share, and continue learning about
    seasonality in Prophet.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了这两种季节性模式之间的区别，让我们将其应用于一个新的数据集，Divvy自行车共享，并继续在Prophet中学习季节性。
- en: In many examples throughout this book, we will be creating examples using data
    from the Divvy bike share program in Chicago. In the previous chapter, we used
    hourly Divvy data, but in this section, we will use daily data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的许多例子中，我们将使用芝加哥Divvy自行车共享计划的数据来创建示例。在前一章中，我们使用了Divvy的小时数据，但在这个部分，我们将使用每日数据。
- en: Tip
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: We used the hourly Divvy data in [*Chapter 4*](B19630_04.xhtml#_idTextAnchor197),
    *Handling Non-Daily Data*, to demonstrate both the *daily* component plot and
    how to work with regular gaps in data; we will use the hourly data again in this
    chapter when we look at conditional seasonalities. But otherwise, throughout this
    book, we will be using the daily Divvy data, which is presented here. In these
    cases, we don’t need the extra granularity of the hourly data, and changing to
    daily data reduces the processing time from minutes down to seconds. Furthermore,
    the daily dataset has associated weather and temperature columns, which are lacking
    in the hourly dataset, which we will use in [*Chapter 9*](B19630_09.xhtml#_idTextAnchor599),
    *Including* *Additional Regressors*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第4章*](B19630_04.xhtml#_idTextAnchor197)中使用了小时级的Divvy数据，*处理非每日数据*，以展示*每日*成分图以及如何处理数据中的常规间隔；在本章中，当我们查看条件季节性时，我们还将再次使用小时级数据。但除此之外，在本书的其余部分，我们将使用每日的Divvy数据，如下所示。在这些情况下，我们不需要小时级数据的额外粒度，改为每日数据可以将处理时间从分钟减少到秒。此外，每日数据集还包含相关的天气和温度列，这些列在小时级数据集中缺失，我们将在[*第9章*](B19630_09.xhtml#_idTextAnchor599)中包括*额外的回归因子*。
- en: 'Here is what the daily Divvy data looks like:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每日Divvy数据的样子：
- en: '![Figure 5.6 – Number of rides per day on Divvy](img/Fig_5.6.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6 – Divvy每日骑行次数](img/Fig_5.6.jpg)'
- en: Figure 5.6 – Number of rides per day on Divvy
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – Divvy每日骑行次数
- en: This is count data because it represents the number of rides each day, and you
    can also see that the magnitude of the seasonality is growing with the trend (if
    we plotted those dotted lines from *Figure 5**.1*, tracing the upper and lower
    bounds of the data, the lines would diverge). As we just learned, these are an
    indication of multiplicative seasonality, so let’s be sure to set that when instantiating
    our model. We imported the necessary Python libraries in the previous example,
    so we can begin this example by loading the data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种计数数据，因为它代表了每天的骑行次数，你也可以看到季节性的幅度随着趋势的增长而增长（如果我们从*图5.1*中绘制那些虚线，追踪数据的上下界限，线条将会发散）。正如我们刚刚学到的，这些都是乘法季节性的指示，所以让我们确保在实例化我们的模型时设置这一点。在先前的例子中，我们已经导入了必要的Python库，因此我们可以从这个例子开始加载数据。
- en: 'This dataset contains some additional columns for weather and temperature conditions,
    which we will use to enrich our forecast in [*Chapter 9*](B19630_09.xhtml#_idTextAnchor599),
    *Including Additional Regressors*. Once we have loaded the data, we can see these
    additional columns:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据集包含一些额外的天气和温度条件列，我们将使用这些列在[*第9章*](B19630_09.xhtml#_idTextAnchor599)中丰富我们的预测，包括*额外的回归因子*。一旦我们加载了数据，我们就可以看到这些额外的列：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running this command in a Jupyter notebook or IPython instance reveals the
    following DataFrame:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jupyter笔记本或IPython实例中运行此命令将显示以下DataFrame：
- en: '![Figure 5.7 – The Divvy DataFrame](img/Fig_5.7.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – Divvy DataFrame](img/Fig_5.7.jpg)'
- en: Figure 5.7 – The Divvy DataFrame
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – Divvy DataFrame
- en: 'For now, though, we only need the `date` and `rides` columns. Let’s load those
    into our Prophet DataFrame with the appropriate column names. We will work with
    `weather` and `temperature` in [*Chapter 9*](B19630_09.xhtml#_idTextAnchor599),
    *Including* *Additional Regressors*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需要`date`和`rides`列。让我们将这些列加载到我们的Prophet DataFrame中，并使用适当的列名。我们将在[*第9章*](B19630_09.xhtml#_idTextAnchor599)中处理`weather`和`temperature`，包括*额外的回归因子*：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As before, we need to create an instance of the Prophet class before calling
    the `fit` method. Note that we are setting `seasonality_mode` to `''multiplicative''`
    because we noticed when plotting the raw data that the seasonality fluctuations
    grew with the increasing trend. After fitting the model, we will again create
    a future DataFrame, with a 1-year forecast, and then call `predict` to create
    the `forecast` DataFrame and send it to the `plot` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在调用`fit`方法之前，我们需要创建Prophet类的实例。请注意，我们将`seasonality_mode`设置为`'multiplicative'`，因为我们注意到在绘制原始数据时，季节性波动随着趋势的增加而增长。在拟合模型后，我们将再次创建一个包含1年预测的未来DataFrame，然后调用`predict`来创建`forecast`
    DataFrame并将其发送到`plot`方法：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After running that code, you should find that Prophet has created the following
    plot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码后，你应该会发现Prophet创建了以下图表：
- en: "![Figure 5.8 – Divvy f\uFEFForecast](img/Fig_5.8.jpg)"
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – Divvy预测](img/Fig_5.8.jpg)'
- en: Figure 5.8 – Divvy forecast
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – Divvy预测
- en: 'We can see that the predicted trend is indeed increasing along with the actual
    data and that the yearly seasonality also matches. Now, let’s plot our components
    and see what they reveal:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，预测趋势确实随着实际数据增加，年度季节性也与之匹配。现在，让我们绘制我们的组件图，看看它们揭示了什么：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see in the output plot, Prophet has isolated three components in
    this dataset: **trend**, **weekly** seasonality, and **yearly** seasonality:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在输出图中所见，Prophet已将此数据集中的三个组件隔离出来：**趋势**、**每周**季节性和**年度**季节性：
- en: '![Figure 5.9 – Divvy components plot](img/Fig_5.9.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – Divvy组件图](img/Fig_5.9.jpg)'
- en: Figure 5.9 – Divvy components plot
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – Divvy组件图
- en: By default, Prophet will identify a `'ds'` column contains at least 2 full years
    of data. `'ds'` column was less than 1 day (which does not apply in this case).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Prophet会识别一个包含至少2年完整数据的`'ds'`列。`'ds'`列少于1天（在此情况下不适用）。
- en: The trend linearly increases relatively rapidly for the first 2 years but then
    bends and slows slightly for the remaining 2 years, and the forecasted year continues
    to follow this slope. We can see that the Divvy network has grown in average usage
    over this period from about 3,500 rides per day in 2014 to about 8,500 per day
    by the end of 2018.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势在前两年内线性增长相对较快，但随后弯曲并略微放缓，剩余两年，预测年份继续遵循这一斜率。我们可以看到，Divvy网络在此期间的平均使用量从2014年的每天约3500次增长到2018年底的每天约8500次。
- en: The weekly seasonality shows that there are about 30% fewer rides per day on
    the weekends – maybe all these riders are work commuters – with rides on the weekdays
    being 10-20% higher than the trend would indicate. This fits our intuition that
    weekdays and weekends could reasonably show a different pattern.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每周的季节性表明，周末每天的骑行次数大约减少了30%——也许所有这些骑行者都是上班族——而工作日的骑行次数比趋势高10-20%。这符合我们的直觉，即工作日和周末可能表现出不同的模式。
- en: Now, looking at the yearly seasonality reveals that rides in the summer are
    about 60% higher than the trend, while rides in the winter are 80% lower. Again,
    this also intuitively makes sense. Those work commuters are going to drive or
    take public transport when the weather gets cold and rainy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，观察年度季节性可以发现，夏季的骑行次数比趋势高约60%，而冬季的骑行次数低80%。同样，这也符合直觉。那些上班族在天气寒冷和下雨时会开车或乘坐公共交通。
- en: You’ll notice that this yearly seasonality curve is quite *wavy*, just as we
    noticed in the previous chapter with the hourly Divvy data. You may have expected
    a much smoother curve, not one with so many inflection points. This is a result
    of our yearly seasonality being too flexible – it has too many **degrees of freedom**
    or too many mathematical parameters controlling the curve. In Prophet, the number
    of parameters controlling the seasonality curve is called the **Fourier order**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到这个年度季节性曲线相当**波动**，就像我们在上一章中注意到的小时Divvy数据一样。您可能期望得到一条更平滑的曲线，而不是有这么多拐点的曲线。这是由于我们的年度季节性过于灵活——它有太多的**自由度**或太多的数学参数控制曲线。在Prophet中，控制季节性曲线的参数数量称为**傅里叶阶数**。
- en: Controlling seasonality with the Fourier order
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用傅里叶阶数控制季节性
- en: Seasonality is at the heart of how Prophet works, and Fourier series are used
    to model seasonality. To understand what a Fourier series is, and how the Fourier
    order relates to it, I’ll use an analogy from linear regression.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 季节性是Prophet工作原理的核心，傅里叶级数用于模拟季节性。为了理解傅里叶级数是什么，以及傅里叶阶数如何与之相关，我将使用线性回归的一个类比。
- en: 'You may know that increasing the order of a polynomial equation in linear regression
    will always improve your goodness of fit. For example, the simple linear regression
    equation is ![](img/B19630_05_F01.png) , with ![](img/019630_05_F02.png) being
    the slope of the line and ![](img/019630_05_F03.png) being the ![](img/019630_05_F04.png)-intercept.
    Increasing the order of your equation to, say, ![](img/019630_05_F05.png) will
    always improve your fit, at the risk of overfitting and capturing noise. You can
    always achieve an ![](img/019630_05_F06.png) value of 1 (perfect fit) by arbitrarily
    increasing the order of your polynomial equation higher and higher. The following
    figure illustrates how higher-order fits start to become quite unrealistic and
    overfit, though:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道，在线性回归中增加多项式方程的阶数总会提高你的拟合优度。例如，简单的线性回归方程是 ![](img/B19630_05_F01.png) ，其中
    ![](img/019630_05_F02.png) 是直线的斜率，![](img/019630_05_F03.png) 是 ![](img/019630_05_F04.png)
    截距。将你的方程阶数增加到，比如说，![](img/019630_05_F05.png) ，总会提高你的拟合，但风险是过拟合和捕捉噪声。你可以通过任意增加多项式方程的阶数来达到一个
    ![](img/019630_05_F06.png) 值为 1（完美拟合）。以下图示说明了高阶拟合开始变得相当不切实际和过拟合的情况：
- en: '![Figure 5.10 – Linear regression with higher-order polynomials](img/Fig_5.10.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 高阶多项式线性回归](img/Fig_5.10.jpg)'
- en: Figure 5.10 – Linear regression with higher-order polynomials
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 高阶多项式线性回归
- en: The **Linear** solid line does get the upward trend of the data correct, but
    it seems to be missing some subtle detail. The **Quadratic** dashed line is a
    better fit (indeed, this data was simulated from a quadratic equation with random
    noise). However, the **Quintic** and **Decic** curves are overfitting to the random
    noise. If we sample some more data points from this distribution, they will most
    likely cause the **Quintic** and **Decic** curves to radically change to fit the
    new data, whereas the **Linear** and **Quadratic** curves will only shift slightly.
    We may say that the order of a polynomial is proportional to the number of bends
    the curve can have to fit the data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性**实线确实正确地得到了数据的上升趋势，但它似乎遗漏了一些细微的细节。**二次**虚线是一个更好的拟合（实际上，这些数据是从具有随机噪声的二次方程中模拟出来的）。然而，**五次**和**十次**曲线正在对随机噪声进行过拟合。如果我们从这个分布中采样更多的数据点，它们很可能会使**五次**和**十次**曲线剧烈变化以适应新的数据，而**线性**和**二次**曲线只会略有偏移。我们可以说多项式的阶数与曲线可以有多少个弯曲来拟合数据成正比。'
- en: A Fourier series is simply a sum of sine waves. By changing the shape of these
    individual sine waves – the amplitude, or height of the wave; the period, or distance
    from peak to peak; and the phase, or where along the length of the wave the cycle
    begins – we can create a new and very complex wave shape.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 傅里叶级数简单地说就是正弦波的求和。通过改变这些单个正弦波的形状——振幅，即波的高度；周期，即从峰值到峰值的距离；以及相位，即波沿长度的哪个位置开始一个周期——我们可以创建一个新的非常复杂的波形。
- en: 'In the linear domain, we changed the order of the polynomial to control the
    amount of flexibility the curve has, and we changed the *β* coefficients to control
    the actual shape of the curve. Similarly, in the periodic domain, we change the
    number of sine waves in our Fourier series – this is the Fourier order – to control
    the flexibility of the final curve and we (or, more accurately, Prophet’s fitting
    equations) change the amplitude, period, and phase of the individual waves to
    control the actual shape of our final curve. You can see how this summation works
    in the following figure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性域中，我们改变多项式的阶数来控制曲线的灵活性，我们改变 *β* 系数来控制曲线的实际形状。同样，在周期域中，我们改变傅里叶级数中的正弦波数量——这就是傅里叶阶数——来控制最终曲线的灵活性，而我们（或者更准确地说，Prophet
    的拟合方程）改变单个波的振幅、周期和相位来控制我们最终曲线的实际形状。你可以在以下图中看到这个求和是如何工作的：
- en: '![Figure 5.11 – Fourier series of order 4](img/Fig_5.11.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 四阶傅里叶级数](img/Fig_5.11.jpg)'
- en: Figure 5.11 – Fourier series of order 4
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 四阶傅里叶级数
- en: The solid line is simply the sum of each of the four sine waves. By arbitrarily
    increasing the Fourier order in our model, we can always achieve a perfect fit
    for any set of data. But just as in the linear domain, this approach will inevitably
    lead to overfitting.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实线简单地是四个正弦波各自的和。通过在模型中任意增加傅里叶阶数，我们总能达到任何一组数据的完美拟合。但就像在线性域中一样，这种方法不可避免地会导致过拟合。
- en: Remember in *Figure 5**.9* when we plotted the components of the Divvy forecast
    and the yearly seasonality was too wavy? This is the result of the Fourier order
    being too high. By default, Prophet fits yearly seasonality with an order of 10,
    weekly seasonality with an order of 3, and daily seasonality (if sub-daily data
    is provided, of course) with an order of 4\. Usually, these defaults work very
    well and no tuning is needed. However, in Divvy’s case, we do need to reduce the
    Fourier order of the yearly seasonality to achieve a better fit with the data.
    Let’s see how to do that.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在*图 5**.9*中，当我们绘制 Divvy 预测的组成部分时，年度季节性过于波动？这是傅里叶阶数过高造成的。默认情况下，Prophet 使用 10
    阶数拟合年度季节性，3 阶数拟合周季节性，如果提供了子日数据，则使用 4 阶数拟合日季节性。通常，这些默认值工作得非常好，不需要调整。然而，在 Divvy
    的情况下，我们需要降低年度季节性的傅里叶阶数以更好地拟合数据。让我们看看如何做到这一点。
- en: We already have our necessary libraries imported and the data loaded into our
    `df` DataFrame from the previous example, so to continue, we need to instantiate
    a new Prophet object with a modified yearly seasonality. As before, we will set
    the seasonality mode to multiplicative, but this time, we will include the `yearly_seasonality`
    argument and set it to `4`. This is where we set the Fourier order.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从上一个示例中导入了必要的库并将数据加载到我们的`df` DataFrame中，因此为了继续，我们需要实例化一个新的 Prophet 对象，并带有修改后的年度季节性。和之前一样，我们将季节性模式设置为乘法，但这次我们将包括`yearly_seasonality`参数并将其设置为`4`。这就是我们设置傅里叶阶数的地方。
- en: You may experiment with different values on your own; I have found `4` to provide
    a clean curve without much flexibility in most cases, which is what I want here.
    Similarly, if we wanted to change the Fourier order of `weekly_seasonality` or
    `daily_seasonality`, we would do so here.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自己尝试不同的值；我发现`4`在大多数情况下提供了一个干净的曲线，没有太多的灵活性，这正是我所需要的。同样，如果我们想改变`weekly_seasonality`或`daily_seasonality`的傅里叶阶数，我们也会在这里进行。
- en: 'After instantiating our model, we merely need to fit it to the data to plot
    the seasonality. There is no need to predict in this case:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化我们的模型后，我们只需将其拟合到数据中即可绘制季节性。在这种情况下不需要预测：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will use a new function here to plot just the yearly component – the `plot_yearly`
    function from Prophet’s `plot` package. We need to import it first:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里使用一个新的函数来绘制仅包含年度成分的图表 – 来自 Prophet 的`plot`包中的`plot_yearly`函数。我们首先需要导入它：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that there is also a `plot_weekly` function, which operates much the same
    way. Both functions require the first argument to be the model; here, we will
    also include the optional figure size argument so that it matches the scale of
    our previous plot contained in *Figure 5**.9*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有一个`plot_weekly`函数，它的工作方式几乎相同。这两个函数都需要第一个参数是模型；这里，我们还将包括可选的图形大小参数，以便它与*图
    5**.9*中包含的我们之前的图表的刻度相匹配：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Compare this output with the yearly seasonality curve in *Figure 5**.9*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将此输出与*图 5**.9*中的年度季节性曲线进行比较。
- en: '![Figure 5.12 – Divvy yearly seasonality with a Fourier order of 4](img/Fig_5.12.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 使用傅里叶阶数为 4 的 Divvy 年度季节性](img/Fig_5.12.jpg)'
- en: Figure 5.12 – Divvy yearly seasonality with a Fourier order of 4
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 使用傅里叶阶数为 4 的 Divvy 年度季节性
- en: We have successfully eliminated the waviness of our previous attempt, while
    still maintaining the clear shape of the seasonality. This seems much more reasonable!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功消除了之前尝试中的波动，同时仍然保持了季节性的清晰形状。这似乎更加合理！
- en: So far, we have only been working with Prophet’s default seasonalities. However,
    there are many cyclic datasets out there with periods that don’t fall neatly into
    the yearly, weekly, or daily seasonality bins. Prophet supports custom seasonalities
    precisely for this purpose. Let’s check them out in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用过 Prophet 的默认季节性。然而，有许多周期性数据集的周期并不完美地落在年度、周或日季节性分类中。Prophet 正是为了这个目的支持自定义季节性的。让我们在下一节中查看它们。
- en: Adding custom seasonalities
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义季节性
- en: 'So far, the only seasonalities we have worked with are the defaults in Prophet:
    yearly, weekly, and daily. But there is no reason to limit ourselves to these
    seasonalities. If your data contains a cycle that is either longer or shorter
    than the 365.25-day yearly cycle, the 7-day weekly cycle, or the 1-day daily cycle,
    Prophet makes it easy to model this seasonality yourself.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的唯一季节性是 Prophet 的默认值：年度、周和日。但没有任何理由限制我们自己只使用这些季节性。如果您的数据包含一个比 365.25
    天的年度周期、7 天的周周期或 1 天的日周期更长或更短的周期，Prophet 可以让您轻松地自己建模这种季节性。
- en: A great example of a non-standard seasonality is the 11-year cycle of sunspots.
    Sunspots are regions on the Sun’s surface that temporarily exhibit a much-reduced
    temperature, and hence appear much darker than surrounding areas.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非标准季节性的好例子是太阳黑子的11年周期。太阳黑子是太阳表面暂时表现出大幅降低温度的区域，因此看起来比周围区域要暗得多。
- en: Beginning in approximately 1609, Galileo Galilei began systematic observation
    of sunspots and over the last 400+ years, this phenomenon has been constantly
    recorded. Sunspots represent the longest continuously recorded time series of
    any natural phenomenon. Through these observations, scientists have identified
    a quasi-periodic cycle of 11 years during which the frequency of sunspot occurrences
    varies. They say *quasi*-periodic because the cycle length seems to vary from
    cycle to cycle – it isn’t perfectly 11 years each time. The average cycle length
    is 11 years, though, so that is what we will use to model it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 大约从1609年开始，伽利略·伽利莱开始系统地观测太阳黑子，在过去的400多年里，这一现象一直被持续记录。太阳黑子代表了任何自然现象中连续记录时间最长的时序数据。通过这些观测，科学家们确定了一个11年的准周期循环，在此期间太阳黑子出现的频率会变化。他们称之为“准周期”是因为循环长度似乎在周期之间有所变化——并不是每次都是完美的11年。然而，平均周期长度是11年，因此我们将使用这个数字来建模。
- en: 'The **Solar Influences Data analysis Center** (**SIDC**), a department of the
    Royal Observatory of Belgium in Brussels, provides a dataset of sunspot activity
    from 1750 to the present day in their **World Data Center – Sunspot Index and
    Long-term Solar Observations** (**WDC-SILSO**) project. This dataset will be a
    good demonstration of how to add a new seasonality to Prophet. We will begin by
    loading our data:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**太阳影响数据分析中心**（**SIDC**），位于布鲁塞尔的比利时皇家天文台的部门，在其**世界数据中心——太阳黑子指数和长期太阳观测**（**WDC-SILSO**）项目中提供了从1750年到现在的太阳黑子活动数据集。这个数据集将很好地展示如何向Prophet添加新的季节性。我们将首先加载数据：'
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s visualize this data to see how it looks:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们可视化这些数据，看看它的样子：
- en: '![Figure 5.13 – Number of sunspots per month](img/Fig_5.13.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图5.13 – 每月太阳黑子数量](img/Fig_5.13.jpg)'
- en: Figure 5.13 – Number of sunspots per month
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13 – 每月太阳黑子数量
- en: The data appears rather noisy; there appear to be several outliers and the cycle
    is not perfectly clean. There is quite a lot of variation in the peak of each
    cycle. To see how Prophet will handle this data, we first need to instantiate
    our model. This is count data, so we will choose multiplicative seasonality.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 数据看起来相当嘈杂；似乎有几个异常值，循环并不完全干净。每个周期的峰值变化很大。为了看看Prophet如何处理这些数据，我们首先需要实例化我们的模型。这是计数数据，因此我们将选择乘法季节性。
- en: Another consideration we will take is that the Sun is so large that it hardly
    feels the minuscule tug of Earth’s gravity as we orbit around our star; therefore,
    the Sun does not experience what we would call a yearly seasonality at all. We
    will instruct Prophet not to attempt to fit a yearly seasonality. Prophet won’t
    attempt a weekly or daily seasonality because we are providing monthly data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将考虑的一个因素是，太阳如此之大，以至于在我们围绕我们的恒星轨道运行时几乎感觉不到地球引力的微小牵引；因此，太阳根本不会体验到我们所说的年季节性。我们将指示Prophet不要尝试拟合年季节性。由于我们提供的是月度数据，Prophet不会尝试拟合周或日季节性。
- en: 'We learned how to adjust the Fourier order of the yearly seasonality earlier
    in this chapter by passing an integer to the `yearly_seasonality` argument. This
    is the same argument we use to turn off a default seasonality; simply pass a Boolean
    instead. We pass `yearly_seasonality=False` to instruct Prophet not to fit yearly
    seasonality:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们学习了如何通过传递整数给`yearly_seasonality`参数来调整年季节性的傅里叶阶数。这是我们用来关闭默认季节性的参数；只需传递一个布尔值即可。我们传递`yearly_seasonality=False`来指示Prophet不要拟合年季节性：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once our model has been instantiated, we can add seasonalities. We can do this
    with the `add_seasonality` method. This method requires that we pass arguments
    for the name of the seasonality (we’ll call this one `''11-year cycle''`), the
    period (11 years times 365.25 days, as `period` is stated in days), and the Fourier
    order (we’ll use `5` in this case, but feel free to experiment). This is how it
    all looks together:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的模型被实例化，我们就可以添加季节性。我们可以使用`add_seasonality`方法来做这件事。此方法要求我们传递季节性的名称（我们将称之为`'11-year
    cycle'`），周期（11年乘以365.25天，因为`period`是以天为单位的），以及傅里叶阶数（在这种情况下我们将使用`5`，但请随意实验）。这就是所有内容看起来是什么样的：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Stating the period can be tricky; just remember that it is always counted in
    days. So, a seasonality longer than a day will have a number greater than 1 and
    a seasonality shorter than a day will have a period less than 1.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 说明周期可能会有些棘手；只需记住，它总是按天数计算。因此，周期长于一天的季节性将具有大于1的数字，而周期短于一天的季节性将具有小于1的周期。
- en: 'The rest of this example is exactly as in previous ones; we fit on the training
    DataFrame, create a future DataFrame, and then predict on it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的其余部分与之前的例子完全一样；我们在训练DataFrame上拟合，创建一个未来DataFrame，然后对其进行预测：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s inspect the components plot to see what we created:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查组件图，看看我们创建了什么：
- en: '![Figure 5.14 – Sunspots components plot](img/Fig_5.14.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图5.14 – 太阳黑子成分图](img/Fig_5.14.jpg)'
- en: Figure 5.14 – Sunspots components plot
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 – 太阳黑子成分图
- en: The plot shows just the trend and the 11-year cycle, which is exactly what we
    expected. The trend has a sawtooth shape; in fact, scientists have named that
    trough around **1814** the *Dalton Minimum*, named after the English meteorologist
    John Dalton. The peak during the 1950s is called the *Modern Maximum*. But it’s
    the 11-year cycle that we’re interested in here.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该图仅显示趋势和11年周期，这正是我们预期的。趋势呈锯齿状；事实上，科学家将**1814**年左右的低谷称为*达尔顿最小值*，以纪念英国气象学家约翰·达尔顿。20世纪50年代的峰值被称为*现代最大值*。但我们对这里的11年周期感兴趣。
- en: With this irregular cycle, Prophet plots the *x* axis in days, so each tick
    is about 1.5 years later than the previous tick. The whole cycle is indeed 11
    years. We can see that the low point is a bit *flatter* than the high point and
    has about 60% fewer sunspots than the average. The high point sees about 80% more
    sunspots than average.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个不规则周期，Prophet以天为单位绘制*x*轴，因此每个刻度比前一个刻度晚约1.5年。整个周期确实是11年。我们可以看到，低点比高点略*平坦*，并且比平均值少约60%的太阳黑子。高点比平均值多约80%的太阳黑子。
- en: 'To see all of the seasonalities that your model currently has, as well as the
    parameters controlling that seasonality, simply call the `seasonalities` attribute
    of the model:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看模型当前的所有季节性以及控制该季节性的参数，只需调用模型的`seasonalities`属性：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This outputs a dictionary where the keys are the names of the seasonalities
    and the values are the parameters. In this example, where we only have one seasonality,
    this is the output dictionary:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出一个字典，其中键是季节性的名称，值是参数。在这个例子中，我们只有一个季节性，这是输出字典：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Important note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When specifying a period for your seasonality, it is always specified in days.
    So, a 10-year seasonality will have a period of 10 (years) x 365.25 (days per
    year) = 3652.5 days. An hourly seasonality would be 1 (day) / 24 (hours per day)
    = 0.04167 days.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定季节性的周期时，它总是按天数指定。因此，10年的季节性将具有10（年）x 365.25（每年天数）= 3652.5天的周期。如果数据按分钟测量，则每小时季节性将是1（天）/
    24（每天小时数）= 0.04167天。
- en: Be careful not to confuse the period of seasonality with the period used in
    `make_future_dataframe`. The period in seasonality is always specified in days,
    while the period in `make_future_dataframe` is specified by the `freq` argument.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要将季节性的周期与`make_future_dataframe`中使用的周期混淆。季节性的周期总是按天数指定，而`make_future_dataframe`中的周期由`freq`参数指定。
- en: 'Adding a seasonality to Prophet that doesn’t exist in the data can cause Prophet
    to be very slow to fit, as it struggles to find a pattern where none exists. This
    can harm your forecast as Prophet will eventually fit the non-existent seasonality
    to noise. However, other seasonalities you may find yourself frequently adding
    include an hourly seasonality, if your data is measured per minute, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Prophet中不存在数据中的季节性，则添加季节性可能会导致Prophet拟合速度非常慢，因为它在找不到模式的情况下会努力寻找模式。这可能会损害你的预测，因为Prophet最终会将不存在的季节性拟合到噪声中。然而，你可能经常添加的其他季节性包括如果数据按分钟测量，则添加每小时季节性，如下所示：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Seasonality for the quarterly business cycle would be created in the following
    manner:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 季节性业务周期将按以下方式创建：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That’s how you add custom seasonalities! We’ll be using this `add_seasonality`
    method a bit more in this chapter, starting with the next section about seasonalities
    that depend on other factors.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何添加自定义季节性的！在本章中，我们将更详细地使用这个`add_seasonality`方法，从下一节关于依赖于其他因素的季节性开始。
- en: Adding conditional seasonalities
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加条件季节性
- en: Suppose you work for a utility company in a college town and are tasked with
    forecasting the electricity usage for the coming year. The electricity usage is
    going to depend on the population of the town to some extent, and as a college
    town, thousands of students are only temporary residents! How do you set up Prophet
    to handle this scenario? Conditional seasonalities exist for this purpose.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一个大学城的一家公用事业公司工作，并被要求预测下一年度的电力使用情况。电力使用在一定程度上将取决于城镇的人口，作为一个大学城，数千名学生只是临时居民！你如何设置Prophet来处理这种情况？条件季节性就是为了这个目的而存在的。
- en: Conditional seasonalities are those that are, in effect, for only a portion
    of the dates in the training and future DataFrames. A **conditional seasonality**
    must have a cycle that is shorter than the period in which it is active. So, for
    example, it wouldn’t make sense to have a yearly seasonality that is active for
    just a few months.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 条件季节性是指仅在训练和未来DataFrames的部分日期中存在的那些。一个**条件季节性**必须有一个比其活跃周期更短的周期。所以，例如，如果只有几个月是活跃的，那么有一个只活跃几个月的年度季节性就没有意义。
- en: Forecasting electricity usage in the college town would require you to set up
    either daily or weekly seasonalities – and possibly even both; depending on the
    usage patterns, one daily/weekly seasonality for the summer months when students
    have returned to their hometowns and another daily/weekly seasonality for the
    rest of the year. Ideally, the conditional seasonality would have at least two
    full cycles each time it is active.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在大学城预测电力使用需要你设置每日或每周季节性——甚至可能是两者；根据使用模式，在学生返回家乡的夏季月份设置一个每日/每周季节性，以及全年剩余时间的另一个每日/每周季节性。理想情况下，条件季节性在每次活跃时至少应有两个完整的周期。
- en: To learn how to build a conditional seasonality, we will go back to the hourly
    Divvy data that we explored in the previous chapter. Based on the weekly seasonality
    we observed in that example, we know ridership is significantly lower on weekends
    than on weekdays, suggesting most riders are commuting to work.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何构建条件季节性，我们将回到我们在上一章中探索的小时Divvy数据。基于我们在那个例子中观察到的每周季节性，我们知道周末的乘客量比周中显著较低，这表明大多数乘客是在上下班途中。
- en: We saw in the daily seasonality plot that ridership has usage peaks around 8
    a.m. and 6 p.m., during the morning and evening rush hours. This may lead you
    to suspect that the usage throughout the day will follow different patterns on
    a weekday versus the weekend. That is, maybe those peaks we see at 8 a.m.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每日季节性图中看到，骑手在早上8点和晚上6点有使用高峰，这是在上下班高峰时段。这可能会让你怀疑，整个白天的使用模式在周中和周末可能会有不同的模式。也就是说，我们早上8点看到的高峰可能。
- en: and 6 p.m. and the midday trough will all disappear on weekends, with activity
    levels more even throughout the day. To test this hypothesis, let’s build a forecast
    model using different daily seasonalities for weekends than for weekdays.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在周末，上午6点和下午6点以及中午的低谷都将消失，整个白天的活动水平更加均匀。为了测试这个假设，让我们使用周末和周中不同的每日季节性来构建一个预测模型。
- en: The basic procedure for adding this conditional seasonality is to add new Boolean
    columns to your training DataFrame (and later, matching columns in the future
    DataFrame) indicating whether that row is a weekend or weekday. Then, disable
    the default weekly seasonality and add two new weekly seasonalities that specify
    those new Boolean columns as conditions. Let’s see how to do this.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这种条件季节性的基本步骤是在你的训练DataFrame中添加新的布尔列（稍后，在未来的DataFrame中添加匹配的列），表示该行是周末还是周中。然后，禁用默认的每周季节性，并添加两个新的每周季节性，指定那些新的布尔列作为条件。让我们看看如何做这件事。
- en: 'We have the necessary libraries already loaded, so to begin, we need to create
    our Prophet DataFrame using the Divvy hourly data:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经加载了必要的库，所以首先，我们需要使用Divvy小时数据创建我们的Prophet DataFrame：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, this is where we identify the condition for our seasonality. Let’s create
    a function that outputs `True` if the given date is on a weekend and `False` otherwise.
    Then, we’ll use the `apply` method from `pandas` to create a new column for weekends
    and use the tilde (`~`) operator to take the inverse results for another new column
    for weekdays. Finally, let’s output the first few rows of our DataFrame at this
    point just so that we can see what we’ve got:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是我们确定季节性条件的地方。让我们创建一个函数，如果给定的日期是周末则输出`True`，否则输出`False`。然后，我们将使用`pandas`的`apply`方法创建一个表示周末的新列，并使用波浪号（`~`）运算符为另一个表示周中的新列取反。最后，让我们输出DataFrame的这一点的第一行，这样我们就可以看到我们得到了什么：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If your functions correctly identified the days, you should see this output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的函数正确地识别了日期，你应该会看到这个输出：
- en: '![Figure 5.15 – The Divvy conditional seasonality DataFrame](img/Fig_5.15.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15 – Divvy 条件季节性数据框](img/Fig_5.15.jpg)'
- en: Figure 5.15 – The Divvy conditional seasonality DataFrame
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – Divvy 条件季节性数据框
- en: 'January 1, 2014 was a Wednesday, so that output matches what we would expect.
    Next, we need to instantiate our model. Using what we learned earlier in this
    chapter, we will set the seasonality mode to `multiplicative`, as this Divvy data
    represents count values. We will also set the Fourier order of both yearly and
    weekly seasonalities to `6`; my testing showed that to be a good value on this
    dataset. Finally, because we are adding conditional daily seasonalities, we will
    disable the default daily seasonality:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 2014 年 1 月 1 日是星期三，所以输出符合我们的预期。接下来，我们需要实例化我们的模型。利用本章前面学到的知识，我们将季节性模式设置为 `multiplicative`，因为
    Divvy 数据代表计数值。我们还将年季节性和周季节性的傅里叶阶数都设置为 `6`；我的测试表明在这个数据集上这是一个很好的值。最后，因为我们正在添加条件每日季节性，所以我们将禁用默认的每日季节性：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To create conditional seasonalities, we will use the same `add_seasonality`
    method that we learned about while modeling the sunspot cycle, but in this case,
    we will use the optional `condition_name` argument to specify that the new seasonality
    is conditional.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建条件季节性，我们将使用我们在模拟太阳黑子周期时学到的相同的 `add_seasonality` 方法，但在这个案例中，我们将使用可选的 `condition_name`
    参数来指定新的季节性是条件性的。
- en: 'The `condition_name` argument must be passed the name of a column in the training
    DataFrame and consist of Boolean values identifying which rows to apply the seasonality
    to – our `weekend` and `weekday` columns. Just as we did in the sunspots example,
    we also need to name the seasonality and identify both the period and Fourier
    order:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition_name` 参数必须传递训练数据框中列的名称，并包含布尔值以标识要应用季节性的行 – 我们的 `weekend` 和 `weekday`
    列。就像我们在太阳黑子示例中所做的那样，我们还需要命名季节性并标识周期和傅里叶阶数：'
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That’s it for setting up the model! Next, we will fit the model on our training
    data and create the `future` DataFrame just as before, being careful to set the
    frequency to *hourly* now that we are using hourly data. The last step in setting
    up conditional seasonalities is to identify where in the future DataFrame the
    condition will apply.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 模型设置到此为止！接下来，我们将像以前一样在训练数据上拟合模型并创建 `future` 数据框，现在我们使用的是每小时数据，所以要注意将频率设置为 *hourly*。设置条件季节性的最后一步是确定在
    `future` 数据框中条件将应用在哪里。
- en: 'We already created the `is_weekend` function and applied it to our training
    DataFrame, `df`. We simply need to repeat that procedure on the `future` DataFrame
    before calling `predict` to create our forecast:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了 `is_weekend` 函数并将其应用于我们的训练数据框 `df`。我们只需在调用 `predict` 之前重复该过程于 `future`
    数据框上以创建我们的预测：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We named our two conditional seasonalities `''daily_weekend''` and `''daily_weekday''`,
    so let’s import the `plot_seasonality` function, which we discovered in the previous
    chapter, and plot these two seasonalities:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个条件季节性命名为 `'daily_weekend'` 和 `'daily_weekday'`，所以让我们导入我们在上一章中发现的 `plot_seasonality`
    函数，并绘制这两个季节性：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If everything ran correctly, you should have two new plots:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切运行正确，你应该会有两个新的图表：
- en: '![Figure 5.16 – Daily weekday component plot](img/Fig_5.16.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16 – 每日工作日成分图](img/Fig_5.16.jpg)'
- en: Figure 5.16 – Daily weekday component plot
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – 每日工作日成分图
- en: 'On weekdays, the trend appears much the same as we saw when we used the default
    daily seasonality – a peak around 8 a.m., another peak around 6 p.m., and a small
    hump just after midnight. We hypothesized that weekends would see a much different
    pattern, though. Let’s look at the plot to see:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作日，趋势与我们使用默认每日季节性时看到的情况非常相似 – 早上 8 点左右有一个峰值，下午 6 点左右另一个峰值，午夜过后有一个小峰。尽管如此，我们假设周末将看到一个非常不同的模式。让我们看看图表来了解：
- en: '![Figure 5.17 – Daily weekend component plot](img/Fig_5.17.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17 – 每日周末成分图](img/Fig_5.17.jpg)'
- en: Figure 5.17 – Daily weekend component plot
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – 每日周末成分图
- en: And indeed, we do see a difference! As your intuition might have suggested,
    on the weekends, Divvy riders tend to get a later start than on weekdays, with
    a gradual increase in ridership up until noon and then a gradual decrease to midnight.
    There is no midday slump as we saw on working days.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，我们看到了差异！正如你的直觉所暗示的，在周末，Divvy 骑行者比在工作日更晚开始，直到中午逐渐增加客流量，然后逐渐减少到午夜。在工作日我们没有看到中午的低谷。
- en: 'So far in this chapter, you used the Air Passengers data to learn the difference
    between additive and multiplicative seasonality. Later, you used the Divvy data
    to learn how to add custom seasonalities and conditional seasonalities. You also
    used the Divvy data to discover the Fourier order and learned how to control the
    flexibility of the seasonality curve. However, there is another lever Prophet
    makes available to you to control seasonality: regularization.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，您使用了Air Passengers数据来学习加性和乘性季节性的区别。后来，您使用了Divvy数据来学习如何添加自定义季节性和条件季节性。您还使用了Divvy数据来发现傅里叶阶数，并学习了如何控制季节性曲线的灵活性。然而，Prophet还为您提供了一个控制季节性的杠杆：正则化。
- en: Regularizing seasonality
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则化季节性
- en: Often, when solving a problem with machine learning, the data involved is so
    complex that a simple model just isn’t powerful enough to capture the full subtlety
    of the patterns to be found. The simple model tends to **underfit** the data.
    In contrast, a more complicated model with many parameters and great flexibility
    can tend to **overfit** the data. It is not always easy, or possible, to use a
    simpler model. In these cases, **regularization** is a good technique to use to
    control overfitting.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在用机器学习解决问题时，涉及的数据非常复杂，一个简单的模型往往不足以捕捉到要找到的模式的全部微妙之处。简单的模型往往会**欠拟合**数据。相比之下，一个更复杂的模型，具有许多参数和很大的灵活性，可能会倾向于**过拟合**数据。使用更简单的模型并不总是容易，或者可能。在这些情况下，**正则化**是一种很好的技术，可以用来控制过拟合。
- en: Prophet is such a powerful forecasting tool that without care, it can sometimes
    be very easy to overfit the data. That’s why understanding Prophet’s regularization
    parameters can be quite useful.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet是一个非常强大的预测工具，如果不加注意，有时很容易过拟合数据。这就是为什么理解Prophet的正则化参数非常有用的原因。
- en: Tip
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: A model is said to be *underfit* if it does not fully capture the true relationship
    between the input features and the output features. Performance is low on both
    the training data and any unseen testing data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模型没有完全捕捉到输入特征和输出特征之间的真实关系，那么它就被说成是*欠拟合*。在训练数据和任何未见过的测试数据上的性能都较低。
- en: A model is said to be *overfit* if it goes beyond capturing the true relationship
    and begins to capture random trends in the noise of the data. Performance can
    be very high on the training data but low on the unseen testing data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模型超出了捕捉真实关系的范围，开始捕捉数据噪声中的随机趋势，那么它就被说成是*过拟合*。在训练数据上的性能可能非常高，但在未见过的测试数据上的性能可能很低。
- en: A model with a good fit will perform equally well on both training and testing
    data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个拟合良好的模型将在训练数据和测试数据上表现同样好。
- en: 'Regularization is a technique for controlling overfitting by forcing a model
    to be less flexible. For example, in *Figure 5**.18*, I simulated a set of points
    with random noise (the true relationship I used is ![](img/019630_05_F07.png)))
    and fit two lines using 8th-degree polynomial regression (in reality, you would
    rarely choose such a high order for a regression model; I am using it here merely
    to exaggerate the point). One line is not regularized at all, and the other is:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正则化是一种通过迫使模型变得不那么灵活来控制过拟合的技术。例如，在*图5.18*中，我模拟了一组带有随机噪声的点（我使用的真实关系是![img/019630_05_F07.png]）并使用8次多项式回归拟合了两条线（实际上，你很少会选择如此高的阶数作为回归模型；我在这里只是为了夸张这个观点）。一条线完全没有正则化，而另一条线是：
- en: '![Figure 5.18 – Regularization effects](img/Fig_5.18.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图5.18 – 正则化效果](img/Fig_5.18.jpg)'
- en: Figure 5.18 – Regularization effects
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18 – 正则化效果
- en: As you can see in the plot, the unregularized line is overfit and wiggles around
    the true relationship while attempting to fit to the noise. By regularizing, in
    contrast, the flexibility of the line is constrained and it is forced to trace
    out a much smoother curve. With the true curve essentially being ![](img/019630_05_F08.png)
    , it is clear that the regularized line, while still not perfect, does a better
    job of approximating the relationship and will perform better on new data.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图中所示，未正则化的线是过拟合的，它在尝试拟合噪声的同时围绕着真实关系摇摆。相比之下，通过正则化，线的灵活性受到限制，并被迫绘制出一条更加平滑的曲线。由于真实曲线基本上是![img/019630_05_F08.png]，很明显，正则化的线，尽管仍然不完美，但在近似关系方面做得更好，并且在新数据上表现会更好。
- en: The full Prophet package has several adjustable parameters for regularization.
    For seasonality, that parameter is called the prior scale.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的Prophet包有多个可调整的正则化参数。对于季节性，该参数称为先验尺度。
- en: In statistics, you may have an uncertain quantity that you intend to find the
    value of. The **prior probability distribution**, often just called a prior, of
    that quantity is the probability distribution of values you would expect *prior
    to* learning additional information.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计学中，你可能有一个不确定的量，你打算找到它的值。这个量的 **先验概率分布**，通常简称为先验，是在学习额外信息之前你期望的值的概率分布。
- en: For example, let’s say I ask you to guess the height of a specific human male.
    In your mind, you imagine all the likely heights of males. That range of heights
    is the prior probability distribution. Next, I tell you that the male is an NBA
    basketball player. You know basketball players are typically much taller than
    the average male, so you update that distribution to skew more toward tall heights
    because the additional information I provided you with better informs your guess.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我让你猜测一个特定男性的人类身高。在你的脑海中，你想象所有可能的男性身高。这个身高范围是先验概率分布。接下来，我告诉你这个男性是 NBA 篮球运动员。你知道篮球运动员通常比普通男性高得多，所以你更新这个分布，使其更偏向于高身高，因为我所提供的额外信息更好地帮助你猜测。
- en: The prior is your starting point, what you believe to be true before receiving
    additional information. Let’s learn how to apply this idea to seasonality in Prophet.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 先验是你的起点，在你收到额外信息之前你相信是正确的。让我们学习如何将这个想法应用到 Prophet 的季节性中。
- en: Global seasonality regularization
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局季节性正则化
- en: The first way to apply seasonality regularization is globally, which affects
    all the seasonalities in your model equally. `seasonality_prior_scale` is an attribute
    of your Prophet model instance and is set when you instantiate your model. If
    you do not set it, the default will be `10`. Reducing this number will apply more
    regularization, which will rein in your model’s seasonalities. Let’s see this
    in action.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 应用季节性正则化的第一种方式是全局性的，这会影响模型中所有季节性的同等程度。`seasonality_prior_scale` 是你的 Prophet
    模型实例的一个属性，并在你实例化模型时设置。如果你没有设置它，默认值将是 `10`。减少这个数值将应用更多的正则化，这将控制你的模型季节性。让我们看看实际效果。
- en: 'We’ll use the Divvy daily data in this example, so we need to begin by loading
    it into our Prophet DataFrame, as the necessary libraries should already be loaded
    from previous examples:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用 Divvy 每日数据，因此我们需要首先将其加载到我们的 Prophet DataFrame 中，因为必要的库应该已经从之前的例子中加载：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we need to instantiate our model, setting the seasonality mode to `multiplicative`.
    While learning about Fourier order, you went through a forecast with this dataset
    using the default `seasonality_prior_scale` value of `10`. So, let’s use a prior
    scale this time around of `0.01`. We also found the yearly seasonality to be better
    modeled with a Fourier order of `4`, so we’ll set that as well. You can refer
    back to *Figure 5**.8* and *Figure 5**.9* to see the unregularized model for comparison:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实例化我们的模型，将季节性模式设置为 `multiplicative`。在了解傅里叶阶数时，你使用默认的 `seasonality_prior_scale`
    值 `10` 对这个数据集进行了预测。所以，这次我们将先验尺度设置为 `0.01`。我们还发现，使用傅里叶阶数 `4` 更好地模拟了年度季节性，因此我们也将它设置为
    `4`。你可以参考 *图 5.8* 和 *图 5.9* 来查看未正则化的模型以进行比较：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With the regularization set, all that is left to do is complete the model,
    as we did earlier:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 设置正则化后，剩下的工作就是完成模型，就像我们之前做的那样：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'First, we will look at the forecast, and then the components:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看预测，然后是组件：
- en: '![Figure 5.19 – Regularized forecast](img/Fig_5.19.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.19 – 正则化预测](img/Fig_5.19.jpg)'
- en: Figure 5.19 – Regularized forecast
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19 – 正则化预测
- en: Comparing *Figure 5**.19* with *Figure 5**.8* shows that the seasonal swings
    in our forecast have indeed been dampened. Both the annual seasonality and the
    weekly seasonality show less variation. The uncertainty intervals between the
    two models are roughly the same, though, because the variance in the data is now
    handled in the Prophet model’s noise term instead of the seasonality term.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *图 5.19* 与 *图 5.8* 进行比较显示，我们的预测中的季节性波动确实已经减弱。年度季节性和周季节性都显示出更少的波动。不过，两个模型之间的不确定性区间大致相同，因为现在数据中的方差现在由
    Prophet 模型的噪声项而不是季节性项来处理。
- en: 'Now, let’s look at the components plot:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看组件图：
- en: '![Figure 5.20 – Regularized components plot](img/Fig_5.20.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.20 – 正则化组件图](img/Fig_5.20.jpg)'
- en: Figure 5.20 – Regularized components plot
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20 – 正则化组件图
- en: 'Comparing this figure with *Figure 5**.9*, we can see that the trend is very
    similar. We only constrained the seasonality, not the trend. The trend did change
    a bit (the peak value is a bit higher) because Prophet is attempting to capture
    some of the seasonal variations with the trend, but the shape is nearly identical.
    The weekly and yearly seasonalities appear the same, but their *y* axes show that
    the magnitudes have been reduced in the range of one-third to one-quarter of their
    regularized levels. This is the effect of seasonality regularization: it reduces
    the magnitude of the curve’s values.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将此图与*图5.9*进行比较，我们可以看到趋势非常相似。我们只限制了季节性，而没有限制趋势。趋势确实有所变化（峰值略高），因为Prophet试图通过趋势捕捉一些季节性变化，但形状几乎相同。每周和年度季节性看起来相同，但它们的*y*轴显示，幅度已经减少到其正则化水平的三分之一到四分之一。这就是季节性正则化的效果：它减少了曲线值的幅度。
- en: 'To illustrate the effect of different seasonality prior scales, let’s compare
    the yearly and weekly seasonality curves of this dataset when modeled with different
    prior scales. First, here is the yearly seasonality plot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明不同季节性先验尺度的效果，让我们比较使用不同先验尺度建模的此数据集的年度和每周季节性曲线。首先，这是年度季节性图：
- en: '![Figure 5.21 – Yearly seasonality with different prior scales](img/Fig_5.21.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图5.21 – 不同先验尺度的年度季节性](img/Fig_5.21.jpg)'
- en: Figure 5.21 – Yearly seasonality with different prior scales
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21 – 不同先验尺度的年度季节性
- en: 'And here is the weekly seasonality plot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每周季节性图：
- en: '![Figure 5.22 – Weekly seasonality with different prior scales](img/Fig_5.22.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图5.22 – 不同先验尺度的每周季节性](img/Fig_5.22.jpg)'
- en: Figure 5.22 – Weekly seasonality with different prior scales
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.22 – 不同先验尺度的每周季节性
- en: The solid line in both plots is the default scale of `10`; the dashed line and
    dashed-dotted line show increasing regularization amounts. Whereas modifying the
    Fourier order helped control the seasonality curve by reducing the number of bends
    it was allowed to take, modifying the seasonality prior scale helps control seasonality
    by reducing the amount of variation it can achieve.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 两个图中的实线是默认的`10`倍尺度；虚线和虚点线显示正则化量的增加。而修改傅里叶阶数有助于通过减少允许曲线弯曲的数量来控制季节性曲线，而修改季节性先验尺度有助于通过减少它可以实现的变化量来控制季节性。
- en: In this section, you learned how to regularize all seasonalities at the same
    time. Next, learn see how to regularize the seasonalities individually.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何同时正则化所有季节性。接下来，您将学习如何单独正则化季节性。
- en: Local seasonality regularization
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地季节性正则化
- en: Let’s say that you are happy with the yearly seasonality curve with the default
    regularization setting, but your weekly curve is too extreme and overfitting.
    In that case, you can use the `add_seasonality` method to create a new weekly
    seasonality with a custom prior scale.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您对默认正则化设置下的年度季节性曲线感到满意，但您的每周曲线过于极端且过拟合。在这种情况下，您可以使用`add_seasonality`方法创建一个新的具有自定义先验尺度的每周季节性。
- en: 'Let’s continue and instantiate a new model, again with `multiplicative` seasonality
    and a Fourier order of `4` applied to the yearly seasonality. This time, though,
    we will be adding a new weekly seasonality, so let’s remove the default by setting
    it to `False` while instantiating:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续并实例化一个新的模型，再次使用`乘法`季节性和应用于年度季节性的傅里叶阶数`4`。不过，这次我们将添加一个新的每周季节性，所以让我们在实例化时将其设置为`False`：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you learned in the *Adding custom seasonalities* section, we will now add
    a seasonality with a period of `7` days and name it `''weekly''`. We are happy
    with the default weekly Fourier order of `4`, so we’ll use that again here, but
    we want more regularization than is the default, so we will use the `prior_scale`
    argument to set it to `0.01`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在*添加自定义季节性*部分所学，我们现在将添加一个周期为`7`天的季节性，并将其命名为`'weekly'`。我们对默认的每周傅里叶阶数`4`感到满意，所以我们将再次使用它，但我们需要比默认值更多的正则化，因此我们将使用`prior_scale`参数将其设置为`0.01`：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, as I hope is becoming second nature to you, we will fit the model and
    predict on the future DataFrame. Let’s just plot the components this time:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我希望这已经成为您的第二天性，我们将拟合模型并在未来的DataFrame上进行预测。这次我们只绘制组件：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should see this plot, which looks nearly identical to *Figure 5**.20*:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到这个图，它与*图5.20*几乎相同：
- en: '![Figure 5.23 – Weekly regularized components plot](img/Fig_5.23.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图5.23 – 每周正则化成分图](img/Fig_5.23.jpg)'
- en: Figure 5.23 – Weekly regularized components plot
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.23 – 每周正则化成分图
- en: You’ll now see that the magnitude of the unregularized yearly seasonality matches
    that of *Figure 5**.9*, but the regularized weekly seasonality is reduced by about
    half, as expected. All of your seasonalities can have different regularization
    strengths applied, simply with repeated `add_seasonality` calls. Reasonable values
    for these prior scales range from about 10 down to around 0.01.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在会看到未正则化的年季节性的幅度与*图5**.9*的幅度相匹配，但正则化的周季节性减少了大约一半，正如预期的那样。你可以通过重复调用`add_seasonality`来为所有的季节性应用不同的正则化强度。这些先验尺度的合理值从大约10到大约0.01不等。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Seasonality truly is the heart of Prophet. This chapter covered a lot of ground;
    the foundations you learned here will be used throughout the remaining chapters
    of this book. Indeed, almost any model you build in Prophet will have seasonality
    considerations, whereas many of the upcoming chapters cover special cases that
    may or may not apply to your specific problem.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 季节性确实是Prophet的核心。这一章涵盖了大量的内容；你在这里学到的基础知识将在本书剩余的章节中得到应用。实际上，你几乎在Prophet中构建的任何模型都将考虑季节性，而许多即将到来的章节涵盖了可能或可能不适用于你特定问题的特殊情况。
- en: You started this chapter by learning the difference between additive and multiplicative
    seasonality, and how to identify whether your dataset features one or the other.
    We then briefly discussed the Fourier series and demonstrated how a partial Fourier
    sum can build a very complex periodic curve. Using these ideas, you learned how
    setting the Fourier order of a seasonality can be used to control its shape by
    allowing either more or less freedom to bend along its path.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过学习加性和乘性季节性的区别，以及如何识别你的数据集特征是其中之一开始了这一章。然后我们简要讨论了傅里叶级数，并展示了如何通过允许更多的或更少的自由度在其路径上弯曲来控制季节性的傅里叶阶数，从而构建一个非常复杂的周期曲线。使用这些想法，你学习了如何通过允许更多的或更少的自由度在其路径上弯曲来控制季节性的形状。
- en: Next, you modeled the 11-year cycle of sunspots and learned how to add custom
    seasonalities. These custom seasonalities came into use again when you learned
    how to model the different weekday and weekend behaviors of riders on Divvy’s
    network using conditional seasonalities. Finally, we looked at regularization
    techniques, both globally as applied to all seasonalities together and locally,
    using yet again the custom seasonalities lesson to apply regularization to just
    the weekly seasonality alone.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你学习了太阳黑子11年周期的建模，并学会了如何添加自定义季节性。当你学习如何使用条件季节性来建模Divvy网络中骑手在不同工作日和周末的行为时，这些自定义季节性再次被使用。最后，我们探讨了正则化技术，包括全局正则化，即应用于所有季节性，以及局部正则化，再次使用自定义季节性课程来仅对周季节性进行正则化。
- en: In the next chapter, you will learn all about holidays in the Prophet package,
    which, among many other topics, will also include more detail about regularization
    as it applies to Prophet.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习Prophet包中所有关于节假日的知识，其中还包括关于正则化的更多细节，正则化是应用于Prophet的。
