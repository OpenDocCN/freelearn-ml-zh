<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Nonlinearity"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Nonlinearity</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Generalized additive models - measuring the household income of New Zealand</li><li class="listitem" style="list-style-type: disc">Smoothing splines - understanding cars and speed</li><li class="listitem" style="list-style-type: disc">Local regression - understanding drought warnings and impact</li></ul></div><div class="section" title="Generalized additive models - measuring the household income of New Zealand"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Generalized additive models - measuring the household income of New Zealand</h1></div></div></div><p>An income survey provides a snapshot of income levels for people and households. It gives median and average weekly income from most sources. There are income comparisons across different population groups. Income is only received intermittently, whereas consumption is smoothed over time. As a consequence, it is reasonable to expect that consumption is more directly related to current living standards than current income, at least for short reference periods.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec27"/>Getting ready</h2></div></div></div><p>In order to perform shrinkage methods, we will be using a dataset collected on the New Zealand Census 2013.</p><div class="section" title="Step 1 - collecting and describing data"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec68"/>Step 1 - collecting and describing data</h3></div></div></div><p>The <code class="literal">nzcensus</code> package contains demographic values of New Zealand that are more than 60 in number. These values have been accumulated at the level of mesh block, area unit, territorial authority, and regional council.</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec28"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - exploring data"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec69"/>Step 2 - exploring data</h3></div></div></div><p>The first step is to load the following packages:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; devtools::install_github("ellisp/nzelect/pkg2")</strong></span>
<span class="strong"><strong>&gt; library(leaflet)</strong></span>
<span class="strong"><strong>&gt; library(nzcensus)</strong></span>
<span class="strong"><strong>&gt; library(Metrics)</strong></span>
<span class="strong"><strong>&gt; library(ggplot2)</strong></span>
<span class="strong"><strong>&gt; library(scales)</strong></span>
<span class="strong"><strong>&gt; library(boot)</strong></span>
<span class="strong"><strong>&gt; library(dplyr)</strong></span>
<span class="strong"><strong>&gt; library(Hmisc)</strong></span>
<span class="strong"><strong>&gt; library(mgcv)</strong></span>
<span class="strong"><strong>&gt; library(caret)</strong></span>
<span class="strong"><strong>&gt; library(grid)</strong></span>
<span class="strong"><strong>&gt; library(stringr)</strong></span>
<span class="strong"><strong>&gt; library(ggrepel)</strong></span>
<span class="strong"><strong>&gt; library(glmnet)</strong></span>
<span class="strong"><strong>&gt; library(maps)</strong></span>
</pre><p>Removing Chatham Islands from the dataset. <code class="literal">AreaUnits2013</code> is an esriGeometryPolygon Geometry Type object. It defines area units from the 2013 Census pattern:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; tmp &lt;- AreaUnits2013[AreaUnits2013$WGS84Longitude&gt; 0 &amp; !is.na(AreaUnits2013$MedianIncome2013), ]</strong></span>
</pre><p>Creating a color palette function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; palette &lt;- colorQuantile("RdBu", NULL, n = 10)</strong></span>
</pre><p>Creating labels for popups. The <code class="literal">paste0()</code> function concatenates vectors after converting to character:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; labels &lt;- paste0(tmp$AU_NAM, " $", format(tmp$MedianIncome2013, big.mark = ","))</strong></span>
</pre><p>Drawing the map:</p><pre class="programlisting">
<span class="strong"><strong>&gt; leaflet() %&gt;%</strong></span>
<span class="strong"><strong>+ addProviderTiles("CartoDB.Positron") %&gt;%</strong></span>
<span class="strong"><strong>+ addCircles(lng = tmp$WGS84Longitude, lat = tmp$WGS84Latitude,</strong></span>
<span class="strong"><strong>+ color = pal(-tmp$MedianIncome2013),</strong></span>
<span class="strong"><strong>+ popup = labs,</strong></span>
<span class="strong"><strong>+ radius = 500) %&gt;%</strong></span>
<span class="strong"><strong>+ addLegend(</strong></span>
<span class="strong"><strong>+ pal = pal,</strong></span>
<span class="strong"><strong>+ values = -tmp$MedianIncome2013,</strong></span>
<span class="strong"><strong>+ title = "Quantile of median&lt;br&gt;household income",</strong></span>
<span class="strong"><strong>+ position = "topleft",</strong></span>
<span class="strong"><strong>+ bins = 5)
</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_001.jpg" alt="Step 2 - exploring data"/></div><p>
</p></div><div class="section" title="Step 3 - setting up the data for the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec70"/>Step 3 - setting up the data for the model</h3></div></div></div><p>Getting the data into a convenient shape. Eliminate the area's code and name, and the redundant coordinate system:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; au &lt;- AreaUnits2013 %&gt;%     +  select(-AU2014, -AU_NAM, -NZTM2000Easting, -NZTM2000Northing) %&gt;%     +  select(-PropWorked40_49hours2013, -Prop35to39_2013, -PropFemale2013)     &gt; row.names(au) &lt;- AreaUnits2013$AU_NAM</strong></span>
</pre><p>Replacing all occurrences of a repetitive pattern. The <code class="literal">gsub()</code> function searches for patterns <code class="literal">"_2013"</code>, <code class="literal">"2013"</code>, and <code class="literal">"Prop"</code>, and then replaces them with <code class="literal">names(au)</code>:</p><pre class="programlisting">
<span class="strong"><strong> names(au) &lt;- gsub("_2013", "", names(au))
&gt; names(au) &lt;- gsub("2013", "", names(au))
&gt; names(au) &lt;- gsub("Prop", "", names(au))</strong></span>
</pre><p>Fetching a logical vector indicating that a set of cases is complete:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; au &lt;- au[complete.cases(au), ]</strong></span>
</pre><p>Providing a generic name:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; data_use &lt;- au</strong></span>
</pre><p>Exploring the dimension of the <code class="literal">data_use</code> data frame. The <code class="literal">dim()</code> function returns the dimension of the <code class="literal">data_use</code> frame. The <code class="literal">data_use</code>
<code class="literal">data</code> frame is passed as an input parameter. The result clearly states that there are <code class="literal">1785</code> rows of data and <code class="literal">69</code> columns:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dim(data_use)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_002.jpg" alt="Step 3 - setting up the data for the model"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; data_use &lt;- data_use[the_data$WGS84Longitude &gt; 100, ]</strong></span>
</pre><p>Creating syntactically valid names out of character vectors and setting them. The <code class="literal">names()</code> function sets the names of the <code class="literal">data_use</code> object while it creates syntactically valid names out of character vectors returned:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; names(data_use) &lt;- make.names(names(data_use))</strong></span>
</pre><p>Displaying the names created from the <code class="literal">data_use</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; names(data_use)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_003.jpg" alt="Step 3 - setting up the data for the model"/></div><p>
</p></div><div class="section" title="Step 4 - building the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec71"/>Step 4 - building the model</h3></div></div></div><p>Estimating the strength of the non-parametric model. <code class="literal">spearman2()</code> computes the square of Spearman's rho rank correlation, and a generalization of it in which <span class="emphasis"><em>x</em></span> can relate non-monotonically to <span class="emphasis"><em>y</em></span>. This is done by computing the Spearman multiple rho-squared between <span class="emphasis"><em>(rank(x), rank(x)^2)</em></span>, and <span class="emphasis"><em>y</em></span>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; reg_data &lt;- spearman2(MedianIncome ~ ., data = data_use)</strong></span>
</pre><p>Ordering data in descending order:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; reg_data[order(-reg_data[ ,6])[1:15], ]</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_004.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>Allocating flexible splines to the first 15 variables. The <code class="literal">terms()</code> function extracts <code class="literal">terms</code> objects from multiple R data objects:</p><pre class="programlisting">
<span class="strong"><strong>&gt; reg_formula &lt;- terms(MedianIncome ~
s(FullTimeEmployed, k = 6) +
s(InternetHH, k = 6) +
s(NoQualification, k = 5) +
s(UnemploymentBenefit, k = 5) +
s(Smoker, k = 5) +
s(Partnered, k = 5) +
s(Managers, k = 4) +
s(Bachelor, k = 4) +
s(SelfEmployed, k = 4) +
s(NoMotorVehicle, k = 4) +
s(Unemployed, k = 3) +
s(Labourers, k = 3) +
s(Worked50_59hours, k = 3) +
s(Separated, k = 3) +
s(Maori, k = 3) +
s(WGS84Longitude, WGS84Latitude) +
.,
data = data_use)</strong></span>
</pre><p>Fitting the generalized additive model. <code class="literal">reg_formula</code> is the formula, while <code class="literal">data_use</code> is the dataset.</p><pre class="programlisting">
<span class="strong"><strong>    &gt; gam_model &lt;- gam(reg_formula, data = data_use) </strong></span>
</pre><p>Plotting <code class="literal">gam_model</code>.</p><pre class="programlisting">
<span class="strong"><strong>    &gt; par(bty = "l", mar = c(5,4, 2, 1))     &gt; par(mar = rep(2, 4))     &gt; plot(gam_model, residuals = TRUE, pages = 1, shade = TRUE, seWithMean = TRUE, ylab = "")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_005.jpg" alt="Step 4 - building the model"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; rmses_gam_boot &lt;- boot(data = data_use, statistic = fit_gam, R = 99)</strong></span>
</pre><p>Printing the <code class="literal">rmses_gam_boot</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; rmses_gam_boot</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_006.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>Calculating the mean of <code class="literal">rmses_gam_boot$t</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; gam_rmse &lt;- mean(rmses_gam_boot$t)</strong></span>
</pre><p>Printing the <code class="literal">gam_rmse</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; gam_rmse</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_007.jpg" alt="Step 4 - building the model"/></div><p>
</p></div></div></div></div>
<div class="section" title="Smoothing splines - understanding cars and speed"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Smoothing splines - understanding cars and speed</h1></div></div></div><p>In order to determine the parameters required in statistics for fitting a model, multiple methods can be used. In each of the cases, fitting involves the estimating of a small number of parameters from the data. Apart from estimating parameters, two important stages are the identification of a suitable model and the verification of the model. These smoothing methods can be used in a variety of ways: to aid understanding and produce smoothed plots, to identify a suitable parametric model from the shape of the smoothed data, or to focus on the effects of interest in order to eliminate complex effects which are of no use.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec29"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 1 - exploring the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec72"/>Step 1 - exploring the data</h3></div></div></div><p>The first step is to load the following packages:</p><pre class="programlisting">
<span class="strong"><strong>&gt; install.packages("graphics")
&gt; install.packages("splines")
&gt; library(graphics)
&gt; library(splines)</strong></span>
</pre><p>Creating a matrix. The <code class="literal">cbind()</code> function takes the sequence of numbers and creates a matrix. The result is then passed to the <code class="literal">matrix()</code> function, which creates the matrix with two rows. The result is then stored in the matrix:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; matrx = matrix(cbind(1,.99, .99,1),nrow=2)</strong></span>
</pre></div><div class="section" title="Step 2 - creating the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec73"/>Step 2 - creating the model</h3></div></div></div><p>Cholesky factorization creates positive-definite matrix <span class="emphasis"><em>A</em></span>, which can be factored as <span class="emphasis"><em>A=LL<sup>T</sup></em></span>, where <span class="emphasis"><em>L</em></span> is lower triangular with positive diagonal elements. The <code class="literal">chol()</code> function computes Cholesky factorization of a real, symmetrical, positive-definite square matrix. The result is then stored in <code class="literal">cholsky</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; cholsky = t(chol(matrx))
&gt; nvars = dim(cholsky)[1]</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_05_008.jpg" alt="Step 2 - creating the model"/></div><p>
</p><p>Number of observations for density distribution:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; numobs = 1000     
&gt; set.seed(1)</strong></span>
</pre><p>Calculating a matrix using normal distribution. <code class="literal">rnorm()</code> calculates normal distribution, with <code class="literal">numobs</code> as the number of observations to be used. The result is then used by the <code class="literal">matrix()</code> function to the compute matrix, with <code class="literal">nrow=nvars</code> as two rows and <code class="literal">ncol=numobs</code> as 1,000 columns. The result is stored in <code class="literal">random_normal</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; random_normal = matrix(rnorm(nvars*numobs,10,1), nrow=nvars, ncol=numobs)</strong></span>
</pre><p>Performing matrix multiplication. <code class="literal">cholsky</code> is multiplied with matrix <code class="literal">random_normal</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; X = cholsky %*% random_normal</strong></span>
</pre><p>Transposing matrix <code class="literal">X</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; newX = t(X)</strong></span>
</pre><p>Creating a data frame of the matrix. The <code class="literal">as.data.frame()</code> function creates the data frame raw, tightly coupled collections of variables which share many of the properties of matrix <code class="literal">newX</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; raw = as.data.frame(newX)</strong></span>
</pre><p>Printing the raw data frame. The <code class="literal">head()</code> function returns the first part of the raw data frame. The raw data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(raw)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_009.jpg" alt="Step 2 - creating the model"/></div><p>
</p><p>Creating a transposed data frame of <code class="literal">random_normal</code>. The <code class="literal">t()</code> function creates a transposed matrix of the <code class="literal">random_normal</code> matrix, which is then converted to tightly coupled collections of variables. These share many of the properties of the matrix:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; raw_original = as.data.frame(t(random_normal))</strong></span>
</pre><p>Combining the names response and <code class="literal">predictor1</code>. The <code class="literal">c()</code> function combines the arguments response and <code class="literal">predictor1</code> to form a vector:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; names(raw) = c("response","predictor1")</strong></span>
</pre><p>Exponential rise of <code class="literal">raw$predictor1</code> to power 3:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; raw$predictor1_3 = raw$predictor1^3</strong></span>
</pre><p>Printing the <code class="literal">raw$predictor1_3</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">raw$predictor1_3</code> data frame. The <code class="literal">raw$predictor1_3data</code> frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(raw$predictor1_3)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_010.jpg" alt="Step 2 - creating the model"/></div><p>
</p><p>Exponential rise of <code class="literal">raw$predictor1</code> to power 2:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; raw$predictor1_2 = raw$predictor1^2</strong></span>
</pre><p>Printing the <code class="literal">raw$predictor1_2</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">raw$predictor1_2</code> data frame. The <code class="literal">raw$predictor1_2</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(raw$predictor1_2)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_011.jpg" alt="Step 2 - creating the model"/></div><p>
</p><p>Building an ordinary least squares estimation with <code class="literal">raw$response ~ raw$predictor1_3</code> as the formula. The <code class="literal">lm()</code> function is used to fit linear models. <code class="literal">raw$response ~ raw$predictor1_3</code> is the formula. The result is then stored in the fit data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; fit = lm(raw$response ~ raw$predictor1_3)</strong></span>
</pre><p>Printing the fit data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; fit</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_012.jpg" alt="Step 2 - creating the model"/></div><p>
</p><p>Plotting the ordinary least squares estimation formula. The <code class="literal">plot()</code> function is a Generic function for plotting R objects. The <code class="literal">raw$response ~ raw$predictor1_3</code> formula is passed as a function value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; plot(raw$response ~ raw$predictor1_3, pch=16, cex=.4, xlab="Predictor", ylab="Response", col ="red", main="Simulated Data with Slight Curve")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_013.jpg" alt="Step 2 - creating the model"/></div><p>
</p><p>Adding a straight function through the current plot:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; abline(fit)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_014.jpg" alt="Step 2 - creating the model"/></div><p>
</p><p>Fitting the value of cars and speeds on the <span class="emphasis"><em>x</em></span> axis:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; x_axis &lt;- with(cars, speed)</strong></span>
</pre><p>Fitting the value of cars and speeds on the y axis:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; y_axis &lt;- with(cars, dist)</strong></span>
</pre><p>Setting the number of points for smooth curve evaluation:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; eval_length = 50</strong></span>
</pre></div><div class="section" title="Step 3 - fitting the smooth curve model"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec74"/>Step 3 - fitting the smooth curve model</h3></div></div></div><p>Fitting a smooth curve between two variables is a non-parametric method, because the linearity assumptions of conventional regression methods have been relaxed. It is called <span class="strong"><strong>local regression</strong></span>, because the fitting at, say, point <span class="emphasis"><em>x</em></span>, is weighted toward the data nearest to <span class="emphasis"><em>x</em></span>.</p><p>The <code class="literal">loess.smooth()</code> function plots and adds a smooth curve computed to a scatter plot. <code class="literal">x_axis</code>, <code class="literal">y_axis</code> are the arguments provided to the x and y coordinates of the plot. <code class="literal">evaluation = eval.length</code> for example <code class="literal">eval_length = 50</code>, represents the points for smooth curve evaluation. <code class="literal">span=.75</code> is the smoothness parameter. <code class="literal">degree=1</code> is the degree of the local polynomial:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; fit_loess &lt;- loess.smooth(x_axis, y_axis, evaluation = eval_length, family="gaussian", span=.75, degree=1) </strong></span>
</pre><p>Printing the <code class="literal">fit_loess</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; fit_loess</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_015.jpg" alt="Step 3 - fitting the smooth curve model"/></div><p>
</p><p>Fitting a polynomial surface on the basis of one or more numerical predictors, using local fitting. The <code class="literal">loess()</code> function fits the polynomial surface. <code class="literal">y_axis ~ x_axis</code> represents the formula. <code class="literal">span=.75</code> is the smoothness parameter. <code class="literal">degree=1</code> is the degree of the local polynomial:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; fit_loess_2 &lt;- loess(y_axis ~ x_axis, family="gaussian", span=.75, degree=1)</strong></span>
</pre><p>Printing the <code class="literal">fit_loess_2</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; fit_loess_2</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_016.jpg" alt="Step 3 - fitting the smooth curve model"/></div><p>
</p><p>Generating regular sequences of minimum and maximum values of the <span class="emphasis"><em>y</em></span> axis. The <code class="literal">Seq()</code> function takes in <code class="literal">length.out=eval_length</code> for example <code class="literal">eval_length = 50</code>, which indicates the desired length of the sequence to be generated from the minimum and maximum values of the <span class="emphasis"><em>x</em></span> axis:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; new_x_axis = seq(min(x_axis),max(x_axis), length.out=eval_length)</strong></span>
</pre><p>Printing the <code class="literal">new_x_axis</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; new_x_axis</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_017.jpg" alt="Step 3 - fitting the smooth curve model"/></div><p>
</p><p>Setting a confidence level of 95% on the <code class="literal">fit.loess</code> model:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; conf_int = cbind( </strong></span>
<span class="strong"><strong>     + predict(fit_loess_2, data.frame(x=new_x_axis)), </strong></span>
<span class="strong"><strong>     + predict(fit_loess_2, data.frame(x=new_x_axis))+ </strong></span>
<span class="strong"><strong>     + predict(fit_loess_2, data.frame(x=new_x_axis), se=TRUE)$se.fit*qnorm(1-.05/2), </strong></span>
<span class="strong"><strong>     + predict(fit_loess_2, data.frame(x=new_x_axis))- </strong></span>
<span class="strong"><strong>     + predict(fit_loess_2, data.frame(x=new_x_axis), se=TRUE)$se.fit*qnorm(1-.05/2) </strong></span>
<span class="strong"><strong>     + )</strong></span>
</pre><p>Building an ordinary least squares estimation with <code class="literal">y_axis ~ x_axis</code> as the formula. The <code class="literal">lm()</code> function is used to fit linear models. <code class="literal">y_axis ~ x_axis</code> is the formula. The result is then stored in the <code class="literal">fit_lm</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; fit_lm = lm(y_axis ~ x_axis)</strong></span>
</pre><p>Printing the <code class="literal">fit_lm</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; fit_lm</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_018.jpg" alt="Step 3 - fitting the smooth curve model"/></div><p>
</p><p>Building a polynomial function. <code class="literal">y_axis ~ poly(x_axis,3)</code> is a polynomial function with three degrees of freedom. The <code class="literal">lm()</code> function is used to fit linear models. <code class="literal">y_axis ~ poly(x_axis,3)</code> is the formula. The result is then stored in the <code class="literal">fit_poly</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; fit_poly = lm(y_axis ~ poly(x_axis,3) )</strong></span>
</pre><p>Printing the <code class="literal">fit_poly</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; fit_poly</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_019.jpg" alt="Step 3 - fitting the smooth curve model"/></div><p>
</p><p>Building a natural spline function. <code class="literal">y_axis ~ ns(x_axis, 3)</code> is the natural spline function with degree 3 of freedom. The <code class="literal">lm()</code> function is used to fit linear models. <code class="literal">y_axis ~ ns(x_axis, 3)</code> is the formula. The result is then stored in the <code class="literal">fit_nat_spline</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; fit_nat_spline = lm(y_axis ~ ns(x_axis, 3) )</strong></span>
</pre><p>Printing the <code class="literal">fit_nat_spline</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; fit_nat_spline</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_020.jpg" alt="Step 3 - fitting the smooth curve model"/></div><p>
</p><p>Smoothing of the spline:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; fit_smth_spline &lt;- smooth.spline(y_axis ~ x_axis, nknots=15)</strong></span>
</pre><p>Printing the <code class="literal">fit_smth_spline</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; fit_smth_spline</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_021.jpg" alt="Step 3 - fitting the smooth curve model"/></div><p>
</p></div><div class="section" title="Step 4 - plotting the results"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec75"/>Step 4 - plotting the results</h3></div></div></div><p>Plotting the model:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; plot(x_axis, y_axis, xlim=c(min(x_axis),max(x_axis)), ylim=c(min(y_axis),max(y_axis)), pch=16, cex=.5, ylab = "Stopping Distance (feet)", xlab= "Speed (MPH)", main="Comparison of Models", sub="Splines")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_022.jpg" alt="Step 4 - plotting the results"/></div><p>
</p><p>Adding additional models to the graph. Plotting LOESS with Confidence Intervals:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; matplot(new_x_axis, conf_int, lty = c(1,2,2), col=c(1,2,2), type = "l", add=T)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_023.jpg" alt="Step 4 - plotting the results"/></div><p>
</p><p>Plotting an ordinary least squares estimation. The <code class="literal">predict()</code> function predicts values based on linear models. <code class="literal">fit_lm</code> is an object of class <code class="literal">lm</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; lines(new_x_axis, predict(fit_lm, data.frame(x=new_x_axis)), col="red", lty=3)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_024.jpg" alt="Step 4 - plotting the results"/></div><p>
</p><p>Plotting a polynomial function estimation:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; lines(new_x_axis, predict(fit_poly, data.frame(x=new_x_axis)), col="blue", lty=4)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/B04714_05_38.jpg" alt="Step 4 - plotting the results"/></div><p>
</p><p>Plotting a natural spline function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; lines(new_x_axis, predict(fit_nat_spline, data.frame(x=new_x_axis)), col="green", lty=5)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_025.jpg" alt="Step 4 - plotting the results"/></div><p>
</p><p>Plotting a smoothed spline:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; lines(fit_smth_spline, col="dark grey", lty=6)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_026.jpg" alt="Step 4 - plotting the results"/></div><p>
</p><p>Plotting a kernel curve. The <code class="literal">ksmooth()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; lines(ksmooth(x_axis, y_axis, "normal", bandwidth = 5), col = 'purple', lty=7)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_027.jpg" alt="Step 4 - plotting the results"/></div><p>
</p></div></div></div>
<div class="section" title="Local regression - understanding drought warnings and impact"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Local regression - understanding drought warnings and impact</h1></div></div></div><p>Drought is a natural hazard which is measured and characterized by lower-than-expected or lower-than-normal rainfall. This condition, when prolonged over a longer-than-normal time period is insufficient to meet the demands of human activities and hazardous to the environment. Drought is a temporary phenomenon. Three main distinguishing features of droughts are intensity, duration, and spatial coverage. A drought early warning system can help to identify the climatic changes, understand water supply trends, and prepare for upcoming emergencies. The drought warning can help decision-makers take appropriate measures to face the upcoming challenge. They can then measure the severity of the impact and understand the underlying causes of vulnerability to reduce risk for a particular location and for a specific group of people or economic sector.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec30"/>Getting ready</h2></div></div></div><p>Let's get started with the recipe.</p><div class="section" title="Step 1 - collecting and describing data"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec76"/>Step 1 - collecting and describing data</h3></div></div></div><p>The <code class="literal">dataRetrieval</code> package is a collection of functions to help retrieve <span class="strong"><strong>US Geological Survey</strong></span> (<span class="strong"><strong>USGS</strong></span>) and <span class="strong"><strong>US Environmental Protection Agency</strong></span> (<span class="strong"><strong>EPA</strong></span>).</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec31"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - collecting and exploring data"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec77"/>Step 2 - collecting and exploring data</h3></div></div></div><p>The first step is to load the following packages:</p><pre class="programlisting">
<span class="strong"><strong>&gt; library(dataRetrieval)
&gt; library(dplyr)</strong></span>
</pre><p>Retrieving the site number. The site number is usually an eight-digit number, which is represented as a string or vector:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; siteNumber &lt;- c("01538000") </strong></span>
</pre><p>Retrieving parameter codes:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; parameterCd &lt;- "00060"</strong></span>
</pre><p>Using site number and parameter codes importing data from NWIS web service. The result is then stored in the <code class="literal">Q_daily</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; Q_daily &lt;- readNWISdv(siteNumber, parameterCd)</strong></span>
</pre><p>Printing the <code class="literal">Q_daily</code> data frame. The <code class="literal">tail()</code> function returns the last part of the <code class="literal">Q_daily</code> data frame. The <code class="literal">Q_daily</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; tail(Q_daily)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_028.jpg" alt="Step 2 - collecting and exploring data"/></div><p>
</p><p>Exploring the internal structure of the <code class="literal">Q_daily</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">Q_daily</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; str(Q_daily)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_029.jpg" alt="Step 2 - collecting and exploring data"/></div><p>
</p><p>Renaming columns--the <code class="literal">renameNWISColumns()</code> function renames columns retrieved from NWIS. <code class="literal">Q_daily</code> is the daily or unit-values dataset retrieved from NWIS Web:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; Q_daily &lt;- renameNWISColumns(Q_daily)</strong></span>
</pre><p>Printing the renamed <code class="literal">Q_daily</code> data frame. The <code class="literal">tail()</code> function returns the last part of the <code class="literal">Q_daily</code> data frame. The <code class="literal">Q_daily</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; tail(Q_daily)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_030.jpg" alt="Step 2 - collecting and exploring data"/></div><p>
</p><p>Importing data from the USGS file site. The <code class="literal">readNWISsite()</code> function uses <code class="literal">siteNumber</code> 8 digit number which represents the USGS site number. The result is then stored in the <code class="literal">stationInfo</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; stationInfo &lt;- readNWISsite(siteNumber)</strong></span>
</pre></div><div class="section" title="Step 3 - calculating the moving average"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec78"/>Step 3 - calculating the moving average</h3></div></div></div><p>Checking for missing days:</p><pre class="programlisting">
<span class="strong"><strong>&gt; if(as.numeric(diff(range(Q_daily$Date))) != (nrow(Q_daily)+1)){
+ fullDates &lt;- seq(from=min(Q_daily$Date),
+ to = max(Q_daily$Date), by="1 day")
+ fullDates &lt;- data.frame(Date = fullDates,
+ agency_cd = Q_daily$agency_cd[1],
+ site_no = Q_daily$site_no[1],
+ stringsAsFactors = FALSE)
+ Q_daily &lt;- full_join(Q_daily, fullDates,
+ by=c("Date","agency_cd","site_no")) %&gt;%
+ arrange(Date)
+ }</strong></span>
</pre><p>Calculating the moving average for 30 days. The <code class="literal">filter()</code> function applies linear filtering to a time series. <code class="literal">sides=1</code>, the filter coefficients are applied for past values only:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; moving_avg &lt;- function(x,n=30){stats::filter(x,rep(1/n,n), sides=1)}     &gt;
</strong></span>
<span class="strong"><strong>Q_daily &lt;- Q_daily %&gt;% mutate(rollMean = as.numeric(moving_avg(Flow)), day.of.year = as.numeric(strftime(Date, format = "%j")))</strong></span>
</pre><p>Printing the <code class="literal">Q_daily</code> data frame. The <code class="literal">tail()</code> function returns the last part of the <code class="literal">Q_daily</code> data frame. The <code class="literal">Q_daily</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; tail(Q_daily)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_031.jpg" alt="Step 3 - calculating the moving average"/></div><p>
</p></div><div class="section" title="Step 4 - calculating percentiles"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec79"/>Step 4 - calculating percentiles</h3></div></div></div><p>Calculating historical percentiles. The various quantiles are calculated using respective probabilities. Then, the data frame is collapsed into a single row, using the <code class="literal">summarize()</code> function. Finally, using the function <code class="literal">group_by()</code>, the results, which are in table form, are converted and grouped into a table:</p><pre class="programlisting">
<span class="strong"><strong>&gt; Q_summary &gt;- Q_daily %&gt;%
+ group_by(day.of.year) %&gt;%
+ summarize(p75 = quantile(rollMean, probs = .75, na.rm = TRUE),
+ p25 = quantile(rollMean, probs = .25, na.rm = TRUE),
+ p10 = quantile(rollMean, probs = 0.1, na.rm = TRUE),
+ p05 = quantile(rollMean, probs = 0.05, na.rm = TRUE),
+ p00 = quantile(rollMean, probs = 0, na.rm = TRUE))</strong></span>
</pre><p>Obtaining the current year from the system:</p><pre class="programlisting">
<span class="strong"><strong>&gt; current_year &lt;- as.numeric(strftime(Sys.Date(), format = "%Y"))
&gt; summary.0 &lt;- Q_summary %&gt;% mutate(Date = as.Date(day.of.year - 1,
origin = paste0(current_year-2,"-01-01")), day.of.year = day.of.year - 365)
&gt; summary.1 &lt;- Q_summary %&gt;% mutate(Date = as.Date(day.of.year - 1,
origin = paste0(current_year-1,"-01-01")))
&gt; summary.2 &lt;- Q_summary %&gt;% mutate(Date = as.Date(day.of.year - 1,
origin = paste0(current_year,"-01-01")), day.of.year = day.of.year + 365)</strong></span>
</pre><p>Combining each of the data frames:</p><pre class="programlisting">    &gt; <span class="strong"><strong>Q_summary &lt;- bind_rows(summary.0, summary.1, summary.2) </strong></span>
</pre><p>Printing the <code class="literal">Q_summary</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; Q_summary</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_032.jpg" alt="Step 4 - calculating percentiles"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; smooth.span &lt;- 0.3</strong></span>
</pre><p>Predicting values based on a linear model and fitting a polynomial surface. The <code class="literal">loess()</code> function fits the polynomial surface. <code class="literal">p75~day.of.year</code> represents the formula, while <code class="literal">span = smooth.span</code> for example <code class="literal">smooth.span= 0.3</code>, controls the degree of smoothing:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; Q_summary$sm.75 &lt;- predict(loess(p75~day.of.year, data = Q_summary, span = smooth.span))</strong></span>
</pre><p>Printing the <code class="literal">Q_summary$sm.75</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(Q_summary$sm.75)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_033.jpg" alt="Step 4 - calculating percentiles"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; Q_summary$sm.25 &lt;- predict(loess(p25~day.of.year, data = Q_summary, span = smooth.span))</strong></span>
</pre><p>Printing the <code class="literal">Q_summary$sm.25</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(summaryQ$sm.25)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_034.jpg" alt="Step 4 - calculating percentiles"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; Q_summary$sm.10 &lt;- predict(loess(p10~day.of.year, data = Q_summary, span = smooth.span))</strong></span>
</pre><p>Printing the <code class="literal">Q_summary$sm.10</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(summaryQ$sm.10)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_035.jpg" alt="Step 4 - calculating percentiles"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; Q_summary$sm.05 &lt;- predict(loess(p05~day.of.year, data = Q_summary, span = smooth.span))</strong></span>
</pre><p>Printing the <code class="literal">Q_summary$sm.05</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(summaryQ$sm.05)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_036.jpg" alt="Step 4 - calculating percentiles"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; Q_summary$sm.00 &lt;- predict(loess(p00~day.of.year, data = Q_summary, span = smooth.span))</strong></span>
</pre><p>Printing the <code class="literal">Q_summary$sm.05</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(summaryQ$sm.00)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_037.jpg" alt="Step 4 - calculating percentiles"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; Q_summary &lt;- select(Q_summary, Date, day.of.year, sm.75, sm.25, sm.10, sm.05, sm.00) %&gt;% filter(Date &gt;= as.Date(paste0(current_year-1,"-01-01")))</strong></span>
</pre><p>Printing the <code class="literal">Q_summary</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; Q_summary</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_038.jpg" alt="Step 4 - calculating percentiles"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; latest.years &lt;- Q_daily %&gt;% filter(Date &gt;= as.Date(paste0(current_year-1,"-01-01"))) %&gt;% mutate(day.of.year = 1:nrow(.))</strong></span>
</pre></div><div class="section" title="Step 5 - plotting results"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec80"/>Step 5 - plotting results</h3></div></div></div><p>Plotting the data:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; title.text &lt;- paste0(stationInfo$station_nm,"n", "Provisional Data - Subject to changen", "Record Start = ", min(Q_daily$Date), "  Number of years = ", as.integer (as.numeric(difftime(time1 = max(Q_daily$Date), time2 = min(Q_daily$Date), units = "weeks"))/52.25), "nDate of plot = ",Sys.Date(), "  Drainage Area = ",stationInfo$drain_area_va, "mi^2")     &gt; mid.month.days &lt;- c(15, 45, 74, 105, 135, 166, 196, 227, 258, 288, 319, 349)     &gt; month.letters &lt;- c("J","F","M","A","M","J","J","A","S","O","N","D")     &gt; start.month.days &lt;- c(1, 32, 61, 92, 121, 152, 182, 214, 245, 274, 305, 335)     &gt; label.text &lt;- c("Normal","DroughtWatch","DroughtWarning","Drought Emergency")     &gt; year1_summary &lt;- data.frame(Q_summary[2:366,])     &gt; head(year1_summary) </strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_039.jpg" alt="Step 5 - plotting results"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; year2_summary &lt;- data.frame(Q_summary[367:733,])     
&gt; head(year2_summary)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_040.jpg" alt="Step 5 - plotting results"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; simple.plot &lt;- ggplot(data = Q_summary, aes(x = day.of.year)) + </strong></span>
<span class="strong"><strong>    + geom_ribbon(aes(ymin = sm.25, ymax = sm.75, fill = "Normal")) + </strong></span>
<span class="strong"><strong>    + geom_ribbon(aes(ymin = sm.10, ymax = sm.25, fill =       "Drought Watch")) +</strong></span>
<span class="strong"><strong>    + geom_ribbon(aes(ymin = sm.05, ymax = sm.10, fill = "Drought Warning")) +</strong></span>
<span class="strong"><strong>    + geom_ribbon(aes(ymin = sm.00, ymax = sm.05, fill = "Drought Emergency")) + </strong></span>
<span class="strong"><strong>    + scale_y_log10(limits = c(1,1000)) + </strong></span>
<span class="strong"><strong>    + geom_line(data = latest.years, aes(x=day.of.year, y=rollMean, color = "30-Day Mean"),size=2) + </strong></span>
<span class="strong"><strong>    + geom_vline(xintercept = 365) </strong></span>
<span class="strong"><strong>    &gt; simple.plot</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_041.jpg" alt="Step 5 - plotting results"/></div><p>
</p></div></div></div></body></html>