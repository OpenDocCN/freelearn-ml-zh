- en: Getting Started with OpenCV
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we were presented with an introduction to computer
    vision, with some examples of the industries that use it extensively to improve
    their services and products. Then, we learned about the most basic concepts used
    in this field, such as images and pixels. We learned about color spaces and finished
    the chapter with a brief discussion of computer vision libraries and frameworks.
    We're going to continue from where we left off, which is with introducing you
    to one of the most powerful and widely used computer vision libraries, called
    **OpenCV**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV is a huge collection of classes, functions, modules, and other related
    resources used to build cross-platform computer vision applications. In this chapter,
    we will learn about the structure of OpenCV, the modules that it contains and
    their purposes, and the programming languages that it supports. We will learn
    how and where to get OpenCV and briefly go through the possible tools you can
    use to build applications with it. Then, we'll learn how to use the power of CMake
    to easily create projects that use OpenCV. Even though this means that our main
    focus will be on C++ classes and functions, we'll also cover Python equivalents
    of them wherever it makes sense so that developers familiar with both languages
    can follow the topics that are presented here in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: After learning about the initial stages of using the OpenCV library, we'll move
    on to learn about the `Mat` class. We'll see how all of the concepts that we covered
    in the previous chapter about images are embedded into the structure of the `Mat`
    class in OpenCV. We'll also talk about the various other classes that are compatible
    with (or closely related to) the `Mat` class. OpenCV's method of handling input
    and output parameters in its functions is a very important subject that we'll
    be covering in the later sections of this chapter. Finally, we'll learn how OpenCV
    is used to apply the three steps of input, process, and output in computer vision
    applications. This will require learning about accessing (and writing into) images
    and video files using OpenCV.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: This chapter, as a direct connection to the previous introductory chapter, will
    lay out the foundations of learning computer vision algorithms using hands-on
    and practical examples.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: What OpenCV is, where to get it, and how to use it?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use CMake to create OpenCV projects?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the `Mat` class and how it is used to access pixels
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `Mat_`, `Matx`, and `UMat` classes?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `imread` and `imwrite` functions to read and write images?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `VideoCapture` and `VideoWriter` classes to read and write videos?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to access cameras and video feeds from a network (using **Real Time Streaming
    Protocol** (**RTSP**))?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft Visual Studio, Xcode, or any IDE that can be used to develop C++ programs
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code or any other code editor that can be used to edit CMake files,
    Python source files, and so on
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.X
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake 3.X
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenCV 3.X
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is always best to try to use a more recent version of the technologies and
    software that you are trying to learn. The topics covered in this book, and computer
    vision in general, are no exception, so make sure to download and install the
    latest versions of the mentioned software.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Wherever necessary, a brief set of instructions are provided for the installation
    and configuration. You can use the following URL to download the source codes
    and examples for this chapter:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter02)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to OpenCV
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OpenCV**, or **Open Source Computer Vision**, is a set of libraries, tools,
    and modules that contain classes and functions required for building computer
    vision applications. Downloaded millions of times by computer vision developers
    around the world, the OpenCV library is fast and optimized to be used in real-life
    projects (including commercial). As of the time of writing this book, the most
    recent version of OpenCV is 3.4.1, which is also the version we''ll be using in
    all of the examples in this book. OpenCV supports the C/C++, Python, and Java
    languages, and it can be used to build computer vision applications for desktop
    and mobile operating systems alike, including Windows, Linux, macOS, Android,
    and iOS.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that the OpenCV library and OpenCV framework are both
    used to refer to OpenCV, and in the computer vision community the terms are used
    interchangeably most of the time. For the same reason, we will also use the terms
    interchangeably throughout this book. However, strictly speaking, framework is
    usually the term that is used to refer to sets of related libraries and tools
    working toward achieving a common goal, such as OpenCV.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenCV consists of the following two types of modules:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '**Main modules**: These modules are included in OpenCV release versions by
    default, and they contain all of the core OpenCV functionality along with modules
    that are used for image-processing tasks, filtering, transformation, and many
    more capabilities that we''ll talk about in this section.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extra modules**: These modules include all of the OpenCV functionalities
    that are not included in the OpenCV library by default and they mostly include
    additional computer vision-related functionalities. For instance, the Extra modules
    include libraries used for text recognition and non-free feature detectors. Note
    that our focus will be on the Main module and covering the functionalities included
    in it but, wherever it might be helpful, we''ll try to also refer to possible
    options in the extra modules for you to research on your own.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Main modules in OpenCV
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned, OpenCV contains a number of Main modules that contain all of
    its core and default functionalities. Here is a list of those modules:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '`core`: This contains all of the core OpenCV functionalities. For instance,
    all basic structures, including the `Mat` class (which we''ll learn about in detail
    later) and matrix operations are some of the functionalities embedded into this
    module.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imgproc`: This module contains all image-processing functionalities, such
    as filtering, transformations, and histograms.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imgcodecs`: This module includes functions that are used for reading and writing
    images.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`videoio`: This is similar to the `imgcodecs` module, but this one is used
    to work with videos, as the name implies.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`highgui`: This module, which we''ll use extensively throughout the book, contains
    all of the functionalities used for displaying results and GUI creation in general.
    Note that even though the `highgui` module is enough for the purpose of this book
    and learning about computer vision algorithms while visualizing the results as
    we move forward, it''s still not meant for full-scale applications. Refer to the
    *Further reading* section at the end of this chapter for more references about
    proper GUI creation tools for full-scale computer vision applications.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`video`: Contains video analysis functionalities of OpenCV, such as motion
    detection and tracking, the Kalman filter, and the infamous CAM Shift algorithm
    (used for object tracking).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calib3d`: This module includes calibration and 3D reconstruction functionalities.
    A well-known example of the capabilities of this module is the estimation of transformation
    between two images.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`features2d`: Supported keypoint-detection and descriptor-extraction algorithms
    are included in this module. As we''ll learn in the upcoming chapters, this module
    contains some of the most widely used object detection and categorization algorithms.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`objdetect`: As the name implies, this module is used for object detection
    using OpenCV. We''ll learn about the functionalities contained within this module
    in the final chapters of this book.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dnn`: Similar to the `objdetect` module, this module is also used for object
    detection and classification purposes, among others. The `dnn` module is relatively
    new in the list of the Main modules of OpenCV, and it contains all of the capabilities
    related to deep learning.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ml`: This machine learning module contains the classes and functions used
    to handle classification and regression. Simply put, all strictly machine learning-related
    capabilities are included in this module.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flann`: This is OpenCV''s interface to **Fast Library for Approximate Nearest
    Neighbors** (**FLANN**). FLANN contains a wide set of optimized algorithms that
    are used to deal with the nearest neighbor search of high-dimensional features
    in large datasets. The algorithms mentioned here are mostly used in conjunction
    with algorithms in other modules, such as `features2d`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`photo`: An interesting module for photography-related computer vision, it
    contains classes and functions that are used to deal with tasks such as denoising,
    HDR imaging, and restoring a region in a photo using its neighborhood.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stitching`: This module contains classes and functions used for image stitching.
    Note that stitching in itself is a very complex task and it requires functions
    for rotation estimation and image warping, all of which are also part of this
    very interesting OpenCV module.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shape`: This module is used to deal with shape transformation, matching, and
    distance-related topics.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`superres`: Algorithms that fall into the category of resolution enhancement
    are included in the super-resolution module.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`videostab`: This module contains algorithms used for video stabilization.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viz`: Otherwise known as the 3D Visualizer module, it contains classes and
    functions that are used to deal with displaying widgets on the 3D visualization
    window. This module will not be part of the topics discussed in this book, but
    we''ll just mention it.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from the modules that we just covered, OpenCV also contains a number of
    Main modules that are based on CUDA (an API created by Nvidia). These modules
    are easily distinguished by their names, which start with the word `cuda`. Since
    the availability of these modules totally depends on a specific type of hardware,
    and almost all of the functionalities inside those modules are covered, one way
    or another, by other modules, we're going to skip them for now. But it's worth
    noting that using the OpenCV `cuda` modules can significantly improve the performance
    of your applications, provided that the algorithms you need are implemented in
    them, and that your hardware meets the minimum requirements for them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and building/installing OpenCV
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenCV, for the most part, does not have a prebuilt and ready-to-use version
    (there are some exceptions we''ll cover in this section) and similar to most of
    the open source libraries, it needs to be configured and built from sources. In
    this section, we''ll quickly describe how OpenCV is built (and installed) on a
    computer. But first, you need to get the OpenCV source codes in your computer.
    You can use the following link for this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[https://opencv.org/releases.html](https://opencv.org/releases.html)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: On this page, you can find release versions of OpenCV. The latest version, as
    of the time of writing this book, is 3.4.1 so you should download it, or if there
    is a higher version then just go with that.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the following screenshot, for each version of the OpenCV release,
    there are various downloadable entries, such as the Win, iOS, and Android packs,
    but you should download Sources and build OpenCV yourself based on the platform
    you want to work with:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: OpenCV 3.4.1, by default, provides prebuilt versions of the Android, iOS, and
    64-bit MSVC14 and MSVC15 (the same as Microsoft Visual C++ 2015 and Microsoft
    Visual C++ 2017) libraries. So, if you want to build applications for any of these
    platforms, you can download the relevant pack and skip the OpenCV build process
    altogether.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'To build OpenCV from sources, you need the following tools on your computer:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '**C/C++ compiler with C++11 support**: On Windows, this means any of the more
    recent Microsoft Visual C++ compilers, such as MSVC15 (2017) or MSVC14 (2015).
    On Linux operating systems, you can use an up-to-date GCC and, on macOS, you can
    use the command-line tools for Xcode that contain all the required tools.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMake**: Make sure you use the latest version of CMake, such as 3.10, to
    be on the safe side with more recent versions of OpenCV, although you can use
    CMake 3.1 and later.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python**: This is especially important if you are aiming to use the Python
    programming language.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenCV contains a large number of tools and libraries and it's possible to customize
    your build in many different ways. For instance, you can use the Qt Framework,
    Intel **Threading Building Blocks** (**TBB**), **Intel Integrated Performance
    Primitives** (**IPP**), and other third-party libraries to further enhance and
    customize your OpenCV build, but since we'll be using OpenCV with the default
    settings and set of tools, we're ignoring the aforementioned third-party tools
    in the list of requirements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: After getting all of the prerequisites we just mentioned, you can configure
    and build OpenCV by using CMake and the corresponding compilers, depending on
    your operating system and desired platforms.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot depicts the CMake tool with a default set of configurations
    visible. Usually, you don''t need to make any change to the configurations unless
    you want to apply your own set of customizations to the OpenCV build:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: Note that when CMake is first opened, you need to set the source and build folders,
    which are visible in the preceding screenshot, as Where is the source code: and
    Where to build the binaries:, respectively. After hitting the Configure button,
    you need to set a generator and apply the settings, then press Generate.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'After generation, you can simply switch to the CMake output folder using a
    Terminal or Command Prompt instance and execute the following commands:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Be aware that running each one of these commands can take some time depending
    on your computer's speed and configurations. Also note that the `make` commands
    can be different depending on the set of tools you are aiming to use. For instance,
    if you are using Microsoft Visual Studio, then you need to replace `make` with
    `nmake`, or if you are using MinGW then you have to replace `make` with `mingw32-make`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: After the build process is completed, you can start using OpenCV. The only thing
    you need to take care of is configuring your C++ projects so that they can use
    your set of OpenCV libraries and installation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: On Windows operating systems, you need to make sure OpenCV DLL files are accessible
    by the applications you are building. This can be done either by copying all of
    the required DLLs to the same folder where your applications are being built or
    simply by adding the path of the OpenCV DLL files to the PATH environment variable.
    Make sure to take care of this before proceeding further, otherwise your applications
    will crash when they are executed, even though they might build successfully and
    not report any issues at compile time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are going to use Python to build computer vision applications, then
    things are going to be extremely simple for you since you can use `pip` (package
    manager) to install OpenCV for Python, using the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will automatically get you the latest OpenCV version and all of its dependencies
    (such as `numpy`) or, if you have already installed OpenCV, you can use the following
    command to make sure it''s upgraded to the latest version:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It goes without saying that you need a working internet connection for these
    commands to work.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Using OpenCV with C++ or Python
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll demonstrate how you can use OpenCV in your C++ or Python
    projects with a very simple example that we''ll call `HelloOpenCV`. You might
    already know that the purpose of such a project is either one of the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: To get started with a new library, such as OpenCV, that you've never used before
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make sure your OpenCV installation is functional and works fine
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, even if you are not an OpenCV beginner, it's still worth going through the
    following instructions and running the simple example in this section to test
    your OpenCV build or installation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the required steps for using OpenCV in a C++ project:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder named `HelloOpenCV`
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two new text files inside this folder and name them `CMakeLists.txt`
    and `main.cpp`
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure the `CMakeLists.txt` file contains the following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, you need to replace `"path_to_opencv"` with the path
    to the folder containing the `OpenCVConfig.cmake` and `OpenCVConfig-version.cmake`
    files, which is the same folder where you have installed your OpenCV libraries.
    If you are using the Linux operating system and the prebuilt OpenCV libraries,
    you might not need an exact path to the `OpenCV` folder.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the `main.cpp` file, make sure it contains the following, which is the
    actual C++ code we''ll be running:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We'll be covering the functions used in the preceding code individually later
    on, in this and the upcoming chapters, however, for now it's worth noting that
    this program is trying to open and display an image saved on disk. If it succeeds,
    the image will be displayed until any key is pressed, otherwise the `Empty image!` message
    will be displayed. Note that this program, under normal circumstances, should
    not crash at all and it should build successfully. So, if the opposite happens
    to you, then you'll need to go through the topics discussed previously in this
    chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Our C++ project is ready. Now, we can use CMake to generate Visual Studio or
    any other type of project that we want (depending on the platform, compiler, and
    IDE we're going to use) and then build and run it. Note that CMake is simply used
    to make sure a cross-platform and IDE-independent C++ project is created.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By running this example project, your input image (in this case `MyImage.png`)
    will be read and displayed until any key on the keyboard is pressed. If any problems
    occur during the reading of the image, then the `Empty image!` message will be
    displayed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create and run the same project in Python by using the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The resemblance is quite unmistakable here. The exact same `imshow` and `waitKey`
    functions are also used in the Python version of the same code. As was mentioned
    before, for now don't bother with the exact way of using any of the functions
    and just focus on making sure that you are able to run these programs, either
    in C++ or Python, or both, and that you are able to see the image displayed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: If you were able to successfully run the `HelloOpenCV` example project in this
    section, then you are ready to take on the next sections of this chapter and the
    next chapters of this book without any problems. If you still face problems with
    the topics discussed so far, or you feel that you need a stronger understanding
    of those topics, you can go through them once again from the start of the chapter,
    or even better, you can refer to the additional books mentioned in the *Further
    reading* section at the end of this chapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Mat class
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer back to the description that was provided for an image in computer vision
    from the previous chapter, and that any image is in fact a matrix with a given
    width, height, number of channels, and depth. With this description in mind, we
    can say that the OpenCV `Mat` class can be used to handle image data and it supports
    all properties required by an image, such as width and height. In fact, the `Mat`
    class is an n-dimensional array that can be used to store single or multiple channels
    of data with any given data type, and it contains a number of members and methods
    to create, modify, or manipulate it in many ways.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we're going to learn about some of the most important members
    and methods of the `Mat` class with example use cases and code samples.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent of the OpenCV C++ `Mat` class in Python is not originally an
    OpenCV class, and it is represented by the `numpy.ndarray` type. NumPy is a Python
    library that contains a wide set of numerical algorithms and mathematical operations,
    and it supports working with large multi-dimensional arrays and matrices. The
    reason why the `numpy.ndarray` type in Python is used as `Mat` is that it offers
    the best (if not the same) set of members and methods required by the OpenCV `Mat`
    class in C++. For a complete list of members and methods supported by `numpy.ndarray`,
    you can refer to NumPy documentation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a Mat object
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Mat` contains about 20 different constructors that can be used to create instances
    of it, based on what kind of initialization is needed. Let''s see some of the
    most commonly used constructors with some examples.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a `Mat` object (or class instance) that has a width of `1920` and
    height of `1080`, with three channels that contain 32-bit floating-point values
    looks as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that the `type` parameter in the `Mat` constructors accepts a special
    type of parameter, that is, a constant value that contains the depth, type, and
    number of channels. The pattern is seen here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`<depth>` can be replaced by 8, 16, 32, or 64, which represent the number of
    bits used to store each element in the pixels. The actual number of bits needed
    for each pixel can be calculated by multiplying this number with the number of
    channels, or in other words, `<channels>`. Finally, `<type>` needs to be replaced
    with `U`, `S`, or `F` for the unsigned integer, signed integer, and floating-point
    values, respectively. For example, you can use the following to create standard
    grayscale and colored images with a width of `800` and height of `600` pixels.
    Notice that only the number of channels is different, and that the depth and type
    parameters represent 8-bit unsigned integers:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can use the following constructor to create a three-channel RGB image with
    a width of `W`, height of `H`, and 8-bit unsigned integer elements, and then initialize
    all elements with the `R`, `G`, and `B` color value:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It's important to note that the default order of colors in OpenCV is BGR (instead
    of RGB), which means a swapped `B` and `R` value. This is especially important
    if we're aiming to display our processed images at some point during the application
    run time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the correct way of the scalar initializer in the preceding code would be as
    follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we need a `Mat` object with higher dimensions, we can use the following.
    Note that in the following example, a `Mat` object of seven dimensions is created.
    The size of each dimension is provided in the `sizes` array and each element in
    the high dimensional `Mat`, which is called `hdm`, contains two channels of 32-bit
    floating-point values:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another way of achieving the same thing would be using C++ vectors, as seen
    in the following example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similarly, you can provide an additional `Scalar` parameter to initialize all
    of the values in `Mat`. Note that the number of values in `Scalar` must match
    the number of channels. For instance, to initialize all of the elements in the
    previous seven-dimensional `Mat`, we can use the following constructor:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Mat` class allows us to use already-stored image data to initialize it.
    Using this constructor, you can make your `Mat` class contain the same data that
    the `data` pointer is pointing to. Note that this constructor does not create
    a completely new copy of the original data, and it only makes this newly created
    `Mat` object point to it. This allows very efficient initialization and construction
    of the `Mat` classes, but has the obvious downside of not taking care of the memory
    cleanup when it is not needed, so you need to be extra careful when using this
    constructor:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that, unlike the previous constructors and their initializers, `data` here
    is not a `Scalar` but a pointer to a chunk of memory that contains a `1920` by
    `1080` pixel, three-channel image data. This method of initializing a `Mat` object
    with a pointer to a memory space can also be used with higher dimensionalities
    of the `Mat` class.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'One last constructor type, which is also one of the most important constructors
    of the `Mat` class, is the **region of interest** (**ROI**) constructor. This
    constructor is used to initialize a `Mat` object with a region inside another
    `Mat` object. Let''s break this down with an example. Imagine you have an image
    and you want to apply some modifications to a specific region inside that image,
    or in other words to the ROI. You can use the following constructor to create
    a `Mat` class that has access to the ROI, and any changes applied to it will affect
    the same region of the original image. Here''s how you can do that:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the preceding constructor is used while `image` (which itself is a `Mat`
    object) contains the picture on the left side of the following image, then `roi`
    will have access to the region highlighted in that image, and it will contain
    the image seen on the right side:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: 'The `Rect` class in OpenCV is used to represent a rectangle that has a top-left
    point, width, and height. For instance, the `Rect` class that was used in the
    preceding code example has a top-left point of `240` and `140`, width of `300`,
    and height of `300` pixels, as seen here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As was mentioned earlier, modifying the ROI in any way will result in the original
    image being modified. For instance, we can apply something similar to the following
    image-processing algorithm to `roi` (for now don''t bother with the nature of
    the following algorithm, as we''ll learn more about it in the upcoming chapters,
    and just focus on the concept of ROIs):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we attempt to display the image, the result would be similar to the following.
    Notice the area that was highlighted in the previous image is modified (dilated)
    in the following image, even though we applied the change to `roi`, and not the
    image itself:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: 'Similar to constructing an ROI `Mat` object using a `Rect` class that corresponds
    to a rectangular region of an image, you can also create an ROI that corresponds
    to a range of columns and rows in the original `Mat` object. For instance, the
    same region in the preceding example can also be accessed with the ranges seen
    in the following constructor:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Range` class in OpenCV represents a range that has `start` and `end`. Depending
    on the values of `start` and `end`, `Range` class can be checked to see whether
    it's empty or not. In the preceding constructor, the first `Range` class corresponds
    to the rows of the original image, from row `140` to row `440`. The second `Range`
    corresponds to the columns of the original image, from column `240` to column
    `540`. The shared space of the provided two ranges is considered to be the resulting
    ROI.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a Mat object
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Mat` object can be cleaned up by using its `release` function, however, since
    `release` is called in the destructor of the `Mat` class, there is usually no
    need to call this function at all. It's important to note that the `Mat` class
    shares the same data between multiple objects that point to it. This has the advantage
    of less data copying and less memory usage, and since all of the reference counting
    is done automatically, you don't usually need to take care of anything.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The only scenario in which you need to take extra care of how and when your
    objects and data are cleaned up is when you use a data pointer to construct a
    `Mat` object, as mentioned in the previous section. In such cases, calling the
    `release` function of the `Mat` class, or its destructor, will have nothing to
    do with the external data you have used to construct it, and the cleanup will
    be completely on your shoulders.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Accessing pixels
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from using an ROI to access the pixels in a rectangular region of an
    image, as we did in the previous sections, there are a few other methods for achieving
    the same goal or even for accessing individual pixels of an image. To be able
    to access any single pixel in an image (in other words, a `Mat` object), you can
    use the `at` function, as seen in the following example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, in the usage of the `at` function, `TYPE` must be
    replaced with a valid type name that is in accordance with the number of channels
    and depth of the image. `R` must be replaced with the row number, and `C` with
    the column number of the pixels we want to have access to. Notice that this is
    slightly different from the usual pixel-access methods in many libraries, in which
    the first parameter is *X* (or left) and the second parameter is *Y* (or top).
    So basically, the parameters appear reversed here. Here are some examples of accessing
    individual pixels in different types of `Mat` objects.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing a pixel in a single-channel `Mat` object with 8-bit integer elements
    (grayscale images) is done as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Accessing a pixel in a single-channel `Mat` object with floating-point elements is
    done as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Access a pixel in a three-channel `Mat` object with 8-bit integer elements as
    follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, the `Vec3b` (vector of 3 bytes) type is used. This and
    various other similar vector types are defined in OpenCV for convenience. Here
    is the pattern of the OpenCV `Vec` types that you can use with the `at` function,
    or for any other purposes:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`<N>` can be replaced with 2, 3, 4, 6, or 8 (or omitted in the case of 1) and
    it corresponds to the number of channels in a `Mat` object. `<Type>`, on the other
    hand, can be one of the following, which represent the type of the data stored
    in each channel of each pixel:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '`b` for `uchar` (unsigned char)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s` for `short` (signed word)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w` for `ushort` (unsigned word)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i` for `int`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` for `float`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d` for `double`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, `Vec4b` can be used to access the pixels of a four-channel `Mat`
    object with the `uchar` elements, and `Vec6f` can be used to access the pixels
    of a six-channel `Mat` object with the `float` elements. It''s important to note
    that the `Vec` type can be treated like an array to access individual channels
    too. Here''s an example of how to access the second channel of a three-channel
    `Mat` object with the `uchar` elements:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It''s important to note that by access we mean both reading and writing to
    a pixel and its individual channels. For instance, the following example is one
    way to apply a sepia filter to an image:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, a few things to note here are the `rows` and `cols` members of the image,
    which basically represent the number of rows (or height) and the number of columns
    (or width) in it. Also notice how the `at` function is used both to extract the
    values of channels and to write updated values into them. Don't worry about the
    values used in this example to multiply and get the correct sepia tone, as they
    are specific to the tone itself, and essentially any type of operation can be
    applied to the individual pixels to change them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image depicts the result of applying the preceding example code
    on a three-channel color image (left—original image, right—filtered image):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: 'Another method of accessing the pixels in an image is by using the `forEach`
    function of the `Mat` class. `forEach` can be used to apply an operation on all
    pixels in parallel, instead of looping through them one by one. Here''s a simple
    example that shows how `forEach` is used to divide the value of all pixels by
    `5`, which would result in a darker image if it is executed on a grayscale image:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, the second parameter, or the position parameter (which
    is not needed and therefore omitted here) is the pointer to the position of the
    pixel.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the previous `for` loop, we would need to write the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'OpenCV also allows the use of STL-like iterators to access or modify individual
    pixels in an image. Here''s the same example but written using STL-like iterators:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It''s interesting to note that the same operation in all of the preceding three
    examples can also be done by using the following simple statement:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is because the `Mat` object in OpenCV treats this statement as an element-wise
    divide operation, which we''ll learn more about it in the upcoming chapters. The
    following image depicts the result of applying the preceding examples to a grayscale
    image (left—original image, right—modified image):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.gif)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Obviously, `forEach`, the C++ `for` loop, and STL-like iterators can all be
    used to access and modify the pixels within a `Mat` object. We'll suffice to the
    functions and members discussed in this section about the `Mat` class, but make
    sure to explore the huge set of functionalities it provides to work with images
    and their underlying properties in an efficient way.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing images
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenCV allows reading an image from a disk into a `Mat` object using the `imread`
    function, which we briefly used in this chapter in a previous example. The `imread`
    function accepts an input image file name and a `flag` parameter, and returns
    a `Mat` object filled with the input image. The input image file must have one
    of the image formats supported by OpenCV. Here are some of the most popular supported
    formats:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows bitmaps**: `*.bmp`, `*.dib`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JPEG files**: `*.jpeg`, `*.jpg`, `*.jpe`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portable Network Graphics**: `*.png`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portable Image Format**: `*.pbm`, `*.pgm`, `*.ppm`, `*.pxm`, `*.pnm`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TIFF files**: `*.tiff`, `*.tif`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure to always check the OpenCV documentation for a complete and updated
    list, and especially for exception cases and notes that might apply to some formats
    on some operating systems. As for the
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '`flag` parameter, it can be one or a combination of the values from the `ImreadModes`
    enum, which is defined in OpenCV. Here are a few of the most widely used and self-explanatory
    entries:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '`IMREAD_UNCHANGED`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IMREAD_GRAYSCALE`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IMREAD_COLOR`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IMREAD_IGNORE_ORIENTATION`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following code can be used to read an image from a disk, without
    taking the orientation value stored in the EXIF data of the image and also converted
    to grayscale:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Exchangeable Image File Format** (**EXIF**) is a standard for adding tags
    and additional data (or metadata) to images taken by digital cameras. These tags
    might include the manufacturer and camera model and the orientation of the camera
    while the photo was taken. OpenCV is capable of reading certain tags (such as
    orientation) and interpreting them, or in the case of the preceding sample code,
    ignoring them.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: After the image is read, you can call `empty` to see whether it was read successfully
    or not. You can also use `channels` to get the number of channels, `depth` to
    get the depth, `type` to get the type of the image, and so on. Alternatively,
    you can call the `imshow` function to display it, as we saw previously in this
    chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `imreadmulti` function can be used to read a multipage image
    into a vector of `Mat` objects. The obvious difference here is that `imreadmulti`
    returns a `bool` value that can be checked for successful reading of the pages
    and fills the `vector<Mat>` object passed to it by reference.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to write an image to a file on disk, you can use the `imwrite` function.
    `imwrite` takes the file name that will be written to, a `Mat` object, and a `vector`
    of `int` values containing the write parameters, which can be ignored in the case
    of default parameters. See the following enums in OpenCV for a complete list of
    parameters that can be used with the `imwrite` function to alter the behavior
    of the write process:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '`ImwriteFlags`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImwriteEXRTypeFlags`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImwritePNGFlags`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImwritePAMFlags`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example code that depicts how to write a `Mat` object into
    an image file on disk using the `imwrite` function. Note that the format of the
    image is derived from the extension provided, in this case `png`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Besides the `imread` and `imwrite` functions, which are used to read and write
    images from and into image files on disk, you can also use the `imdecode` and
    `imencode` functions to read images stored in a buffer in memory or write into
    them. We'll leave those two functions for you to discover, and move on to the
    next topic, which is accessing videos using OpenCV.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing videos
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenCV, using its `videoio` module or, to be precise, using the `VideoCapture`
    and `VideoWriter` classes, allows us to read and write video files. The obvious
    difference in the case of videos, is that they contain a consecutive set of images
    (or better yet, frames) as opposed to just a single image. So, they are usually
    read and processed or written in a loop that covers the whole or any desired number
    of the frames in a video. Let''s start with example code that shows how to read
    and play a video using the OpenCV `VideoCapture` class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As seen in the preceding code, the video file name is passed to the `VideoCapture`
    class when it is constructed. This automatically leads to the opening of the video
    file, if it exists and if the format is supported by your computer (and OpenCV).
    Consequently, you can check whether the video file was successfully opened or
    not using the `isOpened` function. Right after that, the `get` function of the `VideoCapture`
    class is used to retrieve the **framerate per second** (**FPS**) of the video
    file that has been opened. `get` is an extremely important function of `VideoCapture`
    and it allows us to retrieve a wide range of properties of an opened video file.
    Here are some example parameters that can be provided to the `get` function to
    get the desired result:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '`CAP_PROP_POS_FRAMES`: *0*-based index of the frame to be decoded or captured
    next'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_PROP_FRAME_WIDTH`: Width of the frames in the video stream'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_PROP_FRAME_HEIGHT`: Height of the frames in the video stream'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_PROP_FPS`: Frame rate of the video'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_PROP_FRAME_COUNT`: Number of frames in the video file'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a complete list, you can refer to the `VideoCaptureProperties` enum documentation
    in OpenCV. Back to the preceding example code, after the frame rate is retrieved
    using the `get` function, it is used to calculate the delay needed in between
    two frames, so that it is not too fast or slow when played back. Then, inside
    an infinite loop, the frames are read using the `>>` operator and displayed. Note
    that this operator is essentially the simplified and convenient way of using the `VideoCapture`
    functions, such as `read`, `grab`, and `retrieve`. We are already familiar with
    the `imshow` function and how it's used. `waitKey`, on the other hand, which is
    used slightly differently from what we saw before, can be used to insert delays
    and wait for key presses at the same time. In this case, the desired delay (in
    milliseconds), which was previously calculated, is inserted between displayed
    frames and if the space key is pressed, the loop will break. The `release` function
    in the end is pretty much self-explanatory.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the way we used the `VideoCapture` class and its methods, we can
    also call its `open` function to open the video file, if we do not want to pass
    the file name to the constructor, or if the video file is not present at the `VideoCapture`
    construction time. Another important function of `VideoCapture` is the `set` function.
    Think of `set` as the exact opposite of the `get` function, in the sense that
    it allows setting the parameters of `VideoCapture` and the opened video file.
    Try experimenting with it for yourself with different parameters, mentioned before
    in the `VideoCaptureProperties` enum.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to write into a video file, you can use the `VideoWriter` class
    in a very similar way. Here''s an example that shows how a `VideoWriter` object
    is created:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will create a video file at `"C:/output.avi"` with a width of `1920` and
    height of `1080` pixels at `30` frames per second, ready to be filled with frames.
    But what is `fourcc`? **Four Character Code** (**FourCC**) is simply a four-byte
    code of the format (or the codec, to be precise) that will be used to record the
    video file. In this example, we have used one of the most common FourCC values,
    but you can check online for a more comprehensive list of FourCC values and their
    specifications.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'After a `VideoWriter` object is created, you can use the `<<` operator or the `write`
    function to write an image (of the exact same size as the video) into the video
    file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Or you can also use the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Finally, you can call the `release` function to make sure the video file is
    released, and all of your changes are written into it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the aforementioned methods of using the `VideoCapture` and `VideoWriter`
    classes, you can also set the preferred backend used by them. For more information
    about this, refer to the `VideoCaptureAPIs` enum in the OpenCV documentation.
    When omitted, which was the case in our examples, the default backend supported
    by your computer is used.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Accessing cameras
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenCV supports accessing cameras that are available on a system by using the
    same `VideoCapture` class we used for accessing the video files. The only difference
    is that instead of passing a file name to the constructor of the `VideoCapture`
    class or its open function, you must provide a *0*-based index number that corresponds
    to each available camera. For instance, the default webcam on a computer can be
    accessed and displayed by using the following example code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, the only difference is in the constructor. This implementation
    of the `VideoCapture` class allows users to treat any type of video source the
    same way, thus writing almost the exact same code to deal with cameras instead
    of video files. This is also the case with network feeds, as described in the
    next section.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Accessing RTSP and network feeds
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenCV allows users to read video frames from a network feed or, to be precise,
    from an RTSP stream located on a network, such as the local network or even the
    internet. To be able to do this, you need to pass the URL of the RTSP stream to
    the `VideoCapture` constructor or its open function, exactly the same way as if
    it were a file on a local hard disk. Here''s the most common pattern and an example
    URL that can be used:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this URL, `user` is replaced by the actual username, `password` with the
    password of that user, and so on. In the event that the network feed does not
    require a username and password, they can be omitted.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Mat-like classes
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides the `Mat` class, OpenCV provides a number of other classes that are
    quite similar to `Mat`, but different in how and when they are used. Here are
    the most important `Mat`-like classes that can be used instead of, or together
    with, the `Mat` class:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '`Mat_`: This is a subclass of the `Mat` class, but it provides a better access
    method than the `at` function, that is, using `().Mat_` is a template class and
    obviously needs to be provided with the type of the elements at compile time,
    something that can be avoided with the `Mat` class itself.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Matx`: This is best used with matrices that have a small size, or to be precise,
    a known and small size at compile time.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UMat`: This is a more recent implementation of the `Mat` class, which allows
    us to use OpenCL for faster matrix operations.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `UMat` can significantly increase the performance of your computer vision
    applications, but since it is used in exactly the same way as the `Mat` class,
    we'll ignore it throughout the chapters of this book; however, in practice and
    especially in real-time computer vision applications, you must always make sure
    to use classes and functions that are better optimized and more performant, such
    as `UMat`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're through all the crucial topics that are needed to easily take on computer
    vision algorithms using hands-on examples and real-life scenarios. We started
    this chapter by learning about OpenCV and its overall structure, including its
    modules and main building blocks. This helped us gain a perspective of the computer
    vision library that we'll be working on, but, more importantly, this gave us an
    overview of what's possible and what to expect when dealing with computer vision
    algorithms in general. We moved on to learn where and how to get OpenCV and how
    to install or build it on our own. We also learned how to create, build, and run
    C++ and Python projects that use the OpenCV library. Then, by learning all about
    the `Mat` class and dealing with pixels in an image, we learned how to alter and
    display an image. The final sections of this chapter included everything we need
    to know about reading and writing images from files saved on disk, whether they
    are single (or multi-page) images or videos files, and also cameras and network
    feeds. We finished the chapter by learning about a few other types from the OpenCV
    Mat family that can help improve our applications.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are aware of the real nature of an image (that it is, in essence,
    a matrix), we can start with possible operations on matrices and matrix-like entities.
    In the next chapter, we're going to learn all about the matrix and array operations
    that fall into the realm of computer vision. By the end of the next chapter, we'll
    be able to perform tons of pixel-wise and image-wise operations and transformations
    using OpenCV.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name three Extra OpenCV modules along with their usages.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the effect of building OpenCV 3 with the `BUILD_opencv_world` flag turned
    on?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the ROI pixel-access method described in this chapter, how can we construct
    a `Mat` class that can access the middle pixel, plus all of its neighboring pixels
    (the middle nine pixels) in another image?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name another pixel-access method of the `Mat` class besides the ones mentioned
    in this chapter.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了本章中提到的之外，请说出 `Mat` 类的另一种像素访问方法。
- en: Write a program only using the `at` method and a `for` loop, which creates three
    separate color images, each one containing only one channel of an RGB image read
    from disk.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅使用 `at` 方法和 `for` 循环编写一个程序，该程序创建三个单独的颜色图像，每个图像只包含从磁盘读取的 RGB 图像的一个通道。
- en: Using STL-like iterators, calculate the average pixel value of a grayscale image.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类似 STL 的迭代器，计算灰度图像的平均像素值。
- en: Write a program using `VideoCapture`, `waitKey`, and `imwrite`, that displays
    your webcam and saves the visible image when the *S* key is pressed. This program
    will stop the webcam and exit if the spacebar key is pressed.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个使用 `VideoCapture`、`waitKey` 和 `imwrite` 的程序，当按下 *S* 键时显示您的网络摄像头并保存可见图像。如果按下空格键，此程序将停止网络摄像头并退出。
- en: Further reading
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Computer Vision with OpenCV 3 and Qt5*: [https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5](https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 OpenCV 3 和 Qt5 进行计算机视觉*：[https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5](https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5)'
- en: '*Learn Qt5*: [https://www.packtpub.com/web-development/learn-qt-5](https://www.packtpub.com/web-development/learn-qt-5)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习 Qt5*：[https://www.packtpub.com/web-development/learn-qt-5](https://www.packtpub.com/web-development/learn-qt-5)'
- en: '*Qt5 Projects*: [https://www.packtpub.com/application-development/qt-5-projects](https://www.packtpub.com/application-development/qt-5-projects)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Qt5 项目*：[https://www.packtpub.com/application-development/qt-5-projects](https://www.packtpub.com/application-development/qt-5-projects)'
