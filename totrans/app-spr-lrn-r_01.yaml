- en: '*Chapter 1:*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章：*'
- en: R for Advanced Analytics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R高级分析
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Explain advanced R programming constructs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释高级R编程结构
- en: Print the summary statistics of a real-world dataset
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印真实世界数据集的摘要统计信息
- en: Read data from CSV, text, and JSON files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从CSV、文本和JSON文件中读取数据
- en: Write R markdown files for code reproducibility
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写R markdown文件以实现代码可重复性
- en: Explain R data structures such as data.frame, data.table, lists, arrays, and
    matrices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释R数据结构，如data.frame、data.table、列表、数组以及矩阵
- en: Implement the cbind, rbind, merge, reshape, aggregate, and apply functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现cbind、rbind、merge、reshape、aggregate和apply函数
- en: Use packages such as dplyr, plyr, caret, tm, and many more
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用dplyr、plyr、caret、tm等包以及其他许多包
- en: Create visualizations using ggplot
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ggplot创建可视化
- en: In this chapter, we will set the foundation for programming with R and understand
    the various syntax and data structures for advanced analytics.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为使用R进行编程奠定基础，并了解高级分析的各种语法和数据结构。
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: R was one of the early programming languages developed for statistical computing
    and data analysis with good support for visualization. With the rise of data science,
    R emerged as an undoubted choice of programming language among many data science
    practitioners. Since R was open-source and extremely powerful in building sophisticated
    statistical models, it quickly found adoption in both industry and academia.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: R是早期为统计计算和数据分析开发的编程语言之一，具有良好的可视化支持。随着数据科学的兴起，R在众多数据科学从业者中成为无可争议的编程语言选择。由于R是开源的，并且在构建复杂的统计模型方面非常强大，它很快在工业和学术界得到了广泛应用。
- en: Tools and software such as SAS and SPSS were only affordable by large corporations,
    and traditional programming languages such as C/C++ and Java were not suitable
    for performing complex data analysis and building model. Hence, the need for a
    much more straightforward, comprehensive, community-driven, cross-platform compatible,
    and flexible programming language was a necessity.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 工具和软件如SAS和SPSS仅大型企业能够负担得起，而传统的编程语言如C/C++和Java不适合进行复杂的数据分析和构建模型。因此，需要一个更加直接、全面、社区驱动、跨平台兼容和灵活的编程语言成为了一种必需。
- en: Though Python programming language is increasingly becoming popular in recent
    times because of its industry-wide adoption and robust production-grade implementation,
    R is still the choice of programming language for quick prototyping of advanced
    machine learning models. R has one of the most populous collection of packages
    (a collection of functions/methods for accomplishing a complicated procedure,
    which otherwise requires a lot of time and effort to implement). At the time of
    writing this book, the **Comprehensive R Archive Network** (**CRAN**), a network
    of FTP and web servers around the world that store identical, up-to-date, versions
    of code and documentation for R, has more than 13,000 packages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Python编程语言近年来因其在整个行业的采用和强大的生产级实现而越来越受欢迎，但R仍然是快速原型化高级机器学习模型的编程语言选择。R拥有最丰富的包集合（一个用于完成复杂过程的函数/方法的集合，否则需要花费大量时间和精力来实现）。在撰写本书时，**综合R档案网络**（**CRAN**），一个全球范围内的FTP和Web服务器网络，存储了R的代码和文档的相同、最新版本，拥有超过13,000个包。
- en: While there are numerous books and online resources on learning the fundamentals
    of R, in this chapter, we will limit the scope only to cover the important topics
    in R programming that will be used extensively in many data science projects.
    We will use a real-world dataset from the UCI Machine Learning Repository to demonstrate
    the concepts. The material in this chapter will be useful for learners who are
    new to R Programming. The upcoming chapters in supervised learning concepts will
    borrow many of the implementations from this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多关于学习R基础知识的书籍和在线资源，但在本章中，我们将仅限于涵盖在许多数据科学项目中广泛使用的R编程的重要主题。我们将使用来自UCI机器学习仓库的真实世界数据集来展示这些概念。本章的材料将对新接触R编程的学习者很有用。在接下来的章节中，监督学习概念将借鉴本章的许多实现。
- en: Working with Real-World Datasets
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与真实世界数据集一起工作
- en: 'There are plenty of open datasets available online these days. The following
    are some popular sources of open datasets:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目前网上有大量可用的开放数据集。以下是一些流行的开放数据集来源：
- en: '**Kaggle**: A platform for hosting data science competitions. The official
    website is [https://www.kaggle.com/](https://www.kaggle.com/).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kaggle**: 一个用于举办数据科学竞赛的平台。官方网站是[https://www.kaggle.com/](https://www.kaggle.com/)。'
- en: '**UCI Machine Learning Repository**: A collection of databases, domain theories,
    and data generators that are used by the machine learning community for the empirical
    analysis of machine learning algorithms. You can visit the official page via navigating
    to [https://archive.ics.uci.edu/ml/index.php](https://archive.ics.uci.edu/ml/index.php)
    URL.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UCI机器学习仓库**: 机器学习社区用于实证分析机器学习算法的数据库、领域理论和数据生成器的集合。您可以通过导航到[https://archive.ics.uci.edu/ml/index.php](https://archive.ics.uci.edu/ml/index.php)
    URL访问官方网站。'
- en: '**data.gov.in**: Open Indian government data platform, which is available at
    [https://data.gov.in/](https://data.gov.in/).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**data.gov.in**: 开放印度政府数据平台，可在[https://data.gov.in/](https://data.gov.in/)找到。'
- en: '**World Bank Open Data**: Free and open access to global development data,
    which can be accessed from [https://data.worldbank.org/](https://data.worldbank.org/).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**世界银行开放数据**: 免费和开放访问全球发展数据，可通过[https://data.worldbank.org/](https://data.worldbank.org/)访问。'
- en: Increasingly, many private and public organizations are willing to make their
    data available for public access. However, it is restricted to only complex datasets
    where the organization is looking for solutions to their data science problem
    through crowd-sourcing platforms such as Kaggle. There is no substitute for learning
    from data acquired internally in the organization as part of a job that offers
    all kinds of challenges in processing and analyzing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的私营和公共组织愿意将他们的数据公开供公众访问。然而，这仅限于那些组织正在通过Kaggle等众包平台寻求解决其数据科学问题的复杂数据集。从组织内部获得的数据作为工作的一部分进行学习是没有替代品的，这项工作在处理和分析方面提供了各种挑战。
- en: Significant learning opportunity and challenge concerning data processing comes
    from the public data sources as well, as not all the data from these sources are
    clean and in a standard format. JSON, Excel, and XML are some other formats used
    along with CSV, though CSV is predominant. Each format needs a separate encoding
    and decoding method and hence a reader package in R. In our next section, we will
    discuss various data formats and how to process the available data in detail.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据处理方面的重大学习机会和挑战也来自公共数据源，因为这些数据源中的数据并不都是干净和标准格式的。除了CSV之外，JSON、Excel和XML也是一些其他格式，尽管CSV占主导地位。每种格式都需要单独的编码和解码方法，因此在R中需要一个单独的读取器包。在我们下一节中，我们将讨论各种数据格式以及如何详细处理可用的数据。
- en: 'Throughout this chapter and in many others, we will use the direct marketing
    campaigns (phone calls) of a Portuguese banking institution dataset from UCI Machine
    Learning Repository. ([https://archive.ics.uci.edu/ml/datasets/bank+marketing](https://archive.ics.uci.edu/ml/datasets/bank+marketing)).
    The following table describes the fields in detail:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及许多其他章节中，我们将使用来自UCI机器学习仓库的葡萄牙银行机构的直接营销活动（电话）数据集。([https://archive.ics.uci.edu/ml/datasets/bank+marketing](https://archive.ics.uci.edu/ml/datasets/bank+marketing))以下表格详细描述了字段：
- en: '![Figure 1.1: Portuguese banking institution dataset from UCI Machine Learning
    Repository (Part 1)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1：来自UCI机器学习仓库的葡萄牙银行机构数据集（第一部分）]'
- en: '](img/C12624_01_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C12624_01_01.jpg)'
- en: 'Figure 1.1: Portuguese banking institution dataset from UCI Machine Learning
    Repository (Part 1)'
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.1：来自UCI机器学习仓库的葡萄牙银行机构数据集（第一部分）
- en: '![Figure 1.2: Portuguese banking institution dataset from UCI Machine Learning
    Repository (Part 2)](img/C12624_01_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2：来自UCI机器学习仓库的葡萄牙银行机构数据集（第二部分）](img/C12624_01_02.jpg)'
- en: 'Figure 1.2: Portuguese banking institution dataset from UCI Machine Learning
    Repository (Part 2)'
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.2：来自UCI机器学习仓库的葡萄牙银行机构数据集（第二部分）
- en: In the following exercise, we will download the `bank.zip` dataset as a ZIP
    file and unzip it using the `unzip` method.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将下载`bank.zip`数据集作为ZIP文件，并使用`unzip`方法解压它。
- en: 'Exercise 1: Using the unzip Method for Unzipping a Downloaded File'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：使用unzip方法解压下载的文件
- en: In this exercise, we will write an R script to download the Portuguese Bank
    Direct Campaign dataset from UCI Machine Learning Repository and extract the content
    of the ZIP file in a given folder using the `unzip` function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个R脚本，从UCI机器学习仓库下载葡萄牙银行直接营销活动数据集，并使用`unzip`函数在指定文件夹中提取ZIP文件的内容。
- en: 'Preform these steps to complete the exercise:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: First, open R Studio on your system.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在您的系统上打开R Studio。
- en: 'Now, set the working directory of your choice using the following command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令设置您选择的当前工作目录：
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: R codes in this book are implemented using the R version 3.2.2.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书中的R代码使用R版本3.2.2实现。
- en: 'Download the ZIP file containing the datasets using the `download.file()` method:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`download.file()`方法下载包含数据集的ZIP文件：
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, before we unzip the file in the working directory using the `unzip()`
    method, we need to choose a file and save its file path in R (for Windows) or
    specify the complete path:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们使用`unzip()`方法在工作目录中解压文件之前，我们需要选择一个文件并将其文件路径保存在R中（对于Windows）或指定完整路径：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Define the folder where the ZIP file is unzipped:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义ZIP文件解压的文件夹：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, unzip the ZIP file using the following command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下命令解压ZIP文件：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 1.3: Unzipping the bank.zip file'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3：解压bank.zip文件'
- en: '](img/C12624_01_03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C12624_01_03.jpg)'
- en: 'Figure 1.3: Unzipping the bank.zip file'
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.3：解压bank.zip文件
- en: Reading Data from Various Data Formats
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从各种数据格式读取数据
- en: 'Data from digital systems is generated in various forms: browsing history on
    an e-commerce website, clickstream data, the purchase history of a customer, social
    media interactions, footfalls in a retail store, images from satellite and drones,
    and numerous other formats and types of data. We are living in an exciting time
    when technology is significantly changing lives, and enterprises are leveraging
    it to create their next data strategy to make better decisions.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 来自数字系统的数据以各种形式生成：电子商务网站上的浏览历史、点击流数据、客户的购买历史、社交媒体互动、零售店的客流量、卫星和无人机图像，以及众多其他格式和类型的数据。我们正处于一个令人兴奋的时代，技术正在极大地改变我们的生活，企业正在利用它来制定他们的下一份数据战略，以做出更好的决策。
- en: It is not enough to be able to collect a huge amount of different types of data;
    we also need to leverage value out of it. A CCTV footage captured throughout a
    day will help the law and order teams of the government in improving the real-time
    surveillance of public places. The challenge remains in how we will process a
    large volume of heterogeneous data formats within a single system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 能够收集大量不同类型的数据是不够的；我们还需要从中提取价值。一天中拍摄的视频监控可以帮助政府执法团队改善公共场所的实时监控。挑战在于如何在单一系统中处理大量异构数据格式。
- en: Transaction data in the **Customer Relationship Management** (**CRM**) application
    would mostly be tabular and feed in social media is mostly text, audio, video,
    and images.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在**客户关系管理**（CRM）应用中的交易数据大多为表格形式，而流入社交媒体的数据大多是文本、音频、视频和图片。
- en: We can categorize the data formats as structured—tabular data such as CSV and
    database tables; unstructured—textual data such as tweets, FB posts, and word
    documents; and semi-structured. Unlike textual, which is hard for machines to
    process and understand, semi-structured provides associated metadata, which makes
    it easy for computers to process it. It's popularly used with many web applications
    for data exchange, and JSON is an example of the semi-structured data format.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将数据格式分为结构化——如CSV和数据库表之类的表格数据；非结构化——如推文、FB帖子和Word文档之类的文本数据；以及半结构化。与难以让机器处理和理解的文本不同，半结构化提供了关联的元数据，这使得计算机处理它变得容易。它广泛应用于许多Web应用程序中的数据交换，JSON是半结构化数据格式的一个例子。
- en: In this section, we will see how to load, process, and transform various data
    formats in R. Within the scope of this book, we will work with CSV, text, and
    JSON data.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何在R中加载、处理和转换各种数据格式。在本书的范围内，我们将处理CSV、文本和JSON数据。
- en: CSV Files
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSV文件
- en: CSV files are the most common type of data storage and exchange formats for
    structured data. R provides a method called `read.csv()` for reading data from
    a CSV file. It will read the data into a `data.frame` (more about it in the next
    section). There are many arguments that the method takes; the two required arguments
    are a path to the `filename` and `sep`, which specifies the character that separates
    the column values. The `summary()` method describes the six summary statistics,
    **min**, **first quartile**, **median**, **mean**, **third quartile**, and **max**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CSV文件是结构化数据最常见的数据存储和交换格式。R提供了一个名为`read.csv()`的方法，用于从CSV文件中读取数据。它将数据读入`data.frame`（更多内容将在下一节介绍）。该方法接受许多参数；其中两个必需参数是`filename`的路径和`sep`，它指定了分隔列值的字符。`summary()`方法描述了六个汇总统计量：**最小值**、**第一四分位数**、**中位数**、**平均值**、**第三四分位数**和**最大值**。
- en: In the following exercise, we'll read a CSV file and summarize its column.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将读取 CSV 文件并总结其列。
- en: 'Exercise 2: Reading a CSV File and Summarizing its Column'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 2：读取 CSV 文件并总结其列
- en: In this exercise, we will read the previously extracted CSV file and use the
    `summary` function to print the min, max, mean, median, 1st quartile, and 3rd
    quartile values of numeric variables and count the categories of the categorical
    variable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将读取之前提取的 CSV 文件，并使用 `summary` 函数打印数值变量的最小值、最大值、平均值、中位数、第一四分位数和第三四分位数，并计算分类变量的类别数。
- en: 'Carry out these steps to read a CSV file and later summarize its columns:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以读取 CSV 文件并随后总结其列：
- en: 'First, use the `read.csv` method and load the `bank-full.csv` into a DataFrame:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 `read.csv` 方法将 `bank-full.csv` 载入 DataFrame：
- en: '[PRE5]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Print the summary of the DataFrame:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印 DataFrame 的摘要：
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: JSON
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON
- en: JSON is the next most commonly used data format for sharing and storing data.
    It is unlike CSV files, which only deal with rows and columns of data where each
    has a definite number of columns. For example, in the e-commerce data of the customers,
    each row could be representing a customer with their information stored in separate
    columns. For a customer, if a column has no value, the field is stored as NULL.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是用于共享和存储数据的下一个最常用的数据格式。它与 CSV 文件不同，CSV 文件只处理行和列的数据，其中每一行都有确定数量的列。例如，在电子商务客户数据中，每一行可能代表一个客户，其信息存储在单独的列中。对于一个客户，如果某列没有值，该字段存储为
    NULL。
- en: JSON provides an added flexibility of having a varying number of fields for
    each customer. This type of flexibility relieves the developer from the burden
    of maintaining a schema as we have in traditional relational databases, wherein
    the same customer data might be spread across multiple tables to optimize for
    storage and querying time.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 提供了额外的灵活性，即每个客户可以有可变数量的字段。这种类型的灵活性减轻了开发者在传统关系数据库中维护模式时的负担，在传统关系数据库中，相同客户的数据可能分散在多个表中以优化存储和查询时间。
- en: JSON is more of a key-value store type of storage, where all we care about is
    the keys (such as the name, age, and DOB) and their corresponding values. While
    this sounds flexible, proper care has to be taken, otherwise manageability might
    at times, go out of control. Fortunately, with the advent of big data technologies
    in recent days, many document stores (a subclass of the key-value store), popularly
    also known as **NoSQL** databases, are available for storing, retrieving, and
    processing data in such formats.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 更像是一种键值存储类型的存储，我们只关心键（如姓名、年龄和出生日期）及其对应的值。虽然这听起来很灵活，但必须采取适当的注意，否则管理可能会在某些时候失控。幸运的是，随着近年来大数据技术的出现，许多文档存储（键值存储的一个子类），通常也称为
    **NoSQL** 数据库，可用于存储、检索和处理此类格式的数据。
- en: In the following exercise, the JSON file has data for cardamom (spices and condiments)
    cultivation district-wise in Tamil Nadu, India, for the year 2015-16\. The keys
    include **area** (hectare), **production** (in quintals), and **productivity**
    (average yield per hectare).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，JSON 文件包含 2015-16 年印度泰米尔纳德邦辣椒（香料和调味品）种植区的数据。键包括 **面积**（公顷）、**产量**（公担）和
    **生产力**（每公顷平均产量）。
- en: The `jsonlite` package provides an implementation to read and convert a JSON
    file into DataFrame, which makes the analysis simpler. The `fromJSON` method reads
    a JSON file, and if the `flatten` argument in the `fromJSON` function is set to
    `TRUE`, it gives a DataFrame.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsonlite` 包提供了一个实现，可以将 JSON 文件读取并转换为 DataFrame，这使得分析更加简单。`fromJSON` 方法读取 JSON
    文件，如果 `fromJSON` 函数中的 `flatten` 参数设置为 `TRUE`，则返回一个 DataFrame。'
- en: 'Exercise 3: Reading a JSON file and Storing the Data in DataFrame'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 3：读取 JSON 文件并将数据存储在 DataFrame 中
- en: In this exercise, we will read a JSON file and store the data in the DataFrame.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将读取 JSON 文件并将数据存储在 DataFrame 中。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: Download the data from [https://data.gov.in/catalog/area-production-productivity-spices-condiments-district-wise-tamil-nadu-year-2015-16](https://data.gov.in/catalog/area-production-productivity-spices-condiments-district-wise-tamil-nadu-year-2015-16).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://data.gov.in/catalog/area-production-productivity-spices-condiments-district-wise-tamil-nadu-year-2015-16](https://data.gov.in/catalog/area-production-productivity-spices-condiments-district-wise-tamil-nadu-year-2015-16)
    下载数据。
- en: 'First, use the following command to install the packages required for the system
    of read the JSON file:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令安装读取 JSON 文件所需的包：
- en: '[PRE8]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, read the JSON file using the `fromJSON` method, as illustrated here:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `fromJSON` 方法读取 JSON 文件，如下所示：
- en: '[PRE9]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The second element in the list contains the DataFrame with crop production
    value. Retrieve it from `json_data` and store as a DataFrame named `crop_production`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表中的第二个元素包含包含作物生产价值的 DataFrame。从 `json_data` 中检索它，并将其存储为名为 `crop_production`
    的 DataFrame：
- en: '[PRE10]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, use the following command to rename the columns:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令重命名列：
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, print the top six rows using the `head()` function:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `head()` 函数打印前六行：
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE13]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Text
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本
- en: Unstructured data is the language of the web. All the social media, blogs, web
    pages, and many other sources of information are textual and untidy to extract
    any meaningful information. An increasing amount of research work is coming out
    from the **Natural Language Processing** (**NLP**) field, wherein computers are
    becoming better in understanding not only the meaning of the word but also the
    context in which it's used in a sentence. The rise of computer chatbot, which
    responds to a human query, is the most sophisticated form of understanding textual
    information.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 非结构化数据是网络的通用语言。所有社交媒体、博客、网页以及许多其他信息来源都是文本形式且杂乱无章，难以从中提取任何有意义的信息。越来越多的研究工作来自
    **自然语言处理**（**NLP**）领域，其中计算机不仅变得更擅长理解单词的意义，而且还能理解句子中单词的使用上下文。计算机聊天机器人的兴起，它能对人类查询做出响应，是理解文本信息最复杂的形式。
- en: In R, we will use the `tm` text mining package to show how to read, process,
    and retrieve meaningful information from text data. We will use a small sample
    of the **Amazon Food Review** dataset in Kaggle ([https://www.kaggle.com/snap/amazon-fine-food-reviews](https://www.kaggle.com/snap/amazon-fine-food-reviews))
    for the exercise in this section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，我们将使用 `tm` 文本挖掘包来展示如何读取、处理和从文本数据中检索有意义的信息。我们将使用 Kaggle 上的 **Amazon Food
    Review** 数据集的小样本（[https://www.kaggle.com/snap/amazon-fine-food-reviews](https://www.kaggle.com/snap/amazon-fine-food-reviews)）来练习本节的内容。
- en: In the `tm` package, collections of text documents are called `tm` package is
    `VCorpus` (`VCorpus` object, we can use the `inspect()` method. The following
    exercise uses the `lapply` method for looping through the first two reviews and
    casting the text as a character. You will learn more about the `apply` family
    of function in the *The Apply Family of Functions* section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `tm` 包中，文本文档的集合被称为 `tm` 包的 `VCorpus`（`VCorpus` 对象）。我们可以使用 `inspect()` 方法。以下练习使用
    `lapply` 方法遍历前两条评论并将文本转换为字符。你将在 *函数的 Apply 家族* 部分了解更多关于 `apply` 家族函数的信息。
- en: 'Exercise 4: Reading a CSV File with Text Column and Storing the Data in VCorpus'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 4：读取具有文本列的 CSV 文件并将数据存储在 VCorpus 中
- en: In this exercise, we will read a CSV file with the text column and store the
    data in VCorpus.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将读取具有文本列的 CSV 文件并将数据存储在 VCorpus 中。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 完成练习的步骤如下：
- en: 'First, let''s load the text mining package from the R into the system to read
    the text file:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将 R 中的文本挖掘包加载到系统中以读取文本文件：
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, read the first top 10 reviews from the file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从文件中读取前 10 条评论：
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To store the text column in `VCorpus`, use the following command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将文本列存储在 `VCorpus` 中，使用以下命令：
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To inspect the structure of first two reviews, execute the following command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查前两条评论的结构，执行以下命令：
- en: '[PRE17]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE18]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using `lapply`, cast the first review as character and print:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `lapply` 将第一条评论转换为字符并打印：
- en: '[PRE19]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We will revisit the `review_corpus` dataset in a later section to show how to
    convert the unstructured textual information to structured tabular data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后的部分重新访问 `review_corpus` 数据集，展示如何将非结构化文本信息转换为结构化表格数据。
- en: Apart from CSV, Text, and JSON, there are numerous other data formats depending
    upon the source of data and its usage. R has a rich collection of libraries that
    helps with many formats. R can import not only the standard formats (apart from
    the previous three) such as HTML tables and XML but also formats specific to an
    analytical tool such as SAS and SPSS. This democratization led to a significant
    migration of industry experts who were earlier working in the propriety tools
    (costly and often found with only the large corporations) to open source analytical
    programming languages such as R and Python.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 CSV、文本和 JSON 格式之外，还有许多其他数据格式，这取决于数据来源及其用途。R 拥有一系列丰富的库，可以帮助处理许多格式。R 可以导入不仅包括标准格式（除前三种之外）如
    HTML 表格和 XML，还可以导入特定于分析工具的格式，如 SAS 和 SPSS。这种民主化导致了行业专家的重大迁移，他们之前在专有工具（成本高昂且通常只有大型企业才有）中工作，转向开源分析编程语言，如
    R 和 Python。
- en: Write R Markdown Files for Code Reproducibility
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为代码可重复性编写 R Markdown 文件
- en: The considerable success of analytics is a result of the way the information
    and knowledge network around the subject started to spread. More open source communities
    emerged, developers were happily sharing their work with the outer world, and
    many data projects were becoming reproducible. This change meant that work started
    by one person was soon getting adapted, improvised, and modified in many different
    forms by a community of people before it got adopted in an entirely different
    domain than the one from where it initially emerged. Imagine every research work
    that gets published in conference submitting a collection of code and data that
    is easily reproducible along with their research paper. This change is accelerating
    the pace at which an idea meets reality, and innovation will start to boom.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 分析学的巨大成功是信息与知识网络在主题周围开始传播的结果。出现了更多的开源社区，开发者们愉快地与外界分享他们的工作，许多数据项目变得可重复。这种变化意味着一个人开始的工作很快就会被一个社区以许多不同的形式适应、即兴创作和修改，在它被完全不同的领域采用之前，这个领域与它最初出现的领域完全不同。想象一下，每个在会议上发表的研究工作都提交了一个易于重复的代码和数据集，以及他们的研究论文。这种变化正在加快想法与现实相遇的速度，创新将开始蓬勃发展。
- en: Now, let's see how to create such reproducible work in a single file that we
    call the **R Markdown** file. In the following activity, we will demonstrate how
    to create a new R Markdown file in RStudio. A detailed intro to R Markdown could
    be found at [https://rmarkdown.rstudio.com/lesson-1.html](https://rmarkdown.rstudio.com/lesson-1.html).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在单个文件中创建这样的可重复工作，我们称之为**R Markdown**文件。在以下活动中，我们将演示如何在 RStudio 中创建一个新的
    R Markdown 文件。有关 R Markdown 的详细介绍，请参阅[https://rmarkdown.rstudio.com/lesson-1.html](https://rmarkdown.rstudio.com/lesson-1.html)。
- en: In the next activity, you will recreate the code shown in *Exercise 4*, *Reading
    a CSV File with Text Column and Storing the Data in VCorpus*, into an R Markdown.
    Observe in *Figure 4.2* that you have just written the explanation and the code
    in R Markdown, and when the **Knit to Word** action is performed, it interweaves
    the explanation, code, and its output neatly into a word document.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，你将把 *练习 4* 中显示的代码（使用 Text Column 读取 CSV 文件并将数据存储在 VCorpus 中）重新创建到 R
    Markdown 中。在 *图 4.2* 中观察，你刚刚在 R Markdown 中编写了说明和代码，当执行 **Knit to Word** 操作时，它将说明、代码及其输出整齐地交织到一个文档中。
- en: 'Activity 1: Create an R Markdown File to Read a CSV File and Write a Summary
    of Data'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 1：创建一个 R Markdown 文件来读取 CSV 文件并编写数据摘要
- en: 'In this activity, we will create a R Markdown file to read a CSV file and print
    a small summary of the data in a word file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将创建一个 R Markdown 文件来读取 CSV 文件，并在一个文档中打印数据的小型摘要：
- en: 'Perform the following steps to complete the activity:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成活动：
- en: 'Open RStudio and navigate to the **R Markdown** option:![Figure 1.4: Creating
    a new R Markdown file in Rstudio](img/C12624_01_04.jpg)'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 RStudio 并导航到**R Markdown**选项：![图 1.4：在 RStudio 中创建新的 R Markdown 文件](img/C12624_01_04.jpg)
- en: 'Figure 1.4: Creating a new R Markdown file in Rstudio'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.4：在 RStudio 中创建新的 R Markdown 文件
- en: 'Provide the **Title** and **Author** name for the document and select the **Default
    Output Format** as **Word**:![Figure 1.5: Using the read.csv method to read the
    data'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为文档提供**标题**和**作者**名称，并将**默认输出格式**选择为**Word**：![图 1.5：使用 read.csv 方法读取数据
- en: '](img/C12624_01_05.jpg)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C12624_01_05.jpg)'
- en: 'Figure 1.5: Using the read.csv method to read the data'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.5：使用 read.csv 方法读取数据
- en: Use the `read.csv()` method to read the `bank-full.csv` file.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `read.csv()` 方法读取 `bank-full.csv` 文件。
- en: Finally, print the summary into a word file using the `summary` method.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`summary`方法将摘要打印到word文件中。
- en: 'The output is as follows:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 1.6: Final output after using the summary method](img/C12624_01_06.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6：使用summary方法后的最终输出](img/C12624_01_06.jpg)'
- en: 'Figure 1.6: Final output after using the summary method'
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.6：使用summary方法后的最终输出
- en: Note
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found at page 438.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第438页找到。
- en: Data Structures in R
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: R中的数据结构
- en: In any programming language, data structures are the fundamental units of storing
    information and making it ready for further processing. Depending on the type
    of data, various forms of data structures are available for **storing** and **processing**.
    Each of the data structures explained in the next section has its characteristic
    features and applicability.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中，数据结构是存储信息并使其准备进一步处理的基本单元。根据数据类型，有各种形式的数据结构可用于**存储**和**处理**。下一节中解释的每个数据结构都有其特征和适用性。
- en: In this section, we will explore each of it and how to use it with our data.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索每个数据结构及其如何与我们的数据一起使用。
- en: Vector
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量
- en: '`c()` method, as shown here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`c()`方法，如下所示：'
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can extract the second value in the vector by specifying the index in square
    brackets next to the vector name. Let''s review the following code where we subset
    the value in the second index:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定向量名称旁边的方括号中的索引来提取向量中的第二个值。让我们回顾以下代码，其中我们提取第二个索引的值：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The collection of string concatenated with the `c()` method is a vector. It
    can store a homogenous collection of characters, integers, or floating point values.
    While trying to store an integer with character, an implicit type cast will happen,
    which will convert all the values to character.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`c()`方法连接的字符串集合是一个向量。它可以存储同质的数据集合，如字符、整数或浮点值。在尝试用字符存储整数时，将发生隐式类型转换，将所有值转换为字符。
- en: Caution
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 谨慎
- en: Note that it might not be the expected behavior every time. Caution is required,
    especially when the data is not clean. It may otherwise cause errors that are
    harder to find than the usual programming errors.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这不一定每次都是预期的行为。需要谨慎，尤其是在数据不干净时。否则可能会造成比通常编程错误更难找到的错误。
- en: Matrix
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩阵
- en: '**Matrix** is the higher dimension data structure used for storing *n*-dimensional
    data. It is suitable for storing tabular data. Similar to vector, the matrix also
    allows only homogenous collection of data in its rows and columns.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**矩阵**是用于存储*n*维数据的更高维数据结构。它适用于存储表格数据。与向量类似，矩阵也只允许在其行和列中存储同质的数据集合。'
- en: 'The following code generates 16 random numbers drawn from a binomial distribution
    with a parameter, number of trials `(size) = 100`, and success probability equal
    to `0.4`. The `rbinom()` method in R is useful for generating such random numbers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码生成16个来自参数为试验次数`(size) = 100`和成功概率等于`0.4`的二项分布的随机数。R中的`rbinom()`方法用于生成此类随机数：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, to store `r_number` as a matrix, use the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要存储`r_number`为矩阵，请使用以下命令：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's extend the text mining example we took in *Exercise 4*, *Reading a CSV
    File with Text Column and Storing the Data in VCorpus*, to understand the usage
    of matrix in text mining.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们在*练习4*中使用的文本挖掘示例，即*使用VCorpus存储具有文本列的CSV文件*，以了解矩阵在文本挖掘中的使用。
- en: 'Consider the following two reviews. Use the `lapply` to type cast the first
    review to `as.character` and print:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个评论。使用`lapply`将第一个评论转换为`as.character`并打印：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, in the following exercise, we will transform the data to remove stopwords,
    whitespaces, and punctuations from these two paragraphs. We will then perform
    stemming (both *looking* and *looked* will be reduced to look). Also, for consistency,
    convert all the text into lowercase.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在以下练习中，我们将转换数据以从这两段文本中删除停用词、空白和标点符号。然后我们将进行词干提取（both *looking* 和 *looked*
    将被缩减为 look）。此外，为了保持一致性，将所有文本转换为小写。
- en: 'Exercise 5: Performing Transformation on the Data to Make it Available for
    the Analysis'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5：对数据进行转换以便进行分析
- en: In this exercise, we will perform the transformation on the data to make it
    available for further analysis.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将对数据进行转换，使其可用于进一步分析。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 完成练习的以下步骤：
- en: 'First, use the following commands to convert all the characters in the data
    to lowercase:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令将数据中的所有字符转换为小写：
- en: '[PRE28]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output is as follows:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE29]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, remove the stopwords from the data, such as, `a`, `the`, `an`, and many
    more:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从数据中移除停用词，例如，`a`、`the`、`an` 以及更多：
- en: '[PRE30]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE31]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Remove extra whitespaces between words using the following command:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令移除单词之间的额外空格：
- en: '[PRE32]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is as follows:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE33]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Perform the stemming process, which will only keep the root of the word. For
    example, `looking` and `looked` will become `look`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行词干提取过程，这将只保留单词的词根。例如，`looking` 和 `looked` 将变为 `look`：
- en: '[PRE34]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output is as follows:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE35]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now that we have the text processed and cleaned up, we can create a document
    matrix that stores merely the frequency of the occurrence of distinct words in
    the two reviews. We will demonstrate how to count each word contained in the review.
    Each row of the matrix represents one review, and the columns are distinct words.
    Most of the values are zero because not all the words will be present in each
    review. In this example, we have a sparsity of 49%, which means only 51% of the
    matrix contains non-zero values.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经处理并清理了文本，我们可以创建一个文档矩阵，该矩阵仅存储两个评论中不同单词出现的频率。我们将演示如何计算评论中包含的每个单词。矩阵的每一行代表一个评论，列是不同的单词。大多数值都是零，因为并非每个评论都会包含所有单词。在这个例子中，稀疏度为
    49%，这意味着矩阵中只有 51% 的值是非零的。
- en: Create `as.matrix()` method again. The matrix contains two documents (reviews)
    and 37 unique words. The count of a particular word in a document is retrieved
    by specifying the row and column index or name in the matrix.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次创建 `as.matrix()` 方法。矩阵包含两个文档（评论）和 37 个唯一单词。通过指定矩阵中的行和列索引或名称来检索文档中特定单词的计数。
- en: 'Now, store the results in a matrix using the following command:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令将结果存储在矩阵中：
- en: '[PRE36]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To find the dimension of the matrix, that is, 2 documents and 37 words, use
    the following command:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到矩阵的维度，即 2 个文档和 37 个单词，请使用以下命令：
- en: '[PRE37]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output is as follows:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE38]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, print a subset of the matrix:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打印矩阵的子集：
- en: '[PRE39]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE40]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, count the word `product` in document 1 using the following command:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下命令在文档 1 中计算单词 `product`：
- en: '[PRE41]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is as follows:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE42]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: List
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: While vector and matrix both are useful structures to be used in various computations
    in a program, it might not be sufficient for storing a real-world dataset, which
    most often contains data of mix types, like a customer table in CRM application
    has the customer name and age together in two columns. The list offers a structure
    to allow for storing two different types of data together.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 vector 和 matrix 都是程序中用于各种计算的有用结构，但它们可能不足以存储现实世界的数据集，因为现实世界的数据集通常包含混合类型的数据，例如
    CRM 应用程序中的客户表有两个列，一列是客户姓名，另一列是年龄。列表提供了一种结构，允许存储两种不同类型的数据。
- en: In the following exercise, along with generating 16 random numbers, we have
    used the `sample()` method to generate 16 characters from the English alphabet.
    The `list` method stores both the integers and characters together.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，除了生成 16 个随机数外，我们还使用了 `sample()` 方法从英文字母表中生成 16 个字符。`list` 方法将整数和字符一起存储。
- en: 'Exercise 6: Using the List Method for Storing Integers and Characters Together'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 6：使用列表方法存储整数和字符
- en: In this exercise, we will use the `list` method to store randomly generated
    numbers and characters. The random numbers will be generated using the `rbinom`
    function, and the random characters will be selected from English alphabets A-Z.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `list` 方法存储随机生成的数字和字符。随机数将使用 `rbinom` 函数生成，随机字符将从英文字母表 A-Z 中选择。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成练习：
- en: 'First, generate 16 random numbers drawn from a binomial distribution with parameter
    size equals `100` and the probability of success equals `0.4`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，生成参数大小为 `100` 且成功概率为 `0.4` 的二项分布的 16 个随机数：
- en: '[PRE43]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, select 16 alphabets from English `LETTERS` without repetition:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从英语 `LETTERS` 中选择 16 个字母，不重复：
- en: '[PRE44]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Put `r_numbers` and `r_characters` into a single list. The `list()` function
    will create the data structure list with `r_numbers` and `r_characters`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `r_numbers` 和 `r_characters` 放入一个单独的列表中。`list()` 函数将创建包含 `r_numbers` 和 `r_characters`
    的数据结构列表：
- en: '[PRE45]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output is as follows:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE46]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the following step, we will see a list with the integer and character vectors
    stored together.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将看到一个包含整数和字符向量一起存储的列表。
- en: 'Now, let''s store and retrieve integer and character vectors from a list:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将整数和字符向量存储和检索自一个列表：
- en: '[PRE47]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, retrieve values in the character vector using the following command:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令检索字符向量中的值：
- en: '[PRE48]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output is as follows:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE49]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, retrieve the first value in the character vector:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检索字符向量中的第一个值：
- en: '[PRE50]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output is as follows:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE51]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Though this solves the requirement of storing heterogeneous data types together,
    its still doesn't put any integrity checks on the relationship between the values
    in the two vectors. If we would like to assign every *letter* to one *integer*.
    In the previous output, `V` represents `48`, `C` represents `53`, and so on.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然这解决了存储异构数据类型的要求，但它仍然没有对两个向量中的值之间的关系进行任何完整性检查。如果我们想将每个*字母*分配给一个*整数*。在先前的输出中，`V`代表`48`，`C`代表`53`，以此类推。
- en: A list is not robust to handle such one-to-one mapping. Consider the following
    code, instead of `16` characters, if we generate 18 random characters, and it
    still allows for storing it in a list. The last two characters have no associated
    mapping with the integer now.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表无法很好地处理这种一对一映射。考虑以下代码，如果我们生成18个随机字符，而不是`16`个字符，它仍然允许将它们存储在列表中。现在最后两个字符没有与整数相关联的映射。
- en: 'Now, generate 16 random numbers drawn from a binomial distribution with parameter
    size equal to `100` and probability of success equal to `0.4`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，生成参数大小等于`100`，成功概率等于`0.4`的来自二项分布的16个随机数：
- en: '[PRE52]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Select any 18 alphabets from English `LETTERS` without repetition:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从英语`LETTERS`中选择任意18个字母，且不重复：
- en: '[PRE53]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Place `r_numbers` and `r_characters` into a single list:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`r_numbers`和`r_characters`放入一个单独的列表中：
- en: '[PRE54]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output is as follows:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE55]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Activity 2: Create a List of Two Matrices and Access the Values'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动二：创建两个矩阵的列表并访问其值
- en: In this activity, you will create two matrices and retrieve a few values using
    the index of the matrix. You will also perform operations such as multiplication
    and subtraction.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将创建两个矩阵，并使用矩阵的索引检索一些值。你还将执行乘法和减法等操作。
- en: 'Perform the following steps to complete the activity:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成活动：
- en: Create two matrices of size `10 x 4` and `4 x 5` by randomly generated numbers
    from a binomial distribution (use `rbinom` method). Call the matrix `mat_A` and
    `mat_B`, respectively.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从二项分布（使用`rbinom`方法）随机生成数字来创建大小为`10 x 4`和`4 x 5`的两个矩阵。分别命名为`mat_A`和`mat_B`。
- en: Now, store the two matrices in a list.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将两个矩阵存储在一个列表中。
- en: Using the list, access the row 4 and column 2 of `mat_A` and store it in variable
    `A`, and access row 2 and column 1 of `mat_B` and store it in variable `B`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用列表，访问`mat_A`的第4行第2列并将其存储在变量`A`中，以及访问`mat_B`的第2行第1列并将其存储在变量`B`中。
- en: Multiply the `A` and `B` matrices and subtract from row 2 and column 1 of `mat_A`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`A`和`B`矩阵相乘，并从`mat_A`的第2行第1列中减去。
- en: Note
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found at page 440.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可在第440页找到。
- en: DataFrame
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DataFrame
- en: With the limitation of vector, matrix, and list, a data structure suitable for
    real-world datasets was a much-needed requirement for data science practitioners.
    DataFrames are an elegant way of storing and retrieving tabular data. We have
    already seen how DataFrame handles the rows and columns of data in *Exercise 3*,
    *Reading a JSON File and Storing the Data in DataFrame*. DataFrames will be extensively
    used throughout the book.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于向量、矩阵和列表的限制，对于数据科学从业者来说，需要一个适合现实世界数据集的数据结构，这是一个迫切需要的要求。DataFrame是存储和检索表格数据的一种优雅方式。我们已经在*练习3*，*读取JSON文件并将数据存储在DataFrame中*中看到了DataFrame如何处理数据的行和列。DataFrame将在整本书中广泛使用。
- en: 'Exercise 7: Performing Integrity Checks Using DataFrame'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习7：使用DataFrame执行完整性检查
- en: Let's revisit *step 6* of *Exercise 6*, *Using the List Method for Storing Integers
    and Characters Together*, where we discussed the integrity check when we attempted
    to store two unequal length vectors in a list and will see how DataFrame handles
    it differently. We will, once again, generate random numbers (`r_numbers`) and
    random characters (`r_characters`).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下*练习6*的第*6步*，*使用列表方法存储整数和字符*，其中我们讨论了在尝试将两个不等长向量存储在列表中时的完整性检查，并看看DataFrame是如何不同地处理它的。我们再次生成随机数字（`r_numbers`）和随机字符（`r_characters`）。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'First, generate 16 random numbers drawn from a binomial distribution with parameter
    size equal to `100` and probability of success equal to `0.4`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，生成16个来自参数大小等于`100`和成功概率等于`0.4`的二项分布的随机数：
- en: '[PRE56]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Select any 18 alphabets from English `LETTERS` without repetition:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从英语`LETTERS`中选择任何18个字母，不重复：
- en: '[PRE57]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Put `r_numbers` and `r_characters` into a single DataFrame:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`r_numbers`和`r_characters`放入一个DataFrame中：
- en: '[PRE58]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The output is as follows:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE59]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, the error in the previous output shows that the last two LETTERS,
    that is, `P` and `Q`, have no mapping with a corresponding random `INTEGER` generated
    using the binomial distribution.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，前一个输出中的错误表明最后两个字母，即`P`和`Q`，与使用二项分布生成的相应随机`INTEGER`没有映射。
- en: Accessing any particular row and column in the DataFrame is similar to the matrix.
    We will show many tricks and techniques to best use the power of indexing in the
    DataFrame, which also includes some of the filtering options.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 访问DataFrame中的任何特定行和列与矩阵类似。我们将展示许多技巧和技术来最好地利用DataFrame中索引的强大功能，这还包括一些过滤选项。
- en: Every row in a DataFrame is a result of the tightly coupled collection of columns.
    Each column clearly defines the relationship each row of data has with every other
    one. If there is no corresponding value available in a column, it will be filled
    with NA. For example, a customer in a CRM application might not have filled their
    marital status, whereas a few other customers filled it. So, it becomes essential
    during application design to specify which columns are mandatory and which are
    optional.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame中的每一行都是紧密耦合的列集合的结果。每一列清楚地定义了数据中的每一行与其他每一行之间的关系。如果没有相应的值在列中可用，它将被填充为NA。例如，在CRM应用程序中，客户可能没有填写他们的婚姻状况，而其他一些客户填写了。因此，在应用程序设计期间指定哪些列是必需的，哪些是可选的变得至关重要。
- en: Data Table
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据表
- en: With the growing adaption of DataFrame came a time when its limitations started
    to surface. Particularly with large datasets, DataFrame performs poorly. In the
    complex analysis, we often create many intermediate DataFrames to store the results.
    However, R is built on an in-memory computation architecture, and it heavily depends
    on RAM. Unlike disk space, RAM is limited to either 4 or 8 GB in many standard
    desktops and laptops. DataFrame is not built efficiently to manage the memory
    during the computation, which often results in `out of memory error`, especially
    when working with large datasets.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 随着DataFrame的日益普及，其局限性开始显现。特别是在处理大型数据集时，DataFrame的表现不佳。在复杂分析中，我们经常创建许多中间DataFrame来存储结果。然而，R建立在内存计算架构之上，并且高度依赖于RAM。与磁盘空间不同，许多标准台式机和笔记本电脑的RAM限制在4或8GB。DataFrame在计算过程中没有高效地管理内存，这通常会导致“内存不足错误”，尤其是在处理大型数据集时。
- en: 'In order to handle this issue, `data.table` inherited the `data.frame` functionality
    and offers fast and memory-efficient version for the following task on top of
    it:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，`data.table`继承了`data.frame`的功能，并在其基础上提供了快速且内存高效的版本，用于以下任务：
- en: File reader and writer
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件读取器和写入器
- en: Aggregations
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合
- en: Updates
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新
- en: Equi, non-equi, rolling, range, and interval joins
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等值、不等值、滚动、范围和区间连接
- en: Efficient memory management makes the development fast and reduces the latency
    between operations. The following exercise shows the significant difference `data.table`
    makes in computation time as compared to `data.frame`. First, we read the complete
    `fread()` method, which is one of the fast reading methods from `data.table`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 高效的内存管理使得开发快速，并减少了操作之间的延迟。以下练习展示了`data.table`与`data.frame`相比在计算时间上的显著差异。首先，我们读取完整的`fread()`方法，这是`data.table`中快速读取方法之一。
- en: 'Exercise 8: Exploring the File Read Operation'
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习8：探索文件读取操作
- en: In this exercise, we will only show file read operations. You are encouraged
    to test the other functionalities ([https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html))
    and compare the data table capabilities over DataFrame.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们只展示文件读取操作。我们鼓励您测试其他功能（[https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html)）并比较数据表与DataFrame的能力。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'First, load the data table package using the following command:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令加载数据表包：
- en: '[PRE60]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Read the dataset using the `fread()` method of the `data.table` package:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`data.table`包的`fread()`方法读取数据集：
- en: '[PRE61]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output is as follows:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE62]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, read the same CSV file using the `read.csv()` method of base package:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用基础包中的`read.csv()`方法读取相同的CSV文件：
- en: '[PRE63]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output is as follows:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE64]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Observe that `3.78` seconds elapsed for reading it through the `fread()` method,
    while the `read.csv` function took `4.91` seconds. The execution speed is almost
    *30%* faster. As the size of the data increasing, this difference is even more
    significant.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过`fread()`方法读取它花费了`3.78`秒，而`read.csv`函数则花费了`4.91`秒。执行速度几乎快了*30%*。随着数据量的增加，这种差异变得更加显著。
- en: In the previous output, the `user` time is the time spent by the current R session,
    and `system` time is the time spent by the operating system to complete the process.
    It's possible that you may get a different value after executing the `system.time`
    method even if you use the same dataset. It depends a lot on how busy your CPU
    was at the time of running the method. However, we should read the output of the
    `system.time` method relative to the comparison we are carrying out and not relative
    to the absolute values.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的输出中，`user`时间是当前R会话花费的时间，而`system`时间是操作系统完成该过程花费的时间。即使使用相同的数据集，执行`system.time`方法后也可能得到不同的值。这很大程度上取决于在运行方法时CPU有多忙。然而，我们应该将`system.time`方法的输出相对于我们进行的比较来读取，而不是相对于绝对值。 '
- en: When the size of the dataset is too large, we have too many intermediate operations
    to get to the final output. However, keep in mind that `data.table` is not the
    magic wand that allows us to deal with a dataset of any size in R. The size of
    RAM still plays a significant role, and `data.table` is no substitute for distributed
    and parallel processing big data systems. However, even for the smaller dataset,
    the usage of `data.table` has shown much better performance than `data.frames`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据集的大小太大时，我们有很多中间操作要完成最终输出。然而，请记住，`data.table`并不是一根魔杖，它不能让我们在R中处理任何大小的数据集。RAM的大小仍然起着重要作用，`data.table`不能替代分布式和并行处理大数据系统。然而，即使是对于较小的数据集，`data.table`的使用也显示出比`data.frames`更好的性能。
- en: Data Processing and Transformation
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据处理和转换
- en: So far, we have seen different ways to read and store data. Now, let's focus
    on the kind of data processing and transformation required to perform data analysis
    and draw insights or build models. Data in its raw form is hardly of any use,
    so it becomes essential to process it to make it suitable for any useful purpose.
    This section focuses on many methods in R that have widespread usage during data
    analysis.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了不同的读取和存储数据的方法。现在，让我们关注进行数据分析、提取见解或构建模型所需的数据处理和转换。原始数据几乎没有任何用途，因此将其处理成适合任何有用目的变得至关重要。本节重点介绍了R在数据分析中广泛使用的方法。
- en: cbind
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: cbind
- en: As the name suggests, it combines two or more vector, matrix, DataFrame, or
    table by column. `cbind` is useful when we have more than one vector, matrix,
    or DataFrame that need to be combined into one for analysis or visualization.
    The output of `cbind` varies based on the input data. The following exercise provides
    a few examples of `cbind`, which combines two vectors.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，它通过列组合两个或多个向量、矩阵、DataFrame或表。当我们需要将多个向量、矩阵或DataFrame组合成一个进行分析或可视化时，`cbind`非常有用。`cbind`的输出取决于输入数据。以下练习提供了几个`cbind`的例子，它结合了两个向量。
- en: 'Exercise 9: Exploring the cbind Function'
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习9：探索cbind函数
- en: In this exercise, we will implement the `cbind` function to combine two DataFrame
    objects.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现`cbind`函数以组合两个DataFrame对象。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'Generate 16 random numbers drawn from a binomial distribution with parameter
    size equal to `100` and probability of success equal to `0.4`:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成16个来自参数大小等于`100`和成功概率等于`0.4`的二项分布的随机数：
- en: '[PRE65]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, print the `r_numbers` values using the following command:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令打印`r_numbers`值：
- en: '[PRE66]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is as follows:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE67]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Select any 16 alphabets from English `LETTERS` without repetition:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从英语`LETTERS`中选择任意16个字母，不重复：
- en: '[PRE68]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, print the `r_characters` values using the following command:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令打印`r_characters`值：
- en: '[PRE69]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The output is as follows:'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE70]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Combine `r_numbers` and `r_characters` using `cbind`:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cbind`组合`r_numbers`和`r_characters`：
- en: '[PRE71]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output is as follows:'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE72]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Print the class (type of data structure) we obtain after using `cbind`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印使用`cbind`后获得的类（数据结构类型）：
- en: '[PRE73]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output is as follows:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE74]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Observe a warning message in the output of `cbind` in the 5th step of this
    exercise:'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 观察到在练习的第5步中`cbind`输出的警告信息：
- en: '[PRE75]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The error means that the lengths of `r_numbers` and `r_characters` are not same
    (16 and 18, respectively). Note that the `cbind()` method, unlike `as.data.frame()`,
    doesn't throw an error. Instead, it automatically performs what is known as `r_numbers`
    `38` and `48` are recycled from the top to fill the 17th and 18th index.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误意味着`r_numbers`和`r_characters`的长度不相同（分别是16和18）。请注意，与`as.data.frame()`不同，`cbind()`方法不会抛出错误。相反，它会自动执行所谓的`r_numbers`
    `38`和`48`从顶部回收以填充第17和第18个索引。
- en: 'Consider that we write the following command instead:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们编写以下命令而不是：
- en: '[PRE76]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'It will now throw an error as we had shown earlier in the DataFrame section:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在会抛出一个错误，正如我们在数据框部分之前所展示的：
- en: '[PRE77]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: One needs to be careful by always checking for the dimensions and the class
    of data. Otherwise, it may lead to unwanted results. When we give two vectors,
    it creates a matrix by default on doing a `cbind`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 需要始终检查维度和数据类型，否则可能会导致不希望的结果。当我们给出两个向量时，通过`cbind`默认创建一个矩阵。
- en: Note
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Since we are not setting any seed value, the output of sample and `rbinom` will
    differ in each execution of the code.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有设置任何种子值，因此每次执行代码时，样本和`rbinom`的输出都会不同。
- en: rbind
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rbind
- en: '`rbind` is like `cbind`, but it combines by row instead of column. For `rbind`
    to work, the number of columns should be equal in both the DataFrames. It is useful
    in cases when we want to append an additional set of observations with an existing
    dataset where all the columns of the original dataset are the same and are in
    the same order. Let''s explore `rbind` in the following exercise.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`rbind`类似于`cbind`，但它通过行而不是列进行组合。为了使`rbind`工作，两个数据框中的列数应该相等。当我们在具有相同列的原始数据集中附加额外的观测值时，它很有用，其中原始数据集的所有列都是相同的，并且顺序相同。让我们在以下练习中探索`rbind`。'
- en: 'Exercise 10: Exploring the rbind Function'
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习10：探索`rbind`函数
- en: In this exercise, we will combine two DataFrames using the `rbind` function.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`rbind`函数组合两个数据框。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成练习：
- en: 'Generate 16 random numbers drawn from a binomial distribution with parameter
    size equal to `100` and probability of success equal to 0.4:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成16个来自二项分布的随机数，参数大小等于`100`，成功概率等于0.4：
- en: '[PRE78]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Next, print the `r_numbers` values:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打印`r_numbers`的值：
- en: '[PRE79]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The output is as follows:'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE80]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Select any 16 alphabets from English `LETTERS` without repetition:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从英语`LETTERS`中选择任何16个字母，不重复：
- en: '[PRE81]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, print the `r_characters` using the following command:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令打印`r_characters`：
- en: '[PRE82]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output is as follows:'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE83]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Finally, use the `rbind` method to print the combined value of `r_numbers`
    and `r_characters`:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`rbind`方法打印`r_numbers`和`r_characters`的合并值：
- en: '[PRE84]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output is as follows:'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE85]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: From the last step, observe that the `rbind` function concatenates (binds) the
    `r_numbers` and `r_characters` as two rows of data, unlike `cbind`, where it was
    stacked in two columns. Except for the output, all the other rules of `cbind`
    apply to `rbind` as well.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 从最后一步可以看出，`rbind`函数将`r_numbers`和`r_characters`作为两行数据连接（绑定），这与`cbind`不同，在`cbind`中它是堆叠在两列中的。除了输出之外，`cbind`的所有其他规则也适用于`rbind`。
- en: The merge Function
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并函数
- en: The `merge()` function in R is particularly useful when there is more than one
    DataFrame to join using a common column (what we call a **primary key** in the
    database world). Merge has two different implementations for the DataFrame and
    data table, which behave mostly in the same way.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: R中的`merge()`函数在需要使用公共列（在数据库世界中我们称之为**主键**）连接多个数据框时特别有用。`merge()`函数对数据框和数据表有两种不同的实现方式，它们的行为基本上是相同的。
- en: 'Exercise 11: Exploring the merge Function'
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习11：探索合并函数
- en: In this exercise, we will generate two DataFrames, that is, `df_one` and `df_two`,
    such that the `r_numbers` column uniquely identifies each row in each of the DataFrame.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将生成两个数据框，即`df_one`和`df_two`，使得`r_numbers`列在每个数据框中唯一标识每一行。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成练习：
- en: '**First DataFrame**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一个数据框**'
- en: 'Use the `set.seed()` method to ensure that the same random numbers are generated
    every time the code is run:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`set.seed()`方法确保每次运行代码时生成相同的随机数：
- en: '[PRE86]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, generate any 16 random numbers between 1 to 30 without repetition:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，生成1到30之间的任意16个不重复的随机数：
- en: '[PRE87]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Generate any 16 characters from the English alphabet with repetition:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从英文字母表中生成任意16个字符，允许重复：
- en: '[PRE88]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Combine `r_numbers` and `r_characters` into one DataFrame named `df_one`:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`r_numbers`和`r_characters`合并到一个名为`df_one`的DataFrame中：
- en: '[PRE89]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The output is as follows:'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE90]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '**Second DataFrame**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二个DataFrame**'
- en: 'Use the `set.seed()` method for preserving the same random numbers over multiple
    runs:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`set.seed()`方法来保留多次运行中相同的随机数：
- en: '[PRE91]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, generate any 16 random numbers between 1 to 30 without repetition:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，生成1到30之间的任意16个不重复的随机数：
- en: '[PRE92]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now, generate any 16 characters from the English alphabet with repetition:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从英文字母表中生成任意16个字符，允许重复：
- en: '[PRE93]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Combine `r_numbers` and `r_characters` into one DataFrame named `df_two`:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`r_numbers`和`r_characters`合并到一个名为`df_two`的DataFrame中：
- en: '[PRE94]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output is as follows:'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE95]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Once we create the `df_one` and `df_two` DataFrames using the `cbind()` function,
    we are ready to perform some merge (will use the word JOIN, which means the same
    as `merge()`).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用`cbind()`函数创建了`df_one`和`df_two`DataFrame，我们就可以执行一些合并操作（将使用JOIN这个词，它与`merge()`的意思相同）。
- en: Now, let's see how different type of joins give different results.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看不同类型的连接会产生不同的结果。
- en: In the world of databases, JOINs are used to combine two or more than two tables
    using a common primary key. In databases, we use Structured Query Language (SQL)
    to perform the JOINs. In R, the `merge()` function helps us with the same functionality
    as SQL offers in databases. Also, instead of tables, we have DataFrames here,
    which is again a table with rows and columns of data.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库的世界中，JOIN操作用于通过公共主键结合两个或两个以上的表。在数据库中，我们使用结构化查询语言（SQL）来执行JOIN操作。在R中，`merge()`函数帮助我们实现与SQL在数据库中提供的相同功能。此外，在这里我们不是使用表，而是使用DataFrame，它也是一个具有行和列数据的表。
- en: Inner Join
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内连接
- en: 'In *Exercise 11*, *Exploring the merge Function*, we created two DataFrames:
    `df_one` and `df_ two`. We will now join the two DataFrames using `26` (row number
    `7`) in the `r_numbers` column is common between the two DataFrames, where the
    corresponding character in the `r_characters` column is `R` in `df_one` and character
    `O` in `df_two`. In the output, `X` corresponds to the `df_one` DataFrame and
    `Y` correspond to the `df_two` DataFrame.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习11*，*探索merge函数*中，我们创建了两个DataFrame：`df_one`和`df_two`。现在，我们将使用`r_numbers`列中两个DataFrame共有的`26`（行号`7`）来连接这两个DataFrame，其中`r_characters`列中相应的字符在`df_one`中是`R`，在`df_two`中是`O`。在输出中，`X`对应于`df_one`DataFrame，`Y`对应于`df_two`DataFrame。
- en: 'To merge the `df_one` and `df_two` DataFrames using the `r_numbers` column,
    use the following command:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`r_numbers`列将`df_one`和`df_two`DataFrame合并，使用以下命令：
- en: '[PRE96]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Left Join
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 左连接
- en: '`df_one` in the `r_numbers` column and adds `<NA>` as a value wherever the
    corresponding value in `df_two` is not found. For example, for `r_number = 2`,
    there is no value in `df_two`, whereas for `r_number = 26`, values in `df_one`
    and `df_two`, for the `r_characters` column is `R` and `O`, respectively.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在`df_one`的`r_numbers`列中添加`<NA>`作为值，无论在`df_two`中找不到相应的值。例如，对于`r_number = 2`，在`df_two`中没有值，而对于`r_number
    = 26`，`df_one`和`df_two`中`r_characters`列的值分别是`R`和`O`。
- en: 'To merge the `df_one` and `df_two` DataFrames using the `r_numbers` column,
    use the following command:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`r_numbers`列将`df_one`和`df_two`DataFrame合并，使用以下命令：
- en: '[PRE97]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Right Join
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 右连接
- en: '`r_character` columns of `df_one` are `<NA>` wherever a match is not found.
    Again, `r_numbers = 26` is the only match.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`df_one`的`r_character`列在找不到匹配项的地方是`<NA>`。同样，`r_numbers = 26`是唯一的匹配项。'
- en: 'To merge the `df_one` and `df_two` DataFrames using the `r_numbers` column,
    use the following command:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`r_numbers`列将`df_one`和`df_two`DataFrame合并，使用以下命令：
- en: '[PRE98]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Full Join
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全外连接
- en: Unlike Left and Right Join, `r_numbers` column from both the DataFrames and
    adds `<NA>` in the `r_characters` column from the respective DataFrame. Observe
    that only the `r_number = 26` row has values from both the DataFrame.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 与左连接和右连接不同，`r_numbers`列从两个DataFrame中添加，并在`r_characters`列的相应DataFrame中添加`<NA>`。观察发现，只有`r_number
    = 26`这一行在两个DataFrame中都有值。
- en: 'To merge the `df_one` and `df_two` DataFrames using the `r_numbers` column,
    use the following command:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`r_numbers`列将`df_one`和`df_two`DataFrame合并，使用以下命令：
- en: '[PRE99]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The reshape Function
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`reshape`函数'
- en: Data is known to be in a `reshape` function is used often to convert between
    wide and long formats for a variety of operations to make the data useful for
    computation or analysis. In many visualizations, we use `reshape()` to convert
    wide format to long and vice versa.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通常在`reshape`函数中使用，经常用于在宽格式和长格式之间转换，以便进行各种操作，使数据对计算或分析有用。在许多可视化中，我们使用`reshape()`将宽格式转换为长格式，反之亦然。
- en: We will use the Iris dataset. This dataset contains variables named `Sepal.Length`,
    `Sepal.Width`, `Petal.Length`, and `Petal.Width`, whose measurements are given
    in centimeters, for 50 flowers from each of 3 species of Iris, namely *setosa*,
    *versicolor*, and *virginica*.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Iris数据集。这个数据集包含名为`Sepal.Length`、`Sepal.Width`、`Petal.Length`和`Petal.Width`的变量，这些变量的测量值以厘米为单位，来自3种鸢尾花物种的每种50朵花，即*setosa*、*versicolor*和*virginica*。
- en: 'Exercise 12: Exploring the reshape Function'
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习12：探索重塑函数
- en: In this exercise, we will explore the reshape function.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将探索`reshape`函数。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'First, print the top five rows of the iris dataset using the following command:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令打印iris数据集的前五行：
- en: '[PRE100]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The output of the previous command is as follows:'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一条命令的输出如下：
- en: '[PRE101]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now, create a variable called `Type` based on the following condition. When
    `Sepal.Width > 2` and `Sepal Width <= 3`, we will assign `TYPE 1` or `TYPE 2`.
    The type column is for demo purpose only and has no particular logic:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，根据以下条件创建一个名为`Type`的变量。当`Sepal.Width > 2`且`Sepal Width <= 3`时，我们将分配`TYPE 1`或`TYPE
    2`。类型列仅用于演示目的，没有特定的逻辑：
- en: '[PRE102]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Store the `Type`, `Sepal.Width`, and `Species` columns in the `df_iris` DataFrame:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Type`、`Sepal.Width`和`Species`列存储在`df_iris`数据框中：
- en: '[PRE103]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Next, reshape `df_iris` into wide DataFrame using the following `reshape` command:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下`reshape`命令将`df_iris`重塑为宽数据框：
- en: '[PRE104]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The output is as follows:'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE105]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You will get a warning while running the `reshape` command, saying as follows:'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当运行`reshape`命令时，你会得到一个警告，如下所示：
- en: '[PRE106]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This warning means there were multiple values for `Type 1` and `Type 2` for
    the three species, so the reshape has picked the first occurrence of each of the
    species. In this case, the `1`, `51`, and `101` row numbers. We will now see how
    we could handle this transformation better in the `aggregate` function.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警告意味着三种物种的`Type 1`和`Type 2`有多个值，所以重塑选择了每种物种的第一个出现。在这种情况下，行号`1`、`51`和`101`。我们现在将看到如何在`aggregate`函数中更好地处理这种转换。
- en: The aggregate Function
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合函数
- en: Aggregation is a useful method for computing statistics such as count, averages,
    standard deviations, and quartiles, and it also allows for writing a custom function.
    In the following code, the formula (formula is a name of the data structure in
    R, not a mathematical equation) for each Iris species computes the mean of the
    numeric measures sepal and petal width and length. The first of the aggregate
    function argument is a formula that takes species and all the other measurements
    to compute the mean from all the observations.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是一种有用的计算统计方法，如计数、平均值、标准差和四分位数，它还允许编写自定义函数。在下面的代码中，每个鸢尾花物种的公式（在R中，公式是数据结构的名字，而不是数学方程）计算了萼片和花瓣宽度和长度的数值测量值的平均值。聚合函数的第一个参数是一个公式，它接受物种和所有其他测量值，从所有观测值中计算平均值。
- en: '[PRE107]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The output of the previous command is as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 上一条命令的输出如下：
- en: '[PRE108]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The Apply Family of Functions
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`apply`函数族'
- en: If one has to debate on a few powerful features of R programming, the `apply`
    family of functions, would find a mention. It is used commonly to avoid using
    looping structures such as `for` and `while` even though they are available in
    R.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须讨论R编程的几个强大功能，`apply`函数族将会被提及。它通常被用来避免使用R中可用的循环结构，如`for`和`while`。
- en: First, it's slow to run `for` loops in R and second, the implementation of the
    `apply` functions in R is based on efficient programming languages such as C/C++,
    which makes it extremely fast to loop.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在R中运行`for`循环比较慢，其次，R中`apply`函数的实现基于高效的编程语言，如C/C++，这使得循环非常快。
- en: 'There are many functions in the `apply` family. Depending on the structure
    of the input and output required, we select the appropriate function:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`函数族中有许多函数。根据所需的输入和输出结构，我们选择合适的函数：'
- en: '`apply()`'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply()`'
- en: '`lapply()`'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lapply()`'
- en: '`sapply()`'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sapply()`'
- en: '`vapply()`'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vapply()`'
- en: '`mapply()`'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapply()`'
- en: '`rapply()`'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rapply()`'
- en: '`tapply()`'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tapply()`'
- en: We will discuss a few in this section.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节讨论几个。
- en: The apply Function
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`apply`函数'
- en: The `apply()` function takes an array, including a matrix, as input and returns
    a vector, array, or list of values obtained by applying a function to margins
    of an array or matrix.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply()` 函数接受一个数组，包括一个矩阵，作为输入，并返回通过将一个函数应用于数组的边缘或矩阵的边缘得到的值向量、数组或列表。'
- en: 'Exercise 13: Implementing the apply Function'
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 13：实现 apply 函数
- en: In this exercise, we will count the number of vowels in each column of a 100
    x 100 matrix of random letters from the English alphabet. The `MARGIN = 1` function
    will scan each row, and `MARGIN = 2` will specify the column. The same function
    will the count vowels in each row.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将计算从英语字母表中随机生成的 100 x 100 矩阵中每一列的元音字母数量。`MARGIN = 1` 函数将扫描每一行，而 `MARGIN
    = 2` 将指定列。相同的函数将计算每一行的元音字母数量。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'Create a 100 x 100 matrix of random letters (`ncol` is the number of columns
    and `nrow` is the number of rows) using the following command:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个 100 x 100 的随机字母矩阵（`ncol` 是列数，`nrow` 是行数）：
- en: '[PRE109]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now, create a function named `c_vowel` to count the number of vowels in a given
    array:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `c_vowel` 的函数来计算给定数组中的元音字母数量：
- en: '[PRE110]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Next, use the `apply` function to run through each column of the matrix, and
    use the `c_vowel` function as illustrated here:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `apply` 函数遍历矩阵的每一列，并使用此处所示的 `c_vowel` 函数：
- en: '[PRE111]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The output is as follows:'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE112]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The lapply Function
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: lapply 函数
- en: The `lapply` function looks similar to `apply()`, with a difference that it
    takes input as a *list* and returns a *list* as output. After rewriting our previous
    example in the following exercise, the output of class function shows that the
    output is a list.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`lapply` 函数看起来与 `apply()` 函数相似，不同之处在于它以 *列表* 作为输入并返回 *列表* 作为输出。在以下练习中重写我们之前的示例后，类函数的输出显示输出是一个列表。'
- en: 'Exercise 14: Implementing the lapply Function'
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 14：实现 lapply 函数
- en: In this exercise, we will take a list of vectors and count the number of vowels.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将取一个向量列表并计算元音字母的数量。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'Create a list with two vector of random letters, each of size 100:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含两个随机字母向量的列表，每个向量的大小为 100：
- en: '[PRE113]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Use the `lapply` function to run through on list `a` and `b`, and the `c_vowel`
    function to count the number of vowels from the list:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `lapply` 函数遍历列表 `a` 和 `b`，并使用 `c_vowel` 函数从列表中计算元音字母的数量：
- en: '[PRE114]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The output is as follows:'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE115]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Check the class (type) of the output. The `class()` function provides the type
    of data structure:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查输出的类（类型）。`class()` 函数提供数据结构的类型：
- en: '[PRE116]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The output is as follows:'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE117]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The sapply Function
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sapply 函数
- en: 'The `sapply` function is just a wrapper on the `lapply` function, where the
    output is a vector or matrix instead of a list. In the following code, observe
    the type of the output after applying `sapply` difference. The output returns
    a vector of integers, as we can check with the `class()` function:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`sapply` 函数是 `lapply` 函数的一个包装器，其中输出是一个向量或矩阵而不是列表。在以下代码中，观察应用 `sapply` 差异后的输出类型。输出返回一个整数向量，我们可以通过
    `class()` 函数来检查：'
- en: '[PRE118]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'To print the class of the output, use the following command:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印输出类的信息，请使用以下命令：
- en: '[PRE119]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The output of the previous command is as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 之前命令的输出如下：
- en: '[PRE120]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The tapply Function
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tapply 函数
- en: 'Apply a function to each cell of a ragged array, that is, to each (non-empty)
    group of values given by a unique combination of the levels of certain factors.
    The `tapply` function is quite useful when it comes to working on a subset level
    of data. For example, in our `aggregate` function, if we were to get an aggregate
    like standard deviation for the type of Iris species, we could use `tapply`. The
    following code shows how to use the `tapply` function:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个函数应用于稀疏数组的每个单元格，即应用于由某些因素级别的唯一组合给出的每个（非空）值组。当涉及到在数据子集级别工作时，`tapply` 函数非常有用。例如，在我们的
    `aggregate` 函数中，如果我们想要获取 Iris 物种类型的标准差聚合，我们可以使用 `tapply`。以下代码显示了如何使用 `tapply`
    函数：
- en: 'First, calculate the standard deviation of sepal length for each Iris species:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算每个 Iris 物种花瓣长度的标准差：
- en: '[PRE121]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The output is as follows:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE122]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Next, calculate the standard deviation of sepal width for each of the Iris
    species:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，计算每个 Iris 物种花瓣宽度的标准差：
- en: '[PRE123]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The output of the previous command is as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 之前命令的输出如下：
- en: '[PRE124]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Now, let's explore some popular and useful R packages that might be of value
    while building complex data processing methods, machine learning models, or data
    visualization.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索一些在构建复杂数据处理方法、机器学习模型或数据可视化时可能很有价值的流行且有用的R包。
- en: Useful Packages
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的包
- en: While there are more than thirteen thousand packages in the CRAN repository,
    some of the packages have a unique place and utility for some major functionality.
    So far, we saw many examples of data manipulations such as join, aggregate, reshaping,
    and sub-setting. The R packages we will discuss next will provide a plethora of
    functions, providing a wide range of data processing and transformation capabilities.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管CRAN仓库中有超过十三万个包，但其中一些包在某些主要功能方面具有独特的位置和用途。到目前为止，我们看到了许多数据操作示例，如连接、聚合、重塑和子集。接下来我们将讨论的R包将提供大量函数，提供广泛的数据处理和转换能力。
- en: The dplyr Package
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: dplyr 包
- en: The `dplyr` package helps in the most common data manipulation challenges through
    five different methods, namely, `mutate()`, `select()`, `filter()`, `summarise()`,
    and `arrange()`. Let's revisit our direct marketing campaigns (phone calls) of
    a Portuguese banking institution dataset from UCI Machine Learning Repository
    to test out all these methods.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr`包通过五种不同的方法帮助解决最常见的数据操作挑战，即`mutate()`、`select()`、`filter()`、`summarise()`和`arrange()`。让我们回顾一下来自UCI机器学习仓库的葡萄牙银行机构的直接营销活动（电话）数据集，以测试所有这些方法。'
- en: The `%>%` symbol in the following exercise is called **chain operator**. The
    output of the one operation is sent to the next one without explicitly creating
    a new variable. Such a chaining operation is storage efficient and makes the readability
    of the code easy.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中的`%>%`符号被称为**链操作符**。一个操作的结果被发送到下一个操作，而不需要显式创建一个新变量。这种链式操作是存储高效的，并且使代码的可读性变得容易。
- en: 'Exercise 15: Implementing the dplyr Package'
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习15：实现dplyr包
- en: In this exercise, we are interested in knowing the average bank balance of people
    doing blue-collar jobs by their marital status. Use the functions from the `dplyr`
    package to get the answer.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们感兴趣的是了解从事蓝领工作的人的平均银行余额，根据他们的婚姻状况。使用`dplyr`包中的函数来获取答案。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'Import the `bank-full.csv` file into the `df_bank_detail` object using the
    `read.csv()` function:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`read.csv()`函数将`bank-full.csv`文件导入到`df_bank_detail`对象中：
- en: '[PRE125]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, load the `dplyr` library:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令加载`dplyr`库：
- en: '[PRE126]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Select (filter) all the observations where the `job` column contains the value
    `blue-collar` and then group by the martial status to generate the summary statistic,
    `mean`:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择（过滤）所有`job`列包含值`blue-collar`的观测值，然后按婚姻状况分组生成汇总统计量，即`mean`：
- en: '[PRE127]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The output is as follows:'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE128]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Let''s find out the bank balance of customers with secondary education and
    default as `yes`:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们找出具有中等教育水平和默认值为`yes`的客户的银行余额：
- en: '[PRE129]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The output is as follows:'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE130]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Much of complex analysis is done with ease. Note that the `mutate()` method
    helps in creating custom columns with certain calculation or logic.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 许多复杂分析都可以轻松完成。请注意，`mutate()`方法有助于创建具有特定计算或逻辑的自定义列。
- en: The tidyr Package
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tidyr 包
- en: The `tidyr` package has three essential functions—`gather()`, `separate()`,
    and `spread()`—for cleaning messy data.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`tidyr`包有三个基本函数——`gather()`、`separate()`和`spread()`——用于清理混乱的数据。'
- en: The `gather()` function converts **wide** DataFrame to long by taking multiple
    columns and gathering them into key-value pairs.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`gather()`函数通过将多个列取出来并将它们聚合成键值对，将**宽**DataFrame转换为长DataFrame。'
- en: 'Exercise 16: Implementing the tidyr Package'
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习16：实现tidyr包
- en: In this exercise, we will explore the `tidyr` package and the functions associated
    with it.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将探索`tidyr`包及其相关函数。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'Import the `tidyr` library using the following command:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令导入`tidyr`库：
- en: '[PRE131]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Next, set the `seed` to 100 using the following command:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令将`seed`设置为100：
- en: '[PRE132]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Create an `r_name` object and store the 5 person names in it:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`r_name`对象，并将5个人名存储在其中：
- en: '[PRE133]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'For the `r_food_A` object, generate 16 random numbers between 1 to 30 without
    repetition:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`r_food_A`对象，生成1到30之间的16个不重复的随机数：
- en: '[PRE134]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Similarly, for the `r_food_B` object, generate 16 random numbers between 1
    to 30 without repetition:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，对于`r_food_B`对象，生成1到30之间的16个不重复的随机数：
- en: '[PRE135]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Create and print the data from the DataFrame using the following command:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建并打印DataFrame中的数据：
- en: '[PRE136]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The output is as follows:'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE137]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Use the `gather()` method from the `tidyr` package:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`tidyr`包中的`gather()`方法：
- en: '[PRE138]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The output is as follows:'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE139]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The `spread()` function works the other way around of `gather()`, that is,
    it takes a long format and converts it into wide format:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`spread()`函数与`gather()`函数相反，即它将长格式转换为宽格式：'
- en: '[PRE140]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The `separate()` function is useful in places where columns are a combination
    of values and is used for making it a key column for other purposes. We can separate
    out the key if it has a common separator character:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`separate()`函数在列是值组合的地方很有用，用于将其作为其他目的的关键列。如果它有一个共同的分隔符字符，我们可以分离出关键部分：'
- en: '[PRE141]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'The output is as follows:'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE142]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Activity 3: Create a DataFrame with Five Summary Statistics for All Numeric
    Variables from Bank Data Using dplyr and tidyr'
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动三：使用dplyr和tidyr从银行数据创建包含所有数值变量的五个汇总统计的DataFrame
- en: This activity will make you accustomed to selecting all numeric fields from
    the bank data and produce the summary statistics on numeric variables.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动将使你习惯于从银行数据中选择所有数值字段，并对数值变量生成汇总统计。
- en: 'Perform the following steps to complete the activity:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成活动：
- en: Extract all numeric variables from bank data using `select()`.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`select()`从银行数据中提取所有数值变量。
- en: Using the `summarise_all()` method, compute min, 1st quartile, 3rd quartile,
    median, mean, max, and standard deviation.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`summarise_all()`方法，计算最小值、第一四分位数、第三四分位数、中位数、平均值、最大值和标准差。
- en: Note
  id: totrans-524
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about the `summarise_all` function at [https://www.rdocumentation.org/packages/dplyr/versions/0.5.0/topics/summarise_all](https://www.rdocumentation.org/packages/dplyr/versions/0.5.0/topics/summarise_all).
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[https://www.rdocumentation.org/packages/dplyr/versions/0.5.0/topics/summarise_all](https://www.rdocumentation.org/packages/dplyr/versions/0.5.0/topics/summarise_all)了解更多关于`summarise_all`函数的信息。
- en: Store the result in a DataFrame of wide format named `df_wide`.
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果存储在名为`df_wide`的宽格式DataFrame中。
- en: Now, to convert wide format to deep, use the gather, separate, and spread functions
    of the `tidyr` package.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要将宽格式转换为深格式，请使用`tidyr`包中的`gather`、`separate`和`spread`函数。
- en: The final output should have one row for each variable and one column each of
    min, 1st quartile, 3rd quartile, median, mean, max, and standard deviation.
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终输出应该为每个变量一行，以及最小值、第一四分位数、第三四分位数、中位数、平均值、最大值和标准差的每一列。
- en: 'Once you complete the activity, you should have the final output as follows:'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦完成活动，你应该得到以下最终输出：
- en: '[PRE143]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Note
  id: totrans-531
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 440.
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第440页找到。
- en: The plyr Package
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: plyr包
- en: 'What we saw with the `apply` functions could be done through the `plyr` package
    on a much bigger scale and robustness. The `plyr` package provides the ability
    to split the dataset into subsets, apply a common function to each subset, and
    combine the results into a single output. The advantage of using `plyr` over the
    `apply` function is features like the following:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`apply`函数看到的情况可以通过`plyr`包在更大规模和稳健性上完成。`plyr`包提供了将数据集拆分为子集、对每个子集应用公共函数以及将结果合并为单个输出的能力。使用`plyr`而不是`apply`函数的优势包括以下特点：
- en: Speed of code execution
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码执行速度
- en: Parallelization of processing using `foreach` loop
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`foreach`循环进行处理的并行化。
- en: Support for list, DataFrame, and matrices
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持列表、DataFrame和矩阵。
- en: Better debugging of errors
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的错误调试
- en: All the function names in `plyr` are clearly defined based on input and output.
    For example, if an input is a DataFrame and output is list, the function name
    would be `dlply`.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`plyr`包中所有的函数名都是根据输入和输出明确定义的。例如，如果输入是DataFrame，输出是列表，则函数名将是`dlply`。'
- en: 'The following figure from the *The Split-Apply-Combine Strategy for Data Analysis*
    paper displays all the different `plyr` functions:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 下图来自《数据分析的Split-Apply-Combine策略》论文，显示了所有不同的`plyr`函数：
- en: '![Figure 1.7: Functions in the plyr packages'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.7：plyr包中的函数'
- en: '](img/C12624_01_07.jpg)'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C12624_01_07.jpg)'
- en: 'Figure 1.7: Functions in the plyr packages'
  id: totrans-543
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.7：plyr包中的函数
- en: The `_` means the output will be discarded.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`_`表示输出将被丢弃。'
- en: 'Exercise 17: Exploring the plyr Package'
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习17：探索plyr包
- en: In this exercise, we will see how split-apply-combine makes things simple with
    the flexibility of controlling the input and output.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到如何通过控制输入和输出的灵活性，split-apply-combine方法使事情变得简单。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'Load the `plyr` package using the following command:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令加载 `plyr` 包：
- en: '[PRE144]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Next, use the slightly tweaked version of the `c_vowel` function we created
    in the earlier example in *Exercise 13*, *Exploring the apply Function*:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用我们在早期示例 *练习 13*，*探索 apply 函数* 中创建的 `c_vowel` 函数的略微修改版本：
- en: '[PRE145]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Set the `seed` to `101`:'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `seed` 设置为 `101`：
- en: '[PRE146]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Store the value in the `r_characters` object:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值存储在 `r_characters` 对象中：
- en: '[PRE147]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Note
  id: totrans-556
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`Input = DataFrame to output = list`'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`输入 = DataFrame 输出 = 列表`'
- en: 'Use the `dlply()` function and print the split in the row format:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dlply()` 函数并按行格式打印拆分：
- en: '[PRE148]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The output is as follows:'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE149]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Note
  id: totrans-562
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`Input = data.frame to output = array`'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`输入 = data.frame 输出 = 数组`'
- en: 'We can simply replace dlply with the `daply()` function and print the split
    in the column format as an array:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以简单地用 `daply()` 函数替换 dlply，并按列格式作为数组打印拆分：
- en: '[PRE150]'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The output is as follows:'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE151]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Note
  id: totrans-568
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`Input = DataFrame to output = DataFrame`'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`输入 = DataFrame 输出 = DataFrame`'
- en: 'Use the `ddply()` function and print the split:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ddply()` 函数并打印拆分：
- en: '[PRE152]'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The output is as follows:'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE153]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: In steps 5, 6, and 7, observe how we created a list, array, and data as an output
    for DataFrame input. All we must do is use a different function from `plyr`. This
    makes it easy to type cast between many possible combinations.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 5、6 和 7 中，观察我们如何创建了一个列表、数组以及作为 DataFrame 输出的数据。我们只需使用 `plyr` 的不同函数即可。这使得在许多可能的组合之间进行类型转换变得容易。
- en: The caret Package
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`caret` 包'
- en: 'The `caret` package is particularly useful for building a predictive model,
    and it provides a structure for seamlessly following the entire process of building
    a predictive model. Starting from splitting data to training and testing dataset
    and variable importance estimation, we will extensively use the `caret` package
    in our chapters on regression and classification. In summary, `caret` provides
    tools for:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '`caret` 包特别适用于构建预测模型，它提供了一个无缝地跟随整个预测模型构建过程的框架。从数据拆分到训练和测试数据集以及变量重要性估计，我们将在回归和分类章节中广泛使用
    `caret` 包。总之，`caret` 提供了以下工具：'
- en: Data splitting
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据拆分
- en: Pre-processing
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理
- en: Feature selection
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征选择
- en: Model training
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型训练
- en: Model tuning using resampling
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用重采样进行模型调优
- en: Variable importance estimation
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量重要性估计
- en: We will revisit the caret package with examples in *Chapter 4*, *Regression*,
    and *Chapter 5*, *Classification*.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *第 4 章*，*回归* 和 *第 5 章*，*分类* 中通过示例重新访问 `caret` 包。
- en: Data Visualization
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据可视化
- en: An essential part of what we call `ggplot2`, a powerful package in R. Just like
    `dplyr` and `plyr`, `ggplot2` is built on the **Grammar of Graphics**, which is
    a tool that enables us to describe the components of a graphic concisely.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的 `ggplot2` 是 R 中一个强大的包的一个基本部分。就像 `dplyr` 和 `plyr` 一样，`ggplot2` 建立在 **图形语法**
    的基础上，这是一种使我们能够简洁地描述图形组件的工具。
- en: Note
  id: totrans-586
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Good grammar will allow us to gain insight into the composition of complicated
    graphics and reveal unexpected connections between seemingly different graphics.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的语法将使我们能够深入了解复杂图形的组成，并揭示看似不同图形之间意想不到的联系。
- en: (Cox 1978) [Cox, D. R. (1978), "Some Remarks on the Role in Statistics of Graphical
    Methods," Applied Statistics, 27 (1), 4–9\. [3,26].
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: (Cox 1978) [Cox, D. R. (1978), "Some Remarks on the Role in Statistics of Graphical
    Methods," Applied Statistics, 27 (1), 4–9\. [3,26].
- en: Scatterplot
  id: totrans-589
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 散点图
- en: A scatterplot is a type of plot or mathematical diagram using Cartesian coordinates
    to display values for typically two variables for a set of data. If the points
    are color-coded, an additional variable can be displayed.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图是一种使用笛卡尔坐标系显示数据集中通常两个变量的值的一种图表或数学图。如果点被着色，则可以显示一个额外的变量。
- en: 'It is the most common type of chart and is extremely useful in spotting patterns
    in the data, especially between two variables. We will use our bank data again
    to do some EDA. Let''s use the Portuguese bank direct campaign dataset for the
    visualizations:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最常见的图表类型，在发现数据中的模式，尤其是在两个变量之间时非常有用。我们将再次使用我们的银行数据来进行一些 EDA。让我们使用葡萄牙银行直接营销活动数据集进行可视化：
- en: '[PRE154]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '`ggplot` works in a layered way of stacking different elements of the plot.
    In the following example of this section, in the first layer, we provide the data
    to the `ggplot()` method and then map it with aesthetic details like *x* and *y*-axis,
    in the example, the `age` and `balance` values, respectively. Finally, to be able
    to identify some reasoning associated with few high bank balances, we added a
    color based on the type of job.'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command to plot the scatterplot of age and balance:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '![Figure 1.8: Scatterplot of age and balance.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C12624_01_08.jpg)'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.8: Scatterplot of age and balance.'
  id: totrans-598
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From *Figure 1.8*, the distribution of bank balance with age looks much normal,
    with middle age showing a high bank balance whereas youngsters and old people
    are on the lower side of the spectrum.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, some outlier values seem to be coming from management and retired
    professionals.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: In data visualization, it's always tempting to see a graph and jump to a conclusion.
    A data visual is for consuming the data better and not for drawing causal inference.
    Usually, an interpretation by an analyst is always vetted by a business. Graphs
    that are aesthetically pleasing often tempt you to put it into presentation deck.
    So, next time a beautiful chart gets into your presentation deck, carefully analyze
    what you are going to say.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: Scatter Plot between Age and Balance split by Marital Status
  id: totrans-602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will draw three scatter plots in a single plot between age
    and balance split by marital status (one for each single, divorced, and married
    individuals).
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you could split the distribution by marital status. The patterns seem
    to be consistent among the single, married, and divorced individuals. We used
    a method called `facet_wrap()` as the third layer in `ggplot`. It takes a `marital`
    variable as a formula:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '![Figure 1.9: Scatter plot between age and balance split by marital status'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C12624_01_09.jpg)'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.9: Scatter plot between age and balance split by marital status'
  id: totrans-608
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Line Charts
  id: totrans-609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A line chart or line graph is a type of chart that displays information as a
    series of data points called **markers** connected by straight line segments.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '`ggplot` uses an elegant `geom()` method, which helps in quickly switching
    between two visual objects. In the previous example, we saw `geom_point()` for
    the scatterplot. In line charts, the observations are connected by a line in the
    order of the variable on the *x*-axis. The shaded area surrounding the line represents
    the *95%* confidence interval, that is, there is 95% confidence that the actual
    regression line lies within the shaded area. We will discuss more on this idea
    in *Chapter 4*, *Regression*.'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following plot, we show the line chart of age and bank balance for single,
    married, and divorced individuals. It is not clear whether there is some trend,
    but one can see the pattern among the three categories:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '![Figure 1.10: Line graph of age and balance'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C12624_01_10.jpg)'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.10: Line graph of age and balance'
  id: totrans-616
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.10：年龄和余额的折线图
- en: Histogram
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直方图
- en: A histogram is a visualization consisting of rectangles whose area is proportional
    to the frequency of a variable and whose width is equal to the class interval.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是由矩形组成的可视化，其面积与变量的频率成正比，其宽度等于组距。
- en: The height of the bar in a histogram represents the number of observations in
    each group. In the following example, we are counting the number of observations
    for each type of job and marital status. **y** is a binary variable checking whether
    the client subscribed a term deposit or not (**yes**, **no**) as a response to
    the campaign call.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 在直方图中，柱状的高度代表每个组中的观测值数量。在以下示例中，我们正在计算每种工作类型和婚姻状况的观测值数量。**y**是一个二进制变量，检查客户是否响应活动号召订阅了定期存款（**是**，**否**）。
- en: 'It looks like blue-collar individuals are responding to the campaign calls
    the least, and individuals in management jobs are subscribing to the term deposit
    the most:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来蓝领工人对活动号召的反应最少，而管理岗位的人对定期存款的订阅最多：
- en: '[PRE158]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '![Figure 1.11: Histogram of count and job'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.11：计数和工作的直方图'
- en: '](img/C12624_01_11.jpg)'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C12624_01_11.jpg)'
- en: 'Figure 1.11: Histogram of count and job'
  id: totrans-624
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.11：计数和工作的直方图
- en: Boxplot
  id: totrans-625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箱线图
- en: A boxplot is a standardized way of displaying the distribution of data based
    on a five number summary (minimum, first quartile (Q1), median, third quartile
    (Q3), and maximum). Probably, boxplot is the only chart that encapsulates much
    information in a beautiful looking representation compared to any other charts.
    Observe the summary of the `age` variable by each `job` type. The five summary
    statistics, that is, min, first quartile, median, mean, third quartile, and max,
    are described succinctly by a boxplot.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 箱线图是基于五个数值摘要（最小值、第一四分位数（Q1）、中位数、第三四分位数（Q3）和最大值）显示数据分布的一种标准化方式。箱线图可能是唯一一种与其他图表相比，在美观的表示中封装了更多信息图表。观察每个`job`类型对`age`变量的摘要。五个摘要统计量，即最小值、第一四分位数、中位数、均值、第三四分位数和最大值，通过箱线图简洁地描述。
- en: 'The 25th and 75th percentiles, in the first and third quartiles, are shown
    by lower and upper hinges, respectively. The upper whisper, which extends from
    the hinges to the maximum value, is within an IQR of 1.5 *, from the hinge. This
    is where the IQR is the inter-quartile range or distance between the two quartiles.
    This is similar in case of the lower hinge. All the points that are outside the
    hinges are called **outliers**:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 第一四分位数和第三四分位数中的第25百分位数和第75百分位数分别由下四分位数和上四分位数表示。上四分位数，即从四分位数延伸到最大值的范围，在1.5 *
    IQR（四分位距）内，这里的IQR是指四分位距，即两个四分位数之间的距离。下四分位数的情况类似。所有位于四分位数之外的数据点被称为**异常值**：
- en: '[PRE159]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The output is as follows:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE160]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'In the following boxplot, we are looking at the summary of age with respect
    to each job type. The size of the box that is set to `varwidth = TRUE` in `geom_boxplot`
    shows the number of observations in the particular job type. The wider the box,
    the larger the number of observations:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的箱线图中，我们正在查看每个工作类型的年龄摘要。在`geom_boxplot`中的`varwidth = TRUE`设置下，箱的大小显示了特定工作类型中的观测值数量。箱越宽，观测值数量就越多：
- en: '[PRE161]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '![Figure 1.12: Boxplot of age and job'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.12：年龄和工作的箱线图'
- en: '](img/C12624_01_12.jpg)'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C12624_01_12.jpg)'
- en: 'Figure 1.12: Boxplot of age and job'
  id: totrans-635
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.12：年龄和工作的箱线图
- en: Summary
  id: totrans-636
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we visited some basics of R programming data types, data structures,
    and important functions and packages. We described vectors, matrix, list, DataFrame,
    and data tables as different forms of storing data. In the data processing and
    transformation space, we explore the `cbind`, `rbind`, `merge`, `reshape`, `aggregate`,
    and `apply` family of functions.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了R编程的基础数据类型、数据结构和重要的函数及包。我们描述了向量、矩阵、列表、DataFrame和数据表作为存储数据的不同形式。在数据处理和转换空间中，我们探讨了`cbind`、`rbind`、`merge`、`reshape`、`aggregate`和`apply`函数族。
- en: We also discussed the most important packages in R such as `dplyr`, `tidyr`,
    and `plyr`. In the end, the `ggplot2` data visualization package was used to demonstrate
    various types of visualization and how to draw insights from them.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了R中最重要的包，如`dplyr`、`tidyr`和`plyr`。最后，使用`ggplot2`数据可视化包展示了各种可视化类型以及如何从中提取洞察。
- en: In the next chapter, we will use all that you have learned in this chapter for
    performing Exploratory Data Analysis (EDA). In EDA, data transformation and visualization
    you learned here will be useful for drawing inferences from data.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用本章所学的一切来执行探索性数据分析（EDA）。在EDA中，您在这里学到的数据转换和可视化技巧将有助于从数据中得出推断。
