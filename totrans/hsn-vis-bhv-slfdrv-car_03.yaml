- en: '*Chapter 2*: Understanding and Working with Signals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about several different signal types that you
    are likely to see when integrating the sensors that you have chosen for your project.
    You will also learn about the various signal architectures, and the chapter will
    help you choose the one that is most appropriate for your application. Each has
    its pitfalls, protocols, and prescriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Signal types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analog verus digital
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serial data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CAN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UDP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to apply your understanding of
    each protocol. You will be able to decode the serial data of various protocols
    by hand to aid in debugging signals. Most importantly, you will have the knowledge
    required to help you apply open source tools to do the heavy lifting for you.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To execute the instructions in this chapter, you need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic electrical circuit knowledge (about voltage, current, and resistance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary, hexadecimal, and ASCII programming knowledge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oscilloscope experience for probing sensor signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for the chapter can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2](https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action videos for this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/2HpFqZa](https://bit.ly/2HpFqZa)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding signal types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will encounter many different signal types when integrating sensors, actuators,
    and controllers for a self-driving car. You will need an understanding of the
    strengths and weaknesses of each type to help you select the correct devices to
    integrate. The next few sections will cover all the details regarding each signal
    type and arm you with the knowledge to make the right choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the basic signal types that you will encounter in robotics and self-driving
    cars:'
  prefs: []
  type: TYPE_NORMAL
- en: Serial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single-ended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differential
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, you will learn the difference between analog and digital
    signals.
  prefs: []
  type: TYPE_NORMAL
- en: Analog versus digital
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to remember is that we live in an analog world. Nothing is instantaneous
    and everything is continuous. This is the reason why we can't teleport, sadly!
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, analog signals are continuous and everchanging; they don''t jump
    instantaneously but instead smoothly transition from one state to another. A prime
    example of an analog signal is the old **Amplitude Modulation** (**AM**) radio.
    You can see in the following figure how the smooth data signal is modulated onto
    a smooth carrier wave to create the smooth AM signal. Here, the pitch is represented
    by how quickly the amplitude is changing and the volume is represented by how
    great the amplitude is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Analog signal example](img/B16322_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Analog signal example
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, a digital signal is one that is sampled at known points in time.
    When the signal is sampled, it is checked to see whether it is above or below
    a certain threshold, which will determine whether it is a logic `0` or `1`. You
    can see an example of this in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Digital signal example](img/B16322_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Digital signal example
  prefs: []
  type: TYPE_NORMAL
- en: Analog hides in the digital
  prefs: []
  type: TYPE_NORMAL
- en: Although we talk about digital as jumping from one state to another, it really
    isn't. It is just changing very quickly but in an analog fashion. We simply choose
    to sample it in the middle of a pulse. The world is always analog, but sometimes
    we interpret it digitally.
  prefs: []
  type: TYPE_NORMAL
- en: If you look carefully at the following figure, you see the analog nature that
    hides in the corners!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Digital signal oscilloscope – before and after signal has run](img/B16322_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Digital signal oscilloscope – before and after signal has run
  prefs: []
  type: TYPE_NORMAL
- en: Do you see it? Although this is supposed to be a sharp transition between voltages,
    you can see the rounding of what should be square corners. This is due to the
    fact that nothing in nature is instantaneous and everything transitions smoothly
    from one state to another.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn the difference between serial and parallel
    data transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Serial versus parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serial data is probably the most ubiquitous type of data transfer. It is how
    we as humans are accustomed to communicating. You are doing it right now as you
    read this. Serial communication simply means that data is transmitted and received
    one unit at a time (as opposed to several units of data being transmitted in parallel).
  prefs: []
  type: TYPE_NORMAL
- en: In the case of reading this book, your eyes are processing each word by scanning
    each line of text from left to right, then proceeding back to the beginning of
    the next line and continuing. You are processing a serial stream of words that
    are used to communicate some thoughts and ideas. Conversely, imagine if you could
    read the book several lines at a time. This would be considered parallel data
    transfer and it would be awesome!
  prefs: []
  type: TYPE_NORMAL
- en: The unit of data that is used in computing is the bit, which is a binary representation
    for on or off, more commonly 1 or 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parallel data transfer was popular in the early years of computing since it
    allowed the simultaneous transfer of bits across multiple (usually 8) wires, which
    greatly increased data transfer speeds. This speed comes at several costs. More
    wires mean more weight, cost, and noise. Since the multiple wires are usually
    next to each other, you get a lot of noise induced on adjacent wires, known as
    crosstalk. This noise leads to shorter distances of transmission. The following
    figure illustrates how 8 bits are transferred serially versus in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Serial versus parallel](img/B16322_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Serial versus parallel
  prefs: []
  type: TYPE_NORMAL
- en: Now you can see a single wire is dedicated to each bit. This was fine in early
    computing when 8 bits were being sent, but you can imagine how quickly this becomes
    unmanageable when you consider 32- and 64-bit data. Thankfully, once protocol
    speeds increased, it became clear that serial transfer was far cheaper and simpler
    to integrate. That is not to say that parallel data transfer doesn't still exist;
    it does in applications where speed is paramount.
  prefs: []
  type: TYPE_NORMAL
- en: There are several types of serial data protocols, such as UART, I2C, SPI, Ethernet,
    and CAN. You will get an introduction to each of them in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Universal Asynchronous Receive and Transmit (UART)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UART is a very common protocol, thanks to its simplicity and cost. Many low
    data rate applications will use it to transmit and receive data. A common application
    of UART that you will see in self-driving applications is time synchronization
    to GPS. A message from a GPS receiver containing all the position and time information
    will be sent to a lidar, camera, radar, or other sensor to synchronize them to
    **Coordinated Universal Time** (**UTC**).
  prefs: []
  type: TYPE_NORMAL
- en: Pardon me, I think your acronym is mixed up
  prefs: []
  type: TYPE_NORMAL
- en: The French and the English couldn't agree on the acronym, so rather than CUT
    in English or **TUC** (**Temps Universel Coordonné**) in French, they mixed it
    up for both to not favor either language. If I can't have it my way, neither can
    you! Voilà, UTC is born!
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so what does UART look like? The first thing you need to understand is
    that the protocol is asynchronous, meaning that a clock signal (wire) is not needed.
    Instead, the two devices must each have pretty good internal clocks to keep time
    for themselves. Right, so no clock wire needed; but what wires do you need? You
    only need two wires: one to transmit and one to receive. As such, the two devices
    need to agree on some ground rules before they start the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Baud rate**: This sets the number of bits per second that will be exchanged
    between the devices. In other words, it is the duration of the bit count. Common
    baud rates are 9,600, 19,200, 38,400, 57,600, 115,200, 128,000, and 256,000.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data bits**: This sets the number of bits in a data frame for the payload
    (data).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Parity**: This sets whether you will have a parity bit in the packet. This
    can be used to verify the integrity of the message received. This is done by counting
    the number of 1s in the data frame and setting the parity bit to 0 for an even
    number of 1s or 1 for an odd number of 1s.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Stop bits**: This sets the number of stop bits signifying the end of a packet.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Flow control**: This sets whether you will be using hardware flow control.
    This is not as common since it requires two additional wires for **Ready To Send**
    (**RTS**) and **Clear To Send** (**CTS**).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great, we have the ground rules. Now let's see what a packet looks like and
    then decode one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure illustrates the structure of a packet for a UART message.
    You can see we start with exactly one start bit (low), followed by 5 to 9 data
    bits, followed by the parity bit if one is in the rules, and finally the stop
    bit(s) (1 to 2, high). The idle state is often the high voltage state representing
    a `1` with the active state usually low, representing a `0`. This is a normal
    polarity. You can reverse the polarity if needed, as long as you lay the ground
    rules ahead of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – UART packet structure](img/B16322_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – UART packet structure
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example signal trace showing how to decode the bits with
    eight data bits, no parity, and one stop bit. We begin in the idle (high) state,
    then the packet begins with a low voltage position. This signifies that the following
    eight bits are the data. Next, we see five counts of high voltage, signifying
    five 1 bits, followed by three counts of low voltage, signifying three 0 bits.
    You should know that UART messages are sent with the least significant bit first,
    meaning the lowest binary value or 20 position, followed by the 21 position, then
    the 22 position, and so on. So, if you reorder them into a human-readable format,
    your data message is 0 0 0 1 1 1 1 1; translated into decimal, that would be 31
    or 1F in hexadecimal. There is a great resource at [https://www.mathsisfun.com/binary-decimal-hexadecimal.html](https://www.mathsisfun.com/binary-decimal-hexadecimal.html)
    for different base number systems, such as binary, decimal, and hexadecimal. There
    is another handy resource for decoding ASCII characters from binary at [http://www.asciitable.com/](http://www.asciitable.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – UART example bits](img/B16322_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – UART example bits
  prefs: []
  type: TYPE_NORMAL
- en: Easter Egg
  prefs: []
  type: TYPE_NORMAL
- en: Take out your decoder ring. It's time to learn the meaning of life, the universe,
    and everything...
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16322_02_Art1.png)'
  prefs: []
  type: TYPE_IMG
- en: Excellent, now you know how to decode UART serial messages.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so you may ask, *UART is so simple, why would I use anything else?* Let's
    go over some pros and cons of UART.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Cheap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full duplex (send and receive at the same time)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous (no clock line)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple, with only two wires between each device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parity for error checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Widely used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum bits per frame of nine bits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device clocks must be within 10% of each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is slow by modern standards, with standard bit rates ranging from 9,600-230,400
    bits per second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires a direct connection between each device rather than a bus architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some overhead with start and stop bits, demanding complex hardware for transmitting
    and receiving.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you would like to gain experience with UART and Python, the simplest device
    for you to test UART communication on, will be an Arduino. If you have one, great!
    You can then jump directly to the documentation on PySerial and start communicating
    with your Arduino. If you don''t have an Arduino, you can find an example emulator
    code for practicing in the book''s repository, in the `Chapter 2` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2](https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn about two different standards that use UART messages.
  prefs: []
  type: TYPE_NORMAL
- en: Differential versus single-ended
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UART signals can be transmitted in a few different ways. The two most common
    are **Recommended Standard 232** (**RS-232**) and **Recommended Standard 422**
    (**RS-422**).
  prefs: []
  type: TYPE_NORMAL
- en: 'RS-232 is a single-ended signal, meaning that its voltage is compared directly
    to the electrical ground of the system (0 V). The following figure depicts a single-ended
    signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Single-ended line](img/B16322_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Single-ended line
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, RS-422 is a differential signal, meaning the voltage is compared
    across the two wires independent of the electrical ground of the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Differential line](img/B16322_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Differential line
  prefs: []
  type: TYPE_NORMAL
- en: Now for storytime...
  prefs: []
  type: TYPE_NORMAL
- en: 'Once upon a time, the signal was born, with one mission: to take messages from
    its senders to the far-off lands where receivers live. The world is full of goblins
    and ghosts that are conspiring against our hero signals. These goblins and ghosts
    trip and mangle our poor friend the signal. The longer the signal travels on its
    journey, the more these bad actors will sneak in and wreak havoc. Generally, on
    short sojourns, the signal is unaffected and passes through the enchanted forest
    relatively undisturbed. However, the longer the journey, the more the signal needs
    to find tricks, friends, and guardians to get to its receiver safely.'
  prefs: []
  type: TYPE_NORMAL
- en: So, who are these ghosts and goblins? They are electromagnetic fields and induced
    currents. You see, any time a ghost electromagnetic field moves near the signal's
    path (wire), it spawns a goblin (current) on the path. This goblin in turn uses
    its magical powers to stretch and shrink the signal's arms until it arrives at
    its destination, where the receiver sees the signal's arms as shorter or longer
    than they should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'But have no fear – the tricks, friends, and guardians are here! The signal
    has a great little trick to thwart the ghosts and goblins, but first it must spawn
    a doppelganger: we''ll call it the langis (that''s *signal* backward). The langis
    and the signal twist around each other on their way to the receiver. This confuses
    the ghosts and causes them to spawn two equal but opposite goblins that unwittingly
    smash into each other and vanish before they can use their magical powers.'
  prefs: []
  type: TYPE_NORMAL
- en: The other trick the langis and the signal have is that they promise to always
    hold hands and move together on their journey no matter what goblins strike them.
    So, when they arrive at their destination, the receiver just measures the distance
    between the langis and the signal to get the message!
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so what does this fairy tale look like in real life? Rather than having
    only one transmit wire, you instead use two wires. You then set one wire to be
    your high voltage (V+) and the other to be your low voltage (V-). Now when comparing
    the signals on the receiver side, you measure the voltage difference between V+
    and V- to determine whether you have a high or low signal. The following figure
    shows a single-ended signal (1a) and a differential signal (1b):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Single-ended versus differential signal](img/B16322_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Single-ended versus differential signal
  prefs: []
  type: TYPE_NORMAL
- en: 'This has the wonderful effect of having any induced noise affect both V+ and
    V- similarly, so that when you measure the difference between V+ and V-, it is
    unchanged from how it was when it was sent. The following figure illustrates what
    this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Noise on a differential line](img/B16322_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Noise on a differential line
  prefs: []
  type: TYPE_NORMAL
- en: 'The other trick was to twist the two wires of a differential pair around each
    other. This has the effect of canceling any induced currents in the wires. The
    following illustration shows the difference between straight cables and twisted
    pair cable currents. You can see that at each twist, the wires switch sides, so
    the noise current is alternating at each twist, effectively canceling itself out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Noise cancellation on differential twisted pair cable](img/B16322_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Noise cancellation on differential twisted pair cable
  prefs: []
  type: TYPE_NORMAL
- en: So, what does this all mean for you when choosing between single-ended and differential?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a comparison table to help:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1](img/B16322_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.1
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn about another form of serial communication
    that speeds things up a bit, along with some other very handy benefits.
  prefs: []
  type: TYPE_NORMAL
- en: I2C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**I2C**, or I2C, is short for **Inter-Integrated Circuit** and is another serial
    data transfer protocol with a few cool new features. More on those in a bit. I2C
    is commonly used to communicate between components on a single **Printed Circuit
    Board** (**PCB**). It boasts data rates of 100-400 kHz, which is generally supported,
    and the specification even has room for up to 5 MHz communication, although this
    is not commonly supported on many devices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may ask, "Why use I2C? UART is already very simple and easy." Well, I2C
    adds some very cool features that you don''t have with UART. Recall that UART
    requires two wires connected between each device, which means you need a connector
    for each device that you want to communicate with. This quickly spins an unmanageable
    web of wires when you want several devices interconnected. You also don''t have
    the concept of master or slave in UART, since devices talk directly to each other
    on separate Tx and Rx lines. You can see an example of a fully connected UART
    architecture in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Fully connected UART network](img/B16322_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Fully connected UART network
  prefs: []
  type: TYPE_NORMAL
- en: 'I2C to the rescue! I2C also uses only two wires: a **Serial Clock Wire** (**SCL**)
    and a **Serial Data Wire** (**SDA**) – more on how these work later. It uses these
    two wires to set up a new architecture between devices, a bus. A bus is simply
    a set of shared wires that transmits a signal to all devices attached to them.
    The following illustration will help us understand this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – I2C bus architecture](img/B16322_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – I2C bus architecture
  prefs: []
  type: TYPE_NORMAL
- en: This allows multiple devices to talk to each other without requiring dedicated
    lines from each device to every other device it needs to talk with.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be thinking, *How can everyone be talking on the same lines and understand
    anything?* The I2C protocol implements the concept of master and slave devices.
    A master controls the flow of communication by announcing to everyone, *Hey, listen
    up everyone, I am talking to RasPi1, please acknowledge you are there, then send
    me data!* The master then gives control to RasPi1, who quickly shouts, *I''m here
    and have understood the request! Here is the data you requested; please acknowledge
    you received it*. The master then says, *Got it!* Then the process starts over.
    The following figure is a timing diagram of an I2C exchange:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – I2C timing diagram](img/B16322_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – I2C timing diagram
  prefs: []
  type: TYPE_NORMAL
- en: Let's walk through a communication sequence. The sequence begins with the master
    pulling the SDA line low followed by pulling the SCL line low. This signifies
    the start condition. The next series of 7-10 bits (depending on your settings)
    is the address of the slave that is being spoken to. The next bit, the R/W bit,
    instructs the slave to either write to (logical 0) or read from (logical 1) its
    memory register. The bit that follows the R/W is the acknowledge (ACK) bit. This
    is set by the slave that is being addressed if it heard, understood, acknowledged,
    and will respond to the request. The master will then continue generating pulses
    on the SCL line while either the slave or the master starts placing data on the
    eight data bits on the SDA.
  prefs: []
  type: TYPE_NORMAL
- en: Bigger bits first
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to UART, bits are transmitted MSB first in I2C.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the R/W bit was set to 0, the slave would receive the data being
    placed on the SDA and write it to memory. Immediately following the eight data
    bits, the slave will pull the SDA line low for one clock count to acknowledge
    that it received the data, stored it, and is ready to give back control of the
    SDA line to the master. At this point, the master pulls the SDA back low. Finally,
    to stop the sequence, the master will release the SCL followed by the SDA.
  prefs: []
  type: TYPE_NORMAL
- en: When so many devices can be talking on the bus at the same time, it is important
    to have some rules to ensure that there is no clashing. I2C achieves this by using
    an *open-drain* system, which simply means that any master or slave can only pull
    the line to ground. The idle states of the SCL and SDA are held in the high voltage
    state through pull-up resistors. This can be seen in *Figure 2.13* with the resistors
    connected to VDD. When a master or slave wants to send data, they pull the line
    to ground (or open the drain). This ensures that you will never have one device
    driving the line high while another is driving it low.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting feature of the I2C protocol is that not only can there be
    multiple slave devices on the bus, but there can also be multiple masters. Here,
    you'll ask, *But wait, you said the master controls the flow. How will we know
    who is in control?* The genius in this architecture is that every device is connected
    to the same lines (bus), so they can all see what is happening at any given time.
    So, if two masters are trying to control the bus at nearly the same time, the
    first one to pull the SDA line low wins! The other master backs off and becomes
    a temporary slave. There is a case when two masters pull low at the exact same
    time and it is unclear who has control. In this case, arbitration begins. The
    first master to release to high on the SDA loses arbitration and becomes a slave.
  prefs: []
  type: TYPE_NORMAL
- en: Easter Egg
  prefs: []
  type: TYPE_NORMAL
- en: If a hen and a half lay an egg and a half in a day and a half, how many eggs
    will half a dozen hens lay in half a dozen days? Decode the following signal for
    the answer!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16322_02_Art2.png)'
  prefs: []
  type: TYPE_IMG
- en: Here is a summary of the benefits and disadvantages of I2C.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: A multiple-master, multiple-slave architecture, up to 1,024 devices in 10-bit
    address mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bus-based with only two wires (SCL and SDA) required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speeds of up to 5 MHz
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inexpensive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message acknowledgment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Half-duplex, cannot transmit and receive at the same time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overhead of start, stop, and acknowledge conditions reduces throughput.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pull-up resistors limit clock speed, eat up PCB space, and increase power
    dissipation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short maximum wire lengths (1 cm–2 m) dependent on capacitance, resistance,
    and speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have learned a lot about I2C, which has armed you with even more knowledge
    about dealing with serial data. In the next section, you will learn about yet
    another serial communication protocol with a bit more spunk but traded for something
    else.
  prefs: []
  type: TYPE_NORMAL
- en: SPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Serial Peripheral Interface** (**SPI**) is a serial transmission link used
    primarily in microcontrollers to link peripherals such as USB, memory, and onboard
    sensors. Its main advantage is its speed and the simplicity of is implementation.
    SPI is not commonly used for sensors that you will be using in your self-driving
    car applications, but it is worth knowing a bit about in case you come across
    it. It is a full-duplex link with four wires used: SCLK, MOSI, MISO, and SS. The
    following illustration will help as we talk through their functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – SPI connection diagram](img/B16322_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – SPI connection diagram
  prefs: []
  type: TYPE_NORMAL
- en: SPI is a synchronous serial link that uses a master clock signal (SCLK), much
    like what you learned about in I2C. The clock rate is typically in the region
    of 6-12.5 MHz, which is also its bit rate. The data is passed between devices
    on the **Master Out Slave In** (**MOSI**) and **Master In Slave Out** (**MISO**)
    lines. MOSI, MISO, and SCLK can be used as a bus architecture, much like I2C.
    The final wire is the **Slave Select** (**SS**) wire. This is pulled low to notify
    the slave connected to it that it should listen to the coming message.
  prefs: []
  type: TYPE_NORMAL
- en: 'This contrasts with I2C, which sent the slave address the information about
    which slave to listen for. As you can see in *Figure 2.15*, a separate wire and
    pin must be dedicated to each slave that is added to the system (denoted by *SS1*,
    *SS2*, and *SS3* in the figure). The hardware used to implement SPI is quite simple
    and usually relies on shift-registers. *What is a shift-register?* you say. Well,
    this is a simple memory register that holds a certain number of bits, say, eight.
    Each time a new bit is brought in from one side, a bit from the other side is
    pushed out. The following figure illustrates how this works in SPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – SPI shift register](img/B16322_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – SPI shift register
  prefs: []
  type: TYPE_NORMAL
- en: 'SPI data transfer is very simple since there is only one master allowed on
    the bus. The following figure helps to illustrate how SCK, MOSI, MISO, and SS
    are used to conduct the transfer of data in full duplex:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – SPI timing diagram](img/B16322_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – SPI timing diagram
  prefs: []
  type: TYPE_NORMAL
- en: The master pulls the SS line low, which lets the target slave know, *Hey, SS1,
    this message is for you, please be ready to receive.* Then the master sends clock
    pulses on the SCK line that tell the slave when they should sample the data coming
    on MOSI. If it has been predetermined that the slave should send something back,
    the master then follows with SCK pulses for when the slave should send data on
    the MISO line. Since there are two lines, MISO and MOSI, these two transactions
    can happen at the same time using shift-register format.
  prefs: []
  type: TYPE_NORMAL
- en: SPI is not standardized like UART or I2C in terms of protocol. Because of this,
    you will need to consult the interface control documents for the devices that
    you want to connect to determine the specific commands, register sizes, clock
    modes, and so on that are required to operate the device.
  prefs: []
  type: TYPE_NORMAL
- en: You can see there is no overhead in SPI as there was in UART and I2C. There
    are no start bits, addresses, stop bits, acknowledge bits, or any other overhead.
    It is pure, sweet, high-speed data. On the other hand, there is a lot more programming
    and prearranged setup needed to communicate between two devices. SPI also can
    drive high and low on the data lines, allowing to slew faster from a `0` to a
    `1`, which leads to the faster transmission rate discussed.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's summarize the pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the pros:'
  prefs: []
  type: TYPE_NORMAL
- en: Fast data rates of 6-12.5 MHz
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full-duplex communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple shift-register hardware can be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple slaves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bus architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the cons:'
  prefs: []
  type: TYPE_NORMAL
- en: Single master only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four wires needed, plus a slave select wire for each slave.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short transmission length dependent on speed, impedance, and capacitance with
    a max estimated at 3 m
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will discuss a very common protocol that is used in
    nearly every vehicle on the road! Start your engines!
  prefs: []
  type: TYPE_NORMAL
- en: Framed-based serial protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have been discussing protocols that have fairly small message
    sizes in the region of 8-10 bits. What if you want to send more? In the next few
    sections, you will learn about protocols that support larger message sizes and
    package them into frames or packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn about the following protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: CAN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ethernet: UDP and TCP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding CAN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Controller Area Network** (**CAN**) is a message-based protocol that was
    developed, by Bosch, to reduce the number of wires connecting the ever-growing
    number of microcontrollers and **Electronic Control Units** (**ECUs**) in vehicles.'
  prefs: []
  type: TYPE_NORMAL
- en: It is a bus-based protocol with two wires acting as a differential pair, CAN-HI
    and CAN-LO. You learned about differential pairs in the *Single-ended versus differential*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Ghost and goblins
  prefs: []
  type: TYPE_NORMAL
- en: Do you recall the trick we used to provide safe passage to the langis and the
    signal on their journey? There is a real *twist* to that story.
  prefs: []
  type: TYPE_NORMAL
- en: 'CAN is a feature-packed protocol that is very robust, reliable, and rapid.
    Here are some of the features of the protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized multi-master communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prioritized messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bus arbitration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote terminal request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data integrity with cyclic redundancy checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexible expandable network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centralized diagnostics and configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EMI noise rejection through a twisted differential pair
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The CAN bus architecture is devilishly simple and is illustrated in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – CAN bus architecture](img/B16322_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – CAN bus architecture
  prefs: []
  type: TYPE_NORMAL
- en: You can see that nodes may be added anywhere on the bus inside of the bus terminations,
    Rterm. A consideration when connecting a node is the unterminated stub length,
    which the standard recommends keeping below 0.3 m.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how bits are transmitted on the CAN HI and CAN LO differential
    twisted pair lines. The figure that follows illustrates the dominant and recessive
    voltages of the CAN protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: Zero to hero
  prefs: []
  type: TYPE_NORMAL
- en: '`0` rules the bus with its dominant differential voltage rising up above the
    minimum threshold.'
  prefs: []
  type: TYPE_NORMAL
- en: One and done
  prefs: []
  type: TYPE_NORMAL
- en: '`1` sleeps on the bus with its recessive differential voltage, which lies below
    the minimum threshold.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – CAN dominant and recessive voltages](img/B16322_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – CAN dominant and recessive voltages
  prefs: []
  type: TYPE_NORMAL
- en: By EE JRW – ow[n work, CC BY-SA 4.0, https://commons.wikimedia.org/w/in](https://commons.wikimedia.org/w/index.php?curid=55237229)dex.php?curid=55237229
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you see how bits are placed on the bus, let''s look at the CAN frame
    structure. This will be useful if you find yourself debugging or reading CAN bus
    traffic. The following figure depicts the segments of a CAN frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20 – CAN message format](img/B16322_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20 – CAN message format
  prefs: []
  type: TYPE_NORMAL
- en: CAN frames begin with a `0`, which is the dominant differential voltage. This
    may sound a bit similar to what you learned in UART communication, which also
    started with a logical `0`. Much like in UART, the SOF bit in CAN is a transition
    from an idle state to an active one. Unlike UART, however, the active and dominant
    state is a high voltage state.
  prefs: []
  type: TYPE_NORMAL
- en: Following the SOF bit is the arbitration field. This can be thought of as the
    ECU's functional address (for example, the steering module, oxygen sensor, lidar
    sensor, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Less is best
  prefs: []
  type: TYPE_NORMAL
- en: ECUs with a smaller address in the arbitration fields are considered higher
    priority in the CAN protocol. The smaller address will win the arbitration when
    two or more devices start transmitting at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The next bit is the `1`, the recessive state.
  prefs: []
  type: TYPE_NORMAL
- en: The next six bits are the **Data Length Code** (**DLC**) section of the frame,
    which says how long the upcoming data field will be. The data for a CAN message
    can be 0 to 8 bytes in length.
  prefs: []
  type: TYPE_NORMAL
- en: Immediately following the DLC is the data, which can be 0-64 (0-8 bytes) bits
    in length.
  prefs: []
  type: TYPE_NORMAL
- en: Bit order
  prefs: []
  type: TYPE_NORMAL
- en: CAN sends its information with the MSB first.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the **Cyclic Redundancy Check** (**CRC**) field, which is 15 bits long
    and is used for error checking the message. The sending ECU performs a checksum
    calculation on the data field and places this in the CRC field. Once the receiving
    ECU gets the frame, it runs the same checksum calculation on the data field and
    verifies that it matches the CRC field in the received frame. The CRC is immediately
    followed by the CRC delimiter field to give it separation from the ACK bit.
  prefs: []
  type: TYPE_NORMAL
- en: The `1` recessive so that any receiving ECU can acknowledge receipt of the error-free
    data during this bit interval. The ACK bit is followed by the ACK delimiter to
    allow for any timing difference that overruns the ACK bit.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `1` bits, which indicate – you guessed it – the end of the frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, one more thing: there is an **Inter Frame Space** (**IFS**), which is
    defined by the CAN controller of the system.'
  prefs: []
  type: TYPE_NORMAL
- en: Sweet – that was long. Don't worry, though; CAN is a very well-supported protocol
    and there are plenty of software and hardware modules that you can find that will
    do the heavy lifting for you. You will likely only need to dust this knowledge
    off when things aren't working right and you pull out the old oscilloscope to
    probe the CAN bus and verify that messages are transmitting properly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's recap the pros and cons of the CAN bus protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the pros:'
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized multi-master communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prioritized messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bus arbitration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RTR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data integrity with CRCs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexible, expandable network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centralized diagnostics and configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EMI noise rejection through a twisted differential pair
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum cable length of 40 m
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the only con, really:'
  prefs: []
  type: TYPE_NORMAL
- en: Careful attention to the wiring bus terminations and stub lengths is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, you will learn about the most ubiquitous networking protocols
    used in modern times, both in cars and at home.
  prefs: []
  type: TYPE_NORMAL
- en: Ethernet and internet protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ethernet is a framework of protocols and layers that is used in modern networking
    in nearly every application you interact with today. Ethernet is in your home,
    the train you ride, the plane you fly in, and definitely in your self-driving
    car. It consists of both the physical and protocol standards for network-based
    communication. It all starts with the **Open Systems Interconnection** (**OSI**)
    model of the different layers. The following figure illustrates the seven layers
    of the OSI model and what each layer is tasked with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.21 – The seven layers of the OSI model](img/B16322_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.21 – The seven layers of the OSI model
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these layers has its own protocol for processing data. It all starts
    with the raw data, or bits, at the application layer. The data gets processed
    at each layer to be passed onto the next layer. Each layer wraps the previous
    layer''s frame into a new frame, which is why the model shows the frames getting
    larger and larger. The following figure illustrates the protocols at each layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22 – Protocols of the OSI model](img/B16322_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.22 – Protocols of the OSI model
  prefs: []
  type: TYPE_NORMAL
- en: We could spend an entire book talking about the details of each layer and protocol.
    Instead, we will focus on two protocols (UDP and TCP) that you will encounter
    when working with sensors and actuators in a self-driving car.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding UDP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**User Datagram Protocol** (**UDP**) is a very popular protocol for sensors
    such as lidars, cameras, and radars. It is a connection-less protocol. *Wait –
    if it''s connection-less, how is it sending data?* Connection-less, in this sense,
    just means that the protocol doesn''t verify that it can reach the destination
    before it sends data. UDP lives on the transport layer of the OSI model. You can
    see in the following figure that the transport layer is the first layer to add
    a header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23 – UDP on the transport layer](img/B16322_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.23 – UDP on the transport layer
  prefs: []
  type: TYPE_NORMAL
- en: If you were sending a gift to someone, what would you want them to know about
    the gift so that they could be confident that it was intended for them and was
    not swapped for someone else's gift? You might say something like, *Tenretni Olleh,
    I am sending you this luxurious pair of rainbow pajamas in size large and I hope
    they fit. Please try them on.* This is exactly what the UDP header's function
    is. It stores the source port, the destination port, the length of the data including
    the header, and finally a checksum. The checksum is simply a number that is created
    with an algorithm before the data is sent to ensure that when it is received,
    the data is intact and not corrupted. This is done by running the same algorithm
    on the received data and comparing the number generated to the checksum value.
    This is akin to sending a picture of the pajamas that were sent to Tenretni so
    they knew they received the correct gift.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure illustrates the fields within a UDP header and the actual
    message itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.24 – UDP header fields](img/B16322_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.24 – UDP header fields
  prefs: []
  type: TYPE_NORMAL
- en: Port, plugs, and sockets
  prefs: []
  type: TYPE_NORMAL
- en: A port in the Ethernet protocol can be thought of like a power socket in your
    wall. You plug different devices into the sockets, such as lamps and TVs. Each
    plug, once connected, serves a specific device power. Similarly, a port is where
    a digital socket is created for a specific device or protocol to send and/or receive
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UDP header is always 8 bytes (64 bits), while the data (message) can be
    up to 65,507 bytes in length. The following figure is a relevant example, to self-driving
    cars, of the data (message) field size of a UDP packet from a popular family of
    high-resolution lidar sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.25 – Ouster lidar UDP data structure](img/B16322_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.25 – Ouster lidar UDP data structure
  prefs: []
  type: TYPE_NORMAL
- en: You can see from this, if you carefully multiply all the bytes, that you get
    389 words * 4 bytes/word * 16 azimuths/packet = 24,896 bytes/packet. This is well
    within the data limit size of a UDP packet, 65,507 bytes. In order to send this
    data over UDP, what must the lidar sensor append to this data? You guessed it
    – there needs to be a UDP header with the 8 bytes of source, destination, data
    length, and checksum information.
  prefs: []
  type: TYPE_NORMAL
- en: UDP is often used for streaming-type devices such as lidar sensors, cameras,
    and radars since it does not make sense to resend data if it is not received.
    Imagine you didn't receive a few azimuths in the lidar sensor example. Would it
    be useful to you to have that data resent to you? Probably not, since whatever
    the lasers bounced off is now in the past and likely in a different position.
    Another reason to use UDP for such devices is that due to the high data rates,
    it would slow things down tremendously to have to resend lost or corrupted data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss a protocol that will address cases where
    you might want to ensure that there is a three-way handshake for each packet of
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding TCP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you were going to send a command to turn the steering wheel of your self-driving
    car, would you be okay if the command never made it, was wrong, or corrupted?
    Would you be okay if you didn't know whether the steering actuator received the
    command? Probably not!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where **Transmission Control Protocol** (**TCP**) can serve you! TCP
    operates similarly to UDP...well, actually, it''s completely different. Unlike
    UDP, TCP is a connection-based protocol. This means that each time you want to
    send data, you need to do a three-way handshake. This is done through a process
    known as SYN-SYN/ACK-ACK. Let''s break that down to understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: SYN – The client sends a SYN (synchronization) packet with a randomly selected
    initial sequence number (`x`), which is used to count the bytes that are being
    sent. It also sets the SYN bit flag to `1` (more on this later).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SYN/ACK – The server receives the SYN packet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It increments `x` by one. This becomes the acknowledgement (ACK) number (`x+1`),
    which is the number of the next byte it expects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then sends a SYN/ACK packet back to the client with the ACK number as well
    as the server's own randomly selected sequence number (`y`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ACK – The client receives the SYN/ACK packet with the ACK number (`x+1`) and
    server sequence number (`y`):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It increments the server's initial sequence number to `y+1`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It sends an ACK packet with the ACK number (`y+1`) and ACK bit flag set to `1`
    back to the server to establish the connection.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the connection sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.26 – TCP connection sequence diagram](img/B16322_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.26 – TCP connection sequence diagram
  prefs: []
  type: TYPE_NORMAL
- en: Now the connection is established and data can begin to flow. Each packet that
    is sent will be followed by an ACK packet with the number of bytes received plus
    one, indicating that the packet was received intact and what byte number it expects
    next. The sequence number is incremented by one for SYN and SYN/ACK packets and
    by the number of bytes of payload received for ACK packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can already see that in order to do all this, the header is going to need
    more fields than with UDP. The following figure illustrates the fields of a TCP
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.27 – TCP header fields](img/B16322_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.27 – TCP header fields
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s unpack each field and its purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source port**: This is the port the packet is sent from. This is usually
    a randomly assigned port number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`22`. A list of well-known ports can be found at this link: [https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml.](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequence number**: This is the number of the first byte being sent in the
    payload; or, for SYN and SYN/ACK packets, it is the randomly selected initial
    sequence number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acknowledgment number**: This is the number of bytes that have been received
    plus one, indicating the next byte number expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data offset**: This is the length of the TCP header, that is, the offset
    before the payload.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reserved**: These are bits that are unused but reserved for future protocol
    improvements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` or `1`). This is used to mark a packet as urgent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACK` bit flag, which is set to `1` when a valid acknowledgment number is being
    sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` when the data should be pushed to the application immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` when the connection needs to be reset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` when the SYN-SYN/ACK connection establishment process is initiated. It
    indicates that there is a valid sequence number in the sequence number field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` when the connection should be closed after all data is sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Window**: This is the size of the buffer that the receiving end can accept
    before losing data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`payload+header` that is used to verify that the data received is valid and
    unchanged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URG` bit flag is set to `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP uses all this header information for the task of ensuring that all data
    is received, verified, and acknowledged. If data is ever missed, the last valid
    sequence number can be used to resend the data. Now you can send your steering
    commands over Ethernet with confidence, knowing that you won't go careening off
    a cliff!
  prefs: []
  type: TYPE_NORMAL
- en: Cars use CAN, mostly...
  prefs: []
  type: TYPE_NORMAL
- en: Although we used steering as an example for TCP here, you will typically find
    that vehicle control commands are sent using CAN bus over Ethernet bus from the
    factory. Increasingly, though, self-driving car creators are relying on Ethernet
    for its higher data throughput and security. There is talk of moving to Ethernet
    bus for factory vehicles in the future. Military aircraft have already started
    doing so!
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay – goodness, that was a lot to take in. Do not worry, though: now that
    you have seen this once and understand it, you can rely on open source tools to
    parse through this in the future. Where you will find this useful is when things
    start going wrong and you need to debug the traffic flow of your data.'
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of which, Wireshark is a fantastic tool for **sniffing** Ethernet packets
    on your network and seeing the flow of information for debugging and testing.
    You can find all the information you need on installation and use at [https://www.wireshark.org/](https://www.wireshark.org/).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, TCP is a powerful protocol for connection-based, highly reliable,
    and secure data transfer. Now get out there and start using the Ethernet protocol
    with the open source tools listed at the end of this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations, you have completed your quest with your new friends, the langis
    and the signal! You have had quite an adventure! You battled ghosts and goblins
    in the form of electromagnetic waves and induced currents. You learned so much
    along the way about serial versus parallel data transfer; digital versus analog
    signals; and protocols such as UART, I2C, SPI, CAN, UDP, and TCP and their secret
    decoder rings! You are now armed with the knowledge you will need when integrating
    sensors and actuators into your real self-driving car.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to use OpenCV to detect lanes on the
    road, a vital skill to ensure the safe and legal operation of your self-driving
    car!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After reading this chapter, you should be able to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How many wires does each protocol require and what are their names?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are two methods to reduce noise in a signal?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between serial and parallel data transmission?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which protocols use a bus architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which protocols have a clock signal?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What protocol is used widely to send GPS information to other sensors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Texas Instruments Controller Area Network Physical Layer Requirements ([http://www.ti.com/lit/an/slla270/slla270.pdf?HQS=slla270-aaj&ts=1589256007656](http://www.ti.com/lit/an/slla270/slla270.pdf?HQS=slla270-aaj&ts=1589256007656))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texas Instruments Introduction to the Controller Area Network (CAN) ([http://www.ti.com/lit/an/sloa101b/sloa101b.pdf](http://www.ti.com/lit/an/sloa101b/sloa101b.pdf))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Universal Asynchronous Receiver and Transmitter (UART) ([https://ieeexplore.ieee.org/document/7586376](https://ieeexplore.ieee.org/document/7586376))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the I2C Bus ([http://www.ti.com/lit/an/slva704/slva704.pdf?&ts=1589265769229](http://www.ti.com/lit/an/slva704/slva704.pdf?&ts=1589265769229))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open source protocol tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also refer to the following resources to learn more about the tools
    for programming with the protocols covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PySerial` ([https://pypi.org/project/pyserial/](https://pypi.org/project/pyserial/))
    for UART (RS-232, RS-422, RS-485)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python-periphery` ([https://python-periphery.readthedocs.io/en/latest/index.html](https://python-periphery.readthedocs.io/en/latest/index.html))
    for UART, I2C, SPI, and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`smbus2` ([https://pypi.org/project/smbus2/](https://pypi.org/project/smbus2/))
    for I2C'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spidev` ([https://pypi.org/project/spidev/](https://pypi.org/project/spidev/))
    for SPI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python-can` ([https://pypi.org/project/python-can/](https://pypi.org/project/python-can/))
    for CAN'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket` ([https://docs.python.org/3/library/socket.html](https://docs.python.org/3/library/socket.html))
    for Ethernet TCP, UDP, and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
