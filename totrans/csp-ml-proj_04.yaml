- en: Foreign Exchange Rate Forecast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to start building regression models in C#. Up
    until now, we have built **machine learning** (**ML**) models with the goal of
    classifying data into binary or multiple buckets using logistic regression, Naive
    Bayes, and random forest learning algorithms. However, we are now going to switch
    gears and start building models that predict continuous outcomes. In this chapter,
    we will explore a financial dataset, more specifically a Foreign Exchange Rate
    market dataset. We will be using historical data of daily currency exchange rates
    between Euros (EUR) and U.S. Dollars (USD) to build a regression model that forecasts
    future exchange rates. We are going to start with the problem definition and then
    move on to data preparation and data analysis. During the data preparation and
    analysis steps, we are going to explore how we can manage the time series data
    and analyze the distributions of daily returns. Then, we are going to start building
    features that can forecast currency exchange rates in the feature engineering
    step. We are going to discuss a few commonly used technical indicators in the
    financial market, such as moving averages, Bollinger Bands, and lagging variables.
    Using those technical indicators, we will be building regression ML models using
    linear regression and **Support Vector Machine** (**SVM**) learning algorithms.
    While building such models, we will also explore some of the ways we can fine-tune
    hyperparameters for the SVM model. Lastly, we will discuss a few validation metrics
    and methods for evaluating our regression models. We will discuss how we can use
    **root mean square error** (**RMSE**), R², and an observed versus fitted values
    plot to evaluate the performances of our models. By the end of this chapter, you
    will have working regression models for forecasting daily EUR/USD exchange rates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Problem definition for the Foreign Exchange Rate (EUR versus USD) forecast project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data preparation using time-series functionalities in the Deedle framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time series data analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature engineering using various technical indicators in Forex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear regression versus SVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model validations using RMSE, R², and the actual versus predicted plot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problem definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start this chapter by defining what we are trying to solve in this project.
    You might have heard the terms *Algorithmic Trading* or *Quantitative Finance/Trading*.
    This is one of the well-known fields in the finance industry where data science
    and ML meet finance. Algorithmic Trading or Quantitative Finance refers to a strategy
    where you use statistical learning models that were built from a large amount
    of historical data to forecast future financial market movements. Such strategies
    and techniques are used widely by various traders and investors forecast future
    prices for various financial assets. The foreign exchange market is one of the
    largest and most liquid financial markets, and a large pool of traders and investors
    take part in it. It is a unique market that is open 24 hours a day and five days
    a week and traders from all over the world come in to buy and sell certain currency
    pairs. Due to this advantage and uniqueness, the foreign exchange market is also
    an attractive financial market for algorithmic and quantitative traders to build
    ML models to forecast future exchange rates and automate their trades to take
    advantage of the fast decisions and executions that computers can make.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a feel for how we can apply our ML knowledge to financial markets and
    regression models, we are going to use historical data of daily EUR/USD rates
    from January 1, 1999 to December 31st, 2017\. We are going to use a publicly available
    dataset, which can be downloaded from this link: [http://www.global-view.com/forex-trading-tools/forex-history/index.html](http://www.global-view.com/forex-trading-tools/forex-history/index.html).
    With this data, we are going to build features by using commonly used technical
    indicators, such as moving averages, Bollinger Bands, and lagging variables. Then,
    we are going to build regression models using linear regression and SVM learning
    algorithms that forecast future daily exchange rates for EUR/USD currency pairs.
    Once we have built these models, we are going to use RMSE, R^([2]), and a plot
    of observed values against predicted values to evaluate our models.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize our problem definition for the foreign exchange rate forecasting
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the problem? We need a regression model that forecasts future foreign
    exchange rates between Euros and U.S. Dollars; more specifically, we want to build
    a ML model that forecasts daily changes in EUR/USD exchange rates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is it a problem? Due to the fast-paced and volatile environments in the
    foreign exchange market, it is advantageous to have a ML model that can forecast
    and make autonomous decisions on when to buy and when to sell certain currency
    pairs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some of the approaches to solving this problem? We are going to use
    historical data of daily exchange rates between EUR and USD. With this dataset,
    we are going to build financial features using often used technical indicators,
    such as moving averages, Bollinger Bands, and lagging variables. We will explore
    linear regression and SVM learning algorithms as our candidates for the regression
    model. Then, we will look at RMSE, R², and use an observed versus predicted plot
    to evaluate the performances of the models that we built.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the success criteria? We want low RMSE, as we want our predictions
    to be as close to the actual values as possible. We want high R², as it indicates
    the goodness of fit for our models. Lastly, we would like to see data points lined
    up closely to a diagonal line in the observed versus predicted plot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what kind of problem we are trying to solve in this chapter,
    let's start looking into the data. Unlike the two previous chapters, where we
    precompiled and prelabeled data, we are going to start with raw EUR/USD exchange
    rate data. Follow this link: [http://www.global-view.com/forex-trading-tools/forex-history/index.html](http://www.global-view.com/forex-trading-tools/forex-history/index.html)
    and select **EUR/USD Close**, **EUR/USD High**, and **EUR/USD Low**. You can also
    select different currency pairs, if you'd like to explore different datasets.
    Once you have selected the data points you want, you can then select the start
    and end dates and you can also choose whether you want to download daily, weekly,
    or monthly data. For this chapter, we choose **01/01/1999** as the **Start Date**
    and **12/31/2017** as the **Stop Date** and we download the daily dataset that
    contains close, high, and low prices for the EUR/USD currency pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have downloaded the data, there are a few tasks we need to do to get
    it ready for our future data analysis, feature engineering, and ML modeling. First,
    we need to define target variables. As discussed in our problem definition step,
    our target variable is going to be the daily change in EUR/USD exchange rates.
    To compute daily returns, we need to subtract the previous day''s close price
    from today''s close price and then divide it by previous day''s close price. The
    formula for calculating daily returns is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use the `Diff` method in Deedle''s data frame to calculate the difference
    between the previous price and the current price. You can actually use the `Diff`
    method to calculate the difference between a data point at any arbitrary point
    in time and the current data point. For example, the following code shows how
    you can calculate the differences between the current data point and the data
    points at one step ahead, three steps ahead, and five steps ahead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Using this `Diff` method, the following code is how we can calculate the daily
    returns of EUR/USD exchange rates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we are taking the difference in close prices between the previous
    day and the current day and then dividing them by the previous close price. By
    multiplying them by `100`, we can get the daily returns in a percentage. Finally,
    we add this daily return series back to the original data frame with a column
    name, `DailyReturn`, by using the `AddColumn` method in Deedle's data frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we are not quite done yet with building the target variables. Since
    we are building a forecasting model, we need to take the next day return as the
    target variable. We can use the `Shift` method in Deedle''s data frame to associate
    each record with the next day return. Similar to the `Diff` method, you can use
    the `Shift` method to move a series back and forth to any arbitrary point in time.
    The following code shows how you can move the `DailyReturn` column by `1`, `3`,
    and `5` steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from this example, the `DailyReturn` column or series has been
    moved forward by `1`, `3`, and `5` steps, depending on the parameters you fed
    into the `Shift` method. Using this `Shift` method, we are going to move daily
    returns back one step, so that each record has the next day''s return as a target
    variable. The following code is how we created a target variable column, `Target`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have encoded target variables, there is one more step we need to
    take to get our data prepared for future tasks. When you are working with financial
    data, you will often hear the terms *OHLC chart* or *OHLC prices*. OHLC stands
    for Open, High, Low, and Close and it is often used to show price movements over
    time. If you look at the data that we downloaded, you will notice that open prices
    are missing in the dataset. However, we are going to need open prices for our
    future feature engineering step. We are going to assume that the open price for
    a given day is the close price of the previous day, given that the foreign exchange
    market is run 24 hours a day and is very liquid with high trading volume. In order
    to take previous close prices as open prices, we are going to use the `Shift`
    method. The following code shows how we created and added open prices into our
    data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the full code that we used for the data preparation step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When you run this code, it is going to output the results into a file named `eurusd-daily-ohlc.csv`,
    which contains the OHLC prices, daily returns, and target variables. We are going
    to use this file for the future data analysis and feature engineering steps.
  prefs: []
  type: TYPE_NORMAL
- en: This code can also be found in the following repository: [https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/DataPrep.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/DataPrep.cs).
  prefs: []
  type: TYPE_NORMAL
- en: Time series data analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start looking into the data. We are going to take the output from the
    previous data preparation step and start looking at the distributions of daily
    returns. Unlike previous chapters, where we primarily worked with categorical
    variables, we are dealing with continuous and time series variables. We will look
    at this data in a few different ways. First, let''s look at the time series close
    prices chart. The following code shows how to build a line chart using the Accord.NET
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the Accord.NET documentation the `DataSeriesBox.Show` method for various
    other ways to display a line chart. In this example, we built a line chart with
    the integer indexes of our data frame as the *x* axis values and the close prices
    as the *y* axis values. The following is the time series line chart that you will
    see when you run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This chart shows us the overall movements of EUR/USD exchange rates over time
    from 1999 to 2017\. It started from around 1.18 and went below 1.0 in 2000 and
    2001\. Then, it went as high as 1.6 in 2008 and then ended 2017 at around 1.20\.
    Let''s now look at the historical daily returns. The following code shows you
    how to build a line chart of historical daily returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: One thing to note here is the usage of the `FillMissing` method. If you remember
    from the previous data preparation step, the `DailyReturn` series was built by
    taking the difference between the previous period and the current period. As a
    result, we have a missing value for the very first data point, since there is
    no previous period data point for the first record. The `FillMissing` method helps
    you encode missing values with custom values. Depending on your dataset and assumptions,
    you can encode missing values with different values, and the `FillMissing` method
    in Deedle's data frame will come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the previous code, it will display a chart as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from this chart, daily returns oscillate around **0**, mostly
    between -2.0% and +2.0%. Let''s look at the distribution of daily returns more
    closely. We are going to look at the minimum, maximum, mean, and standard deviation
    values. Then, we are going to look at the quartiles of daily returns, which we
    will discuss in more detail after looking at the code. The code to compute those
    numbers is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, the Deedle framework has numerous built-in methods for
    computing basic statistics. As shown in the first six lines of the code, you can
    use the `Max`, `Mean`, `Median`, `Min`, and `StdDev` methods in the Deedle framework
    in order to get corresponding statistics for daily returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get quartiles, we need to use the `Quantiles` method in the `Accord.Statistics.Measures`
    module of the Accord.NET Framework. Quantiles are the points that divide an ordered
    distribution into equal-length intervals. For example, ten-quantiles break an
    ordered distribution into ten subsets of equal sizes, so that the first subset
    represents the bottom 10% of the distribution and the last subset represents the
    top 10% of the distribution. Similarly, four-quantiles break an ordered distribution
    into four subsets of equal sizes, where the first subset represents the bottom
    25% of the distribution and the last subset represents the top 25% of the distribution.
    Four-quantiles are often called **quartiles**, ten-quantiles are called **deciles**,
    and 100-quantiles are called **percentiles**. As you can deduce from these definitions,
    the 1^(st )quartile is the same as the 0.25^(th )decile and the 25^(th )percentile.
    Similarly, the 2^(nd )and 3^(rd )quartiles are the same as the 0.50^(th )and 0.75^(th )deciles and the
    50^(th )and 75^(th )percentiles. As we are interested in the quartiles, we used
    25%, 50%, and 75% as the inputs for the `percentiles` parameter in the `Quantiles`
    method. The following shows the output when you run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Similar to what we have noticed from the daily return time series line chart,
    mean, and median are about 0, suggesting the daily returns oscillate around 0%.
    From 1999 to 2017, the largest negative daily return in history is -2.86% and
    the largest positive daily return is 3.61%. The first quartile, which is the middle
    number between the minimum and median, is at -0.36% and the third quartile, which
    is the middle number between the median and the maximum, is at 0.35%. From these
    summary statistics, we can see that the daily returns are spread almost symmetrically
    from 0%. To show this more visually, let''s now look at the histogram of daily
    returns. The code to plot a histogram of daily returns is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We used `HistogramBox` in the Accord.NET framework to build a histogram chart
    of daily returns. Here, we set the number of bins as `20`. You can increase or
    decrease the number of bins to show more or less granular buckets. When you run
    this code, the following chart is what you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Similar to what we have observed in the summary statistics, daily returns are
    spread almost symmetrically from 0%. This histogram of daily returns shows a clear
    bell curve, which suggests that daily returns follow a normal distribution.
  prefs: []
  type: TYPE_NORMAL
- en: The full code that we ran for this data analysis step can be found at this link: [https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/DataAnalyzer.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/DataAnalyzer.cs).
  prefs: []
  type: TYPE_NORMAL
- en: Feature engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a better understanding of the distribution of daily returns,
    let's start building features for our ML modeling. In this step, we are going
    to discuss a couple of frequently used technical indicators that traders in the
    foreign exchange market use and how we can build features for our ML models using
    those technical indicators.
  prefs: []
  type: TYPE_NORMAL
- en: Moving average
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first set of features we are going to build moving averages. A moving average
    is a rolling average for a pre-defined number of periods and is an often used
    technical indicator. A moving average helps smooth out volatile price movements
    and shows the overall trends of price actions. An in-depth discussion about how
    moving averages are used in trading financial assets is beyond the scope of this
    book, but in short, looking at multiple moving averages with different timeframes
    helps traders to identify trends and support and resistance levels for trading.
    In this chapter, we are going to use four moving averages, where the look-back
    periods are 10 days, 20 days, 50 days, and 200 days. The following code shows
    how we can compute moving averages using the `Window` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Window` method in the Deedle framework helps us easily compute moving
    averages. The `Window` method takes a data frame and builds a series of data frames
    where each data frame contains a pre-defined number of records. For example, if
    your input to the `Window` method is `10`, then it is going to build a series
    of data frames, where the first data frame contains records from the 0th index
    to the 9^(th) index, the second data frame contains records from the 1^(st) index
    to the 11^(th) index, and so forth. Using this method, we can easily compute moving
    averages for different time windows, as shown in the code. Now, let''s plot a
    time series close price chart with these moving averages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from this chart, moving averages smooth out volatile price movements.
    The red line shows moving averages of 10 days, the green line shows moving averages
    of 20 days, the black line for 50 days, and the pink line for 200 days. As you
    can see from this chart, the shorter the time window the closer it follows price
    actions and the less smooth the chart is. The code we used to generate this chart
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With these moving averages we just calculated, the actual features that we
    are going to use for our model are the distances between the close price and the
    moving averages. As briefly mentioned, moving averages often work as support and
    resistance levels and by looking at how far each price point is from each of the
    moving averages, we can figure out whether we are approaching the support and
    resistance lines. The code to calculate the distances between the close price
    and the moving averages is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Bollinger Bands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second technical indicator that we are going to look at is Bollinger Bands. Bollinger
    Bands comprise a moving average and the moving standard deviation of the same
    time window as the moving average that it is using. Then, Bollinger Bands are
    plotted two standard deviations above and below the moving average on the price
    time series chart. We will use a 20-day time window for computing Bollinger Bands.
    The code to compute Bollinger Bands is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, we are using the `Window` and `StdDev` methods
    to calculate moving standard deviations. Then, we calculate the upper and lower
    boundaries of Bollinger Bands by adding and subtracting two standard deviations
    from 20-day moving averages. When you plot Bollinger Bands with price series,
    the result looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The blue line shows the price movements, the green line shows 20-day moving
    averages, the red line shows the upper boundary of Bollinger Bands, which is two
    standard deviations above the moving averages, and the black line shows the lower
    boundary of Bollinger Bands, which is two standard deviations below the moving
    averages. As you can see from this chart, Bollinger Bands form bands around the
    price movements. The code to display this chart is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the previous case of moving averages, we are going to use the distances
    between the close price and Bollinger Bands. Since most of the trades are made
    between the upper and lower bands, the distances between the price and the bands
    can be features for our ML models. The code to calculate the distances is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Lagged variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, the last set of features we are going to use is lagged variables.
    Lagged variables contain information about previous periods. For example, if we
    use the daily return value of a previous day as a feature for our model, then
    it is a lagged variable that lagged one period. We can also use the daily return
    of two days prior to the current date as a feature for our model. These types
    of variable are called **lagged variables** and are often used in time series
    modeling. We are going to use daily returns and previously built features as lagged
    variables. In this project, we look back as far as five periods, but you can experiment
    with longer or shorter look-back periods. The code to create lagged variables
    for daily returns is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can create lagged variables for the differences between moving
    averages and the close prices, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we can create lagged variables for Bollinger Band indicators, using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from these code snippets, it is very simple and straightforward
    to create such lagged variables. We can simply use the `Shift` method in the Deedle
    framework and change the input to the method according to the look-back period.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing we are going to do in this section is drop the missing values.
    Because we were building many time series features, we created a lot of missing
    values. For example, when we calculate 200-day moving averages, the first 199
    records will have no moving averages, and as a result will have missing values.
    When you happen to have missing values in your dataset, there are two ways you
    can handle them—you can either encode them with certain values, or drop the missing
    values from the dataset. Since we have enough data, we are going to drop all the
    records with missing values. The code for dropping missing values from our data
    frame is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, the Deedle framework has a handy function that
    we can use to drop missing values. We can use the `DropSparseRows` method to drop
    all the missing values. When you run this code, your output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from this output, it dropped 250 records for having missing
    values. The full code to run the data analysis step from end to end can be found
    at this link: [https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/FeatureEngineer.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/FeatureEngineer.cs).'
  prefs: []
  type: TYPE_NORMAL
- en: Linear regression versus SVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to build models that are completely different
    from previous chapters. We are going to build models that predict continuous variables
    and provide a daily return of EUR/USD exchange rates, and we are going to use
    two new learning algorithms, linear regression and SVM. Linear regression models
    try to find linear relationships between the target variables and the features,
    whereas SVM models try to build hyperplanes that maximize the distances between
    different classes. For this foreign exchange rate forecasting project, we are
    going to discuss how to build linear regression and SVM models for regression
    problems in C# using the Accord.NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we build models, we will have to split our sample set into two subsets—one
    for training and another for testing. In the previous chapter, we used `SplitSetValidation`in
    the Accord.NET Framework to randomly split a sample set into train and test sets
    at a pre-defined proportion. However, we cannot apply the same approach in this
    chapter. Since we are dealing with time series data, we cannot randomly select
    and split records into train and test sets. If we do randomly split the sample
    set, then we are going to have cases where we train our ML models with future
    events and test our models on past events. So, we want to split our sample set
    at a certain point in time and take the records up to that point into a train
    set and the records after that point into a test set. The following code shows
    how we split our sample set into train and test sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to start building model objects and training our ML models.
    Let''s first look at how to instantiate a linear regression model. The code we
    used to train a linear regression model is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now look at another learning algorithm and model that we are going to
    use in this chapter. The following code shows how to build and train a SVM model
    for regression problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, we are using `LinearRegressionNewtonMethod` as
    a learning algorithm to train a SVM model. `LinearRegressionNewtonMethod`is a
    learning algorithm for SVM using linear kernel. Simply put, a kernel is a way
    of projecting data points onto another space where the data points are more separable
    than in the original space. Other kernels, such as polynomial and Gaussian kernels,
    are also often used when training SVM models. We will experiment with and further
    discuss these other kernels in the next chapter, but you can certainly experiment
    with the model performances on other kernels for this project. When making predictions
    with a trained SVM model, you can use the `Score` method, as shown in the code
    snippet.
  prefs: []
  type: TYPE_NORMAL
- en: The full code that we used to train and validate linear regression and SVM models
    can be found here: [https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/Modeling.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/Modeling.cs).
  prefs: []
  type: TYPE_NORMAL
- en: Model validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have built and trained regression models for this chapter's foreign
    exchange rate forecast project, let's start looking into how our models performed.
    In this section, we are going to discuss two commonly used basic metrics, RMSE,
    and R², and a diagnostic plot, actual or observed values versus predicted values.
    Before we delve into those metrics and a diagnostic plot, let's first briefly
    discuss how to extract coefficient and intercept values from the linear regression
    model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, you will see an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.gif)'
  prefs: []
  type: TYPE_IMG
- en: Looking at the coefficients and intercept of the fitted linear regression model
    helps us understand the model and gain some insights into how each feature affects
    the prediction results. The fact that we can understand and visualize exactly
    how the relationships between the features and the target variable are formed
    and how they interact with each other makes linear regression models still attractive,
    even though other black-box models, such as random forest models or support vector
    machines, often outperform linear regression models. As you can see from this
    output, you can easily tell which features affect daily return predictions negatively
    or positively and the magnitudes of their impacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the first metrics that we are using for regression model
    validation in this chapter. You might already be familiar with RMSE, which measures
    the square root of the errors between the predicted values and the actual values.
    The lower RMSE values are, the better the model fit is. The following code shows
    how you can compute the RMSE of the model fit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, we are using the `SquareLoss` class in the Accord.NET
    framework, which computes the squared values of the differences between the predicted
    and the actual values. In order to get the RMSE, we need to take a square root
    of this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next metric that we are going to look at is R². R^(*2*) is frequently used
    as an indicator of the goodness of fit. The closer the value is to 1, the better
    the model fit. The following code shows how we can compute R² values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, we are using the `RSquaredLoss` class in the
    Accord.NET framework. We are computing once for in-sample predictions (predictions
    on the train set) and once for out-of-sample predictions (predictions on the test
    set). The closer the two values are, the less overfitting the models.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this code for RMSE and R² for the linear regression model, the
    following is an output you will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'And for the SVM model, the output you will see is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.gif)'
  prefs: []
  type: TYPE_IMG
- en: From these outputs, we can see that the SVM model outperforms the linear regression
    model by a large amount. The SVM model has a much lower RMSE compared to the linear
    regression model. Also, the SVM model has a much higher R² value than the linear
    regression model. Note the R² value for the linear regression model. This happens
    when the fit of the model is worse than a simple horizontal line, and this suggests
    that our linear regression model fit is not good. On the other hand, the R² for
    the SVM model is about 0.26, which suggests that 26% of the target variable variance
    can be explained by this model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we are going to look at a diagnostic plot; actual values versus predicted
    values. This diagnostic plot is a good way to visually see the goodness of the
    model fit. Ideally, we would want all the points to be on a diagonal line. For
    example, if the actual value is 1.0, then we would want to have predicted value
    close to 1.0\. The closer the points are to the diagonal line, the better the
    model fit is. You can use the following code to plot actual values against predicted
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `ScatterplotBox` class in the Accord.NET framework to build
    a scatter plot of actual values against predicted values. When you run this code
    for linear regression model results, you will see the following diagnostic plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you run the same code for the SVM model results, the diagnostic plot appears
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from these plots, predictions from the linear regression model
    are more clogged around 0, while those from the SVM model are more spread out
    across a wider range. Although both plots for the linear regression and SVM model
    results do now show a perfect diagonal line, the plot for the SVM model shows
    better results and is aligned with the results we have seen from the RMSE and
    R² metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method we wrote and used to run validations for the models is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built and trained our first regression models. We used a
    time series dataset that contains historical daily exchange rates between Euros
    and U.S. Dollars from 1999 to 2017\. We first discussed how to create a target
    variable from an unlabeled raw dataset and how to apply the `Shift` and `Diff`
    methods in the Deedle framework in order to compute daily returns and create the
    target variable, which is the daily return for one period ahead. We further looked
    at the distributions of daily returns in a few different ways, such as a time
    series line chart, summary statistics using mean, standard deviation, and quantiles.
    We also looked at the histogram of daily returns and saw a well-drawn bell curve
    that follows a normal distribution. Then, we covered a few frequently used technical
    indicators in the foreign exchange market and how to apply them to our feature
    building processes. Using technical indicators, such as moving averages, Bollinger
    Bands, and lagged variables, we built various features that help our learning
    algorithms to learn how to predict future daily returns. With these features that
    we built in the feature engineering step, we built linear regression and SVM models
    to forecaste EUR/USD rates. We learned how to extract coefficients and the intercept
    from the `MultipleLinearRegression`object to gain insights into, and a better
    understanding, of how each feature affects the outcome of predictions. We briefly
    discussed the usage of kernels in building SVM models. Lastly, we went over two
    frequently used metrics for regression models, RMSE and R², and a diagnostic plot
    of actual values versus predicted values. From this model validation step, we
    observed how the SVM model outperformed the linear regression model by a large
    amount. We also discussed the comparative benefits of explainability we can gain
    from using the linear regression model, compared to other black-box models such
    as random forest and SVM models.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to extend our knowledge and experience by
    building regression models in C# using the Accord.NET framework. We will use a
    house price dataset that contains both continuous and categorical variables and
    learn how to build regression models for such a complex dataset. We will also
    discuss various other kernels we can use for SVMs and how they affect the performance
    of our SVM models.
  prefs: []
  type: TYPE_NORMAL
