- en: Image Filtering and Transformations in OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn the basic building blocks for computer vision
    applications. We are already familiar with digital cameras and smartphone devices
    with auto image enhancement or color adjustments to make our photographs more
    pleasing. The techniques behind these originated long ago and have come through
    several iterations to become better and faster. Many of the techniques explained
    in this chapter also become major preprocessing techniques for object detection
    and object classification tasks introduced later. Hence, it is very important
    to study these techniques and understand their applications.
  prefs: []
  type: TYPE_NORMAL
- en: You will study the basis for these applications with several techniques for
    filtering an image linearly as well as non-linearly.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the chapter, you will also study transformation techniques and downsampling
    techniques. A code is provided together with explanations and sample output. Readers
    are encouraged to write the code and experiment with changing parameters to understand
    several concepts. There are several colored image results in this chapter, for
    an effective understanding download the images from book's website.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Datasets and libraries required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformations on an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image pyramids
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Datasets and libraries required
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using a sample image for most of this task. However, you can try
    the code with any other image or also use a webcam to see live results. The libraries
    used in this chapter are `OpenCV`, `NumPy`, and `matplotlib`. Even if you are
    not acquainted with libraries, you can still understand the code and implement
    them. There are also remarks for special cases when using a Jupyter notebook for
    the code written here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The sample image used in this chapter can be loaded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This image can be plotted either using `OpenCV` or `matplotlib` libraries.
    We will be using `matplotlib` for the majority of plots as this will be beneficial
    in plotting other kinds of data as well in later chapters. A plotting function
    for a colored image read in `OpenCV` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The previously read image can be plotted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f28cc829-37ea-4a73-b5bb-4a0074939687.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The image in Python is a NumPy array, so all of the array operations are still
    valid in the image. For example, you can crop an image by using array slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3dfa0d43-e7b1-4684-8701-ab22ab36d5ef.png)'
  prefs: []
  type: TYPE_IMG
- en: Image manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As explained in previous chapters, an image in the digital domain, such as on
    a computer, is made up of a grid-like structure with each grid cell termed a **pixel**.
    These pixels store a value representing information about the image. For a simple
    grayscale image, these pixels store an integer with range [0, 255]. Changing these
    pixel values also changes the image. One of the basic image manipulation techniques
    is modifying pixel values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by displaying what is inside an image at pixel level. For simplicity,
    we will do analysis on a grayscale image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The earlier code reads a grayscale image from a file, in this case the image
    is in PNG format. We can also convert from one type of image color format to another.
    In this case, to convert a colored image to grayscale, `OpenCV` provides functions
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The previously shown code for displaying an image takes only a colored image
    as input, so to display a grayscale image there needs to be some modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddb8d425-b42f-4561-886a-0918e0a1e6f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can display a small patch from this image as follows, that shows pixel values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce an image of the patch and prints out the value extracted
    in that patch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32168a89-43ce-44a6-81bc-0dda59da5563.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Corresponding values are as follows, the lower values represent more darker
    regions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These are the intensities for a pixel and is represented as a two-dimensional
    array. The range of each pixel value is 0-255\. In order to modify image, we change
    these pixel values. A simple filtering for images is applying point operation
    targeted to multiply and add constants to each pixel values. We will see this
    type of filters in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw basic IO extending our discussion from [Chapter 1](prac-cv_ch01.html), *A
    Fast Introduction to Computer Vision*. In further section, we will see how to
    modify these using filters which are used in image editing applications on smartphones,
    desktops and even on social media applications.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filters are operations on an image to modify them so that they are usable for
    other computer vision tasks or to give us required information. These perform
    various functions such as removing noise from an image, extracting edges in an
    image, blurring an image, removing unwanted objects etc. We will see their implementations
    and understand the results.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering techniques are necessary because there are several factors that may
    lead to noise in an image or undesired information in an image. Taking a picture
    in sunlight, induces lots of bright and dark areas in the image or an improper
    environment like night time, the image captured by a camera may contain a lot
    of noise. Also, in cases of unwanted objects or colors in an image, these are
    also considered noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of salt and pepper noise looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/832dbbce-3b05-4208-9746-619c5d1d7f35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding image can be easily generated using OpenCV as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add weighted noise to a grayscale image (on the left) so the resulting
    image will look like the one on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e1e664e-4a85-47ec-8455-00cab6441e06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, `0.2` is used as parameter, increase or decrease the value to create different
    intensity noise.
  prefs: []
  type: TYPE_NORMAL
- en: In several applications, noise plays an important role in improving a system's
    capabilities, especially when we will use Deep Learning based models in the upcoming
    chapters. It is quite crucial for several applications, to know how robust the
    application is against noise becomes very important. As an example, we would want
    the model designed for applications like image classification to work with noisy
    images as well, hence noise is deliberately added in the images to test the application
    precision.
  prefs: []
  type: TYPE_NORMAL
- en: Linear filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin with, the simplest kind of filter is a point operator, where each
    pixel value is multiplied by a scalar value. This operation can be written as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acf011fc-6afd-45e3-8d9c-5a9ba99c771f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: The input image is F and the value of pixel at *(i,j)* is denoted as *f(i,j)*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output image is G and the value of pixel at *(i,j) *is denoted as *g(i,j)*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*K* is scalar constant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such an operation on an image is termed a **linear** **filter**. There are
    many more kinds of linear filters which you will be reading about further in this
    section. In addition to multiplication by a scalar value, each pixel can also
    be increased or decreased by a constant value. So overall point operation can
    be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60552f1f-9e00-47fc-823f-a5057422b8e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This operation can be applied both to grayscale images and RGB images. For
    RGB images, each channel will be modified with this operation separately. The
    following is the result of varying both *K* and *L*. The first image is input
    on the left. In the second image, `*K*=0.5` and `*L*=0.0`, while in the third
    image, *K* is set to `1.0` and *L* is `10`. For the final image on the right,
    `*K*=0.7` and `*L*=25`. As you can see, varying *K* changes the brightness of
    the image and varying *L* changes the contrast of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3550feb8-129d-42f3-94a1-27361f68de4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This image can be generated with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 2D linear filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the preceding filter is a point-based filter, image pixels have information
    around the pixel as well. In the previous image of the flower, the pixel values
    in the petal are all yellow. If we choose a pixel of the petal and move around,
    the values will be quite close. This gives some more information about the image.
    To extract this information in filtering, there are several neighborhood filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In neighborhood filters, there is a kernel matrix which captures local region
    information around a pixel. To explain these filters, let''s start with an input
    image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eef640fc-0d99-4136-bd18-bce5b1f26cc9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a simple binary image of the number 2\. To get certain information
    from this image, we can directly use all the pixel values. But instead, to simplify,
    we can apply filters on this. We define a matrix smaller than the given image
    which operates in the neighborhood of a target pixel. This matrix is termed **kernel**; an
    example is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b892f25-b7e8-40cb-a8ad-18db2bf256fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The operation is defined first by superimposing the kernel matrix on the original
    image, then taking the product of the corresponding pixels and returning a summation
    of all the products. In the following figure, the lower 3 x 3 area in the original
    image is superimposed with the given kernel matrix and the corresponding pixel
    values from the kernel and image are multiplied. The resulting image is shown
    on the right and is the summation of all the previous pixel products:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66b04090-921d-488b-b5c6-37f1fa8e8e7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This operation is repeated by sliding the kernel along image rows and then
    image columns. This can be implemented as in following code. We will see the effects
    of applying this on an image in coming sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as you can see previously, the corner pixel will have a drastic impact
    and results in a smaller image because the kernel, while overlapping, will be
    outside the image region. This causes a black region, or holes, along with the
    boundary of an image. To rectify this, there are some common techniques used:'
  prefs: []
  type: TYPE_NORMAL
- en: Padding the corners with constant values maybe 0 or 255, by default `OpenCV`
    will use this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mirroring the pixel along the edge to the external area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pattern of pixels around the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice of these will depend on the task at hand. In common cases, padding
    will be able to generate satisfactory results.
  prefs: []
  type: TYPE_NORMAL
- en: The effect of the kernel is most crucial as changing these values changes the
    output significantly. We will first see simple kernel-based filters and also see
    their effects on the output when changing the size.
  prefs: []
  type: TYPE_NORMAL
- en: Box filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This filter averages out the pixel value as the kernel matrix is denoted as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a69e58ed-7853-40df-b3e2-5d7f5ce62526.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Applying this filter results in blurring the image. The results are as shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1454f664-20c7-49a1-b53b-ac0a35a0153f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In frequency domain analysis of the image, this filter is a low pass filter.
    The frequency domain analysis is done using Fourier transformation of the image,
    which is beyond the scope of this introduction. We can see on changing the kernel
    size, the image gets more and more blurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2c49b04-1730-40ea-b3a4-ef664ec4eaec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we increase the size of the kernel, we can observe that resulting image
    gets more blurred. This is due to averaging out of peak values in the small neighborhood
    where the kernel is applied. The result for applying kernel of size 20 x 20 can
    be seen in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d799059-e43e-4a7c-bded-a7f40456a585.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if we use a very small filter of size (3, 3) there is negligible effect
    on the output, due to the fact that the kernel size is quite small compared to
    the photo size. In most applications, kernel size is heuristically set according
    to image size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/524cdf06-249f-425f-b360-aaa7e1cd0e85.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The complete code to generate box filtered photos is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Properties of linear filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Several computer vision applications are composed of step by step transformations
    of an input photo to output. This is easily done due to several properties associated
    with a common type of filters, that is, linear filters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The linear filters are commutative such that we can perform multiplication
    operations on filters in any order and the result still remains the same:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*a * b = b * a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'They are associative in nature, which means the order of applying the filter
    does not effect the outcome:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(a * b) * c = a * (b * c)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even in cases of summing two filters, we can perform the first summation and
    then apply the filter, or we can also individually apply the filter and then sum
    the results. The overall outcome still remains the same:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*b = (k+l) * a*'
  prefs: []
  type: TYPE_NORMAL
- en: Applying a scaling factor to one filter and multiplying to another filter is
    equivalent to first multiplying both filters and then applying scaling factor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These properties play a significant role later, when we look at computer vision
    tasks such as object detection, segmentation, and so on. A suitable combination
    of these filters enhances the quality of information extraction and as a result,
    improves the accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Non-linear filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While in many cases linear filters are sufficient to get the required results,
    in several other use cases performance can be significantly increased with the
    use of non-linear filters. As the name suggests, these filters are composed of
    more complex operations, have some kind of non-linearity, and as a result these
    filters do not follow some or all of the properties of linear filters.
  prefs: []
  type: TYPE_NORMAL
- en: We will understand these filters with implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Smoothing a photo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying a box filter with hard edges doesn't result in a smooth blur on the
    output photo.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve this, the filter can be made smoother around the edges. One of the
    popular such filters is a **Gaussian filter**. This is a non-linear filter which
    enhances the effect of the center pixel and gradually reduces the effects as the
    pixel gets farther from the center. Mathematically, a Gaussian function is given
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c1a20e0-6024-4028-9d72-f812f13151ff.png)'
  prefs: []
  type: TYPE_IMG
- en: where μ is mean and σ is variance.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example kernel matrix for this kind of filter in a two-dimensional discrete
    domain is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa06aa76-4958-476d-836d-aab5b7801689.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This two-dimensional array is used in normalized form and effect of this filter
    also depends on its width by changing the kernel width has varying effects on
    the output as discussed in further section. Applying Gaussian kernel as filter
    removes high-frequency components which results in removing strong edges and hence
    a blurred photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/560325e5-14f4-44f4-ac22-76439f27394b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While this filter performs better blurring than a box filter, the implementation
    is also quite simple with OpenCV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Histogram equalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic point operations, to change the brightness and contrast, help in
    improving photo quality but require manual tuning. Using histogram equalization
    technique, these can be found algorithmically and create a better-looking photo.
    Intuitively, this method tries to set the brightest pixels to white and the darker
    pixels to black. The remaining pixel values are similarly rescaled. This rescaling
    is performed by transforming original intensity distribution to capture all intensity
    distribution. An example of this equalization is as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2e536d1-f279-4e31-94bd-d14d78cbb990.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding image is an example of histogram equalization. On the right is
    the output and, as you can see, the contrast is increased significantly. The input
    histogram is shown in the bottom figure on the left and it can be observed that
    not all the colors are observed in the image. After applying equalization, resulting
    histogram plot is as shown on the right bottom figure. To visualize the results
    of equalization in the image, the input and results are stacked together in following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/310afc41-7651-464e-aa2e-0e8d4b2bd65e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Code for the preceding photos is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Median filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This filter uses the same technique of neighborhood filtering; the key technique
    in this is the use of a median value. As such, the filter is non-linear. It is
    quite useful in removing sharp noise such as salt and pepper.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using a product or sum of neighborhood pixel values, this filter
    computes a median value of the region. This results in the removal of random peak
    values in the region, which can be due to noise like salt and pepper noise. This
    is further shown in the following figure with different kernel size used to create
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this image first input is added with channel wise random noise as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The created noisy image is used for median filtering as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following photo, you can see the resulting photo after varying the kernel
    size (indicated in brackets). The rightmost photo is the smoothest of them all:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e6b982a-c653-4e59-9017-302280a84143.png)'
  prefs: []
  type: TYPE_IMG
- en: The most common application for median blur is in smartphone application which
    filters input image and adds additional artifacts to add artistic effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to generate the preceding photograph is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Image gradients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are more *edge detectors* or sharp changes in a photograph. Image gradients
    widely used in object detection and segmentation tasks. In this section, we will
    look at how to compute image gradients. First, the image derivative is applying
    the kernel matrix which computes the change in a direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sobel filter is one such filter and kernel in the *x *direction is given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a5dd501-0ded-40c5-8978-38357785667b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, in the *y *direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b51855e0-69c3-4f41-a6a6-c6cff1f279b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is applied in a similar fashion to the linear box filter by computing
    values on a superimposed kernel with the photo. The filter is then shifted along
    the image to compute all values. Following is some example results, where *X*
    and *Y* denote the direction of the Sobel kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec732c3c-95a0-4d6f-b690-9ef80b6f877f.png)'
  prefs: []
  type: TYPE_IMG
- en: This is also termed as an image derivative with respect to given direction(here
    X or Y). The lighter resulting photographs (middle and right) are positive gradients,
    while the darker regions denote negative and gray is zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Sobel filters correspond to first order derivatives of a photo, the Laplacian
    filter gives a second-order derivative of a photo. The Laplacian filter is also
    applied in a similar way to Sobel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbbbf462-e1ab-419c-8a1f-1c8d9f2933df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code to get Sobel and Laplacian filters is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Transformation of an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transformation operations on an image are usually referred to as geometric transformations,
    applied on a photo. There are several other kinds of transformations as well but
    in this section we will refer to geometric transformations. These consist of,
    but are not limited to, shifting an image, rotating an image along an axis, or
    projecting it onto different planes.
  prefs: []
  type: TYPE_NORMAL
- en: At the core of transformation is a matrix multiplication of our image. We will
    look at different components of this matrix and the resulting image.
  prefs: []
  type: TYPE_NORMAL
- en: Translation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Displacement of an image in any direction can be done by creating a transformation
    matrix and applying the transformation to our image. The transformation matrix
    for translation only is given as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1d16c6a-71f3-4e89-b5a3-259913998bb3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'where *t[x]* is translation in *x* direction and *t[y]* in *y* direction in
    image reference. On choosing different values of translation matrix, results are
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb52c7e8-32e0-42db-aa93-ef25e6449def.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous figure, output is images are larger than the input image to
    show the effects of translation otherwise only visible region of images which
    are inside the original image size will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code for creating this translation is given as follows, here change the values
    of `tx` and `ty` to generate different translations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Rotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to translation, rotating an image is also possible by creating a transformation
    matrix. Instead of creating translation matrix, in `OpenCV`, given a rotation
    angle θ, a rotation matrix is created of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/587e03b9-ffdb-4b57-9be5-50036accd864.png)'
  prefs: []
  type: TYPE_IMG
- en: where,
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41e76660-f4cb-4a31-b01e-e55cf7a96bdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of applying result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8018b5d3-c2c3-45e1-9843-cf02e1c30336.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the previous screenshot, the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, transformations also can be done by combining both rotation and translation
    with scaling and as a result, the angle between the lines will be preserved.
  prefs: []
  type: TYPE_NORMAL
- en: Affine transform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With an Affine transform, only parallel lines will be preserved in the output.
    An example output image is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65de58b3-1166-42a6-b0c2-087721d67790.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code for the preceding image is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Image pyramids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pyramids refer to rescaling a photograph either increasing the resolution or
    decreasing it. These are often used to increase the computation efficiency of
    computer vision algorithms such as image matching in a huge database. In such
    cases, image matching is computed on a downsampled image and later on the search
    is iteratively refined for a higher resolution of the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The downsampling and upsampling often depend on the pixel selection process.
    One of the simplest processes is selecting alternative rows and column pixel values
    to create a downsampled version of the photo as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f47cd63-6f43-4d7a-852a-60856e46c764.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if we try to upsample from the rightmost picture in the previous figure,
    the results look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6bdefdf-a24f-4d3d-87a6-4954af6b19ff.png)'
  prefs: []
  type: TYPE_IMG
- en: It can easily be seen that the rightmost picture above is not the same as the
    original one that we started with. This is due to the fact that we lose information
    during downsampling and hence the image cannot be recreated in the same way as
    the original one. In `OpenCV`, there is also blurring of input image before downsampling
    or upsampling. This also further makes it harder to keep the resolution intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'The codes for downsampling is as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And for upsampling an image to twice its height and width sizes as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with initial image analysis by applying various
    manipulation. We began discussion with point filters and extending to more complex
    linear as well as non linear filters. We saw the visualization of results on varying
    parameters like kernel size, and so on. The non-linear filters, like histogram
    equalization, can further tune images which are difficult to do with linear filters.
    Image gradients, introduced in this chapter, are quite common in complex tasks
    of object detection, image segmentation, and so on. We also saw various transformation
    methods like translation, rotation and affine transformation with visualization
    of the output given different choice of parameters. The various transformations
    can applied in cascaded fashion to create combined transformed results. Lastly,
    image downsampling and upsampling method is introduced which has crucial role
    in making computation faster or extracting more richer information respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be going through different features and feature
    extraction methods with the importance for each.
  prefs: []
  type: TYPE_NORMAL
