- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Foundations of Quantum Computing
  prefs: []
  type: TYPE_NORMAL
- en: '*The beginning is always today.*'
  prefs: []
  type: TYPE_NORMAL
- en: — Mary Shelley
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard that the mathematics needed to understand quantum computing
    is arcane, mysterious and difficult…but we utterly disagree! In fact, in this
    chapter, we will introduce all the concepts that you will need in order to follow
    the quantum algorithms that we will be studying in the rest of the book. Actually,
    you may be surprised to see that we will only rely on some linear algebra and
    a bit of (extremely simple) trigonometry.
  prefs: []
  type: TYPE_NORMAL
- en: We shall start by giving a quick overview of what quantum computing is, what
    the current state of the art is, and what the main applications are expected to
    be. After that, we will introduce the **model of quantum circuits**. There are
    several computational models for quantum computing, but this is the most popular
    one and, moreover, it’s the one that we will be using throughout most of the book.
    Then, we will describe in detail what qubits are, how we can operate on them by
    using quantum gates, and how we can retrieve results by performing measurements.
    We will start with the simplest possible case — just a humble qubit! Then, we
    will steadily build upon that until we learn how to work with as many qubits as
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Quantum computing: the big picture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of the quantum circuit model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with one qubit and the Bloch sphere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with two qubits and entanglement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with multiple qubits and universality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you will have acquired a solid understanding of
    the fundamentals of quantum computing and you will be more than ready to learn
    how practical quantum algorithms are developed.
  prefs: []
  type: TYPE_NORMAL
- en: '1.1 Quantum computing: the big picture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In October 2019, an announcement made by a team of researchers from Google took
    the scientific world by storm. For the first time ever, a practical demonstration
    of quantum computational advantage had been shown. The results, published in the
    prestigious Nature journal [[9](ch030.xhtml#Xarute2019quantum)], reported that
    a quantum computer had solved, in just a few minutes, a problem that would have
    taken the most powerful classical supercomputer in the world thousands of years.
  prefs: []
  type: TYPE_NORMAL
- en: Although the task solved by the quantum computer has no direct practical applications
    and it was later claimed that the computing time with classical resources had
    been overestimated (see [[75](ch030.xhtml#Xpednault2019quantum)] and, also, [[73](ch030.xhtml#Xpan2022solving)]),
    this feat remains a milestone in the history of computing and has fueled interest
    in quantum computing all over the world. So, what can these mysterious quantum
    computers do? How do they work in order to achieve these mind-blowing speed-ups?
  prefs: []
  type: TYPE_NORMAL
- en: We could define quantum computing as the study of the application of properties
    of quantum systems (such as superposition, entanglement, and interference) to
    accelerate some computational tasks. These properties do not manifest in our macroscopic
    world and, although they are present at the fundamental level in our computing
    devices, they are not explicitly used in the traditional computing models that
    we employ to build our microprocessors and to design our algorithms. For this
    reason, quantum computers behave in a radically different way to classical computers,
    making it possible to solve some tasks much more efficiently than with traditional
    computing devices.
  prefs: []
  type: TYPE_NORMAL
- en: The most famous problem for which quantum algorithms offer a huge advantage
    over classical methods is finding prime factors of big integers. The best known
    classical algorithm for this task requires an amount of time that grows almost
    exponentially with the length of the number (see *Appendix* *[*C*](ch026.xhtml#x1-233000C),
    *Computational Complexity*, for all the concepts referred to computational complexity,
    including exponential growth). Thus, factoring numbers that are several thousand
    bits long becomes infeasible with classical computers, and this inefficiency is
    the basis for some widely used cryptographic protocols, such as RSA, proposed
    by Rivest, Shamir, and Adleman [[80](ch030.xhtml#Xrivest1978method)].*
  prefs: []
  type: TYPE_NORMAL
- en: '*Nevertheless, more than twenty years ago, the mathematician Peter Shor proved
    in a celebrated paper [[87](ch030.xhtml#Xshor99polynomial)] that a quantum computer
    could factor numbers taking an amount of time that no longer grows exponentially
    with the size of the input, but only polynomially. Other examples in which quantum
    algorithms outperform classical ones include finding elements satisfying a given
    condition from an unsorted list (with Grover’s algorithm [[48](ch030.xhtml#Xgrover1996fast)])
    or sampling from the solutions of systems of linear equations (using the famous
    HHL algorithm [[49](ch030.xhtml#Xharrow2009quantum)]).'
  prefs: []
  type: TYPE_NORMAL
- en: Wonderful as the properties of these quantum algorithms are, they require quantum
    computers that are fault tolerant and more powerful than those available today.
    This is why, in the last few years, many researchers have focused on studying
    quantum algorithms that try to obtain some advantage with the noisy intermediate-scale
    quantum computers, also known as **NISQ** **devices**, that are at our disposal
    now. The **NISQ** name was coined by John Preskill in a greatly enjoyable article
    [[78](ch030.xhtml#Xpreskill2018quantum)] and has been widely adopted to describe
    the *evolutionary stage* in which quantum hardware currently is.
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning and optimization are two of the fields that are being actively
    explored in this NISQ era. In these areas, many interesting algorithms have been
    proposed in recent years; some examples are the **Quantum** **Approximate Optimization
    Algorithm** (**QAOA**), the **Variational** **Quantum Eigensolver** (**VQE**),
    or different quantum flavors of machine learning models, including **Quantum Support
    Vector Machines** (**QSVMs**) and **Quantum Neural Networks** (**QNNs**).
  prefs: []
  type: TYPE_NORMAL
- en: Since these algorithms are fairly new, we still lack a complete understanding
    of their full capabilities. However, some partial theoretical results show some
    evidence that these approaches can offer some advantages over what is possible
    with classical computers, for instance, by giving us better approximations to
    the solutions of hard **combinatorial optimization** **problems** or by showing
    better performance when learning from particular **datasets**.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the real possibilities of these NISQ computers and the algorithms
    designed to take advantage of them will be crucial in the short and medium term,
    and it may very likely pave the way for the first practical applications of quantum
    computing to real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: We believe that you can be part of the exciting task of making quantum computing
    applications a reality and we would like to help you on that journey. But, for
    that, we need to start by setting in place the tools that we will be using throughout
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: If you are already familiar with the quantum circuit model, you can skip the
    rest of this chapter. However, we recommend that you at least skim through the
    following sections so that you can get familiar with the conventions and choices
    of notation that we will use in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 The basics of the quantum circuit model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have mentioned that quantum computing relies on quantum phenomena such as
    **superposition**, **entanglement**, and **interference** to perform computations.
    But what does this really mean? To make this explicit, we need to define a particular
    computational model that allow us to describe mathematically how to take advantage
    of all these properties.
  prefs: []
  type: TYPE_NORMAL
- en: There are many such models, including **quantum Turing machines**, **measurement-based
    quantum computing** (also known as **one-way** **quantum computing**), or **adiabatic
    quantum computing**, and all of them are equivalent in power. However, the most
    popular one — and the one that we will be using for the most part in the book
    — is the **quantum circuit** **model**.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the quantum circuit model, sometimes we will also use the adiabatic
    model. All the necessary concepts will be introduced in *Chapter* *[*4*](ch012.xhtml#x1-750004),
    *Quantum Adiabatic Computing and Quantum Annealing*.*
  prefs: []
  type: TYPE_NORMAL
- en: '*Every computation has three elements: **data**, **operations**, and **output**.
    In the quantum circuit model, these correspond to some concepts that you may have
    already heard about: **qubits**, **quantum gates**, and **measurements**. Through
    the remainder of this chapter, we will briefly review all of them, highlighting
    some special details that will be of particular importance when talking about
    quantum machine learning and quantum optimization algorithms; at the same time,
    we will show the notation that will be used throughout the book. But before committing
    to that, let us have a quick overview of what a **quantum circuit** is.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at *Figure* *[*1.1*](#Figure1.1). It shows a simple quantum
    circuit. The three horizontal lines that you see are sometimes called **wires**,
    and they represent the qubits that we are working with. Thus, in this case, we
    have three qubits. The circuit is meant to be read from left to right, and it
    represents all the different operations that are performed on the qubits. It is
    customary to assume that, at the very beginning, all the qubits are in state ![\left|
    0 \right\rangle](img/file6.png "\left| 0 \right\rangle"). You do not need to worry
    yet about what ![\left| 0 \right\rangle](img/file6.png "\left| 0 \right\rangle")
    means, but please notice how we have indicated that this is indeed the initial
    state of all the wires by writing ![\left| 0 \right\rangle](img/file6.png "\left|
    0 \right\rangle") to the left of each of them.*
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 1.1: An example of a simple quantum circuit.](img/file7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 1.1**: An example of a simple quantum circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: In that circuit, we start by applying an operation called a ![Z](img/file8.png
    "Z") gate on the top qubit; we will explain in the next section what all of these
    operations do, but note that we represent them with little boxes with the name
    of the operation inside. After that initial ![Z](img/file8.png "Z") gate, we apply
    individual gates ![X](img/file9.png "X"), ![H](img/file10.png "H"), and ![Y](img/file11.png
    "Y") on the top, middle, and bottom qubits and, then, a two-qubit gate on the
    top and middle qubits followed by a three-qubit gate, which acts on all the qubits
    at the same time. Finally, we measure the top and bottom qubits (we will get to
    measurements in the next section, don’t worry), and we represent this in the circuit
    using the **gauge symbol**. Notice that, after these measurements, the wires are
    represented with double lines, to indicate that we have obtained a result — technically,
    we say that the state of the qubit has **collapsed** to a classical value. This
    means that, from this point on, we do not have quantum data anymore, only classical
    bits. This collapse may seem a little bit mysterious (it is!), but don’t worry.
    In the next section, we will explain in detail the process by which quantum information
    (qubits) is transformed into classical data (bits).
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, quantum circuits are somewhat similar to digital ones,
    in which we have wires representing bits and different logical gates such as **AND**,
    **OR**, and **NOT** acting on them. However, our qubits, quantum gates, and measurements
    obey the rules of quantum mechanics and show some properties that are not found
    in classical circuits. The rest of this chapter is devoted to explaining all of
    this in detail, starting with the simplest of cases, that of a single qubit, but
    growing all the way up to fully-fledged quantum circuits that can use as many
    qubits and gates as desired.
  prefs: []
  type: TYPE_NORMAL
- en: Ready? Let’s start, then!
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 Working with one qubit and the Bloch sphere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of using a computational model is that you can forget
    about the particularities of the physical implementation of your computer and
    focus instead on the properties of the elements on which you store information
    and the operations you can perform on them. For instance, we could define a qubit
    as a (physical) quantum system that is capable of being in two different states.
    In practice, it could be a photon with two possible polarizations, a particle
    with two possible values for its spin, or a superconducting circuit, whose current
    can be flowing in one of two directions. When using the quantum circuit model,
    we can forget about those implementation details and just define a qubit…as a
    mathematical vector!
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.1 What is a qubit?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In fact, a **qubit** (short for **quantum bit**, sometimes also written as **qbit**,
    **Qbit** or even **q-bit**) is the minimal information unit in quantum computing.
    In the same way that a **bit** (short for **binary digit**) can be in state ![0](img/file12.png
    "0") or in state ![1](img/file13.png "1"), a qubit can be in state ![\left| 0
    \right\rangle](img/file6.png "\left| 0 \right\rangle") or in state ![\left| 1
    \right\rangle](img/file14.png "\left| 1 \right\rangle"). Here, we are using the
    so-called **Dirac notation**, where these funny-looking symbols surrounding ![0](img/file12.png
    "0") and ![1](img/file13.png "1") are called **kets** and are used to indicate
    that we are dealing with vectors instead of regular numbers. In fact, ![\left|
    0 \right\rangle](img/file6.png "\left| 0 \right\rangle") and ![\left| 1 \right\rangle](img/file14.png
    "\left| 1 \right\rangle") are not the only possibilities for the state of a qubit
    and, in general, it could be in a **superposition** of the form
  prefs: []
  type: TYPE_NORMAL
- en: '![a\left| 0 \right\rangle + b\left| 1 \right\rangle,](img/file15.png "a\left|
    0 \right\rangle + b\left| 1 \right\rangle,")'
  prefs: []
  type: TYPE_IMG
- en: where ![a](img/file16.png "a") and ![b](img/file17.png "b") are complex numbers,
    called **amplitudes**, such that ![|a|^{2} + |b|^{2} = 1](img/file18.png "|a|^{2}
    + |b|^{2} = 1"). The quantity ![\sqrt{|a|^{2} + |b|^{2}}](img/file19.png "\sqrt{|a|^{2}
    + |b|^{2}}") is called the **norm** or **length** of the state and, when it is
    equal to ![1](img/file13.png "1"), we say that the state is **normalized**.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: If you need a refresher on complex numbers or vector spaces, please check *Appendix*
    *[*A*](ch024.xhtml#x1-225000A), *Complex Numbers*, and *Appendix* *[*B*](ch025.xhtml#x1-226000B),
    *Basic Linear* *Algebra*.**
  prefs: []
  type: TYPE_NORMAL
- en: '**All these possible values for the state of a single qubit are vectors that
    live in a complex vector space of dimension 2 (in fact, they live in what is called
    a **Hilbert space**, but since we will be working only with finite dimensions,
    there is no real difference). Thus we shall fix the vectors ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle") and ![\left| 1 \right\rangle](img/file14.png "\left|
    1 \right\rangle") as elements of a special **basis**, which we will refer to as
    the **computational basis**. We will represent these vectors, constituents of
    the computational basis, as the column vectors'
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| 0 \right\rangle = \begin{pmatrix} 1 \\ 0 \\ \end{pmatrix},\qquad\left|
    1 \right\rangle = \begin{pmatrix} 0 \\ 1 \\ \end{pmatrix}](img/file20.png "\left|
    0 \right\rangle = \begin{pmatrix} 1 \\ 0 \\ \end{pmatrix},\qquad\left| 1 \right\rangle
    = \begin{pmatrix} 0 \\ 1 \\ \end{pmatrix}")'
  prefs: []
  type: TYPE_IMG
- en: and hence
  prefs: []
  type: TYPE_NORMAL
- en: '![a\left| 0 \right\rangle + b\left| 1 \right\rangle = a\begin{pmatrix} 1 \\
    0 \\ \end{pmatrix} + b\begin{pmatrix} 0 \\ 1 \\ \end{pmatrix} = \begin{pmatrix}
    a \\ b \\ \end{pmatrix}.](img/file21.png "a\left| 0 \right\rangle + b\left| 1
    \right\rangle = a\begin{pmatrix} 1 \\ 0 \\ \end{pmatrix} + b\begin{pmatrix} 0
    \\ 1 \\ \end{pmatrix} = \begin{pmatrix} a \\ b \\ \end{pmatrix}.")'
  prefs: []
  type: TYPE_IMG
- en: 'If we are given a qubit and we want to determine or, rather, estimate its state,
    all we can do is perform a measurement and get one of two possible results: 0
    or 1\. We have nonetheless seen how a qubit can be in infinitely many states,
    so how does the state of a qubit determine the outcome of a measurement? As you
    likely already know, in quantum physics, these measurements are not deterministic,
    but probabilistic. In particular, given any qubit ![a\left| 0 \right\rangle +
    b\left| 1 \right\rangle](img/file22.png "a\left| 0 \right\rangle + b\left| 1 \right\rangle"),
    the probability of getting ![0](img/file12.png "0") upon a measurement is ![|a|^{2}](img/file23.png
    "|a|^{2}"), while that of getting ![1](img/file13.png "1") is ![|b|^{2}](img/file24.png
    "|b|^{2}"). Naturally, these two probabilities must add up to 1, hence the need
    for the **normalization** **condition** ![|a|^{2} + |b|^{2} = 1](img/file18.png
    "|a|^{2} + |b|^{2} = 1").'
  prefs: []
  type: TYPE_NORMAL
- en: If upon measuring a qubit we get, let’s say, ![0](img/file12.png "0"), we then
    know that, after the measurement, the state of the qubit is ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle"), and we say that the qubit has **collapsed** into that
    state. If we obtain ![1](img/file13.png "1"), the state collapses to ![\left|
    1 \right\rangle](img/file14.png "\left| 1 \right\rangle"). Since we are obtaining
    results that correspond to ![\left| 0 \right\rangle](img/file6.png "\left| 0 \right\rangle")
    and ![\left| 1 \right\rangle](img/file14.png "\left| 1 \right\rangle"), we say
    that we are **measuring in the computational basis**.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.1
  prefs: []
  type: TYPE_NORMAL
- en: What is the probability of measuring 0 if the state of a qubit is ![\sqrt{\left.
    1\slash 2 \right.}\left| 0 \right\rangle + \sqrt{\left. 1\slash 2 \right.}\left|
    1 \right\rangle](img/file25.png "\sqrt{\left. 1\slash 2 \right.}\left| 0 \right\rangle
    + \sqrt{\left. 1\slash 2 \right.}\left| 1 \right\rangle")? And the probability
    of measuring 1? What if the state of the qubit is ![\sqrt{\left. 1\slash 3 \right.}\left|
    0 \right\rangle + \sqrt{\left. 2\slash 3 \right.}\left| 1 \right\rangle](img/file26.png
    "\sqrt{\left. 1\slash 3 \right.}\left| 0 \right\rangle + \sqrt{\left. 2\slash
    3 \right.}\left| 1 \right\rangle")? And if it is ![\sqrt{\left. 1\slash 2 \right.}\left|
    0 \right\rangle - \sqrt{\left. 1\slash 2 \right.}\left| 1 \right\rangle](img/file27.png
    "\sqrt{\left. 1\slash 2 \right.}\left| 0 \right\rangle - \sqrt{\left. 1\slash
    2 \right.}\left| 1 \right\rangle")?
  prefs: []
  type: TYPE_NORMAL
- en: So a qubit is, mathematically, just a 2-dimensional vector that satisfies a
    normalization condition. Who could have known? But the surprises do not end here.
    In the next subsection, we will see how we can use those funny-looking kets to
    compute inner products in a very easy way.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.2 Dirac notation and inner products
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dirac notation can not only be used for column vectors, but also for row vectors.
    In that case, we talk of **bras**, which, together with kets, can be used to form
    **bra-kets**. This name is a pun, because, as we are about to show, bra-kets are,
    in fact, inner products that are written — you guessed it — between brackets.
    To be more mathematically precise, with each ket we can associate a bra that is
    its **adjoint** or **conjugate** **transpose** or **Hermitian transpose**. In
    order to obtain this adjoint, we take the ket’s column vector, we transpose it
    and conjugate each of its coordinates (which are, as we already know, complex
    numbers). We use ![\left\langle 0 \right|](img/file28.png "\left\langle 0 \right|")
    to denote the bra associated with ![\left| 0 \right\rangle](img/file6.png "\left|
    0 \right\rangle") and ![\left\langle 1 \right|](img/file29.png "\left\langle 1
    \right|") to denote the bra associated with ![\left| 1 \right\rangle](img/file14.png
    "\left| 1 \right\rangle"), so we have
  prefs: []
  type: TYPE_NORMAL
- en: '![\left\langle 0 \right| = \left| 0 \right\rangle^{\dagger} = \begin{pmatrix}
    1 \\ 0 \\ \end{pmatrix}^{\dagger} = \begin{pmatrix} 1 & 0 \\ \end{pmatrix},\qquad\left\langle
    1 \right| = \left| 1 \right\rangle^{\dagger} = \begin{pmatrix} 0 \\ 1 \\ \end{pmatrix}^{\dagger}
    = \begin{pmatrix} 0 & 1 \\ \end{pmatrix}](img/file30.png "\left\langle 0 \right|
    = \left| 0 \right\rangle^{\dagger} = \begin{pmatrix} 1 \\ 0 \\ \end{pmatrix}^{\dagger}
    = \begin{pmatrix} 1 & 0 \\ \end{pmatrix},\qquad\left\langle 1 \right| = \left|
    1 \right\rangle^{\dagger} = \begin{pmatrix} 0 \\ 1 \\ \end{pmatrix}^{\dagger}
    = \begin{pmatrix} 0 & 1 \\ \end{pmatrix}")'
  prefs: []
  type: TYPE_IMG
- en: and, in general,
  prefs: []
  type: TYPE_NORMAL
- en: '![a\left\langle 0 \right| + b\left\langle 1 \right| = a\left| 0 \right\rangle^{\dagger}
    + b\left| 1 \right\rangle^{\dagger} = a\begin{pmatrix} 1 & 0 \\ \end{pmatrix}
    + b\begin{pmatrix} 0 & 1 \\ \end{pmatrix} = \begin{pmatrix} a & b \\ \end{pmatrix},](img/file31.png
    "a\left\langle 0 \right| + b\left\langle 1 \right| = a\left| 0 \right\rangle^{\dagger}
    + b\left| 1 \right\rangle^{\dagger} = a\begin{pmatrix} 1 & 0 \\ \end{pmatrix}
    + b\begin{pmatrix} 0 & 1 \\ \end{pmatrix} = \begin{pmatrix} a & b \\ \end{pmatrix},")'
  prefs: []
  type: TYPE_IMG
- en: where, as it is customary, we use the dagger symbol (![\dagger](img/file32.png
    "\dagger")) for the adjoint.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When finding the adjoint, do not forget to conjugate the complex numbers! For
    instance, it holds that
  prefs: []
  type: TYPE_NORMAL
- en: '![\begin{pmatrix} \frac{1 - i}{2} \\ \frac{i}{\sqrt{2}} \\ \end{pmatrix}^{\dagger}
    = \begin{pmatrix} \frac{1 + i}{2} & \frac{- i}{\sqrt{2}} \\ \end{pmatrix}.](img/file33.png
    "\begin{pmatrix} \frac{1 - i}{2} \\ \frac{i}{\sqrt{2}} \\ \end{pmatrix}^{\dagger}
    = \begin{pmatrix} \frac{1 + i}{2} & \frac{- i}{\sqrt{2}} \\ \end{pmatrix}.")'
  prefs: []
  type: TYPE_IMG
- en: One of the reasons why Dirac notation is so popular for working with quantum
    systems is that, by using it, we can easily compute the inner products of kets
    and bras. For instance, we can readily show that
  prefs: []
  type: TYPE_NORMAL
- en: '![\left\langle 0 \middle| 0 \right\rangle = \begin{pmatrix} 1 & 0 \\ \end{pmatrix}\begin{pmatrix}
    1 \\ 0 \\ \end{pmatrix} = 1,\qquad\left\langle 0 \middle| 1 \right\rangle = \begin{pmatrix}
    1 & 0 \\ \end{pmatrix}\begin{pmatrix} 0 \\ 1 \\ \end{pmatrix} = 0,](img/file34.png
    "\left\langle 0 \middle| 0 \right\rangle = \begin{pmatrix} 1 & 0 \\ \end{pmatrix}\begin{pmatrix}
    1 \\ 0 \\ \end{pmatrix} = 1,\qquad\left\langle 0 \middle| 1 \right\rangle = \begin{pmatrix}
    1 & 0 \\ \end{pmatrix}\begin{pmatrix} 0 \\ 1 \\ \end{pmatrix} = 0,")'
  prefs: []
  type: TYPE_IMG
- en: '![\left\langle 1 \middle| 0 \right\rangle = \begin{pmatrix} 0 & 1 \\ \end{pmatrix}\begin{pmatrix}
    1 \\ 0 \\ \end{pmatrix} = 0,\qquad\left\langle 1 \middle| 1 \right\rangle = \begin{pmatrix}
    0 & 1 \\ \end{pmatrix}\begin{pmatrix} 0 \\ 1 \\ \end{pmatrix} = 1.](img/file35.png
    "\left\langle 1 \middle| 0 \right\rangle = \begin{pmatrix} 0 & 1 \\ \end{pmatrix}\begin{pmatrix}
    1 \\ 0 \\ \end{pmatrix} = 0,\qquad\left\langle 1 \middle| 1 \right\rangle = \begin{pmatrix}
    0 & 1 \\ \end{pmatrix}\begin{pmatrix} 0 \\ 1 \\ \end{pmatrix} = 1.")'
  prefs: []
  type: TYPE_IMG
- en: This proves that ![\left| 0 \right\rangle](img/file6.png "\left| 0 \right\rangle")
    and ![\left| 1 \right\rangle](img/file14.png "\left| 1 \right\rangle") are not
    just elements of any basis but of an **orthonormal** one, since ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle") and ![\left| 1 \right\rangle](img/file14.png "\left|
    1 \right\rangle") are orthogonal and of length 1\. Thus, we can compute the inner
    product of two states ![\left| \psi_{1} \right\rangle = a\left| 0 \right\rangle
    + b\left| 1 \right\rangle](img/file36.png "\left| \psi_{1} \right\rangle = a\left|
    0 \right\rangle + b\left| 1 \right\rangle") and ![\left| \psi_{2} \right\rangle
    = c\left| 0 \right\rangle + d\left| 1 \right\rangle](img/file37.png "\left| \psi_{2}
    \right\rangle = c\left| 0 \right\rangle + d\left| 1 \right\rangle") using Dirac
    notation by noting that
  prefs: []
  type: TYPE_NORMAL
- en: '![\begin{array}{rlrl} \left\langle \psi_{1} \middle| \psi_{2} \right\rangle
    & {= \left( {a^{\ast}\left\langle 0 \right| + b^{\ast}\left\langle 1 \right|}
    \right)\left( {c\left| 0 \right\rangle + d\left| 1 \right\rangle} \right)\qquad}
    & & \qquad \\ & {= a^{\ast}c\left\langle 0 \middle| 0 \right\rangle + a^{\ast}d\left\langle
    0 \middle| 1 \right\rangle + b^{\ast}c\left\langle 1 \middle| 0 \right\rangle
    + b^{\ast}d\left\langle 1 \middle| 1 \right\rangle\qquad} & & \qquad \\ & {= a^{\ast}c
    + b^{\ast}d,\qquad} & & \qquad \\ \end{array}](img/file38.png "\begin{array}{rlrl}
    \left\langle \psi_{1} \middle| \psi_{2} \right\rangle & {= \left( {a^{\ast}\left\langle
    0 \right| + b^{\ast}\left\langle 1 \right|} \right)\left( {c\left| 0 \right\rangle
    + d\left| 1 \right\rangle} \right)\qquad} & & \qquad \\  & {= a^{\ast}c\left\langle
    0 \middle| 0 \right\rangle + a^{\ast}d\left\langle 0 \middle| 1 \right\rangle
    + b^{\ast}c\left\langle 1 \middle| 0 \right\rangle + b^{\ast}d\left\langle 1 \middle|
    1 \right\rangle\qquad} & & \qquad \\  & {= a^{\ast}c + b^{\ast}d,\qquad} & & \qquad
    \\ \end{array}")'
  prefs: []
  type: TYPE_IMG
- en: where ![a^{\ast}](img/file39.png "a^{\ast}") and ![b^{\ast}](img/file40.png
    "b^{\ast}") are the complex conjugates of ![a](img/file16.png "a") and ![b](img/file17.png
    "b").
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.2
  prefs: []
  type: TYPE_NORMAL
- en: What is the inner product of ![\sqrt{\left. 1\slash 2 \right.}\left| 0 \right\rangle
    + \sqrt{\left. 1\slash 2 \right.}\left| 1 \right\rangle](img/file25.png "\sqrt{\left.
    1\slash 2 \right.}\left| 0 \right\rangle + \sqrt{\left. 1\slash 2 \right.}\left|
    1 \right\rangle") and ![\sqrt{\left. 1\slash 3 \right.}\left| 0 \right\rangle
    + \sqrt{\left. 2\slash 3 \right.}\left| 1 \right\rangle](img/file26.png "\sqrt{\left.
    1\slash 3 \right.}\left| 0 \right\rangle + \sqrt{\left. 2\slash 3 \right.}\left|
    1 \right\rangle")? And the inner product of ![\sqrt{\left. 1\slash 2 \right.}\left|
    0 \right\rangle + \sqrt{\left. 1\slash 2 \right.}\left| 1 \right\rangle](img/file25.png
    "\sqrt{\left. 1\slash 2 \right.}\left| 0 \right\rangle + \sqrt{\left. 1\slash
    2 \right.}\left| 1 \right\rangle") and ![\sqrt{\left. 1\slash 2 \right.}\left|
    0 \right\rangle - \sqrt{\left. 1\slash 2 \right.}\left| 1 \right\rangle](img/file27.png
    "\sqrt{\left. 1\slash 2 \right.}\left| 0 \right\rangle - \sqrt{\left. 1\slash
    2 \right.}\left| 1 \right\rangle")?
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that, if ![\left| \psi \right\rangle = a\left| 0 \right\rangle + b\left|
    1 \right\rangle](img/file41.png "\left| \psi \right\rangle = a\left| 0 \right\rangle
    + b\left| 1 \right\rangle"), then ![\left| \left\langle 0 \middle| \psi \right\rangle
    \right|^{2} = |a|^{2}](img/file42.png "\left| \left\langle 0 \middle| \psi \right\rangle
    \right|^{2} = |a|^{2}"), which is the probability of measuring ![0](img/file12.png
    "0") if the state is ![\left| \psi \right\rangle](img/file43.png "\left| \psi
    \right\rangle"). This is not accidental. In *Chapter* * [*7*](ch015.xhtml#x1-1190007),
    *VQE: Variational Quantum* *Eigensolver*, for example, we will use measurements
    in orthonormal bases other than the computational one, and we will see how, in
    that case, the probability of measuring the result associated to an element ![\left|
    \varphi \right\rangle](img/file44.png "\left| \varphi \right\rangle") of a given
    orthonormal basis is exactly ![\left| \left\langle \varphi \middle| \psi \right\rangle
    \right|^{2}](img/file45.png "\left| \left\langle \varphi \middle| \psi \right\rangle
    \right|^{2}").*'
  prefs: []
  type: TYPE_NORMAL
- en: '*We now know what qubits are, how to measure them, and even how to benefit
    from Dirac notation for some useful computations. The only thing remaining is
    to study how to operate on qubits. Are you ready? It is time for us to get you
    introduced to the mighty quantum gates!'
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.3 One-qubit quantum gates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have focused on how a qubit stores information in its state and on
    how we can access (part of) that information with measurements. But in order to
    develop useful algorithms, we also need some way of manipulating the state of
    qubits to perform computations.
  prefs: []
  type: TYPE_NORMAL
- en: Since a qubit is, fundamentally, a quantum system, its evolution follows the
    laws of quantum mechanics. More precisely, if we suppose that our system is isolated
    from its environment, it obeys the famous **Schrödinger** **equation**.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: The time-independent Schrödinger equation can be written as
  prefs: []
  type: TYPE_NORMAL
- en: '![H\left| {\psi(t)} \right\rangle = i\hslash\frac{\partial}{\partial t}\left|
    {\psi(t)} \right\rangle,](img/file46.png "H\left| {\psi(t)} \right\rangle = i\hslash\frac{\partial}{\partial
    t}\left| {\psi(t)} \right\rangle,")'
  prefs: []
  type: TYPE_IMG
- en: where ![H](img/file10.png "H") is the **Hamiltonian** of the system, ![\left|
    {\psi(t)} \right\rangle](img/file47.png "\left| {\psi(t)} \right\rangle") is the
    state vector of the system at time ![t](img/file48.png "t"), ![i](img/file49.png
    "i") is the imaginary unit, and ![\hslash](img/file50.png "\hslash") is the reduced
    Planck constant.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk more about Hamiltonians in *Chapter* *[*3*](ch011.xhtml#x1-590003),
    *QUBO:* *Quadratic Unconstrained Binary Optimization*, *Chapter* *[*4*](ch012.xhtml#x1-750004),
    *Quantum* *Adiabatic Computing and Quantum Annealing*, and *Chapter* *[*7*](ch015.xhtml#x1-1190007),
    *VQE:* *Variational Quantum Eigensolver*.***
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t panic! To program a quantum computer, you don’t need to know how to
    solve Schrödinger’s equation. In fact, the only thing that you need to know is
    that its solutions are always a special type of linear transformations. For the
    purposes of the quantum circuit model, since we are working in finite-dimensional
    spaces and we have fixed a basis, the operations can be described by matrices
    that are applied to the vectors that represent the states of the qubits.'
  prefs: []
  type: TYPE_NORMAL
- en: But not any kind of matrix does the trick. According to quantum mechanics, the
    only matrices that we can use are the so-called **unitary** matrices, which are
    the matrices ![U](img/file51.png "U") such that
  prefs: []
  type: TYPE_NORMAL
- en: '![U^{\dagger}U = UU^{\dagger} = I,](img/file52.png "U^{\dagger}U = UU^{\dagger}
    = I,")'
  prefs: []
  type: TYPE_IMG
- en: where ![I](img/file53.png "I") is the identity matrix and ![U^{\dagger}](img/file54.png
    "U^{\dagger}") is the adjoint of ![U](img/file51.png "U"), that is, the matrix
    obtained by transposing ![U](img/file51.png "U") and replacing each element by
    its complex conjugate. This means that any unitary matrix ![U](img/file51.png
    "U") is invertible and its inverse is given by ![U^{\dagger}](img/file54.png "U^{\dagger}").
    In the context of the quantum circuit model, the operations represented by these
    matrices are called quantum gates.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: It is relatively easy to check that unitary matrices preserve vector lengths
    (see, for instance, Section *5.7.5* in *Dancing with Qubits*, by Robert Sutor
    [[92](ch030.xhtml#Xsutor2019dancing)]). That is, if ![U](img/file51.png "U") is
    a unitary matrix and ![\left| \psi \right\rangle](img/file43.png "\left| \psi
    \right\rangle") is a quantum state (and, hence, its norm is ![1](img/file13.png
    "1"), as we already know) then ![U\left| \psi \right\rangle](img/file55.png "U\left|
    \psi \right\rangle") also is a valid quantum state because its norm is still ![1](img/file13.png
    "1"). For this reason, we can safely apply unitary matrices to our quantum states
    and rest assured that the resulting states will satisfy the normalization condition.
  prefs: []
  type: TYPE_NORMAL
- en: When we have just one qubit, our unitary matrices need to be of size ![2 \times
    2](img/file56.png "2 \times 2") because the state vector is of dimension 2\. Thus,
    the simplest example of a quantum gate is the identity matrix of dimension 2,
    which transforms the state of the qubit by... well, by not transforming it at
    all. A less boring example is the ![X](img/file9.png "X") gate, whose matrix is
    given by
  prefs: []
  type: TYPE_NORMAL
- en: '![X = \begin{pmatrix} 0 & 1 \\ 1 & 0 \\ \end{pmatrix}.](img/file57.png "X =
    \begin{pmatrix} 0 & 1 \\ 1 & 0 \\ \end{pmatrix}.")'
  prefs: []
  type: TYPE_IMG
- en: The ![X](img/file9.png "X") gate is also called the **NOT** gate, because its
    action on the elements of the computational basis is
  prefs: []
  type: TYPE_NORMAL
- en: '![X\left| 0 \right\rangle = \begin{pmatrix} 0 & 1 \\ 1 & 0 \\ \end{pmatrix}\begin{pmatrix}
    1 \\ 0 \\ \end{pmatrix} = \begin{pmatrix} 0 \\ 1 \\ \end{pmatrix} = \left| 1 \right\rangle,\qquad
    X\left| 1 \right\rangle = \begin{pmatrix} 0 & 1 \\ 1 & 0 \\ \end{pmatrix}\begin{pmatrix}
    0 \\ 1 \\ \end{pmatrix} = \begin{pmatrix} 1 \\ 0 \\ \end{pmatrix} = \left| 0 \right\rangle,](img/file58.png
    "X\left| 0 \right\rangle = \begin{pmatrix} 0 & 1 \\ 1 & 0 \\ \end{pmatrix}\begin{pmatrix}
    1 \\ 0 \\ \end{pmatrix} = \begin{pmatrix} 0 \\ 1 \\ \end{pmatrix} = \left| 1 \right\rangle,\qquad
    X\left| 1 \right\rangle = \begin{pmatrix} 0 & 1 \\ 1 & 0 \\ \end{pmatrix}\begin{pmatrix}
    0 \\ 1 \\ \end{pmatrix} = \begin{pmatrix} 1 \\ 0 \\ \end{pmatrix} = \left| 0 \right\rangle,")'
  prefs: []
  type: TYPE_IMG
- en: which is exactly what the NOT gate does in classical digital circuits.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.3
  prefs: []
  type: TYPE_NORMAL
- en: Check that the gate ![X](img/file9.png "X") matrix is, indeed, unitary. What
    is the inverse of ![X](img/file9.png "X")? What is the action of ![X](img/file9.png
    "X") on a general qubit in a state of the form ![a\left| 0 \right\rangle + b\left|
    1 \right\rangle](img/file22.png "a\left| 0 \right\rangle + b\left| 1 \right\rangle")?
  prefs: []
  type: TYPE_NORMAL
- en: A quantum gate with no classical analog is the **Hadamard** or ![H](img/file10.png
    "H") gate, given by
  prefs: []
  type: TYPE_NORMAL
- en: '![H = \begin{pmatrix} \frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}}
    & {- \frac{1}{\sqrt{2}}} \\ \end{pmatrix} = \frac{1}{\sqrt{2}}\begin{pmatrix}
    1 & 1 \\ 1 & {- 1} \\ \end{pmatrix}.](img/file59.png "H = \begin{pmatrix} \frac{1}{\sqrt{2}}
    & \frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}} & {- \frac{1}{\sqrt{2}}} \\ \end{pmatrix}
    = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & {- 1} \\ \end{pmatrix}.")'
  prefs: []
  type: TYPE_IMG
- en: This gate is extremely useful in quantum computing, for it can create superposition.
    To be precise, if we apply the ![H](img/file10.png "H") gate on a qubit in state
    ![\left| 0 \right\rangle](img/file6.png "\left| 0 \right\rangle"), we obtain
  prefs: []
  type: TYPE_NORMAL
- en: '![H\left| 0 \right\rangle = \frac{1}{\sqrt{2}}\left| 0 \right\rangle + \frac{1}{\sqrt{2}}\left|
    1 \right\rangle = \frac{1}{\sqrt{2}}\left( {\left| 0 \right\rangle + \left| 1
    \right\rangle} \right).](img/file60.png "H\left| 0 \right\rangle = \frac{1}{\sqrt{2}}\left|
    0 \right\rangle + \frac{1}{\sqrt{2}}\left| 1 \right\rangle = \frac{1}{\sqrt{2}}\left(
    {\left| 0 \right\rangle + \left| 1 \right\rangle} \right).")'
  prefs: []
  type: TYPE_IMG
- en: This state is so important that it has its own name and symbol. It is called
    the **plus** state and it is denoted by ![\left| + \right\rangle](img/file61.png
    "\left| + \right\rangle"). In a similar way, we have that
  prefs: []
  type: TYPE_NORMAL
- en: '![H\left| 1 \right\rangle = \frac{1}{\sqrt{2}}\left( {\left| 0 \right\rangle
    - \left| 1 \right\rangle} \right)](img/file62.png "H\left| 1 \right\rangle = \frac{1}{\sqrt{2}}\left(
    {\left| 0 \right\rangle - \left| 1 \right\rangle} \right)")'
  prefs: []
  type: TYPE_IMG
- en: and, as you probably guessed, this state is called the **minus** state and it
    is denoted by ![\left| - \right\rangle](img/file63.png "\left| - \right\rangle").
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.4
  prefs: []
  type: TYPE_NORMAL
- en: Check that the gate ![H](img/file10.png "H") matrix is, indeed, unitary. What
    is the action of ![H](img/file10.png "H") on ![\left| + \right\rangle](img/file61.png
    "\left| + \right\rangle") and ![\left| - \right\rangle](img/file63.png "\left|
    - \right\rangle")? What is the action of ![X](img/file9.png "X") on ![\left| +
    \right\rangle](img/file61.png "\left| + \right\rangle") and ![\left| - \right\rangle](img/file63.png
    "\left| - \right\rangle")?
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we can apply several gates to the same qubit one after the other.
    For instance, consider the following circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HXH ](img/file64.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We read gates from left to right, so in the preceding circuit we would first
    apply an ![H](img/file10.png "H") gate, then an ![X](img/file9.png "X") gate and,
    finally, another ![H](img/file10.png "H") gate. You can easily check that, if
    the initial state of the qubit is ![\left| 0 \right\rangle](img/file6.png "\left|
    0 \right\rangle"), it would end up again in state ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle"). But were its initial state ![\left| 1 \right\rangle](img/file14.png
    "\left| 1 \right\rangle"), the final state would become ![- \left| 1 \right\rangle](img/file65.png
    "- \left| 1 \right\rangle").
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that this operation is also very important, and, of course, it
    has its own name: we call it the ![Z](img/file8.png "Z") gate. From its action
    on ![\left| 0 \right\rangle](img/file6.png "\left| 0 \right\rangle") and ![\left|
    1 \right\rangle](img/file14.png "\left| 1 \right\rangle"), we can tell that its
    matrix will be'
  prefs: []
  type: TYPE_NORMAL
- en: '![Z = \begin{pmatrix} 1 & 0 \\ 0 & {- 1} \\ \end{pmatrix},](img/file66.png
    "Z = \begin{pmatrix} 1 & 0 \\ 0 & {- 1} \\ \end{pmatrix},")'
  prefs: []
  type: TYPE_IMG
- en: something that we could have also deduced by multiplying the matrices of the
    gates ![H](img/file10.png "H"), ![X](img/file9.png "X"), and ![H](img/file10.png
    "H") one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.5
  prefs: []
  type: TYPE_NORMAL
- en: Check that ![Z\left| 0 \right\rangle = \left| 0 \right\rangle](img/file67.png
    "Z\left| 0 \right\rangle = \left| 0 \right\rangle") and that ![Z\left| 1 \right\rangle
    = - \left| 1 \right\rangle](img/file68.png "Z\left| 1 \right\rangle = - \left|
    1 \right\rangle") in two different ways. First, use Dirac notation and the actions
    of ![H](img/file10.png "H") and ![X](img/file9.png "X") (remember that we have
    defined ![Z](img/file8.png "Z") as ![HXH](img/file69.png "HXH")). Then, derive
    the same result by performing the matrix multiplication
  prefs: []
  type: TYPE_NORMAL
- en: '![\begin{pmatrix} \frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}}
    & {- \frac{1}{\sqrt{2}}} \\ \end{pmatrix}\begin{pmatrix} 0 & 1 \\ 1 & 0 \\ \end{pmatrix}\begin{pmatrix}
    \frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}} & {- \frac{1}{\sqrt{2}}}
    \\ \end{pmatrix}.](img/file70.png "\begin{pmatrix} \frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}}
    \\ \frac{1}{\sqrt{2}} & {- \frac{1}{\sqrt{2}}} \\ \end{pmatrix}\begin{pmatrix}
    0 & 1 \\ 1 & 0 \\ \end{pmatrix}\begin{pmatrix} \frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}}
    \\ \frac{1}{\sqrt{2}} & {- \frac{1}{\sqrt{2}}} \\ \end{pmatrix}.")'
  prefs: []
  type: TYPE_IMG
- en: Since there are ![X](img/file9.png "X") and ![Z](img/file8.png "Z") gates, you
    may be wondering if there is also a ![Y](img/file11.png "Y") gate. Indeed, there
    is one, given by matrix ![Y = \begin{pmatrix} 0 & {- i} \\ i & 0 \\ \end{pmatrix}.](img/file71.png
    "Y = \begin{pmatrix} 0 & {- i} \\ i & 0 \\ \end{pmatrix}.")
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: 'The set ![\{ I,X,Y,Z\}](img/file72.png "\{ I,X,Y,Z\}"), known as the set of
    **Pauli matrices**, is of great importance in quantum computing. One of its many
    interesting properties is that it constitutes a basis of the vector space of ![2
    \times 2](img/file56.png "2 \times 2") complex matrices. We will work with it
    in *Chapter* * [*7*](ch015.xhtml#x1-1190007), *VQE: Variational* *Quantum Eigensolver*,
    for instance.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Other important one-qubit gates include the ![S](img/file73.png "S") and ![T](img/file74.png
    "T") gates, whose matrices are'
  prefs: []
  type: TYPE_NORMAL
- en: '![S = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\frac{\pi}{2}} \\ \end{pmatrix},\qquad
    T = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\frac{\pi}{4}} \\ \end{pmatrix}.](img/file75.png
    "S = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\frac{\pi}{2}} \\ \end{pmatrix},\qquad T
    = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\frac{\pi}{4}} \\ \end{pmatrix}.")'
  prefs: []
  type: TYPE_IMG
- en: But, of course, there is an (uncountably!) infinite number of 2-dimensional
    unitary matrices and we cannot just list them all here. What we will do instead
    is introduce a beautiful geometrical representation of single-qubit states, and,
    with it, we will explain how all one-qubit quantum gates can, in fact, be understood
    as certain kinds of rotations. Enter the Bloch sphere!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.6
  prefs: []
  type: TYPE_NORMAL
- en: Check that ![T^{2} = S](img/file76.png "T^{2} = S"). Then, use the most beautiful
    formula ever (i.e., Euler’s identity ![e^{i\pi} + 1 = 0](img/file77.png "e^{i\pi}
    + 1 = 0")) to check that ![S^{2} = Z](img/file78.png "S^{2} = Z"). Check also
    that ![S](img/file73.png "S") and ![T](img/file74.png "T") are unitary. Express
    ![S^{\dagger}](img/file79.png "S^{\dagger}") and ![T^{\dagger}](img/file80.png
    "T^{\dagger}") as powers of ![S](img/file73.png "S") and ![T](img/file74.png "T").
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.4 The Bloch sphere and rotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The general state of a qubit is described with two complex numbers. Since each
    of those numbers has two real components, it would be natural to think that we
    would need a four-dimensional real space in order to represent the state of a
    qubit. Surprisingly enough, all the possible states of a qubit can be drawn on
    the surface of an old-school sphere, which is a two-dimensional object!
  prefs: []
  type: TYPE_NORMAL
- en: To show how it can be accomplished, we need to remember that a complex number
    ![z](img/file81.png "z") can be written in polar coordinates as
  prefs: []
  type: TYPE_NORMAL
- en: '![z = re^{i\alpha},](img/file82.png "z = re^{i\alpha},")'
  prefs: []
  type: TYPE_IMG
- en: where ![r = |z|](img/file83.png "r = |z|") is a non-negative real number and
    ![\alpha](img/file84.png "\alpha") is an angle in ![\left\lbrack {0,2\pi} \right\rbrack](img/file85.png
    "\left\lbrack {0,2\pi} \right\rbrack"). Consider, then, a qubit in a state ![\left|
    \psi \right\rangle = a\left| 0 \right\rangle + b\left| 1 \right\rangle](img/file41.png
    "\left| \psi \right\rangle = a\left| 0 \right\rangle + b\left| 1 \right\rangle")
    and write ![a](img/file16.png "a") and ![b](img/file17.png "b") in polar coordinates
    as
  prefs: []
  type: TYPE_NORMAL
- en: '![a = r_{1}e^{i\alpha_{1}},\qquad b = r_{2}e^{i\alpha_{2}}.](img/file86.png
    "a = r_{1}e^{i\alpha_{1}},\qquad b = r_{2}e^{i\alpha_{2}}.")'
  prefs: []
  type: TYPE_IMG
- en: We know that ![r_{1}^{2} + r_{2}^{2} = |a|^{2} + |b|^{2} = 1](img/file87.png
    "r_{1}^{2} + r_{2}^{2} = |a|^{2} + |b|^{2} = 1") and, since ![0 \leq r_{1},r_{2}
    \leq 1](img/file88.png "0 \leq r_{1},r_{2} \leq 1"), there must exist an angle
    ![\theta](img/file89.png "\theta") in ![\lbrack 0,\pi\rbrack](img/file90.png "\lbrack
    0,\pi\rbrack") such that ![\left. {\cos}(\theta/2) = r_{1} \right.](img/file91.png
    "\left. {\cos}(\theta/2) = r_{1} \right.") and ![\left. {\sin}(\theta/2) = r_{2}
    \right.](img/file92.png "\left. {\sin}(\theta/2) = r_{2} \right."). The reason
    for considering ![\left. \theta\slash 2 \right.](img/file93.png "\left. \theta\slash
    2 \right.") instead of ![\theta](img/file89.png "\theta") in the cosine and sine
    will be apparent in a moment. Notice that, by now, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| \psi \right\rangle = \cos\frac{\theta}{2}e^{i\alpha_{1}}\left| 0 \right\rangle
    + \sin\frac{\theta}{2}e^{i\alpha_{2}}\left| 1 \right\rangle.](img/file94.png "\left|
    \psi \right\rangle = \cos\frac{\theta}{2}e^{i\alpha_{1}}\left| 0 \right\rangle
    + \sin\frac{\theta}{2}e^{i\alpha_{2}}\left| 1 \right\rangle.")'
  prefs: []
  type: TYPE_IMG
- en: Another crucial observation is that we can multiply ![\left| \psi \right\rangle](img/file43.png
    "\left| \psi \right\rangle") by a complex number ![c](img/file95.png "c") with
    absolute value 1 without changing its state. Indeed, it is easy to see that ![c](img/file95.png
    "c") does not affect the probabilities of obtaining 0 and 1 when measuring in
    the computational basis (check it!) and, by linearity, it comes out when applying
    a quantum gate ![U](img/file51.png "U") (that is, ![U\left( {c\left| \psi \right\rangle}
    \right) = cU\left| \psi \right\rangle](img/file96.png "U\left( {c\left| \psi \right\rangle}
    \right) = cU\left| \psi \right\rangle")). Thus, there is no operation — either
    unitary transformation or measurement — that allows us to distinguish ![\left|
    \psi \right\rangle](img/file43.png "\left| \psi \right\rangle") from ![c\left|
    \psi \right\rangle](img/file97.png "c\left| \psi \right\rangle"). We call ![c](img/file95.png
    "c") a **global phase** and we have just shown that it is physically irrelevant.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Notice, however, that **relative** phases are, unlike global ones, really relevant!
    For instance, ![\left| + \right\rangle = \frac{1}{\sqrt{2}}\left( {\left| 0 \right\rangle
    + \left| 1 \right\rangle} \right)](img/file98.png "\left| + \right\rangle = \frac{1}{\sqrt{2}}\left(
    {\left| 0 \right\rangle + \left| 1 \right\rangle} \right)") and ![\left| - \right\rangle
    = \frac{1}{\sqrt{2}}\left( {\left| 0 \right\rangle - \left| 1 \right\rangle} \right)](img/file99.png
    "\left| - \right\rangle = \frac{1}{\sqrt{2}}\left( {\left| 0 \right\rangle - \left|
    1 \right\rangle} \right)") differ just in the phase of ![\left| 1 \right\rangle](img/file14.png
    "\left| 1 \right\rangle"), but we can easily distinguish between them by first
    applying ![H](img/file10.png "H") to those states and then measuring them in the
    computational basis.
  prefs: []
  type: TYPE_NORMAL
- en: We can, thus, multiply ![\left| \psi \right\rangle](img/file43.png "\left| \psi
    \right\rangle") by ![e^{- i\alpha_{1}}](img/file100.png "e^{- i\alpha_{1}}") to
    obtain an equivalent representation
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| \psi \right\rangle = \cos\frac{\theta}{2}\left| 0 \right\rangle +
    \sin\frac{\theta}{2}e^{i\varphi}\left| 1 \right\rangle,](img/file101.png "\left|
    \psi \right\rangle = \cos\frac{\theta}{2}\left| 0 \right\rangle + \sin\frac{\theta}{2}e^{i\varphi}\left|
    1 \right\rangle,")'
  prefs: []
  type: TYPE_IMG
- en: where we have defined ![\varphi = \alpha_{2} - \alpha_{1}](img/file102.png "\varphi
    = \alpha_{2} - \alpha_{1}").
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we can describe the state of any qubit with just two numbers ![\theta
    \in \left\lbrack {0,\pi} \right\rbrack](img/file103.png "\theta \in \left\lbrack
    {0,\pi} \right\rbrack") and ![\varphi \in \left\lbrack {0,2\pi} \right\rbrack](img/file104.png
    "\varphi \in \left\lbrack {0,2\pi} \right\rbrack") that we can interpret as a
    polar angle and an azimuthal angle, respectively (that is, we are using what are
    known as **spherical coordinates**). This gives us a three-dimensional point
  prefs: []
  type: TYPE_NORMAL
- en: '![(\sin\theta\cos\varphi,\sin\theta\sin\varphi,\cos\theta)](img/file105.png
    "(\sin\theta\cos\varphi,\sin\theta\sin\varphi,\cos\theta)")'
  prefs: []
  type: TYPE_IMG
- en: that locates the state of the qubit on the surface of a sphere, called the **Bloch**
    **sphere** (see *Figure* *[*1.2*](#Figure1.2)).*
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 1.2: Qubit state \left| \psi \right\rangle represented on the Bloch
    sphere.](img/file106.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 1.2**: Qubit state ![\left| \psi \right\rangle](img/file43.png "\left|
    \psi \right\rangle") represented on the Bloch sphere.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that ![\theta](img/file89.png "\theta") runs from ![0](img/file12.png
    "0") to ![\pi](img/file107.png "\pi") to cover the whole range from the top to
    the bottom of the sphere. This is why we used ![\left. \theta\slash 2 \right.](img/file93.png
    "\left. \theta\slash 2 \right.") in the representation of our preceding qubit.
    We only needed to get up to ![\left. \pi\slash 2 \right.](img/file108.png "\left.
    \pi\slash 2 \right.") for our angles in the sines and cosines!
  prefs: []
  type: TYPE_NORMAL
- en: In the Bloch sphere, ![\left| 0 \right\rangle](img/file6.png "\left| 0 \right\rangle")
    is mapped to the North pole and ![\left| 1 \right\rangle](img/file14.png "\left|
    1 \right\rangle") to the South pole. In general, states that are orthogonal with
    respect to the inner product are antipodal on the sphere. For instance, ![\left|
    + \right\rangle](img/file61.png "\left| + \right\rangle") and ![\left| - \right\rangle](img/file63.png
    "\left| - \right\rangle") both lie on the equator, but on opposite points of the
    sphere. As we already know, the ![X](img/file9.png "X") gate takes ![\left| 0
    \right\rangle](img/file6.png "\left| 0 \right\rangle") to ![\left| 1 \right\rangle](img/file14.png
    "\left| 1 \right\rangle") and ![\left| 1 \right\rangle](img/file14.png "\left|
    1 \right\rangle") to ![\left| 0 \right\rangle](img/file6.png "\left| 0 \right\rangle"),
    but leaves ![\left| + \right\rangle](img/file61.png "\left| + \right\rangle")
    and ![\left| - \right\rangle](img/file63.png "\left| - \right\rangle") unchanged,
    at least up to an irrelevant global phase. In fact, this means that the ![X](img/file9.png
    "X") gate acts like a rotation of ![\pi](img/file107.png "\pi") radians around
    the ![X](img/file9.png "X") axis of the Bloch sphere…, so now you know why we
    use that name for the gate! In the same manner, ![Z](img/file8.png "Z") and ![Y](img/file11.png
    "Y") are rotations of ![\pi](img/file107.png "\pi") radians around the ![Z](img/file8.png
    "Z") and ![Y](img/file11.png "Y") axes, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We can generalize this behavior to obtain rotations of any angle around any
    axis of the Bloch sphere. For instance, for the ![X](img/file9.png "X"), ![Y](img/file11.png
    "Y"), and ![Z](img/file8.png "Z") axes we may define
  prefs: []
  type: TYPE_NORMAL
- en: '![R_{X}(\theta) = e^{- i\frac{\theta}{2}X} = \cos\frac{\theta}{2}I - i\sin\frac{\theta}{2}X
    = \begin{pmatrix} {\cos\frac{\theta}{2}} & {- i\sin\frac{\theta}{2}} \\ {- i\sin\frac{\theta}{2}}
    & {\cos\frac{\theta}{2}} \\ \end{pmatrix},](img/file109.png "R_{X}(\theta) = e^{-
    i\frac{\theta}{2}X} = \cos\frac{\theta}{2}I - i\sin\frac{\theta}{2}X = \begin{pmatrix}
    {\cos\frac{\theta}{2}} & {- i\sin\frac{\theta}{2}} \\ {- i\sin\frac{\theta}{2}}
    & {\cos\frac{\theta}{2}} \\ \end{pmatrix},")'
  prefs: []
  type: TYPE_IMG
- en: '![R_{Y}(\theta) = e^{- i\frac{\theta}{2}Y} = \cos\frac{\theta}{2}I - i\sin\frac{\theta}{2}Y
    = \begin{pmatrix} {\cos\frac{\theta}{2}} & {- \sin\frac{\theta}{2}} \\ {\sin\frac{\theta}{2}}
    & {\cos\frac{\theta}{2}} \\ \end{pmatrix},](img/file110.png "R_{Y}(\theta) = e^{-
    i\frac{\theta}{2}Y} = \cos\frac{\theta}{2}I - i\sin\frac{\theta}{2}Y = \begin{pmatrix}
    {\cos\frac{\theta}{2}} & {- \sin\frac{\theta}{2}} \\ {\sin\frac{\theta}{2}} &
    {\cos\frac{\theta}{2}} \\ \end{pmatrix},")'
  prefs: []
  type: TYPE_IMG
- en: '![R_{Z}(\theta) = e^{- i\frac{\theta}{2}Z} = \cos\frac{\theta}{2}I - i\sin\frac{\theta}{2}Z
    = \begin{pmatrix} e^{- i\frac{\theta}{2}} & 0 \\ 0 & e^{i\frac{\theta}{2}} \\
    \end{pmatrix} \equiv \begin{pmatrix} 1 & 0 \\ 0 & e^{i\theta} \\ \end{pmatrix},](img/file111.png
    "R_{Z}(\theta) = e^{- i\frac{\theta}{2}Z} = \cos\frac{\theta}{2}I - i\sin\frac{\theta}{2}Z
    = \begin{pmatrix} e^{- i\frac{\theta}{2}} & 0 \\ 0 & e^{i\frac{\theta}{2}} \\
    \end{pmatrix} \equiv \begin{pmatrix} 1 & 0 \\ 0 & e^{i\theta} \\ \end{pmatrix},")'
  prefs: []
  type: TYPE_IMG
- en: where we use the ![\equiv](img/file112.png "\equiv") symbol for equivalent action
    up to a global phase. Notice that ![R_{X}(\pi) \equiv X](img/file113.png "R_{X}(\pi)
    \equiv X"), ![R_{Y}(\pi) \equiv Y](img/file114.png "R_{Y}(\pi) \equiv Y"), ![R_{Z}(\pi)
    \equiv Z](img/file115.png "R_{Z}(\pi) \equiv Z"), ![R_{Z}(\frac{\pi}{2}) \equiv
    S](img/file116.png "R_{Z}(\frac{\pi}{2}) \equiv S"), and ![R_{Z}(\frac{\pi}{4})
    \equiv T](img/file117.png "R_{Z}(\frac{\pi}{4}) \equiv T").
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.7
  prefs: []
  type: TYPE_NORMAL
- en: Check these equivalences by substituting the angles in the definitions of ![R_{X}](img/file118.png
    "R_{X}"), ![R_{Y}](img/file119.png "R_{Y}"), and ![R_{Z}](img/file120.png "R_{Z}").
  prefs: []
  type: TYPE_NORMAL
- en: In fact, it can be proved (see, for instance, the book by Nielsen and Chuang
    [[69](ch030.xhtml#Xnielsen11quantum)]) that for any one-qubit gate ![U](img/file51.png
    "U") there exists a unit vector ![r = (r_{x},r_{y},r_{z})](img/file121.png "r
    = (r_{x},r_{y},r_{z})") and an angle ![\theta](img/file89.png "\theta") such that
  prefs: []
  type: TYPE_NORMAL
- en: '![U \equiv \cos\frac{\theta}{2}I - i\sin\frac{\theta}{2}(r_{x}X + r_{y}Y +
    r_{z}Z).](img/file122.png "U \equiv \cos\frac{\theta}{2}I - i\sin\frac{\theta}{2}(r_{x}X
    + r_{y}Y + r_{z}Z).")'
  prefs: []
  type: TYPE_IMG
- en: For example, choosing ![\theta = \pi](img/file123.png "\theta = \pi") and ![\left.
    r = (1\slash\sqrt{2},0,1\slash\sqrt{2}) \right.](img/file124.png "\left. r = (1\slash\sqrt{2},0,1\slash\sqrt{2})
    \right.") we can obtain the Hadamard gate, for it holds that
  prefs: []
  type: TYPE_NORMAL
- en: '![H \equiv - i\frac{1}{\sqrt{2}}(X + Z).](img/file125.png "H \equiv - i\frac{1}{\sqrt{2}}(X
    + Z).")'
  prefs: []
  type: TYPE_IMG
- en: Additionally, it can also be proved that, again for any one-qubit gate ![U](img/file51.png
    "U"), there exist three angles ![\alpha](img/file84.png "\alpha"), ![\beta](img/file126.png
    "\beta"), and ![\gamma](img/file127.png "\gamma") such that
  prefs: []
  type: TYPE_NORMAL
- en: '![U \equiv R_{Z}(\alpha)R_{Y}(\beta)R_{Z}(\gamma).](img/file128.png "U \equiv
    R_{Z}(\alpha)R_{Y}(\beta)R_{Z}(\gamma).")'
  prefs: []
  type: TYPE_IMG
- en: In fact, you can obtain such a decomposition for any two rotation axes as long
    as they are not parallel, not just for ![Y](img/file11.png "Y") and ![Z](img/file8.png
    "Z").
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, in some quantum computing architectures (including the ones used by
    companies such as IBM), it is common to use a **universal** one-qubit gate, called
    the ![U](img/file51.png "U")**-gate**, that depends on three angles and is able
    to generate any other one-qubit gate. Its matrix is
  prefs: []
  type: TYPE_NORMAL
- en: '![U\left( {\theta,\varphi,\lambda} \right) = \begin{pmatrix} {\cos\frac{\theta}{2}}
    & {- e^{i\lambda}\sin\frac{\theta}{2}} \\ {e^{i\varphi}\sin\frac{\theta}{2}} &
    {e^{i{({\varphi + \lambda})}}\cos\frac{\theta}{2}} \\ \end{pmatrix}.](img/file129.png
    "U\left( {\theta,\varphi,\lambda} \right) = \begin{pmatrix} {\cos\frac{\theta}{2}}
    & {- e^{i\lambda}\sin\frac{\theta}{2}} \\ {e^{i\varphi}\sin\frac{\theta}{2}} &
    {e^{i{({\varphi + \lambda})}}\cos\frac{\theta}{2}} \\ \end{pmatrix}.")'
  prefs: []
  type: TYPE_IMG
- en: Exercise 1.8
  prefs: []
  type: TYPE_NORMAL
- en: Show that ![U\left( {\theta,\varphi,\lambda} \right)](img/file130.png "U\left(
    {\theta,\varphi,\lambda} \right)") is unitary. Check that ![\left. R_{X}(\theta)
    = U(\theta, - \pi\slash 2,\pi\slash 2) \right.](img/file131.png "\left. R_{X}(\theta)
    = U(\theta, - \pi\slash 2,\pi\slash 2) \right."), that ![R_{Y}(\theta) = U(\theta,0,0)](img/file132.png
    "R_{Y}(\theta) = U(\theta,0,0)") and that, up to a global phase, ![U(\theta) =
    R_{Z}(0,0,\theta)](img/file133.png "U(\theta) = R_{Z}(0,0,\theta)").
  prefs: []
  type: TYPE_NORMAL
- en: All these observations about how to construct one-qubit gates from rotations
    and parametrized families will be very important when we talk about variational
    forms and feature maps in *Chapter* *[*9*](ch018.xhtml#x1-1600009), *Quantum Support
    Vector Machines*, and *Chapter* *[*10*](ch019.xhtml#x1-18100010), *Quantum Neural
    Networks*, and also to construct controlled gates later in this chapter.**
  prefs: []
  type: TYPE_NORMAL
- en: '**## 1.3.5 Hello, quantum world!'
  prefs: []
  type: TYPE_NORMAL
- en: 'To put together everything that we have learned, we are going to create our
    very first complete quantum circuit. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![H ](img/file134.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It doesn’t seem very impressive, but let’s analyze it part by part. As you know,
    following convention, the initial state of our qubit is assumed to be ![\left|
    0 \right\rangle](img/file6.png "\left| 0 \right\rangle"), so that’s what we have
    before we do anything. Then we apply the ![H](img/file10.png "H") gate, so the
    state changes to ![\sqrt{\left. 1\slash 2 \right.}\left| 0 \right\rangle + \sqrt{\left.
    1\slash 2 \right.}\left| 1 \right\rangle](img/file25.png "\sqrt{\left. 1\slash
    2 \right.}\left| 0 \right\rangle + \sqrt{\left. 1\slash 2 \right.}\left| 1 \right\rangle").
    Finally, we measure the qubit. The probability of obtaining ![0](img/file12.png
    "0") will be ![\left. \left| \sqrt{\left. 1\slash 2 \right.} \right|^{2} = 1\slash
    2 \right.](img/file135.png "\left. \left| \sqrt{\left. 1\slash 2 \right.} \right|^{2}
    = 1\slash 2 \right."), and that of getting ![1](img/file13.png "1") will also
    be ![\left. 1\slash 2 \right.](img/file136.png "\left. 1\slash 2 \right."), so
    we have created a circuit that — at least in theory — generates random bits following
    a perfectly uniform distribution.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: Unbiased uniform bit distributions are of great relevance for multiple applications
    in simulation, cryptography, and even online gambling games. As we will learn
    in *Chapter* *[*2*](ch009.xhtml#x1-400002), *The Tools of the Trade*, current
    quantum computers deviate from this equilibrium because they are affected by noise
    and gate and measurement errors. However, protocols to extract perfect random
    bits even with noisy quantum computers have been proposed and could become one
    of the first practical applications of quantum computing (see, for instance, the
    paper by Acín and Masanes [[3](ch030.xhtml#Xacin2016certified)]).*
  prefs: []
  type: TYPE_NORMAL
- en: '*We can modify the previous circuit to obtain any distribution over ![0](img/file12.png
    "0") and ![1](img/file13.png "1") that we desire. If we want the probability of
    measuring ![0](img/file12.png "0") to be ![p \in \left\lbrack {0,1} \right\rbrack](img/file137.png
    "p \in \left\lbrack {0,1} \right\rbrack"), we just need to consider ![\theta =
    2\arccos\sqrt{p}](img/file138.png "\theta = 2\arccos\sqrt{p}") and the following
    circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![R (𝜃) Y ](img/file139.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exercise 1.9
  prefs: []
  type: TYPE_NORMAL
- en: Check that, with the preceding circuit, the state before measurement is ![\sqrt{p}\left|
    0 \right\rangle + \sqrt{1 - p}\left| 1 \right\rangle](img/file140.png "\sqrt{p}\left|
    0 \right\rangle + \sqrt{1 - p}\left| 1 \right\rangle") and, hence, the probability
    of measuring ![0](img/file12.png "0") is ![p](img/file141.png "p") and that of
    measuring ![1](img/file13.png "1") is ![1 - p](img/file142.png "1 - p").
  prefs: []
  type: TYPE_NORMAL
- en: For now, this is all that we need to know about one-qubit states, gates, and
    measurements. Let us move on to two-qubit systems, where the mysteries of entanglement
    are awaiting to be revealed!
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 Working with two qubits and entanglement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have mastered the inner workings of solitary qubits, we are ready
    to up the ante. In this section, we will learn about systems of two qubits and
    how they can become entangled. We will first define the mathematical representation
    of two-qubit systems and how we can measure them. After that, we will study different
    quantum gates that can act on two qubits at once and we will have a look at some
    of their very interesting and slightly puzzling properties. We will conclude with
    a simple but enlightening example of a two-qubit circuit. We promise that the
    ride is going to be amazing!
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.1 Two-qubit states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have worked with qubits in isolation. But the real power of quantum
    computing cannot be unleashed unless qubits can talk to each other. We will start
    by considering the simplest case of quantum systems in which there is qubit interaction:
    two-qubit systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, in a two-qubit system, each of the qubits can be in state ![\left|
    0 \right\rangle](img/file6.png "\left| 0 \right\rangle") or in state ![\left|
    1 \right\rangle](img/file14.png "\left| 1 \right\rangle"). Thus, for the two qubits,
    we have four possible combinations: both are in state ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle"), the first one is in state ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle") and the second one in state ![\left| 1 \right\rangle](img/file14.png
    "\left| 1 \right\rangle"), the first one is in state ![\left| 1 \right\rangle](img/file14.png
    "\left| 1 \right\rangle") and the second one in state ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle"), or both are in state ![\left| 1 \right\rangle](img/file14.png
    "\left| 1 \right\rangle"). These four possibilities form a basis (called the **computational
    basis**) of a ![4](img/file143.png "4")-dimensional space and we denote them,
    respectively, by'
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| 0 \right\rangle \otimes \left| 0 \right\rangle,\,\left| 0 \right\rangle
    \otimes \left| 1 \right\rangle,\,\left| 1 \right\rangle \otimes \left| 0 \right\rangle,\,\left|
    1 \right\rangle \otimes \left| 1 \right\rangle.](img/file144.png "\left| 0 \right\rangle
    \otimes \left| 0 \right\rangle,\,\left| 0 \right\rangle \otimes \left| 1 \right\rangle,\,\left|
    1 \right\rangle \otimes \left| 0 \right\rangle,\,\left| 1 \right\rangle \otimes
    \left| 1 \right\rangle.")'
  prefs: []
  type: TYPE_IMG
- en: Here, ![\otimes](img/file145.png "\otimes") is the symbol for the **tensor product**.
    The tensor product of two column vectors is defined by
  prefs: []
  type: TYPE_NORMAL
- en: '![\begin{pmatrix} a_{1} \\ a_{2} \\ {\vdots} \\ a_{n} \\ \end{pmatrix} \otimes
    \begin{pmatrix} b_{1} \\ b_{2} \\ {\vdots} \\ b_{m} \\ \end{pmatrix} = \begin{pmatrix}
    {a_{1}\begin{pmatrix} b_{1} \\ b_{2} \\ {\vdots} \\ b_{m} \\ \end{pmatrix}} \\
    {a_{2}\begin{pmatrix} b_{1} \\ b_{2} \\ {\vdots} \\ b_{m} \\ \end{pmatrix}} \\
    {\vdots} \\ {a_{n}\begin{pmatrix} b_{1} \\ b_{2} \\ {\vdots} \\ b_{m} \\ \end{pmatrix}}
    \\ \end{pmatrix} = \begin{pmatrix} {a_{1}b_{1}} \\ {a_{1}b_{2}} \\ {\vdots} \\
    {a_{1}b_{m}} \\ {a_{2}b_{1}} \\ {a_{2}b_{2}} \\ {\vdots} \\ {a_{2}b_{m}} \\ {\vdots}
    \\ {a_{n}b_{1}} \\ {a_{n}b_{2}} \\ {\vdots} \\ {a_{n}b_{m}} \\ \end{pmatrix}.](img/file146.png
    "\begin{pmatrix} a_{1} \\ a_{2} \\ {\vdots} \\ a_{n} \\ \end{pmatrix} \otimes
    \begin{pmatrix} b_{1} \\ b_{2} \\ {\vdots} \\ b_{m} \\ \end{pmatrix} = \begin{pmatrix}
    {a_{1}\begin{pmatrix} b_{1} \\ b_{2} \\ {\vdots} \\ b_{m} \\ \end{pmatrix}} \\
    {a_{2}\begin{pmatrix} b_{1} \\ b_{2} \\ {\vdots} \\ b_{m} \\ \end{pmatrix}} \\
    {\vdots} \\ {a_{n}\begin{pmatrix} b_{1} \\ b_{2} \\ {\vdots} \\ b_{m} \\ \end{pmatrix}}
    \\ \end{pmatrix} = \begin{pmatrix} {a_{1}b_{1}} \\ {a_{1}b_{2}} \\ {\vdots} \\
    {a_{1}b_{m}} \\ {a_{2}b_{1}} \\ {a_{2}b_{2}} \\ {\vdots} \\ {a_{2}b_{m}} \\ {\vdots}
    \\ {a_{n}b_{1}} \\ {a_{n}b_{2}} \\ {\vdots} \\ {a_{n}b_{m}} \\ \end{pmatrix}.")'
  prefs: []
  type: TYPE_IMG
- en: Hence, the four basis states can be represented by four-dimensional column vectors
    given by
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| 0 \right\rangle \otimes \left| 0 \right\rangle = \begin{pmatrix} 1
    \\ 0 \\ 0 \\ 0 \\ \end{pmatrix},\qquad\left| 0 \right\rangle \otimes \left| 1
    \right\rangle = \begin{pmatrix} 0 \\ 1 \\ 0 \\ 0 \\ \end{pmatrix},\qquad\left|
    1 \right\rangle \otimes \left| 0 \right\rangle = \begin{pmatrix} 0 \\ 0 \\ 1 \\
    0 \\ \end{pmatrix},\qquad\left| 1 \right\rangle \otimes \left| 1 \right\rangle
    = \begin{pmatrix} 0 \\ 0 \\ 0 \\ 1 \\ \end{pmatrix}.](img/file147.png "\left|
    0 \right\rangle \otimes \left| 0 \right\rangle = \begin{pmatrix} 1 \\ 0 \\ 0 \\
    0 \\ \end{pmatrix},\qquad\left| 0 \right\rangle \otimes \left| 1 \right\rangle
    = \begin{pmatrix} 0 \\ 1 \\ 0 \\ 0 \\ \end{pmatrix},\qquad\left| 1 \right\rangle
    \otimes \left| 0 \right\rangle = \begin{pmatrix} 0 \\ 0 \\ 1 \\ 0 \\ \end{pmatrix},\qquad\left|
    1 \right\rangle \otimes \left| 1 \right\rangle = \begin{pmatrix} 0 \\ 0 \\ 0 \\
    1 \\ \end{pmatrix}.")'
  prefs: []
  type: TYPE_IMG
- en: Usually, we omit the ![\otimes](img/file145.png "\otimes") symbol and just write
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| 0 \right\rangle\left| 0 \right\rangle,\,\left| 0 \right\rangle\left|
    1 \right\rangle,\,\left| 1 \right\rangle\left| 0 \right\rangle,\,\left| 1 \right\rangle\left|
    1 \right\rangle](img/file148.png "\left| 0 \right\rangle\left| 0 \right\rangle,\,\left|
    0 \right\rangle\left| 1 \right\rangle,\,\left| 1 \right\rangle\left| 0 \right\rangle,\,\left|
    1 \right\rangle\left| 1 \right\rangle")'
  prefs: []
  type: TYPE_IMG
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| {00} \right\rangle,\,\left| {01} \right\rangle,\,\left| {10} \right\rangle,\,\left|
    {11} \right\rangle](img/file149.png "\left| {00} \right\rangle,\,\left| {01} \right\rangle,\,\left|
    {10} \right\rangle,\,\left| {11} \right\rangle")'
  prefs: []
  type: TYPE_IMG
- en: or even
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| 0 \right\rangle,\,\left| 1 \right\rangle,\,\left| 2 \right\rangle,\,\left|
    3 \right\rangle.](img/file150.png "\left| 0 \right\rangle,\,\left| 1 \right\rangle,\,\left|
    2 \right\rangle,\,\left| 3 \right\rangle.")'
  prefs: []
  type: TYPE_IMG
- en: Obviously, in this last case, the number of qubits that we are using must be
    clear from the context in order not to mistake the state ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle") of a one-qubit system with the state ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle") of a two-qubit system — or, as we will see soon, any
    other multi-qubit system!
  prefs: []
  type: TYPE_NORMAL
- en: As we have mentioned, these four states constitute a basis of the vector space
    of possible states for a two-qubit system. The general expression for the state
    of such a system is
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| \psi \right\rangle = a_{00}\left| {00} \right\rangle + a_{01}\left|
    {01} \right\rangle + a_{10}\left| {10} \right\rangle + a_{11}\left| {11} \right\rangle](img/file151.png
    "\left| \psi \right\rangle = a_{00}\left| {00} \right\rangle + a_{01}\left| {01}
    \right\rangle + a_{10}\left| {10} \right\rangle + a_{11}\left| {11} \right\rangle")'
  prefs: []
  type: TYPE_IMG
- en: where ![a_{00}](img/file152.png "a_{00}"), ![a_{01}](img/file153.png "a_{01}"),
    ![a_{10}](img/file154.png "a_{10}"), and ![a_{11}](img/file155.png "a_{11}") are
    complex numbers (called amplitudes, remember?) such that ![{\sum}_{x,y = 0}^{1}\left|
    a_{xy} \right|^{2} = 1](img/file156.png "{\sum}_{x,y = 0}^{1}\left| a_{xy} \right|^{2}
    = 1").
  prefs: []
  type: TYPE_NORMAL
- en: If we measure in the computational basis both qubits at this generic state that
    we are considering, we will obtain ![00](img/file157.png "00") with probability
    ![\left| a_{00} \right|^{2}](img/file158.png "\left| a_{00} \right|^{2}"), ![01](img/file159.png
    "01") with probability ![\left| a_{01} \right|^{2}](img/file160.png "\left| a_{01}
    \right|^{2}"), ![10](img/file161.png "10") with probability ![\left| a_{10} \right|^{2}](img/file162.png
    "\left| a_{10} \right|^{2}"), and ![11](img/file163.png "11") with probability
    ![\left| a_{11} \right|^{2}](img/file164.png "\left| a_{11} \right|^{2}"). In
    all those cases, the state will collapse to the state corresponding to the outcome
    of the measurement, just as with one-qubit systems.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now say that we only measure one of the qubits. What happens then? Suppose
    that we measure the first qubit. Then, the probability of obtaining ![0](img/file12.png
    "0") will be ![\left| a_{00} \right|^{2} + \left| a_{01} \right|^{2}](img/file165.png
    "\left| a_{00} \right|^{2} + \left| a_{01} \right|^{2}"), which is the sum of
    the probabilities of all the outcomes in which the first qubit can be ![0](img/file12.png
    "0"). If we measure the first qubit and the result turns out to be ![0](img/file12.png
    "0"), the system will not collapse completely, but it will remain in the state
  prefs: []
  type: TYPE_NORMAL
- en: '![\frac{a_{00}\left| {00} \right\rangle + a_{01}\left| {01} \right\rangle}{\sqrt{\left|
    a_{00} \right|^{2} + \left| a_{01} \right|^{2}}},](img/file166.png "\frac{a_{00}\left|
    {00} \right\rangle + a_{01}\left| {01} \right\rangle}{\sqrt{\left| a_{00} \right|^{2}
    + \left| a_{01} \right|^{2}}},")'
  prefs: []
  type: TYPE_IMG
- en: where we have divided by ![\sqrt{\left| a_{00} \right|^{2} + \left| a_{01} \right|^{2}}](img/file167.png
    "\sqrt{\left| a_{00} \right|^{2} + \left| a_{01} \right|^{2}}") to keep the state
    normalized. The situation in which the result of the measurement is ![1](img/file13.png
    "1") is analogous.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.10
  prefs: []
  type: TYPE_NORMAL
- en: Derive the formulas for the probability of measuring ![1](img/file13.png "1")
    on the first qubit in a general two-qubit state and for the state of the system
    after the measurement.
  prefs: []
  type: TYPE_NORMAL
- en: Dirac notation is also useful to compute inner products of two-qubit states.
    We only need to notice that
  prefs: []
  type: TYPE_NORMAL
- en: '![\left( {\left\langle \psi_{1} \right| \otimes \left\langle \psi_{2} \right|}
    \right)\left( {\left| \varphi_{1} \right\rangle \otimes \left| \varphi_{2} \right\rangle}
    \right) = \left\langle \psi_{1} \middle| \varphi_{1} \right\rangle\left\langle
    \psi_{2} \middle| \varphi_{2} \right\rangle,](img/file168.png "\left( {\left\langle
    \psi_{1} \right| \otimes \left\langle \psi_{2} \right|} \right)\left( {\left|
    \varphi_{1} \right\rangle \otimes \left| \varphi_{2} \right\rangle} \right) =
    \left\langle \psi_{1} \middle| \varphi_{1} \right\rangle\left\langle \psi_{2}
    \middle| \varphi_{2} \right\rangle,")'
  prefs: []
  type: TYPE_IMG
- en: apply distributivity and remember to conjugate the complex coefficients when
    obtaining a bra from a ket.
  prefs: []
  type: TYPE_NORMAL
- en: Then, for instance, we can notice that the inner product of ![\frac{4}{5}\left|
    {01} \right\rangle + \frac{3i}{5}\left| {11} \right\rangle](img/file169.png "\frac{4}{5}\left|
    {01} \right\rangle + \frac{3i}{5}\left| {11} \right\rangle") and ![\frac{1}{\sqrt{2}}\left|
    {00} \right\rangle + \frac{1}{\sqrt{2}}\left| {11} \right\rangle](img/file170.png
    "\frac{1}{\sqrt{2}}\left| {00} \right\rangle + \frac{1}{\sqrt{2}}\left| {11} \right\rangle")
    is
  prefs: []
  type: TYPE_NORMAL
- en: '![\begin{array}{rlrl} & {\left( {\frac{4}{5}\left\langle {01} \right| - \frac{3i}{5}\left\langle
    {11} \right|} \right)\left( {\frac{1}{\sqrt{2}}\left| {00} \right\rangle + \frac{1}{\sqrt{2}}\left|
    {11} \right\rangle} \right) = \qquad} & & \qquad \\ & {\quad\frac{4}{5\sqrt{2}}\left\langle
    01 \middle| 00 \right\rangle + \frac{4}{5\sqrt{2}}\left\langle 01 \middle| 11
    \right\rangle - \frac{3i}{5\sqrt{2}}\left\langle 11 \middle| 00 \right\rangle
    - \frac{3i}{5\sqrt{2}}\left\langle 11 \middle| 11 \right\rangle = \qquad} & &
    \qquad \\ & {\quad\frac{4}{5\sqrt{2}}\left\langle 0 \middle| 0 \right\rangle\left\langle
    1 \middle| 0 \right\rangle + \frac{4}{5\sqrt{2}}\left\langle 0 \middle| 1 \right\rangle\left\langle
    1 \middle| 1 \right\rangle - \frac{3i}{5\sqrt{2}}\left\langle 1 \middle| 0 \right\rangle\left\langle
    1 \middle| 0 \right\rangle - \frac{3i}{5\sqrt{2}}\left\langle 1 \middle| 1 \right\rangle\left\langle
    1 \middle| 1 \right\rangle = - \frac{3i}{5\sqrt{2}},\qquad} & & \qquad \\ \end{array}](img/file171.png
    "\begin{array}{rlrl}  & {\left( {\frac{4}{5}\left\langle {01} \right| - \frac{3i}{5}\left\langle
    {11} \right|} \right)\left( {\frac{1}{\sqrt{2}}\left| {00} \right\rangle + \frac{1}{\sqrt{2}}\left|
    {11} \right\rangle} \right) = \qquad} & & \qquad \\  & {\quad\frac{4}{5\sqrt{2}}\left\langle
    01 \middle| 00 \right\rangle + \frac{4}{5\sqrt{2}}\left\langle 01 \middle| 11
    \right\rangle - \frac{3i}{5\sqrt{2}}\left\langle 11 \middle| 00 \right\rangle
    - \frac{3i}{5\sqrt{2}}\left\langle 11 \middle| 11 \right\rangle = \qquad} & &
    \qquad \\  & {\quad\frac{4}{5\sqrt{2}}\left\langle 0 \middle| 0 \right\rangle\left\langle
    1 \middle| 0 \right\rangle + \frac{4}{5\sqrt{2}}\left\langle 0 \middle| 1 \right\rangle\left\langle
    1 \middle| 1 \right\rangle - \frac{3i}{5\sqrt{2}}\left\langle 1 \middle| 0 \right\rangle\left\langle
    1 \middle| 0 \right\rangle - \frac{3i}{5\sqrt{2}}\left\langle 1 \middle| 1 \right\rangle\left\langle
    1 \middle| 1 \right\rangle = - \frac{3i}{5\sqrt{2}},\qquad} & & \qquad \\ \end{array}")'
  prefs: []
  type: TYPE_IMG
- en: since ![\left\langle 0 \middle| 1 \right\rangle = \left\langle 1 \middle| 0
    \right\rangle = 0](img/file172.png "\left\langle 0 \middle| 1 \right\rangle =
    \left\langle 1 \middle| 0 \right\rangle = 0") and ![\left\langle 0 \middle| 0
    \right\rangle = \left\langle 1 \middle| 1 \right\rangle = 1](img/file173.png "\left\langle
    0 \middle| 0 \right\rangle = \left\langle 1 \middle| 1 \right\rangle = 1").
  prefs: []
  type: TYPE_NORMAL
- en: '1.4.2 Two-qubit gates: tensor products'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, the operations that we can conduct on two-qubit systems need to be
    unitary. Thus, two-qubit quantum gates are ![4 \times 4](img/file174.png "4 \times
    4") unitary matrices that act on 4-dimensional column vectors. The simplest way
    to construct such matrices is by taking the tensor product of two one-qubit quantum
    gates. Namely, if we consider two one-qubit gates ![U_{1}](img/file175.png "U_{1}")
    and ![U_{2}](img/file176.png "U_{2}") and two one-qubit states ![\left| \psi_{1}
    \right\rangle](img/file177.png "\left| \psi_{1} \right\rangle") and ![\left| \psi_{2}
    \right\rangle](img/file178.png "\left| \psi_{2} \right\rangle"), we can form a
    two-qubit gate ![U_{1} \otimes U_{2}](img/file179.png "U_{1} \otimes U_{2}") that
    acts on ![\left| \psi_{1} \right\rangle \otimes \left| \psi_{2} \right\rangle](img/file180.png
    "\left| \psi_{1} \right\rangle \otimes \left| \psi_{2} \right\rangle") as
  prefs: []
  type: TYPE_NORMAL
- en: '![\left( {U_{1} \otimes U_{2}} \right)\left( {\left| \psi_{1} \right\rangle
    \otimes \left| \psi_{2} \right\rangle} \right) = \left( {U_{1}\left| \psi_{1}
    \right\rangle} \right) \otimes \left( {U_{2}\left| \psi_{2} \right\rangle} \right).](img/file181.png
    "\left( {U_{1} \otimes U_{2}} \right)\left( {\left| \psi_{1} \right\rangle \otimes
    \left| \psi_{2} \right\rangle} \right) = \left( {U_{1}\left| \psi_{1} \right\rangle}
    \right) \otimes \left( {U_{2}\left| \psi_{2} \right\rangle} \right).")'
  prefs: []
  type: TYPE_IMG
- en: By linearity, we can extend ![U_{1} \otimes U_{2}](img/file179.png "U_{1} \otimes
    U_{2}") to any combination of two-qubit states and we can associate a matrix to
    ![U_{1} \otimes U_{2}](img/file179.png "U_{1} \otimes U_{2}"). In fact, said matrix
    is given by the tensor product of the matrices associated to ![U_{1}](img/file175.png
    "U_{1}") and ![U_{2}](img/file176.png "U_{2}"). More concretely, the expression
    for the tensor product, ![A \otimes B](img/file182.png "A \otimes B"), of the
    ![2 \times 2](img/file56.png "2 \times 2") matrices ![A](img/file183.png "A")
    and ![B](img/file184.png "B") is
  prefs: []
  type: TYPE_NORMAL
- en: '![\begin{array}{rlrl} {\begin{pmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \\
    \end{pmatrix} \otimes \begin{pmatrix} b_{11} & b_{12} \\ b_{21} & b_{22} \\ \end{pmatrix}}
    & {= \begin{pmatrix} {a_{11}\begin{pmatrix} b_{11} & b_{12} \\ b_{21} & b_{22}
    \\ \end{pmatrix}} & {a_{12}\begin{pmatrix} b_{11} & b_{12} \\ b_{21} & b_{22}
    \\ \end{pmatrix}} \\ {a_{21}\begin{pmatrix} b_{11} & b_{12} \\ b_{21} & b_{22}
    \\ \end{pmatrix}} & {a_{22}\begin{pmatrix} b_{11} & b_{12} \\ b_{21} & b_{22}
    \\ \end{pmatrix}} \\ \end{pmatrix}\qquad} & & \qquad \\ & {= \begin{pmatrix} {a_{11}b_{11}}
    & {a_{11}b_{12}} & {a_{12}b_{11}} & {a_{12}b_{12}} \\ {a_{11}b_{21}} & {a_{11}b_{22}}
    & {a_{12}b_{21}} & {a_{12}b_{22}} \\ {a_{21}b_{11}} & {a_{21}b_{12}} & {a_{22}b_{11}}
    & {a_{22}b_{12}} \\ {a_{21}b_{21}} & {a_{21}b_{22}} & {a_{22}b_{21}} & {a_{22}b_{22}}
    \\ \end{pmatrix}.\qquad} & & \qquad \\ \end{array}](img/file185.png "\begin{array}{rlrl}
    {\begin{pmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \\ \end{pmatrix} \otimes \begin{pmatrix}
    b_{11} & b_{12} \\ b_{21} & b_{22} \\ \end{pmatrix}} & {= \begin{pmatrix} {a_{11}\begin{pmatrix}
    b_{11} & b_{12} \\ b_{21} & b_{22} \\ \end{pmatrix}} & {a_{12}\begin{pmatrix}
    b_{11} & b_{12} \\ b_{21} & b_{22} \\ \end{pmatrix}} \\ {a_{21}\begin{pmatrix}
    b_{11} & b_{12} \\ b_{21} & b_{22} \\ \end{pmatrix}} & {a_{22}\begin{pmatrix}
    b_{11} & b_{12} \\ b_{21} & b_{22} \\ \end{pmatrix}} \\ \end{pmatrix}\qquad} &
    & \qquad \\  & {= \begin{pmatrix} {a_{11}b_{11}} & {a_{11}b_{12}} & {a_{12}b_{11}}
    & {a_{12}b_{12}} \\ {a_{11}b_{21}} & {a_{11}b_{22}} & {a_{12}b_{21}} & {a_{12}b_{22}}
    \\ {a_{21}b_{11}} & {a_{21}b_{12}} & {a_{22}b_{11}} & {a_{22}b_{12}} \\ {a_{21}b_{21}}
    & {a_{21}b_{22}} & {a_{22}b_{21}} & {a_{22}b_{22}} \\ \end{pmatrix}.\qquad} &
    & \qquad \\ \end{array}")'
  prefs: []
  type: TYPE_IMG
- en: Now it is easy to verify that this operation is indeed unitary and, hence, deserves
    the name of quantum gate.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.11
  prefs: []
  type: TYPE_NORMAL
- en: Check that, given any pair of unitary matrices ![U_{1}](img/file175.png "U_{1}")
    and ![U_{2}](img/file176.png "U_{2}"), the inverse of ![U_{1} \otimes U_{2}](img/file179.png
    "U_{1} \otimes U_{2}") is ![U_{1}^{\dagger} \otimes U_{2}^{\dagger}](img/file186.png
    "U_{1}^{\dagger} \otimes U_{2}^{\dagger}") and that ![{(U_{1} \otimes U_{2})}^{\dagger}
    = U_{1}^{\dagger} \otimes U_{2}^{\dagger}](img/file187.png "{(U_{1} \otimes U_{2})}^{\dagger}
    = U_{1}^{\dagger} \otimes U_{2}^{\dagger}").
  prefs: []
  type: TYPE_NORMAL
- en: 'Tensor products of gates occur naturally when we have circuits with two qubits
    and pairs of individual one-qubit gates are acting on each of them. For instance,
    in the following circuit, the gate ![X \otimes X](img/file188.png "X \otimes X")
    acts on the two qubits and then it is followed by the gate ![H \otimes I](img/file189.png
    "H \otimes I"), where ![I](img/file53.png "I") is the identity gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![XHX ](img/file190.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exercise 1.12
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly compute the matrices for the gates ![X \otimes X](img/file188.png
    "X \otimes X") and ![H \otimes I](img/file189.png "H \otimes I").
  prefs: []
  type: TYPE_NORMAL
- en: You may complain that we haven’t done anything new so far. And you would be
    right! In fact, quantum gates that are obtained as the tensor product of one-qubit
    gates can be seen as operations on isolated qubits that just happen to be applied
    at the same time. But wait and see! In the next subsection, we will introduce
    a completely different way of acting on two-qubit systems.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.3 The CNOT gate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By taking tensor products of one-qubit gates, we can only obtain operations
    that act on each qubit individually. But this just leaves us with a (rather boring)
    subset of all the possible two-qubit gates. There are many unitary matrices that
    cannot be written as the tensor product of other simple matrices. In the two-qubit
    case, probably the most important one is the **controlled-NOT** (or **controlled-**![\mathbf{X}](img/file191.png
    "\mathbf{X}")) gate, usually called the **CNOT gate**, given by the unitary matrix
  prefs: []
  type: TYPE_NORMAL
- en: '![\begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0
    & 1 & 0 \\ \end{pmatrix}.](img/file192.png "\begin{pmatrix} 1 & 0 & 0 & 0 \\ 0
    & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \\ \end{pmatrix}.")'
  prefs: []
  type: TYPE_IMG
- en: It is illuminating to see how this gate acts on the elements of the two-qubit
    computational basis. As you can easily check, we get
  prefs: []
  type: TYPE_NORMAL
- en: '![\text{CNOT}\left| {00} \right\rangle = \left| {00} \right\rangle,\qquad\text{CNOT}\left|
    {01} \right\rangle = \left| {01} \right\rangle,\qquad\text{CNOT}\left| {10} \right\rangle
    = \left| {11} \right\rangle,\qquad\text{CNOT}\left| {11} \right\rangle = \left|
    {10} \right\rangle.](img/file193.png "\text{CNOT}\left| {00} \right\rangle = \left|
    {00} \right\rangle,\qquad\text{CNOT}\left| {01} \right\rangle = \left| {01} \right\rangle,\qquad\text{CNOT}\left|
    {10} \right\rangle = \left| {11} \right\rangle,\qquad\text{CNOT}\left| {11} \right\rangle
    = \left| {10} \right\rangle.")'
  prefs: []
  type: TYPE_IMG
- en: This means that the value of the second qubit is flipped if and only if the
    value of the first qubit is ![1](img/file13.png "1"). Or, to put it in other words,
    the application of a NOT gate on the second qubit (that we call the **target**)
    is **controlled** by the first qubit. Now the name of this gate makes much more
    sense, doesn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: 'In a quantum circuit, the CNOT gate is represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](img/file194.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the control qubit is indicated by a solid black circle and the target
    qubit is indicated by the ![\oplus](img/file195.png "\oplus") symbol (the symbol
    for an ![X](img/file9.png "X") gate can also be used instead of ![\oplus](img/file195.png
    "\oplus")).
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, technical difficulties restrict the number of CNOT gates that can
    be actually implemented on a quantum computer. For instance, on a certain quantum
    chip you may have the possibility of applying a CNOT gate targeting qubit ![1](img/file13.png
    "1") and controlled by qubit ![0](img/file12.png "0"), but not the other way around.
    If you find yourself in such a situation, there’s no need to panic. If you use
    the circuit
  prefs: []
  type: TYPE_NORMAL
- en: '![HHHH ](img/file196.jpg)'
  prefs: []
  type: TYPE_IMG
- en: you are effectively applying a CNOT gate with target in the top qubit and control
    in the bottom one. And that’s how you can save the day!
  prefs: []
  type: TYPE_NORMAL
- en: 'The CNOT gate can also be used to interchange or **swap** the states of two
    qubits, by using the following circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](img/file197.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exercise 1.13
  prefs: []
  type: TYPE_NORMAL
- en: 'Check these equivalences in two different ways: by computing the matrices of
    the circuits and by obtaining the result of using them with qubits in states ![\left|
    {00} \right\rangle](img/file198.png "\left| {00} \right\rangle"), ![\left| {01}
    \right\rangle](img/file199.png "\left| {01} \right\rangle"), ![\left| {10} \right\rangle](img/file200.png
    "\left| {10} \right\rangle"), and ![\left| {11} \right\rangle](img/file201.png
    "\left| {11} \right\rangle").'
  prefs: []
  type: TYPE_NORMAL
- en: In any case, the most prominent use of the CNOT gate is, without a doubt, the
    ability to create entanglement, an intriguing property of quantum systems that
    we will study next.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.4 Entanglement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Oddly enough, in order to define when a quantum system is entangled, we first
    need to define when it is **not** entangled. We say that a state ![\left| \psi
    \right\rangle](img/file43.png "\left| \psi \right\rangle") is a **product state**
    if it can be written as the tensor product of two other states ![\left| \psi_{1}
    \right\rangle](img/file177.png "\left| \psi_{1} \right\rangle") and ![\left| \psi_{2}
    \right\rangle](img/file178.png "\left| \psi_{2} \right\rangle"), each of at least
    one qubit,
  prefs: []
  type: TYPE_NORMAL
- en: as in
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| \psi \right\rangle = \left| \psi_{1} \right\rangle \otimes \left|
    \psi_{2} \right\rangle.](img/file202.png "\left| \psi \right\rangle = \left| \psi_{1}
    \right\rangle \otimes \left| \psi_{2} \right\rangle.")'
  prefs: []
  type: TYPE_IMG
- en: If ![\left| \psi \right\rangle](img/file43.png "\left| \psi \right\rangle")
    is not a product state, we say that it is **entangled**.
  prefs: []
  type: TYPE_NORMAL
- en: For example, ![\left| {01} \right\rangle](img/file199.png "\left| {01} \right\rangle")
    is a product state, because we know that it is just another way of writing ![\left|
    0 \right\rangle \otimes \left| 1 \right\rangle](img/file203.png "\left| 0 \right\rangle
    \otimes \left| 1 \right\rangle"). Also, ![\sqrt{\left. 1\slash 2 \right.}(\left|
    {00} \right\rangle + \left| {10} \right\rangle)](img/file204.png "\sqrt{\left.
    1\slash 2 \right.}(\left| {00} \right\rangle + \left| {10} \right\rangle)") is
    a product state, because we can factor ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle") on the second qubit to obtain
  prefs: []
  type: TYPE_NORMAL
- en: '![\frac{1}{\sqrt{2}}(\left| {00} \right\rangle + \left| {10} \right\rangle)
    = \left( {\frac{1}{\sqrt{2}}\left( {\left| 0 \right\rangle + \left| 1 \right\rangle}
    \right)} \right)\left| 0 \right\rangle.](img/file205.png "\frac{1}{\sqrt{2}}(\left|
    {00} \right\rangle + \left| {10} \right\rangle) = \left( {\frac{1}{\sqrt{2}}\left(
    {\left| 0 \right\rangle + \left| 1 \right\rangle} \right)} \right)\left| 0 \right\rangle.")'
  prefs: []
  type: TYPE_IMG
- en: On the other hand, ![\sqrt{\left. 1\slash 2 \right.}\left( {\left| {00} \right\rangle
    + \left| {11} \right\rangle} \right)](img/file206.png "\sqrt{\left. 1\slash 2
    \right.}\left( {\left| {00} \right\rangle + \left| {11} \right\rangle} \right)")
    is an entangled state. No matter how hard you try, it is impossible to write it
    as a product of two one-qubit states. Suppose, for sake of contradiction, that
    it were possible. Then, you would have
  prefs: []
  type: TYPE_NORMAL
- en: '![\begin{array}{rlrl} {\frac{1}{\sqrt{2}}\left( {\left| {00} \right\rangle
    + \left| {11} \right\rangle} \right)} & {= \left( {a\left| 0 \right\rangle + b\left|
    1 \right\rangle} \right)\left( {c\left| 0 \right\rangle + d\left| 1 \right\rangle}
    \right)\qquad} & & \qquad \\ & {= ac\left| {00} \right\rangle + ad\left| {01}
    \right\rangle + bc\left| {01} \right\rangle + bd\left| {11} \right\rangle.\qquad}
    & & \qquad \\ \end{array}](img/file207.png "\begin{array}{rlrl} {\frac{1}{\sqrt{2}}\left(
    {\left| {00} \right\rangle + \left| {11} \right\rangle} \right)} & {= \left( {a\left|
    0 \right\rangle + b\left| 1 \right\rangle} \right)\left( {c\left| 0 \right\rangle
    + d\left| 1 \right\rangle} \right)\qquad} & & \qquad \\  & {= ac\left| {00} \right\rangle
    + ad\left| {01} \right\rangle + bc\left| {01} \right\rangle + bd\left| {11} \right\rangle.\qquad}
    & & \qquad \\ \end{array}")'
  prefs: []
  type: TYPE_IMG
- en: But this forces ![ad](img/file208.png "ad") to be ![0](img/file12.png "0"),
    because we have no ![\left| {01} \right\rangle](img/file199.png "\left| {01} \right\rangle")
    component in ![\sqrt{\left. 1\slash 2 \right.}(\left| {00} \right\rangle + \left|
    {11} \right\rangle)](img/file209.png "\sqrt{\left. 1\slash 2 \right.}(\left| {00}
    \right\rangle + \left| {11} \right\rangle)"). Then, either ![a = 0](img/file210.png
    "a = 0"), in which case ![ac](img/file211.png "ac") is ![0](img/file12.png "0"),
    or ![d = 0](img/file212.png "d = 0"), from which ![bd = 0](img/file213.png "bd
    = 0") follows. In both cases, it is impossible to reach the equality that we needed.
    Thus, it follows that the state is entangled.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.14
  prefs: []
  type: TYPE_NORMAL
- en: Is ![\sqrt{\left. 1\slash 3 \right.}(\left| {00} \right\rangle + \left| {01}
    \right\rangle + \left| {11} \right\rangle)](img/file214.png "\sqrt{\left. 1\slash
    3 \right.}(\left| {00} \right\rangle + \left| {01} \right\rangle + \left| {11}
    \right\rangle)") entangled? And what about ![\frac{1}{2}(\left| {00} \right\rangle
    + \left| {01} \right\rangle + \left| {10} \right\rangle + \left| {11} \right\rangle)](img/file215.png
    "\frac{1}{2}(\left| {00} \right\rangle + \left| {01} \right\rangle + \left| {10}
    \right\rangle + \left| {11} \right\rangle)")?
  prefs: []
  type: TYPE_NORMAL
- en: When measured, entangled states can show correlations that go beyond what can
    be explained with classical physics. For instance, if we have the entangled state
    ![\sqrt{\left. 1\slash 2 \right.}\left( {\left| {00} \right\rangle + \left| {11}
    \right\rangle} \right)](img/file206.png "\sqrt{\left. 1\slash 2 \right.}\left(
    {\left| {00} \right\rangle + \left| {11} \right\rangle} \right)") and we measure
    the first qubit, we can obtain ![0](img/file12.png "0") or ![1](img/file13.png
    "1"), each with probability ![\left. 1\slash 2 \right.](img/file136.png "\left.
    1\slash 2 \right."). However, if we measure the second qubit afterwards, the result
    will be completely determined by the value obtained when measuring the first qubit
    and, in fact, will be exactly the same. If we invert the order and measure first
    the second qubit, then the result will be ![0](img/file12.png "0") or ![1](img/file13.png
    "1"), with equal probability. But, in this case, the result of a subsequent measurement
    of the first qubit will be completely determined!
  prefs: []
  type: TYPE_NORMAL
- en: This still happens even if we separate the two qubits thousands of light years
    apart, as if one qubit could somehow know what the result of measuring the other
    qubit was. This curious behavior haunted many physicists during the 20th century,
    including Albert Einstein, who called it a *”spooky* *action at a distance”* (see
    [[34](ch030.xhtml#Xeinstein2014born)]). Nevertheless, the effects of entanglement
    have been repeatedly demonstrated in uncountable experiments (in fact, the Nobel
    Prize in Physics 2022 was awarded to Alain Aspect, John F. Clauser, and Anton
    Zeilinger, pioneers in studying and testing this phenomenon in practice [[10](ch030.xhtml#Xaspect1982experimental),
    [25](ch030.xhtml#Xclauser1969proposed), [41](ch030.xhtml#Xfreedman1972experimental),
    [19](ch030.xhtml#Xbouwmeester1997experimental)]). And, very importantly for us,
    entanglement is one of the most powerful resources available in quantum computing.
  prefs: []
  type: TYPE_NORMAL
- en: But entanglement is, by no means, the only puzzling feature of qubit systems.
    In the next subsection, we are going to mathematically prove that copying quantum
    information, an operation that you may have taken for granted, is not possible
    in general. These qubits are, indeed, full of surprises!
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.5 The no-cloning theorem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another peculiar property of quantum systems is that, in general, they don’t
    allow us to **copy information**. Surprising as this may seem, it is just an easy
    consequence of the linearity of quantum gates. To show why, let us be more precise
    about what we would need in order to copy information, for instance with just
    two qubits. We would like to have a two-qubit quantum gate ![U](img/file51.png
    "U") that will be able to copy the first qubit into the second. That is, for any
    given quantum state ![\left| \psi \right\rangle](img/file43.png "\left| \psi \right\rangle"),
    we would need
  prefs: []
  type: TYPE_NORMAL
- en: '![U\left| \psi \right\rangle\left| 0 \right\rangle = \left| \psi \right\rangle\left|
    \psi \right\rangle.](img/file216.png "U\left| \psi \right\rangle\left| 0 \right\rangle
    = \left| \psi \right\rangle\left| \psi \right\rangle.")'
  prefs: []
  type: TYPE_IMG
- en: Then, ![U\left| {00} \right\rangle = \left| {00} \right\rangle](img/file217.png
    "U\left| {00} \right\rangle = \left| {00} \right\rangle") and ![U\left| {10} \right\rangle
    = \left| {11} \right\rangle](img/file218.png "U\left| {10} \right\rangle = \left|
    {11} \right\rangle") and, by linearity,
  prefs: []
  type: TYPE_NORMAL
- en: '![U\left( {\frac{1}{\sqrt{2}}(\left| {00} \right\rangle + \left| {10} \right\rangle)}
    \right) = \frac{1}{\sqrt{2}}\left( {U\left| {00} \right\rangle + U\left| {10}
    \right\rangle} \right) = \frac{1}{\sqrt{2}}\left( {\left| {00} \right\rangle +
    \left| {11} \right\rangle} \right).](img/file219.png "U\left( {\frac{1}{\sqrt{2}}(\left|
    {00} \right\rangle + \left| {10} \right\rangle)} \right) = \frac{1}{\sqrt{2}}\left(
    {U\left| {00} \right\rangle + U\left| {10} \right\rangle} \right) = \frac{1}{\sqrt{2}}\left(
    {\left| {00} \right\rangle + \left| {11} \right\rangle} \right).")'
  prefs: []
  type: TYPE_IMG
- en: We should highlight that the state that we have obtained is entangled, as we
    proved in the previous subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, notice that, in our original state, we can factor the second ![\left|
    0 \right\rangle](img/file6.png "\left| 0 \right\rangle") out to obtain
  prefs: []
  type: TYPE_NORMAL
- en: '![\frac{1}{\sqrt{2}}(\left| {00} \right\rangle + \left| {10} \right\rangle)
    = \left( \frac{\left| 0 \right\rangle + \left| 1 \right\rangle}{\sqrt{2}} \right)\left|
    0 \right\rangle.](img/file220.png "\frac{1}{\sqrt{2}}(\left| {00} \right\rangle
    + \left| {10} \right\rangle) = \left( \frac{\left| 0 \right\rangle + \left| 1
    \right\rangle}{\sqrt{2}} \right)\left| 0 \right\rangle.")'
  prefs: []
  type: TYPE_IMG
- en: Then, in virtue of the action of ![U](img/file51.png "U"), we should have
  prefs: []
  type: TYPE_NORMAL
- en: '![U\left( {\frac{1}{\sqrt{2}}(\left| {00} \right\rangle + \left| {10} \right\rangle)}
    \right) = U\left( {\left( \frac{\left| 0 \right\rangle + \left| 1 \right\rangle}{\sqrt{2}}
    \right)\left| 0 \right\rangle} \right) = \frac{(\left| 0 \right\rangle + \left|
    1 \right\rangle)}{\sqrt{2}}\frac{(\left| 0 \right\rangle + \left| 1 \right\rangle)}{\sqrt{2}},](img/file221.png
    "U\left( {\frac{1}{\sqrt{2}}(\left| {00} \right\rangle + \left| {10} \right\rangle)}
    \right) = U\left( {\left( \frac{\left| 0 \right\rangle + \left| 1 \right\rangle}{\sqrt{2}}
    \right)\left| 0 \right\rangle} \right) = \frac{(\left| 0 \right\rangle + \left|
    1 \right\rangle)}{\sqrt{2}}\frac{(\left| 0 \right\rangle + \left| 1 \right\rangle)}{\sqrt{2}},")'
  prefs: []
  type: TYPE_IMG
- en: which is a product state. However, we had obtained earlier that ![U(\sqrt{\left.
    1\slash 2 \right.}(\left| {00} \right\rangle + \left| {10} \right\rangle)) = \sqrt{\left.
    1\slash 2 \right.}(\left| {00} \right\rangle + \left| {11} \right\rangle)](img/file222.png
    "U(\sqrt{\left. 1\slash 2 \right.}(\left| {00} \right\rangle + \left| {10} \right\rangle))
    = \sqrt{\left. 1\slash 2 \right.}(\left| {00} \right\rangle + \left| {11} \right\rangle)"),
    which is entangled! This contradiction implies that, alas, no such ![U](img/file51.png
    "U") exists.
  prefs: []
  type: TYPE_NORMAL
- en: This remarkable result is called the **no-cloning theorem** and we should explain
    its meaning in a little more detail. On the one hand, notice that this does not
    imply that we cannot copy classical information. In fact, if ![\left| \psi \right\rangle](img/file43.png
    "\left| \psi \right\rangle") is just ![\left| 0 \right\rangle](img/file6.png "\left|
    0 \right\rangle") or ![\left| 1 \right\rangle](img/file14.png "\left| 1 \right\rangle"),
    we can easily achieve ![U\left| \psi \right\rangle\left| 0 \right\rangle = \left|
    \psi \right\rangle\left| \psi \right\rangle](img/file223.png "U\left| \psi \right\rangle\left|
    0 \right\rangle = \left| \psi \right\rangle\left| \psi \right\rangle") by taking
    ![U](img/file51.png "U") to be the CNOT gate. On the other hand, the theorem applies
    to unknown states ![\left| \psi \right\rangle](img/file43.png "\left| \psi \right\rangle").
    If we know what ![\left| \psi \right\rangle](img/file43.png "\left| \psi \right\rangle")
    is — that is, if we know a circuit that prepares ![\left| \psi \right\rangle](img/file43.png
    "\left| \psi \right\rangle") starting from ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle") — then, of course, we can create as many independent
    copies of it as we want. However, if ![\left| \psi \right\rangle](img/file43.png
    "\left| \psi \right\rangle") is handed to us without any additional information
    about its state, the no-cloning theorem shows that we cannot replicate its state
    in general.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: The no-cloning theorem plays an important role in the security of quantum key
    distribution protocols such as the famous **BB84**, introduced in 1984 by Bennett
    and Brassard [[13](ch030.xhtml#Xbennett84quantum)].
  prefs: []
  type: TYPE_NORMAL
- en: After this brief detour, let’s return to our study of two-qubit quantum gates.
    In the next subsection, we will show how to construct many interesting two-qubit
    unitary operations whose action is controlled by one of their inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.6 Controlled gates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be wondering if, in addition to a controlled-![X](img/file9.png "X")
    (or CNOT) gate, there are also **controlled-**![\mathbf{Y}](img/file224.png "\mathbf{Y}"),
    **controlled-**![\mathbf{Z}](img/file225.png "\mathbf{Z}"), or **controlled-**![\mathbf{H}](img/file226.png
    "\mathbf{H}") gates. The answer is a resounding yes and, in fact, for any quantum
    gate ![U](img/file51.png "U"), it is possible to define a **controlled-**![U](img/file51.png
    "U") (or, simply, ![\text{C}\mathbf{U}](img/file227.png "\text{C}\mathbf{U}"))
    gate whose action on the computational basis is
  prefs: []
  type: TYPE_NORMAL
- en: '![\text{C}U\left| {00} \right\rangle = \left| {00} \right\rangle,\qquad\text{C}U\left|
    {01} \right\rangle = \left| {01} \right\rangle,\qquad\text{C}U\left| {10} \right\rangle
    = \left| 1 \right\rangle U\left| 0 \right\rangle,\qquad\text{C}U\left| {11} \right\rangle
    = \left| 1 \right\rangle U\left| 1 \right\rangle.](img/file228.png "\text{C}U\left|
    {00} \right\rangle = \left| {00} \right\rangle,\qquad\text{C}U\left| {01} \right\rangle
    = \left| {01} \right\rangle,\qquad\text{C}U\left| {10} \right\rangle = \left|
    1 \right\rangle U\left| 0 \right\rangle,\qquad\text{C}U\left| {11} \right\rangle
    = \left| 1 \right\rangle U\left| 1 \right\rangle.")'
  prefs: []
  type: TYPE_IMG
- en: Exercise 1.15
  prefs: []
  type: TYPE_NORMAL
- en: Check that the matrix of ![\text{C}U](img/file229.png "\text{C}U") is
  prefs: []
  type: TYPE_NORMAL
- en: '![\begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & u_{11} & u_{12}
    \\ 0 & 0 & u_{21} & u_{22} \\ \end{pmatrix},](img/file230.png "\begin{pmatrix}
    1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & u_{11} & u_{12} \\ 0 & 0 & u_{21} &
    u_{22} \\ \end{pmatrix},")'
  prefs: []
  type: TYPE_IMG
- en: where ![{(u_{ij})}_{i,j = 1}^{2}](img/file231.png "{(u_{ij})}_{i,j = 1}^{2}")
    is the matrix of ![U](img/file51.png "U"). Check also that ![\text{C}U](img/file229.png
    "\text{C}U") is unitary. What is the adjoint of ![\text{C}U](img/file229.png "\text{C}U")?
  prefs: []
  type: TYPE_NORMAL
- en: The circuit representation of a ![\text{C}U](img/file229.png "\text{C}U") gate
    is similar to the one that we use for the CNOT gate, namely
  prefs: []
  type: TYPE_NORMAL
- en: '![U ](img/file232.jpg) ,'
  prefs: []
  type: TYPE_NORMAL
- en: where the solid black circle indicates the control and the box with ![U](img/file51.png
    "U") inside indicates the target.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a controlled gate is simpler than it seems, provided your quantum
    computer already implements rotation gates and the two-qubit CNOT gate. In fact,
    from the decomposition in rotations that we mentioned at the end of *Section*
    *[*1.3.4*](#x1-250001.3.4), it can be proved (see the book by Nielsen and Chuang
    [[69](ch030.xhtml#Xnielsen11quantum), Corollary 4.2]) that any one-qubit quantum
    gate ![U](img/file51.png "U") can be written in the form*
  prefs: []
  type: TYPE_NORMAL
- en: '*![U = e^{i\theta}AXBXC](img/file233.png "U = e^{i\theta}AXBXC")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for some angle ![\theta](img/file89.png "\theta") and gates ![A](img/file183.png
    "A"), ![B](img/file184.png "B"), and ![C](img/file234.png "C") such that ![ABC
    = I](img/file235.png "ABC = I"). Then, the following circuit implements ![\text{C}U](img/file229.png
    "\text{C}U"):'
  prefs: []
  type: TYPE_NORMAL
- en: '![RCBA (𝜃) Z ](img/file236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes, though, constructing a controlled gate is much easier. For instance,
    it can be shown that a controlled-![Z](img/file8.png "Z") gate can be obtained
    from a controlled-![X](img/file9.png "X") and two ![H](img/file10.png "H") gates,
    as shown in the identity of the following circuits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Z ](img/file237.jpg) ![\qquad = \qquad](img/file238.png "\qquad = \qquad")
    ![HH ](img/file239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exercise 1.16
  prefs: []
  type: TYPE_NORMAL
- en: Prove the preceding equivalence.
  prefs: []
  type: TYPE_NORMAL
- en: We now have everything we need in order to construct our first two-qubit quantum
    circuit. Let’s get those qubits entangled!
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.7 Hello, entangled world!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To finish up with our study of two-qubit systems, let us show how to create
    entangled states with the help of the CNOT gate. Consider the following circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![|H|00⟩⟩ ](img/file240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Initially, the state of the system is ![\left| {00} \right\rangle](img/file198.png
    "\left| {00} \right\rangle"). After we apply the ![H](img/file10.png "H") gate,
    we get into the state ![\sqrt{\left. 1\slash 2 \right.}(\left| {00} \right\rangle
    + \left| {10} \right\rangle)](img/file204.png "\sqrt{\left. 1\slash 2 \right.}(\left|
    {00} \right\rangle + \left| {10} \right\rangle)"). Finally, when we apply the
    CNOT gate, the state changes to ![\sqrt{\left. 1\slash 2 \right.}(\left| {00}
    \right\rangle + \left| {11} \right\rangle)](img/file209.png "\sqrt{\left. 1\slash
    2 \right.}(\left| {00} \right\rangle + \left| {11} \right\rangle)"), which, as
    we proved in *Section* * [*1.4.4*](#x1-310001.4.4), is indeed an entangled state.*
  prefs: []
  type: TYPE_NORMAL
- en: '*The state ![\sqrt{\left. 1\slash 2 \right.}\left( {\left| {00} \right\rangle
    + \left| {11} \right\rangle} \right)](img/file206.png "\sqrt{\left. 1\slash 2
    \right.}\left( {\left| {00} \right\rangle + \left| {11} \right\rangle} \right)")
    is known as a **Bell state**, of which there are four. The other three are ![\sqrt{\left.
    1\slash 2 \right.}\left( {\left| {00} \right\rangle - \left| {11} \right\rangle}
    \right)](img/file241.png "\sqrt{\left. 1\slash 2 \right.}\left( {\left| {00} \right\rangle
    - \left| {11} \right\rangle} \right)"), ![\sqrt{\left. 1\slash 2 \right.}(\left|
    {10} \right\rangle + \left| {01} \right\rangle)](img/file242.png "\sqrt{\left.
    1\slash 2 \right.}(\left| {10} \right\rangle + \left| {01} \right\rangle)"), and
    ![\sqrt{\left. 1\slash 2 \right.}(\left| {10} \right\rangle - \left| {01} \right\rangle)](img/file243.png
    "\sqrt{\left. 1\slash 2 \right.}(\left| {10} \right\rangle - \left| {01} \right\rangle)").
    All of them are entangled, and they can be prepared with circuits similar to the
    preceding one.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.17
  prefs: []
  type: TYPE_NORMAL
- en: 'Show that all four Bell states are entangled. Obtain circuits to prepare them.
    *Hint*: you can use ![Z](img/file8.png "Z") and ![X](img/file9.png "X") gates
    after the CNOT in the preceding circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready for the big moment. In the next section, we will finally learn
    how to work with not just one or two qubits, but with as many as we can get in
    our quantum computers.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5 Working with multiple qubits and universality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have mastered working with two-qubit systems, it will be fairly
    straightforward to generalize all the notions that we have been studying to the
    case in which the number of qubits in our circuits is arbitrarily big. You know
    the drill: we will start by defining, mathematically, what a multi-qubit system
    is, we will then learn how to measure it and, finally, we will introduce quantum
    gates that act on many qubits at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.1 Multi-qubit systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With all that we have learned so far, it will now be very easy to understand
    how to work with **multi-qubit systems**.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have already deduced, if we have ![n](img/file244.png "n") qubits,
    the states that constitute the computational basis are
  prefs: []
  type: TYPE_NORMAL
- en: '![\begin{matrix} {\left| 0 \right\rangle \otimes \left| 0 \right\rangle \otimes
    \cdots \otimes \left| 0 \right\rangle,} & \\ {\left| 0 \right\rangle \otimes \left|
    0 \right\rangle \otimes \cdots \otimes \left| 1 \right\rangle,} & \\ {\vdots}
    & \\ {\left| 1 \right\rangle \otimes \left| 1 \right\rangle \otimes \cdots \otimes
    \left| 1 \right\rangle.} & \\ \end{matrix}](img/file245.png "\begin{matrix} {\left|
    0 \right\rangle \otimes \left| 0 \right\rangle \otimes \cdots \otimes \left| 0
    \right\rangle,} & \\ {\left| 0 \right\rangle \otimes \left| 0 \right\rangle \otimes
    \cdots \otimes \left| 1 \right\rangle,} & \\ {\vdots} & \\ {\left| 1 \right\rangle
    \otimes \left| 1 \right\rangle \otimes \cdots \otimes \left| 1 \right\rangle.}
    & \\ \end{matrix}")'
  prefs: []
  type: TYPE_IMG
- en: We usually omit the ![\otimes](img/file145.png "\otimes") symbol to write
  prefs: []
  type: TYPE_NORMAL
- en: '![\begin{matrix} {\left| 0 \right\rangle\left| 0 \right\rangle\cdots\left|
    0 \right\rangle,} & \\ {\left| 0 \right\rangle\left| 0 \right\rangle\cdots\left|
    1 \right\rangle,} & \\ {\left| 1 \right\rangle\left| 1 \right\rangle\cdots\left|
    1 \right\rangle} & \\ \end{matrix}](img/file246.png "\begin{matrix} {\left| 0
    \right\rangle\left| 0 \right\rangle\cdots\left| 0 \right\rangle,} & \\ {\left|
    0 \right\rangle\left| 0 \right\rangle\cdots\left| 1 \right\rangle,} & \\ {\left|
    1 \right\rangle\left| 1 \right\rangle\cdots\left| 1 \right\rangle} & \\ \end{matrix}")'
  prefs: []
  type: TYPE_IMG
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| {00\cdots 0} \right\rangle,\left| {00\cdots 1} \right\rangle,\ldots,\left|
    {11\cdots 1} \right\rangle](img/file247.png "\left| {00\cdots 0} \right\rangle,\left|
    {00\cdots 1} \right\rangle,\ldots,\left| {11\cdots 1} \right\rangle")'
  prefs: []
  type: TYPE_IMG
- en: or simply
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| 0 \right\rangle,\left| 1 \right\rangle,\ldots,\left| {2^{n} - 1} \right\rangle.](img/file248.png
    "\left| 0 \right\rangle,\left| 1 \right\rangle,\ldots,\left| {2^{n} - 1} \right\rangle.")'
  prefs: []
  type: TYPE_IMG
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When using the ![\left| 0 \right\rangle,\left| 1 \right\rangle,\ldots,\left|
    {2^{n} - 1} \right\rangle](img/file249.png "\left| 0 \right\rangle,\left| 1 \right\rangle,\ldots,\left|
    {2^{n} - 1} \right\rangle") notation for basis states, the total number of qubits
    must be clear from context. Otherwise, a state like, for example, ![\left| 2 \right\rangle](img/file250.png
    "\left| 2 \right\rangle") might mean either ![\left| {10} \right\rangle](img/file200.png
    "\left| {10} \right\rangle"), ![\left| {010} \right\rangle](img/file251.png "\left|
    {010} \right\rangle"), ![\left| {0010} \right\rangle](img/file252.png "\left|
    {0010} \right\rangle"), or any string with leading zeroes and ending in ![10](img/file161.png
    "10")…and that would be an intolerable ambiguity!
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a generic state of the system will then be of the form
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| \psi \right\rangle = a_{0}\left| 0 \right\rangle + a_{1}\left| 1 \right\rangle
    + \ldots + a_{2^{n} - 1}\left| {2^{n} - 1} \right\rangle](img/file253.png "\left|
    \psi \right\rangle = a_{0}\left| 0 \right\rangle + a_{1}\left| 1 \right\rangle
    + \ldots + a_{2^{n} - 1}\left| {2^{n} - 1} \right\rangle")'
  prefs: []
  type: TYPE_IMG
- en: subject to the only condition that the amplitudes ![a_{i}](img/file254.png "a_{i}")
    should be complex numbers such that ![{\sum}_{l = 0}^{2^{n} - 1}\left| a_{l} \right|^{2}
    = 1](img/file255.png "{\sum}_{l = 0}^{2^{n} - 1}\left| a_{l} \right|^{2} = 1").
    Our dear old friend, the normalization condition!
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the number of parameters describing the general state of an ![n](img/file244.png
    "n")-qubit system is exponential in ![n](img/file244.png "n"). For highly entangled
    states, we do not know how to represent all this information in a more succinct
    way and it is strongly suspected that it is not possible. Part of the power of
    quantum computing comes from this possibility of implicitly working with ![2^{n}](img/file256.png
    "2^{n}") complex numbers by manipulating just ![n](img/file244.png "n") qubits.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.18
  prefs: []
  type: TYPE_NORMAL
- en: 'Check that the basis state ![\left| j \right\rangle](img/file257.png "\left|
    j \right\rangle") is represented by a ![2^{n}](img/file256.png "2^{n}")-dimensional
    column vector whose ![j](img/file258.png "j")-th component is 1, while the rest
    are 0 (*Hint*: Use, repeatedly, the expression for the tensor product of column
    vectors that we discussed in *Section* * [*1.4.1*](#x1-280001.4.1) and the fact
    that the tensor product is associative). Deduce that any ![n](img/file244.png
    "n")-qubit state can be represented by a ![2^{n}](img/file256.png "2^{n}")-dimensional
    column vector with unit length.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*If we decide to measure all the qubits of the system in the computational
    basis, we will obtain ![m](img/file259.png "m") with probability ![\left| a_{m}
    \right|^{2}](img/file260.png "\left| a_{m} \right|^{2}"). If that is the case,
    then the state will collapse to ![\left| m \right\rangle](img/file261.png "\left|
    m \right\rangle"). But if we only measure one of the qubits, say the ![j](img/file258.png
    "j")-th one, then we will obtain ![0](img/file12.png "0") with probability'
  prefs: []
  type: TYPE_NORMAL
- en: '![\sum\limits_{l \in J_{0}}\left| a_{l} \right|^{2},](img/file262.png "\sum\limits_{l
    \in J_{0}}\left| a_{l} \right|^{2},")'
  prefs: []
  type: TYPE_IMG
- en: where ![J_{0}](img/file263.png "J_{0}") is the set of numbers whose ![j](img/file258.png
    "j")-th bit is ![0](img/file12.png "0"). In this scenario, the state of the system
    after measuring ![0](img/file12.png "0") would be
  prefs: []
  type: TYPE_NORMAL
- en: '![\frac{\sum\limits_{l \in J_{0}}a_{l}\left| l \right\rangle}{\sqrt{\sum\limits_{l
    \in J_{0}}\left| a_{i} \right|^{2}}}.](img/file264.png "\frac{\sum\limits_{l \in
    J_{0}}a_{l}\left| l \right\rangle}{\sqrt{\sum\limits_{l \in J_{0}}\left| a_{i}
    \right|^{2}}}.")'
  prefs: []
  type: TYPE_IMG
- en: Exercise 1.19
  prefs: []
  type: TYPE_NORMAL
- en: Derive the formulas for the case in which the result of the measurement is ![1](img/file13.png
    "1").
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.20
  prefs: []
  type: TYPE_NORMAL
- en: What is the probability of getting ![0](img/file12.png "0") when we measure
    the second qubit of ![\left. (1\slash 2)\left| {100} \right\rangle + (1\slash
    2)\left| {010} \right\rangle + \sqrt{\left. 1\slash 2 \right.}\left| {001} \right\rangle
    \right.](img/file265.png "\left. (1\slash 2)\left| {100} \right\rangle + (1\slash
    2)\left| {010} \right\rangle + \sqrt{\left. 1\slash 2 \right.}\left| {001} \right\rangle
    \right.")? What will the state be after the measurement if we indeed get ![0](img/file12.png
    "0")?
  prefs: []
  type: TYPE_NORMAL
- en: Computing inner products of ![n](img/file244.png "n")-qubit systems in Dirac
    notation is very similar to doing it with two-qubit systems. The procedure is
    analogous to the one we showed in *Section* * [*1.4.1*](#x1-280001.4.1), but taking
    into account that*
  prefs: []
  type: TYPE_NORMAL
- en: '*![\left( {\left\langle \psi_{1} \right| \otimes \ldots \otimes \left\langle
    \psi_{n} \right|} \right)\left( {\left| \varphi_{1} \right\rangle \otimes \ldots
    \otimes \left| \varphi_{n} \right\rangle} \right) = \left\langle \psi_{1} \middle|
    \varphi_{1} \right\rangle\ldots\left\langle \psi_{n} \middle| \varphi_{n} \right\rangle.](img/file266.png
    "\left( {\left\langle \psi_{1} \right| \otimes \ldots \otimes \left\langle \psi_{n}
    \right|} \right)\left( {\left| \varphi_{1} \right\rangle \otimes \ldots \otimes
    \left| \varphi_{n} \right\rangle} \right) = \left\langle \psi_{1} \middle| \varphi_{1}
    \right\rangle\ldots\left\langle \psi_{n} \middle| \varphi_{n} \right\rangle.")'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.21
  prefs: []
  type: TYPE_NORMAL
- en: Compute the inner product of ![\left| x \right\rangle](img/file267.png "\left|
    x \right\rangle") and ![\left| y \right\rangle](img/file268.png "\left| y \right\rangle"),
    where ![x](img/file269.png "x") and ![y](img/file270.png "y") are both binary
    strings of length ![n](img/file244.png "n"). Use your result to prove that ![{\{\left|
    x \right\rangle\}}_{x \in {\{ 0,1\}}^{n}}](img/file271.png "{\{\left| x \right\rangle\}}_{x
    \in {\{ 0,1\}}^{n}}") is, indeed, an orthonormal basis.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.22
  prefs: []
  type: TYPE_NORMAL
- en: Compute the inner product of the states ![\sqrt{\left. 1\slash 2 \right.}\left(
    {\left| {000} \right\rangle + \left| {111} \right\rangle} \right)](img/file272.png
    "\sqrt{\left. 1\slash 2 \right.}\left( {\left| {000} \right\rangle + \left| {111}
    \right\rangle} \right)") and ![\left. 1\slash 2\left( {\left| {000} \right\rangle
    + \left| {011} \right\rangle + \left| {101} \right\rangle + \left| {110} \right\rangle}
    \right) \right.](img/file273.png "\left. 1\slash 2\left( {\left| {000} \right\rangle
    + \left| {011} \right\rangle + \left| {101} \right\rangle + \left| {110} \right\rangle}
    \right) \right.").
  prefs: []
  type: TYPE_NORMAL
- en: We can now turn to the question of how to operate on many qubits at once. Let’s
    define multi-qubit gates!
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.2 Multi-qubit gates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since ![n](img/file244.png "n")-qubit states are represented by ![2^{n}](img/file256.png
    "2^{n}")-dimensional column vectors, ![n](img/file244.png "n")-qubit gates can
    be identified with ![2^{n} \times 2^{n}](img/file274.png "2^{n} \times 2^{n}")
    unitary matrices. Similar to the two-qubit case, we can construct ![n](img/file244.png
    "n")-qubit gates by taking the tensor product of gates on a smaller number of
    qubits. Namely, if ![U_{1}](img/file175.png "U_{1}") is an ![n_{1}](img/file275.png
    "n_{1}")-qubit gate and ![U_{2}](img/file176.png "U_{2}") is an ![n_{2}](img/file276.png
    "n_{2}")-qubit gate, then ![U_{1} \otimes U_{2}](img/file179.png "U_{1} \otimes
    U_{2}") is an ![(n_{1} + n_{2})](img/file277.png "(n_{1} + n_{2})")-qubit gate
    and its matrix is given by the tensor product of the matrices ![U_{1}](img/file175.png
    "U_{1}") and ![U_{2}](img/file176.png "U_{2}").
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: The expression for the tensor product of two matrices ![A](img/file183.png "A")
    and ![B](img/file184.png "B") is
  prefs: []
  type: TYPE_NORMAL
- en: '![\begin{pmatrix} a_{11} & {\ldots} & a_{1q} \\ {\vdots} & \ddots & {\vdots}
    \\ a_{p1} & {\ldots} & a_{pq} \\ \end{pmatrix} \otimes B = \begin{pmatrix} {a_{11}B}
    & {\ldots} & {a_{1q}B} \\ {\vdots} & \ddots & {\vdots} \\ {a_{p1}B} & {\ldots}
    & {a_{pq}B} \\ \end{pmatrix}.](img/file278.png "\begin{pmatrix} a_{11} & {\ldots}
    & a_{1q} \\ {\vdots} & \ddots & {\vdots} \\ a_{p1} & {\ldots} & a_{pq} \\ \end{pmatrix}
    \otimes B = \begin{pmatrix} {a_{11}B} & {\ldots} & {a_{1q}B} \\ {\vdots} & \ddots
    & {\vdots} \\ {a_{p1}B} & {\ldots} & {a_{pq}B} \\ \end{pmatrix}.")'
  prefs: []
  type: TYPE_IMG
- en: However, there are ![n](img/file244.png "n")-qubit gates that cannot be constructed
    as tensor products of smaller gates. One such example is the **Toffoli** or **CCNOT**
    gate, a three-qubit gate that acts on the computational basis as
  prefs: []
  type: TYPE_NORMAL
- en: '![\text{CCNOT}\left| x \right\rangle\left| y \right\rangle\left| z \right\rangle
    = \left| x \right\rangle\left| y \right\rangle\left| {z \oplus \left( {x \land
    y} \right)} \right\rangle,](img/file279.png "\text{CCNOT}\left| x \right\rangle\left|
    y \right\rangle\left| z \right\rangle = \left| x \right\rangle\left| y \right\rangle\left|
    {z \oplus \left( {x \land y} \right)} \right\rangle,")'
  prefs: []
  type: TYPE_IMG
- en: where ![\oplus](img/file195.png "\oplus") is the **XOR** function and ![\land](img/file280.png
    "\land") is the symbol for the AND Boolean function. Thus, CCNOT applies a doubly
    controlled (in this case, by the first two qubits) NOT gate to the third qubit
    — hence the name!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.23
  prefs: []
  type: TYPE_NORMAL
- en: Obtain the matrix for the CCNOT gate and verify that it is unitary.
  prefs: []
  type: TYPE_NORMAL
- en: The Toffoli gate is important because, using it and with the help of auxiliary
    qubits, we can construct any classical Boolean operator. For instance, ![\text{CCNOT}\left|
    1 \right\rangle\left| 1 \right\rangle\left| z \right\rangle = \left| 1 \right\rangle\left|
    1 \right\rangle\left| {\neg z} \right\rangle](img/file281.png "\text{CCNOT}\left|
    1 \right\rangle\left| 1 \right\rangle\left| z \right\rangle = \left| 1 \right\rangle\left|
    1 \right\rangle\left| {\neg z} \right\rangle") (where ![\neg z](img/file282.png
    "\neg z") is the negation of ![z](img/file81.png "z")) and ![\text{CCNOT}\left|
    x \right\rangle\left| y \right\rangle\left| 0 \right\rangle = \left| x \right\rangle\left|
    y \right\rangle\left| {x \land y} \right\rangle](img/file283.png "\text{CCNOT}\left|
    x \right\rangle\left| y \right\rangle\left| 0 \right\rangle = \left| x \right\rangle\left|
    y \right\rangle\left| {x \land y} \right\rangle"). This shows that, with quantum
    circuits, we can simulate the behavior of any classical digital circuit at the
    cost of using some additional ancillary qubits, since any Boolean function can
    be built with just negations and conjunctions. This is somewhat surprising, because
    we know that all quantum gates are invertible, while not all Boolean functions
    are. It then follows that we could make all of our digital circuits reversible
    just by implementing a classical version of the Toffoli gate!
  prefs: []
  type: TYPE_NORMAL
- en: We will not be studying any other concrete examples of gates that act on three
    (or more!) qubits because, in fact, we can simulate their behavior with circuits
    that only use one- and two-qubit gates. Keep on reading to know how!
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.3 Universal gates in quantum computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Current quantum computers can’t implement every possible quantum gate. Instead,
    they rely on **universality results** that show how any unitary operation can
    be decomposed as a circuit that uses a reduced set of **primitive** gates. In
    previous sections, we mentioned, for instance, that any one-qubit gate can be
    obtained by using just ![R_{Z}](img/file120.png "R_{Z}") and ![R_{Y}](img/file119.png
    "R_{Y}") rotations. It turns out that similar results exist for the general case
    of ![n](img/file244.png "n")-qubit quantum gates.
  prefs: []
  type: TYPE_NORMAL
- en: To us, it will be important to know that, for any unitary operation, we can
    construct a circuit that implements it using only one-qubit gates and the CNOT
    gate. For this reason, we say that those gates are **universal** — in the same
    sense that, for example, negation and conjunction are universal for Boolean logic.
    This fact will be crucial for our study of **feature maps** and **variational
    forms** in connection to **quantum neural networks** and other quantum machine
    learning models.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: In addition to one-qubit gates plus CNOT, there are many other sets of universal
    gates. For instance, it can be shown that the three gates ![H](img/file10.png
    "H"), ![T](img/file74.png "T"), and CNOT can be used to approximate any unitary
    operation to any desired accuracy — and they are universal in that sense. See
    Section *4.5* of the book by Nielsen and Chuang [[69](ch030.xhtml#Xnielsen11quantum)]
    for proofs of these facts and for more examples of universal gate sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how CNOT and one-qubit gates can be used to implement any other
    quantum gate, the following circuit shows a possible decomposition of the Toffoli
    gate targeting the top qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTTTTHTTT††† ](img/file284.jpg) .'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.24
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the preceding circuit implements the Toffoli gate by checking its
    action on the states of the computational basis.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our review of the fundamentals of quantum computing. We’ve come
    a long way since the beginning of this chapter, but by now we have mastered all
    the mathematics that we will need in order to study quantum machine learning and
    quantum optimization algorithms. Soon, we will see all these concepts in action!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have introduced the quantum circuit model and the main
    concepts that it relies on: qubits, gates, and measurements. We have started by
    studying the most humble circuits, those that only have one or two qubits, but
    we have used our experience with them to grow all the way up to multi-qubit systems.
    In the process, we have discovered some powerful properties, such as superposition
    and entanglement, and we have mastered the mathematics — mainly some linear algebra
    — needed to work with them.'
  prefs: []
  type: TYPE_NORMAL
- en: These notions will be extremely valuable to us, because they make up the language
    in which we will be describing the quantum algorithms for machine learning and
    optimization that we will study in the rest of the book. Soon, all the pieces
    will come together to form a beautiful structure. And we will be able to appreciate
    it and understand it fully because of the solid foundations that we have acquired
    by now.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start applying all that we have learned by implementing
    and running quantum circuits on quantum simulators and on actual quantum computers.
    We don’t know about you, but we are pretty excited!*****************
  prefs: []
  type: TYPE_NORMAL
