["```py\nimport torchimport torchvision\nimport torchvision.transforms as transforms\ntorch.manual_seed(10)\n# Device configuration\ndevice = torch.device(\n    'cuda' if torch.cuda.is_available() else 'cpu')\n# MNIST dataset\nbatch_size = 100\ntrain_dataset = torchvision.datasets.MNIST(\n    root='../../data',train=True,\n    transform=transforms.ToTensor(),download=True)\ntest_dataset = torchvision.datasets.MNIST(\n    root='../../data', train=False,\n    transform=transforms.ToTensor())\n# Data loader\ntrain_loader = torch.utils.data.DataLoader(\n    dataset=train_dataset,batch_size=batch_size,\n    shuffle=True)\ntest_loader = torch.utils.data.DataLoader(\n    dataset=test_dataset,  batch_size=batch_size,\n    shuffle=False)\n```", "```py\ninput_size = 784# size of hidden layer\nhidden_size = 256\n# number of classes\nnum_classes = 10\n# number of epochs\nnum_epochs = 10\n# learning rate for the optimization process\nlearning_rate = 0.001\n```", "```py\nimport torch.nn as nnclass NeuralNet(nn.Module):\n    def __init__(self, input_size, hidden_size,\n        num_classes):\n        super(NeuralNet, self).__init__()\n        Self.fc_layer_1 = nn.Linear(input_size, hidden_size)\n        self.fc_layer_2 = nn.Linear(hidden_size, num_classes)\n    def forward(self, x):\n        out = self.fc_layer_1(x)\n        out = nn.ReLU()(out)\n        out = self.fc_layer_2(out)\n        return out\nmodel = NeuralNet(input_size, hidden_size,\n    num_classes).to(device)\n```", "```py\ncriterion = nn.CrossEntropyLoss()optimizer = torch.optim.Adam(model.parameters(),\n    lr=learning_rate)\n```", "```py\ntotal_step = len(train_loader)for epoch in range(num_epochs):\n    for i, (images, labels) in enumerate(train_loader):\n        images = images.reshape(-1, 28*28).to(device)\n        labels = labels.to(device)\n        # Forward pass to calculate output and loss\n        outputs = model(images)\n        loss = criterion(outputs, labels)\n        # Backpropagation and optimization\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n```", "```py\nwith torch.no_grad():    correct = 0\n    total = 0\n    for images, labels in test_loader:\n        images = images.reshape(-1, 28*28).to(device)\n        labels = labels.to(device)\n        outputs = model(images)\n        _, predicted = torch.max(outputs.data, 1)\n        total += labels.size(0)\n        correct += (predicted == labels).sum().item()\n    print('Accuracy of the network on the test images:\n         {} %'.format(100 * correct / total))\n```"]