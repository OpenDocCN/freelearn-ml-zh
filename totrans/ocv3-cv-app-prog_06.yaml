- en: Chapter 6. Filtering the Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 图像过滤
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Filtering images using low-pass filters
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用低通滤波器过滤图像
- en: Downsampling images with filters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用滤波器对图像进行下采样
- en: Filtering images using a median filter
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中值滤波器过滤图像
- en: Applying directional filters to detect edges
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用方向滤波器检测边缘
- en: Computing the Laplacian of an image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算图像的拉普拉斯算子
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Filtering is one of the fundamental tasks in signal and image processing. It
    is a process aimed at selectively extracting certain aspects of an image that
    are considered to convey important information in the context of a given application.
    Filtering removes noise in images, extracts interesting visual features, allows
    image resampling, and so on. It finds its roots in the general **Signals and Systems**
    theory. We will not cover this theory in detail here. However, this chapter will
    present some of the important concepts related to filtering and will show you
    how filters can be used in image-processing applications. But first, let's begin
    with a brief explanation of the concept of frequency domain analysis.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤是信号和图像处理中的基本任务之一。它是一个旨在选择性地提取图像中某些方面（在特定应用背景下被认为传达了重要信息）的过程。过滤可以去除图像中的噪声，提取有趣的视觉特征，允许图像重采样，等等。它源于一般的**信号与系统**理论。我们在这里不会详细讨论这个理论。然而，本章将介绍一些与过滤相关的重要概念，并展示如何在图像处理应用中使用过滤器。但首先，让我们从频率域分析的概念简要解释开始。
- en: When we look at an image, we observe different gray-levels (or colors) patterns
    laid out over it. Images differ from each other because they have different gray-level
    distributions. However, there is another point of view under which an image can
    be analyzed. We can look at the gray-level variations that are present in an image.
    Some images contain large areas of almost constant intensity (for example, a blue
    sky), while in other images, the gray-level intensities vary rapidly over the
    image (for example, a busy scene crowded with many small objects).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们观察图像时，我们观察到不同的灰度级（或颜色）模式覆盖在其上。图像之间的差异在于它们有不同的灰度级分布。然而，还有一种观点可以用来分析图像。我们可以观察图像中存在的灰度级变化。一些图像包含几乎恒定强度的大面积（例如，一片蓝天），而其他图像的灰度级强度在图像上快速变化（例如，一个拥挤的场景，充满了许多小物体）。
- en: Therefore, observing the frequency of these variations in an image constitutes
    another way of characterizing an image. This point of view is referred to as the
    **frequency domain**, while characterizing an image by observing its gray-level
    distribution is referred to as the **spatial domain**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，观察图像中这些变化的频率构成了表征图像的另一种方式。这种观点被称为**频域**，而通过观察其灰度级分布来表征图像则被称为**空间域**。
- en: The frequency domain analysis decomposes an image into its frequency content
    from the lowest to the highest frequencies. Areas where the image intensities
    vary slowly contain only low frequencies, while high frequencies are generated
    by rapid changes in intensities. Several well-known transformations exist, such
    as the **Fourier transform** or the **Cosine transform**, which can be used to
    explicitly show the frequency content of an image. Note that since an image is
    a two-dimensional entity, it is made of both vertical frequencies (variations
    in the vertical directions) and horizontal frequencies (variations in the horizontal
    directions).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 频域分析将图像分解为其从最低到最高频率的频率内容。图像强度变化缓慢的区域只包含低频，而高频是由强度快速变化产生的。存在几种著名的变换，如**傅里叶变换**或**余弦变换**，可以用来明确地显示图像的频率内容。请注意，由于图像是一个二维实体，它既包含垂直频率（垂直方向的变化）也包含水平频率（水平方向的变化）。
- en: Under the frequency domain analysis framework, a **filter** is an operation
    that amplifies certain bands of frequencies of an image (or leaves them unchanged)
    while blocking (or reducing) other image frequency bands. A low-pass filter is,
    for instance, a filter that eliminates the high-frequency components of an image;
    and reciprocally, a high-pass filter eliminates the low-frequency components.
    This chapter will present some filters that are frequently used in image processing
    and will explain their effect when applied on an image.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在频域分析框架下，**滤波器**是一种操作，它放大图像（或保持不变）的某些频率带，同时阻止（或减少）其他图像频率带。例如，低通滤波器是一种消除图像高频成分的滤波器；相反，高通滤波器消除低频成分。本章将介绍一些在图像处理中经常使用的滤波器，并解释它们在图像上应用时的效果。
- en: Filtering images using low-pass filters
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用低通滤波器进行图像滤波
- en: In this first recipe, we will present some very basic low-pass filters. In the
    introductory section of this chapter, we learned that the objective of such filters
    is to reduce the amplitude of the image variations. One simple way to achieve
    this goal is to replace each pixel with the average value of the pixels around
    it. By doing this, the rapid intensity variations will be smoothed out and thus
    replaced by more gradual transitions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个菜谱中，我们将介绍一些非常基本的低通滤波器。在本章的介绍部分，我们了解到这类滤波器的目的是减少图像变化的幅度。实现这一目标的一种简单方法是将每个像素替换为其周围像素的平均值。通过这样做，快速强度变化将被平滑，从而被更渐进的过渡所取代。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The objective of the `cv::blur` function is to smooth an image by replacing
    each pixel with the average pixel value computed over a rectangular neighborhood.
    This low-pass filter is applied as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::blur`函数的目标是通过用矩形邻域内计算的平均像素值替换每个像素来平滑图像。这个低通滤波器如下应用：'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This kind of filter is also called a **box filter**. Here, we applied it by
    using a `5x5` filter in order to make the filter''s effect more visible. Our original
    image is the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种滤波器也被称为**箱式滤波器**。在这里，我们通过使用`5x5`滤波器来应用它，以便使滤波器的影响更加明显。我们的原始图像如下所示：
- en: '![How to do it...](img/image_06_001.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_06_001.jpg)'
- en: 'The result of the filter being applied on the preceding image is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 应用在先前图像上的滤波器结果如下所示：
- en: '![How to do it...](img/image_06_002.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_06_002.jpg)'
- en: 'In some cases, it might be desirable to give more importance to the closer
    pixels in the neighborhood of a pixel. Therefore, it is possible to compute a
    weighted average in which nearby pixels are assigned a larger weight than ones
    that are further away. This can be achieved by using a weighted scheme that follows
    a **Gaussian function** (a "bell-shaped" function). The `cv::GaussianBlur` function
    applies such a filter and it is called as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能希望给邻域中较近的像素赋予更高的权重。因此，可以计算一个加权平均值，其中附近的像素被分配比较远的像素更大的权重。这可以通过使用遵循**高斯函数**（一种“钟形”函数）的加权方案来实现。`cv::GaussianBlur`函数应用这种滤波器，其调用方式如下：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result is then the following image:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是以下图像：
- en: '![How to do it...](img/image_06_003.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_06_003.jpg)'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A filter is said to be linear if its application corresponds to replacing a
    pixel with a weighted sum of neighboring pixels. This is the case of the mean
    filter in which a pixel is replaced by the sum of all pixels in a rectangular
    neighborhood divided by the size of this neighborhood (to get the average value).
    This is like multiplying each neighboring pixel by `1` over the total number of
    pixels and summing all of these values. The different weights of a filter can
    be represented using a matrix that shows the multiplying factors associated with
    each pixel position in the considered neighborhood.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个滤波器的应用对应于用一个像素替换为相邻像素的加权总和，那么这个滤波器被称为线性滤波器。这是均值滤波器的情况，其中一个像素被替换为矩形邻域内所有像素的总和除以邻域的大小（以获得平均值）。这就像将每个相邻像素乘以像素总数的`1`，然后将所有这些值相加。滤波器的不同权重可以用一个矩阵来表示，该矩阵显示了与考虑的邻域中每个像素位置相关的乘数。
- en: 'The central element of the matrix corresponds to the pixel on which the filter
    is currently applied. Such a matrix is sometimes called a **kernel** or a **mask**.
    For a `3x3` mean filter, the corresponding kernel would be as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的核心元素对应于当前应用滤波器的像素。这种矩阵有时被称为**核**或**掩模**。对于一个`3x3`均值滤波器，相应的核如下所示：
- en: '![How it works...](img/B05388_06_29.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B05388_06_29.jpg)'
- en: The `cv::boxFilter` function filters an image with a square kernel made of many
    `1`s only. It is similar to the mean filter but without dividing the result by
    the number of coefficients.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::boxFilter` 函数使用仅由许多 `1` 组成的正方形核过滤图像。它与均值滤波器相似，但不需要将结果除以系数的数量。'
- en: 'Applying a linear filter then corresponds to moving a kernel over each pixel
    of an image and multiplying each corresponding pixel by its associated weight.
    Mathematically, this operation is called a **convolution** and can formally be
    written as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 应用线性滤波器相当于将核在图像的每个像素上移动，并将每个对应的像素乘以其关联的权重。从数学上讲，这个操作被称为 **卷积**，可以正式写成以下形式：
- en: '![How it works...](img/B05388_06_24-300x43.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B05388_06_24-300x43.jpg)'
- en: The preceding double summation aligns the current pixel at `(x,y)` with the
    center of the kernel, which is assumed to be at coordinate `(0,0)`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的双重求和将当前像素 `(x,y)` 与核的中心对齐，假设核的中心在坐标 `(0,0)`。
- en: Looking at the output images produced in this recipe, it can be observed that
    the net effect of a low-pass filter is to blur or smooth the image. This is not
    surprising since this filter attenuates the high-frequency components that correspond
    to the rapid variations visible on an object's edge.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 观察本食谱生成的输出图像，可以观察到低通滤波器的净效应是模糊或平滑图像。这并不令人惊讶，因为该滤波器衰减了与物体边缘上可见的快速变化相对应的高频分量。
- en: 'In the case of a Gaussian filter, the weight associated with a pixel is proportional
    to its distance from the central pixel. Recall that the 1D Gaussian function has
    the following form:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在高斯滤波器的情况下，与像素关联的权重与其与中心像素的距离成正比。回想一下，1D 高斯函数具有以下形式：
- en: '![How it works...](img/B05388_06_25-300x88.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B05388_06_25-300x88.jpg)'
- en: 'The normalizing coefficient `A` is chosen so that the area under the Gaussian
    curve equals one. The σ (sigma) value controls the width of the resulting Gaussian
    function. The greater this value is, the flatter the function will be. For example,
    if we compute the coefficients of the 1D Gaussian filter for the interval `[-4,
    0, 4]` with σ = 0.5, we obtain the following coefficients:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正则化系数 `A` 被选择，使得高斯曲线下的面积等于一。σ (sigma) 值控制着结果高斯函数的宽度。这个值越大，函数就越平坦。例如，如果我们计算区间
    `[-4, 0, 4]` 的 1D 高斯滤波器的系数，σ = 0.5，我们得到以下系数：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For σ=1.5, these coefficients are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 σ=1.5，这些系数如下：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that these values were obtained by calling the `cv::getGaussianKernel`
    function with the appropriate σ value:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些值是通过调用 `cv::getGaussianKernel` 函数并使用适当的 σ 值获得的：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The shape of the Gaussian curve for these two σ values is shown in the following
    figure. The symmetrical bell shape of the Gaussian function makes it a good choice
    for filtering:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图中显示了这两个 σ 值对应的高斯曲线的形状。高斯函数的对称钟形使其成为过滤的良好选择：
- en: '![How it works...](img/image_06_006.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image_06_006.jpg)'
- en: As it can be observed, pixels farther from the center have a lower weight, which
    makes the pixel-to-pixel transitions smoother. This contrasts with the flat mean
    filter where pixels far away can cause sudden changes in the current mean value.
    In terms of frequencies, this implies that the mean filter does not remove all
    the high frequency components.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如观察所示，远离中心的像素权重较低，这使得像素间的过渡更平滑。这与平坦的均值滤波器形成对比，远离中心的像素可能导致当前均值值的突然变化。从频率的角度来看，这意味着均值滤波器不会移除所有的高频分量。
- en: To apply a 2D Gaussian filter on an image, one can simply apply a 1D Gaussian
    filter on the image lines first (to filter the horizontal frequencies), followed
    by the application of another 1D Gaussian filter on the image columns (to filter
    the vertical frequencies). This is possible because the Gaussian filter is a **separable
    filter** (that is, the 2D kernel can be decomposed into two 1D filters). The `cv::sepFilter2D`
    function can be used to apply a general separable filter. It is also possible
    to directly apply a 2D kernel using the `cv::filter2D` function. In general, separable
    filters are faster to compute than non-separable ones because they require less
    multiplication operations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要在图像上应用2D高斯滤波器，可以先在图像行上应用1D高斯滤波器（以过滤水平频率），然后应用另一个1D高斯滤波器在图像列上（以过滤垂直频率）。这是可能的，因为高斯滤波器是一个**可分离的滤波器**（即，2D核可以分解为两个1D滤波器）。可以使用`cv::sepFilter2D`函数应用一个通用的可分离滤波器。也可以直接使用`cv::filter2D`函数应用2D核。一般来说，可分离滤波器比不可分离滤波器计算速度更快，因为它们需要的乘法操作更少。
- en: With OpenCV, the Gaussian filter to be applied to an image is specified by providing
    both the number of coefficients (the third parameter, which is an odd number)
    and the value of σ (the fourth parameter) to `cv::GaussianBlur`. You can also
    simply set the value of σ and let OpenCV determine the appropriate number of coefficients
    (you then input a value of `0` for the filter size). The opposite is also possible,
    where you input a size and a value of `0` for σ. The σ value that best fits the
    given size will be determined.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenCV中，要应用于图像的高斯滤波器通过提供系数数量（第三个参数，为奇数）和σ的值（第四个参数）来指定`cv::GaussianBlur`。您也可以简单地设置σ的值，让OpenCV确定合适的系数数量（此时您为滤波器大小输入一个`0`值）。反之亦然，您可以输入一个大小和一个`0`值作为σ。将根据给定的大小确定最佳σ值。
- en: See also
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Downsampling images with filters* recipe explains how to reduce the size
    of an image using low-pass filters.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用滤波器对图像进行下采样*配方解释了如何使用低通滤波器减小图像的大小。'
- en: The *There's more...* section of the *Scanning an image with neighbor access
    recipe* in [Chapter 2](ch02.html "Chapter 2. Manipulating Pixels"), *Manipulating
    Pixels*, introduces the `cv::filter2D` function. This function lets you apply
    a linear filter to an image by inputting the kernel of your choice.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 操作像素")的“使用邻域访问配方扫描图像”的*更多内容...*部分中，介绍了`cv::filter2D`函数。此函数允许您通过输入您选择的核来对图像应用线性滤波器。
- en: Downsampling images with filters
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用滤波器对图像进行下采样
- en: Images often need to be resized (resampled). The process of reducing the size
    of an image is often called **downsampling**, while increasing its size is **upsampling**.
    The challenge in performing these operations is to ensure that the visual quality
    of the image is preserved as much as possible. To accomplish this objective, low-pass
    filters are often used; this recipe explains why.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图像通常需要调整大小（重采样）。减小图像大小的过程通常称为**下采样**，而增加其大小称为**上采样**。执行这些操作时的挑战是尽可能多地保留图像的视觉质量。为了实现这一目标，通常使用低通滤波器；本配方解释了原因。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: You might think that you can reduce the size of an image by simply eliminating
    some of the columns and rows of the image. Unfortunately, the resulting image
    will not look very nice. The following figure illustrates this fact by showing
    you a test image that is reduced by a factor of `4` with respect to its original
    size by simply keeping `1` of every `4` columns and rows.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为，通过简单地消除图像的一些列和行，就可以减小图像的大小。不幸的是，生成的图像看起来不会很好。以下图通过仅保留每4列和行的`1`列和行来将原始图像大小减少`4`倍，以说明这一事实。
- en: 'Note that to make the defects in this image more apparent, we zoom in on the
    image by displaying it with pixels that are four times larger:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了使此图像中的缺陷更加明显，我们通过以四倍像素大小显示图像来放大图像：
- en: '![How to do it...](img/image_06_007.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_06_007.jpg)'
- en: Clearly, one can see that the image quality has degraded. For example, the oblique
    edges of the castle's roof in the original image now appear as a staircase on
    the reduced image. Other jagged distortions are also visible on the textured parts
    of the image (the brick walls, for instance).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，可以看到图像质量已经下降。例如，原始图像中城堡屋顶的斜边现在在减小后的图像上表现为楼梯状。图像纹理部分（例如砖墙）的其他锯齿形扭曲也可见。
- en: These undesirable artifacts are caused by a phenomenon called **spatial aliasing**
    that occurs when you try to include high-frequency components in an image that
    is too small to contain them. Indeed, smaller images (that is, images with fewer
    pixels) cannot represent fine textures and sharp edges as nicely as higher resolution
    images (think of the difference between high-definition TV versus older TV technology).
    Since fine details in an image correspond to high frequencies, we need to remove
    these higher frequency components in an image before reducing its size.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不希望出现的伪影是由一种称为**空间混叠**的现象引起的，当你试图在无法容纳这些高频分量的过小图像中包含它们时。确实，较小的图像（即像素较少的图像）无法像高分辨率图像那样很好地表示精细纹理和锐利边缘（想想高清电视与较老电视技术的区别）。由于图像中的细微细节对应于高频，我们在减小图像尺寸之前需要移除这些高频分量。
- en: 'We learned in the previous recipe that this can be done through a low-pass
    filter. Consequently, to reduce the size of an image by four without adding annoying
    artifacts, you must first apply a low-pass filter to the original image before
    throwing away columns and rows. This is how you would do this using OpenCV:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在先前的菜谱中了解到，这可以通过低通滤波器来完成。因此，为了在不添加令人烦恼的伪影的情况下将图像尺寸减小四倍，你必须首先对原始图像应用低通滤波器，然后再丢弃列和行。这是使用OpenCV进行此操作的方法：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The resulting image (also displayed with pixel of four times the normal size)
    is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图像（也以四倍正常大小的像素显示）如下：
- en: '![How to do it...](img/image_06_008.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_06_008.jpg)'
- en: Of course, some of the fine details of the image have been lost, but globally,
    the visual quality of the image is better preserved than in the previous case
    (looking at this image from far away should convince you of the relative good
    quality of the image).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，图像的一些细微细节已经丢失，但从整体上看，图像的视觉质量比之前的情况（从远处看这张图像）要好得多。
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to avoid undesirable aliasing effect, an image must always be low-pass
    filtered before reducing its size. As we explained previously, the role of the
    low-pass filter is to eliminate the high-frequency components that cannot be represented
    in the reduced image. The formal theory demonstrating this fact is well established
    and is often referred to as the **Nyquist-Shannon theorem**. In substance, the
    theory tells us that if you downsample an image by two, then the bandwidth of
    the representable frequencies is also reduced by two.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免不希望的混叠效应，在减小图像尺寸之前，必须始终对图像进行低通滤波。正如我们之前解释的，低通滤波器的作用是消除在减小尺寸的图像中无法表示的高频分量。这一事实的正式理论已经建立，通常被称为**奈奎斯特-香农定理**。实质上，该理论告诉我们，如果你将图像下采样为原来的一半，那么可表示的频率带宽也将减少一半。
- en: 'A special OpenCV function performs image reduction using this principle. This
    is the `cv::pyrDown` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特殊的OpenCV函数使用这个原理进行图像减小。这是`cv::pyrDown`函数：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding function uses a `5x5` Gaussian filter to low-pass the image before
    reducing it by a factor of two. The reciprocal `cv::pyrUp` function that doubles
    the size of an image also exists. It is interesting to note that in this case,
    the upsampling is done by inserting the 0 values between every two columns and
    rows and then by applying the same `5x5` Gaussian filter (but with the coefficients
    multiplied by four) on the expanded image. Obviously, if you downsize an image
    and then upsize it, you will not recover the exact original image. What was lost
    during the downsizing process cannot be recovered. These two functions are used
    to create image pyramids. This is a data structure made of stacked versions of
    an image at different sizes built for efficient multi-scale image analysis. The
    resulting image is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数使用一个`5x5`高斯滤波器在减小图像尺寸之前对其进行低通滤波。存在一个相反的`cv::pyrUp`函数，可以将图像尺寸加倍。值得注意的是，在这种情况下，上采样是通过在每两列和每两行之间插入0值来完成的，然后对扩展后的图像应用相同的`5x5`高斯滤波器（但系数乘以四）。显然，如果你先减小图像尺寸，然后再将其放大，你将无法恢复原始图像。在减小尺寸过程中丢失的内容无法恢复。这两个函数用于创建图像金字塔。这是一种由不同尺寸的图像堆叠版本组成的数据结构，用于高效的多尺度图像分析。结果图像如下：
- en: '![How it works...](img/image_06_009.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/image_06_009.jpg)'
- en: Here, each level is two times smaller than the previous level, but the reduction
    factor can be less, and not necessarily an integer (for example, `1.2`). For example,
    if you want to efficiently detect an object in an image, the detection can be
    first accomplished on the small image at the top of the pyramid, and as you locate
    the object of interest, you can refine the search by moving to the lower levels
    of the pyramid that contains the higher resolution versions of the image.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个级别比前一个级别小两倍，但减少因子可以更小，不一定是整数（例如，`1.2`）。例如，如果你想高效地检测图像中的对象，可以先在小金字塔顶部的图像上完成检测，当你定位到感兴趣的对象时，可以通过移动到包含更高分辨率图像版本的金字塔较低级别来细化搜索。
- en: 'Note that there is also a more general `cv::resize` function that allows you
    to specify the size you want for the resulting image. You simply call it by specifying
    a new size that could be smaller or larger than the original image:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有一个更通用的 `cv::resize` 函数，允许你指定所需的结果图像大小。你只需通过指定一个新大小来调用它，这个大小可以比原始图像小或大：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It is also possible to specify resizing in terms of scale factors. In this
    case, an empty size instance is given as an argument followed by the desired scale
    factors:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以用缩放因子来指定调整大小。在这种情况下，给定的参数是一个空的大小实例，后跟所需的缩放因子：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A final parameter allows you to select the interpolation method that is to be
    used in the resampling process. This is discussed in the following section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最终参数允许你在重采样过程中选择要使用的插值方法。这将在下一节中讨论。
- en: There's more...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When an image is resized by a factional factor, it becomes necessary to perform
    some pixel interpolation in order to produce new pixel values at locations that
    fall in between the existing ones. General image remapping, as discussed in the
    *Remapping an image* recipe in  [Chapter 2](ch02.html "Chapter 2. Manipulating
    Pixels") , *Manipulating Pixels*, is another situation where pixel interpolation
    is required.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像按分数因子调整大小时，必须执行一些像素插值，以便在现有像素之间产生新的像素值。正如在第二章“操作像素”中的“重映射图像”配方所讨论的通用图像重映射，这也是需要像素插值的情况。
- en: Interpolating pixel values
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插值像素值
- en: 'The most basic approach to perform interpolation is to use a nearest neighbor
    strategy. The new grid of pixels that must be produced is placed on top of the
    existing image, and each new pixel is assigned the value of its closest pixel
    in the original image. In the case of image upsampling (that is, when using a
    new grid denser than the original one), this implies that more than one pixel
    of the new grid will receive its value from the same original pixel. For example,
    resizing the reduced image of the previous section by four using nearest neighbor
    interpolation has been done as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 执行插值的最基本方法是用最近邻策略。必须生成的新的像素网格放置在现有图像的上方，并且每个新像素被分配其原始图像中最接近像素的值。在图像上采样（即，使用比原始网格更密集的新网格）的情况下，这意味着新网格的多个像素将从一个相同的原始像素接收其值。例如，通过最近邻插值将上一节中减小后的图像按四倍大小调整，操作如下：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, the interpolation corresponds to simply increasing the size of
    each pixel by four. A better approach consists of interpolating a new pixel value
    by combining the values of several neighboring pixels. Hence, we can linearly
    interpolate a pixel value by considering the four pixels around it, as illustrated
    by the following figure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，插值相当于简单地增加每个像素的大小四倍。一个更好的方法是通过组合几个相邻像素的值来插值新的像素值。因此，我们可以通过考虑其周围的四个像素来线性插值像素值，如下面的图所示：
- en: '![Interpolating pixel values](img/image_06_010.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![插值像素值](img/image_06_010.jpg)'
- en: 'This is done by first vertically interpolating two pixel values to the left-
    and right-hand side of the added pixel. Then, these two interpolated pixels (drawn
    in gray in the preceding figure) are used to horizontally interpolate the pixel
    value at the desired location. This bilinear interpolation scheme is the default
    approach used by `cv::resize` (that can also be explicitly specified by the `cv::INTER_LINEAR` flag):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过首先垂直插值两个像素值到添加的像素的左侧和右侧来完成的。然后，使用这两个插值像素（在前面的图中以灰色绘制）来水平插值所需位置的像素值。这种双线性插值方案是
    `cv::resize`（也可以通过 `cv::INTER_LINEAR` 标志显式指定）使用的默认方法：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the result:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为结果：
- en: '![Interpolating pixel values](img/image_06_011.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![插值像素值](img/image_06_011.jpg)'
- en: There are also other approaches that can produce superior results. With **bicubic
    interpolation**, a neighborhood of `4x4` pixels is considered to perform the interpolation.
    However, since the approach uses more pixels (`16`) and implies the computation
    of cubic terms, it is slower to compute than bilinear interpolation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以产生更优的结果。使用**双三次插值**时，考虑一个`4x4`像素的邻域来进行插值。然而，由于这种方法使用了更多的像素（`16`）并且涉及到立方项的计算，它比双线性插值计算速度慢。
- en: See also
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *There's more...* section of the *Scanning an image with neighbor access*
    recipe in [Chapter 2](ch02.html "Chapter 2. Manipulating Pixels"), *Manipulating
    Pixels*, introduces the `cv::filter2D` function. This function lets you apply
    a linear filter to an image by inputting the kernel of your choice.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章. 操作像素")中关于*使用邻域访问扫描图像*的*更多内容...*部分介绍了`cv::filter2D`函数。此函数允许您通过输入选择的核将线性滤波器应用于图像。'
- en: The *Detecting scale-invariant features* recipe in [Chapter 8](ch08.html "Chapter 8. Detecting
    Interest Points") , *Detecting Interest Points*, uses image pyramids to detect
    interest points in an image.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章. 检测兴趣点")中关于*检测尺度不变特征*的配方使用图像金字塔在图像中检测兴趣点。'
- en: Filtering images using a median filter
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中值滤波器过滤图像
- en: The first recipe of this chapter introduced the concept of linear filters. Non-linear
    filters also exist and can be advantageously used in image processing. One such
    filter is the median filter that we present in this recipe.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一个配方介绍了线性滤波器的概念。非线性滤波器也存在，并且可以在图像处理中有效地使用。这种滤波器之一就是我们在本配方中介绍的中值滤波器。
- en: 'Since median filters are particularly useful in order to combat salt-and-pepper
    noise (or salt-only, in our case), we will use the image we created in the first
    recipe of [Chapter 2](ch02.html "Chapter 2. Manipulating Pixels") , *Manipulating
    Pixels*, which is reproduced here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于中值滤波器特别适用于对抗椒盐噪声（或在我们的情况下，仅椒盐），我们将使用我们在[第2章](ch02.html "第2章. 操作像素")中第一个配方中创建的图像，*操作像素*，此处重新呈现：
- en: '![Filtering images using a median filter](img/image_06_012.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使用中值滤波器过滤图像](img/image_06_012.jpg)'
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The call to the median filtering function is done in a way that is similar
    to the other filters:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 调用中值滤波函数的方式与其他滤波器类似：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The resulting image is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图像如下：
- en: '![How to do it...](img/image_06_013.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_06_013.jpg)'
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: Since the median filter is not a linear filter, it cannot be represented by
    a kernel matrix, it cannot be applied through a convolution operation (that is,
    using the double-summation equation introduced in the first recipe of this chapter).
    However, it also operates on a pixel's neighborhood in order to determine the
    output pixel value. The pixel and its neighborhood form a set of values and, as
    the name suggests, the median filter will simply compute the median value of this
    set (the median of a set is the value at the middle position when the set is sorted).
    The current pixel is then replaced with this median value.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于中值滤波器不是线性滤波器，它不能通过核矩阵表示，不能通过卷积操作应用（即使用本章第一个配方中引入的双重求和方程）。然而，它也作用于像素的邻域以确定输出像素值。像素及其邻域形成一组值，正如其名称所暗示的，中值滤波器将简单地计算这组值的中值（一组的中值是当组排序时中间位置的值）。然后，当前像素被替换为中值值。
- en: This explains why the filter is so efficient in eliminating the salt-and-pepper
    noise. Indeed, when an outlier black or white pixel is present in a given pixel
    neighborhood, it is never selected as the median value (it is rather the maximal
    or minimal value), so it is always replaced by a neighboring value.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了为什么该滤波器在消除椒盐噪声方面如此高效。确实，当给定像素邻域中存在异常的黑色或白色像素时，它永远不会被选为中值值（而是最大或最小值），因此它总是被相邻的值所替代。
- en: 'In contrast, a simple mean filter would be greatly affected by such noise,
    as can be observed in the following image, which represents the mean filtered
    version of our salt-and-pepper corrupted image:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，一个简单的均值滤波器会受到这种噪声的严重影响，如下面的图像所示，它表示了我们的椒盐噪声损坏图像的均值滤波版本：
- en: '![How it works...](img/image_06_014.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image_06_014.jpg)'
- en: Clearly, the noisy pixels shifted the mean value of neighboring pixels. As a
    result, the noise is still visible even if it has been blurred by the mean filter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，噪声像素改变了相邻像素的均值。因此，即使噪声已被均值滤波器模糊，噪声仍然可见。
- en: The median filter also has the advantage of preserving the sharpness of the
    edges. However, it washes out the textures in uniform regions (for example, the
    trees in the background). Because of the visual impact it has on images, the median
    filter is often used to create special effects in photo-editing software tools.
    You should test it on a color image to see how it can produce cartoon-like images.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 中值滤波器也有保留边缘锐度的优势。然而，它会在均匀区域（例如，背景中的树木）洗掉纹理。由于它在图像上产生的视觉影响，中值滤波器通常用于在照片编辑软件工具中创建特殊效果。你应该在彩色图像上测试它，看看它如何产生卡通般的图像。
- en: Applying directional filters to detect edges
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用方向滤波器以检测边缘
- en: The first recipe of this chapter introduced the idea of linear filtering using
    kernel matrices. The filters that were used had the effect of blurring an image
    by removing or attenuating its high-frequency components. In this recipe, we will
    perform the opposite transformation, that is, amplifying the high-frequency content
    of an image. As a result, the high-pass filters introduced in this recipe will
    perform **edge detection**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一种配方介绍了使用核矩阵进行线性滤波的想法。所使用的滤波器具有通过移除或衰减其高频成分来模糊图像的效果。在本配方中，我们将执行相反的转换，即放大图像的高频内容。因此，本配方中引入的高通滤波器将执行**边缘检测**。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The filter that we will use here is called the **Sobel** filter. It is said
    to be a directional filter, because it only affects the vertical or the horizontal
    image frequencies depending on which kernel of the filter is used. OpenCV has
    a function that applies the Sobel operator on an image. The horizontal filter
    is called as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的滤波器被称为**Sobel**滤波器。据说它是一个方向滤波器，因为它只影响垂直或水平图像频率，这取决于使用的滤波器核。OpenCV有一个函数可以对图像应用Sobel算子。水平滤波器的调用方式如下：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Vertical filtering is achieved by the following (and very similar to the horizontal
    filter) call:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直滤波是通过以下（与水平滤波非常相似）的调用实现的：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Several integer parameters are provided to the function, and these will be explained
    in the next section. Note that these have been chosen to produce an 8-bit image
    (`CV_8U`) representation of the output.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 函数提供了几个整数参数，这些将在下一节中解释。请注意，这些参数已被选择以生成输出结果的8位图像（`CV_8U`）表示。
- en: 'The result of the horizontal `Sobel` operator is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 水平`Sobel`算子的结果如下：
- en: '![How to do it...](img/image_06_015.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_06_015.jpg)'
- en: 'Since, as will be seen in the next section, the kernels of the `Sobel` operator
    contain both positive and negative values, the result of the `Sobel` filter is
    generally computed in a 16-bit signed integer image (`CV_16S`). To make the results
    displayable as an 8-bit image, as shown in the preceding figure, we used a representation
    in which a zero value corresponds to gray-level `128`. Negative values are represented
    by darker pixels, while positive values are represented by brighter pixels. The
    vertical Sobel image is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于，如将在下一节中看到的，`Sobel`算子的核包含正负值，因此`Sobel`滤波器的结果通常在16位有符号整数图像（`CV_16S`）中计算。为了将结果显示为8位图像，如图中所示，我们使用了零值对应灰度级别`128`的表示。负值由较暗的像素表示，而正值由较亮的像素表示。垂直Sobel图像如下：
- en: '![How to do it...](img/image_06_016.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_06_016.jpg)'
- en: If you are familiar with photo-editing software, the preceding images might
    remind you of the image emboss effect, and indeed, this image transformation is
    generally based on the use of directional filters.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉照片编辑软件，前面的图像可能会让你想起图像浮雕效果，确实，这种图像变换通常基于方向滤波器的使用。
- en: 'The two results (vertical and horizontal) can then be combined to obtain the
    norm of the `Sobel` filter:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个结果（垂直和水平）可以组合起来以获得`Sobel`滤波器的范数：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The Sobel norm can be conveniently displayed in an image using the optional
    rescaling parameter of the `convertTo` method in order to obtain an image in which
    zero values correspond to white, and higher values are assigned darker gray shades:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`convertTo`方法的可选缩放参数方便地显示Sobel范数，以获得一个图像，其中零值对应白色，而更高的值则分配更暗的灰色阴影：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following image is then produced:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后生成以下图像：
- en: '![How to do it...](img/image_06_017.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_06_017.jpg)'
- en: 'Looking at this image, it is now clear why this kind of operator is called
    an edge detector. It is then possible to threshold the image in order to obtain
    a binary map showing the image contours. The following snippet creates the image
    that follows it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 看着这张图，现在很清楚为什么这种算子被称为边缘检测器。然后可以阈值化图像，以获得显示图像轮廓的二值图。以下代码片段创建了随后的图像：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![How to do it...](img/image_06_018.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_06_018.jpg)'
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The Sobel operator is a classic edge-detection linear filter that is based
    on two simple `3x3` kernels that have the following structure:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Sobel算子是一种经典的边缘检测线性滤波器，它基于两个简单的`3x3`核，具有以下结构：
- en: '![How it works...](img/B05388_06_30.jpg)![How it works...](img/B05388_06_31.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B05388_06_30.jpg)![如何工作...](img/B05388_06_31.jpg)'
- en: 'If we view the image as a two-dimensional function, the Sobel operator can
    then be seen as a measure of the variation of the image in the vertical and horizontal
    directions. In mathematical terms, this measure is called a **gradient**, and
    it is defined as a 2D vector that is made from the function''s first derivatives
    in two orthogonal directions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将图像视为一个二维函数，那么Sobel算子可以被视为图像在垂直和水平方向上的变化度量。在数学上，这个度量被称为**梯度**，它定义为从函数的两个正交方向的第一导数构成的二维向量：
- en: '![How it works...](img/image_06_019-300x112.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image_06_019-300x112.jpg)'
- en: 'The Sobel operator gives you an approximation of the image gradient by differencing
    pixels in the horizontal and vertical directions. It operates on a window around
    the pixel of interest in order to reduce the influence of noise. The `cv::Sobel`
    function computes the result of the convolution of the image with a Sobel kernel.
    Its complete specification is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Sobel算子通过在水平和垂直方向上对像素进行差分，为你提供了一个图像梯度的近似。它在一个围绕感兴趣像素的窗口上操作，以减少噪声的影响。`cv::Sobel`函数计算图像与Sobel核卷积的结果。其完整规范如下：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By using the appropriate arguments, you decide whether you wish to have the
    result written in an unsigned character, a signed integer, or a floating point
    image. Of course, if the result falls outside of the domain of the image pixel,
    saturation will be applied. This is where the last two parameters can be useful.
    Before storing the result in the image, the result can be scaled (multiplied)
    by `alpha` and an offset, `beta`, can be added.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用适当的参数，你可以决定是否希望将结果写入无符号字符、有符号整数或浮点图像。当然，如果结果超出了图像像素的域，将会应用饱和度。这就是最后两个参数可能很有用的地方。在将结果存储到图像之前，结果可以被缩放（乘以）`alpha`，并且可以添加一个偏移量`beta`。
- en: This is how, in the previous section, we generated an image for which the Sobel
    value `0` was represented by the mid-gray level `128`. Each Sobel mask corresponds
    to a derivative in one direction. Therefore, two parameters are used to specify
    the kernel that will be applied, the order of the derivative in the `x`, and the
    `y` directions. For instance, the horizontal Sobel kernel is obtained by specifying
    `1` and `0` for the `xorder` and `yorder` parameters, and the vertical kernel
    will be generated with `0` and `1`. Other combinations are also possible, but
    these two are the ones that will be used most often (the case of second-order
    derivatives is discussed in the next recipe). Finally, it is also possible to
    use kernels of a size larger than `3x3`. Values `1`, `3`, `5`, and `7` are possible
    choices for the kernel size. A kernel of size `1` corresponds to a 1D Sobel filter
    (`1x3` or `3x1`). See the following *There's more...* section to learn why using
    a larger kernel might be useful.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在上一节中我们生成一个图像的过程，其中Sobel值`0`被表示为中灰度级别`128`。每个Sobel掩码对应一个方向上的导数。因此，使用两个参数来指定将要应用的核，即`x`和`y`方向上的导数阶数。例如，水平Sobel核是通过为`xorder`和`yorder`参数指定`1`和`0`来获得的，而垂直核将通过指定`0`和`1`来生成。其他组合也是可能的，但这两个是最常用的（二阶导数的情况将在下一个菜谱中讨论）。最后，也可以使用大于`3x3`大小的核。可能的核大小值为`1`、`3`、`5`和`7`。大小为`1`的核对应于1D
    Sobel滤波器（`1x3`或`3x1`）。请参阅以下*更多内容...*部分，了解为什么使用更大的核可能是有用的。
- en: 'Since the gradient is a 2D vector, it has a norm and a direction. The norm
    of the gradient vector tells you what the amplitude of the variation is, and it
    is normally computed as a Euclidean norm (also called **L2 norm**):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于梯度是一个二维向量，它有一个范数和一个方向。梯度向量的范数告诉你变化的幅度是多少，它通常被计算为欧几里得范数（也称为**L2范数**）：
- en: '![How it works...](img/B05388_06_27-300x89.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B05388_06_27-300x89.jpg)'
- en: 'However, in image processing, this norm is often computed as the sum of the
    absolute values. This is called the **L1 norm**, and it gives values that are
    close to the L2 norm but at a lower computational cost. This is what we did in
    this recipe:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在图像处理中，这个范数通常被计算为绝对值的总和。这被称为**L1范数**，它给出的值接近L2范数，但计算成本更低。这就是我们在本食谱中所做的：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The gradient vector always points in the direction of the steepest variation.
    For an image, this means that the gradient direction will be orthogonal to the
    edge, pointing in the darker to brighter direction. Gradient angular direction
    is given by the following formula:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度向量始终指向最陡变化的方向。对于图像，这意味着梯度方向将与边缘正交，指向暗到亮的方向。梯度角度方向由以下公式给出：
- en: 'Most often, for edge detection, only the norm is computed. However, if you
    require both the norm and the orientation, then the following OpenCV function
    can be used:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于边缘检测，只计算范数。但是，如果您需要范数和方向，则可以使用以下OpenCV函数：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By default, the orientation is computed in radians. Just add `true` as an additional
    argument in order to have them computed in degrees.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，方向是以弧度计算的。只需将`true`作为附加参数添加，就可以以度为单位进行计算。
- en: 'A binary edge map has been obtained by applying a threshold on the gradient
    magnitude. Choosing the right threshold is not an obvious task. If the threshold
    value is too low, too many (thick) edges will be retained, while if we select
    a more severe (higher) threshold, then broken edges will be obtained. As an illustration
    of this trade-off situation, compare the preceding binary edge map with the following,
    which is obtained using a higher threshold value:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对梯度幅度应用阈值，已获得二值边缘图。选择正确的阈值不是一个显而易见的工作。如果阈值值太低，将保留太多（粗）边缘，而如果我们选择更严格的（更高的）阈值，则将获得断裂边缘。为了说明这种权衡情况，可以将前面的二值边缘图与以下使用更高阈值值获得的图进行比较：
- en: '![How it works...](img/image_06_021.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image_06_021.jpg)'
- en: One way to get the best of both lower and higher thresholds is to use the concept
    of hysteresis thresholding. This will be explained in the next chapter, where
    we introduce the Canny operator.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要同时获得低阈值和高阈值的最佳效果，可以使用滞后阈值的概念。这将在下一章中解释，其中我们将介绍Canny算子。
- en: There's more...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Other gradient operators also exist. We present some of them in this section.
    It is also possible to apply a Gaussian smoothing filter before applying a derivative
    filter. This makes it less sensitive to noise, as explained in this section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 其他梯度算子也存在。我们将在本节中介绍其中的一些。在应用导数滤波器之前，也可以先应用高斯平滑滤波器。这使其对噪声的敏感性降低，如本节所述。
- en: Gradient operators
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 梯度算子
- en: 'To estimate the gradient at a pixel location, the **Prewitt ** **operator**
    defines the following kernels:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了估计像素位置的梯度，**Prewitt** **算子**定义了以下核：
- en: '![Gradient operators](img/B05388_06_32.jpg)![Gradient operators](img/B05388_06_33.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![梯度算子](img/B05388_06_32.jpg)![梯度算子](img/B05388_06_33.jpg)'
- en: 'The **Roberts operator** is based on these simple `2x2` kernels:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**Roberts算子**基于以下简单的`2x2`核：'
- en: '![Gradient operators](img/B05388_06_34.jpg)![Gradient operators](img/B05388_06_35.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![梯度算子](img/B05388_06_34.jpg)![梯度算子](img/B05388_06_35.jpg)'
- en: 'The **Scharr operator** is preferred when more accurate estimates of the gradient
    orientation are required:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要更精确的梯度方向估计时，**Scharr算子**更受欢迎：
- en: '![Gradient operators](img/B05388_06_36.jpg)![Gradient operators](img/B05388_06_37.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![梯度算子](img/B05388_06_36.jpg)![梯度算子](img/B05388_06_37.jpg)'
- en: 'Note that it is possible to use the Scharr kernels with the `cv::Sobel` function
    by calling it with the `CV_SCHARR` argument:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可以通过使用`cv::Sobel`函数并使用`CV_SCHARR`参数来调用它，使用Scharr核：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Or, equivalently, you can call the `cv::Scharr` function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，等价地，你可以调用`cv::Scharr`函数：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All of these directional filters try to estimate the first-order derivatives
    of the image function. Therefore, high values are obtained at areas where large
    intensity variations in the filter direction are present, while flat areas produce
    low values. This is why filters that compute image derivatives are high-pass filters.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方向滤波器都试图估计图像函数的一阶导数。因此，在滤波器方向上存在较大强度变化区域，会获得高值，而平坦区域产生低值。这就是为什么计算图像导数的滤波器是高通滤波器。
- en: Gaussian derivatives
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高斯导数
- en: Derivative filters are high-pass filters. As such, they tend to amplify noise
    and small highly-contrasted details in an image. In order to reduce the impact
    of these higher frequency elements, it is a good practice to first smooth the
    image before applying a derivative filter. You might think that this would be
    done in two steps, which are smoothing the image and then computing the derivative.
    However, a closer look at these operations reveals that it is possible to combine
    these two steps into one with a proper choice of the smoothing kernel. We learned
    previously that the convolution of an image with a filter can be expressed as
    a summation of terms. Interestingly, a well-known mathematical property is that
    the derivative of a summation of terms is equal to the summation of the terms'
    derivative.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 导数滤波器是高通滤波器。因此，它们倾向于放大图像中的噪声和小的、高度对比的细节。为了减少这些高频元素的影响，在应用导数滤波器之前先平滑图像是一个好习惯。你可能会认为这将是两个步骤，即先平滑图像然后计算导数。然而，仔细观察这些操作可以发现，可以通过适当选择平滑核将这两个步骤合并为一个。我们之前了解到，图像与滤波器的卷积可以表示为项的求和。有趣的是，一个著名的数学性质是，项的求和的导数等于项的导数的求和。
- en: 'Consequently, instead of applying the derivative on the result of the smoothing,
    it is possible to derive the kernel and then convolute it with the image; these
    two operations are then accomplished in a single pass over the pixels. Since the
    Gaussian kernel is continuously derivable, it represents a particularly appropriate
    choice. This is what is done when you call the `cv::sobel` function with different
    kernel sizes. The function will compute a Gaussian derivative kernel with different
    σ values. As an example, if we select the `7x7` Sobel filter (that is, `kernel_size=7`)
    in the `x` direction, the following result is obtained:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，而不是在平滑的结果上应用导数，可以推导出核，然后将其与图像进行卷积；这两个操作随后在单个像素遍历中完成。由于高斯核是连续可导的，它是一个特别合适的选择。当你用不同核大小调用`cv::sobel`函数时，就是这样做的。该函数将计算具有不同σ值的高斯导数核。例如，如果我们选择`7x7`索贝尔滤波器（即`kernel_size=7`）在`x`方向上，将得到以下结果：
- en: '![Gaussian derivatives](img/image_06_022.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![高斯导数](img/image_06_022.jpg)'
- en: If you compare this image with the one shown earlier, it can be seen that many
    fine details have been removed, giving them more emphasis on the more significant
    edges. Note that we now have a band-pass filter, some higher frequencies being
    removed by the Gaussian filter and the lower frequencies being removed by the
    `Sobel` filter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此图像与之前显示的图像进行比较，可以看出许多细微细节已被移除，从而使得对更重要的边缘更加突出。请注意，我们现在有一个带通滤波器，一些较高频率被高斯滤波器移除，而较低频率被`Sobel`滤波器移除。
- en: See also
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Detecting image contours with the Canny operator* recipe in [Chapter 7](ch07.html
    "Chapter 7. Extracting Lines, Contours, and Components") , *Extracting Lines,
    Contours, and Components*, shows you how to obtain a binary edge map using two
    different threshold values
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。提取线、轮廓和组件")的*使用Canny算子检测图像轮廓*配方中，*提取线、轮廓和组件*展示了如何使用两个不同的阈值值获得二值边缘图
- en: Computing the Laplacian of an image
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算图像的拉普拉斯算子
- en: The Laplacian is another high-pass linear filter that is based on the computation
    of the image derivatives. As it will be explained, it computes second-order derivatives
    to measure the curvature of the image function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 拉普拉斯算子是另一种基于图像导数计算的高通线性滤波器。正如将解释的那样，它计算二阶导数以测量图像函数的曲率。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The OpenCV function, `cv::Laplacian`, computes the Laplacian of an image. It
    is very similar to the `cv::Sobel` function. In fact, it uses the same basic function,
    `cv::getDerivKernels`, in order to obtain its kernel matrix. The only difference
    is that there are no derivative order parameters since these ones are, by definition,
    second order derivatives.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV函数`cv::Laplacian`计算图像的拉普拉斯算子。它与`cv::Sobel`函数非常相似。事实上，它使用相同的基函数`cv::getDerivKernels`来获取其核矩阵。唯一的区别是没有导数阶数参数，因为这些参数按定义是二阶导数。
- en: 'For this operator, we will create a simple class that will encapsulate some
    useful operations related to the Laplacian. The basic attributes and methods are
    as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此算子，我们将创建一个简单的类，它将封装一些与拉普拉斯相关的有用操作。基本属性和方法如下：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The computation of the Laplacian is done here on a floating point image. To
    get an image of the result, we perform a rescaling, as shown in the previous recipe.
    This rescaling is based on the Laplacian maximum absolute value, where value `0`
    is assigned gray-level `128`. A method of our class allows the following image
    representation to be obtained:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 拉普拉斯的计算在这里是在一个浮点图像上进行的。为了得到结果的图像，我们执行了一个缩放，如前一个菜谱中所示。这种缩放基于拉普拉斯的最大绝对值，其中值`0`被分配为灰度级`128`。我们类中的一个方法允许获得以下图像表示：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using this class, the Laplacian image computed from a `7x7` kernel is obtained
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个类，从`7x7`核计算得到的拉普拉斯图像如下所示：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The resulting image is shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最终生成的图像如下所示：
- en: '![How to do it...](img/image_06_023.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_06_023.jpg)'
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'Formally, the Laplacian of a 2D function is defined as the sum of its second
    derivatives:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 形式上，二维函数的拉普拉斯定义为其二阶导数的和：
- en: '![How it works...](img/B05388_06_28-1-300x80.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B05388_06_28-1-300x80.jpg)'
- en: 'In its simplest form, it can be approximated by the following `3x3` kernel:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单形式中，它可以近似为以下`3x3`核：
- en: '![How it works...](img/B05388_06_38.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B05388_06_38.jpg)'
- en: As for the Sobel operator, it is also possible to compute the Laplacian using
    larger kernels, and since this operator is even more sensitive to image noise,
    it is desirable to do so (unless computational efficiency is a concern). Since
    these larger kernels are computed using the second derivatives of the Gaussian
    function, the corresponding operator is often called **Laplacian of Gaussian**
    (**LoG**). Note that the kernel values of a Laplacian always sum up to `0`. This
    guarantees that the Laplacian will be zero in areas of constant intensities. Indeed,
    since the Laplacian measures the curvature of the image function, it should be
    equal to `0` on flat areas.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Sobel算子一样，也可以使用更大的核来计算拉普拉斯，并且由于这个算子对图像噪声更加敏感，因此这样做是可取的（除非计算效率是一个问题）。由于这些较大的核是使用高斯函数的二阶导数计算的，因此相应的算子通常被称为**高斯拉普拉斯**（**LoG**）。请注意，拉普拉斯的核值总是加起来等于`0`。这保证了拉普拉斯将在强度恒定的区域内为零。实际上，由于拉普拉斯测量图像函数的曲率，它应该在平坦区域内等于`0`。
- en: 'At first glance, the effect of the Laplacian might be difficult to interpret.
    From the definition of the kernel, it is clear that any isolated pixel value (that
    is, a value that''s very different from its neighbors) will be amplified by the
    operator. This is a consequence of the operator''s high sensitivity to noise.
    However, it is more interesting to look at the Laplacian values around an image
    edge. The presence of an edge in an image is the result of a rapid transition
    between areas of different gray-level intensities. Following the evolution of
    the image function along an edge (for example, caused by a transition from dark
    to bright), one can observe that the gray-level ascension necessarily implies
    a gradual transition from a positive curvature (when the intensity values start
    to rise) to a negative curvature (when the intensity is about to reach its high
    plateau). Consequently, a transition between a positive and a negative Laplacian
    value (or reciprocally) constitutes a good indicator of the presence of an edge.
    Another way to express this fact is to say that edges will be located at the zero-crossings
    of the Laplacian function. We will illustrate this idea by looking at the values
    of a Laplacian inside a small window of our test image. We select one that corresponds
    to an edge created by the bottom part of the roof of one of the castle''s tower.
    A white box has been drawn in the following image to show you the exact location
    of this region of interest:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，拉普拉斯的效果可能难以解释。从核的定义来看，很明显，任何孤立的像素值（即与邻居非常不同的值）都将被算子放大。这是算子对噪声高度敏感的结果。然而，更有趣的是观察图像边缘周围的拉普拉斯值。图像中边缘的存在是不同灰度级强度区域之间快速转换的结果。沿着边缘（例如，由暗到亮的转换引起的）跟踪图像函数的演变，可以观察到灰度级上升必然意味着从正曲率（当强度值开始上升时）到负曲率（当强度即将达到其高平台时）的逐渐过渡。因此，正负拉普拉斯值之间的转换（或反之）是边缘存在的好指标。另一种表达这个事实的方法是说，边缘将位于拉普拉斯函数的零交叉点。我们将通过查看测试图像中一个小窗口内的拉普拉斯值来阐述这个想法。我们选择一个对应于城堡塔楼底部部分创建的边缘的值。在以下图像中画了一个白色框，以显示这个感兴趣区域的精确位置：
- en: '![How it works...](img/image_06_025.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image_06_025.jpg)'
- en: 'The following figure shows the numerical values (divided by `100`) of the Laplacian
    image (`7x7` kernel) inside the selected window:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了所选窗口内拉普拉斯图像（`7x7`核）的数值（除以`100`）：
- en: '![How it works...](img/image_06_026.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image_06_026.jpg)'
- en: If, as illustrated, you carefully follow some of the zero-crossings of the Laplacian
    (located between pixels of different signs), you obtain a curve that corresponds
    some of the edges that is visible in the image window. In the preceding figure,
    we drew lines along the zero-crossings that correspond to the edge of the tower
    that is visible in the selected image window. This implies that, in principle,
    you can even detect the image edges at sub-pixel accuracy.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，如图所示，你仔细追踪拉普拉斯算子的某些零交叉点（位于不同符号像素之间），你将得到一条曲线，它对应于图像窗口中可见的一些边缘。在先前的图中，我们在所选图像窗口中可见的塔边缘对应的零交叉点上画了线。这意味着，原则上，你甚至可以以亚像素的精度检测图像边缘。
- en: 'Following the zero-crossing curves in a Laplacian image is a delicate task.
    However, a simplified algorithm can be used to detect the approximate zero-crossing
    locations. This one proceeds by first thresholding the Laplacian at `0` so that
    a partition separating the positive and negative values is obtained. The limits
    between these two partitions then correspond to our zero-crossings. Therefore,
    we use a morphological operation to extract these contours, that is, we subtract
    the dilated image from the Laplacian image (this is the Beucher gradient presented
    in the *Applying morphological operators on gray-level images* recipe in [Chapter
    5](ch05.html "Chapter 5. Transforming Images with Morphological Operations") ,
    *Transforming Images with Morphological Operations*). This algorithm is implemented
    by the following method, which generates a binary image of zero-crossings:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随拉普拉斯图像中的零交叉曲线是一项精细的任务。然而，可以使用一个简化的算法来检测近似零交叉位置。这个算法首先在`0`处对拉普拉斯算子进行阈值处理，以便获得一个分隔正负值的分区。这两个分区之间的界限对应于我们的零交叉点。因此，我们使用形态学操作来提取这些轮廓，即我们从拉普拉斯图像中减去膨胀图像（这是在[第5章](ch05.html
    "第5章. 使用形态学操作变换图像")中介绍的Beucher梯度，*在灰度图像上应用形态学算子*食谱）。此算法通过以下方法实现，该方法生成零交叉的二值图像：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result is the following binary map:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是以下二值图：
- en: '![How it works...](img/image_06_027.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image_06_027.jpg)'
- en: As you can see, the zero-crossings of the Laplacian detect all edges. No distinction
    is made between strong edges and weaker edges. We also mentioned that the Laplacian
    is very sensitive to noise. Also, it is interesting to note that some of the visible
    edges are due to compression artifacts. All these factors explain why so many
    edges are detected by the operator. In practice, the Laplacian is only used in
    conjunction with other operators to detect edges (for example, edges can be declared
    at zero-crossing locations of strong gradient magnitude). We will also learn in
    [Chapter 8](ch08.html "Chapter 8. Detecting Interest Points") , *Detecting Interest
    Points*, that the Laplacian and other second-order operators are very useful in
    order to detect interest points at multiple scales.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，拉普拉斯算子的零交叉点检测到了所有的边缘。没有在强边缘和弱边缘之间做出区分。我们还提到，拉普拉斯算子对噪声非常敏感。值得注意的是，一些可见的边缘是由于压缩伪影造成的。所有这些因素解释了为什么操作者检测到这么多边缘。实际上，拉普拉斯算子通常与其他算子结合使用来检测边缘（例如，可以在强梯度幅度的零交叉位置声明边缘）。我们还将了解到[第8章](ch08.html
    "第8章. 检测兴趣点")，*检测兴趣点*，拉普拉斯算子和其他二阶算子在检测多尺度兴趣点方面非常有用。
- en: There's more...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Laplacian is a high-pass filter but, interestingly, it is possible to approximate
    it by using a combination of low-pass filters. But before exploring this aspect,
    let's have a word about image enhancement, which is a topic we have already discussed,
    in [Chapter 2](ch02.html "Chapter 2. Manipulating Pixels") , *Manipulating Pixels*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 拉普拉斯算子是一个高通滤波器，但有趣的是，可以通过使用低通滤波器的组合来近似它。但在探讨这个方面之前，让我们谈谈图像增强，这是一个我们已经在[第2章](ch02.html
    "第2章. 操作像素")中讨论过的主题，*操作像素*。
- en: Enhancing the contrast of an image using the Laplacian
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用拉普拉斯算子增强图像
- en: 'The contrast of an image can be enhanced by subtracting its Laplacian from
    it. This is what we did in the *Scanning an image with neighbor access* recipe
    of [Chapter 2](ch02.html "Chapter 2. Manipulating Pixels") , *Manipulating Pixels*,
    where we introduced the kernel:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从图像中减去其拉普拉斯变换，可以增强图像的对比度。这就是我们在[第2章](ch02.html "第2章. 操作像素")的*使用邻域访问扫描图像*菜谱中做的事情，*操作像素*，在那里我们引入了核：
- en: '![Enhancing the contrast of an image using the Laplacian](img/B05388_06_39.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![使用拉普拉斯增强图像对比度](img/B05388_06_39.jpg)'
- en: This is equal to 1 minus the Laplacian kernel (that is, the original image minus
    its Laplacian).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这等于1减去拉普拉斯核（即原始图像减去其拉普拉斯变换）。
- en: Difference of Gaussians
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高斯函数差异
- en: 'The Gaussian filter presented in the first recipe of this chapter extracts
    the low frequencies of an image. We learned that the range of frequencies that
    are filtered by a Gaussian filter depend on the parameter σ, which controls the
    width of the filter. Now, if we subtract the two images that result from the filtering
    of an image by two Gaussian filters of different bandwidths, then the resulting
    image will be composed of those higher frequencies that one filter has preserved,
    and not the other. This operation is called **Difference of Gaussians** (**DoG**)
    and is computed as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本章第一道菜谱中介绍的高斯滤波器提取图像的低频部分。我们了解到，高斯滤波器过滤的频率范围取决于参数σ，它控制滤波器的宽度。现在，如果我们从两个不同带宽的高斯滤波器对图像进行滤波的结果中减去这两个图像，那么得到的图像将只包含一个滤波器保留而另一个没有保留的高频部分。这种操作称为**高斯函数差异**（**DoG**），其计算方法如下：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The last line of code computes the zero-crossings of the `DoG` operator. It
    results in the following image:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一行计算`DoG`算子的零交叉。它得到以下图像：
- en: '![Difference of Gaussians](img/image_06_028.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![高斯函数差异](img/image_06_028.jpg)'
- en: In fact, it can be demonstrated that with the proper choice of σ values, `DoG`
    operators can constitute a good approximation of LoG filters. Also, if you compute
    a series of difference of Gaussians from consecutive pair values in an increasing
    sequence of σ values, you obtain a scale-space representation of the image. This
    multiscale representation is useful, for example, for scale-invariant image feature
    detection, as will be explained in [Chapter 8](ch08.html "Chapter 8. Detecting
    Interest Points") , *Detecting Interest Points*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可以证明，通过适当选择σ值，`DoG`算子可以构成LoG滤波器的一个良好近似。此外，如果你从σ值递增的连续对值中计算一系列高斯函数差异，你将获得图像的尺度空间表示。这种多尺度表示很有用，例如，对于尺度不变图像特征检测，将在[第8章](ch08.html
    "第8章. 检测兴趣点")的*检测兴趣点*中解释。
- en: See also
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Detecting scale-invariant features* recipe in [Chapter 8](ch08.html "Chapter 8. Detecting
    Interest Points") , *Detecting Interest Points*, uses the Laplacian and DoG for
    the detection of scale-invariant features
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章. 检测兴趣点")中的*检测尺度不变特征*菜谱，*检测兴趣点*，使用拉普拉斯和DoG进行尺度不变特征的检测'
