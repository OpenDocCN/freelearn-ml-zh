<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Letting Applications Understand Commands"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Letting Applications Understand Commands</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>"LUIS saved us tremendous time while going from a prototype to production."</em></span>
</p><p>                                                   - Eyal Yavor, Cofounder and CTO of Meekan</p></blockquote></div><p>Throughout the previous chapters, we have focused on vision APIs. Starting with this chapter, we will move on to language APIs, where we will start with the <span class="strong"><strong>Language Understanding Intelligent Service</strong></span> (<span class="strong"><strong>LUIS</strong></span>). Throughout this chapter, you will learn how to create <a class="indexterm" id="id233"/>and maintain language-understanding models.</p><p>By the end of this chapter, we will have covered the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating language-understanding models</li><li class="listitem" style="list-style-type: disc">Handling common requests using prebuilt models from Bing and Cortana</li></ul></div><div class="section" title="Creating language-understanding models"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Creating language-understanding models</h1></div></div></div><p>Sometimes, we might wish that our computer could understand what we want. As we go on with our <a class="indexterm" id="id234"/>day-to-day business, we want to be able to talk to our computer, or mobile phone, using regular sentences. This is hard to do without any extra help.</p><p>Utilizing the power of LUIS, we can now solve this problem. By creating language-understanding models, we can allow applications to understand what users want. We can also recognize key data, which is, typically, data that you want to be part of a query or command. If you are asking for the latest news on a certain issue, then the key data would be the topic of the news that you are asking for.</p><div class="section" title="Creating an application"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Creating an application</h2></div></div></div><p>To get started<a class="indexterm" id="id235"/> with LUIS, you should head over to <a class="ulink" href="https://www.luis.ai">https://www.luis.ai</a>. This is where we will set up our application. Click on the <span class="strong"><strong>Sign in or create an account</strong></span> button to get started.</p><p>Let's create <a class="indexterm" id="id236"/>our first application. Click on <span class="strong"><strong>My Apps</strong></span> from the top menu. This should take you back to the application list, which should be empty. Click on <span class="strong"><strong>New App</strong></span>.</p><p>In the form that is shown, we fill in the given information about our application. We are required to give the application a name. We also need to indicate an atypical usage scenario, which will be set by default to <span class="strong"><strong>Other (please specify)</strong></span>. Instead, set this to <span class="strong"><strong>SmartHouseApplication</strong></span>. This application falls under the <span class="strong"><strong>Tools</strong></span> domain. We will choose an English <span class="strong"><strong>Application Culture</strong></span>.</p><p>The other languages that are available are Brazilian, Portuguese, Chinese, French, German, Italian, Japanese, and Spanish.</p><p>The following screenshot shows how we can define the application:</p><div class="mediaobject"><img alt="Creating an application" src="graphics/B12373_04_01.jpg"/></div><p>When you<a class="indexterm" id="id237"/> click on the <span class="strong"><strong>Create</strong></span> button, the application will be created. This process will take about a minute or so to complete, so just be patient.</p><p>When the application has been created, you will be taken to the application's home base, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Creating an application" src="graphics/B12373_04_02.jpg"/></div><p>As you can see, we<a class="indexterm" id="id238"/> have a variety of features to use, and we will cover the important ones here.</p><p>The application we will build will be aimed at our smart house application. We will configure the application to recognize commands to set the temperature in different rooms. In addition, we would like it to tell us what the temperatures in the different rooms are.</p></div><div class="section" title="Recognizing key data using entities"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Recognizing key data using entities</h2></div></div></div><p>One of the key features of LUIS is the ability to recognize key data in sentences. The instances <a class="indexterm" id="id239"/>of this key data are known as entities. In a news application, an example of an entity would be the topic. If<a class="indexterm" id="id240"/> we ask to get the latest news, we could specify a topic for the service to recognize.</p><p>For our application, we want to add an entity for our rooms. We do this by selecting <span class="strong"><strong>Entities</strong></span> in the left-hand pane. Then we click on <span class="strong"><strong>Add custom entity</strong></span>.</p><p>We will be presented with the following screen:</p><div class="mediaobject"><img alt="Recognizing key data using entities" src="graphics/B12373_04_03.jpg"/></div><p>Enter the name of the entity and click on the <span class="strong"><strong>Save</strong></span> button. That's it—you have now created the first entity. We will see how to use this in a bit.</p><p>As you<a class="indexterm" id="id241"/> may have noticed, there is a drop-down list called <span class="strong"><strong>Entity type</strong></span> in the entity creation form. Entity types<a class="indexterm" id="id242"/> are a way to create hierarchical entities, which is basically about defining relationships between entities.</p><p>As an example, you can imagine searching for news inside a given time frame. The generic top-level entity is <code class="literal">Date</code>. Going from there, you can define two children, <code class="literal">StartDate</code> and <code class="literal">EndDate</code>. These will be recognized by the service, where models will be built for the entity and its children.</p><p>To add a hierarchical child entity, check the checkbox and select <span class="strong"><strong>Hierarchical</strong></span> from the selection. Click on the + button next to <span class="strong"><strong>Entity Children</strong></span> for each child you want to add, as shown in the following screenshot. Enter the name of the child:</p><div class="mediaobject"><img alt="Recognizing key data using entities" src="graphics/B12373_04_04.jpg"/></div><p>The <a class="indexterm" id="id243"/>other types of entities you can add are called <span class="strong"><strong>composite entities</strong></span>. This is a type of entity that is formed by a set of<a class="indexterm" id="id244"/> existing entities. This is what we would call a <span class="emphasis"><em>has-a</em></span> relationship, so the components are children, but not in a parent-child relationship.</p><p>Composite <a class="indexterm" id="id245"/>entities do not share common traits as hierarchical entities do. When deleting the top-level entity, you do not delete components. Using composite entities, LUIS can identify groups of entities, which are then treated as a single entity.</p><p>Using composite entities is like ordering a pizza. You can order a pizza by stating <span class="emphasis"><em>I want a large pizza with mushrooms and pepperoni</em></span>. In this example, we can see the size as an entity, and we can also see the two toppings as entities. Combining these could make a composite entity, which is called an order.</p><p>The last type of entity you can <a class="indexterm" id="id246"/>add is called a <span class="strong"><strong>list entity</strong></span>. This is a customized list of entity values to be used as keywords or identifiers within utterances.</p><p>When<a class="indexterm" id="id247"/> using entities, there may be times where an entity consists of several words. In our case, with the <code class="literal">Rooms</code> entity, we may ask for the living room. To be able to identify such phrasings, we can <a class="indexterm" id="id248"/>define a feature list. This is a comma-separated list that can contain some or all of the expected phrases.</p><p>Let's add one for our application. On the left-hand side, at the bottom of the pane, you will see <span class="strong"><strong>Features</strong></span>. Select this and click on <span class="strong"><strong>Add phrase list</strong></span> to create a new list. Call it <code class="literal">Rooms</code> and add the different rooms that you would expect to find in a house, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Recognizing key data using entities" src="graphics/B12373_04_05.jpg"/></div><p>By clicking on <span class="strong"><strong>Recommend</strong></span> on the right-hand side, LUIS will recommend more values related to the ones you have already entered.</p><p>We will see how this is utilized later.</p><p>In<a class="indexterm" id="id249"/> addition to creating phrase lists, we can create <span class="strong"><strong>pattern features</strong></span>. The typical use case of using pattern<a class="indexterm" id="id250"/> features is when you have data that matches patterns but it is not feasible to enter them as a phrase list. Pattern features are typically used with<a class="indexterm" id="id251"/> product numbers.</p></div><div class="section" title="Understanding what the user wants using intents"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Understanding what the user wants using intents</h2></div></div></div><p>Now that we have<a class="indexterm" id="id252"/> defined an entity, it is time to see how it fits in with intents. An <span class="strong"><strong>intent</strong></span> is basically the purpose of a sentence.</p><p>We can <a class="indexterm" id="id253"/>add intents to our application by <a class="indexterm" id="id254"/>selecting the <span class="strong"><strong>Intents</strong></span> option in the left-hand pane. Click on <span class="strong"><strong>Add intent</strong></span>. When we add an intent, we give it a name. The name should be descriptive of what the intent is. We want to add an intent named <code class="literal">GetRoomTemperature</code>, where the goal is to get the temperature of a given room, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Understanding what the user wants using intents" src="graphics/B12373_04_06.jpg"/></div><p>When you click on the <span class="strong"><strong>Save</strong></span> button, you will be taken to the utterance page. Here, we can add sentences that we can use for the intent, so let's add one. Enter <code class="literal">what is the temperature in the kitchen?</code> and press <span class="emphasis"><em>Enter</em></span>. The sentence (or utterance, as it is called) will be ready for labeling. Labeling an utterance means that we define what intent it belongs to. We should also make sure that we mark entities with the correct type.</p><p>The following screenshot shows the labeling process for our first utterance:</p><div class="mediaobject"><img alt="Understanding what the user wants using intents" src="graphics/B12373_04_07.jpg"/></div><p>As you<a class="indexterm" id="id255"/> can see, the entity is marked. You<a class="indexterm" id="id256"/> can tell LUIS that a word is a given entity by clicking on the word. This will pop up a menu containing all the available entities, and you can then select the correct one. Also, note how the <span class="strong"><strong>GetRoomTemperature</strong></span> intent is selected in the drop-down list. Click <span class="strong"><strong>Train</strong></span> once you are done labeling your utterances.</p><p>All applications are created with a default intent called <span class="strong"><strong>None</strong></span>. This intent will encompass sentences that do not belong to our application at all. If we were to say <span class="emphasis"><em>Order a large pizza with mushrooms and pepperoni</em></span>, this would end up with <span class="strong"><strong>None</strong></span> as the intent.</p><p>When you are creating intents, you should define at least three to five utterances. This will give LUIS something to work with, and, as such, it can create better models. We will see how we can improve performance later in this chapter.</p></div><div class="section" title="Simplifying development using prebuilt models"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Simplifying development using prebuilt models</h2></div></div></div><p>Building<a class="indexterm" id="id257"/> entities and intents can be easy or it can be intricate. Fortunately, LUIS provides a set of prebuilt entities that stem from Bing. These entities will be included in the applications, as well as on the web, while going through the labeling process.</p><p>The following table describes all the available prebuilt entities:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Entity</p>
</th><th style="text-align: left" valign="bottom">
<p>Example</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">builtin.number</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Five, 23.21</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">builtin.ordinal</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Second, 3rd</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">builtin.temperature</code>
</p>
</td><td style="text-align: left" valign="top">
<p>2 degrees Celsius, 104 F</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">builtin.dimension</code>
</p>
</td><td style="text-align: left" valign="top">
<p>231 square kilometers</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">builtin.age</code>
</p>
</td><td style="text-align: left" valign="top">
<p>27 years old</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">builtin.geography</code>
</p>
</td><td style="text-align: left" valign="top">
<p>City, country, point of interest</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">builtin.encyclopedia</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Person, organization, event, TV episode, product, film, and so on</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">builtin.datetime</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Date, time, duration, set</p>
</td></tr></tbody></table></div><p>The last three have several subentities, as described in the <span class="strong"><strong>Example</strong></span> column of the table.</p><p>We are going to add one of these prebuilt entities, so select <span class="strong"><strong>Entities</strong></span> in the menu. Click on <span class="strong"><strong>Add prebuilt entity</strong></span>, select <span class="strong"><strong>temperature</strong></span> from the list, and click on <span class="strong"><strong>Save</strong></span>.</p><p>With the newly created entity, we want to add a new intent called <span class="strong"><strong>SetTemperature</strong></span>. If the example utterance is <span class="emphasis"><em>Set the temperature in the kitchen to 22 degrees Celsius,</em></span> we can label the utterance as shown in the following screenshot:</p><div class="mediaobject"><img alt="Simplifying development using prebuilt models" src="graphics/B12373_04_08.jpg"/></div><p>As you can see, we have a <code class="literal">room</code> entity. We also have the prebuilt <code class="literal">temperature</code> entity clearly labeled. As the correct intent should be selected in the drop-down menu, we can click on the <span class="strong"><strong>Train</strong></span> button to save the utterance.</p></div><div class="section" title="Prebuilt domains"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Prebuilt domains</h2></div></div></div><p>In addition to<a class="indexterm" id="id258"/> using prebuilt entities, we can use prebuilt domains. These are entities and intents that already exist, leveraging <a class="indexterm" id="id259"/>commonly used intents and entities from different domains. By using these intents and entities, you can use models that you would typically use in Windows. A very basic example is setting up appointments in the calendar.</p><p>To use Cortana's prebuilt domain, you can select <span class="strong"><strong>Prebuilt domains</strong></span> from the left-hand menu. This will open a list of available domains. By clicking <span class="strong"><strong>Add domain</strong></span>, you can add the selected domain, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Prebuilt domains" src="graphics/B12373_04_09.jpg"/></div><p>This will add the intents and entities for that specific domain to the list of intents and entities that is already defined, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Prebuilt domains" src="graphics/B12373_04_10.jpg"/></div><p>The following list shows the top-level domains that are available with Cortana's prebuilt domains. For<a class="indexterm" id="id260"/> a complete list <a class="indexterm" id="id261"/>of the available prebuilt domains, please refer to <a class="link" href="apa.html" title="Appendix A. LUIS Entities">Appendix A</a>, <span class="emphasis"><em>LUIS Entities</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Calendar</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Camera</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Communication</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Entertainment</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Events</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Fitness</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Gaming</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">HomeAutomation</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">MovieTickets</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Music</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Note</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">OnDevice</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Places</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Reminder</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">RestaurantReservation</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Taxi</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Translate</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Utilities</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Weather</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Web</code></li></ul></div></div></div></div>
<div class="section" title="Training a model"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Training a model</h1></div></div></div><p>Now that <a class="indexterm" id="id262"/>we have a working model, it is time to put it into action.</p><div class="section" title="Training and publishing the model"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Training and publishing the model</h2></div></div></div><p>The first step to using the model is to make sure that the model has some utterances to work with. Until now, we have added one utterance per intent. Before we deploy the application, we<a class="indexterm" id="id263"/> need more.</p><p>Think of three to <a class="indexterm" id="id264"/>four different ways to set or get the room temperature and add them, specifying the entities and intents. Also, add a couple of utterances that fall into the <code class="literal">None</code> intent, just for reference.</p><p>When we have added some new utterances, we need to train the model. Doing so will make LUIS develop code to recognize the relevant entities and intents in the future. This process is done periodically; however, it is wise to do it whenever you have made changes, before publication. This can be done by clicking <span class="strong"><strong>Train</strong></span> in the top menu.</p><p>To test the application, you can simply enter test sentences in the <span class="strong"><strong>Interactive Testing</strong></span> tab. This will show you how any given sentence is labeled, and what intents the service has discovered, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Training and publishing the model" src="graphics/B12373_04_11.jpg"/></div><p>With the<a class="indexterm" id="id265"/> training completed, we can publish the <a class="indexterm" id="id266"/>application. This will deploy the models to an HTTP endpoint, which will interpret the sentences that we send to it.</p><p>Select <span class="strong"><strong>Publish</strong></span> from the left-hand menu. This will present you with the following screen:</p><div class="mediaobject"><img alt="Training and publishing the model" src="graphics/B12373_04_12.jpg"/></div><p>Click on the <span class="strong"><strong>Publish</strong></span> button to deploy the application. The URL beneath the <span class="strong"><strong>Endpoint</strong></span> <span class="strong"><strong>url settings</strong></span> field is the endpoint where the model is deployed. As you can see, it specifies the <a class="indexterm" id="id267"/>application ID, as well as the <a class="indexterm" id="id268"/>subscription key.</p><p>Before we go any further, we can verify that the endpoint actually works. You can do this by entering a query into the text field (for instance, <code class="literal">get the bedroom temperature</code>) and clicking on the link. This should present you with something similar to the following screenshot:</p><div class="mediaobject"><img alt="Training and publishing the model" src="graphics/B12373_04_13.jpg"/></div><p>When the<a class="indexterm" id="id269"/> model has been published, we can move <a class="indexterm" id="id270"/>on to access it through the code.</p></div><div class="section" title="Connecting to the smart house application"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Connecting to the smart house application</h2></div></div></div><p>To be able to <a class="indexterm" id="id271"/>easily work with LUIS, we will want to add the NuGet client package. In the smart house application, go to the NuGet package manager and find the <code class="literal">Microsoft.Cognitive.LUIS</code> package. Install this into the project.</p><p>We will <a class="indexterm" id="id272"/>need to add a new class called <code class="literal">Luis</code>. Place the file under the <code class="literal">Model</code> folder. This class will be in charge of calling the endpoint and processing the result.</p><p>As we will need to test this class, we will need to add a <code class="literal">View</code> and a <code class="literal">ViewModel</code>. Add the file <code class="literal">LuisView.xaml</code> to the <code class="literal">View</code> folder, and add <code class="literal">LuisViewModel.cs</code> to the <code class="literal">ViewModel</code> folder.</p><p>The <code class="literal">View</code> should be rather simple. It should contain two <code class="literal">TextBox</code> elements, one for inputting requests and the other for displaying results. We also need a button to execute commands.</p><p>Add the <code class="literal">View</code> as a <code class="literal">TabItem</code> in the <code class="literal">MainView.xaml</code> file.</p><p>The <code class="literal">ViewModel</code> should have two <code class="literal">string</code> properties, one for each of the <code class="literal">TextBox</code> elements. It will also need an <code class="literal">ICommand</code> property for the <code class="literal">button</code> command.</p><p>We will create the <code class="literal">Luis</code> class first, so open the <code class="literal">Luis.cs</code> file. Make the class <code class="literal">public</code>.</p><p>When we have made requests and received the corresponding result, we want to trigger an event to notify the UI. We want some additional arguments with this event, so, below the <code class="literal">Luis</code> class, create a <code class="literal">LuisUtteranceResultEventArgs</code> class that inherits from the <code class="literal">EventArgs</code> class, as follows:</p><div class="informalexample"><pre class="programlisting">    public class LuisUtteranceResultEventArgs : EventArgs {
        public string Status { get; set; }
        public string Message { get; set; }
        public bool RequiresReply { get; set; }
    }</pre></div><p>This will contain a <code class="literal">Status</code> string, a <code class="literal">Message</code> status, and the <code class="literal">Result</code> itself. Go back to the <code class="literal">Luis</code> class and add an event and a private member, as follows:</p><div class="informalexample"><pre class="programlisting">    public event EventHandler&lt;LuisUtteranceResultEventArgs&gt; OnLuisUtteranceResultUpdated;

    private LuisClient _luisClient;</pre></div><p>We have already discussed the event. The private member is the API access object, which we installed from NuGet:</p><div class="informalexample"><pre class="programlisting">    public Luis(LuisClientluisClient) {
        _luisClient = luisClient;
    }</pre></div><p>The constructor should accept the <code class="literal">LuisClient</code> object as a parameter and assign it to the member we previously created.</p><p>Let's create<a class="indexterm" id="id273"/> a helper method to raise the <code class="literal">OnLuisUtteranceResultUpdated</code> event, as follows:</p><div class="informalexample"><pre class="programlisting">private void RaiseOnLuisUtteranceResultUpdated( LuisUtteranceResultEventArgsargs)
{
    OnLuisUtteranceResultUpdated?.Invoke(this, args);
}</pre></div><p>This is<a class="indexterm" id="id274"/> purely for our own convenience.</p><p>To be able to make requests, we will create a function called <code class="literal">RequestAsync</code>. This will accept a <code class="literal">string</code> as a parameter and have <code class="literal">Task</code> as the return type. The function should be marked as <code class="literal">async</code>, as follows:</p><div class="informalexample"><pre class="programlisting">    public async Task RequestAsync(string input) {
        try {
            LuisResult result = await _luisClient.Predict(input);</pre></div><p>Inside the function, we make a call to the <code class="literal">Predict</code> function of <code class="literal">_luisClient</code>. This will send a query to the endpoint we published earlier. A successful request will result in a <code class="literal">LuisResult</code> object that contains some data, which we will explore shortly.</p><p>We use the result in a new function, where we process it. We make sure that we catch any exceptions and notify any listeners about it using the following code:</p><div class="informalexample"><pre class="programlisting">            ProcessResult(result);
        }
        catch(Exception ex) {
            RaiseOnLuisUtteranceResultUpdated(new LuisUtteranceResultEventArgs
            {
                Status = "Failed",
                Message = ex.Message
            });
        }
    }</pre></div><p>In the <code class="literal">ProcessResult</code> function, we create a new object of the <code class="literal">LuisUtteranceResultEventArgs</code> type. This will be used when notifying listeners of any results. In this argument object, we add the <code class="literal">Succeeded</code> status and the <code class="literal">result</code> object. We also write out a message, stating the top identified intent. We also add the likelihood of this intent being the top one out of all the intents we have. Finally, we also add the number <a class="indexterm" id="id275"/>of intents identified:</p><div class="informalexample"><pre class="programlisting">    private void ProcessResult(LuisResult result) {
        LuisUtteranceResultEventArgsargs = new LuisUtteranceResultEventArgs();

        args.Result = result;
        args.Status = "Succeeded";
        args.Message = $"Top intent is {result.TopScoringIntent.Name} with score {result.TopScoringIntent.Score}. Found {result.Entities.Count} entities.";

        RaiseOnLuisUtteranceResultUpdated(args);
    }</pre></div><p>With<a class="indexterm" id="id276"/> that in place, we head to our view model. Open the <code class="literal">LuisViewModel.cs</code> file. Make sure that the class is <code class="literal">public</code> and that it inherits from the <code class="literal">ObservableObject</code> class.</p><p>Declare a private member, as follows:</p><div class="informalexample"><pre class="programlisting">    private Luis _luis;</pre></div><p>This will hold the <code class="literal">Luis</code> object we created earlier:</p><div class="informalexample"><pre class="programlisting">    public LuisViewModel() {
        _luis = new Luis(new LuisClient("APP_ID_HERE", "API_KEY_HERE"));</pre></div><p>Our constructor creates the <code class="literal">Luis</code> object, making sure it is initialized with a new <code class="literal">LuisClient</code>. As you may have noticed, this requires two parameters, the application ID and the subscription ID. There is also a third parameter, <code class="literal">preview</code>, but we will not need to set it at this time.</p><p>The application ID can be found either by looking at the URL in the publishing step or by going to <span class="strong"><strong>Settings</strong></span> on the application's site at <a class="ulink" href="https://www.luis.ai">https://www.luis.ai</a>. There, you will find the <span class="strong"><strong>Application ID</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Connecting to the smart house application" src="graphics/B12373_04_14.jpg"/></div><p>With the <code class="literal">Luis</code> object created, we complete the constructor as follows:</p><div class="informalexample"><pre class="programlisting">    _luis.OnLuisUtteranceResultUpdated += OnLuisUtteranceResultUpdated;
    ExecuteUtteranceCommand = new DelegateCommand(ExecuteUtterance, CanExecuteUtterance);
}</pre></div><p>This <a class="indexterm" id="id277"/>will hook<a class="indexterm" id="id278"/> up the <code class="literal">OnLuisUtteranceResultUpdated</code> event and create a new <code class="literal">DelegateCommand</code> event for our button. For our command to be able to run, we need to check that we have written some text in the input field. This is done using <code class="literal">CanExecuteUtterance</code>.</p><p>The <code class="literal">ExecuteUtterance</code> command is itself rather simple, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    private async void ExecuteUtterance(object obj) {
        await _luis.RequestAsync(InputText);
    }</pre></div><p>All we do is make a call to the <code class="literal">RequestAsync</code> function in the <code class="literal">_luis</code> object. We do not need to wait for any results, as these will be coming from the event.</p><p>The event handler, <code class="literal">OnLuisUtteranceResultUpdated</code>, will format the results and print them to the screen.</p><p>First, we make sure that we invoke the methods in the current dispatcher thread. This is done as the event is triggered in another thread. We create a <code class="literal">StringBuilder</code>, which will be used to concatenate all the results, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">private void OnLuisUtteranceResultUpdated(object sender, LuisUtteranceResultEventArgs e) {
    Application.Current.Dispatcher.Invoke(() =&gt; {
        StringBuilder sb = new StringBuilder();</pre></div><p>First, we append the <code class="literal">Status</code> and the <code class="literal">Message</code> status. We then check to see if we have any entities that were detected and append the number of entities, as follows:</p><div class="informalexample"><pre class="programlisting">    sb.AppendFormat("Status: {0}\n", e.Status);
    sb.AppendFormat("Summary: {0}\n\n", e.Message);

    if(e.Result.Entities != null&amp;&amp;e.Result.Entities.Count != 0) {
        sb.AppendFormat("Entities found: {0}\n", e.Result.Entities.Count);
        sb.Append("Entities:\n");</pre></div><p>If we <a class="indexterm" id="id279"/>do have<a class="indexterm" id="id280"/> any entities, we loop through each of them, printing out the entity name and the value:</p><div class="informalexample"><pre class="programlisting">        foreach(var entities in e.Result.Entities) {
            foreach(var entity in entities.Value) {
                sb.AppendFormat("Name: {0}\tValue: {1}\n",
                                 entity.Name, entity.Value);
            }
        }
        sb.Append("\n");
    }</pre></div><p>Finally, we add <code class="literal">StringBuilder</code> to our <code class="literal">ResultText</code> string, which should display it on screen, as follows:</p><div class="informalexample"><pre class="programlisting">            ResultText = sb.ToString();
        });
    }</pre></div><p>With everything having compiled, the result should look something like the following screenshot:</p><div class="mediaobject"><img alt="Connecting to the smart house application" src="graphics/B12373_04_15.jpg"/></div></div><div class="section" title="Model improvement through active usage"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Model improvement through active usage</h2></div></div></div><p>LUIS is a machine learning service. The applications we create, and the models that are generated, can <a class="indexterm" id="id281"/>therefore improve based on use. Throughout the development, it is a good idea to keep an eye on the performance. You may notice some intents that are often mislabeled, or entities that are hard to recognize.</p><div class="section" title="Visualizing performance"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec40"/>Visualizing performance</h3></div></div></div><p>On the <a class="indexterm" id="id282"/>LUIS website, the dashboard displays information about intent and entity breakdowns. This is basically information on how the intents and entities are distributed across the utterances that have been used.</p><p>The following diagram shows what the intent breakdown display looks like:</p><div class="mediaobject"><img alt="Visualizing performance" src="graphics/B12373_04_16.jpg"/></div><p>The <a class="indexterm" id="id283"/>following diagram shows what the entity breakdown looks like:</p><div class="mediaobject"><img alt="Visualizing performance" src="graphics/B12373_04_17.jpg"/></div><p>By<a class="indexterm" id="id284"/> hovering the mouse over the different bars (or sectors of the pie chart), the name of the intent/entity will be displayed. In addition, the percentage number of the total number of intents/entities in use is displayed.</p></div><div class="section" title="Resolving performance problems"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec41"/>Resolving performance problems</h3></div></div></div><p>If you <a class="indexterm" id="id285"/>notice an error in your applications, there are typically four options to resolve it:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding model features</li><li class="listitem" style="list-style-type: disc">Adding labeled utterances</li><li class="listitem" style="list-style-type: disc">Looking for incorrect utterance labels</li><li class="listitem" style="list-style-type: disc">Changing the schema</li></ul></div><p>We <a class="indexterm" id="id286"/>will now look briefly at each of these.</p><div class="section" title="Adding model features"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec06"/>Adding model features</h4></div></div></div><p>Adding model features is typically something we can do if we have phrases that should be detected as<a class="indexterm" id="id287"/> entities, but are not. We have already seen an example of this with the room entity, where one room could be the living room.</p><p>The solution is, of course, to add phrase lists or regex features. There are three scenarios where this will likely help:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When LUIS fails to see words or phrases that are similar.</li><li class="listitem" style="list-style-type: disc">When LUIS has trouble identifying entities. Adding all possible entity values in a phrase list should help.</li><li class="listitem" style="list-style-type: disc">When rare or proprietary words are used.</li></ul></div></div><div class="section" title="Adding labeled utterances"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec07"/>Adding labeled utterances</h4></div></div></div><p>Adding<a class="indexterm" id="id288"/> and labeling more utterances will always improve performance. This will most likely help in the following scenarios:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When LUIS fails to differentiate between two intents</li><li class="listitem" style="list-style-type: disc">When LUIS fails to detect entities between surrounding words</li><li class="listitem" style="list-style-type: disc">If LUIS systematically assigns low scores to an intent</li></ul></div></div><div class="section" title="Looking for incorrect utterance labels"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec08"/>Looking for incorrect utterance labels</h4></div></div></div><p>A common <a class="indexterm" id="id289"/>mistake is mislabeling an utterance or entity. In such cases, you will need to find the incorrect utterance and correct it. This will likely resolve problems in the following scenarios:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If LUIS fails to differentiate between two intents, even when similar utterances have been labeled</li><li class="listitem" style="list-style-type: disc">If LUIS <a class="indexterm" id="id290"/>consistently misses an entity</li></ul></div></div><div class="section" title="Changing the schema"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec09"/>Changing the schema</h4></div></div></div><p>If all the<a class="indexterm" id="id291"/> preceding solutions fail and you still have problems with the model, you may consider changing the schema, meaning combining, regrouping, and/or dropping intents and entities.</p><p>Keep in mind that if it is hard for humans to label an utterance, it is even harder for a machine.</p></div></div><div class="section" title="Active learning"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec42"/>Active learning</h3></div></div></div><p>A very nice <a class="indexterm" id="id292"/>feature of LUIS is the power of active learning. When we are using the service actively, it will log all queries, and, as such, we will then be able to analyze usage. Doing so allows us to quickly correct errors and label utterances we have not seen before.</p><p>Using the application we have built—the smart house application—if we run a query with the utterance <code class="literal">can you tell me the bedroom temperature?</code>, the model will likely not recognize this. If we debug the process, stepping through the <code class="literal">ProcessResult</code> function, we will see the following values returned:</p><div class="mediaobject"><img alt="Active learning" src="graphics/B12373_04_18.jpg"/></div><p>As you can see from the preceding screenshot, the top-scoring intent is <code class="literal">None</code>, with a score of <code class="literal">0.61</code>. In addition, no entities have been recognized, so this is not good.</p><p>Head back to the LUIS website. Move to the <span class="strong"><strong>Review endpoint utterances</strong></span> page, which can be found in the left-hand menu. Here, we can see that the utterance we just tried has been added. We can now label the intent and entity correctly, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Active learning" src="graphics/B12373_04_19.jpg"/></div><p>By labeling the utterance with the correct intent and entity, we will get a correct result the next time we<a class="indexterm" id="id293"/> query in this way, as you can see in the following screenshot:</p><div class="mediaobject"><img alt="Active learning" src="graphics/B12373_04_20.jpg"/></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Summary</h1></div></div></div><p>In this chapter, we created a LUIS application. You learned how to create language-understanding models, which can recognize entities in sentences. You learned how to understand the user's intent and how we can trigger actions from this. An important step was to see how to improve the model in various ways.</p><p>In the next chapter, we will utilize what you have learned here, using LUIS with speech APIs, giving us the ability to speak to our application.</p></div></body></html>