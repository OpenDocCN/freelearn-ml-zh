- en: Chapter 4. Letting Applications Understand Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"LUIS saved us tremendous time while going from a prototype to production."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- Eyal Yavor, Cofounder and CTO of Meekan'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Throughout the previous chapters, we have focused on vision APIs. Starting with
    this chapter, we will move on to language APIs, where we will start with the **Language
    Understanding Intelligent Service** (**LUIS**). Throughout this chapter, you will
    learn how to create and maintain language-understanding models.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, we will have covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating language-understanding models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling common requests using prebuilt models from Bing and Cortana
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating language-understanding models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we might wish that our computer could understand what we want. As
    we go on with our day-to-day business, we want to be able to talk to our computer,
    or mobile phone, using regular sentences. This is hard to do without any extra
    help.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the power of LUIS, we can now solve this problem. By creating language-understanding
    models, we can allow applications to understand what users want. We can also recognize
    key data, which is, typically, data that you want to be part of a query or command.
    If you are asking for the latest news on a certain issue, then the key data would
    be the topic of the news that you are asking for.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with LUIS, you should head over to [https://www.luis.ai](https://www.luis.ai).
    This is where we will set up our application. Click on the **Sign in or create
    an account** button to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create our first application. Click on **My Apps** from the top menu.
    This should take you back to the application list, which should be empty. Click
    on **New App**.
  prefs: []
  type: TYPE_NORMAL
- en: In the form that is shown, we fill in the given information about our application.
    We are required to give the application a name. We also need to indicate an atypical
    usage scenario, which will be set by default to **Other (please specify)**. Instead,
    set this to **SmartHouseApplication**. This application falls under the **Tools**
    domain. We will choose an English **Application Culture**.
  prefs: []
  type: TYPE_NORMAL
- en: The other languages that are available are Brazilian, Portuguese, Chinese, French,
    German, Italian, Japanese, and Spanish.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how we can define the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an application](img/B12373_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you click on the **Create** button, the application will be created. This
    process will take about a minute or so to complete, so just be patient.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the application has been created, you will be taken to the application''s
    home base, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an application](img/B12373_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have a variety of features to use, and we will cover the
    important ones here.
  prefs: []
  type: TYPE_NORMAL
- en: The application we will build will be aimed at our smart house application.
    We will configure the application to recognize commands to set the temperature
    in different rooms. In addition, we would like it to tell us what the temperatures
    in the different rooms are.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing key data using entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the key features of LUIS is the ability to recognize key data in sentences.
    The instances of this key data are known as entities. In a news application, an
    example of an entity would be the topic. If we ask to get the latest news, we
    could specify a topic for the service to recognize.
  prefs: []
  type: TYPE_NORMAL
- en: For our application, we want to add an entity for our rooms. We do this by selecting
    **Entities** in the left-hand pane. Then we click on **Add custom entity**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be presented with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing key data using entities](img/B12373_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enter the name of the entity and click on the **Save** button. That's it—you
    have now created the first entity. We will see how to use this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, there is a drop-down list called **Entity type** in
    the entity creation form. Entity types are a way to create hierarchical entities,
    which is basically about defining relationships between entities.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, you can imagine searching for news inside a given time frame.
    The generic top-level entity is `Date`. Going from there, you can define two children,
    `StartDate` and `EndDate`. These will be recognized by the service, where models
    will be built for the entity and its children.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a hierarchical child entity, check the checkbox and select **Hierarchical**
    from the selection. Click on the + button next to **Entity Children** for each
    child you want to add, as shown in the following screenshot. Enter the name of
    the child:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing key data using entities](img/B12373_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The other types of entities you can add are called **composite entities**. This
    is a type of entity that is formed by a set of existing entities. This is what
    we would call a *has-a* relationship, so the components are children, but not
    in a parent-child relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Composite entities do not share common traits as hierarchical entities do. When
    deleting the top-level entity, you do not delete components. Using composite entities,
    LUIS can identify groups of entities, which are then treated as a single entity.
  prefs: []
  type: TYPE_NORMAL
- en: Using composite entities is like ordering a pizza. You can order a pizza by
    stating *I want a large pizza with mushrooms and pepperoni*. In this example,
    we can see the size as an entity, and we can also see the two toppings as entities.
    Combining these could make a composite entity, which is called an order.
  prefs: []
  type: TYPE_NORMAL
- en: The last type of entity you can add is called a **list entity**. This is a customized
    list of entity values to be used as keywords or identifiers within utterances.
  prefs: []
  type: TYPE_NORMAL
- en: When using entities, there may be times where an entity consists of several
    words. In our case, with the `Rooms` entity, we may ask for the living room. To
    be able to identify such phrasings, we can define a feature list. This is a comma-separated
    list that can contain some or all of the expected phrases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add one for our application. On the left-hand side, at the bottom of
    the pane, you will see **Features**. Select this and click on **Add phrase list**
    to create a new list. Call it `Rooms` and add the different rooms that you would
    expect to find in a house, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing key data using entities](img/B12373_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By clicking on **Recommend** on the right-hand side, LUIS will recommend more
    values related to the ones you have already entered.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how this is utilized later.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to creating phrase lists, we can create **pattern features**. The
    typical use case of using pattern features is when you have data that matches
    patterns but it is not feasible to enter them as a phrase list. Pattern features
    are typically used with product numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what the user wants using intents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have defined an entity, it is time to see how it fits in with intents.
    An **intent** is basically the purpose of a sentence.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add intents to our application by selecting the **Intents** option in
    the left-hand pane. Click on **Add intent**. When we add an intent, we give it
    a name. The name should be descriptive of what the intent is. We want to add an
    intent named `GetRoomTemperature`, where the goal is to get the temperature of
    a given room, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding what the user wants using intents](img/B12373_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you click on the **Save** button, you will be taken to the utterance page.
    Here, we can add sentences that we can use for the intent, so let's add one. Enter
    `what is the temperature in the kitchen?` and press *Enter*. The sentence (or
    utterance, as it is called) will be ready for labeling. Labeling an utterance
    means that we define what intent it belongs to. We should also make sure that
    we mark entities with the correct type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the labeling process for our first utterance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding what the user wants using intents](img/B12373_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the entity is marked. You can tell LUIS that a word is a given
    entity by clicking on the word. This will pop up a menu containing all the available
    entities, and you can then select the correct one. Also, note how the **GetRoomTemperature**
    intent is selected in the drop-down list. Click **Train** once you are done labeling
    your utterances.
  prefs: []
  type: TYPE_NORMAL
- en: All applications are created with a default intent called **None**. This intent
    will encompass sentences that do not belong to our application at all. If we were
    to say *Order a large pizza with mushrooms and pepperoni*, this would end up with
    **None** as the intent.
  prefs: []
  type: TYPE_NORMAL
- en: When you are creating intents, you should define at least three to five utterances.
    This will give LUIS something to work with, and, as such, it can create better
    models. We will see how we can improve performance later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying development using prebuilt models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building entities and intents can be easy or it can be intricate. Fortunately,
    LUIS provides a set of prebuilt entities that stem from Bing. These entities will
    be included in the applications, as well as on the web, while going through the
    labeling process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes all the available prebuilt entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Entity | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `builtin.number` | Five, 23.21 |'
  prefs: []
  type: TYPE_TB
- en: '| `builtin.ordinal` | Second, 3rd |'
  prefs: []
  type: TYPE_TB
- en: '| `builtin.temperature` | 2 degrees Celsius, 104 F |'
  prefs: []
  type: TYPE_TB
- en: '| `builtin.dimension` | 231 square kilometers |'
  prefs: []
  type: TYPE_TB
- en: '| `builtin.age` | 27 years old |'
  prefs: []
  type: TYPE_TB
- en: '| `builtin.geography` | City, country, point of interest |'
  prefs: []
  type: TYPE_TB
- en: '| `builtin.encyclopedia` | Person, organization, event, TV episode, product,
    film, and so on |'
  prefs: []
  type: TYPE_TB
- en: '| `builtin.datetime` | Date, time, duration, set |'
  prefs: []
  type: TYPE_TB
- en: The last three have several subentities, as described in the **Example** column
    of the table.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add one of these prebuilt entities, so select **Entities** in
    the menu. Click on **Add prebuilt entity**, select **temperature** from the list,
    and click on **Save**.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the newly created entity, we want to add a new intent called **SetTemperature**.
    If the example utterance is *Set the temperature in the kitchen to 22 degrees
    Celsius,* we can label the utterance as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simplifying development using prebuilt models](img/B12373_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have a `room` entity. We also have the prebuilt `temperature`
    entity clearly labeled. As the correct intent should be selected in the drop-down
    menu, we can click on the **Train** button to save the utterance.
  prefs: []
  type: TYPE_NORMAL
- en: Prebuilt domains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to using prebuilt entities, we can use prebuilt domains. These are
    entities and intents that already exist, leveraging commonly used intents and
    entities from different domains. By using these intents and entities, you can
    use models that you would typically use in Windows. A very basic example is setting
    up appointments in the calendar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Cortana''s prebuilt domain, you can select **Prebuilt domains** from
    the left-hand menu. This will open a list of available domains. By clicking **Add
    domain**, you can add the selected domain, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prebuilt domains](img/B12373_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will add the intents and entities for that specific domain to the list
    of intents and entities that is already defined, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prebuilt domains](img/B12373_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following list shows the top-level domains that are available with Cortana''s
    prebuilt domains. For a complete list of the available prebuilt domains, please
    refer to [Appendix A](apa.html "Appendix A. LUIS Entities"), *LUIS Entities*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Calendar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Camera`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Communication`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Entertainment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Events`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fitness`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Gaming`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HomeAutomation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MovieTickets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Music`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Note`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDevice`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Places`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reminder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RestaurantReservation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Taxi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Translate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Utilities`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Weather`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Web`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Training a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a working model, it is time to put it into action.
  prefs: []
  type: TYPE_NORMAL
- en: Training and publishing the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step to using the model is to make sure that the model has some utterances
    to work with. Until now, we have added one utterance per intent. Before we deploy
    the application, we need more.
  prefs: []
  type: TYPE_NORMAL
- en: Think of three to four different ways to set or get the room temperature and
    add them, specifying the entities and intents. Also, add a couple of utterances
    that fall into the `None` intent, just for reference.
  prefs: []
  type: TYPE_NORMAL
- en: When we have added some new utterances, we need to train the model. Doing so
    will make LUIS develop code to recognize the relevant entities and intents in
    the future. This process is done periodically; however, it is wise to do it whenever
    you have made changes, before publication. This can be done by clicking **Train**
    in the top menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the application, you can simply enter test sentences in the **Interactive
    Testing** tab. This will show you how any given sentence is labeled, and what
    intents the service has discovered, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Training and publishing the model](img/B12373_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the training completed, we can publish the application. This will deploy
    the models to an HTTP endpoint, which will interpret the sentences that we send
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Publish** from the left-hand menu. This will present you with the
    following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Training and publishing the model](img/B12373_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the **Publish** button to deploy the application. The URL beneath the
    **Endpoint** **url settings** field is the endpoint where the model is deployed.
    As you can see, it specifies the application ID, as well as the subscription key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go any further, we can verify that the endpoint actually works. You
    can do this by entering a query into the text field (for instance, `get the bedroom
    temperature`) and clicking on the link. This should present you with something
    similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Training and publishing the model](img/B12373_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the model has been published, we can move on to access it through the code.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the smart house application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to easily work with LUIS, we will want to add the NuGet client package.
    In the smart house application, go to the NuGet package manager and find the `Microsoft.Cognitive.LUIS`
    package. Install this into the project.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to add a new class called `Luis`. Place the file under the `Model`
    folder. This class will be in charge of calling the endpoint and processing the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: As we will need to test this class, we will need to add a `View` and a `ViewModel`.
    Add the file `LuisView.xaml` to the `View` folder, and add `LuisViewModel.cs`
    to the `ViewModel` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The `View` should be rather simple. It should contain two `TextBox` elements,
    one for inputting requests and the other for displaying results. We also need
    a button to execute commands.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `View` as a `TabItem` in the `MainView.xaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: The `ViewModel` should have two `string` properties, one for each of the `TextBox`
    elements. It will also need an `ICommand` property for the `button` command.
  prefs: []
  type: TYPE_NORMAL
- en: We will create the `Luis` class first, so open the `Luis.cs` file. Make the
    class `public`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have made requests and received the corresponding result, we want to
    trigger an event to notify the UI. We want some additional arguments with this
    event, so, below the `Luis` class, create a `LuisUtteranceResultEventArgs` class
    that inherits from the `EventArgs` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will contain a `Status` string, a `Message` status, and the `Result` itself.
    Go back to the `Luis` class and add an event and a private member, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already discussed the event. The private member is the API access object,
    which we installed from NuGet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The constructor should accept the `LuisClient` object as a parameter and assign
    it to the member we previously created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a helper method to raise the `OnLuisUtteranceResultUpdated` event,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is purely for our own convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to make requests, we will create a function called `RequestAsync`.
    This will accept a `string` as a parameter and have `Task` as the return type.
    The function should be marked as `async`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Inside the function, we make a call to the `Predict` function of `_luisClient`.
    This will send a query to the endpoint we published earlier. A successful request
    will result in a `LuisResult` object that contains some data, which we will explore
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the result in a new function, where we process it. We make sure that
    we catch any exceptions and notify any listeners about it using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ProcessResult` function, we create a new object of the `LuisUtteranceResultEventArgs`
    type. This will be used when notifying listeners of any results. In this argument
    object, we add the `Succeeded` status and the `result` object. We also write out
    a message, stating the top identified intent. We also add the likelihood of this
    intent being the top one out of all the intents we have. Finally, we also add
    the number of intents identified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With that in place, we head to our view model. Open the `LuisViewModel.cs` file.
    Make sure that the class is `public` and that it inherits from the `ObservableObject`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a private member, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will hold the `Luis` object we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our constructor creates the `Luis` object, making sure it is initialized with
    a new `LuisClient`. As you may have noticed, this requires two parameters, the
    application ID and the subscription ID. There is also a third parameter, `preview`,
    but we will not need to set it at this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application ID can be found either by looking at the URL in the publishing
    step or by going to **Settings** on the application''s site at [https://www.luis.ai](https://www.luis.ai).
    There, you will find the **Application ID**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to the smart house application](img/B12373_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the `Luis` object created, we complete the constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will hook up the `OnLuisUtteranceResultUpdated` event and create a new
    `DelegateCommand` event for our button. For our command to be able to run, we
    need to check that we have written some text in the input field. This is done
    using `CanExecuteUtterance`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ExecuteUtterance` command is itself rather simple, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: All we do is make a call to the `RequestAsync` function in the `_luis` object.
    We do not need to wait for any results, as these will be coming from the event.
  prefs: []
  type: TYPE_NORMAL
- en: The event handler, `OnLuisUtteranceResultUpdated`, will format the results and
    print them to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we make sure that we invoke the methods in the current dispatcher thread.
    This is done as the event is triggered in another thread. We create a `StringBuilder`,
    which will be used to concatenate all the results, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we append the `Status` and the `Message` status. We then check to see
    if we have any entities that were detected and append the number of entities,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do have any entities, we loop through each of them, printing out the
    entity name and the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add `StringBuilder` to our `ResultText` string, which should display
    it on screen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With everything having compiled, the result should look something like the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to the smart house application](img/B12373_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Model improvement through active usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LUIS is a machine learning service. The applications we create, and the models
    that are generated, can therefore improve based on use. Throughout the development,
    it is a good idea to keep an eye on the performance. You may notice some intents
    that are often mislabeled, or entities that are hard to recognize.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the LUIS website, the dashboard displays information about intent and entity
    breakdowns. This is basically information on how the intents and entities are
    distributed across the utterances that have been used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows what the intent breakdown display looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing performance](img/B12373_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram shows what the entity breakdown looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing performance](img/B12373_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By hovering the mouse over the different bars (or sectors of the pie chart),
    the name of the intent/entity will be displayed. In addition, the percentage number
    of the total number of intents/entities in use is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving performance problems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you notice an error in your applications, there are typically four options
    to resolve it:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding model features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding labeled utterances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking for incorrect utterance labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now look briefly at each of these.
  prefs: []
  type: TYPE_NORMAL
- en: Adding model features
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adding model features is typically something we can do if we have phrases that
    should be detected as entities, but are not. We have already seen an example of
    this with the room entity, where one room could be the living room.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is, of course, to add phrase lists or regex features. There are
    three scenarios where this will likely help:'
  prefs: []
  type: TYPE_NORMAL
- en: When LUIS fails to see words or phrases that are similar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When LUIS has trouble identifying entities. Adding all possible entity values
    in a phrase list should help.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When rare or proprietary words are used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding labeled utterances
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Adding and labeling more utterances will always improve performance. This will
    most likely help in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When LUIS fails to differentiate between two intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When LUIS fails to detect entities between surrounding words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If LUIS systematically assigns low scores to an intent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking for incorrect utterance labels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A common mistake is mislabeling an utterance or entity. In such cases, you
    will need to find the incorrect utterance and correct it. This will likely resolve
    problems in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: If LUIS fails to differentiate between two intents, even when similar utterances
    have been labeled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If LUIS consistently misses an entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the schema
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If all the preceding solutions fail and you still have problems with the model,
    you may consider changing the schema, meaning combining, regrouping, and/or dropping
    intents and entities.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that if it is hard for humans to label an utterance, it is even
    harder for a machine.
  prefs: []
  type: TYPE_NORMAL
- en: Active learning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very nice feature of LUIS is the power of active learning. When we are using
    the service actively, it will log all queries, and, as such, we will then be able
    to analyze usage. Doing so allows us to quickly correct errors and label utterances
    we have not seen before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the application we have built—the smart house application—if we run a
    query with the utterance `can you tell me the bedroom temperature?`, the model
    will likely not recognize this. If we debug the process, stepping through the
    `ProcessResult` function, we will see the following values returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Active learning](img/B12373_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshot, the top-scoring intent is `None`,
    with a score of `0.61`. In addition, no entities have been recognized, so this
    is not good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back to the LUIS website. Move to the **Review endpoint utterances** page,
    which can be found in the left-hand menu. Here, we can see that the utterance
    we just tried has been added. We can now label the intent and entity correctly,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Active learning](img/B12373_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By labeling the utterance with the correct intent and entity, we will get a
    correct result the next time we query in this way, as you can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Active learning](img/B12373_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a LUIS application. You learned how to create language-understanding
    models, which can recognize entities in sentences. You learned how to understand
    the user's intent and how we can trigger actions from this. An important step
    was to see how to improve the model in various ways.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will utilize what you have learned here, using LUIS
    with speech APIs, giving us the ability to speak to our application.
  prefs: []
  type: TYPE_NORMAL
