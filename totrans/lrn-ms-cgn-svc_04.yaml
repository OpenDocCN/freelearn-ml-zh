- en: Chapter 4. Letting Applications Understand Commands
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：让应用程序理解命令
- en: '*"LUIS saved us tremendous time while going from a prototype to production."*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “LUIS在从原型到生产的过程中为我们节省了大量的时间。”
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- Eyal Yavor, Cofounder and CTO of Meekan'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- Eyal Yavor，Meekan的联合创始人兼CTO'
- en: Throughout the previous chapters, we have focused on vision APIs. Starting with
    this chapter, we will move on to language APIs, where we will start with the **Language
    Understanding Intelligent Service** (**LUIS**). Throughout this chapter, you will
    learn how to create and maintain language-understanding models.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们专注于视觉API。从本章开始，我们将转向语言API，我们将从**语言理解智能服务**（**LUIS**）开始。在本章中，您将学习如何创建和维护语言理解模型。
- en: 'By the end of this chapter, we will have covered the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将涵盖以下主题：
- en: Creating language-understanding models
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建语言理解模型
- en: Handling common requests using prebuilt models from Bing and Cortana
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bing和Cortana预构建模型处理常见请求
- en: Creating language-understanding models
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建语言理解模型
- en: Sometimes, we might wish that our computer could understand what we want. As
    we go on with our day-to-day business, we want to be able to talk to our computer,
    or mobile phone, using regular sentences. This is hard to do without any extra
    help.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望我们的电脑能理解我们的需求。在我们日常的业务中，我们希望能够用常规句子与电脑或手机交谈。没有额外的帮助，这是很难做到的。
- en: Utilizing the power of LUIS, we can now solve this problem. By creating language-understanding
    models, we can allow applications to understand what users want. We can also recognize
    key data, which is, typically, data that you want to be part of a query or command.
    If you are asking for the latest news on a certain issue, then the key data would
    be the topic of the news that you are asking for.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 利用LUIS的力量，我们现在可以解决这个问题。通过创建语言理解模型，我们可以让应用程序理解用户的需求。我们还可以识别关键数据，这通常是您希望成为查询或命令一部分的数据。如果您正在询问某个问题的最新新闻，那么关键数据就是您所询问的新闻的主题。
- en: Creating an application
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: To get started with LUIS, you should head over to [https://www.luis.ai](https://www.luis.ai).
    This is where we will set up our application. Click on the **Sign in or create
    an account** button to get started.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用LUIS，你应该前往[https://www.luis.ai](https://www.luis.ai)。这是我们设置应用程序的地方。点击**登录或创建账户**按钮开始。
- en: Let's create our first application. Click on **My Apps** from the top menu.
    This should take you back to the application list, which should be empty. Click
    on **New App**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个应用程序。从顶部菜单点击**我的应用**。这应该会带您回到应用程序列表，列表应该是空的。点击**新建应用**。
- en: In the form that is shown, we fill in the given information about our application.
    We are required to give the application a name. We also need to indicate an atypical
    usage scenario, which will be set by default to **Other (please specify)**. Instead,
    set this to **SmartHouseApplication**. This application falls under the **Tools**
    domain. We will choose an English **Application Culture**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示的表格中，我们填写有关我们应用程序的信息。我们需要给应用程序起一个名字。我们还需要指出一个非典型使用场景，默认设置为**其他（请指定**）。相反，将其设置为**SmartHouseApplication**。此应用程序属于**工具**领域。我们将选择英语**应用程序文化**。
- en: The other languages that are available are Brazilian, Portuguese, Chinese, French,
    German, Italian, Japanese, and Spanish.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的其他语言包括巴西葡萄牙语、中文、法语、德语、意大利语、日语和西班牙语。
- en: 'The following screenshot shows how we can define the application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了我们可以如何定义应用程序：
- en: '![Creating an application](img/B12373_04_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![创建应用程序](img/B12373_04_01.jpg)'
- en: When you click on the **Create** button, the application will be created. This
    process will take about a minute or so to complete, so just be patient.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击**创建**按钮时，应用程序将被创建。这个过程大约需要一分钟或更长时间来完成，所以请耐心等待。
- en: 'When the application has been created, you will be taken to the application''s
    home base, as shown in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序创建完成后，您将被带到应用程序的主页，如下面的截图所示：
- en: '![Creating an application](img/B12373_04_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![创建应用程序](img/B12373_04_02.jpg)'
- en: As you can see, we have a variety of features to use, and we will cover the
    important ones here.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有各种功能可以使用，我们将在下面介绍重要的功能。
- en: The application we will build will be aimed at our smart house application.
    We will configure the application to recognize commands to set the temperature
    in different rooms. In addition, we would like it to tell us what the temperatures
    in the different rooms are.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的应用程序将针对我们的智能家居应用程序。我们将配置应用程序以识别设置不同房间温度的命令。此外，我们希望它能告诉我们不同房间的温度。
- en: Recognizing key data using entities
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用实体识别关键数据
- en: One of the key features of LUIS is the ability to recognize key data in sentences.
    The instances of this key data are known as entities. In a news application, an
    example of an entity would be the topic. If we ask to get the latest news, we
    could specify a topic for the service to recognize.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: LUIS的一个关键特性是能够识别句子中的关键数据。这些关键数据实例被称为实体。在一个新闻应用程序中，实体的一个例子是主题。如果我们要求获取最新的新闻，我们可以指定一个主题供服务识别。
- en: For our application, we want to add an entity for our rooms. We do this by selecting
    **Entities** in the left-hand pane. Then we click on **Add custom entity**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们想要添加一个关于房间的实体。我们通过在左侧面板中选择**实体**来实现这一点。然后我们点击**添加自定义实体**。
- en: 'We will be presented with the following screen:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下屏幕：
- en: '![Recognizing key data using entities](img/B12373_04_03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![使用实体识别关键数据](img/B12373_04_03.jpg)'
- en: Enter the name of the entity and click on the **Save** button. That's it—you
    have now created the first entity. We will see how to use this in a bit.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 输入实体的名称并点击**保存**按钮。就这样——您现在已经创建了第一个实体。我们将在稍后看到如何使用它。
- en: As you may have noticed, there is a drop-down list called **Entity type** in
    the entity creation form. Entity types are a way to create hierarchical entities,
    which is basically about defining relationships between entities.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已注意到，在实体创建表单中有一个名为**实体类型**的下拉列表。实体类型是一种创建层次实体的方式，这基本上是关于定义实体之间关系的问题。
- en: As an example, you can imagine searching for news inside a given time frame.
    The generic top-level entity is `Date`. Going from there, you can define two children,
    `StartDate` and `EndDate`. These will be recognized by the service, where models
    will be built for the entity and its children.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以想象在给定的时间范围内搜索新闻。通用的顶级实体是`日期`。从那里开始，您可以定义两个子项，`StartDate`和`EndDate`。这些将由服务识别，其中将为实体及其子项构建模型。
- en: 'To add a hierarchical child entity, check the checkbox and select **Hierarchical**
    from the selection. Click on the + button next to **Entity Children** for each
    child you want to add, as shown in the following screenshot. Enter the name of
    the child:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个层次子实体，请勾选复选框并从选择中选取**层次**。为每个要添加的子项，点击**实体子项**旁边的+按钮，如图所示。输入子项的名称：
- en: '![Recognizing key data using entities](img/B12373_04_04.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![使用实体识别关键数据](img/B12373_04_04.jpg)'
- en: The other types of entities you can add are called **composite entities**. This
    is a type of entity that is formed by a set of existing entities. This is what
    we would call a *has-a* relationship, so the components are children, but not
    in a parent-child relationship.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加的其他类型的实体被称为**组合实体**。这是一种由一组现有实体形成的实体类型。这就是我们所说的“具有”关系，因此组件是子项，但不是在父子关系中。
- en: Composite entities do not share common traits as hierarchical entities do. When
    deleting the top-level entity, you do not delete components. Using composite entities,
    LUIS can identify groups of entities, which are then treated as a single entity.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 组合实体与层次实体不共享共同特征。当删除顶级实体时，不会删除组件。使用组合实体，LUIS可以识别实体组，然后将其作为单个实体处理。
- en: Using composite entities is like ordering a pizza. You can order a pizza by
    stating *I want a large pizza with mushrooms and pepperoni*. In this example,
    we can see the size as an entity, and we can also see the two toppings as entities.
    Combining these could make a composite entity, which is called an order.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组合实体就像订购披萨一样。您可以通过说“我想一个大披萨，上面有蘑菇和意大利辣肠”来订购披萨。在这个例子中，我们可以看到大小作为一个实体，我们也可以看到两种配料作为实体。将这些组合起来可以形成一个组合实体，这被称为订单。
- en: The last type of entity you can add is called a **list entity**. This is a customized
    list of entity values to be used as keywords or identifiers within utterances.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加的最后一种实体类型被称为**列表实体**。这是一个用于在话语中作为关键词或标识符使用的自定义实体值列表。
- en: When using entities, there may be times where an entity consists of several
    words. In our case, with the `Rooms` entity, we may ask for the living room. To
    be able to identify such phrasings, we can define a feature list. This is a comma-separated
    list that can contain some or all of the expected phrases.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用实体时，有时一个实体可能由多个单词组成。在我们的例子中，对于`Rooms`实体，我们可能要求客厅。为了能够识别这样的表述，我们可以定义一个特征列表。这是一个以逗号分隔的列表，可以包含一些或所有预期的短语。
- en: 'Let''s add one for our application. On the left-hand side, at the bottom of
    the pane, you will see **Features**. Select this and click on **Add phrase list**
    to create a new list. Call it `Rooms` and add the different rooms that you would
    expect to find in a house, as shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的应用程序添加一个。在左侧，面板底部，您将看到**Features**（功能）。选择此选项，然后点击**Add phrase list**（添加短语列表）来创建一个新的列表。将其命名为`Rooms`，并添加您预期在房屋中找到的不同房间，如下面的截图所示：
- en: '![Recognizing key data using entities](img/B12373_04_05.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![使用实体识别关键数据](img/B12373_04_05.jpg)'
- en: By clicking on **Recommend** on the right-hand side, LUIS will recommend more
    values related to the ones you have already entered.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击右侧的**Recommend**（推荐），LUIS将推荐与您已输入的相关更多值。
- en: We will see how this is utilized later.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后看到这是如何被利用的。
- en: In addition to creating phrase lists, we can create **pattern features**. The
    typical use case of using pattern features is when you have data that matches
    patterns but it is not feasible to enter them as a phrase list. Pattern features
    are typically used with product numbers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建短语列表，我们还可以创建**模式特征**。使用模式特征的典型用例是当您有符合模式的数据，但无法将其作为短语列表输入时。模式特征通常与产品编号一起使用。
- en: Understanding what the user wants using intents
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用意图理解用户的需求
- en: Now that we have defined an entity, it is time to see how it fits in with intents.
    An **intent** is basically the purpose of a sentence.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个实体，是时候看看它是如何与意图相匹配的了。**意图**基本上是句子的目的。
- en: 'We can add intents to our application by selecting the **Intents** option in
    the left-hand pane. Click on **Add intent**. When we add an intent, we give it
    a name. The name should be descriptive of what the intent is. We want to add an
    intent named `GetRoomTemperature`, where the goal is to get the temperature of
    a given room, as shown in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在左侧面板中选择**Intents**（意图）选项来向我们的应用程序添加意图。点击**Add intent**（添加意图）。当我们添加意图时，我们给它一个名字。名字应该描述意图的内容。我们想要添加一个名为`GetRoomTemperature`的意图，其目的是获取特定房间的温度，如下面的截图所示：
- en: '![Understanding what the user wants using intents](img/B12373_04_06.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图理解用户的需求](img/B12373_04_06.jpg)'
- en: When you click on the **Save** button, you will be taken to the utterance page.
    Here, we can add sentences that we can use for the intent, so let's add one. Enter
    `what is the temperature in the kitchen?` and press *Enter*. The sentence (or
    utterance, as it is called) will be ready for labeling. Labeling an utterance
    means that we define what intent it belongs to. We should also make sure that
    we mark entities with the correct type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击**Save**（保存）按钮时，您将被带到语句页面。在这里，我们可以添加用于意图的句子，所以让我们添加一个。输入`厨房的温度是多少？`然后按*Enter*。这个句子（或称为语句）将准备好进行标记。标记语句意味着我们定义它属于哪个意图。我们还应该确保用正确的类型标记实体。
- en: 'The following screenshot shows the labeling process for our first utterance:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的第一个语句的标记过程：
- en: '![Understanding what the user wants using intents](img/B12373_04_07.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图理解用户的需求](img/B12373_04_07.jpg)'
- en: As you can see, the entity is marked. You can tell LUIS that a word is a given
    entity by clicking on the word. This will pop up a menu containing all the available
    entities, and you can then select the correct one. Also, note how the **GetRoomTemperature**
    intent is selected in the drop-down list. Click **Train** once you are done labeling
    your utterances.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，实体已被标记。您可以通过点击单词来告诉LUIS一个单词是特定的实体。这将弹出一个包含所有可用实体的菜单，然后您可以从中选择正确的一个。同时，注意在下拉列表中如何选择**GetRoomTemperature**意图。完成标记您的语句后，点击**Train**。
- en: All applications are created with a default intent called **None**. This intent
    will encompass sentences that do not belong to our application at all. If we were
    to say *Order a large pizza with mushrooms and pepperoni*, this would end up with
    **None** as the intent.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序都是使用默认的意图**None**创建的。这个意图将包括不属于我们应用程序的句子。如果我们说要**订购一个带蘑菇和意大利辣肠的大披萨**，这将导致意图为**None**。
- en: When you are creating intents, you should define at least three to five utterances.
    This will give LUIS something to work with, and, as such, it can create better
    models. We will see how we can improve performance later in this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建意图时，你应该定义至少三到五个话语。这将给LUIS一些可以工作的事情，因此它可以创建更好的模型。我们将在本章后面看到我们如何提高性能。
- en: Simplifying development using prebuilt models
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用预构建模型简化开发
- en: Building entities and intents can be easy or it can be intricate. Fortunately,
    LUIS provides a set of prebuilt entities that stem from Bing. These entities will
    be included in the applications, as well as on the web, while going through the
    labeling process.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 构建实体和意图可以是简单的，也可以是复杂的。幸运的是，LUIS提供了一套来自Bing的预构建实体。这些实体将包含在应用程序中，以及在网上，在经过标签化过程时。
- en: 'The following table describes all the available prebuilt entities:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了所有可用的预构建实体：
- en: '| Entity | Example |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 实体 | 示例 |'
- en: '| --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `builtin.number` | Five, 23.21 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `builtin.number` | 五，23.21 |'
- en: '| `builtin.ordinal` | Second, 3rd |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `builtin.ordinal` | 第二，第三 |'
- en: '| `builtin.temperature` | 2 degrees Celsius, 104 F |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `builtin.temperature` | 2摄氏度，104华氏度 |'
- en: '| `builtin.dimension` | 231 square kilometers |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `builtin.dimension` | 231平方公里 |'
- en: '| `builtin.age` | 27 years old |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `builtin.age` | 27岁 |'
- en: '| `builtin.geography` | City, country, point of interest |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `builtin.geography` | 城市，国家，兴趣点 |'
- en: '| `builtin.encyclopedia` | Person, organization, event, TV episode, product,
    film, and so on |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `builtin.encyclopedia` | 人物，组织，事件，电视剧集，产品，电影等 |'
- en: '| `builtin.datetime` | Date, time, duration, set |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `builtin.datetime` | 日期，时间，持续时间，设置 |'
- en: The last three have several subentities, as described in the **Example** column
    of the table.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个有多个子实体，如表格中**示例**列所述。
- en: We are going to add one of these prebuilt entities, so select **Entities** in
    the menu. Click on **Add prebuilt entity**, select **temperature** from the list,
    and click on **Save**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加这些预构建实体中的一个，因此请从菜单中选择**实体**。点击**添加预构建实体**，从列表中选择**温度**，然后点击**保存**。
- en: 'With the newly created entity, we want to add a new intent called **SetTemperature**.
    If the example utterance is *Set the temperature in the kitchen to 22 degrees
    Celsius,* we can label the utterance as shown in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新创建的实体，我们想要添加一个名为**SetTemperature**的新意图。如果示例话语是*将厨房的温度设置为22摄氏度*，我们可以如以下截图所示标注话语。
- en: '![Simplifying development using prebuilt models](img/B12373_04_08.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![使用预构建模型简化开发](img/B12373_04_08.jpg)'
- en: As you can see, we have a `room` entity. We also have the prebuilt `temperature`
    entity clearly labeled. As the correct intent should be selected in the drop-down
    menu, we can click on the **Train** button to save the utterance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个`room`实体。我们还有一个清晰标注的预构建`temperature`实体。由于正确的意图应该在下拉菜单中选择，我们可以点击**训练**按钮来保存话语。
- en: Prebuilt domains
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预构建域
- en: In addition to using prebuilt entities, we can use prebuilt domains. These are
    entities and intents that already exist, leveraging commonly used intents and
    entities from different domains. By using these intents and entities, you can
    use models that you would typically use in Windows. A very basic example is setting
    up appointments in the calendar.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用预构建实体外，我们还可以使用预构建域。这些是已经存在的实体和意图，利用了来自不同域的常用意图和实体。通过使用这些意图和实体，你可以使用通常在Windows中使用的模型。一个非常基本的例子是在日历中设置约会。
- en: 'To use Cortana''s prebuilt domain, you can select **Prebuilt domains** from
    the left-hand menu. This will open a list of available domains. By clicking **Add
    domain**, you can add the selected domain, as shown in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Cortana的预构建域，你可以从左侧菜单中选择**预构建域**。这将打开一个可用域的列表。通过点击**添加域**，你可以添加选定的域，如以下截图所示：
- en: '![Prebuilt domains](img/B12373_04_09.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![预构建域](img/B12373_04_09.jpg)'
- en: 'This will add the intents and entities for that specific domain to the list
    of intents and entities that is already defined, as shown in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加该特定域的意图和实体到已定义的意图和实体列表中，如以下截图所示：
- en: '![Prebuilt domains](img/B12373_04_10.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![预构建域](img/B12373_04_10.jpg)'
- en: 'The following list shows the top-level domains that are available with Cortana''s
    prebuilt domains. For a complete list of the available prebuilt domains, please
    refer to [Appendix A](apa.html "Appendix A. LUIS Entities"), *LUIS Entities*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了Cortana预构建域中可用的顶级域。有关可用的预构建域的完整列表，请参阅[附录A](apa.html "附录A. LUIS实体")，*LUIS实体*：
- en: '`Calendar`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`日历`'
- en: '`Camera`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`相机`'
- en: '`Communication`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`通信`'
- en: '`Entertainment`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`娱乐`'
- en: '`Events`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`事件`'
- en: '`Fitness`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`健身`'
- en: '`Gaming`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`游戏`'
- en: '`HomeAutomation`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`智能家居自动化`'
- en: '`MovieTickets`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`电影票`'
- en: '`Music`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`音乐`'
- en: '`Note`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`备注`'
- en: '`OnDevice`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`设备端`'
- en: '`Places`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`地点`'
- en: '`Reminder`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`提醒`'
- en: '`RestaurantReservation`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`餐厅预订`'
- en: '`Taxi`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`出租车`'
- en: '`Translate`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`翻译`'
- en: '`Utilities`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`公用事业`'
- en: '`Weather`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`天气`'
- en: '`Web`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`网络`'
- en: Training a model
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练模型
- en: Now that we have a working model, it is time to put it into action.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作的模型，是时候将其投入使用了。
- en: Training and publishing the model
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 训练和发布模型
- en: The first step to using the model is to make sure that the model has some utterances
    to work with. Until now, we have added one utterance per intent. Before we deploy
    the application, we need more.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该模型的第一步是确保模型有一些话语可以处理。到目前为止，我们为每个意图添加了一个话语。在我们部署应用程序之前，我们需要更多。
- en: Think of three to four different ways to set or get the room temperature and
    add them, specifying the entities and intents. Also, add a couple of utterances
    that fall into the `None` intent, just for reference.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 想想三种或四种设置或获取房间温度的不同方法，并将它们添加进去，指定实体和意图。此外，添加一些属于`None`意图的话语，仅作参考。
- en: When we have added some new utterances, we need to train the model. Doing so
    will make LUIS develop code to recognize the relevant entities and intents in
    the future. This process is done periodically; however, it is wise to do it whenever
    you have made changes, before publication. This can be done by clicking **Train**
    in the top menu.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加了一些新的话语后，我们需要训练模型。这样做将使LUIS开发代码来识别未来的相关实体和意图。这个过程是定期进行的；然而，在发布之前，在您做出更改时进行此操作是明智的。这可以通过在顶部菜单中点击**训练**来完成。
- en: 'To test the application, you can simply enter test sentences in the **Interactive
    Testing** tab. This will show you how any given sentence is labeled, and what
    intents the service has discovered, as shown in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试应用程序，您可以在**交互式测试**选项卡中简单地输入测试句子。这将显示任何给定句子是如何被标记的，以及服务发现了哪些意图，如下面的截图所示：
- en: '![Training and publishing the model](img/B12373_04_11.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![训练和发布模型](img/B12373_04_11.jpg)'
- en: With the training completed, we can publish the application. This will deploy
    the models to an HTTP endpoint, which will interpret the sentences that we send
    to it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 训练完成后，我们可以发布应用程序。这将部署模型到HTTP端点，该端点将解释我们发送给它的句子。
- en: 'Select **Publish** from the left-hand menu. This will present you with the
    following screen:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从左侧菜单中选择**发布**。这将显示以下屏幕：
- en: '![Training and publishing the model](img/B12373_04_12.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![训练和发布模型](img/B12373_04_12.jpg)'
- en: Click on the **Publish** button to deploy the application. The URL beneath the
    **Endpoint** **url settings** field is the endpoint where the model is deployed.
    As you can see, it specifies the application ID, as well as the subscription key.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**发布**按钮来部署应用程序。**端点** **URL设置**字段下的URL是模型部署的端点。如您所见，它指定了应用程序ID以及订阅密钥。
- en: 'Before we go any further, we can verify that the endpoint actually works. You
    can do this by entering a query into the text field (for instance, `get the bedroom
    temperature`) and clicking on the link. This should present you with something
    similar to the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，我们可以验证端点是否实际工作。您可以通过在文本字段中输入一个查询（例如，`获取卧室温度`）并点击链接来完成此操作。这应该会向您展示以下类似截图的内容：
- en: '![Training and publishing the model](img/B12373_04_13.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![训练和发布模型](img/B12373_04_13.jpg)'
- en: When the model has been published, we can move on to access it through the code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型发布后，我们可以继续通过代码访问它。
- en: Connecting to the smart house application
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到智能家居应用程序
- en: To be able to easily work with LUIS, we will want to add the NuGet client package.
    In the smart house application, go to the NuGet package manager and find the `Microsoft.Cognitive.LUIS`
    package. Install this into the project.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够轻松地与LUIS一起工作，我们将想要添加NuGet客户端包。在智能家居应用程序中，转到NuGet包管理器并找到`Microsoft.Cognitive.LUIS`包。将此包安装到项目中。
- en: We will need to add a new class called `Luis`. Place the file under the `Model`
    folder. This class will be in charge of calling the endpoint and processing the
    result.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个名为`Luis`的新类。将文件放在`Model`文件夹下。这个类将负责调用端点并处理结果。
- en: As we will need to test this class, we will need to add a `View` and a `ViewModel`.
    Add the file `LuisView.xaml` to the `View` folder, and add `LuisViewModel.cs`
    to the `ViewModel` folder.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要测试这个类，我们需要添加一个`View`和一个`ViewModel`。将`LuisView.xaml`文件添加到`View`文件夹中，并将`LuisViewModel.cs`添加到`ViewModel`文件夹中。
- en: The `View` should be rather simple. It should contain two `TextBox` elements,
    one for inputting requests and the other for displaying results. We also need
    a button to execute commands.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`View`应该相当简单。它应该包含两个`TextBox`元素，一个用于输入请求，另一个用于显示结果。我们还需要一个按钮来执行命令。'
- en: Add the `View` as a `TabItem` in the `MainView.xaml` file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将`View`作为`TabItem`添加到`MainView.xaml`文件中。
- en: The `ViewModel` should have two `string` properties, one for each of the `TextBox`
    elements. It will also need an `ICommand` property for the `button` command.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel`应该有两个`string`属性，分别对应于两个`TextBox`元素。它还需要一个`ICommand`属性用于按钮命令。'
- en: We will create the `Luis` class first, so open the `Luis.cs` file. Make the
    class `public`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建`Luis`类，因此打开`Luis.cs`文件。将类设置为`public`。
- en: 'When we have made requests and received the corresponding result, we want to
    trigger an event to notify the UI. We want some additional arguments with this
    event, so, below the `Luis` class, create a `LuisUtteranceResultEventArgs` class
    that inherits from the `EventArgs` class, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发出请求并收到相应的结果时，我们希望触发一个事件来通知UI。我们希望这个事件带有一些额外的参数，因此，在`Luis`类下面创建一个名为`LuisUtteranceResultEventArgs`的类，该类继承自`EventArgs`类，如下所示：
- en: '[PRE0]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will contain a `Status` string, a `Message` status, and the `Result` itself.
    Go back to the `Luis` class and add an event and a private member, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包含一个`Status`字符串，一个`Message`状态，以及`Result`本身。回到`Luis`类，添加一个事件和一个私有成员，如下所示：
- en: '[PRE1]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have already discussed the event. The private member is the API access object,
    which we installed from NuGet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了事件。私有成员是API访问对象，我们从NuGet安装了它：
- en: '[PRE2]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The constructor should accept the `LuisClient` object as a parameter and assign
    it to the member we previously created.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数应接受`LuisClient`对象作为参数，并将其分配给之前创建的成员。
- en: 'Let''s create a helper method to raise the `OnLuisUtteranceResultUpdated` event,
    as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个辅助方法来触发`OnLuisUtteranceResultUpdated`事件，如下所示：
- en: '[PRE3]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is purely for our own convenience.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这纯粹是为了我们自己的方便。
- en: 'To be able to make requests, we will create a function called `RequestAsync`.
    This will accept a `string` as a parameter and have `Task` as the return type.
    The function should be marked as `async`, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够发出请求，我们将创建一个名为`RequestAsync`的函数。这个函数将接受一个`string`作为参数，并返回`Task`类型。该函数应标记为`async`，如下所示：
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Inside the function, we make a call to the `Predict` function of `_luisClient`.
    This will send a query to the endpoint we published earlier. A successful request
    will result in a `LuisResult` object that contains some data, which we will explore
    shortly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们调用`_luisClient`的`Predict`函数。这将向之前发布的端点发送查询。成功的请求将导致一个包含一些数据的`LuisResult`对象，我们将在稍后探讨。
- en: 'We use the result in a new function, where we process it. We make sure that
    we catch any exceptions and notify any listeners about it using the following
    code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个新函数中使用结果并处理它。我们确保捕获任何异常，并使用以下代码通知任何监听者：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `ProcessResult` function, we create a new object of the `LuisUtteranceResultEventArgs`
    type. This will be used when notifying listeners of any results. In this argument
    object, we add the `Succeeded` status and the `result` object. We also write out
    a message, stating the top identified intent. We also add the likelihood of this
    intent being the top one out of all the intents we have. Finally, we also add
    the number of intents identified:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ProcessResult`函数中，我们创建一个`LuisUtteranceResultEventArgs`类型的新对象。当通知监听者任何结果时将使用此对象。在这个参数对象中，我们添加`Succeeded`状态和`result`对象。我们还输出一个消息，说明顶级识别的意图。我们还添加了这个意图是所有意图中顶级意图的可能性。最后，我们还添加了识别到的意图数量：
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With that in place, we head to our view model. Open the `LuisViewModel.cs` file.
    Make sure that the class is `public` and that it inherits from the `ObservableObject`
    class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们转向我们的视图模型。打开`LuisViewModel.cs`文件。确保类是`public`的，并且继承自`ObservableObject`类。
- en: 'Declare a private member, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个私有成员，如下所示：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will hold the `Luis` object we created earlier:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将保存我们之前创建的`Luis`对象：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our constructor creates the `Luis` object, making sure it is initialized with
    a new `LuisClient`. As you may have noticed, this requires two parameters, the
    application ID and the subscription ID. There is also a third parameter, `preview`,
    but we will not need to set it at this time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造函数创建`Luis`对象，确保它使用一个新的`LuisClient`初始化。如您所注意到的，这需要两个参数，应用程序ID和订阅ID。还有一个第三个参数，`preview`，但在此我们不需要设置它。
- en: 'The application ID can be found either by looking at the URL in the publishing
    step or by going to **Settings** on the application''s site at [https://www.luis.ai](https://www.luis.ai).
    There, you will find the **Application ID**, as shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序 ID 可以通过查看发布步骤中的 URL 或访问应用程序网站上的 **设置** 来找到 [https://www.luis.ai](https://www.luis.ai)。在那里，您将找到
    **应用程序 ID**，如下面的截图所示：
- en: '![Connecting to the smart house application](img/B12373_04_14.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![连接到智能家居应用](img/B12373_04_14.jpg)'
- en: 'With the `Luis` object created, we complete the constructor as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了 `Luis` 对象后，我们按如下方式完成构造函数：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will hook up the `OnLuisUtteranceResultUpdated` event and create a new
    `DelegateCommand` event for our button. For our command to be able to run, we
    need to check that we have written some text in the input field. This is done
    using `CanExecuteUtterance`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这将连接 `OnLuisUtteranceResultUpdated` 事件并为我们的按钮创建一个新的 `DelegateCommand` 事件。为了使我们的命令能够运行，我们需要检查我们是否在输入字段中输入了一些文本。这是使用
    `CanExecuteUtterance` 完成的。
- en: 'The `ExecuteUtterance` command is itself rather simple, as shown in the following
    code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecuteUtterance` 命令本身相当简单，如下面的代码所示：'
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All we do is make a call to the `RequestAsync` function in the `_luis` object.
    We do not need to wait for any results, as these will be coming from the event.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的一切只是调用 `_luis` 对象中的 `RequestAsync` 函数。我们不需要等待任何结果，因为这些结果将来自事件。
- en: The event handler, `OnLuisUtteranceResultUpdated`, will format the results and
    print them to the screen.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序 `OnLuisUtteranceResultUpdated` 将格式化结果并将它们打印到屏幕上。
- en: 'First, we make sure that we invoke the methods in the current dispatcher thread.
    This is done as the event is triggered in another thread. We create a `StringBuilder`,
    which will be used to concatenate all the results, as shown in the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确保在当前调度线程中调用方法。这是在另一个线程中触发事件时完成的。我们创建一个 `StringBuilder`，它将用于连接所有结果，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'First, we append the `Status` and the `Message` status. We then check to see
    if we have any entities that were detected and append the number of entities,
    as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加 `Status` 和 `Message` 状态。然后我们检查是否有检测到的实体，并添加实体数量，如下所示：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we do have any entities, we loop through each of them, printing out the
    entity name and the value:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有任何实体，我们将遍历每个实体，打印出实体名称和值：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we add `StringBuilder` to our `ResultText` string, which should display
    it on screen, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `StringBuilder` 添加到我们的 `ResultText` 字符串中，它应该在屏幕上显示，如下所示：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With everything having compiled, the result should look something like the
    following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一切编译完成后，结果应该看起来像下面的截图：
- en: '![Connecting to the smart house application](img/B12373_04_15.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![连接到智能家居应用](img/B12373_04_15.jpg)'
- en: Model improvement through active usage
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过积极使用来改进模型
- en: LUIS is a machine learning service. The applications we create, and the models
    that are generated, can therefore improve based on use. Throughout the development,
    it is a good idea to keep an eye on the performance. You may notice some intents
    that are often mislabeled, or entities that are hard to recognize.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: LUIS 是一个机器学习服务。因此，我们创建的应用程序和生成的模型可以根据使用情况进行改进。在整个开发过程中，关注性能是一个好主意。您可能会注意到一些经常被错误标记的意图，或者难以识别的实体。
- en: Visualizing performance
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可视化性能
- en: On the LUIS website, the dashboard displays information about intent and entity
    breakdowns. This is basically information on how the intents and entities are
    distributed across the utterances that have been used.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LUIS 网站上，仪表板显示有关意图和实体分解的信息。这基本上是关于意图和实体如何在已使用的语句中分布的信息。
- en: 'The following diagram shows what the intent breakdown display looks like:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了意图分解显示的外观：
- en: '![Visualizing performance](img/B12373_04_16.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![可视化性能](img/B12373_04_16.jpg)'
- en: 'The following diagram shows what the entity breakdown looks like:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了实体分解的外观：
- en: '![Visualizing performance](img/B12373_04_17.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![可视化性能](img/B12373_04_17.jpg)'
- en: By hovering the mouse over the different bars (or sectors of the pie chart),
    the name of the intent/entity will be displayed. In addition, the percentage number
    of the total number of intents/entities in use is displayed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将鼠标悬停在不同的条形图（或饼图的扇区）上，将显示意图/实体的名称。此外，还会显示使用中意图/实体的总数百分比。
- en: Resolving performance problems
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决性能问题
- en: 'If you notice an error in your applications, there are typically four options
    to resolve it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在应用程序中注意到错误，通常有四种选项可以解决它：
- en: Adding model features
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加模型功能
- en: Adding labeled utterances
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加标记的语句
- en: Looking for incorrect utterance labels
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找错误的语句标签
- en: Changing the schema
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改模式
- en: We will now look briefly at each of these.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将简要地看一下这些中的每一个。
- en: Adding model features
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加模型功能
- en: Adding model features is typically something we can do if we have phrases that
    should be detected as entities, but are not. We have already seen an example of
    this with the room entity, where one room could be the living room.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 添加模型功能通常是我们可以做到的，如果我们有应该被检测为实体的短语，但还没有。我们已经看到了一个例子，那就是房间实体，其中一个房间可能是客厅。
- en: 'The solution is, of course, to add phrase lists or regex features. There are
    three scenarios where this will likely help:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案当然是添加短语列表或正则表达式功能。有三种情况这可能会有所帮助：
- en: When LUIS fails to see words or phrases that are similar.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当LUIS无法识别相似的字词或短语时。
- en: When LUIS has trouble identifying entities. Adding all possible entity values
    in a phrase list should help.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当LUIS在识别实体时遇到困难时，将短语列表中所有可能的实体值添加进去应该会有所帮助。
- en: When rare or proprietary words are used.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用稀有或专有词汇时。
- en: Adding labeled utterances
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加标记的语句
- en: 'Adding and labeling more utterances will always improve performance. This will
    most likely help in the following scenarios:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和标记更多语句将始终提高性能。这很可能有助于以下场景：
- en: When LUIS fails to differentiate between two intents
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当LUIS无法区分两个意图时
- en: When LUIS fails to detect entities between surrounding words
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当LUIS无法检测到周围词汇之间的实体时
- en: If LUIS systematically assigns low scores to an intent
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果LUIS系统性地给一个意图分配了很低的分数
- en: Looking for incorrect utterance labels
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 寻找错误的语句标签
- en: 'A common mistake is mislabeling an utterance or entity. In such cases, you
    will need to find the incorrect utterance and correct it. This will likely resolve
    problems in the following scenarios:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是错误地标记语句或实体。在这种情况下，您需要找到错误的语句并更正它。这可能会解决以下场景中的问题：
- en: If LUIS fails to differentiate between two intents, even when similar utterances
    have been labeled
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果LUIS无法区分两个意图，即使相似的语句已经被标记
- en: If LUIS consistently misses an entity
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果LUIS持续地错过一个实体
- en: Changing the schema
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改模式
- en: If all the preceding solutions fail and you still have problems with the model,
    you may consider changing the schema, meaning combining, regrouping, and/or dropping
    intents and entities.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有前面的解决方案都失败了，您仍然有模型问题，您可能需要考虑更改模式，这意味着合并、重新分组和/或删除意图和实体。
- en: Keep in mind that if it is hard for humans to label an utterance, it is even
    harder for a machine.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果对人类来说标记语句很困难，那么对机器来说就更加困难了。
- en: Active learning
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主动学习
- en: A very nice feature of LUIS is the power of active learning. When we are using
    the service actively, it will log all queries, and, as such, we will then be able
    to analyze usage. Doing so allows us to quickly correct errors and label utterances
    we have not seen before.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: LUIS的一个非常不错的功能是主动学习的力量。当我们积极使用这项服务时，它会记录所有查询，因此我们可以分析使用情况。这样做可以让我们快速纠正错误，并标记我们之前没有见过的语句。
- en: 'Using the application we have built—the smart house application—if we run a
    query with the utterance `can you tell me the bedroom temperature?`, the model
    will likely not recognize this. If we debug the process, stepping through the
    `ProcessResult` function, we will see the following values returned:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们构建的应用程序——智能家庭应用程序——如果我们用语句`你能告诉我卧室的温度吗？`进行查询，模型可能不会识别这一点。如果我们调试这个过程，逐步通过`ProcessResult`函数，我们将看到以下返回值：
- en: '![Active learning](img/B12373_04_18.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![主动学习](img/B12373_04_18.jpg)'
- en: As you can see from the preceding screenshot, the top-scoring intent is `None`,
    with a score of `0.61`. In addition, no entities have been recognized, so this
    is not good.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的截图中所见，得分最高的意图是`None`，得分为`0.61`。此外，没有识别出任何实体，所以这并不好。
- en: 'Head back to the LUIS website. Move to the **Review endpoint utterances** page,
    which can be found in the left-hand menu. Here, we can see that the utterance
    we just tried has been added. We can now label the intent and entity correctly,
    as shown in the following screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 返回LUIS网站。转到**审查端点语句**页面，该页面可以在左侧菜单中找到。在这里，我们可以看到我们刚刚尝试的语句已经被添加。现在我们可以正确地标记意图和实体，如下面的截图所示：
- en: '![Active learning](img/B12373_04_19.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![主动学习](img/B12373_04_19.jpg)'
- en: 'By labeling the utterance with the correct intent and entity, we will get a
    correct result the next time we query in this way, as you can see in the following
    screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将话语正确地标记为意图和实体，我们将在下次以这种方式查询时得到正确的结果，如下面的截图所示：
- en: '![Active learning](img/B12373_04_20.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![主动学习](img/B12373_04_20.jpg)'
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a LUIS application. You learned how to create language-understanding
    models, which can recognize entities in sentences. You learned how to understand
    the user's intent and how we can trigger actions from this. An important step
    was to see how to improve the model in various ways.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个LUIS应用程序。你学习了如何创建语言理解模型，这些模型可以识别句子中的实体。你学习了如何理解用户的意图以及我们如何从这个意图中触发动作。一个重要的步骤是了解如何以各种方式改进模型。
- en: In the next chapter, we will utilize what you have learned here, using LUIS
    with speech APIs, giving us the ability to speak to our application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用在这里学到的知识，使用LUIS和语音API，使我们能够与应用程序进行语音交互。
