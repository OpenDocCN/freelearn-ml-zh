- en: Vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Indexing and naming vectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most important operations we can do on vectors involves subsetting
    and indexing vectors to access specific elements which are often useful when we
    want to run some code only on specific data points. The following examples show
    some ways in which we can index and subset vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we look at how we can name vectors. This is basically a nifty feature in
    R where you can label each element in a vector to make it more readable or easy
    to interpret. There are two ways this can be done, which are shown in the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Indexing and naming vectors](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Indexing and naming vectors](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Indexing and naming vectors](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Thus, you can see, it becomes really useful to annotate and name vectors sometimes,
    and we can also subset and slice vectors using element names rather than values.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vectors are one dimensional data structures, which means that they just have
    one dimension and we can get the number of elements they have using the `length`
    property. Do remember that arrays may also have a similar meaning in other programming
    languages, but in R they have a slightly different meaning. Basically, arrays
    in R are data structures which hold the data having multiple dimensions. Matrices
    are just a special case of generic arrays having two dimensions, namely represented
    by properties `rows` and `columns`. Let us look at some examples in the following
    code snippets in the accompanying subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Creating arrays and matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we will create an array that has three dimensions. Now it is easy to
    represent two dimensions in your screen, but to go one dimension higher, there
    are special ways in which R transforms the data. The following example shows how
    R fills the data (column first) in each dimension and shows the final output for
    a 4x3x3 array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating arrays and matrices](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Like I mentioned earlier, a matrix is just a special case of an array. We can
    create a matrix using the `matrix` function, shown in detail in the following
    example. Do note that we use the parameter `byrow` to fill the data row-wise in
    the matrix instead of R's default column-wise fill in any array or matrix. The
    `ncol` and `nrow` parameters stand for number of columns and rows respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating arrays and matrices](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Names and dimensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like we named vectors and accessed element names, will perform similar
    operations in the following code snippets. You have already seen the use of the
    `dimnames` parameter in the preceding examples. Let us look at some more examples
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Names and dimensions](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Names and dimensions](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Names and dimensions](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To access details of dimensions related to arrays and matrices, there are special
    functions. The following examples show the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Matrix operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A lot of machine learning and optimization algorithms deal with matrices as
    their input data. In the following section, we will look at some examples of the
    most common operations on matrices.
  prefs: []
  type: TYPE_NORMAL
- en: We start by initializing two matrices and then look at ways of combining the
    two matrices using functions such as `c` which returns a vector, `rbind` which
    combines the matrices by `rows,` and `cbind` which does the same by columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matrix operations](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matrix operations](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matrix operations](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matrix operations](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matrix operations](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we look at some of the important arithmetic operations which can be performed
    on matrices. Most of them are quite self-explanatory from the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matrix operations](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matrix operations](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matrix operations](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matrix operations](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matrix operations](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matrix operations](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matrix operations](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding arithmetic operations are just some of the most popular ones amongst
    the vast number of functions and operators which can be applied to matrices. This
    becomes useful, especially in areas such as linear optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists are a special case of vectors where each element in the vector can be
    of a different type of data structure or even simple data types. It is similar
    to the lists in the Python programming language in some aspects, if you have used
    it before, where the lists indicate elements which can be of different types and
    each have a specific index in the list. In R, each element of a list can be as
    simple as a single element or as complex as a whole matrix, a function, or even
    a vector of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and indexing lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will get started with looking at some common methods to create and initialize
    lists in the following examples. Besides that, we will also look at how we can
    access some of these list elements for further computations. Do remember that
    each element in a list can be a simple primitive data type or even complex data
    structures or functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and indexing lists](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and indexing lists](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the preceding examples how easy it is to access any element
    of the list and use it for further computations, such as the `cos` function.
  prefs: []
  type: TYPE_NORMAL
- en: Combining and converting lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we will take a look at how to combine several lists together into one single
    list in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining and converting lists](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is very easy to convert lists in to vectors and vice versa. The following
    examples show some common ways we can achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining and converting lists](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Data frames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data frames are special data structures which are typically used for storing
    data tables or data in the form of spreadsheets, where each column indicates a
    specific attribute or field and the rows consist of specific values for those
    columns. This data structure is extremely useful in working with datasets which
    usually have a lot of fields and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating data frames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create data frames easily using the `data.frame` function. We will look
    at some following examples to illustrate the same with some popular superheroes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating data frames](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating data frames](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating data frames](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `str` function talks in detail about the structure of the data frame where
    we see details about the data present in each column of the data frame. There
    are a lot of datasets readily available in R base which you can directly load
    and start using. One of them is shown next. The `mtcars` dataset has information
    about various automobiles, which was extracted from the *Motor Trend U.S. Magazine*
    of 1974.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating data frames](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Operating on data frames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a lot of operations we can do on data frames, such as merging, combining,
    slicing, and transposing data frames. We will look at some of the important data
    frame operations in the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: It is really easy to index and subset specific data inside data frames using
    simplex indexes and functions such as `subset`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Operating on data frames](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Operating on data frames](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Operating on data frames](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Operating on data frames](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will now look at some more complex operations, such as combining and merging
    data frames.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Operating on data frames](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Operating on data frames](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Operating on data frames](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Operating on data frames](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding operations it is evident that `rbind` and `cbind` work in
    the same way as we saw previously with arrays and matrices. However, merge lets
    you merge the data frames in the same way as you join various tables in relational
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: Working with functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next up, we will be looking at functions, which is a technique or methodology
    to easily structure and modularize your code, specifically lines of code which
    perform specific tasks, so that you can execute them whenever you need them without
    writing them again and again. In R, functions are basically treated as just another
    data type and you can assign functions, manipulate them as and when needed, and
    also pass them as arguments to other functions. We will be exploring all this
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'R consists of several functions which are available in the R-base package and,
    as you install more packages, you get more functionality, which is made available
    in the form of functions. We will look at a few built-in functions in the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the preceding examples that functions such as `mean`, `median,`
    and `sqrt` are built-in and can be used anytime when you start R, without loading
    any other packages or defining the functions explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The real power lies in the ability to define your own functions based on different
    operations and computations you want to perform on the data and making R execute
    those functions just in the way you intend them to work. Some illustrations are
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Passing functions as arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you define any function, you can also pass other functions to it as arguments
    if you intend to use them inside your function to perform some complex computations.
    This reduces the complexity and redundancy of the code. The following example
    computes the Euclidean distance between two points using the `square` function
    defined earlier, which is passed as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Thus, you can see that with functions you can define a specific function once
    and execute it as many times as you need.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling code flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers areas related to controlling the execution of your code.
    Using specific constructs such as `if-else` and `switch`, you can execute code
    conditionally. Constructs like `for`, `while`, and `repeat`, and `help` in executing
    the same code multiple times which is also known as looping. We will be exploring
    all these constructs in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with if, if-else, and ifelse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several constructs which help us in executing code conditionally.
    This is especially useful when we don''t want to execute a bunch of statements
    one after the other sequentially but execute the code only when it meets or does
    not meet specific conditions. The following examples illustrate the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Working with switch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `switch` function is especially useful when you have to match an expression
    or argument to several conditions and execute only if there is a specific match.
    This becomes extremely messy when implemented with the `if-else` constructs but
    is much more elegant with the `switch` function, as we will see next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Loops are an excellent way to execute code segments repeatedly when needed.
    Vectorization constructs are, however, more optimized than loops for working on
    larger data sets, but we will see that later in this chapter. For now, you should
    remember that there are three types of loops in R, namely, `for`, `while`, and
    `repeat`. We will look at all of them in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Advanced constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We heard the term **vectorized** earlier when we talked about operating on
    vectors without using loops. While looping is a great way to iterate through vectors
    and perform computations, it is not very efficient when we deal with what is known
    as **Big Data**. In this case, R provides some advanced constructs which we will
    be looking at in this section. We will be covering the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lapply`: Loops over a list and evaluates a function on each element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sapply`: A simplified version of lapply'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apply`: Evaluates a function on the boundaries or margins of an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tapply`: Evaluates a function over subsets of a vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapply`: A multivariate version of lapply'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lapply and sapply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like we mentioned earlier, `lapply` takes a list and a function as input and
    evaluates that function over each element of the list. If the input list is not
    a list, it is converted into a list using the `as.list` function before the output
    is returned. It is much faster than a normal loop because the actual looping is
    done internally using C code. We look at its implementation and an example in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![lapply and sapply](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Coming to `sapply`, it is similar to `lapply` except that it tries to simplify
    the results wherever possible. For example, if the final result is such that every
    element is of length `1`, it returns a vector, if the length of every element
    in the result is the same but more than 1, a matrix is returned, and if it is
    not able to simplify the results, we get the same result as `lapply`. We illustrate
    the same with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![lapply and sapply](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![lapply and sapply](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![lapply and sapply](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: apply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `apply` function is used to evaluate a function over the margins or boundaries
    of an array; for instance, applying aggregate functions on the rows or columns
    of an array. The `rowSums`, `rowMeans`, `colSums,` and `colMeans` functions also
    use `apply` internally but are much more optimized and useful when operating on
    large arrays. We will see all the preceding constructs in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![apply](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![apply](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Thus you can see how easy it is to apply various statistical functions on matrices
    without using loops at all.
  prefs: []
  type: TYPE_NORMAL
- en: tapply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function `tapply` is used to evaluate a function over the subsets of any
    vector. This is similar to applying the `GROUP BY` construct in SQL if you are
    familiar with using relational databases. We illustrate the same in the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![tapply](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![tapply](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![tapply](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![tapply](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: mapply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `mapply` function is a multivariate version of `lapply` and is used to
    evaluate a function in parallel over sets of arguments. A simple example is if
    we have to build a list of vectors using the `rep` function, we have to write
    it multiple times. However, with `mapply` we can achieve the same in a more elegant
    way as illustrated next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![mapply](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![mapply](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next steps with R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into machine learning, it will be useful to pause for a moment,
    take a deep breath, and contemplate on what you have learnt so far. This quick
    yet detailed refresher of R will help you a lot in the upcoming chapters. However,
    there are two more things which we must go through quickly. They are how to get
    help in R and how to work with various packages in R.
  prefs: []
  type: TYPE_NORMAL
- en: Getting help
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, you must have figured out that there are thousands of functions and
    constructs in R and it is impossible to remember what each of them actually does
    and you don''t have to either! R provides many intuitive ways to get help regarding
    any function, package, or data structure. To start with, you can run the `help.start()`
    function at the `R` command prompt, which will start a manual browser. Here you
    will get detailed information regarding R which includes manuals, references,
    and other material. The following command shows the contents of `help.start()`
    as shown in the screenshot following the command, which you can use to navigate
    further and get more help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If nothing happens, you should open `http://127.0.0.1:31850/doc/html/index.html`
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting help](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To get help on any particular function or construct in R, if you know the function's
    name, you can get help using the help function or the `?` operator in combination
    with the function name. For example, if you want help regarding the `apply` function,
    just type `help("apply")` or `?apply` to get detailed information regarding the
    `apply` function. This easy mechanism for getting help in R increases your productivity
    and makes working with R a pleasant experience. Often, you won't quite remember
    the exact name of the function you intend to use but you might have a vague idea
    of what its name might be. R has a help feature for this purpose too, where you
    can use the `help.search` function or the `??` operator, in combination with the
    function name. For example, you can use `??apply` to get more information on the
    apply function.
  prefs: []
  type: TYPE_NORMAL
- en: Handling packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are thousands and thousands of packages containing a wide variety of capabilities
    available on **CRAN** (**Comprehensive R Archive Network**), which is a repository
    hosting all these packages. To download any package from CRAN, all you have to
    do is run the `install.packages` function passing the package name as a parameter,
    like `install.packages("caret")`. Once the package is downloaded and installed,
    you can load it into your current R session using the `library` function. To load
    the package `caret`, just type `library(caret)` and it should be readily available
    for use. The `require` function has similar functionality to load a specific package
    and is used specially inside functions in a similar way by typing `require(caret)`
    to load the `caret` package. The only difference between `require` and `library`
    is that, in case the specific package is not found, `library` will show an error
    but `require` will continue the execution of code without showing any error. However,
    if there is a dependency call to that package then your code will definitely throw
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have refreshed your memory about R, we will be talking about the
    basics of what machine learning is, how it is used today, and what are the main
    areas inside machine learning. This section intends to provide an overview into
    machine learning which will help in paving the way to the next chapter where we
    will be exploring it in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning – what does it really mean?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Machine learning does not have just one distinct textbook definition because
    it is a field which encompasses and borrows concepts and techniques from several
    other areas in computer science. It is also taught as an academic course in universities
    and has recently gained more prominence, with machine learning and data science
    being widely adopted online, in the form of educational videos, courses, and training.
    Machine learning is basically an intersection of elements from the fields of computer
    science, statistics, and mathematics, which uses concepts from artificial intelligence,
    pattern detection, optimization, and learning theory to develop algorithms and
    techniques which can learn from and make predictions on data without being explicitly
    programmed.
  prefs: []
  type: TYPE_NORMAL
- en: The learning here refers to the ability to make computers or machines intelligent
    based on the data and algorithms which we provide to them so that they start detecting
    patterns and insights from the provided data. This learning ensures that machines
    can detect patterns on data fed to it without explicitly programming them every
    time. The initial data or observations are fed to the machine and the machine
    learning algorithm works on that data to generate some output which can be a prediction,
    a hypothesis, or even some numerical result. Based on this output, there can be
    feedback mechanisms to our machine learning algorithm to improve our results.
    This whole system forms a machine learning model which can be used directly on
    completely new data or observations to get results from it without needing to
    write any separate algorithm again to work on that data.
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning – how is it used in the world?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might be wondering how on earth some algorithms or code can be used in
    the real world. It turns out they are used in a wide variety of use-cases in different
    verticals. Some examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Retail**: Machine learning is widely used in the retail and e-commerce vertical
    where each store wants to outperform its competitors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pricing analytics**: Machine learning algorithms are used to compare prices
    for items across various stores so that a store can sell the item at the most
    competitive price.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Market basket analysis**: They are used for analysis of customer shopping
    trends and recommendation of products to buy, which we will be covering in [Chapter
    3](part0026_split_000.html#OPEK1-973e731d75c2419489ee73e3a0cf4be8 "Chapter 3. Predicting
    Customer Shopping Trends with Market Basket Analysis"), *Predicting Customer Shopping
    Trends with Market Basket Analysis*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recommendation engines**: They are used to analyze customer purchases, ratings,
    and satisfaction to recommend products to various users. We will be building some
    recommendation systems of our own in [Chapter 4](part0032_split_000.html#UGI01-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 4. Building a Product Recommendation System"), *Building a Product Recommendation
    System*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advertising**: The advertising industry heavily relies on machine learning
    to promote and show the right advertisements to consumers for maximum conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web analytics**: Analyzes website traffic'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Churn analytics**: Predicts customer churn rate'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advertisement click-through prediction**: Used to predict how effective an
    advertisement would be to consumers such that they click on it to buy the relevant
    product'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Healthcare**: Machine learning algorithms are used widely in the healthcare
    vertical for more effective treatment of patients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disease detection and prediction**: Used to detect and predict chances of
    a disease based on the patient''s medical history.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Studying complex structures such as the human brain and DNA to understand the
    human body's functionality better for more effective treatment.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection and filtering of spam e-mails and messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predicting election results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fraud detection and prediction. We will be taking a stab at one of the most
    critical fraud detection problems in [Chapters 5](part0038_split_000.html#147LC1-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 5. Credit Risk Detection and Prediction – Descriptive Analytics"), *Credit
    Risk Detection and Prediction – Descriptive Analytics* and [Chapter 6](part0046_split_000.html#1BRPS1-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 6. Credit Risk Detection and Prediction – Predictive Analytics"), *Credit
    Risk Detection and Prediction – Predictive Analytics*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text prediction in a messaging application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-driving cars, planes, and other vehicles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weather, traffic, and crime activity forecasting and prediction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sentiment and emotion analysis, which we will be covering in [Chapter 8](part0066_split_000.html#1UU542-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 8. Sentiment Analysis of Twitter Data"), *Sentiment Analysis of Twitter
    Data*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding examples just scratch the surface of what machine learning can
    really do and by now I am sure that you have got a good flavor of the various
    areas where machine learning is being used extensively.
  prefs: []
  type: TYPE_NORMAL
- en: Types of machine learning algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we talked about earlier, to make machines learn, you need machine learning
    algorithms. Machine learning algorithms are a special class of algorithms which
    work on data and gather insights from it. The idea is to build a model using a
    combination of data and algorithms which can then be used to work on new data
    and derive actionable insights.
  prefs: []
  type: TYPE_NORMAL
- en: Each machine learning algorithm depends on what type of data it can work on
    and what type of problem are we trying to solve. You might be tempted to learn
    a couple of algorithms and then try to apply them to every problem you face. Do
    remember that there is no universal machine learning algorithm which fits all
    problems. The main input to machine learning algorithms is data which consists
    of features, where each feature can be described as an attribute of the data set,
    such as your height, weight, and so on if we were dealing with data related to
    human beings. Machine learning algorithms can be divided into two main areas,
    namely supervised and unsupervised learning algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Supervised machine learning algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The supervised learning algorithms are a subset of the family of machine learning
    algorithms which are mainly used in predictive modeling. A predictive model is
    basically a model constructed from a machine learning algorithm and features or
    attributes from training data such that we can predict a value using the other
    values obtained from the input data. Supervised learning algorithms try to model
    relationships and dependencies between the target prediction output and the input
    features such that we can predict the output values for new data based on those
    relationships which it learned from the previous data sets. The main types of
    supervised learning algorithms include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Classification algorithms**: These algorithms build predictive models from
    training data which have features and class labels. These predictive models in-turn
    use the features learnt from training data on new, previously unseen data to predict
    their class labels. The output classes are discrete. Types of classification algorithms
    include decision trees, random forests, support vector machines, and many more.
    We will be using several of these algorithms in [Chapter 2](part0022_split_000.html#KVCC1-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 2. Let''s Help Machines Learn"), *Let''s Help Machines Learn*, [Chapter
    6](part0046_split_000.html#1BRPS1-973e731d75c2419489ee73e3a0cf4be8 "Chapter 6. Credit
    Risk Detection and Prediction – Predictive Analytics"), *Credit Risk Detection
    and Prediction – Predictive Analytics*, and [Chapter 8](part0066_split_000.html#1UU542-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 8. Sentiment Analysis of Twitter Data"), *Sentiment Analysis of Twitter
    Data*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression algorithms**: These algorithms are used to predict output values
    based on some input features obtained from the data. To do this, the algorithm
    builds a model based on features and output values of the training data and this
    model is used to predict values for new data. The output values in this case are
    continuous and not discrete. Types of regression algorithms include linear regression,
    multivariate regression, regression trees, and lasso regression, among many others.
    We explore some of these in [Chapter 2](part0022_split_000.html#KVCC1-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 2. Let''s Help Machines Learn"), *Let''s Help Machines Learn*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsupervised machine learning algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The unsupervised learning algorithms are the family of machine learning algorithms
    which are mainly used in pattern detection and descriptive modeling. A descriptive
    model is basically a model constructed from an unsupervised machine learning algorithm
    and features from input data similar to the supervised learning process. However,
    there are no output categories or labels here based on which the algorithm can
    try to model relationships. These algorithms try to use techniques on the input
    data to mine for rules, detect patterns, and summarize and group the data points
    which help in deriving meaningful insights and describe the data better to the
    users. There is no specific concept of training or testing data here since we
    do not have any specific relationship mapping and we are just trying to get useful
    insights and descriptions from the data we are trying to analyze. The main types
    of unsupervised learning algorithms include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clustering algorithms**: The main objective of these algorithms is to cluster
    or group input data points into different classes or categories using just the
    features derived from the input data alone and no other external information.
    Unlike classification, the output labels are not known beforehand in clustering.
    There are different approaches to build clustering models, such as by using means,
    medoids, hierarchies, and many more. Some popular clustering algorithms include
    k-means, k-medoids, and hierarchical clustering. We will look at some clustering
    algorithms in [Chapter 2](part0022_split_000.html#KVCC1-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 2. Let''s Help Machines Learn"), *Let''s Help Machines Learn*, and [Chapter
    7](part0059_split_000.html#1O8H61-973e731d75c2419489ee73e3a0cf4be8 "Chapter 7. Social
    Media Analysis – Analyzing Twitter Data"), *Social Media Analysis – Analyzing
    Twitter Data*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Association rule learning algorithms**: These algorithms are used to mine
    and extract rules and patterns from data sets. These rules explain relationships
    between different variables and attributes, and also depict frequent item sets
    and patterns which occur in the data. These rules in turn help discover useful
    insights for any business or organization from their huge data repositories. Popular
    algorithms include Apriori and FP Growth. We will be using some of these in [Chapter
    2](part0022_split_000.html#KVCC1-973e731d75c2419489ee73e3a0cf4be8 "Chapter 2. Let''s
    Help Machines Learn"), *Let''s Help Machines Learn*, and [Chapter 3](part0026_split_000.html#OPEK1-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 3. Predicting Customer Shopping Trends with Market Basket Analysis"),
    *Predicting Customer Shopping Trends with Market Basket Analysis*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Popular machine learning packages in R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After getting a brief overview of machine learning basics and types of algorithms,
    you must be getting inquisitive as to how we apply some of these algorithms to
    solve real world problems using R. It turns out, there are a whole lot of packages
    in R which are dedicated to just solving machine learning problems. These packages
    consist of algorithms which are optimized and ready to be used to solve problems.
    We will list several popular machine learning packages in R, so that you are aware
    of what tools you might need later on and also feel more familiar with some of
    these packages when used in the later chapters. Based on usage and functionality,
    the following R packages are quite popular in solving machine learning problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '`caret`: This package (short for classification and regression training) consists
    of several machine learning algorithms for building predictive models'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`randomForest`: This package deals with implementations of the random forest
    algorithm for classification and regression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rpart`: This package focuses on recursive partitioning and decision trees'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glmnet`: The main focus of this package is lasso and elastic-net regularized
    regression models'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e1071`: This deals with fourier transforms, clustering, support vector machines,
    and many more supervised and unsupervised algorithms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`party`: This deals with recursive partitioning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arules`: This package is used for association rule learning algorithms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recommenderlab`: This is a library to build recommendation engines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nnet`: This package enables predictive modeling using neural networks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`h2o`: It is one of the most popular packages being used in data science these
    days and offers fast and scalable algorithms including gradient boosting and deep
    learning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the preceding libraries, there are a ton of other packages out there
    related to machine learning in R. What matters is choosing the right algorithm
    and model based on the data and problem in hand.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked briefly about the journey we will take into the world
    of machine learning and R. We discussed the basics of R and built a strong foundation
    of the core constructs and data structures used in R. Then we dived into the world
    of machine learning by looking at some concepts and algorithms, and how it is
    used in the world to solve problems. Finally, we ended with a quick glance at
    some of the most popular machine learning packages in R to get us all familiarized
    with some handy tools for our machine learning toolbox!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking in depth about machine learning concepts
    and algorithms which will help us make the machines learn something!
  prefs: []
  type: TYPE_NORMAL
