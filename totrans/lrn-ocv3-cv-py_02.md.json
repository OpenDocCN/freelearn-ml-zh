["```py\nimg = numpy.zeros((3,3), dtype=numpy.uint8)\n```", "```py\narray([[0, 0, 0],\n       [0, 0, 0],\n       [0, 0, 0]], dtype=uint8)\n```", "```py\nimg = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n```", "```py\narray([[[0, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0]],\n\n       [[0, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0]],\n\n       [[0, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0]]], dtype=uint8)\n```", "```py\n>>> img = numpy.zeros((3,3), dtype=numpy.uint8)\n>>> img.shape\n```", "```py\nimport cv2\n\nimage = cv2.imread('MyPic.png')\ncv2.imwrite('MyPic.jpg', image)\n```", "```py\nimport cv2\n\ngrayImage = cv2.imread('MyPic.png', cv2.IMREAD_GRAYSCALE)\ncv2.imwrite('MyPicGray.png', grayImage)\n```", "```py\nbyteArray = bytearray(image)\n```", "```py\ngrayImage = numpy.array(grayByteArray).reshape(height, width)\nbgrImage = numpy.array(bgrByteArray).reshape(height, width, 3)\n```", "```py\nimport cv2\nimport numpy\nimport os\n\n# Make an array of 120,000 random bytes.\nrandomByteArray = bytearray(os.urandom(120000))\nflatNumpyArray = numpy.array(randomByteArray)\n\n# Convert the array to make a 400x300 grayscale image.\ngrayImage = flatNumpyArray.reshape(300, 400)\ncv2.imwrite('RandomGray.png', grayImage)\n\n# Convert the array to make a 400x100 color image.\nbgrImage = flatNumpyArray.reshape(100, 400, 3)\ncv2.imwrite('RandomColor.png', bgrImage)\n```", "```py\nimport cv\n\nimport numpy as np\nimg = cv.imread('MyPic.png')\nimg[0,0] = [255, 255, 255]\n```", "```py\nimport cv\nimport numpy as  np\nimg = cv.imread('MyPic.png')\nprint img.item(150, 120, 0)  // prints the current value of B for that pixel\nimg.itemset( (150, 120, 0), 255)\nprint img.item(150, 120, 0)  // prints 255\n```", "```py\nimport cv\nimport  as  np\nimg = cv.imread('MyPic.png')\nimg[:, :, 1] = 0\n```", "```py\nimport cv\nimport numpy as  np\nimg = cv.imread('MyPic.png')\nmy_roi = img[0:100, 0:100]\nimg[300:400, 300:400] = my_roi\n```", "```py\nimport cv\nimport numpy  as  np\nimg = cv.imread('MyPic.png')\nprint img.shape\nprint img.size\nprint img.dtype\n```", "```py\nimport cv2\n\nvideoCapture = cv2.VideoCapture('MyInputVid.avi')\nfps = videoCapture.get(cv2.CAP_PROP_FPS)\nsize = (int(videoCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),\n        int(videoCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))\nvideoWriter = cv2.VideoWriter(\n    'MyOutputVid.avi', cv2.VideoWriter_fourcc('I','4','2','0'), fps, size)\n\nsuccess, frame = videoCapture.read()\nwhile success: # Loop until there are no more frames.\n    videoWriter.write(frame)\n    success, frame = videoCapture.read()\n```", "```py\nimport cv2\n\ncameraCapture = cv2.VideoCapture(0)\nfps = 30 # an assumption\nsize = (int(cameraCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),\n        int(cameraCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))\nvideoWriter = cv2.VideoWriter(\n    'MyOutputVid.avi', cv2.VideoWriter_fourcc('I','4','2','0'), fps, size)\n\nsuccess, frame = cameraCapture.read()\nnumFramesRemaining = 10 * fps - 1\nwhile success and numFramesRemaining > 0:\n    videoWriter.write(frame)\n    success, frame = cameraCapture.read()\n    numFramesRemaining -= 1\ncameraCapture.release()\n```", "```py\nsuccess0 = cameraCapture0.grab()\nsuccess1 = cameraCapture1.grab()\nif success0 and success1:\n    frame0 = cameraCapture0.retrieve()\n    frame1 = cameraCapture1.retrieve()\n```", "```py\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('my-image.png')\ncv2.imshow('my image', img)\ncv2.waitKey()\ncv2.destroyAllWindows()\n```", "```py\nimport cv2\n\nclicked = False\ndef onMouse(event, x, y, flags, param):\n    global clicked\n    if event == cv2.EVENT_LBUTTONUP:\n        clicked = True\n\ncameraCapture = cv2.VideoCapture(0)\ncv2.namedWindow('MyWindow')\ncv2.setMouseCallback('MyWindow', onMouse)\n\nprint 'Showing camera feed. Click window or press any key to stop.'\nsuccess, frame = cameraCapture.read()\nwhile success and cv2.waitKey(1) == -1 and not clicked:\n    cv2.imshow('MyWindow', frame)\n    success, frame = cameraCapture.read()\n\ncv2.destroyWindow('MyWindow')\ncameraCapture.release()\n```", "```py\nkeycode = cv2.waitKey(1)\nif keycode != -1:\n    keycode &= 0xFF\n```", "```py\nimport cv2\nimport numpy\nimport time\n\nclass CaptureManager(object):\n\n    def __init__(self, capture, previewWindowManager = None,\n                 shouldMirrorPreview = False):\n\n        self.previewWindowManager = previewWindowManager\n        self.shouldMirrorPreview = shouldMirrorPreview\n\n        self._capture = capture\n        self._channel = 0\n        self._enteredFrame = False\n        self._frame = None\n        self._imageFilename = None\n        self._videoFilename = None\n        self._videoEncoding = None\n        self._videoWriter = None\n\n        self._startTime = None\n        self._framesElapsed = long(0)\n        self._fpsEstimate = None\n\n    @property\n    def channel(self):\n        return self._channel\n\n    @channel.setter\n    def channel(self, value):\n        if self._channel != value:\n            self._channel = value\n            self._frame = None\n\n    @property\n    def frame(self):\n        if self._enteredFrame and self._frame is None:\n            _, self._frame = self._capture.retrieve()\n        return self._frame\n\n    @property\n    def isWritingImage (self):\n\n        return self._imageFilename is not None\n\n    @property\n    def isWritingVideo(self):\n        return self._videoFilename is not None\n```", "```py\n    def enterFrame(self):\n        \"\"\"Capture the next frame, if any.\"\"\"\n\n        # But first, check that any previous frame was exited.\n        assert not self._enteredFrame, \\\n            'previous enterFrame() had no matching exitFrame()'\n\n        if self._capture is not None:\n            self._enteredFrame = self._capture.grab()\n\n    def exitFrame (self):\n        \"\"\"Draw to the window. Write to files. Release the frame.\"\"\"\n\n        # Check whether any grabbed frame is retrievable.\n        # The getter may retrieve and cache the frame.\n        if self.frame is None:\n            self._enteredFrame = False\n            return\n\n        # Update the FPS estimate and related variables.\n        if self._framesElapsed == 0:\n            self._startTime = time.time()\n        else:\n            timeElapsed = time.time() - self._startTime\n            self._fpsEstimate =  self._framesElapsed / timeElapsed\n        self._framesElapsed += 1\n\n        # Draw to the window, if any.\n        if self.previewWindowManager is not None:\n            if self.shouldMirrorPreview:\n                mirroredFrame = numpy.fliplr(self._frame).copy()\n                self.previewWindowManager.show(mirroredFrame)\n            else:\n                self.previewWindowManager.show(self._frame)\n\n        # Write to the image file, if any.\n        if self.isWritingImage:\n            cv2.imwrite(self._imageFilename, self._frame)\n            self._imageFilename = None\n\n        # Write to the video file, if any.\n        self._writeVideoFrame()\n\n        # Release the frame.\n        self._frame = None\n        self._enteredFrame = False\n```", "```py\n    def writeImage(self, filename):\n        \"\"\"Write the next exited frame to an image file.\"\"\"\n        self._imageFilename = filename\n\n    def startWritingVideo(\n            self, filename,\n            encoding = cv2.VideoWriter_fourcc('I','4','2','0')):\n        \"\"\"Start writing exited frames to a video file.\"\"\"\n        self._videoFilename = filename\n        self._videoEncoding = encoding\n\n    def stopWritingVideo (self):\n        \"\"\"Stop writing exited frames to a video file.\"\"\"\n        self._videoFilename = None\n        self._videoEncoding = None\n        self._videoWriter = None\n\ndef _writeVideoFrame(self):\n\n        if not self.isWritingVideo:\n            return\n\n        if self._videoWriter is None:\n            fps = self._capture.get(cv2.CAP_PROP_FPS)\n            if fps == 0.0:\n                # The capture's FPS is unknown so use an estimate.\n                if self._framesElapsed < 20:\n                    # Wait until more frames elapse so that the\n                    # estimate is more stable.\n                    return\n                else:\n                    fps = self._fpsEstimate\n            size = (int(self._capture.get(\n                        cv2.CAP_PROP_FRAME_WIDTH)),\n                    int(self._capture.get(\n                        cv2.CAP_PROP_FRAME_HEIGHT)))\n            self._videoWriter = cv2.VideoWriter(\n                self._videoFilename, self._videoEncoding,\n                fps, size)\n\n        self._videoWriter.write(self._frame)\n```", "```py\nclass WindowManager(object):\n\n    def __init__(self, windowName, keypressCallback = None):\n        self.keypressCallback = keypressCallback\n\n        self._windowName = windowName\n        self._isWindowCreated = False\n\n    @property\n    def isWindowCreated(self):\n        return self._isWindowCreated\n\n    def createWindow (self):\n        cv2.namedWindow(self._windowName)\n        self._isWindowCreated = True\n\n    def show(self, frame):\n        cv2.imshow(self._windowName, frame)\n\n    def destroyWindow (self):\n        cv2.destroyWindow(self._windowName)\n        self._isWindowCreated = False\n\n    def processEvents (self):\n        keycode = cv2.waitKey(1)\n        if self.keypressCallback is not None and keycode != -1:\n            # Discard any non-ASCII info encoded by GTK.\n            keycode &= 0xFF\n            self.keypressCallback(keycode)\n```", "```py\nimport cv2\nfrom managers import WindowManager, CaptureManager\n\nclass Cameo(object):\n\n    def __init__(self):\n        self._windowManager = WindowManager('Cameo',\n                                            self.onKeypress)\n        self._captureManager = CaptureManager(\n            cv2.VideoCapture(0), self._windowManager, True)\n\n    def run(self):\n        \"\"\"Run the main loop.\"\"\"\n        self._windowManager.createWindow()\n        while self._windowManager.isWindowCreated:\n            self._captureManager.enterFrame()\n            frame = self._captureManager.frame\n\n            # TODO: Filter the frame (Chapter 3).\n\n            self._captureManager.exitFrame()\n            self._windowManager.processEvents()\n\n    def onKeypress (self, keycode):\n        \"\"\"Handle a keypress.\n\n        space  -> Take a screenshot.\n        tab    -> Start/stop recording a screencast.\n        escape -> Quit.\n\n        \"\"\"\n        if keycode == 32: # space\n            self._captureManager.writeImage('screenshot.png')\n        elif keycode == 9: # tab\n            if not self._captureManager.isWritingVideo:\n                self._captureManager.startWritingVideo(\n                    'screencast.avi')\n            else:\n                self._captureManager.stopWritingVideo()\n        elif keycode == 27: # escape\n            self._windowManager.destroyWindow()\n\nif __name__==\"__main__\":\n    Cameo().run()\n```"]