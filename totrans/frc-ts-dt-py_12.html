<html><head></head><body>
<div id="_idContainer253">
<h1 class="chapter-number" id="_idParaDest-128"><a id="_idTextAnchor794"/><a id="_idTextAnchor795"/><a id="_idTextAnchor796"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-129"><a id="_idTextAnchor797"/><span class="koboSpan" id="kobo.2.1">Performing Cross-Validation</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The concept of keeping training data and testing data separate is sacrosanct in machine learning and statistics. </span><span class="koboSpan" id="kobo.3.2">You should never train a model and test its performance on the same data. </span><span class="koboSpan" id="kobo.3.3">Setting data aside for testing purposes has a downside, though: that data has valuable information that you would want to include in training. </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Cross-validation</span></strong><span class="koboSpan" id="kobo.5.1"> is a technique that’s used to circumvent </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this problem.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">You may be familiar with </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">k-fold cross-validation</span></strong><span class="koboSpan" id="kobo.9.1">, but if you are not, we will briefly cover it in this chapter. </span><span class="koboSpan" id="kobo.9.2">K-fold cross-validation, however, will not work on time series data. </span><span class="koboSpan" id="kobo.9.3">It requires that the data be independent, an assumption that time series data does not hold. </span><span class="koboSpan" id="kobo.9.4">An understanding of k-fold cross-validation will help you learn how forward-chaining cross-validation works and why it is necessary for time </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">series data.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">After learning how to perform cross-validation in Prophet, you will learn how to speed up the computing of cross-validation through Prophet’s ability to parallelize several processes. </span><span class="koboSpan" id="kobo.11.2">All in all, this chapter will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Performing </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">k-fold cross-validation</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Performing </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">forward-chaining cross-validation</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Creating the Prophet </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">cross-validation DataFrame</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Parallelizing cross-validation</span></span></li>
</ul>
<h1 id="_idParaDest-130"><a id="_idTextAnchor798"/><a id="_idTextAnchor799"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.21.1">The data files and code for examples in this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">at </span></span><a href="https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition"><span class="No-Break"><span class="koboSpan" id="kobo.23.1">https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.24.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">.</span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor800"/><a id="_idTextAnchor801"/><span class="koboSpan" id="kobo.26.1">Performing k-fold cross-validation</span></h1>
<p><span class="koboSpan" id="kobo.27.1">We’ll be using a new </span><a id="_idTextAnchor802"/><span class="koboSpan" id="kobo.28.1">dataset</span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.29.1"> in this chapter – the sales of an online retailer in the United Kingdom. </span><span class="koboSpan" id="kobo.29.2">This data has been anonymized, but it represents 3 years of daily sales amounts, as displayed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">following graph:</span></span></p>
<p class="IMG---Figure"><a id="_idTextAnchor803"/></p>
<div>
<div class="IMG---Figure" id="_idContainer245">
<span class="koboSpan" id="kobo.31.1"><img alt="Figure 12.1 – Daily sales of an anonymous online retailer" src="image/Fig_12.1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.32.1">Figure 12.1 – Daily sales of an anonymous online retailer</span></p>
<p><span class="koboSpan" id="kobo.33.1">This retailer has not seen dramatic growth over the 3 years of data, but it has seen a massive boost in sales at the end of each year. </span><span class="koboSpan" id="kobo.33.2">The main customers of this retailer are wholesalers, who typically make their purchases during the work week. </span><span class="koboSpan" id="kobo.33.3">This is why when we plot the components of Prophet’s forecast, you’ll see that Saturday and Sunday’s sales are the lowest. </span><span class="koboSpan" id="kobo.33.4">We’ll use this data to perform cross-validation </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">in Prophet.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">Before we get to modeling, though, let’s first review traditional validation techniques used to tune a model’s hyperparameters and report performance. </span><span class="koboSpan" id="kobo.35.2">The most basic method is to take</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.36.1"> your full dataset</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.37.1"> and split</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.38.1"> it into three subsets: a </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">training set</span></strong><span class="koboSpan" id="kobo.40.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">validation set</span></strong><span class="koboSpan" id="kobo.42.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">test set</span></strong><span class="koboSpan" id="kobo.44.1">, after randomly </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.45.1">shuffling it around. </span><span class="koboSpan" id="kobo.45.2">This is someti</span><a id="_idTextAnchor804"/><span class="koboSpan" id="kobo.46.1">mes called </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">hold-out</span></strong><span class="koboSpan" id="kobo.48.1"> validation. </span><span class="koboSpan" id="kobo.48.2">Usually, the training set is the largest and the validation and testing sets are smaller. </span><span class="koboSpan" id="kobo.48.3">For example, a 60/20/20 split would look </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">like thi</span><a id="_idTextAnchor805"/><span class="koboSpan" id="kobo.50.1">s:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer246">
<span class="koboSpan" id="kobo.51.1"><img alt="Figure 12.2 – Traditional train/validation/test sets" src="image/Fig_12.2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.52.1">Figure 12.2 – Traditional train/validation/test sets</span></p>
<p><span class="koboSpan" id="kobo.53.1">After the full data has been split, your model</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.54.1"> is trained on the train set, and performance is evaluated on </span><a id="_idTextAnchor806"/><span class="koboSpan" id="kobo.55.1">the validation set. </span><span class="koboSpan" id="kobo.55.2">A new set of hyperparameters is chosen for the given algorithm and the model is retrained on the train set and re-evaluated on the validation set. </span><span class="koboSpan" id="kobo.55.3">This process is repeated for however many combinations of hyperparameters you want </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">to try.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">The set of hyperparameters with the highest performance on the validation set is chosen for the model; the train and validation sets are combined to train a final model, and this final model is evaluated on the test set. </span><span class="koboSpan" id="kobo.57.2">This evaluation is then reported as the </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">model’s performance.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">With this technique, though, only 60% of your full data is available to use to tune the model. </span><span class="koboSpan" id="kobo.59.2">It would be advantageous to use more data for tuning but using smaller validation and testing sets could introduce bias into </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">your model.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">To solve this problem, k-fold cross-validation was developed. </span><span class="koboSpan" id="kobo.61.2">In k-fold cross-validation, the data is still randomly shuffled and has a test set split out, maybe 20% again. </span><span class="koboSpan" id="kobo.61.3">The remaining 80% of the data is all used for training. </span><span class="koboSpan" id="kobo.61.4">This 80% of data is split into </span><em class="italic"><span class="koboSpan" id="kobo.62.1">k</span></em><span class="koboSpan" id="kobo.63.1"> sections, with each section called a </span><em class="italic"><span class="koboSpan" id="kobo.64.1">fold</span></em><span class="koboSpan" id="kobo.65.1">. </span><span class="koboSpan" id="kobo.65.2">This is what the process looks like with </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">five fold</span><a id="_idTextAnchor807"/><span class="koboSpan" id="kobo.67.1">s:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer247">
<span class="koboSpan" id="kobo.68.1"><img alt="Figure 12.3 – k-fold cross-validation with five folds" src="image/Fig_12.3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.69.1">Figure 12.3 – k-fold cross-validation with five folds</span></p>
<p><span class="koboSpan" id="kobo.70.1">For each set of hyperparameters you want to evaluate, you train your model five times. </span><span class="koboSpan" id="kobo.70.2">The first time, you set aside the first fold and train on the remaining four. </span><span class="koboSpan" id="kobo.70.3">You evaluate on that first fold. </span><span class="koboSpan" id="kobo.70.4">You repeat this process for each fold and take the average of your performance metric across the five folds. </span><span class="koboSpan" id="kobo.70.5">Then, you move on to the next set of hyperparameters </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">and repeat.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">The process of tuni</span><a id="_idTextAnchor808"/><span class="koboSpan" id="kobo.73.1">ng your hyperparameters takes much longer in this case because of the training for each fold. </span><span class="koboSpan" id="kobo.73.2">The advantage, though, is that you can use more data for training without introducing bias into </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">your model.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">As you know, time series data</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.76.1"> is sequential and dependent. </span><span class="koboSpan" id="kobo.76.2">You cannot shuffle it. </span><span class="koboSpan" id="kobo.76.3">You cannot train on future data to predict previous data. </span><span class="koboSpan" id="kobo.76.4">This is why both of the methods just demonstrated will not work. </span><span class="koboSpan" id="kobo.76.5">We need a way to maintain the order of our data while still setting some aside for testing and validation. </span><span class="koboSpan" id="kobo.76.6">That’s why forward chaining </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">was develop</span><a id="_idTextAnchor809"/><a id="_idTextAnchor810"/><span class="koboSpan" id="kobo.78.1">ed.</span></span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor811"/><span class="koboSpan" id="kobo.79.1">Performing forward-chaining cross-validation</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.80.1">Forward-chaining cross-validation</span></strong><span class="koboSpan" id="kobo.81.1">, also called </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">rolling-origin cross-validation</span></strong><span class="koboSpan" id="kobo.83.1">,</span><a id="_idTextAnchor812"/><span class="koboSpan" id="kobo.84.1"> is similar</span><a id="_idTextAnchor813"/><span class="koboSpan" id="kobo.85.1"> to k-fold</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.86.1"> cross-validation but is better suited to sequential data</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.87.1"> such as time series. </span><span class="koboSpan" id="kobo.87.2">There is no random shuffling of data to begin with, but a test set may be set aside. </span><span class="koboSpan" id="kobo.87.3">The test set must be the final portion of data, so if each fold is going to be 10% of your data (as it would be in 10-fold cross-validation), then your test set will be the final 10% of your </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">date range.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">With the remaining data, you choose an initial amount of data to train on, let’s say five folds in this example, and then you evaluate on the sixth fold and save that performance metric. </span><span class="koboSpan" id="kobo.89.2">You retrain now on the first six folds and evaluate on the seventh. </span><span class="koboSpan" id="kobo.89.3">You repeat this until all folds are exhausted and again take the average of your performance metric. </span><span class="koboSpan" id="kobo.89.4">The folds using this technique would look </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">like t</span><a id="_idTextAnchor814"/><span class="koboSpan" id="kobo.91.1">his:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer248">
<span class="koboSpan" id="kobo.92.1"><img alt="Figure 12.4 – Forward-chaining cross-validation with five folds" src="image/Fig_12.4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.93.1">Figure 12.4 – Forward-chaining cross-validation with five folds</span></p>
<p><span class="koboSpan" id="kobo.94.1">In this way, you are able to train</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.95.1"> your data on sequential data points and evaluate unseen data, and you are also able to minimize bias by training and testing on a variety </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">of samples.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">Prophet has a bui</span><a id="_idTextAnchor815"/><span class="koboSpan" id="kobo.98.1">lt-in diagnostics tool for performing forward-chaining cross-validation. </span><span class="koboSpan" id="kobo.98.2">Let’s now see how to use it with our retail </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">sales dat</span><a id="_idTextAnchor816"/><a id="_idTextAnchor817"/><span class="koboSpan" id="kobo.100.1">aset.</span></span></p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor818"/><span class="koboSpan" id="kobo.101.1">Creating the Prophet cross-validation DataFrame</span></h1>
<p><span class="koboSpan" id="kobo.102.1">To perform cross-valid</span><a id="_idTextAnchor819"/><span class="koboSpan" id="kobo.103.1">ation</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.104.1"> in Prophet, first, you need a fitted model. </span><span class="koboSpan" id="kobo.104.2">So, we’ll begin with the same procedure we’ve completed throughout this book. </span><span class="koboSpan" id="kobo.104.3">This dataset is very cooperative, so we’ll be able to use plenty of Prophet’s default parameters. </span><span class="koboSpan" id="kobo.104.4">We will plot the changepoints, so be sure to include that function with your other imports before loading </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">the data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.106.1">
import pandas as pd
import matplotlib.pyplot as plt
from prophet import Prophet
from prophet.plot import add_changepoints_to_plot
df = pd.read_csv('online_retail.csv')
df['date'] = pd.to_datetime(df['date'])
df.columns = ['ds', 'y']</span></pre>
<p><span class="koboSpan" id="kobo.107.1">This dataset does not have</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.108.1"> very complicated seasonality, so we’ll reduce the Fourier order of yearly seasonality when instantiating our model, but keep everything else default, before fitting, predicting, and plotting. </span><span class="koboSpan" id="kobo.108.2">We’ll use a 1-year </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">future forecast:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.110.1">
model = Prophet(yearly_seasonality=4)
model.fit(df)
future = model.make_future_dataframe(periods=365)
forecast = model.predict(future)
fig = model.plot(forecast)
add_changepoints_to_plot(fig.gca(), model, forecast)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.111.1">As expected, this plot shows the same data as </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.112.1">Figure 12</span></em></span><em class="italic"><span class="koboSpan" id="kobo.113.1">.1</span></em><span class="koboSpan" id="kobo.114.1"> where the data was introduced. </span><span class="koboSpan" id="kobo.114.2">There were no significant trend changepoints identified and a very gently sloping upward trend. </span><span class="koboSpan" id="kobo.114.3">There appears to be a mild increase in sales during the summer but a dramatic increase over the winter holiday season, as can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">following</span><a id="_idTextAnchor820"/><span class="koboSpan" id="kobo.116.1"> plot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer249">
<span class="koboSpan" id="kobo.117.1"><img alt="Figure 12.5 – Online retail sales forecast" src="image/Fig_12.5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.118.1">Figure 12.5 – Online retail sales forecast</span></p>
<p><span class="koboSpan" id="kobo.119.1">Let’s pl</span><a id="_idTextAnchor821"/><span class="koboSpan" id="kobo.120.1">ot the components</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.121.1"> now to better understand </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">our seasonalities:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.123.1">
fig2 = model.plot_components(forecast)
plt.show()</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">trend</span></strong><span class="koboSpan" id="kobo.125.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">weekly</span></strong><span class="koboSpan" id="kobo.127.1"> seasonality, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">yearly</span></strong><span class="koboSpan" id="kobo.129.1"> seasonality show </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">clear pat</span><a id="_idTextAnchor822"/><span class="koboSpan" id="kobo.131.1">terns:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer250">
<span class="koboSpan" id="kobo.132.1"><img alt="Figure 12.6 – Online retail sales components plot﻿" src="image/Fig_12.6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.133.1">Figure 12.6 – Online retail sales components plot</span><a id="_idTextAnchor823"/></p>
<p><span class="koboSpan" id="kobo.134.1">As we predicted, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">yearly</span></strong><span class="koboSpan" id="kobo.136.1"> seasonality reflects that winter spike. </span><span class="koboSpan" id="kobo.136.2">As I mentioned when introducing</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.137.1"> this data, the retailer largely caters to wholesalers, not consumers. </span><span class="koboSpan" id="kobo.137.2">So, their purchasing occurs during the business week far more than on the weekends. </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">Friday</span></strong><span class="koboSpan" id="kobo.139.1"> sales are even down compared with the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">the week.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">Now, let’s perform the actual cross-validation. </span><span class="koboSpan" id="kobo.141.2">To do that, we first need to import the function from Prophet’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">diagnostics</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.143.1"> package:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.144.1">
from prophet.diagnostics import cross_validation</span></pre>
<p><span class="koboSpan" id="kobo.145.1">Before we see how to use that function, there are some terms we need </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">to discuss:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">initial</span></strong><span class="koboSpan" id="kobo.148.1"> is the first training period. </span><span class="koboSpan" id="kobo.148.2">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.149.1">Figure 12</span></em></span><em class="italic"><span class="koboSpan" id="kobo.150.1">.5</span></em><span class="koboSpan" id="kobo.151.1">, it would be the first five blocks of data in the first fold. </span><span class="koboSpan" id="kobo.151.2">It is the minimum amount of data needed to begin </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">your training.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">horizon</span></strong><span class="koboSpan" id="kobo.154.1"> is the length of t</span><a id="_idTextAnchor824"/><span class="koboSpan" id="kobo.155.1">ime you want to evaluate your forecast over. </span><span class="koboSpan" id="kobo.155.2">Let’s say that this retail outlet is building its model so that it can predict sales over the next month. </span><span class="koboSpan" id="kobo.155.3">A horizon set to 30 days would make sense here so that they evaluate their model on the same parameter setting that they wish to use </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">it on.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">period</span></strong><span class="koboSpan" id="kobo.158.1"> is the amount of time between each fold. </span><span class="koboSpan" id="kobo.158.2">It can be either greater than the horizon or less than it, or even equal </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">to it.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">cutoffs</span></strong><span class="koboSpan" id="kobo.161.1"> are the dates when each horizon </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">will begin.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.163.1">This vocabulary</span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.164.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">illustrate</span><a id="_idTextAnchor825"/><span class="koboSpan" id="kobo.166.1">d here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer251">
<span class="koboSpan" id="kobo.167.1"><img alt="Figure 12.7 – Cross-validation terminology" src="image/Fig_12.7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.168.1">Figure 12.7 – Cross-validation terminology</span></p>
<p><span class="koboSpan" id="kobo.169.1">For each </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">cutoff</span></strong><span class="koboSpan" id="kobo.171.1">, the model will be trained on all data up to that </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">cutoff</span></strong><span class="koboSpan" id="kobo.173.1">, and then a prediction will be made for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">horizon</span></strong><span class="koboSpan" id="kobo.175.1"> period. </span><span class="koboSpan" id="kobo.175.2">That prediction will be compared to the known val</span><a id="_idTextAnchor826"/><span class="koboSpan" id="kobo.176.1">ues and evaluated. </span><span class="koboSpan" id="kobo.176.2">Then, the model will be retrained on all data up to the second </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">cutoff</span></strong><span class="koboSpan" id="kobo.178.1"> and the process will be repeated. </span><span class="koboSpan" id="kobo.178.2">The final performance evaluation will be the average of the performance at </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">each cutoff.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">Let’s imagine that this retail outlet wants a model that is able to predict the next month of daily sales, and they plan on running the model at the beginning of each quarter. </span><span class="koboSpan" id="kobo.180.2">They have 3 years of data and want (as is recommended for Prophet) at least 2 full cycles of seasonality, which because they are modeling yearly seasonality will be </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">2 years.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">They would set their initial training</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.183.1"> data to be 2 years then. </span><span class="koboSpan" id="kobo.183.2">They want to predict the next month of sales, and so would set </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">horizon</span></strong><span class="koboSpan" id="kobo.185.1"> to 30 days. </span><span class="koboSpan" id="kobo.185.2">They plan to run the model each business quarter, and so would set the period to be 90 days. </span><span class="koboSpan" id="kobo.185.3">That’s what was shown previously in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.186.1">Figure 12</span></em></span><em class="italic"><span class="koboSpan" id="kobo.187.1">.7</span></em><span class="koboSpan" id="kobo.188.1">. </span><span class="koboSpan" id="kobo.188.2">Now, let’s apply this </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">to Prophet.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">cross_validation</span></strong><span class="koboSpan" id="kobo.192.1"> function takes two required arguments, the fitted model and </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">horizon</span></strong><span class="koboSpan" id="kobo.194.1">. </span><span class="koboSpan" id="kobo.194.2">Also, </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">period</span></strong><span class="koboSpan" id="kobo.196.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">initial</span></strong><span class="koboSpan" id="kobo.198.1"> can be stated, but they are not required. </span><span class="koboSpan" id="kobo.198.2">If left as their defaults, </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">period</span></strong><span class="koboSpan" id="kobo.200.1"> is half of </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">horizon</span></strong><span class="koboSpan" id="kobo.202.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">initial</span></strong><span class="koboSpan" id="kobo.204.1"> will be three times </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">horizon</span></strong><span class="koboSpan" id="kobo.206.1">. </span><span class="koboSpan" id="kobo.206.2">The output of the function is the cross-validation DataFrame. </span><span class="koboSpan" id="kobo.206.3">Let’s create this DataFrame and call </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">df_cv</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.210.1">
df_cv = cross_validation(model,
                         horizon='90 days',
                         period='30 days',
                         initial='730 days')</span></pre>
<p><span class="koboSpan" id="kobo.211.1">Each of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">horizon</span></strong><span class="koboSpan" id="kobo.213.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">period</span></strong><span class="koboSpan" id="kobo.215.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">initial</span></strong><span class="koboSpan" id="kobo.217.1"> arguments takes a string with a style compatible with pandas’ </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">Timedelta</span></strong><span class="koboSpan" id="kobo.219.1"> format, for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">'5 days'</span></strong><span class="koboSpan" id="kobo.221.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">'3 hours'</span></strong><span class="koboSpan" id="kobo.223.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">'10 seconds'</span></strong><span class="koboSpan" id="kobo.225.1">. </span><span class="koboSpan" id="kobo.225.2">In this example, we’re switching the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">horizon</span></strong><span class="koboSpan" id="kobo.227.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">period</span></strong><span class="koboSpan" id="kobo.229.1"> values fr</span><a id="_idTextAnchor827"/><span class="koboSpan" id="kobo.230.1">om those shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.231.1">Figure 12</span></em></span><em class="italic"><span class="koboSpan" id="kobo.232.1">.7</span></em><span class="koboSpan" id="kobo.233.1">. </span><span class="koboSpan" id="kobo.233.2">The retail outlet wants to predict 3 months of daily sales and update their predictions every month (this is probably a more realistic use of the forecast; these parameters are reversed in the image merely to avoid overlapping the horizons to keep the </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">image clear).</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">We begin our training with an initial period of 2 years, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">'730 days'</span></strong><span class="koboSpan" id="kobo.237.1">. </span><span class="koboSpan" id="kobo.237.2">We set </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">horizon='90 days'</span></strong><span class="koboSpan" id="kobo.239.1"> to evaluate our forecast over a 90-day prediction interval. </span><span class="koboSpan" id="kobo.239.2">And finally, we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">period='30 days'</span></strong><span class="koboSpan" id="kobo.241.1">, so we retrain and re-evaluate our model every 30 days. </span><span class="koboSpan" id="kobo.241.2">This results in a total of 10 forecasts to compare with the final year </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">of data.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">You may also specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">cutoff</span></strong><span class="koboSpan" id="kobo.245.1"> values, but this is usually unnecessary. </span><span class="koboSpan" id="kobo.245.2">However, we’ll cover a specific instance in </span><a href="B19630_13.xhtml#_idTextAnchor839"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.246.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.247.1">, </span><em class="italic"><span class="koboSpan" id="kobo.248.1">Evaluating Performance Metrics</span></em><span class="koboSpan" id="kobo.249.1">, where you will want to set them yourself. </span><span class="koboSpan" id="kobo.249.2">Prophet’s default behavior is to set them automatically by working backward from the end of the </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">time series.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">Now, let’s take a look at this DataFrame by displaying the first </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">five rows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
df_cv.head()</span></pre>
<p><span class="koboSpan" id="kobo.254.1">If you run that code in a Jupyter</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.255.1"> notebook, you’ll see the following formatted output (your values for </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">yhat_lower</span></strong><span class="koboSpan" id="kobo.257.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">yhat_upper</span></strong><span class="koboSpan" id="kobo.259.1"> may slightly differ due to randomness in the </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">optimization algo</span><a id="_idTextAnchor828"/><span class="koboSpan" id="kobo.261.1">rithms):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer252">
<span class="koboSpan" id="kobo.262.1"><img alt="Figure 12.8 – The cross-validation DataFrame" src="image/Fig_12.8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.263.1">Figure 12.8 – The cross-validation DataFrame</span></p>
<p><span class="koboSpan" id="kobo.264.1">For each unique </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">cutoff</span></strong><span class="koboSpan" id="kobo.266.1"> in the DataFrame, you will find 90 days in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">ds</span></strong><span class="koboSpan" id="kobo.268.1"> column, corresponding to the 90-day horizon. </span><span class="koboSpan" id="kobo.268.2">Each date in </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">ds</span></strong><span class="koboSpan" id="kobo.270.1"> has a true value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">y</span></strong><span class="koboSpan" id="kobo.272.1">, which is the same value from your training data, </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">df['y']</span></strong><span class="koboSpan" id="kobo.274.1">, and the value forecast in that fold for that date in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">yhat</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.276.1"> column.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">Note that this is a different </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">yhat</span></strong><span class="koboSpan" id="kobo.279.1"> from that in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">forecast</span></strong><span class="koboSpan" id="kobo.281.1"> DataFrame, as those val</span><a id="_idTextAnchor829"/><span class="koboSpan" id="kobo.282.1">ues were calculated with the full dataset, not with a cross-validated fold. </span><span class="koboSpan" id="kobo.282.2">The cross-validation DataFrame also contains uncertainty intervals for these forecasts, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">yhat_upper</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.284.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">yhat_lower</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.287.1">This DataFrame allows you to compare forecasted values with actual values across the range of date-time values in your data. </span><span class="koboSpan" id="kobo.287.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">forecast</span></strong><span class="koboSpan" id="kobo.289.1"> DataFrame, all </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">yhat</span></strong><span class="koboSpan" id="kobo.291.1"> values for dates in the future obviously have no true </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">y</span></strong><span class="koboSpan" id="kobo.293.1"> value for comparison. </span><span class="koboSpan" id="kobo.293.2">For dates in the past, there is a corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">df['y']</span></strong><span class="koboSpan" id="kobo.295.1"> value to compare your </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">forecast['yhat']</span></strong><span class="koboSpan" id="kobo.297.1"> value with, but the forecast was trained on this value. </span><span class="koboSpan" id="kobo.297.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">forecast['yhat']</span></strong><span class="koboSpan" id="kobo.299.1"> values are biased, whereas the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">df_cv['yhat']</span></strong><span class="koboSpan" id="kobo.301.1"> values are unbiased and therefore will provide a more accurate</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.302.1"> representation of what you can expect your model to predict on new, </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">uns</span><a id="_idTextAnchor830"/><a id="_idTextAnchor831"/><span class="koboSpan" id="kobo.304.1">een data.</span></span></p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor832"/><span class="koboSpan" id="kobo.305.1">Parallelizing cross-validation</span></h1>
<p><span class="koboSpan" id="kobo.306.1">There is</span><a id="_idTextAnchor833"/><span class="koboSpan" id="kobo.307.1"> a lot of iteration</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.308.1"> going on during cross-validation and these are tasks that can be parallelized to speed things up. </span><span class="koboSpan" id="kobo.308.2">All you need to do to take advantage of this is use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">parallel</span></strong><span class="koboSpan" id="kobo.310.1"> keyword. </span><span class="koboSpan" id="kobo.310.2">There are four options you may choose: </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">None</span></strong><span class="koboSpan" id="kobo.312.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">'processes'</span></strong><span class="koboSpan" id="kobo.314.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">'threads'</span></strong><span class="koboSpan" id="kobo.316.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">'dask'</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
df_cv = cross_validation(model,
                         horizon='90 days',
                         period=›30 days›,
                         initial='730 days',
                         parallel='processes›'</span></pre>
<p><span class="koboSpan" id="kobo.321.1">Setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">parallel='processes'</span></strong><span class="koboSpan" id="kobo.323.1"> uses Python’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">concurrent.futures.ProcessPoolExecutor</span></strong><span class="koboSpan" id="kobo.325.1"> class, whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">parallel='threads'</span></strong><span class="koboSpan" id="kobo.327.1"> uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">concurrent.futures.ThreadPoolExecutor</span></strong><span class="koboSpan" id="kobo.329.1">. </span><span class="koboSpan" id="kobo.329.2">If you’re unsure which of these to use, go with </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">'processes'</span></strong><span class="koboSpan" id="kobo.331.1">. </span><span class="koboSpan" id="kobo.331.2">It will give the best performance on a </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">single machine.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">None</span></strong><span class="koboSpan" id="kobo.334.1"> will per</span><a id="_idTextAnchor834"/><span class="koboSpan" id="kobo.335.1">form no parallelism, which can be good if you plan to do other work on yo</span><a id="_idTextAnchor835"/><span class="koboSpan" id="kobo.336.1">ur machine while Prophet calculates and you don’t want Prophet to take up all of your machine’s resources. </span><span class="koboSpan" id="kobo.336.2">If using </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">'dask'</span></strong><span class="koboSpan" id="kobo.338.1">, you will need to install Dask separately and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">Client</span></strong><span class="koboSpan" id="kobo.340.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">dask.distributed</span></strong><span class="koboSpan" id="kobo.342.1"> to connect to the cluster (the following code will result in an error if Dask has not been separately installed and </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">set up):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">
from dask.distributed import Client
client = Client()
df_cv = cross_validation(model,
                         horizon='90 days',
                         period='30 days',
                         initial='730 days',
                         parallel='dask')</span></pre>
<p><span class="koboSpan" id="kobo.345.1">Although you can use Dask on your laptop, its power really comes into effect when using multiple computing</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.346.1"> clusters across many machines. </span><span class="koboSpan" id="kobo.346.2">If you don’t have access to this type of computing power, </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">parallel='processes'</span></strong><span class="koboSpan" id="kobo.348.1"> will usually be the </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">fas</span><a id="_idTextAnchor836"/><a id="_idTextAnchor837"/><span class="koboSpan" id="kobo.350.1">ter option.</span></span></p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor838"/><span class="koboSpan" id="kobo.351.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.352.1">We began this chapter with a discussion of why k-fold cross-validation was developed in traditional machine learning applications, and we then learned why it will not work with time series. </span><span class="koboSpan" id="kobo.352.2">You then learned about forward-chaining, also called rolling-origin cross-validation, for use with time </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">series data.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">You learned the keywords of </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">initial</span></strong><span class="koboSpan" id="kobo.356.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">horizon</span></strong><span class="koboSpan" id="kobo.358.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">period</span></strong><span class="koboSpan" id="kobo.360.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">cutoff</span></strong><span class="koboSpan" id="kobo.362.1">, which are used to define your cross-validation parameters, and you learned how to implement them in Prophet. </span><span class="koboSpan" id="kobo.362.2">Finally, you learned the different options Prophet has for parallelization in order to speed up </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">model evaluation.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">These techniques provide you with a statistically robust way to evaluate and compare models. </span><span class="koboSpan" id="kobo.364.2">By isolating the data used in training and testing, you remove any bias in the process and can be more certain that your model will perform well when making </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">new predictions.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">In the next chapter, you’ll apply what you learned here to measure your model’s performance and tune it for </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">optimal results.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer254">
</div>
</div>
</body></html>