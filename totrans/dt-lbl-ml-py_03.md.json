["```py\nimport pandas as pd\n# Load the labeled data\ndf_labeled = pd.read_csv('housing.csv')\n```", "```py\n# Compute the summary statistics for each feature by target label\nsummary_stats = df.groupby('median_house_value').describe()\n```", "```py\n# Load the unlabeled data\ndf_unlabeled = pd.read_csv(''housing_unlabled.csv')\n```", "```py\n# Predict the target label for each data point in the unlabeled data\nfor i, row in df_unlabeled.iterrows():\n```", "```py\n# Compute the distances to each target label's summary statistics\ndists = {}\n```", "```py\nfor target in summary_stats.index:\n```", "```py\ndist = 0\nfor col in df_unlabeled.columns:\n```", "```py\nif col != 'median_house_value':\n```", "```py\ndist += (row[col] - summary_stats.loc[target, (col, 'mean')]) ** 2\n```", "```py\ndists[target] = dist\n# Select the target label with the minimum distance\npredicted_target = min(dists, key=dists.get)\n# Assign the predicted target label to the current row\ndf_unlabeled.at[i, 'median_house_value'] = predicted_target\n```", "```py\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nimport numpy as np\n```", "```py\n# Load the data\ndata = pd.read_csv(\"housing_data.csv\")\n# Split the labeled data into training and testing sets\ntrain_data, test_data, train_labels, test_labels = \\\n    train_test_split(labeled_data.drop('price', axis=1), \\\n        labeled_data['price'], test_size=0.2)\n```", "```py\n# Train a linear regression model on the labeled data\nregressor = LinearRegression()\nregressor.fit(train_data, train_labels)\n```", "```py\n# Use the trained model to predict the labels of the unlabeled data\npredicted_labels = regressor.predict(\n    unlabeled_data.drop('price', axis=1))\n```", "```py\n# Combine the labeled and newly predicted data\nnew_data = pd.concat([labeled_data, unlabeled_data], ignore_index=True)\nnew_data['price'] = pd.concat([train_labels, \\\n    pd.Series(predicted_labels)], ignore_index=True)\n```", "```py\n# Train a new model on the combined data\nnew_train_data, new_test_data, new_train_labels, new_test_labels = \\\n    train_test_split(new_data.drop('price', axis=1), \\\n    new_data['price'], test_size=0.2)\nnew_regressor = LinearRegression()\nnew_regressor.fit(new_train_data, new_train_labels)\n```", "```py\n# Evaluate the performance of the new model on the test data\nscore = new_regressor.score(new_test_data, new_test_labels)\nprint(\"R^2 Score: \", score)\n```", "```py\nimport pandas as pd\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.model_selection import train_test_split\nimport random\n```", "```py\n# Load the available labeled data\ndf = pd.read_csv(\"labeled_data.csv\")\n```", "```py\n# Define the data augmentation techniques\ndef add_noise(x, std):\n    noise = np.random.normal(0, std, len(x))\n    return x + noise\n# Define the range of data augmentation parameters\nnoise_range = [0.1, 0.2, 0.3]\n```", "```py\n# Generate augmented data\naugmented_data = []\nfor _, row in df.iterrows():\n    for noise in noise_range:\n        new_row = row.copy()\n        new_row[\"price\"] = add_noise(row[\"price\"], noise)\n        augmented_data.append(new_row)\n```", "```py\ndef scale(x, factor):\n    return x * factor\nscale_range = [0.5, 0.75, 1.25, 1.5]\n```", "```py\nfor scale_factor in scale_range:\n    new_row = row.copy()\n    new_row[\"price\"] = scale(row[\"price\"], scale_factor)\n    augmented_data.append(new_row)\n```", "```py\n# Combine the original data and the augmented data\ncombined_data = pd.concat([df, pd.DataFrame(augmented_data)])\n```", "```py\n# Split the data into training and testing sets\nX = combined_data.drop(\"price\", axis=1)\ny = combined_data[\"price\"]\nX_train, X_test, y_train, y_test = train_test_split(X, y, \\\n    test_size=0.2, random_state=42)\n# Train a linear regression model\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n# Evaluate the model\ny_pred = model.predict(X_test)\nmse = mean_squared_error(y_test, y_pred)\nprint(\"Mean Squared Error:\", mse)\n```", "```py\nimport numpy as np\nfrom sklearn.cluster import KMeans\nfrom sklearn.metrics import mean_squared_error\n# Define labelled and unlabelled data\nlabelled_data = np.array([\n[-122.23, 37.88, 41.0, 880.0, 129.0, 322.0, 126.0, 8.3252, 452600.0],\n[-122.22, 37.86, 21.0, 7099.0, 1106.0, 2401.0, 1138.0, 8.3014, 358500.0]\n])\nunlabelled_data = np.array([\n[-122.22, 47.86, 20.0, 7099.0, 1106.0, 2401.0, 1138.0, 8.3014, 0.0]\n])\n# Extract features and labels from labelled data\nlabelled_features = labelled_data[:, :-1]\nlabelled_labels = labelled_data[:, -1]\n```", "```py\n# Train K-means clustering model\nn_clusters = 2 # Number of clusters (you can adjust this)\nkmeans_model = KMeans(n_clusters=n_clusters)\nkmeans_model.fit(labelled_features)\n```", "```py\n# Predict cluster labels for unlabelled data\nunlabelled_clusters = kmeans_model.predict(unlabelled_data[:, :-1])\n```", "```py\n# Calculate average prices for each cluster\ncluster_avg_prices = []\nfor cluster_idx in range(n_clusters):\n    cluster_mask = (kmeans_model.labels_ == cluster_idx)\n    cluster_avg_price = np.mean(labelled_labels[cluster_mask])\n    cluster_avg_prices.append(cluster_avg_price)\n```", "```py\n# Assign predicted prices to unlabeled data\npredicted_prices = np.array([cluster_avg_prices[cluster] \\\n    for cluster in unlabelled_clusters])\n```", "```py\nprint(\"Predicted Prices for Unlabelled Data:\", predicted_prices)\n```", "```py\n# Combine the labeled and newly predicted data\nnew_data = pd.concat([labeled_data, unlabeled_data], ignore_index=True)\nnew_data['price'] = pd.concat([train_labels, \\\n    pd.Series(predicted_labels)], ignore_index=True)\n# Train a new model on the combined data\nnew_train_data, new_test_data, new_train_labels, new_test_labels = \\\n    train_test_split(new_data.drop('price', axis=1), \\\n    new_data['price'], test_size=0.2)\nnew_regressor = LinearRegression()\nnew_regressor.fit(new_train_data, new_train_labels)\n# Evaluate the performance of the new model on the test data\nscore = new_regressor.score(new_test_data, new_test_labels)\nprint(\"R^2 Score: \", score)\n```"]