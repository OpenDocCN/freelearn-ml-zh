- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: The History and Development of Time Series Forecasting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列预测的历史与发展
- en: '**Prophet** is a powerful tool for creating, visualizing, and optimizing your
    forecasts! With Prophet, you’ll be able to understand what factors will drive
    your future results, which will enable you to make more confident decisions. You
    accomplish these tasks and goals through an intuitive but very flexible programming
    interface that is designed for both the beginner and expert alike.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Prophet** 是一个强大的工具，用于创建、可视化和优化您的预测！使用 Prophet，您将能够理解哪些因素将推动您的未来结果，这将使您能够做出更有信心的决策。您将通过一个直观但非常灵活的编程界面来完成这些任务和目标，这个界面旨在为初学者和专家
    alike。'
- en: You don’t need a deep knowledge of the math or statistics behind time series
    forecasting techniques to leverage the power of Prophet, although if you do possess
    this knowledge, Prophet includes a rich feature set that allows you to deploy
    your experience to great effect. You’ll be working in a structured paradigm where
    each problem follows the same pattern, allowing you to spend less time figuring
    out how to optimize your forecasts and more time discovering key insights to supercharge
    your decisions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要对时间序列预测技术背后的数学或统计知识有深入的了解，就可以利用 Prophet 的强大功能。尽管如果您具备这些知识，Prophet 还包括丰富的功能集，让您能够将您的经验发挥到极致。您将在一个结构化的范式下工作，其中每个问题都遵循相同的模式，这样您可以花更少的时间去优化您的预测，更多的时间去发现关键见解，从而增强您的决策。
- en: 'This chapter introduces the foundational ideas behind time series forecasting
    and discusses some of the key model iterations that eventually led to the development
    of Prophet. In this chapter, you’ll learn what time series data is and why it
    must be handled differently than non-time series data, and then you’ll discover
    the most powerful innovations, of which Prophet is one of the latest. Specifically,
    we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了时间序列预测背后的基本思想，并讨论了一些关键模型迭代，这些迭代最终导致了 Prophet 的开发。在本章中，您将了解时间序列数据是什么，以及为什么它必须与非时间序列数据不同处理，然后您将发现其中最强大的创新，其中
    Prophet 是最新的之一。具体来说，我们将涵盖以下主题：
- en: Understanding time series forecasting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解时间序列预测
- en: Moving averages and exponential smoothing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动平均和指数平滑
- en: ARIMA
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARIMA
- en: ARCH/GARCH
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARCH/GARCH
- en: Neural networks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神经网络
- en: Prophet
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prophet
- en: Recent developments
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近期发展
- en: Understanding time series forecasting
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解时间序列预测
- en: A **time series** is a set of data collected sequentially over time. For example,
    think of any chart where the *x a*xis is some measurement of time—anything from
    the number of stars in the universe since the Big Bang until today or the amount
    of energy released each nanosecond from a nuclear reaction. The data behind both
    is time series. The chart in the weather app on your phone showing the expected
    temperature for the next 7 days? That’s also the plot of a time series.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间序列**是一组按时间顺序收集的数据。例如，想想任何图表，其中*x*轴是时间的某种度量——从大爆炸以来宇宙中的星星数量，到每次核反应中每纳秒释放的能量。这两者背后的数据都是时间序列。您手机上天气应用中显示的接下来7天的预期温度？这也是一个时间序列的图。'
- en: In this book, we are mostly concerned with events on the human scales of years,
    months, days, and hours, but all of this is time series data. Predicting future
    values is the act of forecasting.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们主要关注人类尺度上的事件，如年、月、日和小时，但所有这些都是时间序列数据。预测未来值就是预测的行为。
- en: Forecasting the weather has obviously been important to humans for millennia,
    particularly since the advent of agriculture. In fact, over 2,300 years ago, the
    Greek philosopher Aristotle wrote a treatise called *Meteorology* that contained
    a discussion of early weather forecasting. The very word *forecast* was coined
    by an English meteorologist in the 1850s, Robert FitzRoy, who achieved fame as
    the captain of the *HMS Beagle* during Charles Darwin’s pioneering voyage.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 预测天气显然对人类来说自古以来就很重要，尤其是在农业出现之后。事实上，2300多年前，希腊哲学家亚里士多德撰写了一篇名为《气象学》的论文，其中讨论了早期的天气预报。实际上，“预测”这个词是在19世纪50年代由一位英国气象学家罗伯特·菲茨罗伊创造的，他在查尔斯·达尔文的开拓性航行中作为“贝格尔号”的船长而闻名。
- en: However, time series data is not unique to weather. The field of medicine adopted
    time series analysis techniques with the 1901 invention of the first practical
    **electrocardiogram** (**ECG**) by the Dutch physician Willem Einthoven. The ECG
    produces the familiar pattern of heartbeats we now see on the machine next to
    a patient’s bed in every medical drama.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，时间序列数据并不仅限于天气。医学领域在1901年由荷兰医生威廉·埃因托芬发明了第一台实用的**心电图**（**ECG**）后，采用了时间序列分析技术。心电图产生了我们现在在医疗剧中看到的患者床边的熟悉的心跳模式。
- en: Today, one of the most discussed fields of forecasting is economics. There are
    entire television channels dedicated to analyzing trends in the stock market.
    Governments use economic forecasting to advise central bank policy, politicians
    use economic forecasting to develop their platforms, and business leaders use
    economic forecasting to guide their decisions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，最被讨论的预测领域之一是经济学。有整个电视频道致力于分析股市的趋势。政府使用经济预测来咨询中央银行政策，政治家使用经济预测来发展他们的平台，而商业领袖使用经济预测来指导他们的决策。
- en: In this book, we will be forecasting topics as varied as carbon dioxide levels
    in the atmosphere, the number of riders on Chicago’s public bike share program,
    the growth of the wolf population in Yellowstone, the solar sunspot cycles, local
    rainfall, and even Instagram likes on some popular accounts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将预测各种主题，如大气中的二氧化碳水平、芝加哥公共自行车共享项目的骑行者数量、黄石公园狼群的增长、太阳黑子周期、当地降雨量，甚至某些热门账户的Instagram点赞数。
- en: The problem with dependent data
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖数据的难题
- en: So, why does time series forecasting require its own unique approach? From a
    statistical perspective, you might see a scatter plot of time series with a relatively
    clear trend and attempt to fit a line using standard regression—the technique
    for fitting a straight line to data. The problem is that this violates the assumption
    of independence that linear regression demands.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么时间序列预测需要独特的方法呢？从统计学的角度来看，你可能会看到时间序列的散点图，其中有一个相对清晰的趋势，并尝试使用标准回归——将直线拟合到数据的技术来拟合一条线。问题是这违反了线性回归所要求的独立性假设。
- en: To illustrate time series dependence with an example, let’s say that a gambler
    is rolling an unbiased die. I tell you that they just rolled a 2 and ask what
    the next value will be. This data is independent; previous rolls have no effect
    on future rolls, so knowing that the previous roll was a 2 does not provide any
    information about the next roll.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了用例子说明时间序列的依赖性，让我们假设一个赌徒正在掷一个公平的骰子。我告诉你他们刚刚掷出了一个2，然后问你下一个值会是什么。这些数据是独立的；之前的掷骰子对未来的掷骰子没有影响，所以知道之前的掷骰子是2并不提供关于下一个掷骰子的任何信息。
- en: However, in a different situation, let’s say that I call you from an undisclosed
    location somewhere on Earth and ask you to guess the temperature at my location.
    Your best bet would be to guess some average global temperature for that day.
    Now, imagine that I tell you that yesterday’s temperature at my location was 90°F.
    That provides a great deal of information to you because you intuitively know
    that yesterday’s temperature and today’s temperature are linked in some way; they
    are not independent.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在另一种情况下，比如我从一个未公开的地球上的地点给你打电话，让你猜测我所在地点的温度。你最好的猜测是猜测当天的平均全球温度。现在，想象一下我告诉你昨天我所在地点的温度是90°F。这为你提供了大量的信息，因为你直觉上知道昨天的温度和今天的温度以某种方式相关联；它们不是独立的。
- en: With time series data, you cannot randomly shuffle the order of data without
    disturbing the trends, within a reasonable margin of error. The order of the data
    matters; it is not independent. When data is dependent like this, a regression
    model can show statistical significance by random chance, even when there is no
    true correlation, much more often than your chosen confidence level would suggest.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列数据中，你不能随机打乱数据的顺序而不破坏趋势，在合理的误差范围内。数据的顺序很重要；它不是独立的。当数据像这样依赖时，回归模型可以通过随机机会显示出统计显著性，即使没有真正的相关性，也比你所选择的置信水平所暗示的更频繁。
- en: Because high values tend to follow high values and low values tend to follow
    low values, a time series dataset is more likely to show more clusters of high
    or low values than would otherwise be present, and this, in turn, can lead to
    the appearance of more correlations than would otherwise be present.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因为高值往往跟随高值，低值往往跟随低值，所以时间序列数据集更有可能显示出比其他情况下更多的高值或低值集群，而这反过来又可能导致出现比其他情况下更多的相关性。
- en: 'The website *Spurious Correlations* by Tyler Vigen specializes in pointing
    out examples of seemingly significant, but utterly ridiculous, time series correlations.
    Here is one example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Tyler Vigen 的网站 *Spurious Correlations* 专门指出看似重要但实际上荒谬的时间序列关联的例子。以下是一个例子：
- en: '![Figure 1.1 – A spurious time series correlation (https://www.tylervigen.com/spurious-correlations)](img/Fig_1.1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 一个虚假的时间序列关联（https://www.tylervigen.com/spurious-correlations）](img/Fig_1.1.jpg)'
- en: Figure 1.1 – A spurious time series correlation (https://www.tylervigen.com/spurious-correlations)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 一个虚假的时间序列关联（https://www.tylervigen.com/spurious-correlations）
- en: Obviously, the number of people who drown in pools each year is completely independent
    of the number of films Nicolas Cage appears in. They simply have no effect on
    each other at all. However, by making the fallacy of treating time series data
    as if it were independent, Vigen has shown that by pure random chance, the two
    series of data do, in fact, correlate significantly. These types of random chances
    are much more likely to happen when ignoring dependence in time series data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，每年在游泳池中溺水的人数与尼古拉斯·凯奇出演的电影数量完全无关。它们之间没有任何影响。然而，通过将时间序列数据视为独立数据的谬误，Vigen 已经表明，纯粹是随机机会，这两组数据确实存在显著的关联。当忽略时间序列数据中的依赖性时，这种随机机会更有可能发生。
- en: Now that you understand what exactly time series data is and what sets it apart
    from other datasets, let’s look at a few milestones in the development of models,
    from the earliest models up to Prophet.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了时间序列数据究竟是什么，以及它与其他数据集的区别，让我们来看看模型发展历程中的几个里程碑，从最早的模型到 Prophet。
- en: Moving averages and exponential smoothing
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动平均和指数平滑
- en: Possibly the simplest form of forecasting is the **moving average** (**MA**).
    Often, an MA is used as a **smoothing technique** to find a straighter line through
    data with a lot of variation. Each data point is adjusted to the value of the
    average of *n* surrounding data points, with *n* being referred to as the window
    size. With a window size of 10, for example, we would adjust a data point to be
    the average of the 5 values before and the 5 values after. In a forecasting setting,
    the future values are calculated as the average of the *n* previous values, so
    again, with a window size of 10, this means the average of the 10 previous values.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最简单的预测形式是 **移动平均**（**MA**）。通常，移动平均被用作 **平滑技术**，以在变化很大的数据中找到一条更直的线。每个数据点都调整到周围
    *n* 个数据点的平均值，其中 *n* 被称为窗口大小。例如，窗口大小为 10 时，我们会调整一个数据点，使其成为之前 5 个值和之后 5 个值的平均值。在预测环境中，未来值被计算为
    *n* 个先前值的平均值，因此，窗口大小为 10 时，这意味着 10 个先前值的平均值。
- en: The balancing act with an MA is that you want a large window size in order to
    smooth out the noise and capture the actual trend, but with a larger window size,
    your forecasts are going to lag the trend significantly as you reach back further
    and further to calculate the average. The idea behind **exponential smoothing**
    is to apply exponentially decreasing weights to the values being averaged over
    time, giving recent values more weight and older values less weight. This allows
    the forecast to be more reactive to changes while still ignoring a good deal of
    noise.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用移动平均的平衡行为是，您希望有一个大的窗口大小来平滑噪声并捕捉实际趋势，但随着窗口大小的增大，您的预测将显著滞后趋势，因为您需要回溯得更远来计算平均值。指数平滑背后的思想是对随时间平均的值应用指数递减的权重，给近期值更多的权重，给较远期值更少的权重。这允许预测对变化更加敏感，同时仍然忽略大量噪声。
- en: 'As you can see in the following plot of simulated data, the MA line exhibits
    much rougher behavior than the exponential smoothing line, but both lines still
    adjust to trend changes at the same time:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下模拟数据的图中所示，移动平均线的行为比指数平滑线更粗糙，但两条线仍然同时调整趋势变化：
- en: '![Figure 1.2 – MA versus exponential smoothing](img/Fig_1.2.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 移动平均与指数平滑](img/Fig_1.2.jpg)'
- en: Figure 1.2 – MA versus exponential smoothing
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 移动平均与指数平滑
- en: Exponential smoothing originated in the 1950s with **simple exponential smoothing**,
    which does not allow for trends or seasonality. Charles Holt advanced the technique
    in 1957 to allow for a trend with what he called **double exponential smoothing**;
    and in collaboration with Peter Winters, Holt added seasonality support in 1960,
    in what is commonly called **Holt-Winters** **exponential smoothing**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 指数平滑法起源于20世纪50年代，其最初形式为**简单指数平滑法**，不允许趋势或季节性。查尔斯·霍尔特在1957年将技术提升到允许趋势，他称之为**双指数平滑法**；与彼得·温特斯合作，霍尔特在1960年增加了季节性支持，这通常被称为**霍尔特-温特斯指数平滑法**。
- en: The downside to these methods of forecasting is that they can be slow to adjust
    to new trends and so forecasted values lag behind reality—they do not hold up
    well to longer forecasting timeframes, and there are many hyperparameters to tune,
    which can be a difficult and very time-consuming process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些预测方法的缺点是它们对新趋势的调整可能较慢，因此预测值落后于现实——它们在较长的预测时间框架中表现不佳，并且有许多超参数需要调整，这可能是一个困难且非常耗时的过程。
- en: ARIMA
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARIMA
- en: 'In 1970, the mathematicians George Box and Gwilym Jenkins published *Time Series:
    Forecasting and Control*, which described what is now known as the **Box-Jenkins
    model**. This methodology took the idea of the MA further with the development
    of **ARIMA**. As a term, ARIMA is often used interchangeably with Box-Jenkins,
    although technically, Box-Jenkins refers to a method of parameter optimization
    for an ARIMA model.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在1970年，数学家乔治·博克斯和Gwilym Jenkins发表了《时间序列：预测与控制》，其中描述了现在所知的**博克斯-詹金斯模型**。这种方法通过开发**ARIMA**将MA的概念进一步发展。作为一个术语，ARIMA通常与博克斯-詹金斯互换使用，尽管技术上，博克斯-詹金斯指的是ARIMA模型的参数优化方法。
- en: 'ARIMA is an acronym that refers to three concepts: **Autoregressive** (**AR**),
    **Integrated** (**I**), and **MA**. We already understand the MA part. AR means
    that the model uses the dependent relationship between a data point and a certain
    number of lagged data points. That is, the model predicts upcoming values based
    on previous values. This is similar to predicting that it will be warm tomorrow
    because it’s been warm all week so far.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA是一个缩写，代表三个概念：**自回归**（**AR**）、**积分**（**I**）和**移动平均**（**MA**）。我们已经理解了MA部分。AR意味着模型使用数据点与一定数量的滞后数据点之间的依赖关系。也就是说，模型基于先前值预测未来的值。这与预测因为整个星期到目前为止都很暖和，所以明天将会很暖和相似。
- en: The **integrated** part means that instead of using any raw data point, the
    difference between that data point and a previous data point is used. Essentially,
    this means that we convert a series of values into a series of changes in values.
    Intuitively, this suggests that tomorrow will be more or less the same temperature
    as today because the temperature all week hasn’t varied too much.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**积分**部分意味着不是使用任何原始数据点，而是使用该数据点与先前数据点之间的差值。本质上，这意味着我们将一系列值转换为一系列值的变化。直观地，这表明明天的温度将与今天大致相同，因为整个星期温度变化不大。'
- en: Each of the AR, I, and MA components of an ARIMA model are explicitly specified
    as a parameter in the model. Traditionally, *p* is used for the number of lag
    observations to use, also known as the **lag order**. The number of times that
    a raw observation is differenced, or the degree of differencing, is known as *d*,
    and *q* represents the size of the MA window. Thus arises the standard notation
    for an ARIMA model of *ARIMA(p, d, q)*, where *p*, *d*, and *q* are all non-negative
    integers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA模型的AR、I和MA各个组成部分在模型中都被明确指定为一个参数。传统上，*p*用于表示要使用的滞后观测值的数量，也称为**滞后阶数**。原始观测值差分的次数或差分的程度称为*d*，而*q*代表MA窗口的大小。因此，ARIMA模型的标准表示为*ARIMA(p,
    d, q)*，其中*p*、*d*和*q*都是非负整数。
- en: A problem with ARIMA models is that they do not support seasonality, or data
    with repeating cycles, such as temperature rising in the day and falling at night
    or rising in summer and falling in winter. **Seasonal ARIMA** (**SARIMA**) was
    developed to overcome this drawback. Similar to the ARIMA notation, the notation
    for a SARIMA model is *SARIMA(p, d, q)(P, D, Q)m*, with *P* being the seasonal
    AR order, *D* the seasonal difference order, *Q* the seasonal MA order, and *m*
    the number of time steps for a single seasonal period.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA模型的一个问题是它们不支持季节性，或具有重复周期的数据，例如白天温度上升而夜晚下降，或夏季上升而冬季下降。**季节性ARIMA**（**SARIMA**）是为了克服这一缺点而开发的。与ARIMA表示法类似，SARIMA模型的表示法为*SARIMA(p,
    d, q)(P, D, Q)m*，其中*P*是季节性自回归阶数，*D*是季节性差分阶数，*Q*是季节性移动平均阶数，而*m*是单个季节周期的时间步数。
- en: You may also come across other variations of ARIMA models, including **Vector
    ARIMA** (**VARIMA**) for cases with multiple time series as vectors; **Fractional
    ARIMA** (**FARIMA**) or **Autoregressive Fractionally Integrated** **Moving Average**
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可能遇到ARIMA模型的其它变体，包括**向量ARIMA**（**VARIMA**），用于具有多个时间序列作为向量的情况；**分数ARIMA**（**FARIMA**）或**自回归分数积分移动平均**。
- en: '**PD: Style as P-Keyword** (**ARFIMA**), both of which include a fractional
    differencing degree, allowing for long memory in the sense that observations far
    apart in time can have non-negligible dependencies; and **SARIMAX**, a **seasonal
    ARIMA** model where the *X* stands for exogenous or additional variables added
    to the model, such as adding a rain forecast to a temperature model.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**PD：作为P关键字的风格**（**ARFIMA**），两者都包括分数差分度，允许在时间上相隔较远的观测值具有非可忽略的依赖性；以及**SARIMAX**，这是一个**季节性ARIMA**模型，其中*X*代表添加到模型中的外生或额外变量，例如将降雨预报添加到温度模型中。'
- en: ARIMA does typically exhibit very good results, but the downside is its complexity.
    Tuning and optimizing ARIMA models is often computationally expensive and successful
    results can depend upon the skill and experience of the forecaster. It is not
    a scalable process, but better suited to ad hoc analyses by skilled practitioners.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA通常表现出非常好的结果，但其缺点是复杂性。调整和优化ARIMA模型通常计算成本高昂，成功的结果可能取决于预测者的技能和经验。这不是一个可扩展的过程，更适合熟练从业者进行临时分析。
- en: ARCH/GARCH
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARCH/GARCH
- en: When the variance of a dataset is not constant over time, ARIMA models face
    problems with modeling it. In economics and finance, in particular, this is common.
    In a financial time series, large returns tend to be followed by large returns
    and small returns tend to be followed by small returns. The former is called **high
    volatility**, and the latter is **low volatility**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据集的方差随时间变化时，ARIMA模型在建模时会遇到问题。特别是在经济学和金融学中，这是常见的。在金融时间序列中，大回报往往伴随着大回报，而小回报往往伴随着小回报。前者称为**高波动性**，后者称为**低波动性**。
- en: '**Autoregressive Conditional Heteroscedasticity** (**ARCH**) models were developed
    to solve this problem. **Heteroscedasticity** is a fancy way of saying that the
    variance or spread of the data is not constant throughout, with the opposite term
    being **homoscedasticity**. The difference is visualized here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**自回归条件异方差**（**ARCH**）模型是为了解决这个问题而开发的。**异方差性**是一种说法，意味着数据的变化或分布在整个过程中不是恒定的，其对立术语是**同方差性**。差异在此可视化：'
- en: '![Figure 1.3 – Scedasticity](img/Fig_1.3.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 斯凯迪斯提](img/Fig_1.3.jpg)'
- en: Figure 1.3 – Scedasticity
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 斯凯迪斯提
- en: Robert Engle introduced the first ARCH model in 1982 by describing **conditional
    variance** as a function of previous values. For example, there is a lot more
    uncertainty about daytime electricity usage than there is about nighttime usage.
    In a model of electricity usage, then, we might assume that the daytime hours
    have a particular variance, and usage during the night would have a lower variance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伯特·恩格尔于1982年首次介绍了ARCH模型，通过将**条件方差**描述为先前值的函数。例如，白天用电量的不确定性远大于夜间用电量。因此，在电力使用模型中，我们可能会假设白天的小时数具有特定的方差，而夜间使用则具有较低的方差。
- en: Tim Bollerslev and Stephen Taylor introduced a moving average component to the
    model in 1986 with their **Generalized ARCH** (**GARCH**) model. In the electricity
    example, the variance in usage was a function of the time of day, but perhaps
    the swings in volatility don’t necessarily occur at specific times of the day,
    and the swings themselves are random. This is when GARCH is useful.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 1986年，蒂姆·博勒尔塞夫和斯蒂芬·泰勒在他们的**广义ARCH**（**GARCH**）模型中引入了移动平均成分。在电力示例中，使用量方差是时间的函数，但波动性的波动可能并不一定发生在特定的时间，波动本身是随机的。这就是GARCH发挥作用的时候。
- en: Both ARCH and GARCH models can handle neither trend nor seasonality though,
    so often, in practice, an ARIMA model may be built first to extract out the seasonal
    variation and trend of a time series, and then an ARCH model may be used to model
    the expected variance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ARCH和GARCH模型都无法处理趋势或季节性，但在实践中，通常首先构建ARIMA模型以提取时间序列的季节变化和趋势，然后使用ARCH模型来模拟预期的方差。
- en: Neural networks
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经网络
- en: A relatively recent development in time series forecasting is the use of **Recurrent
    Neural Networks** (**RNNs**). This was made possible with the development of the
    **Long Short-Term Memory** (**LSTM**) unit by Sepp Hochreiter and Jürgen Schmidhuber
    in 1997\. Essentially, an LSTM unit allows a neural network to process a sequence
    of data, such as speech or video, instead of a single data point, such as an image.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列预测中相对较新的发展是使用**循环神经网络**（**RNNs**）。这得益于Sepp Hochreiter和Jürgen Schmidhuber在1997年开发的**长短期记忆**（**LSTM**）单元。本质上，LSTM单元允许神经网络处理一系列数据，如语音或视频，而不是单个数据点，如图像。
- en: A standard RNN is called *recurrent* because it has loops built into it, which
    is what gives it memory, that is, gives it access to previous information. A basic
    neural network can be trained to recognize an image of a pedestrian on a street
    by learning what a pedestrian looks like from previous images, but it cannot be
    trained to identify that a pedestrian in a video will soon be crossing the street
    based upon the pedestrian’s approach observed in previous frames of the video.
    It has no knowledge of the sequence of images that leads to the pedestrian stepping
    out into the road. Short-term memory is what the network needs temporarily to
    provide context, but that memory degrades quickly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的循环神经网络（RNN）被称为“循环”是因为它内部有循环结构，这赋予了它记忆能力，也就是说，它能够访问之前的信息。一个基本的神经网络可以通过学习从之前的图像中识别行人的样子来训练识别街道上的行人图像，但它不能通过观察视频之前帧中行人的接近来训练识别视频中行人即将过马路。它没有关于导致行人走上马路的图像序列的知识。短期记忆是网络需要暂时提供上下文的部分，但这种记忆很快就会退化。
- en: 'Early RNNs had a memory problem: it just wasn’t very long. In the sentence
    “*airplanes fly in the …*,” a simple RNN may be able to guess the next word will
    be *sky*, but with “*I went to France for vacation last summer. That’s why I spent
    my spring learning to speak …*,” it’s not so easy for the RNN to guess that *French*
    comes next; it understands that the word for a language should come next but has
    forgotten that the phrase started by mentioning France. An LSTM, though, has this
    necessary context. It gives the network’s short-term memory more longevity. In
    the case of time series data, where patterns can reoccur over long time scales,
    LSTMs can perform very well.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的RNN存在一个记忆问题：它的记忆时间非常短。在句子“*飞机在空中飞……*”中，一个简单的RNN可能能够猜测下一个词将是“天空”，但在“*我去年夏天去了法国度假。这就是为什么我在春天学习说……*”中，RNN猜测下一个词是“法语”就不再那么容易了；它理解语言应该接下来，但它忘记了短语是以提到法国开始的。然而，LSTM具有这种必要的上下文。它为网络的短期记忆提供了更长的寿命。在时间序列数据的情况下，其中模式可以在长时间尺度上重复，LSTM可以表现得非常好。
- en: Time series forecasting with LSTMs is still in its infancy when compared to
    the other forecasting methods discussed here; however, it shows promise. One strong
    advantage over other forecasting techniques is the ability of neural networks
    to capture non-linear relationships, but as with any deep learning problem, LSTM
    forecasting requires a great deal of data and computing power and a long processing
    time.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与这里讨论的其他预测方法相比，使用LSTM进行时间序列预测仍然处于初级阶段；然而，它显示出希望。与其他预测技术相比的一个强大优势是神经网络能够捕捉非线性关系，但与任何深度学习问题一样，LSTM预测需要大量的数据和计算能力，以及较长的处理时间。
- en: Additionally, there are many decisions to be made regarding the architecture
    of the model and the hyperparameters to be used, which necessitate a very experienced
    forecaster. In most practical problems, where budget and deadlines must be considered,
    an ARIMA model is often the better choice.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有许多关于模型架构和要使用的超参数的决定需要做出，这需要一个非常经验丰富的预测者。在大多数实际问题上，必须考虑预算和截止日期，ARIMA模型通常是更好的选择。
- en: Prophet
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Prophet
- en: 'Prophet was developed internally at Facebook (now known as **Meta**) by Sean
    J. Taylor and Ben Letham in order to overcome two issues often encountered with
    other forecasting methodologies: the more automatic forecasting tools available
    tended to be too inflexible and unable to accommodate additional assumptions,
    and the more robust forecasting tools required an experienced analyst with specialized
    data science skills. Facebook experienced too much demand for high-quality business
    forecasts than their analysts were able to provide. In 2017, Facebook released
    Prophet to the public as open source software.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Prophet was designed to optimally handle business forecasting tasks, which
    typically feature any of these attributes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Time series data captured at the hourly, daily, or weekly level with ideally
    at least a full year of historical data
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strong seasonality effects occurring daily, weekly, and/or yearly
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Holidays and other special one-time events that don’t necessarily follow the
    seasonality patterns but occur irregularly
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing data and outliers
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Significant trend changes that may occur with the launch of new features or
    products, for example
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trends that asymptotically approach an upper or lower bound
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of the box, Prophet typically produces very high-quality forecasts, but
    it is also very customizable and approachable for data analysts with no prior
    expertise in time series data. As you’ll see in later chapters, tuning a Prophet
    model is very intuitive.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, Prophet is an **additive regression model**. This means that the
    model is simply the sum of several (optional) components, such as the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: A linear or logistic growth trend curve
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An annual seasonality curve
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A weekly seasonality curve
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A daily seasonality curve
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Holidays and other special events
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional user-specified seasonality curves, such as hourly or quarterly, for
    example
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To take a concrete example, let’s say we are modeling the sales of a small
    online retail store over 4 years, from January 1, 2000, to the end of 2003\. We
    observe that the overall trend is constantly increasing over time from **1,000**
    sales per day to around **1,800** at the end of the time period. We also see that
    sales in spring are about **50** units above average and sales in autumn are about
    **50** units below average. Weekly, sales tend to be lowest on **Tuesday** and
    increase throughout the week, peaking on **Saturday**. Finally, throughout the
    hours of the day, sales peak at noon and smoothly fall to their lowest at midnight.
    This is what those individual curves would look like (note the different *x*-axis
    scales on each chart):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1.4 \uFEFF– Model components](img/Fig_1.4.jpg)"
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Model components
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'An additive model would take those four curves and simply add them to each
    other to arrive at the final model for sales throughout the years. The final curve
    gets more and more complex as the sub-components are added up:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Additive model](img/Fig_1.5.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Additive model
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 加性模型
- en: This preceding plot displays just the first year to see the weekly and daily
    variations better, but the full curve extends for 4 years.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此前的图表仅显示了前一年，以便更好地看到每周和每日的变化，但完整的曲线延伸了4年。
- en: Under the hood, Prophet is written in **Stan**, a probabilistic programming
    language (see the home page at [https://mc-stan.org/](https://mc-stan.org/) for
    more information about Stan). This has several advantages. It allows Prophet to
    optimize the fit process so that it typically completes in under a second. Stan
    is also compatible with both Python and R, so the Prophet team is able to share
    the same core fitting procedure between both language implementations. Also, by
    using Bayesian statistics, Stan allows Prophet to create uncertainty intervals
    for future predictions to add a data-driven estimate of forecasting risk.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，Prophet是用**Stan**编写的，这是一种概率编程语言（有关Stan的更多信息，请访问[https://mc-stan.org/](https://mc-stan.org/)）。这有几个优点。它允许Prophet优化拟合过程，使其通常在不到一秒内完成。Stan也与Python和R兼容，因此Prophet团队能够在两种语言实现之间共享相同的核心拟合过程。此外，通过使用贝叶斯统计，Stan允许Prophet为未来预测创建不确定性区间，从而添加数据驱动的预测风险估计。
- en: Prophet manages to achieve typical results just as well as more complicated
    forecasting techniques but with just a fraction of the effort. It has something
    for everyone. A beginner can build a highly accurate model in just a few lines
    of code without necessarily understanding the details of how everything works,
    while an expert can dig deep into the model, adding more features and tweaking
    hyperparameters to eke out incrementally better performance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet能够以典型的结果与更复杂的预测技术相媲美，但只需付出一小部分努力。它适合每个人。初学者只需几行代码就能构建一个高度准确的模型，而不必 necessarily理解一切工作的细节，而专家可以深入研究模型，添加更多功能，调整超参数以获得更好的性能。
- en: Recent developments
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最近的发展
- en: The public release of Prophet has inspired a lot of open source activity around
    forecasting packages. Although Prophet remains the most widely used tool, there
    are several competing packages to keep an eye on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet的公开发布激发了围绕预测包的大量开源活动。尽管Prophet仍然是使用最广泛的工具，但仍有一些竞争包需要关注。
- en: NeuralProphet
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NeuralProphet
- en: Prophet has become so popular due to its ease of learning, quick predictions
    from data, and customizability. However, it does have some shortcomings; the key
    one among these is that it is a linear model. As discussed earlier in this chapter,
    neural networks are often used when forecasting tasks require a non-linear model,
    although an analyst must be very knowledgeable about both time series and applied
    machine learning to apply these models effectively. **NeuralProphet** ([https://github.com/ourownstory/neural_prophet](https://github.com/ourownstory/neural_prophet))
    aims to bridge this gap and allows an analyst with expertise only in time series
    to build a very strong neural model.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其易于学习、快速从数据中预测以及可定制性，Prophet已经变得非常流行。然而，它确实有一些缺点；其中关键的一个是它是一个线性模型。正如本章前面所讨论的，当预测任务需要非线性模型时，通常会使用神经网络，尽管分析师必须非常了解时间序列和应用的机器学习，才能有效地应用这些模型。**NeuralProphet**
    ([https://github.com/ourownstory/neural_prophet](https://github.com/ourownstory/neural_prophet))旨在弥合这一差距，并允许只有时间序列专业知识的分析师构建一个非常强大的神经网络模型。
- en: Oskar Triebe at Stanford University has built and optimized NeuralProphet for
    several years with the help of the open source community, but at the time of writing,
    NeuralProphet is still in the beta phase. It switches out Prophet’s dependency
    on the Stan language with PyTorch, thus enabling deep learning methods. NeuralProphet
    models time series autocorrelation with an **Autoregressive Network** (**AR-Net**)
    and models lagged regressors with a **Feed-Forward Neural Network**. The programming
    interface has been designed to be nearly identical to Prophet’s, so learning how
    to build models in NeuralProphet will be quite familiar to anyone already familiar
    with Prophet.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 斯坦福大学的Oskar Triebe在开源社区的帮助下，已经构建和优化了NeuralProphet多年，但截至写作时，NeuralProphet仍处于测试阶段。它用PyTorch替换了Prophet对Stan语言的依赖，从而实现了深度学习方法。NeuralProphet使用**自回归网络**（**AR-Net**）来模拟时间序列自相关，并使用**前馈神经网络**来模拟滞后回归器。编程接口的设计与Prophet几乎相同，因此对于已经熟悉Prophet的人来说，学习如何在NeuralProphet中构建模型将会非常熟悉。
- en: Google’s “robust time series forecasting at scale”
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google的“大规模稳健时间序列预测”
- en: Not to be outdone, in April 2017, just 2 months after Facebook announced Prophet
    was being made open source, Google described their solution to the forecasting
    problem in their blog post *Our quest for a robust time series forecasting at
    scale* ([https://www.unofficialgoogledatascience.com/2017/04/our-quest-for-robust-time-series.html](https://www.unofficialgoogledatascience.com/2017/04/our-quest-for-robust-time-series.html)).
    Unlike Prophet, Google’s package is not open source, so few details are publicly
    available. A key difference between Prophet’s and Google’s approaches is that
    Google’s forecasting package uses an ensemble method to forecast growth trends.
    In the time series context, this means that Google fits multiple forecast models,
    removes any outliers, and takes the weighted average of each individual model
    to arrive at a final model. At the time of writing, Google has not announced any
    plans to release its forecasting package to the open source community.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: LinkedIn’s Silverkite/Greykite
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compared to Facebook and Google, LinkedIn is a relative newcomer to the open
    source forecasting community. In May 2021, LinkedIn announced their **Greykite**
    forecasting library for Python ([https://github.com/linkedin/greykite](https://github.com/linkedin/greykite)),
    which uses their own **Silverkite** algorithm (the Prophet algorithms are also
    options within Greykite’s modeling framework). Greykite was developed to provide
    some key benefits to forecasting at LinkedIn: the solution must flexible, intuitive,
    and fast. If that sounds familiar, it’s because those are the very same qualities
    Facebook targeted when developing Prophet.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Whereas Prophet uses a Bayesian approach to fit a model, Silverkite uses more
    traditional models such as a ridge, elastic net, and boosted trees. Both Prophet
    and Silverkite can model linear growth, but only Silverkite can handle square
    root and quadratic growth. Prophet, however, can model logistic growth, something
    that Silverkite cannot do. Possibly the most exciting aspect of Silverkite from
    an analyst’s point of view is that domain expertise can easily be added to a model
    via external variables. Silverkite uses `sklearn` for its API, so any user familiar
    with that library should have no trouble ramping up with Silverkite.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Uber’s Orbit
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the same time that LinkedIn announced the Greykite library, Uber announced
    their own forecasting package, **Object-Oriented Bayesian Time Series** (**Orbit**)
    ([https://github.com/uber/orbit](https://github.com/uber/orbit)). As the name
    suggests, Orbit is Bayesian just like Prophet. Orbit, however, was designed to
    be more generalizable than Prophet, bridging the gap between typical business
    problems and more complex statistical solutions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Uber’s benchmarking indicates that Orbit performs well on all types
    of forecasting problems, its bread-and-butter use case is in marketing mix models,
    a technique to quantify the impact of several marketing inputs on sales. Orbit
    was implemented with two main types of Bayesian structural time series: `sklearn`
    paradigm to help new users onboard.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Uber的基准测试表明Orbit在所有类型的预测问题上都表现良好，但其核心用途是在营销组合模型中，这是一种量化几个营销输入对销售影响的技巧。Orbit通过两种主要的贝叶斯结构时间序列实现：`sklearn`范式以帮助新用户入门。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Through this brief survey of time series, you learned why time series data can
    be problematic if not analyzed with specialized techniques. You followed the developments
    of mathematicians and statisticians as they created new techniques to achieve
    higher forecasting accuracy or greater ease of use. You also learned what motivated
    the Prophet team to add their own contributions to this legacy and what decisions
    they made in their approach, and you learned how the open source community has
    reacted and begun work on different approaches.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对时间序列的简要概述，你了解到如果不用专门的技术分析，时间序列数据可能会出现问题。你跟随数学家和统计学家的发展，他们创造了新技术以实现更高的预测精度或更大的使用便捷性。你还了解到是什么激励了
    Prophet 团队为这个传统做出自己的贡献，以及他们在方法上做出了哪些决策，你还了解到开源社区是如何对此做出反应并开始研究不同方法的。
- en: In the next chapter, you’ll learn how to get Prophet running on your machine
    and build your first model. By the end of this book, you’ll understand every feature,
    no matter how small, and have them all in your toolbox to supercharge your own
    forecasts.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何在你的机器上运行 Prophet 并构建你的第一个模型。到这本书的结尾，你将理解每一个特性，无论大小，并将它们全部纳入你的工具箱，以增强你自己的预测能力。
