<html><head></head><body>
		<div id="_idContainer193">
			<h1 id="_idParaDest-151" class="chapter-number"><a id="_idTextAnchor153"/>12</h1>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor154"/>Deploying, Testing, and Operating an Intelligent MSA Enterprise System</h1>
			<p>In the previous chapters, we talked in detail about microservices, monolithic architecture, the pros and cons of each architecture, how to transition into MSA, and how to make the MSA system smarter using AI services. We also discussed, in <a href="B18934_11.xhtml#_idTextAnchor132"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, some of the best practices for deploying the <span class="No-Break">MSA system.</span></p>
			<p>In this final chapter, we will integrate all the topics and concepts covered throughout the book to understand how we can apply what we have learned through hands-on and <span class="No-Break">practical examples.</span></p>
			<p>Before we dive into the details, we need to understand what existing system we have in <span class="No-Break">place first.</span></p>
			<p>Obviously, every organization is different and has different deployment needs, criteria, and dependencies. Some organizations will deploy in a greenfield, and others in a brownfield. In order to walk you through detailed practical examples and steps for deploying, testing, and operating an intelligent MSA system, we will assume a brownfield environment with an existing monolithic <span class="No-Break">architecture system.</span></p>
			<p>We will sometimes use our ABC-Monolith as an example of the existing system to illustrate the concepts covered in the chapter. In this chapter, we will cover, the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Overcoming <span class="No-Break">deployment dependencies</span></li>
				<li>Deploying the <span class="No-Break">MSA system</span></li>
				<li>Testing and tuning the <span class="No-Break">MSA system</span></li>
				<li>The <span class="No-Break">post-deployment review</span></li>
			</ul>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor155"/>Overcoming system dependencies</h1>
			<p>Before deploying the ABC-Intelligent-MSA system we built earlier in <a href="B18934_10.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, it is important to <a id="_idIndexMarker685"/>first decide what our deployment strategy should be. Based on the requirements, cost, complexity, and pros and cons of the deployment strategies we discussed in <a href="B18934_11.xhtml#_idTextAnchor132"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, we believe the best deployment strategy for our ABC system would be a mix between the ramped deployment and canary <span class="No-Break">deployment strategies.</span></p>
			<p>This deployment strategy will allow us to keep the ABC-Monolith system online and serve users uninterrupted while we deploy the new ABC-Intelligent-MSA system. We will gradually replace older components in ABC-Monolith with the corresponding microservices in the ABC-Intelligent-MSA system. This can be accomplished by routing traffic from the older components to those ABC-Intelligent-MSA <span class="No-Break">system microservices.</span></p>
			<p>Although this trickle approach has lower cost, lower complexity, and lower risk than other deployment approaches, we still need to carefully study the incompatibilities, dependencies, and the proper integration between older and <span class="No-Break">newer components.</span></p>
			<p>Furthermore, we will need to evaluate which of our infrastructure and existing system ABC-Monolith’s components can be reused in the new architecture, <span class="No-Break">if any.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor156"/>Reusable ABC-Monolith components and dependencies</h2>
			<p>We cannot think of a specific ABC-Monolith code base component that can be reused as is <a id="_idIndexMarker686"/>without modification. All of the ABC-Monolith components will have to be either rewritten from scratch <a id="_idIndexMarker687"/>or modified to different degrees to be compatible with the <span class="No-Break">ABC-Intelligent-MSA system.</span></p>
			<p>Some of <a id="_idIndexMarker688"/>the ABC-Monolith and existing infrastructure <a id="_idIndexMarker689"/>components that we know can be reused are the business logic itself, server infrastructure, operating systems, virtualization infrastructure, data storage, network infrastructure, existing monitoring, and network management tools, and some of the software and database licensing. Nevertheless, even these components may need to be updated or upgraded in order to perform the functions of the <span class="No-Break">new system.</span></p>
			<p>In our system installation, command line, and code examples listed in earlier chapters, we had the most updated Ubuntu, Python, and database versions. In a real-life situation, however, that may not be the case; we will likely have the monolithic application running in an older operating system and have an older Python and/or <span class="No-Break">database version.</span></p>
			<p>These situations may produce some incompatibilities between the older components and the newer ones. An older Python version, for example, may have some deprecated functions that are no longer valid with the new MSA code base, and hence, will require some updates or upgrades to the existing system. Furthermore, the potentially different technology stack may also produce <span class="No-Break">more dependencies.</span></p>
			<p>In order <a id="_idIndexMarker690"/>to minimize these dependencies, we would rather deploy the new system components on a separate <a id="_idIndexMarker691"/>server or virtual infrastructure with their own environment, including their own data storage and using their own technology stack. The new environment will have a container engine that will carry all of our <span class="No-Break">ABC-Intelligent-MSA microservices.</span></p>
			<p>It is important <a id="_idIndexMarker692"/>to note that each system is different, and the <a id="_idIndexMarker693"/>specific reusable and non-reusable components will vary depending on the existing monolithic system. A thorough analysis and evaluation of the existing system’s components is necessary to determine what can and cannot be reused when migrating to a <span class="No-Break">microservices architecture.</span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor157"/>Mitigating ABC-Intelligent-MSA deployment risks</h2>
			<p>Some of the risks discussed in <a href="B18934_11.xhtml#_idTextAnchor132"><span class="No-Break"><em class="italic">Chapter 11</em></span></a> are relevant to our scenario. However, we still <a id="_idIndexMarker694"/>need to determine which CAPEX <a id="_idIndexMarker695"/>risks are applicable, examine the risks related to deployment time, potential service disruption, and OPEX, and take specific actions to mitigate <span class="No-Break">these risks.</span></p>
			<p>Since we are using containers on top of virtualized infrastructure in our implementation, CAPEX risks are significantly reduced. As long as the existing infrastructure has the storage and workload capacity to absorb the new ABC system, we are safe. If additional infrastructure resources are needed, we may then need to look into some capacity planning and upgrades to be able to run the system during and after <span class="No-Break">the deployment.</span></p>
			<p>Adopting a trickle migration approach gives us the chance to catch up quickly with any learning curve involved with the new technologies being deployed, which, in return, helps mitigate system failure risks and <span class="No-Break">deployment delays.</span></p>
			<p>The ramped deployment strategy also helps mitigate other OPEX risks. As we will discuss in this chapter, during the deployment, we can test and monitor the performance of the newly deployed components, identify and resolve any issues, and make necessary adjustments before redirecting all traffic to these <span class="No-Break">new components.</span></p>
			<p>Another <a id="_idIndexMarker696"/>way of mitigating OPEX <a id="_idIndexMarker697"/>risks is to establish a robust change management process by establishing a structured and transparent process for managing changes. This includes creating clear guidelines for how changes will be proposed, evaluated, approved, and implemented, as well as communicating the changes to <span class="No-Break">relevant stakeholders.</span></p>
			<p>Part of the change management process is the rollback plan. The rollback plan is essential to bringing back the system to an operational state if a specific technical change is unsuccessful. The following are the steps we need to consider to build a successful <span class="No-Break">rollback plan:</span></p>
			<ol>
				<li>Specify some checkpoints for the change where a rollback may be needed. In our example, and should the ACL be used, the ACL would be deployed prior to switching any traffic to the new microservice. During the change (and right after switching some test traffic to the ABC-Intelligent-MSA), a few good checkpoint examples would be <span class="No-Break">as follows:</span><ol><li>Testing the payment verification communication between ABC-Monolith and <span class="No-Break">the ACL</span></li>
<li>Testing how the ACL processes <span class="No-Break">the requests</span></li>
<li>Testing the communication between the ACL and the <span class="No-Break">ABC-Intelligent-MSA system</span></li>
<li>Testing how the overall end-to-end requests are handled and whether they are processed <span class="No-Break">as expected</span></li>
</ol></li>
			</ol>
			<p>Common Docker and Linux commands to test and troubleshoot the communication between the ACL, the monolith, and the MSA include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">curl</strong>, to simulate an API call to the ACL or a <span class="No-Break">specific microservice</span></li>
				<li><strong class="source-inline">netstat</strong>, to check whether a specific service is actively listening to connections, what the listening port is, and whether there are any <span class="No-Break">active connections</span></li>
				<li><strong class="source-inline">docker inspect</strong>, to return detailed JSON information about a specific microservice’s configuration, state, and <span class="No-Break">network settings</span></li>
				<li><strong class="source-inline">docker log</strong>, to view the logs of a <span class="No-Break">running container</span></li>
			</ul>
			<ol>
				<li value="2">Develop <a id="_idIndexMarker698"/>a plan for reversing the change at each of the preceding <span class="No-Break">specified checkpoints.</span></li>
				<li>Whenever <a id="_idIndexMarker699"/>possible, test the rollback plan in a test or staging environment to ensure it is workable <span class="No-Break">and complete.</span></li>
				<li>Know the time by which the rollback plan needs to be completely executed at each of the specified checkpoints, and allocate a reasonable amount of time in your change <span class="No-Break">for it.</span></li>
				<li>Monitor the system throughout the change and make adjustments <span class="No-Break">as needed.</span></li>
				<li>Have a post-mortem after the change, especially in case of a <span class="No-Break">change failure.</span></li>
				<li>In case the rollback plan is executed, the team will then need to include in the post-mortem the reasons for the change failure, and how effective the rollback plan was. They need to accordingly make the necessary adjustments to the deployment and rollback plan before scheduling <span class="No-Break">another change.</span></li>
			</ol>
			<p>By this point, we should have a clear understanding of the deployment dependencies and risks and be able to determine methods for mitigating them. We are ready now to create a deployment plan and execute it in a manner that minimizes downtime and maintains <span class="No-Break">business continuity.</span></p>
			<p>In the next section, we will build the ABC-Intelligent-MSA system’s deployment plan in the presence of the running <span class="No-Break">ABC-Monolith system.</span></p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor158"/>Deploying the MSA system</h1>
			<p>In <a href="B18934_09.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic">Chapter 9</em></span></a> and <a href="B18934_10.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, we discussed in detail how to install Docker, containers, and other components for our ABC-Intelligent-MSA system. This installation was mostly done in <a id="_idIndexMarker700"/>a lab environment with no specific regard to any existing system in the environment. We were basically just simulating a real-life development or <span class="No-Break">staging environment.</span></p>
			<p>In this section, we will focus rather on how we can take the ABC-Intelligent-MSA system we built, and gradually migrate it into a brownfield production environment where we have the ABC-Monolith system already running in production. The goal is to ramp up the ABC-Intelligent-MSA system’s operations until the system is able to carry the entire existing traffic, then completely phase out the old ABC-Monolith. Everything should be done with minimal <span class="No-Break">operational interruptions.</span></p>
			<p>The current status by now is that we still have ABC-Monolith running in production, and the ABC-Intelligent-MSA running in the staging environment. The following are detailed broken-down deployment plans with their <span class="No-Break">execution steps.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor159"/>The anti-corruption layer</h2>
			<p>Both our ABC-Monolith and ABC-Intelligent-MSA systems use the same type of RESTful APIs and <a id="_idIndexMarker701"/>the same JSON data formats. Moreover, our demo <a id="_idIndexMarker702"/>system is not complicated enough to justify an ACL. We, therefore, won’t be needing an ACL in our migration. However, we developed an ACL in our demo just in case you decide to try <span class="No-Break">it out.</span></p>
			<p>In case you are interested in trying the ACL, the first step you would need to do is to get the ACL up and running. The ACL will act as a buffer and handle the communication between the ABC-Monolith and the <span class="No-Break">ABC-Intelligent-MSA systems.</span></p>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="image/B18934_12_1.jpg" alt="Figure 12.1: Deploying with the ACL"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1: Deploying with the ACL</p>
			<p>ACLs are usually a specific custom-built code for the organization’s specific situation, the old system, and the new MSA system. We built the <strong class="source-inline">abc_acl</strong> ACL for our ABC system. The <strong class="source-inline">abc_acl</strong> code can be found in our <span class="No-Break">GitHub repository.</span></p>
			<p>It would make <a id="_idIndexMarker703"/>much more sense to deploy all the new components, including <strong class="source-inline">abc_acl</strong>, on a separate host or virtual workload. In our lab examples, however, and <a id="_idIndexMarker704"/>for simplicity, we are building the new system’s containers on the same host that’s running <span class="No-Break">the ABC-Monolith.</span></p>
			<p>We built the <strong class="bold">Facade</strong>, <strong class="bold">Adaptor</strong>, and <strong class="bold">Translator</strong> components all together as part of the ACL in one microservice. The Facade is created to interface with the ABC-Monolith, the Adaptor to interface with the ABC-Intelligent-MSA, and the translator for input/output data format mappings. Since we are using the same data formats in both the monolith and the MSA systems, the translator code is not doing any processing and is just used as <span class="No-Break">a placeholder.</span></p>
			<p>We can set up and start the <strong class="source-inline">abc_acl</strong> microservice the same way we did with other microservices in <a href="B18934_09.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic">Chapter 9</em></span></a> and <a href="B18934_10.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, using the <strong class="source-inline">docker build</strong> command to build the <strong class="source-inline">abc_acl_image</strong> image from the Dockerfile, then using the <strong class="source-inline">docker run</strong> command to create the <strong class="source-inline">abc_acl_container</strong> container, <span class="No-Break">as follows:</span></p>
			<pre class="console">$ docker build -t abc_msa_customer_management ~/</pre>
			<p>Once the image is successfully created, use the following command to run the container, and start listening to port TCP/8020 on the <span class="No-Break">host’s IP:</span></p>
			<pre class="console">$ docker run -itd -p 8020:8080 --name abc_acl_container abc_acl_image</pre>
			<p>Now the <a id="_idIndexMarker705"/>ACL is running, it is time to test it before routing <a id="_idIndexMarker706"/>any traffic to it. We can do that using the shell <strong class="source-inline">curl</strong> command as we did in the previous chapters, or we can use some of the ACL built-in API tools created to verify <span class="No-Break">the connection.</span></p>
			<p>The following is a <strong class="source-inline">curl</strong> command issued on the host machine to ensure that the ACL is <span class="No-Break">running successfully:</span></p>
			<pre class="source-code"><strong class="bold">$ curl http://192.168.1.100:8020/</strong>
&lt;!DOCTYPE html&gt;
&lt;head&gt;
   &lt;title&gt;The Anti-Corruption Layer Microservice&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;p&gt;This is the ACL Microservice Part of ABC System. This ACL is used as part of the process of migrating ABC-Monolith to the new system, ABC-Intelligent-MSA &lt;/p&gt;
&lt;/body&gt;</pre>
			<p>The following is an example of another way to test the ACL – more specifically, to test the communication between the ACL and both ABC-Monolith and <span class="No-Break">ABC-Intelligent-MSA systems:</span></p>
			<pre class="console">$ curl http://192.168.1.100:8020/api?func=test_com
{"monolith_com_test": "Communication SUCCESSFUL", "msa_com_test": "Communication SUCCESSFUL"}</pre>
			<p>The first <strong class="source-inline">curl</strong> command ensures that the ACL is listening to API calls from both ABC-Monolith and ABC-Intelligent-MSA, while the second <strong class="source-inline">curl</strong> command ensures that the ACL can successfully communicate with <span class="No-Break">both systems.</span></p>
			<p>The ACL operation is now verified; in the next subsection, we will start migrating the MSA services from the staging (or lab) environment to the actual production environment running the old <span class="No-Break">monolithic system.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor160"/>Integrating the MSA system’s services</h2>
			<p>With the ACL now up and running and tested successfully, we are ready to start switching specific traffic <a id="_idIndexMarker707"/>to specific parts of the ABC-Intelligent-MSA. We will, however, use direct interaction between both the monolith and the MSA system since the ACL is not really needed in our <span class="No-Break">demo example.</span></p>
			<p>Please note that, depending on the existing monolith structure, design, and system’s code base, this process could either be very straightforward or as complicated as can be. Our deployment strategy requires some code changes in the monolith system to be able to route some parts of the traffic to the <span class="No-Break">new MSA.</span></p>
			<p>For that reason, we may very well choose, in some systems, to have the MSA completely tested in a staging environment, then put the MSA on an LA period where partial production traffic is passing through the system for deeper testing. Then, once comfortable with the new MSA system’s performance, we can just start forwarding the entire production traffic, and finally, shut down the <span class="No-Break">old monolith.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.2</em> shows a high-level view of the migration before and after status. During the migration, we will route a specific function of ABC-Monolith to one microservice in ABC-Intelligent-MSA. That microservice should be able to replace the corresponding function in the ABC-Monolith system. After we test the operation of that part of the migration, we then move traffic of another monolithic function, then another, and so on, until we end up migrating all of the ABC-Monolith functions to the <span class="No-Break">ABC-Intelligent-MSA system.</span></p>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="image/B18934_12_2.jpg" alt="Figure 12.2: A high-level view of where we are and where to be"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2: A high-level view of where we are and where to be</p>
			<p>We can start <a id="_idIndexMarker708"/>with a simple microservice such as <strong class="bold">Notification Management</strong> (<strong class="source-inline">abc_msa_notify_user_container</strong>). We can route the traffic destined to the <strong class="source-inline">notify_user()</strong> function in the ABC-Monolith by replacing the function’s code with an API call to <strong class="source-inline">abc_msa_notify_user_container</strong>. All user traffic will still flow through the ABC-Monolith, but all user notifications will be processed through <span class="No-Break">the ABC-Intelligent-MSA.</span></p>
			<p>In the same manner, the <strong class="bold">Customer Management</strong> microservice (<strong class="source-inline">abc_msa_customer_management_container</strong>) should replace the <strong class="source-inline">register_customer()</strong> function from the ABC-Monolith, and <strong class="bold">Order Management</strong> should replace <strong class="source-inline">place_order()</strong> and <strong class="source-inline">order_status_update()</strong> functions, and <span class="No-Break">so on.</span></p>
			<p>As the system stabilizes, we gradually migrate to other MSA services. That migration cycle is shown in <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">.</span></p>
			<p>By following the migration cycle, eventually, all of the ABC-Monolith functions will be replaced with <a id="_idIndexMarker709"/>microservices in the <span class="No-Break">ABC-Intelligent-MSA system.</span></p>
			<div>
				<div id="_idContainer190" class="IMG---Figure">
					<img src="image/B18934_12_3.jpg" alt="Figure 12.3: The microservices integration testing and tuning cycle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3: The microservices integration testing and tuning cycle</p>
			<p><span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.4</em> shows a snapshot of the system status during the migration process. In the figure, we have the <strong class="bold">Notification Management</strong>, <strong class="bold">Customer Management</strong>, and <strong class="bold">Order Management</strong> microservices successfully migrated, but not any other <span class="No-Break">microservice yet.</span></p>
			<div>
				<div id="_idContainer191" class="IMG---Figure">
					<img src="image/B18934_12_4.jpg" alt="Figure 12.4: A system snapshot during the migration process"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4: A system snapshot during the migration process</p>
			<p>Monitor the <a id="_idIndexMarker710"/>system closely during the monolithic function migration, and use the rollback plan if necessary. Once the last ABC-Monolith function is migrated to the new system, we will need to carefully run an end-to-end test on the ABC-Intelligent-MSA system to ensure the system is running properly and independent of <span class="No-Break">the ABC-Monolith.</span></p>
			<p>Testing all microservice logs and stats is essential in the testing process. We need to have a formal testing process in place every step of the way during the migration process. The test process is described in more detail in the <span class="No-Break">next section.</span></p>
			<p>Keep both systems running for a period of time just in case some overseen issues take place and always be prepared with a <span class="No-Break">contingency plan.</span></p>
			<p>The final step is shutting down the monolith. If the migration steps were followed and tested correctly, user traffic and system operations should not be impacted. However, complex systems may have a component or more still processing traffic. To avoid business interruptions in this situation, it is best to shut down the monolith during a maintenance window to allow the migration team to analyze any unforeseen issues and create a plan to <span class="No-Break">resolve them.</span></p>
			<p>In this section, using our ABC system, we explained the MSA system deployment process using an ACL and using a direct monolith-to-microservices approach. We covered the steps to be taken, what to watch for, and how to make the transition to the new system as smooth <a id="_idIndexMarker711"/>as possible with minimal <span class="No-Break">system interruption.</span></p>
			<p>In the next section, we will cover the formal test methodology that should be planned and followed after every microservice migration to ensure system reliability <span class="No-Break">and stability.</span></p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor161"/>Testing and tuning the MSA system</h1>
			<p>Prior to deploying microservices, a formal testing or QA process should be applied to each microservice <a id="_idIndexMarker712"/>to prevent errors during deployment and <span class="No-Break">in production.</span></p>
			<p>There are a <a id="_idIndexMarker713"/>couple of tests that need to be performed on the MSA system microservices before deploying them in the production environment. First, testing the microservice itself as a standalone and before integrating it into any parts of the ABC system – what we <a id="_idIndexMarker714"/>refer to it as, <strong class="bold">unit testing</strong>. Second, testing the integration of that microservice into the ABC-Intelligent-MSA system – what we refer <a id="_idIndexMarker715"/>to it as <strong class="bold">integration testing</strong>. And third, testing how the microservice functions during an interim mix of operations between the ABC-Monolith and the <span class="No-Break">ABC-Intelligent-MSA systems.</span></p>
			<p>Testing the ABC system functions every time a new microservice is deployed is crucial to ensure a successful migration and that the system is able to properly function and sustain the applied traffic load and <span class="No-Break">user requests.</span></p>
			<p>Building structured test cases is an important part of the testing process. Test cases are a set of steps that describe how to test a specific feature or functionality of a system. These test cases should be well defined, easy to understand, and should cover all <span class="No-Break">possible scenarios.</span></p>
			<p>Creating a test case should include the following <span class="No-Break">main steps:</span></p>
			<ol>
				<li value="1">Identify the requirements of the system and the feature or functionality that we want <span class="No-Break">to test.</span></li>
				<li>Write a test case that describes the steps to be taken to test that feature <span class="No-Break">or functionality.</span></li>
				<li>In the test case, specify any prerequisites that are required to run <span class="No-Break">the test.</span></li>
				<li>Identify the pass/fail criteria based on the expected outcome of the <span class="No-Break">test case.</span></li>
				<li>Run the test case and compare the test results to the expected outcome. Accordingly, and based on the pass/criteria specified, record the result of the test in simple PASS or <span class="No-Break">FAIL terms.</span></li>
			</ol>
			<p>The following is a simple example of a test case for the <strong class="bold">Notification Management</strong> microservice. The test case verifies that the microservice is actually sending an SMS notification to a registered user’s mobile number. Another test case should also <a id="_idIndexMarker716"/>be written to test the microservice’s email <em class="italic">Send</em> functionality. We can <a id="_idIndexMarker717"/>write as many test cases as needed for each individual microservice, and for the system <span class="No-Break">functionality overall.</span></p>
			<table id="table001-6" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="2">
							<p><strong class="bold">Test </strong><span class="No-Break"><strong class="bold">Case Details</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Title</span></p>
						</td>
						<td class="No-Table-Style">
							<p>ABC-Intelligent-MSA Notification Management Microservice <span class="No-Break">SMS Functionality</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">ID</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">002912</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Description</span></p>
						</td>
						<td class="No-Table-Style">
							<p>To ensure that the microservice is actually sending an SMS notification to the specified <span class="No-Break">mobile number</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Requirement(s)</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Access to the <span class="No-Break">SMS gateway.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Test Setup</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Have access to the receiver test phone +1 (<span class="No-Break">555) 555-5555.</span></p>
							<p>Have access to the Ubuntu <span class="No-Break">test environment.</span></p>
							<p>Verify SMS <span class="No-Break">gateway access.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Procedure</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Ensure the <strong class="source-inline">abc_msa_notify_user_container</strong> container is running, or start it <span class="No-Break">as follows:</span></p>
							<p><strong class="source-inline">docker container </strong><span class="No-Break"><strong class="source-inline">start abc_msa_notify_user_container</strong></span></p>
							<p>Issue a shell <strong class="source-inline">curl</strong> command <span class="No-Break">as follows:</span></p>
							<p><span class="No-Break"><strong class="source-inline">curl http://192.168.1.100:8010/api?func=send_sms&amp;num=15555555555&amp;msg=order+received</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Test Type</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Unit testing</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Pass/Fail Criteria</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Test case passes if you receive the message “order received” on the <span class="No-Break">test phone</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 12.1 – A sample test case for notification management in ABC-Intelligent-MSA</p>
			<p>Testing the AI services of the ABC-Intelligent-MSA system can be more challenging, and the conventional test case approach may not be sufficient. Testing the AI part of the system will require a multi-level approach that would require including the microservice itself in isolation (unit testing), integration testing, functional testing, performance testing, data validation testing, and human-in-the-loop testing. By using all these approaches <a id="_idIndexMarker718"/>together in building your test cases, we can ensure that <a id="_idIndexMarker719"/>the AI components of the system are functioning as intended and are making accurate predictions <span class="No-Break">and decisions.</span></p>
			<p>In this section, we covered the importance of building a structured testing process and built a test case example as part of our system’s testing process. We discussed how to create a test case and identify the requirements and <span class="No-Break">expected outcomes.</span></p>
			<p>In the next section, we will talk about the importance of conducting a post-deployment review after the completion of the ABC-Intelligent-MSA system deployment. The section will also cover the different types of post-deployment reviews, including user <span class="No-Break">feedback reviews.</span></p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor162"/>The post-deployment review</h1>
			<p>The ABC-Intelligent-MSA <a id="_idIndexMarker720"/>system is currently running, but it hasn’t been operational for a sufficient amount of time to guarantee its stability and resilience under typical traffic patterns and loads. A post-deployment review is crucial for ensuring the success of the ABC system deployment and its compliance, as well as enhancing its functionality and overall <span class="No-Break">user satisfaction.</span></p>
			<p>During the post-deployment review, we will need to monitor the system closely and look for any errors, bugs, or any other operational problems that may happen. Then, we will need to make recommendations for addressing system issues and making necessary improvements to the system to ensure that the system is meeting the user requirements it was <span class="No-Break">created for.</span></p>
			<p>We need to have <a id="_idIndexMarker721"/>special monitoring for the AI services we built in the system to make sure they are performing as they are supposed to and continuously improving themselves and the system’s operations overall. A closer look at the AI services logs that we discussed in <a href="B18934_10.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic">Chapter 10</em></span></a> is important to ensure the system’s stability and <span class="No-Break">enhanced performance.</span></p>
			<p>The following are some of the aspects and criteria that need to be considered when conducting a <span class="No-Break">post-deployment review.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor163"/>Checking the new system’s performance</h2>
			<p>We start by defining performance metrics, which will help us create a baseline for what to expect <a id="_idIndexMarker722"/>from the system, in terms of response time, user interactions, network traffic, and so on. We can use tools available on the internet or the <strong class="source-inline">ms_perfmon.py</strong> we previously discussed in <a href="B18934_10.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic">Chapter 10</em></span></a> to measure the performance of the new system and compare that to the <span class="No-Break">monolith’s performance.</span></p>
			<p>The variance between both the old and the new system’s performances would highly depend on the design, architecture, operational criteria, and infrastructure used in <span class="No-Break">both cases.</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor164"/>Identifying and fixing system defects</h2>
			<p>This goes <a id="_idIndexMarker723"/>back to the testing and tuning <a id="_idIndexMarker724"/>process discussed earlier, and how the process should be conducted. It is important to point out here that post-deployment, identifying system defects is not yet part of the QA process until they are first documented in the organization’s defect <span class="No-Break">tracking system.</span></p>
			<p>We are talking here about monitoring the operational aspects of the system and ensuring proper system supportability. The support process may very well lead to filing specific issues found in the system post-deployment. Later, a thorough investigation of customer support cases with their severity levels will need to be conducted to address and fix <span class="No-Break">these issues.</span></p>
			<p>System issues <a id="_idIndexMarker725"/>can also be identified by <a id="_idIndexMarker726"/>gathering customer feedback, as we will discuss in the next couple of sections, as well as from the outcomes of the different audit processes conducted on the <span class="No-Break">system post-deployment.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor165"/>Compliance</h2>
			<p>Perform regular maintenance and updates to the system to keep it running smoothly. As briefly discussed in <a href="B18934_08.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, a considerable part of compliance can be done through automation <a id="_idIndexMarker727"/>or commercial tools. The tools will help audit the system for different types of compliances, such as the GDPR, PCI, HIPAA, SCSEM, and so on. The specific compliances that an organization has to comply with will depend on the organization’s business itself, the nature of the system, and what processes and users it <span class="No-Break">is serving.</span></p>
			<p>Start by identifying the relevant regulations and standards that apply to the new system. This may include data privacy regulations, industry-specific standards, and <span class="No-Break">cybersecurity standards.</span></p>
			<p>Conduct a risk assessment the way we described in the previous chapter, to identify any potential areas of non-compliance and their associated risks. This may involve reviewing the process of the system’s design, architecture, and data processing. Then, put together a mitigation plan to mitigate the <span class="No-Break">identified risks.</span></p>
			<p>Make sure the organization’s staff are fully aware of compliance, its importance, and the individual roles and responsibilities in that regard. Keeping the staff trained is another aspect of keeping the organization compliant with specific rules, regulations, and specific <span class="No-Break">industry compliances.</span></p>
			<p>The compliance process is not a one-time thing, the organization has to conduct regular audits to maintain that compliance. Audits may include regularly running specific automated audit tools, and conducting manual system audits by checking system logs, data checks, physical and digital security checks, and <span class="No-Break">so on.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor166"/>System maintenance and updates</h2>
			<p>Just like your preventive car maintenance, performing regular system maintenance and updates <a id="_idIndexMarker728"/>is important to keep the system running smoothly with no sudden <span class="No-Break">unplanned failures.</span></p>
			<p>By planning, preparing, testing, implementing, monitoring, documenting the process, and taking a proactive role, we can ensure that our newly deployed system is functioning as expected and able to minimize operational interruptions. The following are a few points to consider in the <span class="No-Break">maintenance plan:</span></p>
			<ol>
				<li value="1">Put together a regular maintenance plan. This is a must-have for successful and reliable operations. This includes which part of the system needs to be updated, what maintenance activities need to be conducted and how often, prioritizing the maintenance tasks, and determining the <span class="No-Break">resources required.</span></li>
				<li>Make sure you have a regular system backup plan in place and have an updated backup before any maintenance work. This is important to bring back the system to its original state in case of any <span class="No-Break">work mishaps.</span></li>
				<li>Test any planned work before actually applying the update or the change. Test the change thoroughly in a lab or staging environment to ensure it is functioning <span class="No-Break">as expected.</span></li>
				<li>Monitor the system after the updates have been deployed. This includes monitoring performance metrics, running automated checks, checking users’ feedback, and checking <span class="No-Break">system logs.</span></li>
				<li>Update your documentation with the changes, and document the maintenance and update outcome. The documentation will help ensure that the maintenance and update process is repeatable for future reference, and help troubleshoot in case of any issues that may happen in <span class="No-Break">the future.</span></li>
			</ol>
			<p>In the beginning, the maintenance plan may not be as perfect as you may like it to be, but as the process is repeated during the lifetime of the system, the process will eventually get refined to a very <span class="No-Break">accurate level.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor167"/>User satisfaction</h2>
			<p>Monitoring and improving user satisfaction are sometimes underestimated in the success of <a id="_idIndexMarker729"/>deploying any new IT system. By gathering feedback from the system’s internal and external customers, analyzing that feedback, prioritizing changes, implementing changes, monitoring progress, and continuously improving, we can ensure that the system meets <span class="No-Break">customer requirements.</span></p>
			<p>The following is a four-step cycle for ensuring high customer <span class="No-Break">satisfaction post-deployment:</span></p>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/B18934_12_5.jpg" alt="Figure 12.5: The four-step customer satisfaction cycle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5: The four-step customer satisfaction cycle</p>
			<ol>
				<li value="1">The first step in monitoring our customer satisfaction is to gather feedback from the system users. The feedback can be collected through surveys, direct customer interaction and visits, phone conversations, and <span class="No-Break">so on.</span></li>
				<li>Analyze the gathered feedback to identify common complaints, common patterns, and specific use cases that may have not been covered during the system testing phase. This will help us understand the strengths of the system and the areas where we need <span class="No-Break">to improve.</span></li>
				<li>Prioritize whatever system changes are decided as an outcome of the gathered feedback. This part should have the biggest impact on customer satisfaction. It will show customers that you are addressing their concerns, reacting to their requests, and, sometimes, even being proactive to <span class="No-Break">customer needs.</span></li>
				<li>Implement the changes as prioritized. Start with the changes with the highest impact and lowest effort similar to what we discussed in <a href="B18934_11.xhtml#_idTextAnchor132"><span class="No-Break"><em class="italic">Chapter 11</em></span></a> under the <em class="italic">Risk mitigation</em> section and in <span class="No-Break"><em class="italic">Figure 11</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">.</span></li>
			</ol>
			<p>We need to <a id="_idIndexMarker730"/>continuously regather customer feedback to regularly monitor customer satisfaction progress. This will ensure that the changes being carried out are having the desired customer <span class="No-Break">satisfaction effect.</span></p>
			<p>The four-step process will help continuously meet customer needs and improve customer satisfaction accordingly. The process helps also constantly improve the system features, supportability, reliability, and stability to enhance the overall <span class="No-Break">user experience.</span></p>
			<p>In this section, we covered the post-deployment review process, the different aspects, and activities that need to be considered when conducting the review, and how that is essential in the overall success of the ABC-Intelligent-MSA <span class="No-Break">system operations.</span></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor168"/>Summary</h1>
			<p>In this chapter, we discussed, the various steps involved in the successful deployment of the new system. We talked about the importance of overcoming the system deployment dependencies, the importance of building structured test cases, and the steps involved in testing and tuning <span class="No-Break">the system.</span></p>
			<p>By following the steps outlined in this chapter, organizations can ensure the successful deployment of their MSA system, including overcoming dependencies, integrating with the monolith during the transition phase, testing and tuning the system, and conducting a post-deployment review. The chapter concluded by emphasizing the significance of following a customer satisfaction cycle and having customers engaged in the process of adapting the new <span class="No-Break">system’s operations.</span></p>
		</div>
		<div>
			<div id="_idContainer194" class="IMG---Figure">
			</div>
		</div>
</body></html>