<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Back-Projection and Histograms</h1>
                
            
            <article>
                
<p class="calibre2">In the previous chapter, we learned about many computer vision algorithms and OpenCV functions that can be used to prepare images for further processing or modify them in one way or another. We learned how to draw text and shapes on images, filter them using smoothening algorithms, perform morphological transformations on them, and calculate their derivatives. We also learned about geometric and miscellaneous transformations of images and applied colormaps to alter the tone of our images.</p>
<p class="calibre2">In this chapter, we'll be learning about a few more algorithms and functions that are used mostly to prepare images for further processing, inference, and modification. This will be further clarified later on in this chapter, after we learn about histograms in computer vision. We'll be introduced to the concept of histograms, and then we'll learn how they are calculated and utilized with hands-on example codes. The other extremely important concept we'll be learning about in this chapter is called <strong class="calibre4">back-projection</strong>. We'll learn how back-projection of a histogram can be used to create an altered version of the original image.</p>
<p class="calibre2">Besides their standard usage, the concepts and algorithms that we'll learn in this chapter are also essential when it comes to dealing with some of the most widely used algorithms for object detection and tracking, which we'll be learning in the upcoming chapters.</p>
<p class="calibre2">In this chapter, we'll cover the following:</p>
<ul class="calibre10">
<li class="calibre11">Understanding histograms</li>
<li class="calibre11">Back projection of histograms</li>
<li class="calibre11">Histogram comparison</li>
<li class="calibre11">Equalizing histograms</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Technical requirements</h1>
                
            
            <article>
                
<ul class="calibre10">
<li class="calibre11">An IDE to develop C++ or Python applications</li>
<li class="calibre11">OpenCV library</li>
</ul>
<p class="calibre2">Refer to <span class="calibre12"><a target="_blank" href="part0030.html#SJGS0-15c05657f8254d318ea883ef10fc67f4" class="calibre9">Chapter 2</a>, <em class="calibre7">Getting Started with OpenCV,</em></span> for more information about how to set up a personal computer and make it ready to develop computer vision applications using the OpenCV library.</p>
<p class="calibre2">You can use the following URL to download the source codes and examples for this chapter:</p>
<p class="calibre2"><a href="https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter05" class="calibre9"><span>https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter05</span></a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding histograms</h1>
                
            
            <article>
                
<p class="calibre2">In computer vision, histograms are simply graphs that represent the distribution of pixel values over the possible range of the accepted values for those pixels, or, in other words, the probability distribution of pixels. Well, this might not be as crystal clear as you would expect, so let's take single-channel grayscale images as a simple example to describe what histograms are, and then expand it to multi-channel colored images, and so on. We already know that the pixels in a standard grayscale image can contain values between 0 and 255. Considering this fact, a graph similar to the following, which depicts the ratio of the number of pixels containing each and every possible grayscale pixel value of an arbitrary image, is simply the histogram of that given image:</p>
<div class="cdpaligncenter"><img src="../images/00055.gif" class="calibre20"/></div>
<p class="calibre2">Keeping in mind what we just learned, it can be easily guessed that the histogram of a three-channel image, for example, would be three graphs representing the distribution of values for each channel, similar to what we just saw with the histogram of a single-channel grayscale image.</p>
<p class="calibre2">You can use the <kbd class="calibre13">calcHist</kbd> function in the OpenCV library to calculate the histogram of one or multiple images that can be single-channel or multi-channel themselves. This function requires a number of parameters that must be provided carefully for it to produce the desired results. Let's see how this function is used with a few examples.</p>
<p class="calibre2">The following example code (followed by description of all the parameters) demonstrates how you can calculate the histogram of a single grayscale image:</p>
<pre class="calibre15">Mat image = imread("Test.png"); 
if(image.empty()) 
    return -1; 
Mat grayImg; 
cvtColor(image, grayImg, COLOR_BGR2GRAY); 
 
int bins = 256; 
int nimages = 1; 
int channels[] = {0}; 
Mat mask; 
int dims = 1; 
int histSize[] = { bins }; 
float rangeGS[] = {0, 256}; 
const float* ranges[] = { rangeGS }; 
bool uniform = true; 
bool accumulate = false; 
Mat histogram; 
calcHist(&amp;grayImg, 
         nimages, 
         channels, 
         mask, 
         histogram, 
         dims, 
         histSize, 
         ranges, 
         uniform, 
         accumulate); </pre>
<p class="calibre2">We infer the following from the preceding code:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">grayImg</kbd> is the input grayscale image that wants to calculate its histogram, and <kbd class="calibre13">histogram</kbd> will contain the result.</li>
<li class="calibre11"><kbd class="calibre13">nimages</kbd> must contain the number of images for which we want histograms calculated, which, in this case, is just one image.</li>
<li class="calibre11"><kbd class="calibre13">channels</kbd> is an array that is supposed to contain the zero-based index number of the channels in each image for which we want their histogram calculated. For instance, if we want to calculate the histogram of the first, second, and fourth channels in a multi-channel image, the <kbd class="calibre13">channels</kbd> array must contain the values of 0, 1, and 3. In our example, <kbd class="calibre13">channels</kbd> only contained <kbd class="calibre13">0</kbd>, since we're calculating the histogram of the only channel in a grayscale image.</li>
<li class="calibre11"><kbd class="calibre13">mask</kbd>, which is common to many other OpenCV functions, is a parameter that is used to mask (or ignore) certain pixels, or, in other words, prevent them from participating in the calculated result. In our case, and as long as we are not working on a certain portion of an image, <kbd class="calibre13">mask</kbd> must contain an empty matrix.</li>
<li class="calibre11"><kbd class="calibre13">dims</kbd>, or the dimensionality parameters, corresponds to the dimensionality of the result histogram that we are calculating. It must not be greater than <kbd class="calibre13">CV_MAX_DIM</kbd>, which is 32 in current OpenCV versions. We'll be using <kbd class="calibre13">1</kbd> in most cases, since we expect our histogram to be a simple array-shaped matrix. Consequently, the index number of each element in the resulting histogram will correspond to the bin number.</li>
<li class="calibre11"><kbd class="calibre13">histSize</kbd> is an array that must contain the size of the histogram in each dimension. In our example, since the dimensionality was <kbd class="calibre13">1</kbd>, <kbd class="calibre13">histSize</kbd> must contain a single value. The size of the histogram, in this case, is the same as the number of bins in a histogram. In the preceding example code, <kbd class="calibre13">bins</kbd> is used to define the number of bins in the histogram, and it is also used as the single <kbd class="calibre13">histSize</kbd> value. Think of <kbd class="calibre13">bins</kbd> as the number of groups of pixels in a histogram. This will be further clarified with examples later on, but for now, it is important to note that a value of <kbd class="calibre13">256</kbd> for <kbd class="calibre13">bins</kbd> will result in a histogram containing the count of all individual possible pixel values.</li>
<li class="calibre11"><kbd class="calibre13">ranges</kbd> must contain pairs of values corresponding to the lower and higher bounds of each range of possible values when calculating the histogram of an image. In our example, this means a value in the single range of (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">256</kbd>), which is what we have provided to this parameter.</li>
<li class="calibre11">The <kbd class="calibre13">uniform</kbd> parameter is used to define the uniformity of the histogram. Note that if the histogram is non-uniform, as opposed to what is demonstrated in our example, the <kbd class="calibre13">ranges</kbd> parameter must contain the lower and higher bounds of all dimensions, respectively.</li>
<li class="calibre11">The <kbd class="calibre13">accumulate</kbd> parameter is used to decide whether the histogram should be cleared before it is calculated, or the calculated values should be added to an existing histogram. This can be quite useful when you need to calculate a single histogram using multiple images.</li>
</ul>
<div class="packt_infobox">We'll cover the parameters mentioned here as much as possible in the examples provided in this chapter. However, you can also refer to the online documentation of the <kbd class="calibre29">calcHist</kbd> function for more information.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Displaying histograms</h1>
                
            
            <article>
                
<p class="calibre2">Quite obviously, trying to display the resulting histogram using a function, such as <kbd class="calibre13">imshow</kbd>, is futile since the raw format of the stored histogram is similar to a single column matrix that has <kbd class="calibre13">bins</kbd> number of rows in it. Each row, or, in other words, each element, of the histogram corresponds to the number of pixels that fall into that specific bin. Considering this, we can draw the calculated histogram by using drawing functions from <a href="part0085.html#2H1VQ0-15c05657f8254d318ea883ef10fc67f4" class="calibre9">Chapter 4</a>, <em class="calibre7">Drawing, Filtering, and Transformation</em>.</p>
<p class="calibre2">Here's an example that shows how we can display the histogram that we calculated in the previous code sample as a graph with custom size and properties:</p>
<pre class="calibre15">int gRows = 200; // height 
int gCol = 500; // width 
Scalar backGroundColor = Scalar(0, 255, 255); // yellow 
Scalar graphColor = Scalar(0, 0, 0); // black 
int thickness = 2; 
LineTypes lineType = LINE_AA; 
 
Mat theGraph(gRows, gCol, CV_8UC(3), backGroundColor); 
 
Point p1(0,0), p2(0,0); 
for(int i=0; i&lt;bins; i++) 
{ 
    float value = histogram.at&lt;float&gt;(i,0); 
    value = maxVal - value; // invert 
    value = value / maxVal * theGraph.rows; // scale 
    line(theGraph, 
         p1, 
         Point(p1.x,value), 
         graphColor, 
         thickness, 
         lineType); 
    p1.y = p2.y = value; 
    p2.x = float(i+1) * float(theGraph.cols) / float(bins); 
    line(theGraph, 
         p1, p2, 
         Scalar(0,0,0)); 
    p1.x = p2.x; 
} </pre>
<p class="calibre2">In the preceding code, <kbd class="calibre13">gRow</kbd> and <kbd class="calibre13">gCol</kbd> refer to the height and width of the resulting graph, respectively. The rest of the parameters are either self-explanatory (<kbd class="calibre13">backgroundColor</kbd> and so on), or you have already learned about them in the previous chapters. Notice how each value in <kbd class="calibre13">histogram</kbd> is used to calculate the position of the line that needs to be drawn. In the preceding code, <kbd class="calibre13">maxVal</kbd> is simply used to scale the results to the visible range. Here's how <kbd class="calibre13">maxVal</kbd> itself is calculated:</p>
<pre class="calibre15">double maxVal = 0; 
minMaxLoc(histogram, 
          0, 
          &amp;maxVal, 
          0, 
          0);</pre>
<p class="calibre2">Refer to <span class="calibre12"><a target="_blank" href="part0048.html#1DOR00-15c05657f8254d318ea883ef10fc67f4" class="calibre9">Chapter 3</a>, <em class="calibre7">Array and Matrix Operations,</em></span> if you need to refresh your memory about how the <kbd class="calibre13">minMaxLoc</kbd> function is used. In our example, we only need the value of the biggest element in the histogram, so we ignore the rest of the parameters by passing zero to them.</p>
<p class="calibre2">Here is the result of the preceding example codes:</p>
<div class="cdpaligncenter"><img src="../images/00056.jpeg" class="calibre74"/></div>
<p class="calibre2">You can easily change the background or the graph color using the provided <kbd class="calibre13">backGroundColor</kbd> or <kbd class="calibre13">graphColor</kbd> parameters, or make the graph thinner or thicker by changing the <kbd class="calibre13">thickness</kbd> parameter, and so on.</p>
<p class="calibre2">Interpretation of a histogram is extremely important, especially in photography and photo-editing applications, so being able to visualize them is essential for easier interpretation of the results. For instance, in the preceding example, it can be easily noticed from the resulting histogram that the source image contains more tones of darker colors than brighter ones. We'll see more examples of darker and brighter images later on, but before that, let's see how changing the number of bins would affect the result.</p>
<p class="calibre2">The following are the resulting histograms of the same image as the previous example, with 150, 80, and 25 bins, from left to right, drawn using a bar chart visualization method:</p>
<div class="cdpaligncenter"><img src="../images/00057.jpeg" class="calibre75"/></div>
<p class="calibre2"/>
<p class="calibre2">You can easily notice that the lower the bins value is, the more grouped together the pixels are. Even though this might seem more like a lower resolution of the same data (from left to right), it is actually better to use a lower number of bins to group similar pixels together. Note that the bar-chart visualization in the preceding example is produced by replacing the <kbd class="calibre13">for</kbd> loop from the previous example code with the following:</p>
<pre class="calibre15">Point p1(0,0), p2(0, theGraph.rows-1); 
for(int i=0; i&lt;bins; i++) 
{ 
    float value = histogram.at&lt;float&gt;(i,0); 
    value *= 0.95f; // 5% empty at top 
    value = maxVal - value; // invert 
    value = value / (maxVal) * theGraph.rows; // scale 
    p1.y = value; 
    p2.x = float(i+1) * float(theGraph.cols) / float(bins); 
    rectangle(theGraph, 
              p1, 
              p2, 
              graphColor, 
              CV_FILLED, 
              lineType); 
    p1.x = p2.x; 
} </pre>
<p class="calibre2">Both of these visualizations (graph or bar-chart) have their own pros and cons, which will be more obvious as you try calculating histograms of different types of images. Let's try calculating the histogram of a color image. We'll need to calculate the histogram of individual channels, as was mentioned previously. Here's an example code that demonstrates how it's done:</p>
<pre class="calibre15">Mat image = imread("Test.png"); 
if(image.empty()) 
{ 
    cout &lt;&lt; "Empty input image!"; 
    return -1; 
} 
 
Mat imgChannels[3]; 
Mat histograms[3]; 
split(image, imgChannels); 
 
// each imgChannels element is an individual 1-channel image</pre>
<p class="calibre2">You can download the complete source code for the preceding example from the online source code repository for this chapter. The example project containing the full source code of the preceding code snippet is called <kbd class="calibre13">CvHistGraphColor</kbd>, and running it would produce a result similar to what is seen in the following diagram:</p>
<div class="cdpaligncenter"><img src="../images/00058.jpeg" class="calibre20"/></div>
<p class="calibre2">As you can see in the preceding example code, the <kbd class="calibre13">split</kbd> function is used to create three individual images, each containing a single channel, out of our source color image (BGR by default). The part of the code that is mentioned with the commented line in the preceding code is simply a <kbd class="calibre13">for</kbd> loop that iterates over the elements of <kbd class="calibre13">imgChannels</kbd> and draws each graph using the exact same code as you saw before, but with each graph having its own unique color that is calculated using the following code in the loop:</p>
<pre class="calibre15">Scalar graphColor = Scalar(i == 0 ? 255 : 0, 
                           i == 1 ? 255 : 0, 
                           i == 2 ? 255 : 0); </pre>
<p class="calibre2">Depending on the value of <kbd class="calibre13">i</kbd>, <kbd class="calibre13">graphColor</kbd> is set to blue, green, or red, hence the resulting histography depicted in the previous picture.</p>
<p class="calibre2">Besides interpreting the content of an image, or to seeing how pixel values are distributed in an image, histograms have many use cases. In the following sections, we'll be learning about back-projection and other algorithms that are used for utilizing histograms in our applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Back-projection of histograms</h1>
                
            
            <article>
                
<p class="calibre2">Considering the definition of histograms from the start of the previous section, it can be said that back-projection of a histogram on an image means replacing each of its pixels with their probability distribution value. This is, in a way (not exactly), the reverse operation of calculating the histogram of an image. When we back-project a histogram on an image, we actually use a histogram to modify an image. Let's first see how back-projection is performed using OpenCV and, afterwards, dive into how it is actually used.</p>
<p class="calibre2">You can use the <kbd class="calibre13">calcBackProject</kbd> function to calculate the back-projection of a histogram on an image. This function needs a similar set of parameters to the <kbd class="calibre13">caclHist</kbd> function. Let's see how it is called and then further break down its parameters:</p>
<pre class="calibre15">calcBackProject(&amp;image, 
                nimages, 
                channels, 
                histogram, 
                backProj, 
                ranges, 
                scale, 
                uniform); </pre>
<p class="calibre2">The <kbd class="calibre13">nimages</kbd>, <kbd class="calibre13">channels</kbd>, <kbd class="calibre13">ranges</kbd>, and <kbd class="calibre13">uniform</kbd> parameters in the <kbd class="calibre13">calcBackProject</kbd> function are used exactly the way they were with the <kbd class="calibre13">calcHist</kbd> function. <kbd class="calibre13">image</kbd> must contain the input image and <kbd class="calibre13">histogram</kbd> needs to be calculated with a prior call to the <kbd class="calibre13">calcHist</kbd> function or with any other method (or even manually). The result will be scaled by using the <kbd class="calibre13">scale</kbd> parameter and finally, it will be saved in <kbd class="calibre13">backProj</kbd>. It's important to note that the values in <kbd class="calibre13">histogram</kbd> can be over the correctly displayable range, so after performing the back-projection, the resulting <kbd class="calibre13">backProj</kbd> object will not be displayable correctly. To fix this issue, we need to first make sure <kbd class="calibre13">histogram</kbd> is normalized to the displayable range by OpenCV. The following code must be executed before the preceding call to <kbd class="calibre13">calcBackProject</kbd> in order for the resulting <kbd class="calibre13">backProj</kbd> to be displayable:</p>
<pre class="calibre15">normalize(histogram, 
          histogram, 
          0, 
          255, 
          NORM_MINMAX);</pre>
<p class="calibre2">The following image depicts the result of the back-projection of the image with its original histogram (unaltered histogram). The image on the right-hand side is the result of the back-projection algorithm:</p>
<div class="cdpaligncenter"><img src="../images/00059.jpeg" class="calibre76"/></div>
<p class="calibre2">According to the definition of histograms and back-projection, it can be said that the darker areas in the preceding back-projection result image contain pixels that are less common to the original image, and vice versa. This algorithm can be used (or even abused) to alter an image using a modified, or manually-made histogram. This technique is commonly used, for example, to create masks that extract only portions of an image that contains a given color or intensity.</p>
<p class="calibre2">Here is an example that demonstrates how you can use the concept of histograms and back-projection to detect the pixels in an image that are in the range of the brightest 10% of possible pixel values:</p>
<pre class="calibre15">int bins = 10; // we need 10 slices 
float rangeGS[] = {0, 256}; 
const float* ranges[] = { rangeGS }; 
int channels[] = {0}; 
Mat histogram(bins, 1, CV_32FC1, Scalar(0.0)); 
histogram.at&lt;float&gt;(9, 0) = 255.0; 
calcBackProject(&amp;imageGray, 
                1, 
                channels, 
                histogram, 
                backProj, 
                ranges);</pre>
<p class="calibre2">Notice that the histogram is formed manually, with <kbd class="calibre13">10</kbd> bins, instead of being calculated from the original image. Then, the last bin, or, in other words, the last element in the histogram, is set to <kbd class="calibre13">255</kbd>, which means absolute white. Obviously, if this wasn't done, we'd need to perform a normalization to make sure the result of back-projection is in the displayable range of colors.</p>
<p class="calibre2">The following image depicts the result of the preceding code snippet when it is executed on the same sample image from the previous examples:</p>
<div class="cdpaligncenter"><img src="../images/00060.jpeg" class="calibre77"/></div>
<p class="calibre2">The extracted mask image can be used to further modify an image, or, in the case of a uniquely-colored object, it can be used to detect and track the object. The detection and tracking algorithms will be covered thoroughly in the upcoming chapters, but how exactly we can use the color of an object is what we're going to learn next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Learning more about back-projections</h1>
                
            
            <article>
                
<p class="calibre2">First off, let's recall that the HSV color space is far better suited to dealing with the actual color value of pixels in an image than the standard RGB (or BGR and so on) color space. You might want to revisit <span class="calibre12"><a target="_blank" href="part0021.html#K0RQ0-15c05657f8254d318ea883ef10fc67f4" class="calibre9">Chapter 1</a>, <em class="calibre7">Introduction to Computer Vision,</em></span> for more information about this phenomenon. We're going to use this simple fact to find regions in an image that have a special color, regardless of their color intensity, brightness, and so on. For this reason, we need to first convert an image to the HSV color s</p>
<p class="calibre2">Let's simplify this with an example case. Imagine we want to replace a specific color in an image, preserving the highlights, brightness, and so on. To be able to perform such a task, we need to be able to accurately detect a given color and then make sure we only change the color in the detected pixels and not their brightness and similar properties. The following example code demonstrates how we can use a manually-formed histogram of the hue channel and its back-projection to extract pixels that have a specific color, which, in this example, is assumed to be blue:</p>
<ol class="calibre14">
<li value="1" class="calibre11">To perform such an operation, we need to start by reading an image, converting it to the HSV color space, and extracting the hue channel, or, in other words, the first channel, as seen here:</li>
</ol>
<pre class="calibre30">Mat image = imread("Test.png"); 
if(image.empty()) 
{ 
    cout &lt;&lt; "Empty input image!"; 
    return -1; 
} 
 
Mat imgHsv, hue; 
vector&lt;Mat&gt; hsvChannels; 
cvtColor(image, imgHsv, COLOR_BGR2HSV); 
split(imgHsv, hsvChannels); 
hue = hsvChannels[0]; </pre>
<ol start="2" class="calibre14">
<li value="2" class="calibre11">Now that we have the hue channel inside the <kbd class="calibre13">hue</kbd> object, we need to form a proper histogram of the hue channel, which contains only the pixels with the color blue. The hue value can be a value between <kbd class="calibre13">0</kbd> and <kbd class="calibre13">360</kbd> (in degrees) and the hue value of blue is <kbd class="calibre13">240</kbd>. So, we can create a histogram using the following code, which can be used to extract the blue-colored pixels, with an offset (or threshold) of <kbd class="calibre13">50</kbd> pixels:</li>
</ol>
<pre class="calibre30">int bins = 360; 
int blueHue = 240; 
int hueOffset = 50; 
Mat histogram(bins, 1, CV_32FC1); 
for(int i=0; i&lt;bins; i++) 
{ 
    histogram.at&lt;float&gt;(i, 0) =  
        (i &gt; blueHue - hueOffset) 
            &amp;&amp; 
        (i &lt; blueHue + hueOffset) 
            ? 
        255.0 : 0.0; 
}</pre>
<div class="packt_infobox">The preceding code acts like a simple threshold, in which all elements in the histogram that have an index of <kbd class="calibre29">240</kbd> (plus/minus <kbd class="calibre29">50</kbd>) are set to <kbd class="calibre29">255</kbd> and the rest are set to zero.</div>
<ol start="3" class="calibre14">
<li value="3" class="calibre11">Visualizing the manually-created hue channel histogram will allow us to have a better idea of the exact colors that are going to be extracted using it. The following code can be used to easily visualize a hue histogram:</li>
</ol>
<pre class="calibre30">double maxVal = 255.0; 
 
int gW = 800, gH = 100; 
Mat theGraph(gH, gW, CV_8UC3, Scalar::all(0)); 
 
Mat colors(1, bins, CV_8UC3); 
for(int i=0; i&lt;bins; i++) 
{ 
    colors.at&lt;Vec3b&gt;(i) = 
            Vec3b(saturate_cast&lt;uchar&gt;( 
                      (i+1)*180.0/bins), 255, 255); 
} 
cvtColor(colors, colors, COLOR_HSV2BGR); 
Point p1(0,0), p2(0,theGraph.rows-1); 
for(int i=0; i&lt;bins; i++) 
{ 
    float value = histogram.at&lt;float&gt;(i,0); 
    value = maxVal - value; // invert 
    value = value / maxVal * theGraph.rows; // scale 
    p1.y = value; 
    p2.x = float(i+1) * float(theGraph.cols) / float(bins); 
    rectangle(theGraph, 
              p1, 
              p2, 
              Scalar(colors.at&lt;Vec3b&gt;(i)), 
              CV_FILLED); 
    p1.x = p2.x; 
}</pre>
<p class="calibre31">Before proceeding with the next steps, let's break down the preceding example code. It is almost exactly the same as visualizing a grayscale histogram or a single red-, green-, or blue-channel histogram. However, the interesting fact to note about the preceding code is where we form the <kbd class="calibre13">colors</kbd> object. The <kbd class="calibre13">colors</kbd> object is going to be a simple vector that contains all possible colors across the hue spectrum, but according to the number of bins we have. Notice how we have used the <kbd class="calibre13">saturate_cast</kbd> function in OpenCV to make sure the hue values are saturated into the acceptable range. The S and V channels are simply set to their highest possible value, which is 255. After the <kbd class="calibre13">colors</kbd> object is correctly created, we have used the same visualization function as before. However, since OpenCV does not display images in the HSV color space by default (and you can expect the same behavior in most image display functions and libraries), we need to convert the HSV color space to BGR in order to display the colors correctly.</p>
<div class="packt_infobox">Even though hue can take a value in the range of (0, 360), it is not possible to store it in single-byte C++ types (such as <kbd class="calibre29">uchar</kbd>), which are capable of storing values in the range of (0, 255). That is why hue values are considered to be in the range of (0, 180) in OpenCV, or, in other words, they are simply divided by two.</div>
<p class="calibre31">The following image depicts the result of the preceding example code, if we try to display <kbd class="calibre13">theGraph</kbd> using the <kbd class="calibre13">imshow</kbd> function:</p>
<div class="cdpaligncenter"><img src="../images/00061.jpeg" class="calibre20"/></div>
<p class="calibre31">These are the colors we're going to extract in a mask, if we use its corresponding histogram to calculate the back-project of an image. This range of colors is created using the simple threshold (in a loop) that we did when we formed the histogram manually. Obviously, if you set all the values of the histogram to <kbd class="calibre13">255.0</kbd> instead of just the blue range, you'd have the whole spectrum of colors. Here's a simple example:</p>
<pre class="calibre30">Mat histogram(bins, 1, CV_32FC1); 
for(int i=0; i&lt;bins; i++) 
{ 
    histogram.at&lt;float&gt;(i, 0) = 255.0; 
}</pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre31">The visualization output would be the following:</p>
<div class="cdpaligncenter"><img src="../images/00062.jpeg" class="calibre20"/></div>
<p class="calibre31">Now let's go back to our original histogram of only the blue colors and continue with the remaining steps.</p>
<ol start="4" class="calibre14">
<li value="4" class="calibre11">We are ready to calculate the back-projection of our histogram on the hue channel that we had extracted in the initial step of our example. Here's how it's done:</li>
</ol>
<pre class="calibre30">int nimages = 1; 
int channels[] = {0}; 
Mat backProject; 
float rangeHue[] = {0, 180}; 
const float* ranges[] = {rangeHue}; 
double scale = 1.0; 
bool uniform = true; 
calcBackProject(&amp;hue, 
                nimages, 
                channels, 
                histogram, 
                backProject, 
                ranges, 
                scale, 
                uniform); </pre>
<p class="calibre31">It's quite similar to how we created the back-projection of grayscale channels, but the range, in this case, is adjusted to correctly represent the possible values for the hue channel, which is <kbd class="calibre13">0</kbd> to <kbd class="calibre13">180</kbd>.</p>
<p class="calibre31">The following image displays the result of such a back-projection, in which pixels with blue colors are extracted:</p>
<div class="cdpaligncenter"><img src="../images/00063.jpeg" class="calibre78"/></div>
<p class="calibre31">Note that pixels with grayscale colors (including white and black) might also have a value similar to the hue value that we want to extract, but since changing their hue value would not have any effect on their color, we can simply ignore them in our example case.</p>
<ol start="5" class="calibre14">
<li value="5" class="calibre11">Shift and change the hue in the pixels we extracted using the <kbd class="calibre13">calcBackProject</kbd> function. We simply need to loop through the pixels and shift their first channel with any desired value. The result obviously must be converted to BGR before it is suitable for being displayed. Here's how:</li>
</ol>
<pre class="calibre30">int shift = -50; 
for(int i=0; i&lt;imgHsv.rows; i++) 
{ 
    for(int j=0; j&lt;imgHsv.cols; j++) 
    { 
        if(backProject.at&lt;uchar&gt;(i, j)) 
        { 
            imgHsv.at&lt;Vec3b&gt;(i,j)[0] += shift; 
        } 
    } 
} 
Mat imgHueShift; 
cvtColor(imgHsv, imgHueShift, CV_HSV2BGR);</pre>
<p class="calibre2">We used a <kbd class="calibre13">shift</kbd> value of <kbd class="calibre13">-50</kbd> in the preceding example, which will cause the blue pixels to turn to green, preserving their brightness, and so on. Using various <kbd class="calibre13">shift</kbd> values would result in different colors replacing the blue pixels. Here are two examples:</p>
<div class="cdpaligncenter"><img src="../images/00064.jpeg" class="calibre20"/></div>
<p class="calibre2">What we learned in the preceding example is the basis of many color-based detection and tracking algorithms, as we'll learn in the upcoming chapters. Being able to correctly extract pixels of a certain color, regardless of their brightness shift, is extremely handy. Brightness shift in a color is what happens when the lighting over an object of a certain color is changed, or during day and night, which is taken into account when hue is used instead of red, green, or blue channels in an RGB image.</p>
<p class="calibre2">Before proceeding to the final section of this chapter, it's worth noting that the exact same visualization method that we used for displaying the manually-made histogram of an imaginary hue channel can also be used to visualize the color histograms calculated from an image. Let's see how it's done with an example.</p>
<p class="calibre2">In the preceding example, right after the initial step, instead of forming the histogram manually, simply calculate it using the <kbd class="calibre13">calcHist</kbd> algorithm, as seen here:</p>
<pre class="calibre15">int bins = 36; 
int histSize[] = {bins}; 
int nimages = 1; 
int dims = 1; 
int channels[] = {0}; 
float rangeHue[] = {0, 180}; 
const float* ranges[] = {rangeHue}; 
bool uniform = true; 
bool accumulate = false; 
Mat histogram, mask; 
 
calcHist(&amp;hue, 
         nimages, 
         channels, 
         mask, 
         histogram, 
         dims, 
         histSize, 
         ranges, 
         uniform, 
         accumulate); </pre>
<p class="calibre2">Changing the bin size effect is similar to what we saw in grayscale and single channel histograms, in the sense that it groups nearby values together. However, and in case of visualizing the hue channel, the nearby hue values will be grouped together, which results in a hue histogram that better represents similar colors in an image. The following example images depict the result of the preceding visualization, but with different <kbd class="calibre13">bins</kbd> values. From top to bottom, the <kbd class="calibre13">bins</kbd> value used to calculate each histogram is 360, 100, 36, and 7. Notice how the resolution of the histogram decreases as the bins value is decreased:</p>
<div class="cdpaligncenter"><img src="../images/00065.jpeg" class="calibre79"/></div>
<p class="calibre2">Choosing the right bins value completely depends on what type of objects you are dealing with and your definition of similar colors. What can be seen from the preceding image is that obviously choosing a very high bin value (such as 360) is not useful when we need at least some level of grouping of similar colors. On the other hand, choosing a very low bin size can result in an extreme grouping of colors in which calculating a back-projection would not produce an accurate result. Make sure to choose the bins value wisely, varying them for different subjects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Comparing histograms</h1>
                
            
            <article>
                
<p class="calibre2">Histograms can be compared with each other in other to get some insight into the content of an image. OpenCV allows histogram comparison using a method called <kbd class="calibre13">compareHist</kbd>, which requires the comparison method to be set first. The following example code depicts how this function can be used to calculate the result of comparison between two histograms calculated using previous calls to the <kbd class="calibre13">calcHist</kbd> function:</p>
<pre class="calibre15">HistCompMethods method = HISTCMP_CORREL; 
double result = compareHist(histogram1, histogram2, method); </pre>
<p class="calibre2"><kbd class="calibre13">histogram1</kbd> and <kbd class="calibre13">histogram2</kbd>, in the preceding example, are simply histograms of two different images, or different channels of an image. <kbd class="calibre13">method</kbd>, on the other hand, which must contain a valid entry from the <kbd class="calibre13">HistCompMethods</kbd> enum, defines the comparison algorithm used by the <kbd class="calibre13">compareHist</kbd> function and it can be any one of the following methods:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">HISTCMP_CORREL</kbd>, for the Correlation method</li>
<li class="calibre11"><kbd class="calibre13">HISTCMP_CHISQR</kbd>, for the Chi-square method</li>
<li class="calibre11"><kbd class="calibre13">HISTCMP_INTERSECT</kbd>, for the Intersection method</li>
<li class="calibre11"><kbd class="calibre13">HISTCMP_BHATTACHARYYA</kbd>, for the Bhattacharyya distance method</li>
<li class="calibre11"><kbd class="calibre13">HISTCMP_HELLINGER</kbd>, same as <kbd class="calibre13">HISTCMP_BHATTACHARYYA</kbd></li>
<li class="calibre11"><kbd class="calibre13">HISTCMP_CHISQR_ALT</kbd>, for the Alternative Chi-square method</li>
<li class="calibre11"><kbd class="calibre13">HISTCMP_KL_DIV</kbd>, for the Kullback-Leibler divergence method</li>
</ul>
<p class="calibre2"/>
<p class="calibre2">You can refer to the latest OpenCV documentation to get more information about the mathematical details of each method, and how and what properties of histograms are used by them. The same can be said about the interpretation of the results of any method. Let's see what this means with an example. Using the following sample code, we can output the result of all histogram-comparison methods:</p>
<pre class="calibre15">cout &lt;&lt; "HISTCMP_CORREL: " &lt;&lt; 
  compareHist(histogram1, histogram2, HISTCMP_CORREL) 
    &lt;&lt; endl; 
cout &lt;&lt; "HISTCMP_CHISQR: " &lt;&lt; 
  compareHist(histogram1, histogram2, HISTCMP_CHISQR) 
    &lt;&lt; endl; 
cout &lt;&lt; "HISTCMP_INTERSECT: " &lt;&lt; 
  compareHist(histogram1, histogram2, HISTCMP_INTERSECT) 
    &lt;&lt; endl; 
cout &lt;&lt; "HISTCMP_BHATTACHARYYA: " &lt;&lt; 
  compareHist(histogram1, histogram2, HISTCMP_BHATTACHARYYA) 
    &lt;&lt; endl; 
cout &lt;&lt; "HISTCMP_HELLINGER: " &lt;&lt; 
  compareHist(histogram1, histogram2, HISTCMP_HELLINGER) 
    &lt;&lt; endl; 
cout &lt;&lt; "HISTCMP_CHISQR_ALT: " &lt;&lt; 
  compareHist(histogram1, histogram2, HISTCMP_CHISQR_ALT) 
    &lt;&lt; endl; 
cout &lt;&lt; "HISTCMP_KL_DIV: " &lt;&lt; 
  compareHist(histogram1, histogram2, HISTCMP_KL_DIV) 
    &lt;&lt; endl; </pre>
<p class="calibre2">We use the same example image we used throughout this chapter to calculate both <kbd class="calibre13">histogram1</kbd> and <kbd class="calibre13">histogram2</kbd>, or, in other words, if we compare one histogram with an equal histogram, here's what we would get:</p>
<pre class="calibre15">HISTCMP_CORREL: 1 
HISTCMP_CHISQR: 0 
HISTCMP_INTERSECT: 426400 
HISTCMP_BHATTACHARYYA: 0 
HISTCMP_HELLINGER: 0 
HISTCMP_CHISQR_ALT: 0 
HISTCMP_KL_DIV: 0</pre>
<p class="calibre2"/>
<p class="calibre2">Notice how distance- and divergence-based methods return a value of zero, while correlation returns a value of one, for exact correlation. All of the results in the preceding output mean equal histograms. Let's shed more light on this by calculating the histograms from the following two images:</p>
<div class="cdpaligncenter"><img src="../images/00066.gif" class="calibre80"/></div>
<p class="calibre2">The following results would be created if the image on the left is used to create <kbd class="calibre13">histogram1</kbd> and the image on the right is used to create <kbd class="calibre13">histogram2</kbd>, or, in other words, an arbitrary bright image is compared with an arbitrary dark image:</p>
<pre class="calibre15">HISTCMP_CORREL: -0.0449654 
HISTCMP_CHISQR: 412918 
HISTCMP_INTERSECT: 64149 
HISTCMP_BHATTACHARYYA: 0.825928 
HISTCMP_HELLINGER: 0.825928 
HISTCMP_CHISQR_ALT: 1.32827e+06 
HISTCMP_KL_DIV: 3.26815e+06 </pre>
<p class="calibre2">It's important to note that the order of the histograms being passed to the <kbd class="calibre13">compareHist</kbd> function matters in some cases, such as when <kbd class="calibre13">HISTCMP_CHISQR</kbd> is used as the method. Here are the results with <kbd class="calibre13">histogram1</kbd> and <kbd class="calibre13">histogram2</kbd> passed in reverse order to the <kbd class="calibre13">compareHist</kbd> function:</p>
<pre class="calibre15">HISTCMP_CORREL: -0.0449654 
HISTCMP_CHISQR: 3.26926e+06 
HISTCMP_INTERSECT: 64149 
HISTCMP_BHATTACHARYYA: 0.825928 
HISTCMP_HELLINGER: 0.825928 
HISTCMP_CHISQR_ALT: 1.32827e+06 
HISTCMP_KL_DIV: 1.15856e+07 </pre>
<p class="calibre2">Comparing histograms is extremely useful, especially when we need to get a better and more meaningful impression of changes across various images. For instance, comparing histograms of consecutive frames from a camera can give us an idea of the intensity of change between those consecutive frames.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Equalizing histograms</h1>
                
            
            <article>
                
<p class="calibre2">Using the functions and algorithms that we've learned so far, we can enhance the intensity distribution of images, or, in other words, adjust the brightness of too dark or overly bright images, among many other operations. In computer vision, the histogram-equalization algorithm is used for the exact same reason. This algorithm performs the following tasks:</p>
<ul class="calibre10">
<li class="calibre11">Calculates the histogram of an image</li>
<li class="calibre11">Normalizes the histogram</li>
<li class="calibre11">Calculates the integral of the histogram</li>
<li class="calibre11">Uses the updated histogram to modify the source image</li>
</ul>
<p class="calibre2">Except the integral part, which is simply calculating the sum of the values in all bins, the rest is what we already performed in this chapter, in one way or another. OpenCV includes a function called <kbd class="calibre13">equalizeHist</kbd> that performs all of the mentioned operations and produces an image with an equalized histogram. Let's first see how this function is used and then try an example to see the effect for ourselves.</p>
<p class="calibre2">The following example codes depict how the <kbd class="calibre13">equalizeHist</kbd> function is used, which is extremely easy to use and requires no special parameters whatsoever:</p>
<pre class="calibre15">Mat equalized; 
equalizeHist(gray, equalized); </pre>
<p class="calibre2">Let's consider for instance that we have the following image, which is extremely overexposed (or bright), and its histogram, which is depicted on the right-hand side:</p>
<div class="cdpaligncenter"><img src="../images/00067.gif" class="calibre20"/></div>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">Using the <kbd class="calibre13">equalizeHist</kbd> function, we can get an image with better contrast and brightness. Here are the resulting image and histogram of the preceding example image when its histogram is equalized:</p>
<div class="cdpaligncenter"><img src="../images/00068.gif" class="calibre81"/></div>
<p class="calibre2">Histogram equalization is quite helpful when we have to deal with images that have the potential to be overexposed (too bright) or underexposed (too dark). For instance, x-ray scan images, where the details are only visible when the contrast and brightness is increased using a powerful backlight, or when we are working with video frames from an environment that can have intensive light changes, are examples of conditions in which histogram equalization can be used to make sure the rest of the algorithms always deal with the same, or just slightly different, brightness and contrast levels.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">We started this chapter by learning about histograms, what they are, and how they are calculated using the OpenCV library. We learned about the bin size of a histogram and how it can affect the accuracy or grouping of the values in a histogram. We continued to learn about visualizing histograms using the functions and algorithms we learned in <span class="calibre12"><a target="_blank" href="part0085.html#2H1VQ0-15c05657f8254d318ea883ef10fc67f4" class="calibre9">Chapter 4</a>, <em class="calibre7">Drawing, Filtering and Transformation</em></span>. After going through various visualization types, we learned about back-projection and how we can update an image using a histogram. We learned about detecting pixels with a certain color and how to shift the hue value, and consequently the color of only those specific pixels. In the final sections of this chapter, we learned about comparing histograms and histogram-equalization algorithms. We performed hands-on examples for possible histogram comparison scenarios and enhanced the contrast and brightness of an overexposed image.</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">Histograms and how they are used to enhance and modify images using back-projection is one of the computer vision subjects that cannot be easily skipped over or missed, since it is the foundation of many image enhancement algorithms and techniques in photo-editing applications, or, as we'll see later on in the upcoming chapters, the basis of some of the most important real-time detection and tracking algorithms. What we learned in this chapter were a few of the most practical use cases of histograms and back-projection, but there is certainly much more to these algorithms if you start building real-life projects that make use of histograms.</p>
<p class="calibre2">In the next chapter, we'll use all of the concepts we learned in this and the previous chapters to work videos and video frames to detect objects with a certain color, track them in real-time, or detect motion in a video.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Questions</h1>
                
            
            <article>
                
<ol class="calibre14">
<li value="1" class="calibre11">Calculate the histogram of the second channel in a three-channel image. Use an optional bin size and a range of 0 to 100 for possible values of the second channel.</li>
<li value="2" class="calibre11">Create a histogram that can be used with the <kbd class="calibre13">calcBackProject</kbd> function to extract the darkest pixels from a grayscale image. Consider the darkest 25% possible pixel values as the grayscale intensities we are looking to extract.</li>
<li value="3" class="calibre11">In the previous question, what if we needed the darkest and brightest 25% to be excluded, instead of extracted, in a mask?</li>
<li value="4" class="calibre11">What is the hue value of the color red? How much should it be shifted to get the color blue?</li>
<li value="5" class="calibre11">Create a hue histogram that can be used to extract red-colored pixels from an image. Consider an offset of 50 for pixels that are considered reddish. Finally, visualize the hue histogram calculated.</li>
<li value="6" class="calibre11">Calculate the integral of a histogram.</li>
<li value="7" class="calibre11">Perform histogram equalization on a color image. Note that the <kbd class="calibre13">equalizeHist</kbd> function only supports histogram equalization of single-channel 8-bit grayscale images.</li>
</ol>
<p class="calibre2"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Further reading</h1>
                
            
            <article>
                
<ul class="calibre10">
<li class="calibre11"><em class="calibre26">OpenCV 3.x with Python By Example <span>–</span> Second Edition</em> (<a href="https://www.packtpub.com/application-development/opencv-3x-python-example-second-edition" class="calibre9">https://www.packtpub.com/application-development/opencv-3x-python-example-second-edition</a>)</li>
<li class="calibre11"><em class="calibre26">Computer Vision with OpenCV 3 and Qt5</em> (<a href="https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5" class="calibre9">https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5</a>)</li>
</ul>


            </article>

            
        </section>
    </body></html>