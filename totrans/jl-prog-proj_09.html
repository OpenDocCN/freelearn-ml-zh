<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Working with Dates, Times, and Time Series</h1>
                </header>
            
            <article>
                
<p class="calibre2">We've had quite an amazing and rewarding journey through the realm of machine learning. We have learned how to use algorithms to classify labeled data and apply our findings to make recommendations. We have seen how to extract business value from raw, unlabeled information by using unsupervised machine learning and clustering algorithms. However, one key component has been missing from our analysis so far—the temporal dimension.</p>
<p class="calibre2"><em class="calibre16">Time is money,</em> the saying goes—and as such, organisations of all sizes, from small businesses to large corporations, to governments, to complex multinational institutions such as the European Union, continuously measure and monitor a multitude of economic indicators over time. To be meaningful, the data is collected at regular intervals, allowing analysts to identify hidden structures and patterns, and predict future developments based on past and present conditions. These values, measured regularly on a time scale, represent a time series. Time series analysis and forecasting can provide extremely valuable insight, allowing market actors to understand trends and make informed decisions based on accurate historical data.</p>
<p class="calibre2">We will dedicate two chapters, this one and the next one, to learning about time series and performing analysis and forecasting. In this chapter, we'll lay the foundations by learning about:</p>
<ul class="calibre10">
<li class="calibre11">Working with dates and times in Julia</li>
<li class="calibre11">Handling time zone information</li>
<li class="calibre11">Processing time series data with <kbd class="calibre12">TimeSeries</kbd></li>
<li class="calibre11">Plotting time series data with the powerful <kbd class="calibre12">Plots</kbd> package</li>
<li class="calibre11">The <kbd class="calibre12">TimeArray</kbd> data structure</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="calibre2">The Julia package ecosystem is under continuous development and new package versions are released on a daily basis. Most of the times this is great news, as new releases bring new features and bug fixes. However, since many of the packages are still in beta (version 0.x), any new release can introduce breaking changes. As a result, the code presented in the book can stop working. In order to ensure that your code will produce the same results as described in the book, it is recommended to use the same package versions. Here are the external packages used in this chapter and their specific versions:</p>
<pre class="calibre17">IJulia@v1.14.1<br class="title-page-name"/>MarketData@v0.11.0<br class="title-page-name"/>Plots@v0.22.0<br class="title-page-name"/>TimeZones@v0.8.2</pre>
<p class="calibre2">In order to install a specific version of a package you need to run:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add PackageName@vX.Y.Z</strong> </pre>
<p class="calibre2">For example:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add IJulia@v1.14.1</strong></pre>
<p class="calibre2">Alternatively you can install all the used packages by downloading the <kbd class="calibre12">Project.toml</kbd> file provided with the chapter and using <kbd class="calibre12">pkg&gt;</kbd> instantiate as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; download("https://raw.githubusercontent.com/PacktPublishing/Julia-Programming-Projects/master/Chapter09/Project.toml", "Project.toml")</strong><br class="title-page-name"/><strong class="calibre1">pkg&gt; activate . </strong><br class="title-page-name"/><strong class="calibre1">pkg&gt; instantiate</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with dates and times</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia provides a very rich API for handling date and time information. All the functionality is packed into the <kbd class="calibre12">Dates</kbd> module. The module is built in to the language so there's no need for additional package installs. In order to access its functionality, all we have to do is declare that we'll be <kbd class="calibre12">using Dates</kbd>.</p>
<p class="calibre2">The dates module exposes three main types—<kbd class="calibre12">Date</kbd>, <kbd class="calibre12">DateTime</kbd>, and <kbd class="calibre12">Time</kbd>. They are all subtypes of the abstract <kbd class="calibre12">TimeType</kbd> type and represent day, millisecond, and nanosecond precision, respectively.</p>
<p class="calibre2">Julia tries to make working with dates and times as simple as possible. This is the reason why, on the one hand, it provides three distinct types, each with its own temporal representation:</p>
<ul class="calibre10">
<li class="calibre11">A <kbd class="calibre12">Date</kbd> object maps to a date—a time entity defined by a day, a month, and a year</li>
<li class="calibre11">An instance of <kbd class="calibre12">Time</kbd> is a moment in time—the hour, the minute, the second, and the milliseconds, but with absolutely no information about the date itself</li>
<li class="calibre11">The <kbd class="calibre12">DateTime</kbd>, as you may have guessed from the name, is an object which puts together a <kbd class="calibre12">Date</kbd> and a <kbd class="calibre12">Time</kbd>, specifying an exact moment in time</li>
</ul>
<p class="calibre2">On the other hand, all these types have, by default and by design, a naive approach to representing dates and times—that is, they do not take into consideration things like time zones, daylight savings, or leap seconds. It's a portrayal of your computer's local date and time, without any extra information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constructing dates and times</h1>
                </header>
            
            <article>
                
<p class="calibre2">In order to construct new date/time objects representing the current date or time, Julia provides two helper functions, <kbd class="calibre12">now</kbd> and <kbd class="calibre12">today</kbd>. Let's look at some examples in the <strong class="calibre4">read-eval-print loop</strong> (<strong class="calibre4">REPL</strong>):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Dates 
 
julia&gt; d = today() 
2018-11-08 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; typeof(d) 
Date </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; dt = now() 
2018-11-08T16:33:34.868 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; dt |&gt; typeof 
DateTime  </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; t = Dates.Time(now()) 
16:34:13.065 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; typeof(t) </strong><br class="title-page-name"/><strong class="calibre1">Time</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">now</kbd> function can also accept an additional argument to return the UTC time (without local adjustments for daylight savings):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; now(UTC) 
2018-11-08T15:35:08.776</strong> </pre>
<p class="calibre2">Internally, all the types wrap an <kbd class="calibre12">Int64</kbd> value that can be accessed through the <kbd class="calibre12">instant</kbd> field:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dt.instant 
Dates.UTInstant{Millisecond}(63677378014868 milliseconds) </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; t.instant 
75147529000000 nanoseconds </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; d.instant 
Dates.UTInstant{Day}(737006 days)</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">instant</kbd> property of the objects reflects the precision level of each type.</p>
<p class="calibre2">Of course, we can also instantiate objects that represent any random moment in time using the dedicated constructors:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; DateTime(2018) # we can pass just the year as a single argument 
2018-01-01T00:00:00 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; DateTime(2018, 6) # passing the year and the month 
2018-06-01T00:00:00 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; DateTime(2018, 6, 15) # year, month and day 
2018-06-15T00:00:00 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; DateTime(2018, 6, 15, 10) # year, month, day and hour (10 AM) 
2018-06-15T10:00:00 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; DateTime(2018, 6, 15, 10, 30) # 15th of June 2018, 10:30 AM  
2018-06-15T10:30:00 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; DateTime(2018, 6, 15, 10, 30, 45) # ...and 45 seconds 
2018-06-15T10:30:45 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; DateTime(2018, 06, 15, 10, 30, 45, 123) # ... and finally, milliseconds  
2018-06-15T10:30:45.123</strong> </pre>
<p class="calibre2">The constructors work in similar ways for <kbd class="calibre12">Date</kbd> and <kbd class="calibre12">Time</kbd>—here are a few examples:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Date(2019) # January 1st 2019 
2019-01-01 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; Date(2018, 12, 31) # December 31st 2018 
2018-12-31 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; Time(22, 05) # 5 past 10 PM 
22:05:00 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; Time(22, 05, 25, 456) # 5 past 10 PM, 25s and 456 milliseconds 
22:05:25.456 </strong> </pre>
<p class="calibre2">The constructors will prevent us from passing the wrong values, resulting in an error. This can be different from other languages that automatically perform date-time arithmetic where, for instance, December 2<span class="calibre5">2,</span> 2018 would be automatically converted into January 1, 2019. That won't happen in Julia:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Date(2018, 12, 32) 
ERROR: ArgumentError: Day: 32 out of range (1:31) 
Stacktrace: 
 [1] Date(::Int64, ::Int64, ::Int64) at ./dates/types.jl:204</strong> </pre>
<p class="calibre2">There are also constructors for the individual date and time components—years, months, days, hours, minutes, seconds, and milliseconds. They return instances of the corresponding <kbd class="calibre12">Period</kbd> type (we'll take a look at periods in detail a bit later). Periods can be used to create date/time objects:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; eleven_hours = Hour(11) 
11 hours </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; half_hour = Minute(30) 
30 minutes </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; brunch_time = Time(eleven_hours, half_hour) 
11:30:00 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; this_year = "2018" 
julia&gt; xmas_month = "12" 
julia&gt; xmas_day = "25" 
julia&gt; Date(Year(this_year), Month(xmas_month), Day(xmas_day)) 
2018-12-25</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parsing strings into dates and times</h1>
                </header>
            
            <article>
                
<p class="calibre2">A common requirement is parsing properly formatted strings coming from an external input (databases, files, user input, and so on) into corresponding date and time objects:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Date("25/12/2019", "dd/mm/yyyy") # Christmas day in 2019 
2019-12-25 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; DateTime("25/12/2019 14,30", "dd/mm/yyyy HH,MM") # xmas day in 2019, at 2:30 PM 
2019-12-25T14:30:00</strong> </pre>
<p class="calibre2">These are the special date-time characters recognised by Julia, together with their significations:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">y</kbd>: Year digit, example <kbd class="calibre12">yyyy</kbd> for <kbd class="calibre12">2015</kbd>, <kbd class="calibre12">yy</kbd> for <kbd class="calibre12">15</kbd></li>
<li class="calibre11"><kbd class="calibre12">m</kbd>: Month digit, <span>example</span> <kbd class="calibre12">m =&gt; 3</kbd> or <kbd class="calibre12">03</kbd></li>
<li class="calibre11"><kbd class="calibre12">u</kbd>: Short month name, <span>example</span> <kbd class="calibre12">Jan</kbd></li>
<li class="calibre11"><kbd class="calibre12">U</kbd>: long month name, <span>example</span> <kbd class="calibre12">January</kbd></li>
<li class="calibre11"><kbd class="calibre12">e</kbd>: Short day of week, <span>example</span> <kbd class="calibre12">Tue</kbd></li>
<li class="calibre11"><kbd class="calibre12">E</kbd>: Long day of week, <span>example</span> <kbd class="calibre12">Tuesday</kbd></li>
<li class="calibre11"><kbd class="calibre12">d</kbd>: Day, <span>example</span> <kbd class="calibre12">3</kbd> or <kbd class="calibre12">03</kbd></li>
<li class="calibre11"><kbd class="calibre12">H</kbd>: Hour digit, <span>example</span> <kbd class="calibre12">HH</kbd> = <kbd class="calibre12">00</kbd></li>
<li class="calibre11"><kbd class="calibre12">M</kbd>: Minute digit, <span>example</span> <kbd class="calibre12">MM</kbd> = <kbd class="calibre12">00</kbd></li>
<li class="calibre11"><kbd class="calibre12">S</kbd>: Second digit, <span>example</span> <kbd class="calibre12">s</kbd> = <kbd class="calibre12">00</kbd></li>
<li class="calibre11"><kbd class="calibre12">s</kbd>: Millisecond digit, <span>example</span> <kbd class="calibre12">.000</kbd></li>
</ul>
<p class="calibre2">With these, we can parse any date/time string into the correct object:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; DateTime("Thursday, 1 of February 2018 at 12.35", "E, d of U yyyy at HH.MM") 
2018-02-01T12:35:00</strong> </pre>
<p class="calibre2">We can also parse multiple strings at once, as elements of an array. First, we create an array of strings that represents valid dates, formatted as <kbd class="calibre12">yyyy-mm-dd</kbd>. We use a comprehension to create the array and name it <kbd class="calibre12">d</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; d = ["$(rand(2000:2020))-$(rand(1:12))-$(rand(1:28))" for _ in 1:100] 
100-element Array{String,1}:  
 "2001-7-1" 
 "2005-9-4"</strong></pre>
<pre class="calibre17"><strong class="calibre1"> "2018-3-3" 
# output truncated </strong> </pre>
<p class="calibre2">Next, we can use dot notation to process the array element-wise using the <kbd class="calibre12">Date</kbd> constructor:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Date.(d, "yyyy-mm-dd") 
100-element Array{Date,1}: 
 2001-07-01 
 2005-09-04 
 2018-03-03 
# output truncated </strong> </pre>
<p class="calibre2">Alternatively, instead of using a string to represent the format of the date, we can use a specialized <kbd class="calibre12">DateFormat</kbd> type:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; date_format = DateFormat("yyyy-mm-dd") 
dateformat"yyyy-mm-dd" </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; Date.(d, date_format) 
100-element Array{Date,1}: 
2001-07-01 
2005-09-04 
2018-03-03 
# output truncated </strong> </pre>
<p class="calibre2">Using a <kbd class="calibre12">DateFormat</kbd> is recommended when parsing a large number of strings for better performance. Julia provides a few formats as part of the standard library, for instance, <kbd class="calibre12">ISODateTimeFormat</kbd> and <kbd class="calibre12">RFC1123Format</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; DateTime("2018-12-25", ISODateTimeFormat) 
2018-12-25T00:00:00</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Formatting dates</h1>
                </header>
            
            <article>
                
<p class="calibre2">If we can parse date-formatted strings into date/time objects, we can also do the reverse. We can output our dates and times as strings using various formats. See the following, for instance:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Dates.format(now(), RFC1123Format) 
"Thu, 08 Nov 2018 20:04:35" </strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining other locales</h1>
                </header>
            
            <article>
                
<p class="calibre2">By default, Julia will use the <kbd class="calibre12">english</kbd> locale, meaning that the names of the days and months will be in English. However, we can internationalize our dates by defining additional locales:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; spanish_months = ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"] 
12-element Array{String,1} # output truncated </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; spanish_days = ["lunes", "martes", "miércoles", "jueves", "viernes", "sábado", "domingo"] 
7-element Array{String,1} # output truncated </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; Dates.LOCALES["es"] = Dates.DateLocale(spanish_months, String[], spanish_days, String[]) 
Dates.DateLocale # output truncated</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">Dates.DateLocale</kbd> function expects four arrays, corresponding to each of the month names, abbreviated month names, day names, and abbreviated day names. As you can see, we haven't provided the abbreviated versions of the names. As long as we don't try to use them, we'll be fine:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Dates.format(now(), "E, d U yyyy", locale = "es") 
"jueves, 8 noviembre 2018"</strong> </pre>
<p class="calibre2">However, attempting to use the abbreviated day name will result in an error:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Dates.format(now(), "e, d U yyyy", locale = "es") 
ERROR: BoundsError: attempt to access 0-element Array{String,1} at index [4]</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with date and time accessors</h1>
                </header>
            
            <article>
                
<p class="calibre2">If we want to access the individual parts of a date (year, month, day), we can retrieve the various components through the available accessor functions:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; earth_day = Date(2018, 4, 22) 
2018-04-22 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt;year(earth_day) # the year 
2018 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; month(earth_day) # the month  
4</strong> </pre>
<p class="calibre2">The API also exposes compound methods, for brevity:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; monthday(earth_day) # month and day 
(4, 22) </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; yearmonthday(earth_day) # year month and day 
(2018, 4, 22)</strong> </pre>
<p class="calibre2">Similar accessors are available for <kbd class="calibre12">DateTime</kbd>—but no compound methods are provided:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; earth_hour = DateTime(2018, 4, 22, 22, 00) 
2018-04-22T22:00:00 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; hour(earth_hour) # the hour 
22 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; minute(earth_hour) # the minute 
0</strong> </pre>
<p class="calibre2">Alternative accessors that return <kbd class="calibre12">Period</kbd> objects are also defined—they have uppercase names:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Hour(earth_hour) # a period of 22 hours 
22 hours </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; Month(earth_hour) # a period of 4 months 
4 months 
 
julia&gt; Month(earth_hour) |&gt; typeof |&gt; supertype</strong><br class="title-page-name"/><strong class="calibre1"> DatePeriod 
 
julia&gt; supertype(DatePeriod) 
Period</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Querying dates</h1>
                </header>
            
            <article>
                
<p class="calibre2">Once we have a date object, we can get a wealth of extra information about it, such as the day of the week, leap year, day of the year, and so on. We can use the <kbd class="calibre12">Dates</kbd> API to extract this kind of information about our date/time object.</p>
<p class="calibre2">Consider this:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; yoga_day = Date(2019, 6, 21) # Really, the International Yoga Day does exist! 
2019-06-21</strong> </pre>
<p class="calibre2">Are you curious when Yoga day falls in 2019? Let's use our Julia skills to figure that out:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dayname(yoga_day) 
"Friday"</strong> </pre>
<p class="calibre2">If you need the numerical value of the day (within the week), there's also <kbd class="calibre12">dayofweek(yoga_day)</kbd>, that obviously returns <kbd class="calibre12">5</kbd>, since Friday is the fifth day of the week.</p>
<p class="calibre2">Of course, we can use localized names here too:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dayname(yoga_day, locale="es") 
"viernes"</strong> </pre>
<p class="calibre2">Another useful function we can call is <kbd class="calibre12">dayofweekofmonth(yoga_day)</kbd>, which will tell us which Friday of the month it is—it's the third Friday of the month of June, in 2019.</p>
<p class="calibre2">If you're not sure how this can be useful, take for example, events that always take place with regularity on a certain day of the month. A good example is a meetup I attend that always takes place on the third Thursday of each month.</p>
<p class="calibre2">We can also get a wealth of information about the month and the year:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; monthname(yoga_day, locale="es") # June, with the Spanish locale  
"junio" </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; isleapyear(yoga_day) # 2019 is not a leap year 
false </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; dayofyear(yoga_day) # It's the 172nd day of 2019 
172 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; quarterofyear(yoga_day) # 2nd quarter of 2019 
2 </strong> </pre>
<div class="packttip">The <kbd class="calibre24">Dates</kbd> API is very rich, including a lot more methods than it would make sense to present here. Please visit the documentation page at <a href="https://docs.julialang.org/en/v1/stdlib/Dates/index.html#stdlib-dates-api-1" class="calibre19"><span>https://docs.julialang.org/en/v1/stdlib/Dates/index.html#stdlib-dates-api-1</span></a><span>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the date ranges</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia allows us to define ranges of dates to express continuous periods of time. For example, we could represent the whole year as the range of days between January 1 and December 31:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; year_2019 = Date(2019, 1, 1):Day(1):Date(2019,12,31) 
2019-01-01:1 day:2019-12-31</strong> </pre>
<p class="calibre2">We have created a date range with a step of one day—so <kbd class="calibre12">365</kbd> items, since 2019 is not a leap year:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; typeof(year_2019) 
StepRange{Date,Day} </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; size(year_2019) 
(365,)</strong> </pre>
<p class="calibre2">We can instantiate the actual <kbd class="calibre12">Date</kbd> objects using the aptly named <kbd class="calibre12">collect</kbd> function:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; collect(year_2019) 
365-element Array{Date,1}: 
 2019-01-01 
 2019-01-02 
 2019-01-03 
# output truncated</strong> </pre>
<p class="calibre2">Also, of course, we can access the elements by index as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; year_2019[100] # day 100 
2019-04-10</strong> </pre>
<p class="calibre2">It's also possible to define ranges with other steps, such as monthly intervals:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; year_2019 = Date(2019, 1, 1):Month(1):Date(2019,12,31) 
2019-01-01:1 month:2019-12-01 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; collect(year_2019) # First day of each of the 12 months 
12-element Array{Date,1}: 
 2019-01-01 
 2019-02-01 
 2019-03-01 
# output truncated</strong> </pre>
<p class="calibre2">We can pass any <kbd class="calibre12">Period</kbd> object for the step, for instance:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; year_2019 = Date(2019, 1, 1):Month(3):Date(2019,12,31) # Quarterly 
2019-01-01:3 months:2019-10-01 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; collect(year_2019) # The first of each of the 4 quarters 
4-element Array{Date,1}: 
 2019-01-01 
 2019-04-01 
 2019-07-01 
 2019-10-01 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; year_2019 = Date(2019, 1, 1):Week(2):Date(2019,12,31) # Bi weekly 
2019-01-01:2 weeks:2019-12-31 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; collect(year_2019) 
27-element Array{Date,1}: 
 2019-01-01 
 2019-01-15 
 2019-01-29 
# output truncated</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Period types and period arithmetic</h1>
                </header>
            
            <article>
                
<p class="calibre2">We have already seen some of the <kbd class="calibre12">Period</kbd> constructors. These are all the available ones—<kbd class="calibre12">Day</kbd>, <kbd class="calibre12">Week</kbd>, <kbd class="calibre12">Month</kbd>, <kbd class="calibre12">Year</kbd>, <kbd class="calibre12">Hour</kbd>, <kbd class="calibre12">Minute</kbd>, <kbd class="calibre12">Second</kbd>, <kbd class="calibre12">Millisecond</kbd>, <kbd class="calibre12">Microsecond</kbd>, and <kbd class="calibre12">Nanosecond</kbd>. The <kbd class="calibre12">Period</kbd> type is an abstract type with two concrete subtypes, <kbd class="calibre12">DatePeriod</kbd> and <kbd class="calibre12">TimePeriod</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; subtypes(Period) 
2-element Array{Any,1}: 
 DatePeriod 
 TimePeriod</strong> </pre>
<p class="calibre2"><kbd class="calibre12">Period</kbd> in Julia represents a duration of time. It is a very useful abstraction representing vague time concepts that people use routinely. Think about a month—how many days does a month have—30 or 31? What about 28? Or 29?</p>
<p class="calibre2">Many times, it can be useful to work with vague abstractions without switching to actual dates until more information is provided. Take, for instance, the hypothetical case of a trip to Mars. According to <a href="https://image.gsfc.nasa.gov/poetry/venus/q2811.html" class="calibre9"><span>https://image.gsfc.nasa.gov/poetry/venus/q2811.html</span></a><a href="https://image.gsfc.nasa.gov/poetry/venus/q2811.html" class="calibre9">, a return trip to Mars will take <kbd class="calibre24">21 months</kbd>—<kbd class="calibre24">9</kbd> to get there, <kbd class="calibre24">3</kbd> to stay there, and <kbd class="calibre24">9</kbd> more to get back:</a></p>
<pre class="calibre17"><strong class="calibre1">julia&gt; duration_of_trip_to_mars = Month(9) * 2 + Month(3) 
21 months</strong> </pre>
<p class="calibre2">Exactly how long these 21 months will take is undetermined until we actually decide when we start the trip:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; take_off_day = Date(2020, 1, 15) 
2020-01-15</strong> </pre>
<p class="calibre2">Now we can compute how long the astronauts will be gone for:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; return_day = take_off_day + duration_of_trip_to_mars 
2021-10-15 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; time_diff = return_day - take_off_day 
639 days</strong> </pre>
<p class="calibre2">However, if, for technical reasons, the launch date will be postponed by five months, the result will be different:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; take_off_day += Month(5) 
2020-06-15 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; return_day = take_off_day + duration_of_trip_to_mars 
2022-03-15 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; time_diff = return_day - take_off_day 
638 days</strong> </pre>
<div class="packttip">It is important to keep in mind that unlike other programming languages, which make assumptions about the default length of a month—such as 31 days in JavaScript or 30 days in PHP—Julia takes a different approach. For a detailed explanation of <kbd class="calibre24">Period</kbd> arithmetic, you can read the official documentation at <a href="https://docs.julialang.org/en/v1/stdlib/Dates/index.html#TimeType-Period-Arithmetic-1" class="calibre19"><span>https://docs.julialang.org/en/v1/stdlib/Dates/index.html#TimeType-Period-Arithmetic-1.</span></a></div>
<p class="calibre2">A period doesn't necessarily need to be a complete amount of time. Julia allows us to express irregular intervals like <kbd class="calibre12">1</kbd> month and <kbd class="calibre12">2</kbd> weeks. However, an irregular amount of time (which combines different types of periods) will be internally represented by a different type—not the <kbd class="calibre12">Period</kbd>, but the <kbd class="calibre12">CompoundPeriod</kbd>. Here's how this works:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; isa(Month(3), Period) 
true </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; isa(Month(3) + Month(1), Period) 
true </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; isa(Month(1) + Week(2), Period)  
false </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; isa(Month(1) + Week(2), Dates.CompoundPeriod)  
true</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Date adjustments</h1>
                </header>
            
            <article>
                
<p class="calibre2"><kbd class="calibre12">Period</kbd> arithmetic is very powerful, but sometimes we need to express more flexible rules that are dependent on other dates. I'm thinking about <em class="calibre16">last day of the next month</em>, <em class="calibre16">next Tuesday</em>, or <em class="calibre16">the third Monday of each month</em>.</p>
<p class="calibre2">For such cases, the <kbd class="calibre12">Dates</kbd> module exposes the adjuster API. For starters, we have the <kbd class="calibre12">firstdayof*</kbd> and the <kbd class="calibre12">lastdayof*</kbd> family of functions—<kbd class="calibre12">firstdayofweek</kbd>, <kbd class="calibre12">firstdayofmonth</kbd>, <kbd class="calibre12">firstdayofquarter</kbd>, and <kbd class="calibre12">firstdayofyear</kbd>; plus <kbd class="calibre12">lastdayofweek</kbd>, <kbd class="calibre12">lastdayofmonth</kbd>, <kbd class="calibre12">lastdayofquarter</kbd>, and <kbd class="calibre12">lastdayofyear</kbd>, respectively. They take as input a date/time object and <em class="calibre16">adjust</em> it to the indicated point in time:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; firstdayofweek(Date(2019, 1, 31)) 
2019-01-28</strong> </pre>
<p class="calibre2">In 2019, the first day of the week includes January 31 is Monday, 28.</p>
<p class="calibre2">The <kbd class="calibre12">lastdayof*</kbd> family of functions works in a similar manner. But useful as they are, they don't provide enough flexibility. Luckily, we're covered. If we need other dates apart from the first or the last day, we have to reach for the <kbd class="calibre12">tonext</kbd> and <kbd class="calibre12">toprev</kbd> pair of functions. They come in two flavors. The first method takes a subtype of <kbd class="calibre12">TimeType</kbd> (that is, any <kbd class="calibre12">Time</kbd>, <kbd class="calibre12">Date</kbd>, <kbd class="calibre12">DateTime</kbd>) and a day of the week:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; tonext(Date(2019, 4, 1), Saturday) 
2019-04-06</strong> </pre>
<p class="calibre2">The next Saturday after April Fool's Day falls on April 7 2019.</p>
<p class="calibre2">The other method of <kbd class="calibre12">tonext</kbd> is even more powerful—it accepts a similar <kbd class="calibre12">TimeType</kbd> and a function. It will adjust the date until the function returns <kbd class="calibre12">true</kbd>. To understand how useful this is, let's get back to our previous meetup example, the meeting I attend every third Thursday of each month. To find out when the next meeting will take place, all I have to do is ask Julia:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; tonext(today()) do d  # today is Thu 8th of November, 2019 
         dayofweek(d) == Thursday &amp;&amp; dayofweekofmonth(d) == 3 
       end 
2018-11-15</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">toprev</kbd> function works in a similar way.</p>
<p class="calibre2">Another function, <kbd class="calibre12">filter</kbd>, allows us to obtain all the matching dates as an <kbd class="calibre12">Iterator</kbd>. Following up on our meetups schedule, let's try to find out the dates of all the meetings in 2019. But we must also take into account that in the second half of May, the organizer will attend a business trip, and that August is a holiday month. So, there won't be meetings during these intervals. How would we express this? It turns out that with Julia, it's quite simple (and very readable):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; filter(Date(2019):Day(1):Date(2020)) do d 
           ! in(d, Date(2019, 5, 15):Day(1):Date(2019, 5, 31)) &amp;&amp;  
           month(d) != August &amp;&amp;  
           dayofweek(d) == Thursday &amp;&amp;  
           dayofweekofmonth(d) == 3 
   end |&gt; collect  
10-element Array{Date,1}: 
 2019-01-17 
 2019-02-21 
 2019-03-21 
 2019-04-18 
 2019-06-20 
 2019-07-18 
 2019-09-19 
 2019-10-17 
 2019-11-21 
 2019-12-19</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rounding of dates</h1>
                </header>
            
            <article>
                
<p class="calibre2">There might be situations where we have a date/time and a need to compute the previous, or next complete time interval, for example, the next hour, or the previous day. The <kbd class="calibre12">Dates</kbd> API exposes a few methods for rounding <kbd class="calibre12">Date</kbd> and <kbd class="calibre12">DateTime</kbd> objects—<kbd class="calibre12">floor</kbd>, <kbd class="calibre12">ceil</kbd>, and <kbd class="calibre12">time</kbd>. They are quite intuitive and very powerful:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; now() 
2018-11-08T21:13:20.605 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1"># round down to the nearest hour 
julia&gt; floor(now(), Hour) 
2018-11-08T21:00:00 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1"># or to the nearest 30 minutes increment 
julia&gt; floor(now(), Minute(30))  
2018-11-08T21:00:00 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1"># it also works with dates  
julia&gt; floor(today(), Month) # today() is the 8th of Nov 2018 
2018-11-01</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">ceil</kbd> function works similarly, but instead of rounding down, it rounds up. As for the <kbd class="calibre12">round</kbd> function, it will round up or down, depending on whichever is the closest value:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; round(today(), Month) 
2018-11-01 # today is the 11th so beginning of month is closer 
 
julia&gt; round(today() + Day(10), Month) 
2018-12-01 # end of month is closer</strong> </pre>
<div class="packttip">Rounding can behave unexpectedly in a few edge cases—for more details please check the official documentation at <a href="https://docs.julialang.org/en/v1/stdlib/Dates/index.html#Rounding-1" class="calibre19"><span>https://docs.julialang.org/en/v1/stdlib/Dates/index.html#Rounding-1</span></a><span>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding support for time zones</h1>
                </header>
            
            <article>
                
<p class="calibre2">As previously mentioned, by default, Julia's date/time objects operate in local time, completely ignoring time zones. However, we can easily extend them to become time-zone aware using the <kbd class="calibre12">TimeZones</kbd> package. Please install it in the usual way:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Pkg</strong><br class="title-page-name"/><strong class="calibre1">pkg&gt; add TimeZones</strong></pre>
<p class="calibre2">Once we inform the compiler that we'll be using <kbd class="calibre12">TimeZones</kbd>, a wealth of timezone-related functionalities become available at our fingertips.</p>
<p class="calibre2">We can start by exploring the available time zones:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; timezone_names() 
439-element Array{AbstractString,1}: 
 "Africa/Abidjan" 
 "Africa/Accra" 
# output truncated</strong> </pre>
<p class="calibre2">Let's create a time zone object for <kbd class="calibre12">Amsterdam</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; amstz = TimeZone("Europe/Amsterdam") 
Europe/Amsterdam (UTC+1/UTC+2)</strong> </pre>
<p class="calibre2">In Julia, a <kbd class="calibre12">TimeZone</kbd> is an abstract type that represents information regarding a specific time zone, which means that it can't be instantiated—we can't create objects of this type. Instead, one of its two subtypes will be automatically used—<kbd class="calibre12">VariableTimeZone</kbd> or <kbd class="calibre12">FixedTimeZone</kbd>. <kbd class="calibre12">VariableTimeZone</kbd> represents a time zone whose offset changes depending on the time of the year—to take into account summertime/daylight savings time. <kbd class="calibre12">FixedTimeZone</kbd> has an invariable offset.</p>
<p class="calibre2">The <kbd class="calibre12">Europe/Amsterdam (UTC+1/UTC+2)</kbd> is such a <kbd class="calibre12">VariableTimeZone</kbd>. This is indicated by the information within the round brackets, signaling the two offsets of this time zone. Checking the type will confirm it:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; typeof(amstz) 
TimeZones.VariableTimeZone</strong> </pre>
<p class="calibre2">The time zones that don't change their offsets are instances of <kbd class="calibre12">FixedTimeZone</kbd>. Such examples are <kbd class="calibre12">UTC</kbd> and <kbd class="calibre12">GMT</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; typeof(TimeZone("GMT")) 
TimeZones.FixedTimeZone</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">TimeZones</kbd> package also provides a special string literal, <kbd class="calibre12">tz"..."</kbd>. It exposes the same functionality as <kbd class="calibre12">TimeZone(...)</kbd> with a bit less typing:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; tz"Europe/Bucharest" 
Europe/Bucharest (UTC+2/UTC+3)</strong> </pre>
<p class="calibre2">Armed with this knowledge, we can now create time zone-aware date/time values. These come in the form of <kbd class="calibre12">ZonedDateTime</kbd> objects, and, as the name suggests, represent a mixture of <kbd class="calibre12">DateTime</kbd> and <kbd class="calibre12">TimeZone</kbd>:</p>
<pre class="calibre17"><strong class="calibre1"># 8 PM, Christmas Day in Vienna, 2018 
julia&gt; ZonedDateTime(DateTime(2018, 12, 25, 20), tz"Europe/Vienna") 
2018-12-25T20:00:00+01:00</strong> </pre>
<p class="calibre2">This can be written a bit more succinctly by skipping the explicit invocation of <kbd class="calibre12">DateTime</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; ZonedDateTime(2018, 12, 25, 20, tz"Europe/Vienna") 
2018-12-25T20:00:00+01:00</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">TimeZones</kbd> module also provides a series of utility methods. First of all, we can retrieve the local time zone by using the aptly named <kbd class="calibre12">localzone</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; localzone() 
Europe/Madrid (UTC+1/UTC+2)</strong> </pre>
<p class="calibre2">I live in Barcelona, so this is my current time zone—your output will correspond to your actual time zone.</p>
<p class="calibre2">Two extension methods are provided for <kbd class="calibre12">now</kbd> and <kbd class="calibre12">today</kbd>—in the form of <kbd class="calibre12">now(::TimeZone)</kbd> and <kbd class="calibre12">today(::TimeZone)</kbd>, respectively:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; now() 
2018-11-08T22:32:59.336 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; now(tz"Europe/Moscow") 
2018-11-09T00:33:23.138+03:00 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; today() 
2018-11-08 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; today(tz"Europe/Moscow") 
2018-11-09</strong> </pre>
<p class="calibre2">Instead of <kbd class="calibre12">today(::TimeZone)</kbd>, another function, <kbd class="calibre12">todayat</kbd>, can be used with two arguments—the time of the day as a <kbd class="calibre12">Time</kbd> object and a <kbd class="calibre12">TimeZone</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; todayat(Time(22, 30), tz"Europe/Moscow") 
2018-11-09T22:30:00+03:00</strong> </pre>
<p class="calibre2">This time we get 10:30 P.M., <kbd class="calibre12">Moscow</kbd> time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting time zones</h1>
                </header>
            
            <article>
                
<p class="calibre2">One of the most basic things we'll want to do is to convert a <kbd class="calibre12">DateTime</kbd> from one time zone to another. That's straightforward with the <kbd class="calibre12">astimezone</kbd> function:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; xmas_day = ZonedDateTime(2018, 12, 25, 20, tz"Europe/Vienna") 
2018-12-25T20:00:00+01:00 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; astimezone(xmas_day, tz"Australia/Sydney") 
2018-12-26T06:00:00+11:00 </strong></pre>
<p class="calibre2">While you're celebrating Christmas in Vienna at 8 P.M., in Sydney, Australia, it will already be 6 A.M. the next day.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parsing date strings</h1>
                </header>
            
            <article>
                
<p class="calibre2">We have already seen how to parse date and date/time strings using Julia's <kbd class="calibre12">Dates</kbd> API. The <kbd class="calibre12">TimeZones</kbd> package takes this functionality one step further, allowing us to parse date/time strings that include time zones:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; ZonedDateTime("2018-12-25T20:00:00+01:00", "yyyy-mm-ddTHH:MM:SSzzzz") 
2018-12-25T20:00:00+01:00</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ZonedDateTime period arithmetic</h1>
                </header>
            
            <article>
                
<p class="calibre2">You will be happy to hear that arithmetic with time zone-aware objects works just like its regular <kbd class="calibre12">TimeType</kbd> counterpart. However, you have to take extra care when dealing with periods of time that start in an offset (as in wintertime) and finish in another offset (say, summertime). For instance, let's see what happens when we play with times around the moment when Europe switches to daylight savings time.</p>
<p class="calibre2">The clock changes during the last Sunday of March. Take a minute and try to find out the date of the last Sunday of March in 2019.</p>
<p class="calibre2">Here's my solution:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; last_day_of_winter = tonext(today()) do d 
           dayofweek(d) == Sunday &amp;&amp; 
           month(d) == March &amp;&amp; 
           dayofmonth(d) &gt; dayofmonth(lastdayofmonth(d) - Day(7)) 
       end 
2019-03-31</strong> </pre>
<p class="calibre2">Now, let's give it a time zone—let's say, London's:</p>
<pre class="calibre17">london_time = ZonedDateTime(DateTime(last_day_of_winter), tz"Europe/London") 
2019-03-31T00:00:00+00:00 </pre>
<p class="calibre2">Adding a day to this will cause the time zone to change:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; next_day = london_time + Day(1) 
2019-04-01T00:00:00+01:00</strong> </pre>
<p class="calibre2">But what if we now remove the equivalent of one day, but in hours? We should get the value of <kbd class="calibre12">london_time</kbd> again, right? Take a look:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; next_day - Hour(24) 
2019-03-30T23:00:00+00:00</strong> </pre>
<p class="calibre2">Oops, not quite! Subtracting <kbd class="calibre12">24</kbd> hours actually pushed us one hour earlier than <kbd class="calibre12">london_time</kbd>. The reason for this is that the change of offset (switching to summertime) effectively caused a whole hour at 2 A.M. to be skipped on the 25th, making that day only 23 hours long.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time zone-aware date ranges</h1>
                </header>
            
            <article>
                
<p class="calibre2">Another important thing to keep in mind when dealing with time zones involves date ranges. If the start item of your range is in a time zone, but the end item is in a different time zone, the resulting value corresponding to the end item will be silently converted to the time zone of the start item. An example will make this clear:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; interval = ZonedDateTime(2019, 8, 1, tz"Europe/London"):Hour(1):ZonedDateTime(2019, 8, 2, tz"Australia/Sydney") 
2019-08-01T00:00:00+01:00:1 hour:2019-08-02T00:00:00+10:00 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; collect(interval) 
16-element Array{TimeZones.ZonedDateTime,1}: 
2019-08-01T00:00:00+01:00 
# output truncated 
2019-08-01T15:00:00+01:00</strong> </pre>
<p class="calibre2">The last item in the array, <kbd class="calibre12">2018-08-01T15:00:00+01:00</kbd>, represents the same time as the end item in the interval, <kbd class="calibre12">2018-08-02T00:00:00+10:00</kbd>—but it's using the London time zone, not Sydney's:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; astimezone(ZonedDateTime("2019-08-01T00:00:00+01:00", "yyyy-mm-ddTHH:MM:SSzzzz"), tz"Australia/Sydney" ) 
2019-08-01T09:00:00+10:00</strong> </pre>
<p class="calibre2">It's the same time, but a different time zone.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time series data in Julia</h1>
                </header>
            
            <article>
                
<p class="calibre2">A time series is a collection of observations of well-defined data items obtained via repeated measurements over time. This collection of quantitative observations is ordered, allowing us to understand the underlying structure. Examples of such data include the daily closing price of a company's stock, quarterly sales figures for a retailer, continuous monitoring of a person's blood glucose levels, or hourly air temperatures.</p>
<p class="calibre2">Julia's package ecosystem provides a powerful functionality for working with time series through the <kbd class="calibre12">TimeSeries</kbd> package. The package provides an extensive API that covers the full range of tasks, from reading and writing CSV files with temporal data, to filtering and segmenting time series, to mathematical and logical operators, and plotting. Let's add it to our toolbox:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Pkg 
pkg&gt; add TimeSeries </strong> </pre>
<p class="calibre2">Now, let's get some time series data. The easiest thing we can do is to reach for the <kbd class="calibre12">MarketData</kbd> package, it provides open source financial data for research and testing and works flawlessly with <kbd class="calibre12">TimeSeries</kbd>. Once you install it in the usual way (<kbd class="calibre12">pkg&gt; add MarketData</kbd>), the module will expose a series of variables corresponding to different datasets. Some of them are small test databases, called <kbd class="calibre12">cl</kbd>, <kbd class="calibre12">ohcl</kbd>, <kbd class="calibre12">ohlcv</kbd>, and so on. For example, the <kbd class="calibre12">ohcl</kbd> dataset contains 500 rows of market data, from January 3, 2000 to December 31, 2001—each row contains a <kbd class="calibre12">Date</kbd>, plus the <kbd class="calibre12">Open</kbd>, <kbd class="calibre12">High</kbd>, <kbd class="calibre12">Low</kbd>, and <kbd class="calibre12">Close</kbd> values. Here's what it looks like:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using MarketData 
julia&gt; MarketData.ohlc 
500x4 TimeSeries.TimeArray{Float64,2,Date,Array{Float64,2}} 2000-01-03 to 2001-12-31</strong> </pre>
<p class="calibre2">You can see that it's of the type <kbd class="calibre12">TimeArray</kbd> and it spans the time interval I just mentioned:</p>
<p class="CDPAlignCenter"><img src="assets/eb05f02d-8eab-4dfd-aa5f-0736a22adb87.png" class="calibre141"/></p>
<p class="calibre2">The <kbd class="calibre12">MarketData</kbd> module also exposes larger historical prices and volume data for three major companies—Apple (<kbd class="calibre12">AAPL</kbd>), Boeing (<kbd class="calibre12">BA</kbd>), and Caterpillar (<kbd class="calibre12">CAT</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A quick look at our data with Plots and PyPlot</h1>
                </header>
            
            <article>
                
<p class="calibre2">As the old saying goes, A<em class="calibre16"> picture is worth a thousand words</em>, so let's get a quick feel for our data by plotting it. It's a great opportunity to introduce one of the best Julia data visualization packages—<kbd class="calibre12">Plots</kbd>. Unlike <kbd class="calibre12">Gadfly</kbd>, which we've previously used, <kbd class="calibre12">Plots</kbd> takes a different approach—it's an interface over many different plotting libraries. Basically, it's like middleware, providing a common, unifying API for other plotting packages (called <strong class="calibre4">backends</strong>). In Julia, different plotting packages have different features and strengths—and depending on the user's specific needs, they may be forced to learn yet another library, change the code, and so on, in order to interchangeably use different plotting packages. <kbd class="calibre12">Plots</kbd> addresses this problem through a unifying API coupled with a simple mechanism that allows for swapping backends on the fly.</p>
<p class="calibre2">The <kbd class="calibre12">Plots</kbd> package supports the following backends—<kbd class="calibre12">PyPlot</kbd>, <kbd class="calibre12">Plotly</kbd> or <kbd class="calibre12">PlotlyJS</kbd>, <kbd class="calibre12">GR</kbd>, <kbd class="calibre12">UnicodePlots</kbd>, <kbd class="calibre12">PGFPlots</kbd>, <kbd class="calibre12">InspectDR</kbd>, and <kbd class="calibre12">HDFS5</kbd>. Which one should you use? It depends on the actual use case, but as a general rule, in the words of <kbd class="calibre12">Plots</kbd> author—<em class="calibre16">GR for speed, Plotly(JS) for interactivity, PyPlot otherwise</em>.</p>
<div class="packtinfobox">Please read the official documentation at <a href="http://docs.juliaplots.org/latest/backends/" class="calibre19"><span>http://docs.juliaplots.org/latest/backends/</span></a> to understand the pros and cons of each backend.</div>
<p class="calibre2">We'll use <kbd class="calibre12">PyPlot</kbd>, a Julia wrapper for the popular Python package with the same name. Let's install both <kbd class="calibre12">Plots</kbd> and <kbd class="calibre12">PyPlot</kbd>. Running <kbd class="calibre12">pkg&gt; add Plots</kbd> should be straightforward. Next, <kbd class="calibre12">pkg&gt; add PyPlot</kbd> will be more involved. As <kbd class="calibre12">PyPlot</kbd> uses <kbd class="calibre12">PyCall.jl</kbd> to invoke Python code, depending on your current Julia installation, <kbd class="calibre12">Pkg</kbd> might also have to install the <kbd class="calibre12">miniconda</kbd> Python distribution. So it might take a few minutes.</p>
<p class="calibre2">To start using <kbd class="calibre12">Plots</kbd> with <kbd class="calibre12">PyPlot</kbd>, please make sure you run the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Plots 
julia&gt; pyplot() 
Plots.PyPlotBackend()</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">pyplot</kbd> function configures the <kbd class="calibre12">PyPlot</kbd> backend to be used by <kbd class="calibre12">Plots</kbd>.</p>
<div class="packttip">Right after installing <kbd class="calibre24">PyPlot</kbd>, when attempting to run <kbd class="calibre24">pyplot()</kbd>, you might get an error. Please follow the instructions provided by the package and restart the Julia REPL if so advised.</div>
<p class="calibre2">We're now ready to go! The module exposes the <kbd class="calibre12">plot</kbd> function, which at its simplest can be invoked with two collections of values, corresponding to the x and y coordinates:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(1:10, rand(10))</strong></pre>
<p class="calibre2">Yo<span class="calibre5">u should see a plot being rendered in a new window—</span><span class="calibre5">mine looks like this, but since we're visualising random values, yours will be different:</span></p>
<div class="CDPAlignCenter1"><img src="assets/24e3b1b9-6fa8-40b5-9482-315774c49d10.png" class="calibre142"/></div>
<p class="calibre2">It's a plot of ten random values, rendered by <kbd class="calibre12">PyPlot</kbd>.</p>
<p class="calibre2">One cool thing about these plots is that they can be mutated using the <kbd class="calibre12">plot!</kbd> function. For instance, we can add two lines to it by plotting a matrix:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot!(rand(10, 2))</strong> </pre>
<p class="calibre2">The resulting output is as follows:</p>
<div class="CDPAlignCenter1"><img src="assets/3e2175ee-847b-4e60-992e-c05ada127727.png" class="calibre143"/></div>
<p class="calibre2">Plots can be enhanced using attributes. They allow us to add labels, titles, and to style the visualizations and so on. For instance, here's how we'd render our previous plot with extra attributes:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(1:10, rand(10,3), title="Three Lines",label=["First" "2nd" "Third Line"],lw=3) # lw stands for line width</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/5689f91d-543f-4d47-ab6f-029a6eae6867.png" class="calibre144"/></p>
<p class="calibre2">The API also exposes functions for modifying the plot after it has been rendered:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; xlabel!("Beautiful lines") 
julia&gt; ylabel!("Small lines")</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/396804be-9e5f-457b-992e-caaceafbb178.png" class="calibre145"/></p>
<p class="calibre2">Going back to our market data, you'll be happy to hear that <kbd class="calibre12">TimeSeries</kbd> provides out-of-the-box integration with <kbd class="calibre12">Plots</kbd>. All we have to do is run the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(MarketData.ohlc)</strong> </pre>
<p class="calibre2">This is what we get:</p>
<p class="CDPAlignCenter"><img src="assets/773c1573-a29b-47c6-8e9b-4357d1258405.png" class="calibre146"/></p>
<p class="calibre2">We can see that the market had been growing, reaching a peak in March 2000, then dropping suddenly to around 50–60. It stayed there for a few months, and then it dropped again at the end of September and stayed under 30 all the way through to the end of 2001. The four values, <kbd class="calibre12">Open</kbd>, <kbd class="calibre12">Close</kbd>, <kbd class="calibre12">High</kbd>, and <kbd class="calibre12">Low</kbd> seem to be highly correlated. We can plot them individually:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(MarketData.ohlc[:High])</strong> </pre>
<p class="calibre2">We get the following result:</p>
<p class="CDPAlignCenter"><img src="assets/f9fd4d5e-cf7f-49ae-8805-8a86d4ee1388.png" class="calibre147"/></p>
<p class="calibre2">We can append extra values like this:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot!(MarketData.ohlc[:Low])</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/29a912d7-2bf6-4fab-b2b5-18350a9f8a5a.png" class="calibre148"/></p>
<p class="calibre2">Visualizing the high versus low values, we can see higher variations in the periods before the market crash.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The TimeArray type</h1>
                </header>
            
            <article>
                
<p class="calibre2">So what's with this <kbd class="calibre12">TimeArray</kbd> then, you may be wondering? It does look like an interesting beast, in that we can index into it using square brackets and the names of columns. We can use the <kbd class="calibre12">fieldnames</kbd> function to see what properties it exposes:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; fieldnames(typeof(MarketData.ohlc)) 
(:timestamp, :values, :colnames, :meta)</strong> </pre>
<p class="calibre2">Indeed, a <kbd class="calibre12">TimeArray</kbd> is a composite type—a <kbd class="calibre12">struct</kbd>, in Julia parlance—with four fields.</p>
<p class="calibre2">The <kbd class="calibre12">timestamp</kbd> field represents a vector of time values—the ones that hold the temporal coordinates of our time series. So if we look at our <kbd class="calibre12">TimeArray</kbd> object, we'll see this in the first row:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; MarketData.ohlc |&gt; head 
6×4 TimeArray{Float64,2,Date,Array{Float64,2}} 2000-01-03 to 2000-01-10 </strong> </pre>
<p class="calibre2">It looks like this:</p>
<div class="CDPAlignCenter1"><img src="assets/bb9db558-b55e-4d3c-954e-9343e9c66ade.png" class="calibre149"/></div>
<p class="calibre2">In this output, <kbd class="calibre12">2000-01-03</kbd> is the first value in the <kbd class="calibre12">timestamp</kbd> array. We can access the array using the <kbd class="calibre12">timestamp</kbd> getter:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; timestamp(MarketData.ohlc) 
500-element Array{Date,1}: 
 2000-01-03 
 2000-01-04 
 2000-01-05 
# output truncated 
 
julia&gt; timestamp(MarketData.ohlc)[1]  
2000-01-03</strong> </pre>
<p class="calibre2">Depending on the actual information in the dataset, its type can be <kbd class="calibre12">Date</kbd> (as in our case), <kbd class="calibre12">Time</kbd>, or <kbd class="calibre12">DateTime</kbd>—any subtype of <kbd class="calibre12">TimeType</kbd>.</p>
<p class="calibre2">When constructing a <kbd class="calibre12">TimeArray</kbd>, you must be careful because the <kbd class="calibre12">timestamp</kbd> data has to be sorted—otherwise, the constructor will error out.</p>
<p class="calibre2">By analogy, with the <kbd class="calibre12">timestamp</kbd> field, you can probably guess what the <kbd class="calibre12">values</kbd> property is all about. It holds the numerical data of the time series:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; values(MarketData.ohlc) 
500×4 Array{Float64,2}</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<div class="CDPAlignCenter1"><img src="assets/c8b84b6a-445e-4ffd-a2c5-ae055a8b7e07.png" class="calibre150"/></div>
<p class="calibre2">Obviously, the row count of the <kbd class="calibre12">values</kbd> array must match the length of the <kbd class="calibre12">timestamp</kbd> collection. Less obviously, all the values inside the <kbd class="calibre12">values</kbd> array must be of the same type.</p>
<p class="calibre2">Thus, each row in a <kbd class="calibre12">TimeArray</kbd> is composed of an item from the <kbd class="calibre12">timestamp</kbd> collection and the corresponding row from the <kbd class="calibre12">values</kbd> array:</p>
<p class="CDPAlignCenter"><img src="assets/6814dcbf-990b-40f3-8638-045d726da3fd.png" class="calibre151"/></p>
<p class="calibre2">The <kbd class="calibre12">colnames</kbd> function returns the array of column names for each column in the values field. They are returned as symbols:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; colnames(MarketData.ohlc)  
4-element Array{Symbol,1}: 
 :Open 
 :High 
 :Low 
 :Close </strong> </pre>
<p class="calibre2">The only hard constraint here is that the number of items in the <kbd class="calibre12">colnames</kbd> vector must match the number of columns in the <kbd class="calibre12">values</kbd> collection. Due to the fact that <kbd class="calibre12">TimeArrays</kbd> are indexable by column name, duplicate strings in the <kbd class="calibre12">colnames</kbd> vector will be modified automatically by the constructor. Each subsequent duplicate name will be appended with <em class="calibre16">n,</em> where <em class="calibre16">n</em> starts from <kbd class="calibre12">1</kbd>.</p>
<p class="calibre2">If you are not happy with the columns names, they can be changed using the <kbd class="calibre12">rename</kbd> method, passing in the <kbd class="calibre12">TimeArray</kbd> object and an array of column names as symbols:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; rename(MarketData.ohlc, [:Opening, :Maximum, :Minimum, :Closing])</strong> </pre>
<p class="calibre2">Finally, the <kbd class="calibre12">meta</kbd> field is supposed to be used for attaching meta-information to the object. By default, it is empty and can be set by the programmer, as needed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Indexing the TimeArray objects</h1>
                </header>
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">TimeSeries</kbd> library exposes a powerful API for accessing information structured as <kbd class="calibre12">TimeArray</kbd> data. We have already seen that we can access individual columns by indexing by column name:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; MarketData.ohlc[:High] 
500×1 TimeArray{Float64,1,Date,Array{Float64,1}} 2000-01-03 to 2001-12-31</strong> </pre>
<p class="calibre2">It results in this:</p>
<div class="CDPAlignCenter1"><img src="assets/586df468-4d42-44f5-9328-7d3101990d98.png" class="calibre152"/></div>
<p class="calibre2">We can even use a combination of columns:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; MarketData.ohlc[:High, :Low]</strong> </pre>
<p class="calibre2"><span class="calibre5">The output is as follows:</span></p>
<div class="CDPAlignCenter1"><img src="assets/52baa074-d17e-424a-b380-3906fbfbbcb6.png" class="calibre153"/></div>
<p class="calibre2">We can also index into the array using row IDs and dates/times (corresponding to the <kbd class="calibre12">timestamp</kbd> values). Let's try to pick up the row with the highest <kbd class="calibre12">Close</kbd> value. First, let's find it:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; maximum(values(MarketData.ohlc[:Close])) 
144.19</strong> </pre>
<p class="calibre2">The highest closing value was <kbd class="calibre12">144.19</kbd>. Please note that indexing by column name returns another instance of <kbd class="calibre12">TimeArray</kbd>, so to get its underlying numerical values, we need to use the <kbd class="calibre12">values</kbd> function.</p>
<p class="calibre2">Now we can find its corresponding index. We can quickly get an array of the indices of all the values that are equal to <kbd class="calibre12">144.19</kbd> by using <kbd class="calibre12">findall</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; findall(values(MarketData.ohlc[:Close]) .== 144.19) 
1-element Array{Int64,1}: 
 56</strong> </pre>
<p class="calibre2">That would be row <kbd class="calibre12">56</kbd>. We can use this information to index into the time series:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; MarketData.ohlc[56] 
1×4 TimeArray{Float64,2,Date,Array{Float64,2}} 2000-03-22 to 2000-03-22</strong> </pre>
<p class="calibre2"><span class="calibre5">The output is as follows:</span></p>
<p class="CDPAlignCenter"><img src="assets/42806baa-f24a-4cfb-a27e-efbab4071af9.png" class="calibre154"/></p>
<p class="calibre2">This is March 22, 2000. If we'd like to see the rows before and after, we can do it easily:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; MarketData.ohlc[50:60] 
11×4 TimeArray{Float64,2,Date,Array{Float64,2}} 2000-03-14 to 2000-03-28</strong> </pre>
<p class="calibre2"><span class="calibre5">This is the resulting <kbd class="calibre12">TimeArray</kbd>:</span></p>
<p class="CDPAlignCenter"><img src="assets/0f0b8825-445a-4517-845e-e95f831e19f8.png" class="calibre155"/></p>
<p class="calibre2">If we want to check the values for the same day of the week, before and after our date, indexing by range supports a step parameter. We can use it as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; MarketData.ohlc[7:7:70]</strong> </pre>
<p class="calibre2">We filter every seventh day, starting with the seventh row, all the way to the seventieth row; that is, every <kbd class="calibre12">Wednesday</kbd>, as indicated by <kbd class="calibre12">Dates.dayname</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dayname(timestamp(MarketData.ohlc)[56]) 
"Wednesday"</strong> </pre>
<p class="calibre2">If we want to retrieve all the Wednesdays, we can, of course, use the <kbd class="calibre12">end</kbd> keyword, as in <kbd class="calibre12">MarketData.ohlc[7:7:end]</kbd>.</p>
<p class="calibre2">Let's say we're happy with this, but we'd like to get more context on our date. So, we want all the Wednesdays plus the day before and the day after our date. We can do this too by indexing with an array of indices:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; MarketData.ohlc[[7:7:49; 54;55;56;57; 63:7:70]] 
13×4 TimeArray{Float64,2,Date,Array{Float64,2}} 2000-01-11 to 2000-04-11</strong> </pre>
<p class="calibre2"><span class="calibre5">The output is as follows:</span></p>
<p class="CDPAlignCenter"><img src="assets/145d0095-c6e0-45fb-a710-166e61811c4a.png" class="calibre156"/></p>
<p class="calibre2">Here, we pull each seventh row between 7 and 49, then the rows 54, 55, 56, and 57, and then each seventh row between 63 and 70.</p>
<div class="packttip"><kbd class="calibre24">TimeArray</kbd> indexing is very flexible, but keep in mind that the rows must always be ordered by date. This is the reason why we can't say, for instance, [<kbd class="calibre24">7:7:70</kbd>; <kbd class="calibre24">54;55;56;57</kbd>]—the elements would be out of order. And speaking of errors, including duplicate rows will also result in an error.</div>
<p class="calibre2">We can also index using date/time objects:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; MarketData.ohlc[Date(2000, 03, 22)] 
1×4 TimeArray{Float64,2,Date,Array{Float64,2}} 2000-03-22 to 2000-03-22</strong> </pre>
<p class="calibre2"><span class="calibre5">This produces the following:</span></p>
<p class="CDPAlignCenter"><img src="assets/186fe5fa-0504-4ba5-8ecc-03f9b669a4cb.png" class="calibre157"/></p>
<p class="calibre2">And yes, we can use date/time ranges too:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; MarketData.ohlc[Date(2000, 03, 20):Day(1):Date(2000, 04,30)] 
29×4 TimeArray{Float64,2,Date,Array{Float64,2}} 2000-03-20 to 2000-04-28</strong> </pre>
<p class="calibre2"><span class="calibre5">The output is as follows:</span></p>
<p class="CDPAlignCenter"><img src="assets/ec7bca41-878f-4422-8d74-01e6cf5fe4e5.png" class="calibre158"/></p>
<p class="calibre2">Using other date range steps will work equally well:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; MarketData.ohlc[Date(2000, 03, 20):Dates.Week(1):Date(2000, 04,30)] 
6×4 TimeArray{Float64,2,Date,Array{Float64,2}} 2000-03-20 to 2000-04-24 
# output truncated</strong> </pre>
<p class="calibre2">Combining multiple indices works too:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; MarketData.ohlc[[Date(2000, 03, 20):Day(1):Date(2000, 04,30); Date(2000, 05, 01)]] 
30×4 TimeArray{Float64,2,Date,Array{Float64,2}} 2000-03-20 to 2000-05-01</strong> </pre>
<p class="calibre2">Finally, we can come up with any combination of columns and rows we can imagine:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; MarketData.ohlc[:High, :Low][Date(2000, 03, 20):Day(1):Date(2000, 03,25)] 
5×2 TimeArray{Float64,2,Date,Array{Float64,2}} 2000-03-20 to 2000-03-24</strong> </pre>
<p class="calibre2"><span class="calibre5">This is the result:</span></p>
<p class="CDPAlignCenter"><img src="assets/d5779849-23df-4573-9bc9-9baaee302341.png" class="calibre159"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Querying TimeArray objects</h1>
                </header>
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">TimeSeries</kbd> module exposes a powerful, query-like API for filtering time series data. Let's take a look at each of them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The when() method</h1>
                </header>
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">when</kbd> method allows for aggregating elements from a <kbd class="calibre12">TimeArray</kbd> into specific time periods. For instance, we can use this function to pick the Wednesdays in our dataset in a more concise fashion:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; when(MarketData.ohlc[1:70], Dates.dayname, "Wednesday") 
14x4 TimeArray{Float64,2,Date,Array{Float64,2}} 2000-01-05 to 2000-04-05 
# output truncated</strong> </pre>
<p class="calibre2">We are not limited to just <kbd class="calibre12">Dates.dayname</kbd>; we can use many of the <kbd class="calibre12">Dates</kbd> functions we covered in the previous section—<kbd class="calibre12">day</kbd>, <kbd class="calibre12">dayname</kbd>, <kbd class="calibre12">week</kbd>, <kbd class="calibre12">month</kbd>, <kbd class="calibre12">monthname</kbd>, <kbd class="calibre12">year</kbd>, <kbd class="calibre12">dayofweek</kbd>, <kbd class="calibre12">dayofweekofmonth</kbd>, <kbd class="calibre12">dayofyear</kbd>, <kbd class="calibre12">quarterofyear</kbd>, and <kbd class="calibre12">dayofquarter</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; when(MarketData.ohlc, Dates.monthname, "August") 
46x4 TimeArray{Float64,2,Date,Array{Float64,2}} 2000-08-01 to 2001-08-31 
# output truncated</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The from() method</h1>
                </header>
            
            <article>
                
<p class="calibre2">This function truncates a <kbd class="calibre12">TimeArray</kbd> starting with the date passed to the method. The row corresponding to the passed date is included in the result:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; from(MarketData.ohlc, Date(2000, 3, 22)) 
445x4 TimeArray{Float64,2,Date,Array{Float64,2}} 2000-03-22 to 2001-12-31</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/55b57b0f-a293-455c-a2b0-0dab1525eef2.png" class="calibre160"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The to() method</h1>
                </header>
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">to()</kbd> method returns the rows up to and including the date passed as an argument:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; to(MarketData.ohlc, Date(2000, 3, 22)) 
56x4 TimeArray{Float64,2,Date,Array{Float64,2}} 2000-01-03 to 2000-03-22 
# output truncated</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The findall() and findwhen() methods</h1>
                </header>
            
            <article>
                
<p class="calibre2">This family of functions tests a condition and returns the results for which the condition is true. The only difference is that <kbd class="calibre12">findall()</kbd> returns an array containing the numbers of the rows, while <kbd class="calibre12">findwhen()</kbd> returns a vector of date/time objects. For example, if we want to find all the rows where the closing value was at least 10% higher than the opening value, we can run the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; findall(MarketData.ohlc[:Close] .&gt;= MarketData.ohlc[:Open] .+ MarketData.ohlc[:Open] .* 0.1) 
7-element Array{Int64,1}: 
  55 
  74 
 119 
 254 
 260 
 271 
 302</strong> </pre>
<p class="calibre2"><kbd class="calibre12">findwhen</kbd> will produce a similar output, but for the dates:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; findwhen(MarketData.ohlc[:Close] .&gt;= MarketData.ohlc[:Open] .+ MarketData.ohlc[:Open] .* 0.1) 
7-element Array{Date,1}: 
 2000-03-21 
 2000-04-17 
 2000-06-21 
 2001-01-03</strong></pre>
<pre class="calibre17"><strong class="calibre1"> 2001-01-11 
 2001-01-29 
 2001-03-14</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Manipulating time series objects</h1>
                </header>
            
            <article>
                
<p class="calibre2"><kbd class="calibre12">TimeSeries</kbd> exposes a minimalist, yet productive set of methods for modifying <kbd class="calibre12">TimeArray</kbd> objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">merge()</h1>
                </header>
            
            <article>
                
<p class="calibre2">For starters, we can combine the data from two <kbd class="calibre12">TimeArrays</kbd>. The <kbd class="calibre12">merge</kbd> method uses the timestamps as the join columns—and by default, it performs an inner join. But it's also possible to perform left, right, and outer joins. Let's generate some random data to experiment with. We'll start by creating a time series with random values, spread over a week, starting today:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; d1 = today():Day(1):today() + Week(1) |&gt; collect 
8-element Array{Date,1}: 
 2018-11-08 
 2018-11-09 
 2018-11-10 
 2018-11-11 
 2018-11-12 
 2018-11-13 
 2018-11-14 
 2018-11-15 
 
julia&gt; t1 = TimeArray(d1, rand(length(d1)), [:V1]) 
8×1 TimeArray{Float64,1,Date,Array{Float64,1}} 2018-11-08 to 2018-11-15</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/48da86e4-5b2e-47c9-9a5a-7f2805468a5b.png" class="calibre161"/></p>
<p class="calibre2">Next, we'll create another time series object spread over ten days:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; d2 = today():Day(1):today() + Day(10) |&gt; collect 
11-element Array{Date,1}: 
 2018-11-08 
 2018-11-09 
 2018-11-10 
 2018-11-11 
 2018-11-12 
 2018-11-13 
 2018-11-14 
 2018-11-15 
 2018-11-16 
 2018-11-17 
 2018-11-18 
 
julia&gt; t2 = TimeArray(d2, rand(length(d2)), [:V2]) 
11×1 TimeArray{Float64,1,Date,Array{Float64,1}} 2018-11-08 to 2018-11-18 </strong> </pre>
<p class="calibre2">This results in the following:</p>
<p class="CDPAlignCenter"><img src="assets/0f8eeb8c-ad11-46b2-9e8d-86caa687e8d1.png" class="calibre162"/></p>
<p class="calibre2">So now we have two <kbd class="calibre12">TimeArray</kbd> instances, <kbd class="calibre12">t1</kbd> and <kbd class="calibre12">t2</kbd>. The <kbd class="calibre12">t2</kbd> object has values for all the days in <kbd class="calibre12">t1</kbd> plus three more days. A regular (inner join) <kbd class="calibre12">merge</kbd> will only use the rows with timestamps that are present in both <kbd class="calibre12">t1</kbd> and <kbd class="calibre12">t2</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; merge(t1, t2) 
8×2 TimeArray{Float64,2,Date,Array{Float64,2}} 2018-11-08 to 2018-11-15 </strong></pre>
<p class="calibre2">This is the output:</p>
<p class="CDPAlignCenter"><img src="assets/39a85886-a371-49c0-8d6a-f6c5cdbb1269.png" class="calibre163"/></p>
<p class="calibre2">Right, left, and outer joins will introduce <kbd class="calibre12">NaN</kbd> values for the rows that don't correspond:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; merge(t1, t2, :right) 
11×2 TimeArray{Float64,2,Date,Array{Float64,2}} 2018-11-08 to 2018-11-18</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/540ce8d0-6f8f-4667-af5a-78e86e19902c.png" class="calibre164"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The vcat() method</h1>
                </header>
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">vcat()</kbd> method can be considered the counterpart of <kbd class="calibre12">merge</kbd>. If <kbd class="calibre12">merge</kbd> joins the columns of two time series, <kbd class="calibre12">vcat</kbd> combines their rows. Its most obvious use case is for putting together data from a dataset that is split into multiple files. Let's see it in action:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; d3 = today() + Week(2):Day(1):today() + Week(3) |&gt; collect  
8-element Array{Date,1}: 
 2018-11-22 
 2018-11-23 
 2018-11-24 
 2018-11-25 
 2018-11-26 
 2018-11-27</strong></pre>
<pre class="calibre17"><strong class="calibre1"> 2018-11-28 
 2018-11-29 
  
julia&gt; t3 = TimeArray(d3, rand(length(d3)), [:V1]) 
8×1 TimeArray{Float64,1,Date,Array{Float64,1}} 2018-11-22 to 2018-11-29</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/c45534bb-8872-49f5-a4d3-09e88dbbb1c8.png" class="calibre165"/></p>
<p class="calibre2">We have created a new <kbd class="calibre12">TimeArray</kbd> which covers the time period between two weeks and three weeks from today:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; vcat(t1, t3) 
16×1 TimeArray{Float64,1,Date,Array{Float64,1}} 2018-11-08 to 2018-11-29</strong> </pre>
<p class="calibre2"><span class="calibre5">This is the resulting <kbd class="calibre12">TimeArray</kbd>:</span></p>
<p class="CDPAlignCenter"><img src="assets/007b4a8f-21bc-41fe-8aea-05e93947e9d2.png" class="calibre166"/></p>
<p class="calibre2">The resulting time series combines data from both <kbd class="calibre12">t1</kbd> and <kbd class="calibre12">t3</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The collapse() method</h1>
                </header>
            
            <article>
                
<p class="calibre2">This method allows for compressing data into a larger time frame, for instance converting daily data into weekly data:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; january = TimeArray(Date(2018, 1, 1):Day(1):Date(2018, 1, 31) |&gt; collect, rand(31), [:values]) 
31×1 TimeArray{Float64,1,Date,Array{Float64,1}} 2018-01-01 to 2018-01-31</strong> </pre>
<p class="calibre2"><span class="calibre5">It produces the following output:</span></p>
<p class="CDPAlignCenter"><img src="assets/610ec7a7-e78c-4718-8593-139b1f9adfdc.png" class="calibre167"/></p>
<p class="calibre2">If we want to <kbd class="calibre12">collapse</kbd> the <kbd class="calibre12">january</kbd> time series, we need to decide what to do about the data that's being collapsed. This is achieved by passing function arguments. The general form of the method is the following:</p>
<pre class="calibre17">collapse(&lt;time series&gt;, &lt;time function&gt;, &lt;time filtering function&gt;, &lt;value collapsing function&gt;) </pre>
<p class="calibre2">For instance, we can <kbd class="calibre12">collapse</kbd> the data for January into a weekly period (the <kbd class="calibre12">&lt;time function&gt;</kbd>) by keeping the last day of the period (the <kbd class="calibre12">&lt;time filtering function&gt;</kbd>) and by computing the mean of the values (the <kbd class="calibre12">&lt;value collapsing function&gt;</kbd>):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Statistics 
julia&gt; collapse(january, week, last, mean) 
5×1 TimeArray{Float64,1,Date,Array{Float64,1}} 2018-01-07 to 2018-01-31</strong> </pre>
<p class="calibre2"><span class="calibre5">The output is as follows:</span></p>
<p class="CDPAlignCenter"><img src="assets/fd0c2612-3271-47ef-845d-a2e3c898aa3d.png" class="calibre168"/></p>
<p class="calibre2">The <kbd class="calibre12">&lt;value collapsing function&gt;</kbd> is optional and if not provided, the values that correspond to the timestamp will be used:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; collapse(january, week, first) 
5×1 TimeArray{Float64,1,Date,Array{Float64,1}} 2018-01-01 to 2018-01-29</strong> </pre>
<p class="calibre2"><span class="calibre5">This is what we get:</span></p>
<p class="CDPAlignCenter"><img src="assets/bc35d17e-515d-43a4-99ba-3625b30aae4e.png" class="calibre169"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The map() method</h1>
                </header>
            
            <article>
                
<p class="calibre2">Finally, the <kbd class="calibre12">map()</kbd> function allows us to iterate over each row in the time series and apply a function to both the timestamps and the values. We could easily postpone the first week in the <kbd class="calibre12">january</kbd> time series by one year, as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; map(january[1:7]) do ts, values 
           ts += Year(1) 
           (ts, values) 
       end 
7×1 TimeArray{Float64,1,Date,Array{Float64,1}} 2019-01-01 to 2019-01-07</strong> </pre>
<p class="calibre2"><span class="calibre5">The output is as follows:</span></p>
<p class="CDPAlignCenter"><img src="assets/6703bb47-ea7a-4990-8be1-bda091b7c9b8.png" class="calibre170"/></p>
<p class="calibre2">There is more to say about <kbd class="calibre12">TimeSeries</kbd>. But for now, we'll stop here. We'll get back to <kbd class="calibre12">TimeArray</kbd> in the next chapter, where we will use it to perform time series analysis and forecasting on the European Union's unemployment numbers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="calibre2">In this chapter, we have learned about working with dates and times in Julia. The language provides a powerful, yet accessible API that follows Julia's overall philosophy—you can start simple and augment your code as you become more knowledgeable. Thus, by default, the date/time objects use local time, ignoring complex details like time zones. However, time zone support is only one package away. We have seen how to extend Julia's <kbd class="calibre12">Dates</kbd> API by using the functionality provided by <kbd class="calibre12">TimeZones</kbd>.</p>
<p class="calibre2">Using our understanding of temporal data, we were able to take yet another step towards becoming proficient Julia programmers and learned about time series and the powerful <kbd class="calibre12">TimeArray</kbd>. We've seen how to plot time series with <kbd class="calibre12">Plots</kbd>, an extremely versatile plotting library for Julia—in fact, it's middleware providing a common API for a series of visualization packages, allowing us to swap backends as needed.</p>
<p class="calibre2">In the next chapter, we will continue our discussion of time series by performing analytics and forecasting on unemployment levels in the European Union. In the process, we'll learn about the most important patterns of time series analysis—trends, seasonality, and irregularity, and we will expand our knowledge of <kbd class="calibre12">TimeSeries</kbd> by performing various time series transformations.</p>


            </article>

            
        </section>
    </body></html>