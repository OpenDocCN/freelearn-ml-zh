- en: Hot Dog or Not Hot Dog - Using External Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热狗还是不是热狗 - 使用外部服务
- en: 'In the previous chapters, I stressed the importance of understanding the mathematics
    behind algorithms. Here''s a recap. We started with linear regression, followed
    by a Naïve Bayes classifier. Then, the topics dovetailed into one of the more
    complex topics in data science: time series. We then detoured and discussed clustering
    by means of K-means. This was followed by two chapters on neural networks. In
    all these chapters, I explained the mathematics behind these algorithms, and showed
    that, with much surprise, the programs yielded are short and simple.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我强调了理解算法背后的数学的重要性。这里是一个回顾。我们从线性回归开始，然后是朴素贝叶斯分类器。然后，话题转向数据科学中更复杂的话题之一：时间序列。然后，我们偏离了主题，讨论了K-means聚类。这之后是关于神经网络的两个章节。在这些章节中，我解释了这些算法背后的数学，并展示了令人惊讶的是，生成的程序既短又简单。
- en: The purpose of this book is to walk a delicate line between the math and the
    implementations. I hope I have provided enough information so that you have an
    understanding of the mathematics and how they may be useful. The projects are
    real projects, but often they are in various forms, simplified and rather academic.
    And so, it may be a bit of a surprise that this chapter will not contain many
    mathematical explanations. Instead, this chapter is aimed at guiding readers through
    more real-world scenarios.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目的是在数学和实现之间走一条微妙的路线。我希望我已经提供了足够的信息，以便你理解数学及其可能的有用之处。项目是真实的项目，但通常它们以各种形式存在，简化且相当学术。因此，本章不会包含很多数学解释可能会让你感到有些意外。相反，本章旨在引导读者通过更多现实世界的场景。
- en: In the previous chapter, we discussed facial detection. Given an image, we want
    to find the faces. But who are they? In order to know who the faces belong to,
    we'd need to perform facial recognition.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了人脸检测。给定一张图片，我们想要找到人脸。但他们是谁呢？为了知道这些人脸属于谁，我们需要进行人脸识别。
- en: MachineBox
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MachineBox
- en: As mentioned, we will not focus on the math going on behind the scenes of face
    detection. Instead, we will use an external service to perform the recognition
    for us. The external service is MachineBox. What it does is quite clever. Instead
    of having to write your own deep learning algorithms, MachineBox packages up the
    commonly-used deep learning functionalities into containers, and you simply just
    use them straight out of the box. What do I mean by commonly-used deep learning
    functionalities? Nowadays people are relying more and more on deep learning for
    tasks such as facial recognition.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们不会关注人脸检测背后发生的数学运算。相反，我们将使用外部服务来为我们执行识别任务。这个外部服务是MachineBox。它所做的事情相当聪明。你不需要编写自己的深度学习算法，MachineBox将常用的深度学习功能打包成容器，你只需直接使用它们即可。我所说的常用深度学习功能是指什么？如今，人们越来越依赖深度学习来完成诸如人脸识别等任务。
- en: Just like Viola-Jones in the early 2000s, there are only a few commonly used
    models—we used the Haar-like cascades generated by Rainer Lienhart in 2002\. The
    same is becoming true of deep learning models, and I shall talk more about the
    implications of that in the next chapter. By models, I mean the actual weights
    of the deep learning networks (for a more in-depth coverage, see [Chapter 7](4c71e400-fde5-467f-a1ee-52300e326504.xhtml),
    *Convolutional Neural Networks – MNIST Handwriting Recognition*, on deep neural
    networks). These commonly-used models are packaged up by MachineBox and you're
    able to just use it out of the box.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 就像2000年代初的Viola-Jones一样，只有少数常用的模型——我们使用了Rainer Lienhart在2002年生成的Haar-like级联模型。同样的情况也正在深度学习模型中发生，我将在下一章中更多地讨论这一点。所谓模型，是指深度学习网络的实际权重（对于更深入的介绍，请参阅第7章，*卷积神经网络
    – MNIST手写识别*，关于深度神经网络）。这些常用模型由MachineBox打包，你可以直接使用它们。
- en: One thing that must be kept in mind is that MachineBox is a paid service. They
    do offer a free tier, which is sufficient for the needs of this chapter. I am
    in no way affiliated with MachineBox. I just think they're a cool company and
    deserve some recognition for the work they do. Plus, they do not do sketchy things
    such as secretly charging your credit card, so that's a plus from me.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 必须记住的一点是，MachineBox是一项付费服务。他们确实提供免费层，这对于本章的需求是足够的。我与MachineBox没有任何关联。我只是认为他们是一家很酷的公司，他们所做的工作值得认可。此外，他们不做一些可疑的事情，比如秘密扣费你的信用卡，所以这也是我加分的地方。
- en: What is MachineBox?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是MachineBox？
- en: MachineBox is a service, first and foremost. The machine learning algorithms
    are packaged nicely as a cloud service. Further, because MachineBox cares about
    the developer experience, they have provided SDKs and local instances for you
    to develop against. This comes in the form of containers. Set up Docker, run the
    commands found on the MachineBox website, and you're done!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: MachineBox首先是一个服务。机器学习算法被包装成云服务。此外，由于MachineBox关注开发者体验，他们为你提供了SDK和本地实例，以便你进行开发。这以容器的形式出现。设置Docker，运行MachineBox网站上的命令，你就完成了！
- en: In this project, we wish to use a facial-recognition system to recognize faces.
    MachineBox provides such a service, called facebox.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们希望使用面部识别系统来识别面部。MachineBox提供了一个名为facebox的服务。
- en: Signing in and up
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册和登录
- en: 'First, we need to sign into MachineBox. Go to [https://machinebox.io](https://machinebox.io)
    and click on Sign Up. Conveniently, the sign in page is the same. MachineBox will
    then email you a link. Clicking the link should send you to this page:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要登录MachineBox。访问[https://machinebox.io](https://machinebox.io)并点击注册。方便的是，登录页面也是一样的。MachineBox会随后给你发送一个链接。点击链接应该会带你到这个页面：
- en: '![](img/38627dd8-8f46-4aa0-96b5-b458d7c531e5.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38627dd8-8f46-4aa0-96b5-b458d7c531e5.png)'
- en: 'Click on Reveal your key. Copy the key. If you''re using a UNIX-based operating
    system, such as Linux or MacOS, in your terminal, run the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**显示你的密钥**。复制密钥。如果你使用的是基于UNIX的操作系统，例如Linux或MacOS，在你的终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Alternatively, if you want to persist this environment variable, simply edit
    your terminal configuration file (I use bash on Linux and MacOS, so the file I'd
    edit is `.bash_profile` or `.bashrc` depending on which OS I'm on).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想持久化这个环境变量，只需编辑你的终端配置文件（我在Linux和MacOS上使用bash，所以我编辑的文件是`.bash_profile`或`.bashrc`，具体取决于我使用的操作系统）。
- en: 'In Windows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中：
- en: Go to **System** | **Control Panel**
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**系统** | **控制面板**
- en: Click on **Advanced System Settings**
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**高级系统设置**
- en: Click on **Environment Variables**
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**环境变量**
- en: In the section **System Variables**, click **New**
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**系统变量**部分，点击**新建**
- en: Add `MB_KEY` as the key and the variable is the key.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MB_KEY`作为密钥，变量就是密钥。
- en: 'MachineBox relies on another piece of technology built on Go: Docker. Most
    modern software developers already have Docker installed on their machines. If
    you haven''t already done so, you can install Docker by going to [https://docs.docker.com/install/](https://docs.docker.com/install/)
    and install the Community Edition of Docker.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: MachineBox依赖于另一项基于Go语言构建的技术：Docker。大多数现代软件开发者已经在他们的机器上安装了Docker。如果你还没有安装，可以通过访问[https://docs.docker.com/install/](https://docs.docker.com/install/)并安装Docker社区版来安装Docker。
- en: Docker installation and setting up
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker安装和设置
- en: 'Once that''s all done, we''re ready to get our MachineBox running with the
    following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都准备好了，我们可以使用以下命令来启动MachineBox：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](img/53d50947-ea7b-46d3-a3c6-fc6dfddd3842.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53d50947-ea7b-46d3-a3c6-fc6dfddd3842.png)'
- en: Using MachineBox in Go
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中使用MachineBox
- en: To interact with MachineBox, simply go `http://localhost:8080`. There, you'll
    see an array of options on the box. But we want to interact with the service programmatically.
    To do so, MachineBox has provided an SDK. To install it, run `go get github.com/machinebox/sdk-go/facebox`.
    This installs the SDK for us to interact with facebox.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要与MachineBox交互，只需访问`http://localhost:8080`。在那里，你会看到箱子上的一组选项。但我们的目标是程序化地与服务交互。为此，MachineBox提供了一个SDK。要安装它，运行`go
    get github.com/machinebox/sdk-go/facebox`。这将为我们安装SDK以与facebox交互。
- en: The project
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目
- en: This is the last project of this book. So, for a bit of fun, let's build on
    the previous chapter's project, but give it a twist. There's an Asian rapper called
    **MC Hot Dog**. So let's build a face-recognition system to determine whether
    a face is HotDog or Not HotDog.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一个项目。所以，为了有点乐趣，让我们基于上一章的项目进行构建，但给它一个转折。有一个亚洲说唱歌手叫**MC Hot Dog**。所以让我们构建一个面部识别系统来判定一个脸是不是HotDog。
- en: What we want to do is to read an image off a webcam, and use MachineBox to determine
    whether MC Hot Dog is in the picture. We'll once again be using GoCV to read images
    off the webcam, but, this time, the image will be sent to MachineBox for classification.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的是从网络摄像头读取一张图片，并使用MachineBox来确定图片中是否有MC Hot Dog。我们再次将使用GoCV从网络摄像头读取图片，但这次，图片将被发送到MachineBox进行分类。
- en: Training
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练
- en: MachineBox is a machine learning system as a service. It has, presumably, in
    some backend somewhere, a general model—say, a convolutional neural network that
    has been trained with many faces, such that it knows what a face is. It does not
    provide the specific model that you may require for the task at hand. So instead,
    we would need to fine-tune the model provided by MachineBox by giving it training
    data. Per MachineBox's terminology, this is called **teaching**. As part of a
    curiosity collection, I have collected a small but usable number of images of
    MC Hot Dog's face that are suitable for the task of teaching the MachineBox what
    MC Hot Dog looks like.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: MachineBox是一个机器学习即服务系统。它可能在某个后端有一个通用模型——比如说，一个经过许多面孔训练的卷积神经网络，这样它就知道什么是面孔。它不提供你可能需要的特定模型。因此，我们需要通过提供训练数据来微调MachineBox提供的模型。按照MachineBox的术语，这被称为**教学**。作为好奇心收集的一部分，我已经收集了一些适合教学MachineBox识别MC
    Hot Dog外观的小但可用的图像。
- en: For this project, the images are in the `hotdog.zip` file. Unzip the file into
    a folder called `HotDog`. This folder should be at the same level as `main.go` for
    this project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，图像存储在`hotdog.zip`文件中。将文件解压到名为`HotDog`的文件夹中。这个文件夹应该与这个项目的`main.go`文件处于同一级别。
- en: 'Training the MachineBox model is simple with the SDK provided. The following
    code illustrates the program:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提供的SDK，训练MachineBox模型很简单。以下代码展示了程序：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And there you have it—a complete tutorial on how to teach MachineBox how to
    recognize MC Hot Dog. MachineBox makes it easy—so easy that you don't need to
    know the mathematics behind the deep learning systems.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由此，你就有了一个完整的教程，介绍了如何教会MachineBox如何识别MC Hot Dog。MachineBox使这个过程变得简单——简单到你不需要了解深度学习系统背后的数学知识。
- en: Reading from the Webcam
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Web摄像头读取
- en: By this point, I hope you have already read the previous chapter and have GoCV
    installed. If you haven't, then read the *GoCV* section in the previous chapter
    to get started.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我希望你已经阅读了上一章，并且安装了GoCV。如果你还没有，那么请阅读上一章中的*GoCV*部分以开始。
- en: 'To read from the webcam, we simply add the following lines to the main file.
    You may recognize them as snippets from the previous chapter:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Web摄像头读取，我们只需将以下几行添加到主文件中。你可能认识它们作为上一章的片段：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The confusing bit of course, is how to pass  `img`, which is of the `gocv.Mat` type,
    to MachineBox. There exists a `Check` method on the MachineBox client that takes
    `io.Reader`. `img` has a method, `ToBytes`, that returns a slice of bytes; coupled
    with `bytes.NewReader`, one should be able to easily pass `io.Reader` into `Check`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，令人困惑的部分是如何将`img`传递给MachineBox，其中`img`是`gocv.Mat`类型。MachineBox客户端存在一个`Check`方法，它接受`io.Reader`。`img`有一个`ToBytes`方法，它返回一个字节数组；结合`bytes.NewReader`，应该能够轻松地将`io.Reader`传递给`Check`。
- en: But if you try that, it won't work.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你尝试这样做，它不会工作。
- en: 'Here''s why: MachineBox expects an input that is *formatted* as a JPEG or PNG.
    If it is not, you will get a 400 Bad Request error. Poorly-formatted images would
    also cause these sorts of problems, which is why the error returned by `box.Teach()`
    is purposefully unhandled in the preceding line. In real-life settings, one might
    want to actually check whether it''s a 400 Bad Request error that was returned.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 原因如下：MachineBox期望输入的格式为JPEG或PNG。如果不是，你将收到一个400 Bad Request错误。格式不佳的图片也会导致这类问题，这就是为什么在上一行中`box.Teach()`返回的错误被故意未处理的。在实际应用中，人们可能真的想检查是否返回了一个400
    Bad Request错误。
- en: 'The raw bytes of an image in `img` are not encoded as a known image format.
    Instead, we have to encode the image in `img` as a JPEG or a PNG and then pass
    it into MachineBox, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`img`中的图像原始字节数据不是以已知图像格式编码的。相反，我们必须将`img`中的图像编码为JPEG或PNG，然后按照以下方式传递给MachineBox：'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we make use of the fact that `*bytes.Buffer` acts as both `io.Reader` and
    `io.Writer`. This way, we don't have to write directly to the file—rather, everything
    stays in memory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用了`*bytes.Buffer`既作为`io.Reader`也作为`io.Writer`的事实。这样，我们就不需要直接写入文件——相反，所有内容都保持在内存中。
- en: Prettifying the results
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 美化结果
- en: 'The program prints the results. It looks something as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 程序打印结果。看起来如下：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a rather boring result to be printed on the terminal output. We live
    in the age of GUIs now! So let's draw our results.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在终端输出上打印的一个相当无聊的结果。我们现在生活在图形用户界面（GUIs）的时代！所以让我们绘制我们的结果。
- en: 'As a result, we want the window to show whatever the webcam is showing. Then,
    when a key is pressed, the image is captured, and processed by MachineBox. If
    a face is found, a rectangle should be drawn around it. If the face is recognized
    as MC Hot Dog, then label the box `HotDog`, followed by the confidence. Otherwise,
    the box should be labelled `Not HotDog`. The code for this looks a bit convoluted:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们希望窗口显示摄像头所显示的内容。然后，当按下键时，图像被捕获，并由MachineBox进行处理。如果发现人脸，则应在其周围绘制一个矩形。如果人脸被识别为MC
    Hot Dog，则标签为`HotDog`，并跟随着置信度。否则，该框应标记为`Not HotDog`。这段代码看起来有点复杂：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But if we break it down, we can see that the code in the main function can be
    split into two parts. The first part deals with opening a webcam and creating
    a window to display the image. A more complete account of this is covered in the
    previous chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们将其分解，我们可以看到主函数中的代码可以分为两部分。第一部分处理打开摄像头并创建一个窗口来显示图像。关于这一点的更完整说明可以在前面的章节中找到。
- en: 'In particular, let''s turn our focus to the infinite loop:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，让我们将注意力转向无限循环：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What this says is simply this: first check whether the recognition process
    has been done. If it hasn''t, grab an image from the webcam, and then show the
    image using `window.IMShow(img)`. This constitutes the main loop—the webcam will
    continuously capture an image and then immediately display it in the window.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话的意思很简单：首先检查识别过程是否已完成。如果没有，从摄像头获取图像，然后使用`window.IMShow(img)`显示图像。这构成了主循环——摄像头将连续捕获图像，然后立即在窗口中显示它。
- en: But what happens when a key is pressed? The block of code that follows says
    to wait for a keyboard event for 1 millisecond. If there is an event, any event
    at all, we check whether the image had previously been recognized. If not, call
    `recognize`, passing in the captured image from the matrix, and the MachineBox
    client. Then we set the `recognized` flag as true. Thus, upon the next key press,
    we exit the program.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但当按下键时会发生什么？接下来的代码块指示等待1毫秒的键盘事件。如果有事件，任何事件都可以，我们检查图像是否之前已被识别。如果没有，调用`recognize`，传入从矩阵捕获的图像和MachineBox客户端。然后我们将`recognized`标志设置为true。因此，在下次按键时，我们将退出程序。
- en: '`recognize` is where the meat of the drawing is done. If you have gone through
    the previous chapter, this should be quite familiar to you already. Otherwise,
    here''s how `recognize` looks:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`recognize`是绘制的主要内容所在。如果你已经阅读了前面的章节，这应该对你来说已经很熟悉了。否则，这里是如何看起来`recognize`：'
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we see the familiar code used to first encode the image as a JPEG, and
    then send it to the MachineBox client for classification. Then, for each face
    found, we draw a blue rectangle around it. `facebox.Face` is defined as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到用于首先将图像编码为JPEG，然后将其发送到MachineBox客户端进行分类的熟悉代码。然后，对于每个找到的人脸，我们围绕它绘制一个蓝色矩形。`facebox.Face`定义如下：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`facebox.Face` allows us to identify the faces, if they are matched, and the
    confidence level. So if there is a `face` found, these fields would be accessible
    to the programmer.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`facebox.Face`允许我们识别人脸，如果它们匹配，以及置信度水平。所以如果找到一个`face`，这些字段将可供程序员访问。'
- en: But first, we must solve the issue of rectangles. MachineBox does not use the
    same definition of rectangles as `image.Rectangle`, which is found in the standard
    library.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们必须解决矩形的问题。MachineBox不使用与标准库中`image.Rectangle`相同的矩形定义。
- en: 'Thus, a helper function to convert `facebox.Rect` into `image.Rectangle` is
    required:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要一个辅助函数将`facebox.Rect`转换为`image.Rectangle`：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are only a handful of ways to define a rectangle. Conversion among the
    two different types is trivial.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 定义矩形的只有几种方法。在这两种不同类型之间的转换是微不足道的。
- en: After the rectangle has been drawn, a label is written. If the face is recognized
    as MC Hot Dog, we'll label it as `HotDog`. MachineBox also provides a confidence
    score, which is a number between 0 and 1 on whether a face is `HotDog` or `Not
    HotDog`. So we'll draw that into the label as well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制矩形之后，写入一个标签。如果人脸被识别为MC Hot Dog，我们将将其标记为`HotDog`。MachineBox还提供了一个置信度分数，这是一个介于0和1之间的数字，表示人脸是`HotDog`还是`Not
    HotDog`。因此，我们也将这个分数绘制到标签中。
- en: The results
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结果
- en: 'You''re probably curious about the results. Here are some of them: my face
    is classified as HotDog with 57% confidence. In fact, using my phone and an image
    of several other people, I have found that some people are more HotDog-like than
    others as shown in the following images:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对结果很好奇。以下是一些结果：我的脸被以57%的置信度分类为HotDog。实际上，使用我的手机和几张其他人的照片，我发现有些人比其他人更像HotDog，如下面的图片所示：
- en: '![](img/15313995-0c95-4b98-9e31-d18800120079.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15313995-0c95-4b98-9e31-d18800120079.png)'
- en: '![](img/0347e95f-6019-4ca7-b78a-e463ed959a67.png)![](img/b05ccc4e-1d11-4ff3-aa30-55be25f0506c.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0347e95f-6019-4ca7-b78a-e463ed959a67.png)![图片](img/b05ccc4e-1d11-4ff3-aa30-55be25f0506c.png)'
- en: What did this book not cover?
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这本书没有涵盖什么？
- en: 'There are a number of things that we can explore in Go. Here''s a non-exhaustive
    list of some things you may want to explore:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，我们可以探索许多事情。以下是一些你可能想要探索的非详尽列表：
- en: Random trees and random forests
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机树和随机森林
- en: Support vector machines
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持向量机
- en: Gradient-boosting methods
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 梯度提升方法
- en: Maximum-entropy methods
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大熵方法
- en: Graphical methods
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形方法
- en: Local outlier factors
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部异常因子
- en: Perhaps if there is a second edition to this book, I will cover them. If you
    are familiar with machine learning methods, you may note that these, especially
    the first three, are perhaps some of the highest-performing machine learning methods,
    when compared with the things written in this book. You might wonder why they
    were not included. The schools of thought that these methods belong to might supply
    a clue.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这本书有第二版，我可能会涵盖它们。如果你熟悉机器学习方法，你可能会注意到，这些方法，尤其是前三种，可能是与这本书中写的内容相比性能最高的机器学习方法之一。你可能会想知道为什么它们没有被包括在内。这些方法所属的思想流派可能提供一些线索。
- en: For example, random trees and random forests can be considered pseudo-Symbolist—they're
    a distant cousin of the Symbolist school of thought, originating from decision
    trees. Support vector machines are analogizers. Maximum entropy and graphical
    methods are of the Bayesian school of thought.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，随机树和随机森林可以被认为是伪符号主义——它们是符号主义思想的一个远亲，起源于决策树。支持向量机是类比器。最大熵和图形方法属于贝叶斯学派。
- en: 'This book is biased toward the Connectionist school of thought for a good reason:
    deep learning is popular right now. If the winds of favor had been different,
    this book would have been markedly different. There is also the issue of explainability.
    I can explain support vector machines quite well, but it would consist of pages
    and pages of mathematical analogy. Opting not to explain how SVMs work, on the
    other hand, would lead to a very thin chapter—the standard implementation of SVMs
    is to use libsvm or svmlight. Simply call the functions provided by the library
    and the job''s done! So an explanation of SVMs is warranted.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书偏向于连接主义思想，有很好的理由：深度学习现在很流行。如果风向不同，这本书会有很大的不同。还有可解释性的问题。我可以很好地解释支持向量机，但这将包括页面的数学类比。另一方面，选择不解释SVMs的工作原理，会导致一个非常薄的章节——SVMs的标准实现是使用libsvm或svmlight。只需调用库提供的函数，工作就完成了！因此，对SVMs的解释是必要的。
- en: What does this all mean?
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这一切意味着什么？
- en: 'Does this mean that MachineBox''s algorithm is not good? The short answer is
    no: we cannot say that the MachineBox algorithm is not good. The longer answer
    requires a more nuanced understanding that combines engineering understanding
    and an understanding of machine learning. As far as the algorithm of facebox goes,
    there are no exact details about what facebox is composed of. But we can deduce
    what goes on.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着MachineBox的算法不好？简短的回答是不：我们不能说MachineBox算法不好。更长的回答需要更细腻的理解，这需要结合工程理解和机器学习的理解。至于facebox的算法，关于facebox由什么组成，没有确切细节。但我们可以推断出发生了什么。
- en: 'First, note that the images with matches are all over 50% in their confidence.
    We can then assume that facebox considers a match being found only if the confidence
    level greater than 50%. I verified this by running the recognizer on a directory
    of over 1,000 images of faces. Only those that are matched have a greater-than
    50% confidence. The program is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，具有匹配的图像的置信度都在50%以上。然后我们可以假设，如果置信度水平大于50%，facebox才会认为找到了匹配。我通过在一个包含1000多张人脸图片的目录上运行识别器来验证了这一点。只有匹配的图片才有超过50%的置信度。程序如下：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this in mind, it also means that we cannot directly use `facebox`'s `.Matched` field
    as the truth value, except for very rudimentary use cases. Instead, we'd have
    to consider the confidence of the results returned.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这也意味着我们无法直接使用`facebox`的`.Matched`字段作为真实值，除非是非常基础的使用场景。相反，我们必须考虑返回结果的可信度。
- en: We could, for example, set a higher threshold for a match to be considered HotDog.
    Setting it to 0.8 shows that only images of MC Hot Dog are recognized as HotDog.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将匹配的阈值设置得更高，以便被认为是HotDog。将其设置为0.8表明只有MC Hot Dog的图像被识别为HotDog。
- en: The lesson learned here is that APIs created by other people require some understanding.
    The code provided in this chapter is remarkably short. This is a testament to
    MachineBox's developer friendliness. But that does not absolve the developer from
    having at least the most basic of understanding of things.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里学到的教训是，由其他人创建的API需要一些理解。本章提供的代码非常简短。这是MachineBox对开发者友好性的证明。但这并不能免除开发者至少对事物有最基本的了解。
- en: Why MachineBox?
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择MachineBox？
- en: I personally prefer to develop my own machine learning solutions. One may, of
    course, chalk this up to ego. However, in the first chapter, I introduced the
    notion that there are different types of problems. Some of these problems may
    be solved by machine learning algorithms. Some problems may only require general
    machine learning algorithms, while some require specialized algorithms derived
    from the general algorithms. In the majority of this book, I've shown the general
    algorithms, and readers are free to adapt these to their own specific problems.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人更喜欢开发自己的机器学习解决方案。当然，有人可能会把这归因于自负。然而，在第一章中，我介绍了不同类型问题的概念。其中一些问题可能可以通过机器学习算法来解决。有些问题可能只需要通用的机器学习算法，而有些则需要从通用算法派生出的专用算法。在这本书的大部分内容中，我展示了通用算法，读者可以自由地将这些算法应用到他们自己的具体问题上。
- en: I, too, recognize the value of having general machine learning algorithms as
    being part of the solution. Imagine that you are developing a program to reorganize
    your personal photos on your computer. There is no need to spend a protracted
    amount of time getting a convolutional neural network trained upon a corpus of
    faces. The main task is to organize the photos, not facial recognition! Instead,
    one may just use a model that is already trained. These sorts of ready-made solutions
    are suitable for problems in which the ready-made solution is a small part. Increasingly,
    there is a demand for such solutions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我也认识到，将通用机器学习算法作为解决方案的一部分是有价值的。想象一下，你正在开发一个程序来重新组织你电脑上的个人照片。没有必要花费大量时间在一个包含面部语料库的卷积神经网络上进行训练。主要任务是组织照片，而不是人脸识别！相反，可以使用已经训练好的模型。这类现成的解决方案适合那些现成解决方案只是其中一小部分的问题。对这类解决方案的需求日益增长。
- en: 'As such, many machine learning algorithms are provided now as a service. Amazon
    Web Services has its own offering, as do Google Cloud and Microsoft Azure. Why
    did I not choose to introduce those in this chapter? Here''s another thing you
    should know about me: I like to work offline. I find being connected to the internet
    while working only serves as a distraction—Slack messages, emails, and various
    other sites compete for my scarce attention. No, I prefer to work and think while
    offline.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在许多机器学习算法都作为服务提供。亚马逊网络服务有自己的产品，谷歌云和微软Azure也是如此。为什么我没有选择在本章介绍它们？关于我，你应该知道的另一件事是：我喜欢离线工作。我发现工作时连接到互联网只会分散我的注意力——Slack消息、电子邮件和各种其他网站争夺我有限的注意力。不，我更喜欢离线工作和思考。
- en: The cloud companies do offer machine learning as a service, and they all require
    internet access. MachineBox, to its credit, provides a Docker image. A Docker
    pull is all that is required. A once-off internet connection is required to download
    the files. But once that's done, the entire workflow may be developed offline—or
    as is the case for all the code in this chapter, on a plane.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务公司确实提供机器学习作为服务，并且它们都要求有互联网接入。MachineBox值得称赞的是，它提供了一个Docker镜像。只需要执行一次Docker
    pull操作。下载文件需要一次性的互联网连接。但一旦完成，整个工作流程就可以离线开发——或者，正如本章所有代码的情况，在飞机上开发。
- en: 'This is MachineBox''s main benefit: you are not beholden to a corporate entity
    that requires an always-on connection to their cloud services. But of course,
    that''s not all. MachineBox is famous for its developer friendliness. That I am
    able to write the majority of this chapter''s code in-flight is testament to their
    developer friendliness. To be fair, even as a seasoned machine learning library
    author, facial recognition is still pretty awesome.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是MachineBox的主要优势：你不需要依赖一个要求始终连接到其云服务的公司实体。但当然，这还不是全部。MachineBox因其对开发者的友好而闻名。我能够在飞行中编写本章大部分代码的事实就是对他们开发者友好性的证明。公平地说，即使作为一个经验丰富的机器学习库作者，人脸识别仍然相当神奇。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In closing, it's only fair to mention that MachineBox does have some limitations
    for its free tiers; but for personal projects, in my experience, you won't run
    into them. Despite my personal reservations on the various machine learning-as-a-service
    systems out there, I do think they provide value. I have used them from time to
    time, but I generally do not need them. Nevertheless, I highly recommend that
    the reader check them out.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束之前，公正地说，MachineBox 对于其免费层确实存在一些限制；但根据我的经验，在个人项目中，你不太会遇到这些问题。尽管我对现有的各种机器学习即服务系统持有个人保留意见，但我确实认为它们提供了价值。我时不时地使用过它们，但通常我不需要它们。尽管如此，我强烈建议读者去了解一下。
- en: 'This chapter, in combination with the previous chapter, has shown the breadth
    of machine learning in the industry. Not all machine learning algorithms have
    to be handwritten from scratch if your main problem does not call for it. I am
    lucky enough to have a career in doing what I love: building customized machine
    learning algorithms. This may have tainted my views on this issue. You may be
    an engineer on a deadline who has to solve some bigger business problems. For
    that, these two chapters are for you.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本章与上一章结合，展示了机器学习在行业中的广泛性。如果你的主要问题不需要，并非所有机器学习算法都必须从头开始手写。我很幸运，能够从事我热爱的工作：构建定制的机器学习算法。这可能会影响我对这个问题的看法。你可能是一名工程师，需要在截止日期前解决一些更大的商业问题。为此，这两章是为你准备的。
- en: The next chapter will list further avenues for ML in Go.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将列出 Go 中机器学习的更多途径。
