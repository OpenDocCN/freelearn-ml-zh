- en: Hot Dog or Not Hot Dog - Using External Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, I stressed the importance of understanding the mathematics
    behind algorithms. Here''s a recap. We started with linear regression, followed
    by a Naïve Bayes classifier. Then, the topics dovetailed into one of the more
    complex topics in data science: time series. We then detoured and discussed clustering
    by means of K-means. This was followed by two chapters on neural networks. In
    all these chapters, I explained the mathematics behind these algorithms, and showed
    that, with much surprise, the programs yielded are short and simple.'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this book is to walk a delicate line between the math and the
    implementations. I hope I have provided enough information so that you have an
    understanding of the mathematics and how they may be useful. The projects are
    real projects, but often they are in various forms, simplified and rather academic.
    And so, it may be a bit of a surprise that this chapter will not contain many
    mathematical explanations. Instead, this chapter is aimed at guiding readers through
    more real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed facial detection. Given an image, we want
    to find the faces. But who are they? In order to know who the faces belong to,
    we'd need to perform facial recognition.
  prefs: []
  type: TYPE_NORMAL
- en: MachineBox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, we will not focus on the math going on behind the scenes of face
    detection. Instead, we will use an external service to perform the recognition
    for us. The external service is MachineBox. What it does is quite clever. Instead
    of having to write your own deep learning algorithms, MachineBox packages up the
    commonly-used deep learning functionalities into containers, and you simply just
    use them straight out of the box. What do I mean by commonly-used deep learning
    functionalities? Nowadays people are relying more and more on deep learning for
    tasks such as facial recognition.
  prefs: []
  type: TYPE_NORMAL
- en: Just like Viola-Jones in the early 2000s, there are only a few commonly used
    models—we used the Haar-like cascades generated by Rainer Lienhart in 2002\. The
    same is becoming true of deep learning models, and I shall talk more about the
    implications of that in the next chapter. By models, I mean the actual weights
    of the deep learning networks (for a more in-depth coverage, see [Chapter 7](4c71e400-fde5-467f-a1ee-52300e326504.xhtml),
    *Convolutional Neural Networks – MNIST Handwriting Recognition*, on deep neural
    networks). These commonly-used models are packaged up by MachineBox and you're
    able to just use it out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that must be kept in mind is that MachineBox is a paid service. They
    do offer a free tier, which is sufficient for the needs of this chapter. I am
    in no way affiliated with MachineBox. I just think they're a cool company and
    deserve some recognition for the work they do. Plus, they do not do sketchy things
    such as secretly charging your credit card, so that's a plus from me.
  prefs: []
  type: TYPE_NORMAL
- en: What is MachineBox?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MachineBox is a service, first and foremost. The machine learning algorithms
    are packaged nicely as a cloud service. Further, because MachineBox cares about
    the developer experience, they have provided SDKs and local instances for you
    to develop against. This comes in the form of containers. Set up Docker, run the
    commands found on the MachineBox website, and you're done!
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we wish to use a facial-recognition system to recognize faces.
    MachineBox provides such a service, called facebox.
  prefs: []
  type: TYPE_NORMAL
- en: Signing in and up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to sign into MachineBox. Go to [https://machinebox.io](https://machinebox.io)
    and click on Sign Up. Conveniently, the sign in page is the same. MachineBox will
    then email you a link. Clicking the link should send you to this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38627dd8-8f46-4aa0-96b5-b458d7c531e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Reveal your key. Copy the key. If you''re using a UNIX-based operating
    system, such as Linux or MacOS, in your terminal, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, if you want to persist this environment variable, simply edit
    your terminal configuration file (I use bash on Linux and MacOS, so the file I'd
    edit is `.bash_profile` or `.bashrc` depending on which OS I'm on).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **System** | **Control Panel**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Advanced System Settings**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Environment Variables**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the section **System Variables**, click **New**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `MB_KEY` as the key and the variable is the key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'MachineBox relies on another piece of technology built on Go: Docker. Most
    modern software developers already have Docker installed on their machines. If
    you haven''t already done so, you can install Docker by going to [https://docs.docker.com/install/](https://docs.docker.com/install/)
    and install the Community Edition of Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker installation and setting up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once that''s all done, we''re ready to get our MachineBox running with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/53d50947-ea7b-46d3-a3c6-fc6dfddd3842.png)'
  prefs: []
  type: TYPE_IMG
- en: Using MachineBox in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To interact with MachineBox, simply go `http://localhost:8080`. There, you'll
    see an array of options on the box. But we want to interact with the service programmatically.
    To do so, MachineBox has provided an SDK. To install it, run `go get github.com/machinebox/sdk-go/facebox`.
    This installs the SDK for us to interact with facebox.
  prefs: []
  type: TYPE_NORMAL
- en: The project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the last project of this book. So, for a bit of fun, let's build on
    the previous chapter's project, but give it a twist. There's an Asian rapper called
    **MC Hot Dog**. So let's build a face-recognition system to determine whether
    a face is HotDog or Not HotDog.
  prefs: []
  type: TYPE_NORMAL
- en: What we want to do is to read an image off a webcam, and use MachineBox to determine
    whether MC Hot Dog is in the picture. We'll once again be using GoCV to read images
    off the webcam, but, this time, the image will be sent to MachineBox for classification.
  prefs: []
  type: TYPE_NORMAL
- en: Training
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MachineBox is a machine learning system as a service. It has, presumably, in
    some backend somewhere, a general model—say, a convolutional neural network that
    has been trained with many faces, such that it knows what a face is. It does not
    provide the specific model that you may require for the task at hand. So instead,
    we would need to fine-tune the model provided by MachineBox by giving it training
    data. Per MachineBox's terminology, this is called **teaching**. As part of a
    curiosity collection, I have collected a small but usable number of images of
    MC Hot Dog's face that are suitable for the task of teaching the MachineBox what
    MC Hot Dog looks like.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, the images are in the `hotdog.zip` file. Unzip the file into
    a folder called `HotDog`. This folder should be at the same level as `main.go` for
    this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Training the MachineBox model is simple with the SDK provided. The following
    code illustrates the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And there you have it—a complete tutorial on how to teach MachineBox how to
    recognize MC Hot Dog. MachineBox makes it easy—so easy that you don't need to
    know the mathematics behind the deep learning systems.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from the Webcam
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By this point, I hope you have already read the previous chapter and have GoCV
    installed. If you haven't, then read the *GoCV* section in the previous chapter
    to get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read from the webcam, we simply add the following lines to the main file.
    You may recognize them as snippets from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The confusing bit of course, is how to pass  `img`, which is of the `gocv.Mat` type,
    to MachineBox. There exists a `Check` method on the MachineBox client that takes
    `io.Reader`. `img` has a method, `ToBytes`, that returns a slice of bytes; coupled
    with `bytes.NewReader`, one should be able to easily pass `io.Reader` into `Check`.
  prefs: []
  type: TYPE_NORMAL
- en: But if you try that, it won't work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s why: MachineBox expects an input that is *formatted* as a JPEG or PNG.
    If it is not, you will get a 400 Bad Request error. Poorly-formatted images would
    also cause these sorts of problems, which is why the error returned by `box.Teach()`
    is purposefully unhandled in the preceding line. In real-life settings, one might
    want to actually check whether it''s a 400 Bad Request error that was returned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The raw bytes of an image in `img` are not encoded as a known image format.
    Instead, we have to encode the image in `img` as a JPEG or a PNG and then pass
    it into MachineBox, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we make use of the fact that `*bytes.Buffer` acts as both `io.Reader` and
    `io.Writer`. This way, we don't have to write directly to the file—rather, everything
    stays in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Prettifying the results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The program prints the results. It looks something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a rather boring result to be printed on the terminal output. We live
    in the age of GUIs now! So let's draw our results.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, we want the window to show whatever the webcam is showing. Then,
    when a key is pressed, the image is captured, and processed by MachineBox. If
    a face is found, a rectangle should be drawn around it. If the face is recognized
    as MC Hot Dog, then label the box `HotDog`, followed by the confidence. Otherwise,
    the box should be labelled `Not HotDog`. The code for this looks a bit convoluted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: But if we break it down, we can see that the code in the main function can be
    split into two parts. The first part deals with opening a webcam and creating
    a window to display the image. A more complete account of this is covered in the
    previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, let''s turn our focus to the infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'What this says is simply this: first check whether the recognition process
    has been done. If it hasn''t, grab an image from the webcam, and then show the
    image using `window.IMShow(img)`. This constitutes the main loop—the webcam will
    continuously capture an image and then immediately display it in the window.'
  prefs: []
  type: TYPE_NORMAL
- en: But what happens when a key is pressed? The block of code that follows says
    to wait for a keyboard event for 1 millisecond. If there is an event, any event
    at all, we check whether the image had previously been recognized. If not, call
    `recognize`, passing in the captured image from the matrix, and the MachineBox
    client. Then we set the `recognized` flag as true. Thus, upon the next key press,
    we exit the program.
  prefs: []
  type: TYPE_NORMAL
- en: '`recognize` is where the meat of the drawing is done. If you have gone through
    the previous chapter, this should be quite familiar to you already. Otherwise,
    here''s how `recognize` looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see the familiar code used to first encode the image as a JPEG, and
    then send it to the MachineBox client for classification. Then, for each face
    found, we draw a blue rectangle around it. `facebox.Face` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`facebox.Face` allows us to identify the faces, if they are matched, and the
    confidence level. So if there is a `face` found, these fields would be accessible
    to the programmer.'
  prefs: []
  type: TYPE_NORMAL
- en: But first, we must solve the issue of rectangles. MachineBox does not use the
    same definition of rectangles as `image.Rectangle`, which is found in the standard
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, a helper function to convert `facebox.Rect` into `image.Rectangle` is
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are only a handful of ways to define a rectangle. Conversion among the
    two different types is trivial.
  prefs: []
  type: TYPE_NORMAL
- en: After the rectangle has been drawn, a label is written. If the face is recognized
    as MC Hot Dog, we'll label it as `HotDog`. MachineBox also provides a confidence
    score, which is a number between 0 and 1 on whether a face is `HotDog` or `Not
    HotDog`. So we'll draw that into the label as well.
  prefs: []
  type: TYPE_NORMAL
- en: The results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''re probably curious about the results. Here are some of them: my face
    is classified as HotDog with 57% confidence. In fact, using my phone and an image
    of several other people, I have found that some people are more HotDog-like than
    others as shown in the following images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15313995-0c95-4b98-9e31-d18800120079.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/0347e95f-6019-4ca7-b78a-e463ed959a67.png)![](img/b05ccc4e-1d11-4ff3-aa30-55be25f0506c.png)'
  prefs: []
  type: TYPE_IMG
- en: What did this book not cover?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of things that we can explore in Go. Here''s a non-exhaustive
    list of some things you may want to explore:'
  prefs: []
  type: TYPE_NORMAL
- en: Random trees and random forests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support vector machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradient-boosting methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum-entropy methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphical methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local outlier factors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps if there is a second edition to this book, I will cover them. If you
    are familiar with machine learning methods, you may note that these, especially
    the first three, are perhaps some of the highest-performing machine learning methods,
    when compared with the things written in this book. You might wonder why they
    were not included. The schools of thought that these methods belong to might supply
    a clue.
  prefs: []
  type: TYPE_NORMAL
- en: For example, random trees and random forests can be considered pseudo-Symbolist—they're
    a distant cousin of the Symbolist school of thought, originating from decision
    trees. Support vector machines are analogizers. Maximum entropy and graphical
    methods are of the Bayesian school of thought.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book is biased toward the Connectionist school of thought for a good reason:
    deep learning is popular right now. If the winds of favor had been different,
    this book would have been markedly different. There is also the issue of explainability.
    I can explain support vector machines quite well, but it would consist of pages
    and pages of mathematical analogy. Opting not to explain how SVMs work, on the
    other hand, would lead to a very thin chapter—the standard implementation of SVMs
    is to use libsvm or svmlight. Simply call the functions provided by the library
    and the job''s done! So an explanation of SVMs is warranted.'
  prefs: []
  type: TYPE_NORMAL
- en: What does this all mean?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Does this mean that MachineBox''s algorithm is not good? The short answer is
    no: we cannot say that the MachineBox algorithm is not good. The longer answer
    requires a more nuanced understanding that combines engineering understanding
    and an understanding of machine learning. As far as the algorithm of facebox goes,
    there are no exact details about what facebox is composed of. But we can deduce
    what goes on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, note that the images with matches are all over 50% in their confidence.
    We can then assume that facebox considers a match being found only if the confidence
    level greater than 50%. I verified this by running the recognizer on a directory
    of over 1,000 images of faces. Only those that are matched have a greater-than
    50% confidence. The program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With this in mind, it also means that we cannot directly use `facebox`'s `.Matched` field
    as the truth value, except for very rudimentary use cases. Instead, we'd have
    to consider the confidence of the results returned.
  prefs: []
  type: TYPE_NORMAL
- en: We could, for example, set a higher threshold for a match to be considered HotDog.
    Setting it to 0.8 shows that only images of MC Hot Dog are recognized as HotDog.
  prefs: []
  type: TYPE_NORMAL
- en: The lesson learned here is that APIs created by other people require some understanding.
    The code provided in this chapter is remarkably short. This is a testament to
    MachineBox's developer friendliness. But that does not absolve the developer from
    having at least the most basic of understanding of things.
  prefs: []
  type: TYPE_NORMAL
- en: Why MachineBox?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I personally prefer to develop my own machine learning solutions. One may, of
    course, chalk this up to ego. However, in the first chapter, I introduced the
    notion that there are different types of problems. Some of these problems may
    be solved by machine learning algorithms. Some problems may only require general
    machine learning algorithms, while some require specialized algorithms derived
    from the general algorithms. In the majority of this book, I've shown the general
    algorithms, and readers are free to adapt these to their own specific problems.
  prefs: []
  type: TYPE_NORMAL
- en: I, too, recognize the value of having general machine learning algorithms as
    being part of the solution. Imagine that you are developing a program to reorganize
    your personal photos on your computer. There is no need to spend a protracted
    amount of time getting a convolutional neural network trained upon a corpus of
    faces. The main task is to organize the photos, not facial recognition! Instead,
    one may just use a model that is already trained. These sorts of ready-made solutions
    are suitable for problems in which the ready-made solution is a small part. Increasingly,
    there is a demand for such solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, many machine learning algorithms are provided now as a service. Amazon
    Web Services has its own offering, as do Google Cloud and Microsoft Azure. Why
    did I not choose to introduce those in this chapter? Here''s another thing you
    should know about me: I like to work offline. I find being connected to the internet
    while working only serves as a distraction—Slack messages, emails, and various
    other sites compete for my scarce attention. No, I prefer to work and think while
    offline.'
  prefs: []
  type: TYPE_NORMAL
- en: The cloud companies do offer machine learning as a service, and they all require
    internet access. MachineBox, to its credit, provides a Docker image. A Docker
    pull is all that is required. A once-off internet connection is required to download
    the files. But once that's done, the entire workflow may be developed offline—or
    as is the case for all the code in this chapter, on a plane.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is MachineBox''s main benefit: you are not beholden to a corporate entity
    that requires an always-on connection to their cloud services. But of course,
    that''s not all. MachineBox is famous for its developer friendliness. That I am
    able to write the majority of this chapter''s code in-flight is testament to their
    developer friendliness. To be fair, even as a seasoned machine learning library
    author, facial recognition is still pretty awesome.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In closing, it's only fair to mention that MachineBox does have some limitations
    for its free tiers; but for personal projects, in my experience, you won't run
    into them. Despite my personal reservations on the various machine learning-as-a-service
    systems out there, I do think they provide value. I have used them from time to
    time, but I generally do not need them. Nevertheless, I highly recommend that
    the reader check them out.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter, in combination with the previous chapter, has shown the breadth
    of machine learning in the industry. Not all machine learning algorithms have
    to be handwritten from scratch if your main problem does not call for it. I am
    lucky enough to have a career in doing what I love: building customized machine
    learning algorithms. This may have tainted my views on this issue. You may be
    an engineer on a deadline who has to solve some bigger business problems. For
    that, these two chapters are for you.'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will list further avenues for ML in Go.
  prefs: []
  type: TYPE_NORMAL
