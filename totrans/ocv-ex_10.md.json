["```py\n#include <opencv2/opencv.hpp>\n#include <vector>\n\nusing namespace std;\nusing namespace cv;\n\nMat binarize(Mat input)\n{\n  //Uses otsu to threshold the input image\n  Mat binaryImage;\n  cvtColor(input, input, CV_BGR2GRAY);\n  threshold(input, binaryImage, 0, 255, THRESH_OTSU);\n  //Count the number of black and white pixels\n  int white = countNonZero(binaryImage);\n  int black = binaryImage.size().area() - white;\n  //If the image is mostly white (white background), invert it\n  return white < black ? binaryImage : ~binaryImage;\n}\n```", "```py\nMat kernel = getStructuringElement(MORPH_CROSS, Size(3,3));\nMat dilated;\ndilate(input, dilated, kernel, cv::Point(-1, -1), 5);\nimshow(\"Dilated\", dilated);\n```", "```py\nvector<vector<Point> > contours;\nfindContours(dilated, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);\n```", "```py\n//For each contour\nvector<RotatedRect> areas;\nfor (auto contour : contours)\n{\n  //Find it's rotated rect\n  auto box = minAreaRect(contour);\n\n  //Discard very small boxes\n  if (box.size.width < 20 || box.size.height < 20)\n    continue;\n\n  //Discard squares shaped boxes and boxes\n  //higher than larger\n  double proportion = box.angle < -45.0 ?\n    box.size.height / box.size.width :\n    box.size.width / box.size.height;\n  if (proportion < 2)\n    continue;\n  //Add the box\n  areas.push_back(box);\n}\n```", "```py\nvector<RotatedRect> findTextAreas(Mat input)\n```", "```py\nMat deskewAndCrop(Mat input, const RotatedRect& box)\n{\n  double angle = box.angle;\n  Size2f size = box.size;\n\n  //Adjust the box angle\n   if (angle < -45.0)\n  {\n        angle += 90.0;\n\t\tstd::swap(size.width, size.height);\n  }\n\n  //Rotate the text according to the angle\n  Mat transform = getRotationMatrix2D(box.center, angle, 1.0);\n  Mat rotated;\n  warpAffine(input, rotated, transform, input.size(), INTER_CUBIC);\n\n  //Crop the result\n  Mat cropped;\n  getRectSubPix(rotated, size, box.center, cropped);\n  copyMakeBorder(cropped,cropped,10,10,10,10,BORDER_CONSTANT,Scalar(0));\n  return cropped;\n}\n```", "```py\n    int main(int argc, char* argv[])\n    {\n      //Loads the ticket image and binarize it\n      Mat ticket = binarize(imread(\"ticket.png\"));\n      auto regions = findTextAreas(ticket);\n\n      //For each region\n      for (auto& region : regions) {\n        //Crop \n        auto cropped = deskewAndCrop(ticket, region);\n        //Show\n        imshow(\"Cropped text\", cropped);\n        waitKey(0);\n        destroyWindow(\"Border Skew\");\n      }\n    }\n    ```", "```py\n    tesseract parkingTicket.png ticket.txt\n    ```", "```py\nTesseractInstallPath\\include\nTesseractInstallPath\\include\\leptonica\n```", "```py\nTesseractInstallPath\\lib\n```", "```py\nliblept168.lib\nlibtesseract302.lib\n```", "```py\nbrew install tesseract\n```", "```py\nbrew install tesseract --all-languages\n```", "```py\n#include <opencv2/opencv.hpp>\n#include <tesseract/baseapi.h>\n\n#include <vector>\n#include <fstream>\n\n```", "```py\ntesseract::TessBaseAPI ocr;\n```", "```py\nchar* identifyText(Mat input, char* language = \"eng\") \n{\n  ocr.Init(NULL, language, tesseract::OEM_TESSERACT_ONLY);\n  ocr.SetPageSegMode(tesseract::PSM_SINGLE_BLOCK);\n  ocr.SetImage(input.data, input.cols, input.rows, 1, input.step);\n  char* text = ocr.GetUTF8Text();\n  cout << \"Text:\" << endl;\n  cout << text << endl;\n  cout << \"Confidence: \" << ocr.MeanTextConf() << endl << endl;\n\n    // Get the text    \n  return text;\n}\n```", "```py\nint Init(const char* datapath, const char* language, OcrEngineMode oem)\n```", "```py\nocr.SetPageSegMode(tesseract::PSM_SINGLE_BLOCK);\n```", "```py\nvoid SetImage(const unsigned char* imagedata, int width, int height, int bytes_per_pixel, int bytes_per_line);\n```", "```py\n  char* text = ocr.GetUTF8Text();\n  cout << \"Text:\" << endl;\n  cout << text << endl;\n  cout << \"Confidence: \" << ocr.MeanTextConf() << endl << endl;\n```", "```py\nint main(int argc, char* argv[])\n{\n  //Loads the ticket image and binarize it\n  Mat ticket = binarize(imread(\"ticket.png\"));\n  auto regions = findTextAreas(ticket);\n\n  std::ofstream file;\n  file.open(\"ticket.txt\", std::ios::out | std::ios::binary);\n\n  //For each region\n  for (auto region : regions) {\n    //Crop\n    auto cropped = deskewAndCrop(ticket, region);\n    char* text = identifyText(cropped, \"por\");\n\n    file.write(text, strlen(text));\n    file << endl;\n  }\n\n  file.close();\n}\n```", "```py\nfile.open(\"ticket.txt\", std::ios::out | std::ios::binary);\n```", "```py\nfile.write(text, strlen(text));\n```"]