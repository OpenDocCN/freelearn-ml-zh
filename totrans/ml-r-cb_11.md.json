["```py\n    > install.packages(\"FSelector\")\n    > library(FSelector)\n\n    ```", "```py\n    > weights = random.forest.importance(churn~., trainset, importance.type = 1)\n    > print(weights)\n     attr_importance\n    international_plan                 96.3255882\n    voice_mail_plan                    24.8921239\n    number_vmail_messages              31.5420332\n    total_day_minutes                  51.9365357\n    total_day_calls                    -0.1766420\n    total_day_charge                   53.7930096\n    total_eve_minutes                  33.2006078\n    total_eve_calls                    -2.2270323\n    total_eve_charge                   32.4317375\n    total_night_minutes                22.0888120\n    total_night_calls                   0.3407087\n    total_night_charge                 21.6368855\n    total_intl_minutes                 32.4984413\n    total_intl_calls                   51.1154046\n    total_intl_charge                  32.4855194\n    number_customer_service_calls     114.2566676\n\n    ```", "```py\n    > subset = cutoff.k(weights, 5)\n    > f = as.simple.formula(subset, \"Class\")\n    > print(f)\n    Class ~ number_customer_service_calls + international_plan + \n     total_day_charge + total_day_minutes + total_intl_calls\n    <environment: 0x00000000269a28e8>\n\n    ```", "```py\n    > evaluator = function(subset) {\n    +   k = 5 \n    +   set.seed(2)\n    +   ind = sample(5, nrow(trainset), replace = TRUE)\n    +   results = sapply(1:k, function(i) {\n    +     train = trainset[ind ==i,]\n    +     test  = trainset[ind !=i,]\n    +     tree  = rpart(as.simple.formula(subset, \"churn\"), trainset)\n    +     error.rate = sum(test$churn != predict(tree, test, type=\"class\")) / nrow(test)\n    +     return(1 - error.rate)\n    +   })\n    +   return(mean(results))\n    + }\n\n    ```", "```py\n    > attr.subset = hill.climbing.search(names(trainset)[!names(trainset) %in% \"churn\"], evaluator)\n    > f = as.simple.formula(attr.subset, \"churn\")\n    > print(f)\n    churn ~ international_plan + voice_mail_plan + number_vmail_messages + \n     total_day_minutes + total_day_calls + total_eve_minutes + \n     total_eve_charge + total_intl_minutes + total_intl_calls + \n     total_intl_charge + number_customer_service_calls\n    <environment: 0x000000002224d3d0>\n\n    ```", "```py\n    > help(package=\"FSelector\")\n\n    ```", "```py\n    > data(swiss)\n\n    ```", "```py\n    > swiss = swiss[,-1]\n\n    ```", "```py\n    > swiss.pca = prcomp(swiss,\n    + center = TRUE,\n    + scale  = TRUE)\n    > swiss.pca\n    Standard deviations:\n    [1] 1.6228065 1.0354873 0.9033447 0.5592765 0.4067472\n\n    Rotation:\n     PC1         PC2          PC3        PC4         PC5\n    Agriculture      0.52396452 -0.25834215  0.003003672 -0.8090741  0.06411415\n    Examination  -0.57185792 -0.01145981 -0.039840522 -0.4224580 -0.70198942\n    Education       -0.49150243  0.19028476  0.539337412 -0.3321615  0.56656945\n    Catholic            0.38530580  0.36956307  0.725888143 0.1007965 -0.42176895\n    Infant.Mortality 0.09167606 0.87197641 -0.424976789 -0.2154928 0.06488642\n\n    ```", "```py\n    > summary(swiss.pca)\n    Importance of components:\n     PC1    PC2    PC3     PC4     PC5\n    Standard deviation     1.6228 1.0355 0.9033 0.55928 0.40675\n    Proportion of Variance 0.5267 0.2145 0.1632 0.06256 0.03309\n    Cumulative Proportion  0.5267 0.7411 0.9043 0.96691 1.00000\n\n    ```", "```py\n    > predict(swiss.pca, newdata=head(swiss, 1))\n     PC1       PC2        PC3      PC4       PC5\n    Courtelary -0.9390479 0.8047122 -0.8118681 1.000307 0.4618643\n\n    ```", "```py\n    > swiss.princomp = princomp(swiss,\n    + center = TRUE,\n    + scale  = TRUE)\n    > swiss.princomp\n    Call:\n    princomp(x = swiss, center = TRUE, scale = TRUE)\n\n    Standard deviations:\n     Comp.1    Comp.2    Comp.3    Comp.4    Comp.5 \n    42.896335 21.201887  7.587978  3.687888  2.721105 \n\n     5 variables and 47 observations.\n\n    ```", "```py\n    > summary(swiss.princomp)\n    Importance of components:\n     Comp.1     Comp.2     Comp.3      Comp.4      Comp.5\n    Standard deviation     42.8963346 21.2018868 7.58797830 3.687888330 2.721104713\n    Proportion of Variance  0.7770024  0.1898152 0.02431275 0.005742983 0.003126601\n    Cumulative Proportion   0.7770024  0.9668177 0.99113042 0.996873399 1.000000000\n\n    ```", "```py\n    > predict(swiss.princomp, swiss[1,])\n     Comp.1    Comp.2   Comp.3   Comp.4   Comp.5\n    Courtelary -38.95923 -20.40504 12.45808 4.713234 -1.46634\n\n    ```", "```py\n    > install.packages(\"psych\")\n    > install.packages(\"GPArotation\")\n    > library(psych)\n\n    ```", "```py\n    > swiss.principal = principal(swiss, nfactors=5, rotate=\"none\")\n    > swiss.principal\n    Principal Components Analysis\n    Call: principal(r = swiss, nfactors = 5, rotate = \"none\")\n    Standardized loadings (pattern matrix) based upon correlation matrix\n     PC1   PC2   PC3   PC4   PC5 h2       u2\n    Agriculture      -0.85 -0.27  0.00  0.45 -0.03  1 -6.7e-16\n    Examination       0.93 -0.01 -0.04  0.24  0.29  1  4.4e-16\n    Education         0.80  0.20  0.49  0.19 -0.23  1  2.2e-16\n    Catholic         -0.63  0.38  0.66 -0.06  0.17  1 -2.2e-16\n    Infant.Mortality -0.15  0.90 -0.38  0.12 -0.03  1 -8.9e-16\n\n     PC1  PC2  PC3  PC4  PC5\n    SS loadings           2.63 1.07 0.82 0.31 0.17\n    Proportion Var        0.53 0.21 0.16 0.06 0.03\n    Cumulative Var        0.53 0.74 0.90 0.97 1.00\n    Proportion Explained  0.53 0.21 0.16 0.06 0.03\n    Cumulative Proportion 0.53 0.74 0.90 0.97 1.00\n\n    Test of the hypothesis that 5 components are sufficient.\n\n    The degrees of freedom for the null model are 10 and the objective function was 2.13\n    The degrees of freedom for the model are -5  and the objective function was  0 \n    The total number of observations was  47  with MLE Chi Square =  0  with prob <  NA \n\n    Fit based upon off diagonal values = 1\n\n    ```", "```py\n    > screeplot(swiss.pca, type=\"barplot\")\n\n    ```", "```py\n    > screeplot(swiss.pca, type=\"line\")\n\n    ```", "```py\n> help(screeplot)\n\n```", "```py\n> install.packages(\"nFactors\")\n> library(nFactors)\n> ev = eigen(cor(swiss))\n> ap = parallel(subject=nrow(swiss),var=ncol(swiss),rep=100,cent=.05)\n> nS = nScree(x=ev$values, aparallel=ap$eigen$qevpea)\n> plotnScree(nS)\n\n```", "```py\n    > swiss.pca$sdev \n    [1] 1.6228065 1.0354873 0.9033447 0.5592765 0.4067472\n\n    ```", "```py\n    > swiss.pca$sdev ^ 2\n    [1] 2.6335008 1.0722340 0.8160316 0.3127902 0.1654433\n\n    ```", "```py\n    > which(swiss.pca$sdev ^ 2> 1)\n    [1] 1 2\n\n    ```", "```py\n    > screeplot(swiss.pca, type=\"line\")\n    > abline(h=1, col=\"red\", lty= 3)\n\n    ```", "```py\n    >  plot(swiss.pca$x[,1], swiss.pca$x[,2], xlim=c(-4,4))\n    > text(swiss.pca$x[,1], swiss.pca$x[,2], rownames(swiss.pca$x), cex=0.7, pos=4, col=\"red\")\n\n    ```", "```py\n    > biplot(swiss.pca)\n\n    ```", "```py\n> install.packages(\"devtools\")\n\n> library(ggbiplot)\n> g = ggbiplot(swiss.pca, obs.scale = 1, var.scale = 1, \n+ ellipse = TRUE, \n+ circle = TRUE)\n> print(g)\n\n```", "```py\n    > swiss.dist =dist(swiss)\n    > swiss.mds = cmdscale(swiss.dist, k=2)\n\n    ```", "```py\n    > plot(swiss.mds[,1], swiss.mds[,2], type = \"n\", main = \"cmdscale (stats)\")\n    > text(swiss.mds[,1], swiss.mds[,2], rownames(swiss), cex = 0.9, xpd = TRUE)\n\n    ```", "```py\n    > library(MASS)\n    > swiss.nmmds = isoMDS(swiss.dist, k=2)\n    initial  value 2.979731 \n    iter   5 value 2.431486\n    iter  10 value 2.343353\n    final  value 2.338839 \n    converged\n\n    ```", "```py\n    > plot(swiss.nmmds$points, type = \"n\", main = \"isoMDS (MASS)\")\n    > text(swiss.nmmds$points, rownames(swiss), cex = 0.9, xpd = TRUE)\n\n    ```", "```py\n    > swiss.sh = Shepard(swiss.dist, swiss.mds)\n    > plot(swiss.sh, pch = \".\")\n    > lines(swiss.sh$x, swiss.sh$yf, type = \"S\")\n\n    ```", "```py\n> library(igraph)\n> swiss.sample = swiss[1:10,]\n\n> g = graph.full(nrow(swiss.sample))\n> V(g)$label = rownames(swiss.sample)\n> layout = layout.mds(g, dist = as.matrix(dist(swiss.sample)))\n> plot(g, layout = layout, vertex.size = 3)\n\n```", "```py\n> swiss.dist = dist(swiss)\n> swiss.mds = cmdscale(swiss.dist, k=2)\n> plot(swiss.mds[,1], swiss.mds[,2], type=\"n\")\n> text(swiss.mds[,1], swiss.mds[,2], rownames(swiss), cex = 0.9, xpd = TRUE)\n> swiss.pca = prcomp(swiss)\n> text(-swiss.pca$x[,1],-swiss.pca$x[,2], rownames(swiss), \n+      ,col=\"blue\", adj = c(0.2,-0.5),cex = 0.9, xpd = TRUE)\n\n```", "```py\n    > swiss.svd = svd(swiss)\n\n    ```", "```py\n    > plot(swiss.svd$d^2/sum(swiss.svd$d^2), type=\"l\", xlab=\" Singular vector\", ylab = \"Variance explained\")\n\n    ```", "```py\n    > plot(cumsum(swiss.svd$d^2/sum(swiss.svd$d^2)), type=\"l\", xlab=\"Singular vector\", ylab = \"Cumulative percent of variance explained\")\n\n    ```", "```py\n    > swiss.recon = swiss.svd$u[,1] %*% diag(swiss.svd$d[1], length(1), length(1)) %*% t(swiss.svd$v[,1])\n\n    ```", "```py\n    > par(mfrow=c(1,2))\n    > image(as.matrix(swiss), main=\"swiss data Image\")\n    > image(swiss.recon,  main=\"Reconstructed Image\")\n\n    ```", "```py\n    > svd.m = svd(scale(swiss))\n    > svd.m$v\n     [,1]        [,2]         [,3]       [,4]        [,5]\n    [1,]  0.52396452 -0.25834215  0.003003672 -0.8090741  0.06411415\n    [2,] -0.57185792 -0.01145981 -0.039840522 -0.4224580 -0.70198942\n    [3,] -0.49150243  0.19028476  0.539337412 -0.3321615  0.56656945\n    [4,]  0.38530580  0.36956307  0.725888143  0.1007965 -0.42176895\n    [5,]  0.09167606  0.87197641 -0.424976789 -0.2154928  0.06488642\n    > pca.m = prcomp(swiss,scale=TRUE)\n    > pca.m$rotation\n     PC1         PC2          PC3        PC4         PC5\n    Agriculture      0.52396452 -0.25834215  0.003003672 -0.8090741  0.06411415\n    Examination  -0.57185792 -0.01145981 -0.039840522 -0.4224580 -0.70198942\n    Education       -0.49150243  0.19028476  0.539337412 -0.3321615  0.56656945\n    Catholic          0.38530580  0.36956307  0.725888143  0.1007965 -0.42176895\n    Infant.Mortality 0.09167606 0.87197641 -0.424976789 -0.2154928 0.06488642\n\n    ```", "```py\n    > install.packages(\"bmp\")\n    > library(bmp)\n\n    ```", "```py\n    > lenna = read.bmp(\"lena512.bmp\")\n\n    ```", "```py\n    > lenna = t(lenna)[,nrow(lenna):1]\n    > image(lenna) \n\n    ```", "```py\n    > lenna.svd = svd(scale(lenna))\n    > plot(lenna.svd$d^2/sum(lenna.svd$d^2), type=\"l\", xlab=\" Singular vector\", ylab = \"Variance explained\")\n\n    ```", "```py\n    > length(lenna.svd$d)\n    [1] 512\n\n    ```", "```py\n    > min(which(cumsum(lenna.svd$d^2/sum(lenna.svd$d^2))> 0.9))\n    [1] 18\n\n    ```", "```py\n    > lenna_compression = function(dim){\n    +     u=as.matrix(lenna.svd$u[, 1:dim])\n    +     v=as.matrix(lenna.svd$v[, 1:dim])\n    +     d=as.matrix(diag(lenna.svd$d)[1:dim, 1:dim])\n    +     image(u%*%d%*%t(v))\n    + }\n\n    ```", "```py\n    > lenna_compression(18)\n\n    ```", "```py\n    > min(which(cumsum(lenna.svd$d^2/sum(lenna.svd$d^2))> 0.99))\n    [1] 92\n    > lenna_compression(92)\n\n    ```", "```py\n    > install.packages(\"RnavGraphImageData\")\n    > install.packages(\"vegan\")\n    > library(RnavGraphImageData)\n    > library(vegan)\n\n    ```", "```py\n    > data(digits)\n\n    ```", "```py\n    > sample.digit = matrix(digits[,3000],ncol = 16, byrow=FALSE)\n    > image(t(sample.digit)[,nrow(sample.digit):1])\n\n    ```", "```py\n    > set.seed(2)\n    > digit.idx = sample(1:ncol(digits),size = 600)\n    > digit.select = digits[,digit.idx]\n\n    ```", "```py\n    > digits.Transpose = t(digit.select)\n    > digit.dist = vegdist(digits.Transpose, method=\"euclidean\")\n\n    ```", "```py\n    > digit.isomap = isomap(digit.dist,k = 8, ndim=6, fragmentedOK = TRUE)\n    > plot(digit.isomap)\n\n    ```", "```py\n    > digit.st = spantree(digit.dist)\n    > digit.plot = plot(digit.isomap, main=\"isomap k=8\")\n    > lines(digit.st, digit.plot, col=\"red\")\n\n    ```", "```py\n    > install.packages(\"RnavGraph\")\n    > source(\"http://bioconductor.org/biocLite.R\")\n    > biocLite(\"graph\")\n    > library(RnavGraph)\n\n    ```", "```py\n    > digit.group = rep(c(1:9,0), each = 1100)\n    > digit.ng_data = ng_data(name = \"ISO_digits\",\n    + data = data.frame(digit.isomap$points),\n    + shortnames = paste('i',1:6, sep = ''),\n    + group = digit.group[digit.idx],\n    + labels = as.character(digits.group[digit.idx]))\n\n    ```", "```py\n    >  V = shortnames(digit.ng_data)\n    >  G = completegraph(V)\n    >  LG =linegraph(G)\n    >  LGnot = complement(LG)\n    >  ng.LG = ng_graph(name = \"3D Transition\", graph = LG)\n    > ng.LGnot = ng_graph(name = \"4D Transition\", graph = LGnot)\n\n    ```", "```py\n    > ng.i.digits = ng_image_array_gray('USPS Handwritten Digits',\n    + digit.select,16,16,invert = TRUE,\n    + img_in_row = FALSE)\n    > vizDigits1 = ng_2d(data = digit.ng_data, graph = ng.LG, images = ng.i.digits)\n    > vizDigits2 = ng_2d(data = digit.ng_data, graph = ng.LGnot, images = ng.i.digits)\n    > nav = navGraph(data = digit.ng_data, graph = list(ng.LG, ng.LGnot), viz = list(vizDigits1, vizDigits2))\n\n    ```", "```py\n    > install.packages(\"lle\")\n    > library(lle)\n\n    ```", "```py\n    > data( lle_scurve_data )\n\n    ```", "```py\n    > X = lle_scurve_data\n    > results = lle( X=X , m=2, k=12,  id=TRUE)\n    finding neighbours\n    calculating weights\n    intrinsic dim: mean=2.47875, mode=2\n    computing coordinates\n\n    ```", "```py\n    > str( results )\n    List of 4\n     $ Y     : num [1:800, 1:2] -1.586 -0.415 0.896 0.513 1.477 ...\n     $ X     : num [1:800, 1:3] 0.955 -0.66 -0.983 0.954 0.958 ...\n     $ choise: NULL\n     $ id    : num [1:800] 3 3 2 3 2 2 2 3 3 3 ...\n    >plot( results$Y, main=\"embedded data\", xlab=expression(y[1]), ylab=expression(y[2]) )\n\n    ```", "```py\n    > plot_lle( results$Y, X, FALSE, col=\"red\", inter=TRUE )\n\n    ```", "```py\n    > source(\"http://bioconductor.org/biocLite.R\")\n    > biocLite(\"RDRToolbox\")\n    > library(RDRToolbox)\n\n    ```"]