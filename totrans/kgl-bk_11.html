<html><head></head><body>
  <div id="_idContainer290" class="Basic-Text-Frame">
    <h1 class="chapterNumber">9</h1>
    <h1 id="_idParaDest-148" class="chapterTitle">Ensembling with Blending and Stacking Solutions</h1>
    <p class="normal">When you start competing on Kaggle, it doesn’t take long to realize that you cannot win with a single, well-devised model; you need to ensemble multiple models. Next, you will immediately wonder how to set up a working ensemble. There are few guides around, and more is left to Kaggle’s lore than to scientific papers.</p>
    <p class="normal">The point here is that if ensembling is the key to winning in Kaggle competitions, in the real world it is associated with complexity, poor maintainability, difficult reproducibility, and hidden technical costs for little advantage. Often, the small boost that can move you from the lower ranks to the top of the leaderboard really doesn’t matter for real-world applications because the costs overshadow the advantages. However, that doesn’t mean that ensembling is not being used at all in the real world. In a limited form, such as averaging and mixing a few diverse models, ensembling allows us to create models that can solve many data science problems in a more effective and efficient way.</p>
    <p class="normal">Ensembling<a id="_idIndexMarker745"/> in Kaggle is not only a way to gain extra predictive performance, but it is also a teaming strategy. When you are working with other teammates, putting together everyone’s contributions produces a result that often performs better than individual efforts, and can also help to organize the work of the team by structuring everyone’s efforts toward a clear goal. In fact, when work is performed in different time zones and under different constraints for each participant, collaborative techniques like pair coding are clearly not feasible. One team member may be subject to constraints due to office hours, another due to studying and examinations, and so on. </p>
    <p class="normal">Teams in a competition often don’t have the chance to, and do not necessarily have to, synchronize and align all participants on the same tasks. Moreover, the skills within a team may also differ.</p>
    <p class="normal">A good ensembling <a id="_idIndexMarker746"/>strategy shared among a team means that individuals can keep working based on their own routines and styles, yet still contribute to the success of the group. Therefore, even different skills may become an advantage when using ensembling techniques based on diversity of predictions.</p>
    <p class="normal">In this chapter, we will start from the ensembling techniques that you already know, because they are embedded in algorithms such as random forests and gradient boosting, and then progress to ensembling techniques for multiple models such as averaging, blending, and stacking. We will provide you with some theory, some practice, and also some code examples you can use as templates when building your own solutions on Kaggle.</p>
    <p class="normal">We will cover these topics:</p>
    <ul>
      <li class="bulletList">A brief introduction to ensemble algorithms</li>
      <li class="bulletList">Averaging models into an ensemble</li>
      <li class="bulletList">Blending models using a meta-model </li>
      <li class="bulletList">Stacking models </li>
      <li class="bulletList">Creating complex stacking and blending solutions</li>
    </ul>
    <div class="note">
      <p class="normal">Before leaving you to read this chapter and try all the techniques, we have to mention a great reference on ensembling for us and for all practitioners when competing on Kaggle: the blog post written in 2015 by <em class="italic">Triskelion</em> (<em class="italic">Hendrik Jacob van Veen</em>) and by a few collaborators (<em class="italic">Le Nguyen The Dat</em>, <em class="italic">Armando Segnini</em>). The <em class="italic">Kaggle Ensembling Guide</em> was originally found on the <em class="italic">mlwave</em> blog (<a href="https://mlwave.com/kaggle-ensembling-guide"><span class="url">https://mlwave.com/kaggle-ensembling-guide</span></a>), which is no longer up, but you can retrieve the contents of the guide from <a href="https://usermanual.wiki/Document/Kaggle20ensembling20guide.685545114.pdf"><span class="url">https://usermanual.wiki/Document/Kaggle20ensembling20guide.685545114.pdf</span></a>. The post arranged most of the implicit and explicit knowledge about ensembling from Kaggle forums at the time.</p>
    </div>
    <h1 id="_idParaDest-149" class="heading-1">A brief introduction to ensemble algorithms</h1>
    <p class="normal">The idea that<a id="_idIndexMarker747"/> ensembles of models can outperform single ones is not a recent one. We can trace it back to <em class="italic">Sir</em> <em class="italic">Francis Galton</em>, who was alive in Victorian Britain. He figured out that, in order to guess the weight of an ox at a county fair, it was more useful to take an average from a host of more or less educated estimates from a crowd than having a single carefully devised estimate from an expert.</p>
    <p class="normal">In 1996, <em class="italic">Leo Breiman</em> <a id="_idIndexMarker748"/>formalized the idea of using multiple models combined into a more predictive one by illustrating <a id="_idIndexMarker749"/>the <strong class="keyWord">bagging</strong> technique (also called the “bootstrap aggregating” procedure) that later led to the development of the even more<a id="_idIndexMarker750"/> effective <strong class="keyWord">random forests</strong> algorithms. In the period that followed, other ensembling techniques such<a id="_idIndexMarker751"/> as <strong class="keyWord">gradient boosting</strong> and <strong class="keyWord">stacking</strong> were <a id="_idIndexMarker752"/>also presented, thus completing the range of ensemble methods that we use today.</p>
    <div class="note">
      <p class="normal">You can refer to a few articles to figure out how these ensembling algorithms were initially devised:</p>
      <ul>
        <li class="bulletList">For random forests, read Breiman, L. <em class="italic">Bagging predictors</em>. Machine learning 24.2 – 1996: 123-140.</li>
        <li class="bulletList">If you want to know how boosting originally worked in more detail, read Freund, Y. and Schapire, R.E. <em class="italic">Experiments with a new boosting algorithm.</em> <em class="italic">icml. Vol. 96 – 1996</em>, and <em class="italic">Friedman, J. H</em>. <em class="italic">Greedy function approximation: a gradient boosting machine.</em> <em class="italic">Annals of Statistics</em> (2001): 1189-1232. </li>
        <li class="bulletList">As for stacking, refer to Ting, K. M. and Witten, <em class="italic">I. H.</em> <em class="italic">Stacking bagged and dagged models</em>, 1997, for a first formal draft of the technique.</li>
      </ul>
    </div>
    <p class="normal">The first basic strategies<a id="_idIndexMarker753"/> for ensembling predictors in Kaggle competitions were taken directly from bagging and random forest strategies for classification and regression. They involved making an average of various predictions and were thus named <strong class="keyWord">averaging</strong> techniques. These <a id="_idIndexMarker754"/>approaches quickly emerged from the very first Kaggle competitions held over 11 years ago also because of the pre-Kaggle Netflix competition, where strategies based on the average of the results of different models dominated the scene. Given their success, basic ensembling techniques based on averaging set a standard for many competitions to come, and they are still quite useful and valid even today for scoring more highly on the leaderboard.</p>
    <p class="normal">Stacking, which is more complex and computationally demanding, emerged a bit later, when problems in competitions become more complex and the struggle between participants fiercer. Just as the random forest approach has inspired averaging different predictions, boosting heavily inspired stacking approaches. In boosting, by sequentially re-processing information, your learning algorithm can model problems in a better and more complete way. In fact, in gradient boosting, sequential decision trees are built in order to model the part of data that previous iterations are unable to grasp. This<a id="_idIndexMarker755"/> idea is reprised in stacking <a id="_idIndexMarker756"/>ensembles, where you stack the results of previous models and re-process them in order to gain an increase in predictive performance.</p>
    <div class="interviewBox">
      <div class="intervieweePhoto">
        <img src="../Images/Rob_Mulla.png" alt=""/>
      </div>
      <p class="intervieweeName">Rob Mulla</p>
      <p class="normal"><a href="https://www.kaggle.com/robikscube"><span class="url">https://www.kaggle.com/robikscube</span></a></p>
      <p class="normal">Rob spoke<a id="_idIndexMarker757"/> to us about his views on ensembling and what he has learned from Kaggle. A Grandmaster in Competitions, Notebooks, and Discussion, and Senior Data Scientist at Biocore LLC, there is a lot we can learn from his experiences.</p>
      <p class="interviewHeader">What’s your favorite kind of competition and why? In terms of techniques and solving approaches, what is your specialty on Kaggle?</p>
      <p class="normal"><em class="italic">My favorite type of competitions are ones that involve unique datasets requiring novel solutions that incorporate different types of modeling approaches. I enjoy when a competition isn’t just training large models on the dataset, but actually requires understanding the data very well and implementing ideas that leverage architectures specific to the tasks. I don’t try to specialize in any particular approach. When I first started Kaggle, I mainly stuck to gradient boosted models, but in order to be competitive in recent years I’ve grown in my understanding of deep learning, computer vision, NLP, and optimization. My favorite competitions require using more than just one technique.</em></p>
      <p class="interviewHeader">How do you approach a Kaggle competition? How different is this approach to what you do in your day-to-day work?</p>
      <p class="normal"><em class="italic">I approach Kaggle competitions in some ways very similar to work projects. First comes data understanding. In real-world projects, you may need to work on defining the problem and developing a good metric. In Kaggle, that is already done for you. Next is understanding how the data and metric relate to each other – and developing and testing modeling techniques that you believe will best solve the problem. The biggest difference in Kaggle compared to real-life data science is the final bit of ensembling and tuning of models to get a slight edge – in many real-world applications, these types of large ensembles are not necessary because the computational expense to performance gain can be small.</em></p>
      <p class="interviewHeader">Tell us about a particularly challenging competition you entered, and what insights you used to tackle the task.</p>
      <p class="normal"><em class="italic">A very challenging competition that I entered was the </em>NFL Helmet Impact Detection<em class="italic"> competition. It involved video data, which I had no prior experience with. It also required researching common approaches and reading existing papers on the topic. I had to work on a two-stage approach, which added to the complexity of the solution. A different competition that I found challenging was the </em>Indoor Location Navigation<em class="italic"> competition. It involved modeling, optimization, and really understanding the data well. I didn’t end up doing very well in the competition, but I learned a lot.</em></p>

      <p class="interviewHeader">Has Kaggle helped you in your career? If so, how?</p>
      <p class="normal"><em class="italic">Yes. Kaggle has played a big part in helping me gain notoriety in the data science space. I’ve also grown in my knowledge and understanding of new techniques and have met and worked with many brilliant people who have helped me grow in my skills and understanding of machine learning.</em></p>
      <p class="normal"><em class="italic">My team placed second for the </em>NFL Helmet Impact Detection<em class="italic"> Competition. I also participated in a number of NFL competitions prior to that competition. The hosts of the competition reached out to me and eventually it helped me land my current role.</em></p>
      <p class="interviewHeader">In your experience, what do inexperienced Kagglers often overlook? What do you know now that you wish you’d known when you first started?</p>
      <p class="normal"><em class="italic">I think inexperienced Kagglers sometimes worry too much about the ensembling and hyperparameter tuning of models. These are important towards the end of a competition, but they are not important unless you’ve already built a good base model. I also think that fully understanding the competition metric is extremely important. Many Kagglers overlook how important it is to understand how to optimize your solution to the evaluation metric.</em></p>
      <p class="interviewHeader">What mistakes have you made in competitions in the past?</p>
      <p class="normal"><em class="italic">A lot. I’ve overfit models and spent time working on things that didn’t end up being beneficial in the end. However, I feel like this was necessary for me to learn how to better tackle future competitions. The mistakes may have hurt me in the specific competition I was working in, but helped me to be better in later competitions.</em></p>
      <p class="interviewHeader">Are there any particular tools or libraries that you would recommend using for data analysis or machine learning?</p>
      <p class="normal"><em class="italic">For EDA, know how to manipulate data using NumPy, Pandas, and Matplotlib or another plotting library. For modeling, know how set up a proper cross validation scheme with Scikit-learn. The standard models like XGBoost/LightGBM are good to know how to baseline with. Deep learning libraries are mainly TensorFlow/Keras or PyTorch. Getting to know one of the two main deep learning libraries is important.</em></p>
    </div>
    <h1 id="_idParaDest-150" class="heading-1">Averaging models into an ensemble</h1>
    <p class="normal">In order to introduce the <a id="_idIndexMarker758"/>averaging ensembling technique better, let’s quickly revise all the strategies devised by Leo Breiman for ensembling. His work represented a milestone for ensembling strategies, and what he found out at the time still works fairly well in a wide range of problems. </p>
    <p class="normal">Breiman explored all these<a id="_idIndexMarker759"/> possibilities in order to figure out if there was a way to reduce the variance of error in powerful models that tended to overfit the training data too much, such as decision trees.</p>
    <p class="normal">Conceptually, he discovered that ensembling effectiveness was based on three elements: how we deal with<a id="_idIndexMarker760"/> the <strong class="keyWord">sampling of training cases</strong>, how we <strong class="keyWord">build the models</strong>, and, finally, how we <strong class="keyWord">combine the different models</strong> obtained.</p>
    <p class="normal">As for the sampling, the approaches tested and found were:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Pasting</strong>, where<a id="_idIndexMarker761"/> a number of models are built using subsamples (sampling without replacements) of the examples (the data rows)</li>
      <li class="bulletList"><strong class="keyWord">Bagging</strong>, where<a id="_idIndexMarker762"/> a number of models are built using random selections of bootstrapped examples (sampling with replacement)</li>
      <li class="bulletList"><strong class="keyWord">Random subspaces</strong>, where <a id="_idIndexMarker763"/>a number of models are built using subsamples (sampling without replacements) of the features (the data columns)</li>
      <li class="bulletList"><strong class="keyWord">Random patches</strong>, an<a id="_idIndexMarker764"/> approach similar to bagging, except features are also sampled when each model is selected, as in random subspaces</li>
    </ul>
    <p class="normal">The reason we <a id="_idIndexMarker765"/>sample instead of using the same information is because, by subsampling cases and features, we create models that are all relevant to the same problem while each being different from the others. This difference also applies to the way each model overfits the sample; we expect all the models to grasp the useful, generalizable information from the data <em class="italic">in the same way</em>, and deal with the noise that is not useful for making predictions <em class="italic">in a different way</em>. Hence, variation in modeling reduces the variation in predictions, because errors tend to cancel each other out.</p>
    <p class="normal">If this variation<a id="_idIndexMarker766"/> is so useful, then the next step should not just be to modify the <em class="italic">data</em> the model learns from, but also <em class="italic">the model itself</em>. We have two main approaches for the models:</p>
    <ul>
      <li class="bulletList">Ensembles of the same type of models</li>
      <li class="bulletList">Ensembles of different models</li>
    </ul>
    <p class="normal">Interestingly, ensembling in one way or the other doesn’t help too much if the models that we are putting together are too different in predictive power. The point here is that you get an advantage if you put together models that are able to correctly guess the same type of predictions, so they can smooth out their errors when averaging the predictions that they get wrong. If you are ensembling models with performances that are too different, you will soon find out that there is no point because the net effect will be negative: as you are not smoothing your incorrect predictions, you are also degrading the correct ones.</p>
    <p class="normal">This is an important limit of averaging: it can use a set of different models (for instance, because they are trained using different samples and features) only if they are similar in predictive power. To take <a id="_idIndexMarker767"/>an example, a linear regression and a <em class="italic">k</em>-nearest neighbor algorithm have different ways of modeling a problem and capturing signals from data; thanks to the (distinct) characteristic functional forms at their cores, these algorithms can grasp different predictive nuances from the data and perform better on specific parts of their predictive tasks, but you cannot really take advantage of that when using averaging. By contrast, the different ways algorithms have to capture signals is something that stacking actually can leverage, because it can take the best results from each algorithm.</p>
    <p class="normal">Based <a id="_idIndexMarker768"/>on this, we can summarize that, for an ensemble based on averaging (averaging the results of multiple models) to be effective, it should be:</p>
    <ul>
      <li class="bulletList">Built on models that are trained on different samples</li>
      <li class="bulletList">Built on models that use different subsamples from the available features</li>
      <li class="bulletList">Composed of models similar in predictive power</li>
    </ul>
    <p class="normal">Technically, this implies that the models’ predictions should be as uncorrelated as possible while performing at the same level of accuracy on prediction tasks.</p>
    <p class="normal">Now that we have discussed the opportunities and limitations of averaging multiple machine learning models, we are finally going to delve into the technical details. There are three ways to average multiple classification or regression models:</p>
    <ul>
      <li class="bulletList">Majority voting, using the most frequent classification among multiple models (only for classification models)</li>
      <li class="bulletList">Averaging values or probabilities</li>
      <li class="bulletList">Using a weighted average of values or probabilities</li>
    </ul>
    <p class="normal">In the next few sections, we will discuss each approach in detail in the context of Kaggle competitions.</p>
    <h2 id="_idParaDest-151" class="heading-2">Majority voting</h2>
    <p class="normal">Producing<a id="_idIndexMarker769"/> different models by varying<a id="_idIndexMarker770"/> the examples, features, and models we use in the ensemble (if they are comparable in predictive power, as we discussed before) requires a certain computational effort, but it doesn’t require you to build a data processing pipeline that is all that different from what you would set up when using a single model. </p>
    <p class="normal">In this pipeline, you just need to collect different test predictions, keeping track of the models used, how you sampled examples or features when training, the hyperparameters that you used, and the resulting cross-validation performance.</p>
    <p class="normal">If the <a id="_idIndexMarker771"/>competition requires you to predict a class, you<a id="_idIndexMarker772"/> can use <strong class="keyWord">majority voting</strong>; that is, for each prediction, you take the class most frequently predicted by your models. This works for both binary predictions and multi-class predictions, because it presumes that there are sometimes errors in your models, but that they can guess correctly most of the time. Majority voting is used as an “error correction procedure,” discarding noise and keeping meaningful signals.</p>
    <p class="normal">In our first simple example, we demonstrate how majority voting works. We start by creating our example dataset. Using the <code class="inlineCode">make_classification</code> function from Scikit-learn, we generate a <em class="italic">Madelon</em>-like dataset.</p>
    <div class="note">
      <p class="normal">The original Madelon was an artificial dataset containing data points grouped in clusters placed on the vertices of some dimensional hypercube and randomly labeled. It comprised a few informative features, mixed with irrelevant and repeated ones (to create multicollinearity between features) and it has a certain amount of injected random noise. Ideated by <em class="italic">Isabelle Guyon</em> (one of the creators of the SVM algorithm) for the <em class="italic">NIPS 2003 Feature Selection Challenge</em>, the Madelon dataset is the model example of a challenging artificial dataset for a competition. Even some Kaggle competitions were inspired by it: <a href="https://www.kaggle.com/c/overfitting"><span class="url">https://www.kaggle.com/c/overfitting</span></a> and the more recent <a href="https://www.kaggle.com/c/dont-overfit-ii"><span class="url">https://www.kaggle.com/c/dont-overfit-ii</span></a>.</p>
    </div>
    <p class="normal">We will use this recreation of the Madelon dataset throughout this chapter as a basis for testing ensembling techniques:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> make_classification
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split
X, y = make_classification(n_samples=<span class="hljs-number">5000</span>, n_features=<span class="hljs-number">50</span>, 
                           n_informative=<span class="hljs-number">10</span>,
                           n_redundant=<span class="hljs-number">25</span>, n_repeated=<span class="hljs-number">15</span>, 
                           n_clusters_per_class=<span class="hljs-number">5</span>,
                           flip_y=<span class="hljs-number">0.05</span>, class_sep=<span class="hljs-number">0.5</span>, 
                           random_state=<span class="hljs-number">0</span>)
X_train, X_test, y_train, y_test = train_test_split(X, y,   
                           test_size=<span class="hljs-number">0.33</span>, random_state=<span class="hljs-number">0</span>)
</code></pre>
    <p class="normal">After<a id="_idIndexMarker773"/> splitting it into a training and a test set, we proceed by instantiating our learning algorithms. We will just use three base algorithms: SVMs, random forests, and <em class="italic">k</em>-nearest neighbors classifiers, with default hyperparameters for demonstration purposes. You can try changing them or increasing their number:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC
<span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier
<span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> log_loss, roc_auc_score, accuracy_score
model_1 = SVC(probability=<span class="hljs-literal">True</span>, random_state=<span class="hljs-number">0</span>)
model_2 = RandomForestClassifier(random_state=<span class="hljs-number">0</span>)
model_3 = KNeighborsClassifier()
</code></pre>
    <p class="normal">The following step is just to train each model on the training set:</p>
    <pre class="programlisting code"><code class="hljs-code">model_1.fit(X_train, y_train)
model_2.fit(X_train, y_train)
model_3.fit(X_train, y_train)
</code></pre>
    <p class="normal">At this point, we need to predict on the test set for each model and ensemble all these predictions using majority voting. To do this, we will be using the <code class="inlineCode">mode</code> function from SciPy:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> mode
preds = np.stack([model_1.predict(X_test),
                  model_2.predict(X_test),
                  model_3.predict(X_test)]).T
max_voting = np.apply_along_axis(mode, <span class="hljs-number">1</span>, preds)[:,<span class="hljs-number">0</span>]
</code></pre>
    <p class="normal">First, we check the accuracy for each single model:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> i, model <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>([<span class="hljs-string">'SVC'</span>, <span class="hljs-string">'RF '</span>, <span class="hljs-string">'KNN'</span>]):
    acc = accuracy_score(y_true=y_test, y_pred=preds[:, i])
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Accuracy for model </span><span class="hljs-subst">{model}</span><span class="hljs-string"> is: </span><span class="hljs-subst">{acc:</span><span class="hljs-number">0.3</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">We see that the three models have similar performance, around <strong class="keyWord">0.8</strong>. Now it is time to check the majority voting ensemble:</p>
    <pre class="programlisting code"><code class="hljs-code">max_voting_accuray = accuracy_score(y_true=y_test, y_pred=max_voting)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Accuracy for majority voting is: </span><span class="hljs-subst">{max_voting_accuray:</span><span class="hljs-number">0.3</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">The <a id="_idIndexMarker774"/>voting ensemble is actually more accurate: <strong class="keyWord">0.817</strong>, because it managed to put together the correct signals from the majority.</p>
    <p class="normal">For multilabel problems (when you can predict multiple classes), you can just pick the classes that are predicted above a certain number of times, assuming a relevance threshold that indicates that a prediction for a class is signal, not noise. For instance, if you have five models, you could set this threshold to 3, which means if a class is predicted by at least three models, then the prediction should be considered correct.</p>
    <p class="normal">In regression problems, as well as when you are predicting probabilities, you cannot actually use majority voting. Majority voting works exclusively with class ownership. Instead, when you have to predict numbers, you need to combine the results numerically. In this case, resorting to an <strong class="keyWord">average</strong> or a <strong class="keyWord">weighted average</strong> will <a id="_idIndexMarker775"/>provide you the right way to combine predictions. </p>
    <h2 id="_idParaDest-152" class="heading-2">Averaging of model predictions</h2>
    <p class="normal">When <a id="_idIndexMarker776"/>averaging your predictions from different models in a competition, you can consider all your predictions as having potentially the same predictive power and use the arithmetic mean to derive an average value.</p>
    <p class="normal">Aside from the arithmetic mean, we have also found it quite effective to use:</p>
    <ul>
      <li class="bulletList">The <strong class="keyWord">geometric mean</strong>: This <a id="_idIndexMarker777"/>is where you multiply the <em class="italic">n</em> submissions, then you take the <em class="italic">1/n</em><sup class="superscript-italic" style="font-style: italic;">th</sup> power of the resulting product.</li>
      <li class="bulletList">The <strong class="keyWord">logarithmic mean</strong>: Analogous<a id="_idIndexMarker778"/> to the geometric mean, you take the logarithm of your submission, average them together, and take the exponentiation of the resulting mean.</li>
      <li class="bulletList">The <strong class="keyWord">harmonic mean</strong>: Where <a id="_idIndexMarker779"/>you take the arithmetic mean of the reciprocals of your submissions, then you take the reciprocal of the resulting mean.</li>
      <li class="bulletList">The <strong class="keyWord">mean of powers</strong>: Where you take the average of the <em class="italic">n</em><sup class="superscript-italic" style="font-style: italic;">th</sup> power of the submissions, then <a id="_idIndexMarker780"/>you take the <em class="italic">1/n</em><sup class="superscript-italic" style="font-style: italic;">th</sup> power of the resulting average.</li>
    </ul>
    <p class="normal">The simple arithmetic average<a id="_idIndexMarker781"/> is always quite effective and basically a no-brainer that works more often than expected. Sometimes, variants such as the geometric mean or the harmonic mean may work better.</p>
    <p class="normal">Continuing<a id="_idIndexMarker782"/> with the previous example, we will now try to figure out what kind of mean works best when we switch <a id="_idIndexMarker783"/>to <strong class="keyWord">ROC-AUC</strong> as our evaluation metric. To begin with, we evaluate the performances of each single model:</p>
    <pre class="programlisting code"><code class="hljs-code">proba = np.stack([model_1.predict_proba(X_test)[:, <span class="hljs-number">1</span>],
                  model_2.predict_proba(X_test)[:, <span class="hljs-number">1</span>],
                  model_3.predict_proba(X_test)[:, <span class="hljs-number">1</span>]]).T
<span class="hljs-keyword">for</span> i, model <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>([<span class="hljs-string">'SVC'</span>, <span class="hljs-string">'RF '</span>, <span class="hljs-string">'KNN'</span>]):
    ras = roc_auc_score(y_true=y_test, y_score=proba[:, i])
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"ROC-AUC for model </span><span class="hljs-subst">{model}</span><span class="hljs-string"> is: </span><span class="hljs-subst">{ras:</span><span class="hljs-number">0.5</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">The results give us a range from <strong class="keyWord">0.875</strong> to <strong class="keyWord">0.881</strong>.</p>
    <p class="normal">Our first test is performed using the arithmetic mean:</p>
    <pre class="programlisting code"><code class="hljs-code">arithmetic = proba.mean(axis=<span class="hljs-number">1</span>)
ras = roc_auc_score(y_true=y_test, y_score=arithmetic)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Mean averaging ROC-AUC is: </span><span class="hljs-subst">{ras:</span><span class="hljs-number">0.5</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">The resulting ROC-AUC score is decisively better than the single performances: <strong class="keyWord">0.90192</strong>. We also test if the geometric, harmonic, or logarithmic mean, or the mean of powers, can outperform the plain mean:</p>
    <pre class="programlisting code"><code class="hljs-code">geometric = proba.prod(axis=<span class="hljs-number">1</span>)**(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>)
ras = roc_auc_score(y_true=y_test, y_score=geometric)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Geometric averaging ROC-AUC is: </span><span class="hljs-subst">{ras:</span><span class="hljs-number">0.5</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
harmonic = <span class="hljs-number">1</span> / np.mean(<span class="hljs-number">1.</span> / (proba + <span class="hljs-number">0.00001</span>), axis=<span class="hljs-number">1</span>)
ras = roc_auc_score(y_true=y_test, y_score=harmonic)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Geometric averaging ROC-AUC is: </span><span class="hljs-subst">{ras:</span><span class="hljs-number">0.5</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
n = <span class="hljs-number">3</span>
mean_of_powers = np.mean(proba**n, axis=<span class="hljs-number">1</span>)**(<span class="hljs-number">1</span>/n)
ras = roc_auc_score(y_true=y_test, y_score=mean_of_powers)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Mean of powers averaging ROC-AUC is: </span><span class="hljs-subst">{ras:</span><span class="hljs-number">0.5</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
logarithmic = np.expm1(np.mean(np.log1p(proba), axis=<span class="hljs-number">1</span>))
ras = roc_auc_score(y_true=y_test, y_score=logarithmic)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Logarithmic averaging ROC-AUC is: </span><span class="hljs-subst">{ras:</span><span class="hljs-number">0.5</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">Running<a id="_idIndexMarker784"/> the code will tell us that none of them can. In this case, the arithmetic mean is the best choice for ensembling. What actually works better than the simple mean, in almost all cases, is putting some <em class="italic">prior knowledge</em> into the way you combine the numbers. This happens when you weight your models in the mean calculation.</p>
    <h2 id="_idParaDest-153" class="heading-2">Weighted averages</h2>
    <p class="normal">When <a id="_idIndexMarker785"/>weighting your models, you need to find an empirical way to figure out the right weights. A common method, though very <a id="_idIndexMarker786"/>prone to adaptive overfitting, is to test different combinations on the public leaderboard until you find the combination that scores the best. Of course, that won’t ensure that you score the same on the private leaderboard. Here, the principle is to weight what works better. However, as we have discussed at length, very often the feedback from the public leaderboard cannot be trusted because of important differences with the private test data. Yet, you <em class="italic">can</em> use your cross-validation scores or out-of-fold ones (the latter will be discussed along with stacking in a later section). In fact, another viable strategy is to use weights that are <strong class="keyWord">proportional to the models’ cross-validation performances</strong>.</p>
    <p class="normal">Although it is a bit counterintuitive, another very effective method is weighting the submissions <strong class="keyWord">inversely proportionally to their covariances</strong>. In fact, since we are striving to cancel errors by averaging, averaging based on the unique variance of each submission allows us to weight more heavily the predictions that are less correlated and more diverse, more effectively reducing the variance of the estimates.</p>
    <p class="normal">In the next example, we will first <a id="_idIndexMarker787"/>create a <strong class="keyWord">correlation matrix</strong> of our predicted probabilities, and then we proceed by:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Removing the one values on the diagonal and replacing them with zeroes</li>
      <li class="numberedList">Averaging the correlation matrix by row to obtain a vector</li>
      <li class="numberedList">Taking the reciprocal of each row sum</li>
      <li class="numberedList">Normalizing their sum to 1.0</li>
      <li class="numberedList">Using the resulting weighting vector in a matrix multiplication of our predicted probabilities</li>
    </ol>
    <p class="normal">Here is the code for this:</p>
    <pre class="programlisting code"><code class="hljs-code">cormat = np.corrcoef(proba.T)
np.fill_diagonal(cormat, <span class="hljs-number">0.0</span>)
W = <span class="hljs-number">1</span> / np.mean(cormat, axis=<span class="hljs-number">1</span>)
W = W / <span class="hljs-built_in">sum</span>(W) <span class="hljs-comment"># normalizing to sum==1.0</span>
weighted = proba.dot(W)
ras = roc_auc_score(y_true=y_test, y_score=weighted)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Weighted averaging ROC-AUC is: </span><span class="hljs-subst">{ras:</span><span class="hljs-number">0.5</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">The resulting ROC-AUC of <strong class="keyWord">0.90206</strong> is slightly better than the plain average. Giving more importance<a id="_idIndexMarker788"/> to more uncorrelated predictions is an ensembling strategy that is often successful. Even if it only provides slight improvements, this could suffice to turn the competition to your advantage.</p>
    <h2 id="_idParaDest-154" class="heading-2">Averaging in your cross-validation strategy</h2>
    <p class="normal">As we have <a id="_idIndexMarker789"/>covered, averaging doesn’t require you to build any special complex pipelines, only a certain number of typical data pipelines that create the models you are going to average, either<a id="_idIndexMarker790"/> using the same weights for all predictions or some empirically found weights. The only way to test it is to run a submission on the public leaderboard, thus risking adaptive fitting because your evaluation of the averaging will solely be based on the response from Kaggle.</p>
    <p class="normal">Before testing directly on the leaderboard, though, you may also test at training time by running the averaging operations on the validation fold (the fold that you are not using for training your model). This will provide you with less biased feedback than that from the leaderboard. In the following code, you can find an example of how a cross-validation prediction is arranged:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> KFold
kf = KFold(n_splits=<span class="hljs-number">5</span>, shuffle=<span class="hljs-literal">True</span>, random_state=<span class="hljs-number">0</span>)
scores = <span class="hljs-built_in">list</span>()
<span class="hljs-keyword">for</span> k, (train_index, test_index) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(kf.split(X_train)):
    model_1.fit(X_train[train_index, :], y_train[train_index])
    model_2.fit(X_train[train_index, :], y_train[train_index])
    model_3.fit(X_train[train_index, :], y_train[train_index])
    
    proba = np.stack(
          [model_1.predict_proba(X_train[test_index, :])[:, <span class="hljs-number">1</span>],
           model_2.predict_proba(X_train[test_index, :])[:, <span class="hljs-number">1</span>],
           model_3.predict_proba(X_train[test_index, :])[:, <span class="hljs-number">1</span>]]).T
    
    arithmetic = proba.mean(axis=<span class="hljs-number">1</span>)
    ras = roc_auc_score(y_true=y_train[test_index], 
                        y_score=arithmetic)
    scores.append(ras)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"FOLD </span><span class="hljs-subst">{k}</span><span class="hljs-string"> Mean averaging ROC-AUC is: </span><span class="hljs-subst">{ras:</span><span class="hljs-number">0.5</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"CV Mean averaging ROC-AUC is: </span><span class="hljs-subst">{np.mean(scores):</span><span class="hljs-number">0.5</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">Relying<a id="_idIndexMarker791"/> on the results of a <a id="_idIndexMarker792"/>cross-validation as in the code above can help you evaluate which averaging strategy is more promising, without testing directly on the public leaderboard.</p>
    <h2 id="_idParaDest-155" class="heading-2">Correcting averaging for ROC-AUC evaluations</h2>
    <p class="normal">If your task <a id="_idIndexMarker793"/>will be evaluated on the ROC-AUC score, simply averaging your results may not suffice. This <a id="_idIndexMarker794"/>is because different models may have adopted different optimization strategies and their outputs may be deeply different. A solution could be to calibrate the models, a type of post-processing we previously discussed in <em class="chapterRef">Chapter 5</em>, <em class="italic">Competition Tasks and Metrics</em>, but this obviously takes further time and computational effort.</p>
    <p class="normal">In these cases, the straightforward solution would be to convert output probabilities into ranks and just average the ranks (or make a weighted average of them). Using a min-max scaler approach, you simply convert each model’s estimates into the range 0-1 and then proceed with averaging the predictions. That will effectively convert your model’s probabilistic output into ranks that can be compared:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> MinMaxScaler
proba = np.stack(
          [model_1.predict_proba(X_train)[:, <span class="hljs-number">1</span>],
           model_2.predict_proba(X_train)[:, <span class="hljs-number">1</span>],
           model_3.predict_proba(X_train)[:, <span class="hljs-number">1</span>]]).T
arithmetic = MinMaxScaler().fit_transform(proba).mean(axis=<span class="hljs-number">1</span>)
ras = roc_auc_score(y_true=y_test, y_score=arithmetic)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Mean averaging ROC-AUC is: </span><span class="hljs-subst">{ras:</span><span class="hljs-number">0.5</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">This approach<a id="_idIndexMarker795"/> works perfectly when you are directly handling the test predictions. If, instead, you <a id="_idIndexMarker796"/>are working and trying to average results during cross-validation, you may encounter problems because the prediction range of your training data may differ from the range of your test predictions. In this case, you <a id="_idIndexMarker797"/>can solve the problem by training a calibration model (see <strong class="keyWord">probability calibration</strong> on Scikit-learn (<a href="https://scikit-learn.org/stable/modules/calibration.html"><span class="url">https://scikit-learn.org/stable/modules/calibration.html</span></a>) and <em class="chapterRef">Chapter 5</em>), converting predictions into true, comparable probabilities for each of your models.</p>
    <h1 id="_idParaDest-156" class="heading-1">Blending models using a meta-model</h1>
    <p class="normal">The<a id="_idIndexMarker798"/> Netflix competition (which we discussed at length in <em class="chapterRef">Chapter 1</em>) didn’t just demonstrate that averaging would be advantageous for difficult problems in a data science competition; it also brought about the idea that you can use a model to average your models’ results more effectively. The winning team, BigChaos, in their paper (Töscher, A., Jahrer, M., and Bell, R.M. <em class="italic">The BigChaos Solution to the Netflix Grand Prize</em>. Netflix prize documentation – 2009) made many mentions of <strong class="keyWord">blending</strong>, and provided many hints about its effectiveness and the way it works.</p>
    <p class="normal">In a few words, blending is <a id="_idIndexMarker799"/>kind of a weighted averaging procedure where the weights used to combine the predictions are estimated by way of a holdout set and a meta-model trained on it. A <strong class="keyWord">meta-model</strong> is <a id="_idIndexMarker800"/>simply a machine learning algorithm that learns from the output of other machine learning models. Usually, a meta-learner is a linear model (but sometimes it can also be a non-linear one; more on that in the next section), but you can actually use whatever you want, with some risks that we will discuss.</p>
    <p class="normal">The procedure for obtaining a blending is straightforward:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Before starting to build all your models, you randomly extract a holdout sample from the training data (in a team, you should all use the same holdout). Usually, the holdout is about 10% of the available data; however, depending on circumstances (for instance, the number of examples in your training data, stratifications), it could be less as well as more. As always in sampling, you may enforce stratification in order to ensure sampling representativeness, and you can test using adversarial validation that the sample really matches the distribution <a id="_idIndexMarker801"/>in the rest of the training set.</li>
      <li class="numberedList">Train all your models on the remaining training data.</li>
      <li class="numberedList">Predict on the holdout and on the test data.</li>
      <li class="numberedList">Use the holdout predictions as training data in a meta-learner and reuse the meta-learner model to compute the final test predictions using the test predictions from your models. Alternatively, you can use the meta-learner to figure out the selection of predictors and their weights that should be used in a weighted average.</li>
    </ol>
    <p class="normal">There a<a id="_idIndexMarker802"/> quite a few advantages<a id="_idIndexMarker803"/> and disadvantages to such a procedure. Let’s start with the advantages. First, it is easy to implement; you just have to figure out what the holdout sample is. In addition, using a meta-learning algorithm ensures you will find the best weights without testing on the public leaderboard.</p>
    <p class="normal">In terms of <a id="_idIndexMarker804"/>weaknesses, sometimes, depending on sample size and the type of models you use, reducing the number of training examples may increase the variance of the predictions of your estimators. Moreover, even if you take great care over how you sample your holdout, you may still fall into adaptive overfitting, that is, finding weights that suit the holdout but are not generalizable, especially if you use a meta-learner that is too complex. Finally, using a holdout for testing purposes has the same limitations as the training and test split we discussed in the chapter on model validation: you won’t have a reliable estimate if the sample size of the holdout is too small or if, for some reason, your sampling is not representative.</p>
    <h2 id="_idParaDest-157" class="heading-2">Best practices for blending</h2>
    <p class="normal">In blending, the <a id="_idIndexMarker805"/>kind of meta-learner you use can make a great difference. The most common choices are to use a linear model or a non-linear one. Among linear models, linear or logistic regressions are the preferred ones. Using a regularized model also helps to discard models that are not useful (L1 regularization) or reduce the influence of less useful ones (L2 regularization). One limit to using these kinds of meta-learners is that they may assign some models a negative contribution, as you will be able to see from the value of the coefficient in the model. When you encounter this situation, the model is usually overfitting, since all models should be contributing positively to the building of the ensemble (or, at worst, not contributing at all). The most recent versions of Scikit-learn allow you to impose only positive weights and to remove the intercept. These constraints act as a regularizer and prevent overfitting.</p>
    <p class="normal">Non-linear<a id="_idIndexMarker806"/> models as meta-learners are less common because they tend to overfit in regression and binary classification problems, but they often shine in multiclass and multilabel classification problems since they can model the complex relationships between the classes present. They also generally perform better if, aside from the models’ predictions, you also provide them with the <em class="italic">original features</em>, since they can spot any useful interactions that help them correctly select which models to trust more.</p>
    <p class="normal">In our next example, we first try blending using a linear model (a logistic regression), then a non-linear approach (a random forest). We start by splitting the training set into a training part for the blend elements and a holdout for the meta-learner. Afterward, we fit the models on the trainable part and predict on the holdout.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler
X_blend, X_holdout, y_blend, y_holdout = train_test_split(X_train, y_train, test_size=<span class="hljs-number">0.25</span>, random_state=<span class="hljs-number">0</span>)
model_1.fit(X_blend, y_blend)
model_2.fit(X_blend, y_blend)
model_3.fit(X_blend, y_blend)
proba = np.stack([model_1.predict_proba(X_holdout)[:, <span class="hljs-number">1</span>],
                  model_2.predict_proba(X_holdout)[:, <span class="hljs-number">1</span>],
                  model_3.predict_proba(X_holdout)[:, <span class="hljs-number">1</span>]]).T
scaler = StandardScaler()
proba = scaler.fit_transform(proba)
</code></pre>
    <p class="normal">We can now train our linear meta-learner using the probabilities predicted on the holdout:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression
blender = LogisticRegression(solver=<span class="hljs-string">'liblinear'</span>)
blender.fit(proba, y_holdout)
<span class="hljs-built_in">print</span>(blender.coef_)
</code></pre>
    <p class="normal">The resulting coefficients are:</p>
    <pre class="programlisting con"><code class="hljs-con">[[0.78911314 0.47202077 0.75115854]]
</code></pre>
    <p class="normal">By looking <a id="_idIndexMarker807"/>at the coefficients, we can figure out which model contributes more to the meta-ensemble. However, remember that coefficients also rescale probabilities when they are not well calibrated, so a larger coefficient for a model may not imply that it is the most important one. If you want to figure out the role of each model in the blend by looking at coefficients, you first have to rescale them by standardization (in our code example, this has been done using Scikit-learn’s <code class="inlineCode">StandardScaler</code>).</p>
    <p class="normal">Our output shows us that the SVC and <em class="italic">k</em>-nearest neighbors models are weighted more in the blend than the random forest one; their coefficients are almost equivalent and both are larger than the random forest coefficient.</p>
    <p class="normal">Once the meta-model is trained, we just predict on our test data and check its performance:</p>
    <pre class="programlisting code"><code class="hljs-code">test_proba = np.stack([model_1.predict_proba(X_test)[:, <span class="hljs-number">1</span>],
                       model_2.predict_proba(X_test)[:, <span class="hljs-number">1</span>],
                       model_3.predict_proba(X_test)[:, <span class="hljs-number">1</span>]]).T
blending = blender.predict_proba(test_proba)[:, <span class="hljs-number">1</span>]
ras = roc_auc_score(y_true=y_test, y_score=blending)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"ROC-AUC for linear blending </span><span class="hljs-subst">{model}</span><span class="hljs-string"> is: </span><span class="hljs-subst">{ras:</span><span class="hljs-number">0.5</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">We can try the same thing using a non-linear meta-learner, such as a random forest, for instance:</p>
    <pre class="programlisting code"><code class="hljs-code">blender = RandomForestClassifier()
blender.fit(proba, y_holdout)
test_proba = np.stack([model_1.predict_proba(X_test)[:, <span class="hljs-number">1</span>],
                       model_2.predict_proba(X_test)[:, <span class="hljs-number">1</span>],
                       model_3.predict_proba(X_test)[:, <span class="hljs-number">1</span>]]).T
blending = blender.predict_proba(test_proba)[:, <span class="hljs-number">1</span>]
ras = roc_auc_score(y_true=y_test, y_score=blending)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"ROC-AUC for non-linear blending </span><span class="hljs-subst">{model}</span><span class="hljs-string"> is: </span><span class="hljs-subst">{ras:</span><span class="hljs-number">0.5</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">An alternative to using a linear or non-linear model as a meta-learner is provided by the <strong class="keyWord">ensemble selection</strong> technique<a id="_idIndexMarker808"/> formalized by <em class="italic">Caruana</em>, <em class="italic">Niculescu-Mizil</em>, <em class="italic">Crew</em>, and <em class="italic">Ksikes</em>.</p>
    <div class="note">
      <p class="normal">If you are interested in more details, read their famous paper: Caruana, R., Niculescu-Mizil, A., Crew, G., and Ksikes, A. <em class="italic">Ensemble selection from libraries of models</em> (Proceedings of the Twenty-First International Conference on Machine Learning, 2004).</p>
    </div>
    <p class="normal">The <a id="_idIndexMarker809"/>ensemble selection is actually a weighted average, so it could simply be considered analogous to a linear combination. However, it is a constrained linear combination (because it is part of a hill-climbing optimization) that will also make a selection of models and apply only positive weights to the predictions. All this minimizes the risk of overfitting and ensures a more compact solution, because the solution will involve a model selection. From this perspective, ensemble selection is recommended in all problems where the risk of overfitting is high (for instance, because the training cases are few in number or the models are too complex) and in real-world applications because of its simpler yet effective solution.</p>
    <p class="normal">When using a meta-learner, you are depending on the optimization of its own cost function, which may differ from the metric adopted for the competition. Another great advantage of ensemble selection is that it can be optimized to any evaluation function, so it is mostly suggested when the metric for the competition is different from the canon of those typically optimized in machine learning models.</p>
    <p class="normal">Implementing ensemble selection requires the following steps, as described in the paper mentioned previously:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Start with your trained models and a holdout sample.</li>
      <li class="numberedList">Test all your models on the holdout sample and, based on the evaluation metric, retain the most effective in a selection (the <strong class="keyWord">ensemble selection</strong>).</li>
      <li class="numberedList">Then, keep on testing other models that could be added to the one(s) in the ensemble selection so that the average of the proposed selection improves over the previous one. You can either do this with replacement or without. Without replacement, you only put a model into the selection ensemble once; in this case, the procedure is just like a simple average after a forward selection. (In a forward selection, you iteratively add to a solution the model that improves the performance the most, until adding further models no longer improves the performance.) With replacement, you can put a model into the selection multiple times, thus resembling a weighted average.</li>
      <li class="numberedList">When you cannot get any further improvement, stop and use the ensemble selection.</li>
    </ol>
    <p class="normal">Here is a simple code example of an ensemble selection. We start by deriving a holdout sample and a training selection from our original training data. We fit the models and obtain the <a id="_idIndexMarker810"/>predictions on our holdout, as previously seen when blending with a meta-learner:</p>
    <pre class="programlisting code"><code class="hljs-code">X_blend, X_holdout, y_blend, y_holdout = train_test_split
    (X_train, y_train, test_size=<span class="hljs-number">0.5</span>, random_state=<span class="hljs-number">0</span>)
model_1.fit(X_blend, y_blend)
model_2.fit(X_blend, y_blend)
model_3.fit(X_blend, y_blend)
proba = np.stack([model_1.predict_proba(X_holdout)[:, <span class="hljs-number">1</span>],
                  model_2.predict_proba(X_holdout)[:, <span class="hljs-number">1</span>],
                  model_3.predict_proba(X_holdout)[:, <span class="hljs-number">1</span>]]).T
</code></pre>
    <p class="normal">In the next code snippet, the ensembling is created through a series of iterations. At each iteration, we try adding all the models in turn to the present ensemble and check if they improve the model. If any of these additions outperforms the previous ensemble on the holdout sample, the ensemble is updated and the bar is raised to the present level of performance. </p>
    <p class="normal">If no addition can improve the ensemble, the loop is stopped and the composition of the ensemble is reported back:</p>
    <pre class="programlisting code"><code class="hljs-code">iterations = <span class="hljs-number">100</span>
proba = np.stack([model_1.predict_proba(X_holdout)[:, <span class="hljs-number">1</span>],
                  model_2.predict_proba(X_holdout)[:, <span class="hljs-number">1</span>],
                  model_3.predict_proba(X_holdout)[:, <span class="hljs-number">1</span>]]).T
baseline = <span class="hljs-number">0.5</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"starting baseline is </span><span class="hljs-subst">{baseline:</span><span class="hljs-number">0.5</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
models = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(iterations):
    challengers = <span class="hljs-built_in">list</span>()
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(proba.shape[<span class="hljs-number">1</span>]):
        new_proba = np.stack(proba[:, models + [j]])
        score = roc_auc_score(y_true=y_holdout, 
                              y_score=np.mean(new_proba, axis=<span class="hljs-number">1</span>))
        challengers.append([score, j])
    
    challengers = <span class="hljs-built_in">sorted</span>(challengers, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>],
                         reverse=<span class="hljs-literal">True</span>)
    best_score, best_model = challengers[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">if</span> best_score &gt; baseline:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Adding model_</span><span class="hljs-subst">{best_model+</span><span class="hljs-number">1</span><span class="hljs-subst">}</span><span class="hljs-string"> to the ensemble"</span>,  
              end=<span class="hljs-string">': '</span>) 
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"ROC-AUC increases score to </span><span class="hljs-subst">{best_score:</span><span class="hljs-number">0.5</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
        models.append(best_model)
        baseline = best_score
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Cannot improve further - Stopping"</span>)
</code></pre>
    <p class="normal">Finally, we count how many times each model has been inserted into the average and we calculate the weights for our averaging on the test set:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter
freqs = Counter(models)
weights = {key: freq/<span class="hljs-built_in">len</span>(models) <span class="hljs-keyword">for</span> key, freq <span class="hljs-keyword">in</span> freqs.items()}
<span class="hljs-built_in">print</span>(weights)
</code></pre>
    <p class="normal">You can <a id="_idIndexMarker811"/>make the procedure more sophisticated in various ways. Since this approach may overfit, especially at the initial stages, you could start from a randomly initialized ensemble set or, as the authors suggest, you may already be starting with the <em class="italic">n</em> best performing models in the set (you decide the value of <em class="italic">n</em>, as a hyperparameter). Another variation involves applying sampling to the set of models that can enter the selection at each iteration; in other words, you randomly exclude some models from being picked. Not only will this inject randomness into the process but it will also prevent specific models from dominating the selection.</p>
    <h1 id="_idParaDest-158" class="heading-1">Stacking models together</h1>
    <p class="normal"><strong class="keyWord">Stacking</strong> was <a id="_idIndexMarker812"/>first mentioned in <em class="italic">David Wolpert</em>’s paper (<em class="italic">Wolpert, D. H</em>. <em class="italic">Stacked generalization.</em> Neural networks 5.2 – 1992), but it took years before the idea become widely accepted and <a id="_idIndexMarker813"/>common (only with release 0.22 in December 2019, for instance, has Scikit-learn implemented a stacking wrapper). This was due principally to the Netflix competition first, and to Kaggle competitions afterward.</p>
    <p class="normal">In stacking, you<a id="_idIndexMarker814"/> always have a meta-learner. This time, however, it is not trained on a holdout, but on the entire training set, thanks to the <strong class="keyWord">out-of-fold</strong> (<strong class="keyWord">OOF</strong>) prediction strategy. We <a id="_idIndexMarker815"/>already discussed this strategy in <em class="chapterRef">Chapter 6</em>, <em class="italic">Designing Good Validation</em>. In OOF prediction, you start from a replicable <em class="italic">k</em>-fold cross-validation split. <em class="italic">Replicable</em> means that, by recording the cases in each training and testing sets at each round or by reproducibility <a id="_idIndexMarker816"/>assured by a random seed, you can replicate the same validation scheme for each model you need to be part of the stacking ensemble.</p>
    <div class="note">
      <p class="normal">In the Netflix competition, stacking and blending were often used interchangeably, though the actual method devised by Wolpert originally implied leveraging a scheme based on <em class="italic">k</em>-fold cross-validation, not a holdout set. In fact, the core idea in stacking is not to reduce the variance, as in averaging; it is mostly to reduce the bias, because it is expected that each model involved in the stacking will grasp a part of the information present in the data, to be recomposed in the final meta-learner.</p>
    </div>
    <p class="normal">Let’s remind <a id="_idIndexMarker817"/>ourselves of how OOF predictions on the training data work. When testing a model, at each round of the validation you train a model on part of the training data and you validate on another part that is held out from the training. </p>
    <p class="normal">By recording the validation predictions and then reordering them to reconstruct the ordering of the original training cases, you will obtain a prediction of your model on the very same training set that you have used. However, as you have used multiple models and each model has predicted on cases it didn’t use for training, you should not have any overfitting effects on your training set predictions.</p>
    <p class="normal">Having obtained OOF predictions for all your models, you can proceed to build a meta-learner that predicts your target based on the OOF predictions (first-level predictions), or you can keep on producing further OOF predictions on top of your previous OOF predictions (second- or higher-level predictions), thus creating multiple stacking layers. This is compatible with an idea presented by Wolpert himself: by using multiple meta-learners, you are actually imitating the structure of a fully connected feedforward neural network without backpropagation, where the weights are optimally calculated in order to maximize the predictive performance at the level of each layer separately. From a practical point of view, stacking multiple layers has proven very effective and works very well for complex problems where single algorithms are unable to obtain the best results.</p>
    <p class="normal">Moreover, one interesting aspect of <a id="_idIndexMarker818"/>stacking is that you don’t need models of comparable<a id="_idIndexMarker819"/> predictive power, as in averaging and often in blending. In fact, even worse-performing models may be effective as part of a stacking ensemble. A <em class="italic">k</em>-nearest neighbors model may not be comparable to a gradient boosting solution, but when you use its OOF predictions for stacking it may contribute positively and increase the predictive performance of the ensemble.</p>
    <p class="normal">When you have trained all the stacking layers, it is time to predict. As far as producing the predictions used at various stacking stages, it is important to note that you have two ways to do this. The original Wolpert paper suggests re-training your models on all your training data and then using those re-trained models for predicting on the test set. In practice, many Kagglers don’t retrain, but directly use the models created for each fold and make multiple predictions on the test set that are averaged at the end.</p>
    <p class="normal">In our experience, stacking is generally more effective with complete re-training on all available data before predicting on the test set when you are using a low number of <em class="italic">k</em>-folds. In these cases, the sample consistency may really make a difference in the quality of the prediction because training on less data means getting more variance in the estimates. As we discussed in <em class="chapterRef">Chapter 6</em>, when creating OOF predictions it is always better to use a high number of folds, between 10 to 20. This limits the number of examples that are held out, and, without re-training on all the data, you can simply use the average of predictions obtained from the cross-validation trained models for obtaining your prediction on the test set.</p>
    <p class="normal">In our next example, for illustrative purposes, we only have five CV folds and the results are stacked twice. In the diagram below, you can follow how the data and the models move between different stages of the stacking process:</p>
    <figure class="mediaobject"><img src="../Images/B17574_09_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.1: Diagram of a two-layer stacking process with final averaging of predictions</p>
    <p class="normal">Notice that:</p>
    <ul>
      <li class="bulletList">Training data is fed to both levels of the stacking (OOF predictions at the second level of the stacking are joined with the training data)</li>
      <li class="bulletList">After obtaining OOF predictions from the CV loops, models are re-trained on the entire training dataset</li>
      <li class="bulletList">The final predictions are a simple average of all the predictions obtained by the stacked predictors</li>
    </ul>
    <p class="normal">Let’s now take a look at the<a id="_idIndexMarker820"/> code<a id="_idIndexMarker821"/> to understand how this diagram translates into Python commands, starting with the first level of training:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> KFold
kf = KFold(n_splits=<span class="hljs-number">5</span>, shuffle=<span class="hljs-literal">True</span>, random_state=<span class="hljs-number">0</span>)
scores = <span class="hljs-built_in">list</span>()
first_lvl_oof = np.zeros((<span class="hljs-built_in">len</span>(X_train), <span class="hljs-number">3</span>))
fist_lvl_preds = np.zeros((<span class="hljs-built_in">len</span>(X_test), <span class="hljs-number">3</span>))
<span class="hljs-keyword">for</span> k, (train_index, val_index) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(kf.split(X_train)):
    model_1.fit(X_train[train_index, :], y_train[train_index])
    first_lvl_oof[val_index, <span class="hljs-number">0</span>] = model_1.predict_proba(
                                     X_train[val_index, :])[:, <span class="hljs-number">1</span>]
    
    model_2.fit(X_train[train_index, :], y_train[train_index])
    first_lvl_oof[val_index, <span class="hljs-number">1</span>] = model_2.predict_proba(
                                     X_train[val_index, :])[:, <span class="hljs-number">1</span>]
    
    model_3.fit(X_train[train_index, :], y_train[train_index])
    first_lvl_oof[val_index, <span class="hljs-number">2</span>] = model_3.predict_proba(
                                     X_train[val_index, :])[:, <span class="hljs-number">1</span>]
</code></pre>
    <p class="normal">After the<a id="_idIndexMarker822"/> first layer, we retrain on the full dataset:</p>
    <pre class="programlisting code"><code class="hljs-code">model_1.fit(X_train, y_train)
fist_lvl_preds[:, <span class="hljs-number">0</span>] = model_1.predict_proba(X_test)[:, <span class="hljs-number">1</span>]
model_2.fit(X_train, y_train)
fist_lvl_preds[:, <span class="hljs-number">1</span>] = model_2.predict_proba(X_test)[:, <span class="hljs-number">1</span>]
model_3.fit(X_train, y_train)
fist_lvl_preds[:, <span class="hljs-number">2</span>] = model_3.predict_proba(X_test)[:, <span class="hljs-number">1</span>]
</code></pre>
    <p class="normal">In the second stacking, we<a id="_idIndexMarker823"/> will reuse the same models as those in the first layer, adding the stacked OOF predictions to the existing variables:</p>
    <pre class="programlisting code"><code class="hljs-code">second_lvl_oof = np.zeros((<span class="hljs-built_in">len</span>(X_train), <span class="hljs-number">3</span>))
second_lvl_preds = np.zeros((<span class="hljs-built_in">len</span>(X_test), <span class="hljs-number">3</span>))
<span class="hljs-keyword">for</span> k, (train_index, val_index) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(kf.split(X_train)):
    skip_X_train = np.hstack([X_train, first_lvl_oof])
    model_1.fit(skip_X_train[train_index, :],
                y_train[train_index])
    second_lvl_oof[val_index, <span class="hljs-number">0</span>] = model_1.predict_proba(
                          skip_X_train[val_index, :])[:, <span class="hljs-number">1</span>]
    
    model_2.fit(skip_X_train[train_index, :],
                y_train[train_index])
    second_lvl_oof[val_index, <span class="hljs-number">1</span>] = model_2.predict_proba(
                          skip_X_train[val_index, :])[:, <span class="hljs-number">1</span>]
    
    model_3.fit(skip_X_train[train_index, :],
                y_train[train_index])
    second_lvl_oof[val_index, <span class="hljs-number">2</span>] = model_3.predict_proba(
                          skip_X_train[val_index, :])[:, <span class="hljs-number">1</span>]
</code></pre>
    <p class="normal">Again, we retrain on the full data for the second layer:</p>
    <pre class="programlisting code"><code class="hljs-code">skip_X_test = np.hstack([X_test, fist_lvl_preds])
model_1.fit(skip_X_train, y_train)
second_lvl_preds[:, <span class="hljs-number">0</span>] = model_1.predict_proba(skip_X_test)[:, <span class="hljs-number">1</span>]
model_2.fit(skip_X_train, y_train)
second_lvl_preds[:, <span class="hljs-number">1</span>] = model_2.predict_proba(skip_X_test)[:, <span class="hljs-number">1</span>]
model_3.fit(skip_X_train, y_train)
second_lvl_preds[:, <span class="hljs-number">2</span>] = model_3.predict_proba(skip_X_test)[:, <span class="hljs-number">1</span>]
</code></pre>
    <p class="normal">The stacking is <a id="_idIndexMarker824"/>concluded <a id="_idIndexMarker825"/>by averaging all the stacked OOF results from the second layer:</p>
    <pre class="programlisting code"><code class="hljs-code">arithmetic = second_lvl_preds.mean(axis=<span class="hljs-number">1</span>)
ras = roc_auc_score(y_true=y_test, y_score=arithmetic)
scores.append(ras)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Stacking ROC-AUC is: </span><span class="hljs-subst">{ras:</span><span class="hljs-number">0.5</span><span class="hljs-subst">f}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">The resulting ROC-AUC score is about <strong class="keyWord">0.90424</strong>, which is better than previous blending and averaging attempts on the same data and models.</p>
    <h2 id="_idParaDest-159" class="heading-2">Stacking variations</h2>
    <p class="normal">The <a id="_idIndexMarker826"/>main variations on stacking involve changing how test data is processed across the layers, whether to use only stacked OOF predictions or also the original features in all the stacking layers, what model to use as the last one, and various tricks in order to prevent overfitting. </p>
    <p class="normal">We discuss some of the most effective here that we have personally experimented with:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Optimization may or may not be used.</strong> Some solutions do not care too much about optimizing single models; others optimize only the last layers; others optimize on the first layers. Based on our experiences, optimization of single models is important and we prefer to do it as early as possible in our stacking ensemble.</li>
      <li class="bulletList"><strong class="keyWord">Models can differ at the different stacking layers, or the same sequence of models can be repeated at every stacking layer.</strong> Here we don’t have a general rule, as it really depends on the problem. The kind of models that are more effective may vary according to the problem. As a general suggestion, putting together gradient boosting solutions and neural networks has never disappointed us.</li>
      <li class="bulletList"><strong class="keyWord">At the first level of the stacking procedure, just create as many models are possible.</strong> For instance, you can try a regression model if your problem is a classification one, and vice versa. You can also use different models with different hyperparameter settings, thus avoiding too much extensive optimization because the stacking will decide for you. If you are using neural networks, just changing the random initialization seed could suffice to create a diverse bag of models. You can also try models using different feature engineering and even use unsupervised learning (like <em class="italic">Mike Kim</em> did when he used t-SNE dimensions in a solution of his: <a href="https://www.kaggle.com/c/otto-group-product-classification-challenge/discussion/14295"><span class="url">https://www.kaggle.com/c/otto-group-product-classification-challenge/discussion/14295</span></a>). The idea is that the selection of all such contributions is done during the second level of the stacking. This means that, at that point, you do not have to experiment any further and you just need to focus on a narrower set of better-performing models. By applying stacking, you can re-use all your experiments and let the stacking decide for you to what degree you should use something in your modeling pipeline.</li>
      <li class="bulletList"> Some stacking implementations take on all the features or a selection of them to further stages, reminiscent of skip layers in neural networks. We have noticed that bringing in features at later stages in the stacking can improve your results, but be careful: it also brings in more noise and risk of overfitting.</li>
      <li class="bulletList">Ideally, your <a id="_idIndexMarker827"/>OOF predictions should be made from cross-validation schemes with a high number of folds, in other words, between 10 to 20, but we have also seen solutions working with a lower number, such as 5 folds.</li>
      <li class="bulletList">For each fold, bagging the data (resampling with repetition) multiple times for the same model and then averaging all the results from the model (OOF predictions and test predictions) helps to avoid overfitting and produces better results in the end. </li>
      <li class="bulletList"><strong class="keyWord">Beware of early stopping in stacking.</strong> Using it directly on the validation fold may cause a certain degree of overfitting, which may or may not be mitigated in the end by the stacking procedure. We suggest you play it safe and always apply early stopping based on a validation sample from your training folds, not your validation one.</li>
    </ul>
    <p class="normal">The possibilities are endless. Once you have grasped the basic concept of this ensembling technique, all <a id="_idIndexMarker828"/>you need is to apply your creativity to the problem at hand. We will discuss this key concept in the final section of this chapter, where we will look at a stacking solution for a Kaggle competition.</p>
    <h1 id="_idParaDest-160" class="heading-1">Creating complex stacking and blending solutions</h1>
    <p class="normal">At this <a id="_idIndexMarker829"/>point in the chapter, you may be wondering to what extent you should apply the techniques we have been discussing. In theory, you could use all the ensembling techniques we have presented in any competition on Kaggle, not just tabular ones, but you have to consider a few limiting factors:</p>
    <ul>
      <li class="bulletList">Sometimes, datasets are massive, and training a single model takes a long time.</li>
      <li class="bulletList">In image recognition competitions, you are limited to using deep learning methods.</li>
      <li class="bulletList">Even if you can manage to stack models in a deep learning competition, you have a limited choice for stacking different models. Since you are restricted to deep learning solutions, you can only vary small design aspects of the networks and some hyperparameters (or sometimes just the initialization seed) without degrading the performance. In the end, given the same type of models and more similarities than differences in the architectures, the predictions will tend to be too similar and more correlated than they should be, limiting the effectiveness of ensembling. </li>
    </ul>
    <p class="normal">Under these conditions, complex stacking regimes are usually not feasible. By contrast, averaging and blending are usually possible when you have large datasets.</p>
    <p class="normal">In earlier competitions, as well as in all recent tabular competitions, complex stacking and blending solutions ruled the day. To give you an idea of the complexity and creativity that needs to be put into stacking for a competition, in this last section we will discuss the solution provided by <em class="italic">Gilberto Titericz</em> (<a href="https://www.kaggle.com/titericz"><span class="url">https://www.kaggle.com/titericz</span></a>) and <em class="italic">Stanislav Semenov</em> (<a href="https://www.kaggle.com/stasg7"><span class="url">https://www.kaggle.com/stasg7</span></a>) to the <em class="italic">Otto Group Product Classification Challenge</em> (<a href="https://www.kaggle.com/c/otto-group-product-classification-challenge"><span class="url">https://www.kaggle.com/c/otto-group-product-classification-challenge</span></a>). The competition was held in 2015 and its task required classifying over 200,000 products into 9 distinct classes based on 93 features.</p>
    <p class="normal">The solution proposed by Gilberto and Stanislav comprised three levels:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">On the first level, there were 33 models. All the models used quite different algorithms, apart from a cluster of <em class="italic">k</em>-nearest neighbors where only the <em class="italic">k</em> parameter varied. They also used unsupervised t-SNE. In addition, they engineered eight features based on dimensionality manipulation (computations performed on distances from nearest neighbors and clusters) and on row statistics (the number of non-zero elements in each row). All the OOF predictions and features were passed to the second level.</li>
      <li class="numberedList">On the second level, they started optimizing hyperparameters and doing model selection and bagging (they created multiple versions of the same model by resampling and averaged the results for each model). In the end, they had only three models that they re-trained on all the data: an XGBoost, an AdaBoost, and a neural network.</li>
      <li class="numberedList">On the third level, they prepared a weighted average of the results by first doing a geometric mean of XGBoost and the neural network and then averaging it with the AdaBoost.</li>
    </ol>
    <p class="normal">We can learn<a id="_idIndexMarker830"/> a lot from this solution, and not just limited to this competition. Aside from the complexity (on the second level, the number of times they resampled was in the order of hundreds for each model), it is noticeable that there are multiple variations on the schemes we discussed in this chapter. Creativity and trial and error clearly dominate the solution. This is quite typical of many Kaggle competitions, where the problems are seldom the same from one competition to another and each solution is unique and not easily repeatable.</p>
    <p class="normal">Many AutoML engines, such <a id="_idIndexMarker831"/>as <strong class="keyWord">AutoGluon</strong>, more or less explicitly try to take inspiration from such procedures in order to offer a predefined series of automated steps that can ensure you a top result by stacking and blending.</p>
    <div class="note">
      <p class="normal">See <a href="https://arxiv.org/abs/2003.06505"><span class="url">https://arxiv.org/abs/2003.06505</span></a> for a list of the algorithms used by AutoGluon to build its stacked models. The list is quite long and you will find many ideas for your own stacking solutions.</p>
    </div>
    <p class="normal">However, despite the fact they implement some of the best practices around, their results are always subpar compared to what can be achieved by a good team of Kagglers, because creativity in the way you experiment and compose the ensemble is the key to success. The same goes for this chapter of ours. We have shown you the best practices for ensembling; take them as a starting point and create your own by mixing ideas and innovating based on the Kaggle competition or the real-world problem that you are dealing with.</p>
    <div class="interviewBox">
      <div class="intervieweePhoto">
        <img src="../Images/Xavier_Conort.png" alt=""/>
      </div>
      <p class="intervieweeName">Xavier Conort</p>
      <p class="normal"><a href="https://www.kaggle.com/xavierconort"><span class="url">https://www.kaggle.com/xavierconort</span></a></p>
      <p class="normal">To conclude<a id="_idIndexMarker832"/> the chapter, we caught up with Xavier Conort, a Competitions Grandmaster who ranked #1 in 2012-2013. An inspiration for many Kagglers at the beginning of Kaggle history, he is now the founder and CEO of his own company, Data Mapping and Engineering. He spoke to us about his experiences with Kaggle, his career, and more.</p>
      <p class="interviewHeader">What’s your favourite kind of competition and why? In terms of techniques and solving approaches, what is your speciality on Kaggle?</p>
      <p class="normal"><em class="italic">I really enjoyed competitions where feature engineering from multiple tables was required to get good results. I liked to mine for good features, especially for business problems that were new to me. This gave me a lot of confidence in my capacity to tackle new problems. In addition to good feature engineering, stacking helped me get good results. I used it to blend multiple models or transform text or high categorical variables into numeric features. My favorite algorithm was GBM, but I tested many other algorithms to add diversity to my blends.</em></p>
      <p class="interviewHeader">How do you approach a Kaggle competition? How different is this approach to what you do in your day-to-day work?</p>
      <p class="normal"><em class="italic">My primary goal was to learn as much as possible from each competition. Before entering a competition, I tried to assess which skills I would develop. I was not afraid to go beyond my comfort zone. Thanks to the leaderboard feedback, I knew I could learn rapidly from my mistakes. Day-to-day work rarely offers this opportunity. It is difficult to assess the actual quality of the solution we are working on. So, we just play safe and tend to repeat past recipes. I don’t think I could have learnt as much as I did without Kaggle.</em></p>
      <p class="interviewHeader">Tell us about a particularly challenging competition you entered, and what insights you used to tackle the task.</p>
      <p class="normal"><em class="italic">My favorite competition is </em>GE Flight Quest<em class="italic">, a competition organised by GE where competitors had to predict arrival time of domestic flights in the US. I especially liked the way the competition’s private leaderboard was designed. It tested our capacity to predict future events by scoring our predictions on flights that happened after the competition deadline.</em></p>

      <p class="normal"><em class="italic">As we had</em><em class="italic"><a id="_idIndexMarker833"/></em><em class="italic"> only a few months of history (3 or 4, if my memory is correct), I knew there was a strong risk of overfitting. To mitigate this risk, I decided to build only features that had an obvious causal relation with flight delays, such as features measuring weather conditions and traffic. And I was very careful to exclude the name of the airport from my primary feature lists. Indeed, some airports hadn’t experienced bad weather conditions during the few months of history. So, I was very concerned that my favorite ML algorithm, GBM, would use the name of the airport as a proxy for good weather and then fail to predict well for those airports in the private leaderboard. To capture the fact that some airports are better managed than others and improve my leaderboard score slightly, I eventually did use the name of the airport, but as a residual effect only. It was a feature of my second layer of models that used as an offset the predictions of my first layer of models. This approach can be considered a two-step boosting, where you censor some information during the first step. I learnt it from actuaries applying this approach in insurance to capture geospatial residual effects.</em></p>
      <p class="interviewHeader">Has Kaggle helped you in your career? If so, how?</p>
      <p class="normal"><em class="italic">It definitely helped me in my career as a data scientist. Before converting into data science, I was an actuary in the insurance industry, didn’t know anything about machine learning, and didn’t know any data scientists. Thanks to Kaggle’s diversity of competitions, I boosted my learning curve. Thanks to my good results, I could show a track record and convince employers that a 39-year-old actuary could successfully develop new skills on his own. And thanks to Kaggle’s community, I connected with many passionate data scientists across the world. I first had a lot of fun competing with or against them. Finally, I had the chance to work with some of them. Jeremy Achin and Tom De Godoy, the DataRobot founders, were my competition teammates before they asked me to join DataRobot. Without Kaggle’s help, I think I would still be working as an actuary in the insurance industry.</em></p>
      <p class="interviewHeader">Have you ever used something you have done in Kaggle competitions in order to build your portfolio to show to potential employers?</p>
      <p class="normal"><em class="italic">I have to confess that I did enter a few competitions with the goal to impress my employer or potential clients. It worked well, but it was much less fun and much more pressure.</em></p>
      <p class="interviewHeader">In your experience, what do inexperienced Kagglers often overlook? What do you know now that you wish you’d known when you first started?</p>
      <p class="normal"><em class="italic">I would advise</em><em class="italic"><a id="_idIndexMarker834"/></em><em class="italic"> inexperienced Kagglers not to look at the solutions posted during the competition but to try to find good solutions on their own. I am happy that competitors didn’t share code during the early days of Kaggle. It forced me to learn the hard way.</em></p>

      <p class="interviewHeader">What mistakes have you made in competitions in the past?</p>
      <p class="normal"><em class="italic">One mistake is to keep on competing in competitions that are badly designed with leaks. It is just a waste of time. You don’t learn much from those competitions.</em></p>
      <p class="interviewHeader">Are there any particular tools or libraries that you would recommend using for data analysis or machine learning?</p>
      <p class="normal"><em class="italic">Gradient Boosting Machine is my favorite algorithm. I first used R’s gbm, then Scikit-learn GBM, then XGBoost, and finally LightGBM. Most of the time, it has been the principal ingredient of my winning solution. To get some insight into what GBM learns, I would recommend the SHAP package.</em></p>
      <p class="interviewHeader">What’s the most important thing someone should keep in mind or do when they’re entering a competition?</p>
      <p class="normal"><em class="italic">Compete to learn. Compete to connect with other passionate data scientists. Don’t compete only to win.</em></p>
    </div>
    <h1 id="_idParaDest-161" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we discussed how ensembling multiple solutions works and proposed some basic code examples you can use to start building your own solutions. We started from the ideas that power model ensembles such as random forests and gradient boosting. Then, we moved on to explore the different ensembling approaches, from the simple averaging of test submissions to meta-modeling across multiple layers of stacked models.</p>
    <p class="normal">As we discussed at the end, ensembling is more an art form based on some shared common practices. When we explored a successful complex stacking regime that won a Kaggle competition, we were amazed by how the combinations were tailored to the data and the problem itself. You cannot just take a stacking, replicate it on another problem, and hope that it will be the best solution. You can only follow guidelines and find the best solution consisting of averaging/stacking/blending of diverse models yourself, through lots of experimentation and computational effort. </p>
    <p class="normal">In the next chapter, we will start delving into deep learning competitions, beginning with computer vision ones for classification and segmentation tasks.</p>
    <h1 id="_idParaDest-162" class="heading-1">Join our book’s Discord space</h1>
    <p class="normal">Join the book’s Discord workspace for a monthly <em class="italic">Ask me Anything</em> session with the authors: </p>
    <p class="normal"><a href="https://packt.link/KaggleDiscord"><span class="url">https://packt.link/KaggleDiscord</span></a></p>
    <p class="normal"><img src="../Images/QR_Code40480600921811704671.png" alt=""/></p>
  </div>
</body></html>