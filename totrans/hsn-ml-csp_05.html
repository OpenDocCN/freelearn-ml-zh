<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Fuzzy Logic – Navigating the Obstacle Course</h1>
                </header>
            
            <article>
                
<p><strong>Fuzzy logic</strong>. Another one of those buzzword-compliant terms you hear all the time. But what does it really mean, and could it mean more than one thing? We are about to find out just that. We will use fuzzy logic to help guide an autonomous vehicle around an obstacle course, and if we do it correctly, we will avoid obstacles along the way. Our <strong>automated guided vehicle</strong> (<strong>AGV</strong>) will navigate its way around the obstacle course, sensing for obstacles in its path. It will use an inference system to help guide it along. You, the user, will be able to create obstacles or throughways, which the AGV either <span>must </span>avoid or can utilize. You can watch the tracking beams work as well as track the path of the AGV along its course. Each step the AGV takes will be updated on the user interface so that you can see what is going on.</p>
<p>In Boolean logic, things are either true or false, on or off, black or white. What many people do not know is that there is also what is known as <strong>many-valued logic</strong>, where the truth lies somewhere between 1 and 0. Fuzzy logic is a <span>conceptual implementation of </span>many-valued logic that handles partial truth. What many people also do not know is that the famous sigmoid function, which you will hear of later, in our chapter on activation functions, is a fuzzification method.</p>
<p>Wikipedia has a great visual of this, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dda03ae2-295a-4898-9fd4-7d78c8312853.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign"/>
<p>According to Wikipedia:</p>
<div class="packt_quote">"In this image, the meanings of the expressions cold, warm, and hot are represented by functions mapping a temperature scale. A point on that scale has three "truth values"-one for each of the three functions. The vertical line in the image represents a particular temperature that the three arrows (truth values) gauge. Since the red arrow points to zero, this temperature may be interpreted as "not hot". The orange arrow (pointing at 0.2) may describe it as "slightly warm" and the blue arrow (pointing at 0.8) "fairly cold"."</div>
<p>This diagram and description are a very accurate representation of what we are about to delve into. Why do we show this? Because our first example is going to show exactly this. To illustrate fuzzy logic, we will be using the AForge.NET open source machine learning framework. For a user, it is an excellent framework to show how easy it is to use the inference engine to accomplish tasks.</p>
<p>In this chapter we will cover:</p>
<ul>
<li>Fuzzy logic</li>
<li>Autonomously guided vehicles</li>
<li>Obstacle avoidance and recognition</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fuzzy logic</h1>
                </header>
            
            <article>
                
<p>Our application will have two simple buttons, one for running the fuzzy set test and the other for running the linguistic variable test. Here is a quick snapshot of what our example application will look like:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/a95d0ce8-a83f-4978-8825-bb0041f0d2ba.png" style=""/></div>
<p>The code to create this sample is relatively small and simple. Here is what it looks like when we click on the <span class="packt_screen">Run Fuzzy Set Test</span> button. We will create two fuzzy sets (one for <span class="packt_screen">Cool</span> and one for <span class="packt_screen">Warm</span>), add some membership data values for each, and then plot them:</p>
<pre class="mce-root CDPAlignLeft CDPAlign">TrapezoidalFunction function1 = new TrapezoidalFunction( 13, 18, 23, 28 );<br/>             FuzzySet fsCool = new FuzzySet( "Cool", function1 );<br/>             TrapezoidalFunction function2 = new TrapezoidalFunction( 23, 28, 33, 38 );<br/>             FuzzySet fsWarm = new FuzzySet( "Warm", function2 );<br/> <br/>             double[,] coolValues = new double[20, 2];<br/>             for ( int i = 10; i &lt; 30; i++ )<br/>             {<br/>                 coolValues[i - 10, 0] = i;<br/>                 coolValues[i - 10, 1] = fsCool.GetMembership( i );<br/>             }<br/> <br/>             double[,] warmValues = new double[20, 2];<br/>             for ( int i = 20; i &lt; 40; i++ )<br/>             {<br/>                 warmValues[i - 20, 0] = i;<br/>                 warmValues[i - 20, 1] = fsWarm.GetMembership( i );<br/>             }<br/> <br/>             chart?.UpdateDataSeries( "COOL", coolValues );<br/>             chart?.UpdateDataSeries( "WARM", warmValues );</pre>
<p>The code for running the linguistic variable test is as follows. Again, we create fuzzy sets, but this time we create four instead of two. As with our first test, we add membership data and then plot:</p>
<pre class="mce-root CDPAlignLeft CDPAlign">LinguisticVariable lvTemperature = new LinguisticVariable( "Temperature", 0, 80 );<br/>             TrapezoidalFunction function1 = new TrapezoidalFunction( 10, 15, TrapezoidalFunction.EdgeType.Right );<br/>             FuzzySet fsCold = new FuzzySet( "Cold", function1 );<br/>             TrapezoidalFunction function2 = new TrapezoidalFunction( 10, 15, 20, 25 );<br/>             FuzzySet fsCool = new FuzzySet( "Cool", function2 );<br/>             TrapezoidalFunction function3 = new TrapezoidalFunction( 20, 25, 30, 35 );<br/>             FuzzySet fsWarm = new FuzzySet( "Warm", function3 );<br/>             TrapezoidalFunction function4 = new TrapezoidalFunction( 30, 35, TrapezoidalFunction.EdgeType.Left );<br/>             FuzzySet fsHot = new FuzzySet( "Hot", function4 );<br/> <br/>             lvTemperature.AddLabel( fsCold );<br/>             lvTemperature.AddLabel( fsCool );<br/>             lvTemperature.AddLabel( fsWarm );<br/>             lvTemperature.AddLabel( fsHot );<br/> <br/>             double[][,] chartValues = new double[4][,];<br/>             for ( int i = 0; i &lt; 4; i++ )<br/>                 chartValues[i] = new double[160, 2];</pre>
<p class="mce-root">And finally we chart the values:</p>
<pre class="mce-root CDPAlignLeft CDPAlign">int j = 0;<br/>             for ( float x = 0; x &lt; 80; x += 0.5f, j++ )<br/>             {<br/>                 double y1 = lvTemperature.GetLabelMembership( "Cold", x );<br/>                 double y2 = lvTemperature.GetLabelMembership( "Cool", x );<br/>                 double y3 = lvTemperature.GetLabelMembership( "Warm", x );<br/>                 double y4 = lvTemperature.GetLabelMembership( "Hot", x );<br/> <br/>                 chartValues[0][j, 0] = x;<br/>                 chartValues[0][j, 1] = y1;<br/>                 chartValues[1][j, 0] = x;<br/>                 chartValues[1][j, 1] = y2;<br/>                 chartValues[2][j, 0] = x;<br/>                 chartValues[2][j, 1] = y3;<br/>                 chartValues[3][j, 0] = x;<br/>                 chartValues[3][j, 1] = y4;<br/>             }<br/> <br/>             chart.UpdateDataSeries( "COLD", chartValues[0] );<br/>             chart.UpdateDataSeries( "COOL", chartValues[1] );<br/>             chart.UpdateDataSeries( "WARM", chartValues[2] );<br/>             chart.UpdateDataSeries( "HOT", chartValues[3] );</pre>
<p>Linguistic variable shape:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/78d3c1c5-8a9c-4fb8-a2ec-4e76a08f8d62.png" style=""/></div>
<p>As you can see, we were able to easily show the exact visual definition and clarity that the Wikipedia definition presented.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fuzzy AGV</h1>
                </header>
            
            <article>
                
<p>In this example, we are going to go more in depth than we did for our first example. Before we go any further, let me show you what our application will look like, and then a brief explanation of an inference engine is in order:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6462a37e-0518-402b-aa89-d3c38ae894bd.png" style=""/></div>
<p> </p>
<div class="CDPAlignCenter CDPAlign"/>
<p>Although AForge.NET makes it very easy and transparent for us to create an <kbd>InferenceSystem</kbd> object, we should probably start first by telling you a little bit about what such a system is. A fuzzy inference system is a model capable of executing fuzzy computing. This is accomplished using a database, linguistic variables and a rule base, all of which can be in memory. The typical operation of a fuzzy inference system is as follows:</p>
<ul>
<li>Get the numeric inputs</li>
<li>Utilize the database with the linguistic variables to obtain linguistic meaning for each numerical input</li>
<li>Verify which rules from the rule base are activated by the input</li>
<li>Combine the results of the activated rules to obtain a fuzzy output</li>
</ul>
<p>For us, the part where most of the work will be performed is in initializing our fuzzy logic system. Let's break this down into our individual steps as previously outlined.</p>
<p>First, we prepare the linguistic labels (fuzzy sets) that compose the distances we will have. They are <kbd>Near</kbd>, <kbd>Medium</kbd>, and <kbd>Far</kbd>:</p>
<pre class="mce-root CDPAlignLeft CDPAlign">            FuzzySet fsNear = new FuzzySet( "Near", new TrapezoidalFunction( 15, 50, TrapezoidalFunction.EdgeType.Right ) );<br/>             FuzzySet fsMedium = new FuzzySet( "Medium", new TrapezoidalFunction( 15, 50, 60, 100 ) );<br/>             FuzzySet fsFar = new FuzzySet( "Far", new TrapezoidalFunction( 60, 100, TrapezoidalFunction.EdgeType.Left ) );</pre>
<p>Next, we initialize the linguistic variables we'll need. The first, <kbd>lvRight</kbd>, will be an input variable for the right distance measurement:</p>
<pre class="mce-root CDPAlignLeft CDPAlign">            LinguisticVariable lvRight = new LinguisticVariable( "RightDistance", 0, 120 );<br/>             lvRight.AddLabel( fsNear );<br/>             lvRight.AddLabel( fsMedium );<br/>             lvRight.AddLabel( fsFar );</pre>
<p>Now, we do the same for the left distance input measurement:</p>
<pre class="mce-root CDPAlignLeft CDPAlign">            LinguisticVariable lvLeft = new LinguisticVariable( "LeftDistance", 0, 120 );<br/>             lvLeft.AddLabel( fsNear );<br/>             lvLeft.AddLabel( fsMedium );<br/>             lvLeft.AddLabel( fsFar );</pre>
<p>Our last linguistic variable will be for the front distance measurement:</p>
<pre class="mce-root CDPAlignLeft CDPAlign">            LinguisticVariable lvFront = new LinguisticVariable( "FrontalDistance", 0, 120 );<br/>             lvFront.AddLabel( fsNear );<br/>             lvFront.AddLabel( fsMedium );<br/>             lvFront.AddLabel( fsFar );</pre>
<p>We now focus on the linguistic labels (fuzzy sets) that compose the angle. We need to do this step so that we can create our final linguistic variable:</p>
<pre class="mce-root CDPAlignLeft CDPAlign">            FuzzySet fsVN = new FuzzySet( "VeryNegative", new TrapezoidalFunction( -40, -35, TrapezoidalFunction.EdgeType.Right));<br/>             FuzzySet fsN = new FuzzySet( "Negative", new TrapezoidalFunction( -40, -35, -25, -20 ) );<br/>             FuzzySet fsLN = new FuzzySet( "LittleNegative", new TrapezoidalFunction( -25, -20, -10, -5 ) );<br/>             FuzzySet fsZero = new FuzzySet( "Zero", new TrapezoidalFunction( -10, 5, 5, 10 ) );<br/>             FuzzySet fsLP = new FuzzySet( "LittlePositive", new TrapezoidalFunction( 5, 10, 20, 25 ) );<br/>             FuzzySet fsP = new FuzzySet( "Positive", new TrapezoidalFunction( 20, 25, 35, 40 ) );<br/>             FuzzySet fsVP = new FuzzySet( "VeryPositive", new TrapezoidalFunction( 35, 40, TrapezoidalFunction.EdgeType.Left));</pre>
<p>Now we can create our final linguistic variable for the angle:</p>
<pre class="mce-root CDPAlignLeft CDPAlign">            LinguisticVariable lvAngle = new LinguisticVariable( "Angle", -50, 50 );<br/>             lvAngle.AddLabel( fsVN );<br/>             lvAngle.AddLabel( fsN );<br/>             lvAngle.AddLabel( fsLN );<br/>             lvAngle.AddLabel( fsZero );<br/>             lvAngle.AddLabel( fsLP );<br/>             lvAngle.AddLabel( fsP );<br/>             lvAngle.AddLabel( fsVP );</pre>
<p>We can now move on to creating our fuzzy database. For our application, this is an in-memory dictionary of linguistic variables, but there is no reason you can't implement it as a SQL, NoSQL, or any other type of concrete database, should you so desire:</p>
<pre class="mce-root CDPAlignLeft CDPAlign">            Database fuzzyDB = new Database( );<br/>             fuzzyDB.AddVariable( lvFront );<br/>             fuzzyDB.AddVariable( lvLeft );<br/>             fuzzyDB.AddVariable( lvRight );<br/>             fuzzyDB.AddVariable( lvAngle );</pre>
<p>Next, we will create the main inference engine. What is most interesting about this next line of code is the <kbd>CentroidDifuzzifier</kbd>. At the end of our inference process, we are going to need a numeric value to control other parts of the process. In order to obtain this number, a defuzzification method is performed. Let me explain it.</p>
<p>The output of our fuzzy inference system is a set of rules with a firing strength greater than zero. This firing strength applies a constraint to the consequent fuzzy sets of the rules. When we put all those fuzzy sets together, they result in a shape that is the linguistic output meaning. The centroid method will calculate the center of the area of our shape to obtain the numerical representation of the output. It uses numerical approximation, so several intervals will be chosen. As the number of intervals increases, so does the precision of our output:</p>
<pre>IS = new InferenceSystem(fuzzyDB, new CentroidDefuzzifier(1000));</pre>
<p>Next, we can start adding the rules to our inference system:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bb9364a6-0fa2-4277-85cd-41b48d8cf5a0.png"/></div>
<p>After all this work, our inference system is ready to go!</p>
<p>The main code loop for our application will look like this. We will describe each function in detail:</p>
<pre class="mce-root CDPAlignLeft CDPAlign">if (FirstInference)<br/>                 GetMeasures();<br/> <br/>             try<br/>             {<br/>                 DoInference();<br/>                 MoveAGV();<br/>                 GetMeasures();<br/>             }<br/>             catch (Exception ex)<br/>             {<br/>                 Debug.WriteLine(ex);<br/>             }</pre>
<p class="mce-root">Let's take a quick look at the <kbd>GetMeasures</kbd> function.</p>
<p>After getting the current bitmap as well as the position of our AGV, we call the <kbd>HandleAGVOnWall</kbd> function, which handles the scenario where our AGV is up against a wall and has nowhere to move. After this, <kbd>DrawAGV</kbd> handles drawing our AGV within our map. Finally, <kbd>RefreshTerrain</kbd> does exactly what its name implies:</p>
<pre class="mce-root CDPAlignLeft CDPAlign">        private void GetMeasures()<br/>         {<br/>             // Getting AGV's position<br/>             pbTerrain.Image = CopyImage(OriginalMap);<br/>             Bitmap b = (Bitmap) pbTerrain.Image;<br/>             Point pPos = new Point(pbRobot.Left - pbTerrain.Left + 5, pbRobot.Top - pbTerrain.Top + 5);<br/> <br/>             // AGV on the wall<br/>             HandleAGVOnWall(b, pPos);<br/> <br/>             DrawAGV(pPos, b);<br/> <br/>             RefreshTerrain();<br/>         }</pre>
<p><kbd>DrawAGV</kbd> gets any obstacles in front of us, to the left and to the right. If you have the <span class="packt_screen">Show Beams</span> checkbox selected, you will see the front, left, and right beam avoidance detectors displayed:</p>
<pre class="mce-root CDPAlignLeft CDPAlign">private void DrawAGV(Point pPos, Bitmap b)<br/>         {<br/>             Point pFrontObstacle = GetObstacle(pPos, b, -1, 0);<br/>             Point pLeftObstacle = GetObstacle(pPos, b, 1, 90);<br/>             Point pRightObstacle = GetObstacle(pPos, b, 1, -90);<br/> <br/>             // Showing beams<br/>             Graphics g = Graphics.FromImage(b);<br/>             if (cbLasers.Checked)<br/>             {<br/>                 g.DrawLine(new Pen(Color.Red, 1), pFrontObstacle, pPos);<br/>                 g.DrawLine(new Pen(Color.Red, 1), pLeftObstacle, pPos);<br/>                 g.DrawLine(new Pen(Color.Red, 1), pRightObstacle, pPos);<br/>             }<br/> <br/>             // Drawing AGV<br/>             if (btnRun.Text != RunLabel)<br/>             {<br/>                 g.FillEllipse(new SolidBrush(Color.Blue), pPos.X - 5, pPos.Y - 5, 10, 10);<br/>             }<br/> <br/>             g.DrawImage(b, 0, 0);<br/>             g.Dispose();<br/> <br/>             // Updating distances texts<br/>             txtFront.Text = GetDistance(pPos, pFrontObstacle).ToString();<br/>             txtLeft.Text = GetDistance(pPos, pLeftObstacle).ToString();<br/>             txtRight.Text = GetDistance(pPos, pRightObstacle).ToString();<br/>         }</pre>
<p>The <kbd>DoInference</kbd> function runs one epoch (instance, generation, and so on) of our fuzzy inference system. Ultimately, it is responsible for determining the next angle of our AGV.</p>
<pre class="mce-root CDPAlignLeft CDPAlign"> private void DoInference()<br/>         {<br/>             // Setting inputs<br/>             IS?.SetInput("RightDistance", Convert.ToSingle(txtRight.Text));<br/>             IS?.SetInput("LeftDistance", Convert.ToSingle(txtLeft.Text));<br/>             IS?.SetInput("FrontalDistance", Convert.ToSingle(txtFront.Text));<br/> <br/>             // Setting outputs<br/>             try<br/>             {<br/>                 double NewAngle = IS.Evaluate("Angle");<br/>                 txtAngle.Text = NewAngle.ToString("##0.#0");<br/>                 Angle += NewAngle;<br/>             }<br/>             catch (Exception)<br/>             {<br/>             }<br/>         }</pre>
<p>The <kbd>MoveAGV</kbd> function is responsible for moving our AGV one step. Approximately 50% of the code in this function is dedicated to drawing the historical trajectory of your AGV if you have <span class="packt_screen">Track Path</span> checked:</p>
<pre class="mce-root CDPAlignLeft CDPAlign"> private void MoveAGV()<br/>         {<br/>             double rad = ((Angle + 90) * Math.PI) / 180;<br/>             int Offset = 0;<br/>             int Inc = -4;<br/> <br/>             Offset += Inc;<br/>             int IncX = Convert.ToInt32(Offset * Math.Cos(rad));<br/>             int IncY = Convert.ToInt32(Offset * Math.Sin(rad));<br/> <br/>             // Leaving the track<br/>             if (cbTrajeto.Checked)<br/>             {<br/>                 Graphics g = Graphics.FromImage(OriginalMap);<br/>                 Point p1 = new Point(pbRobot.Left - pbTerrain.Left + pbRobot.Width / 2, pbRobot.Top - pbTerrain.Top + pbRobot.Height / 2);<br/>                 Point p2 = new Point(p1.X + IncX, p1.Y + IncY);<br/>                 g.DrawLine(new Pen(new SolidBrush( Color.Green)), p1, p2);<br/>                 g.DrawImage(OriginalMap, 0, 0);<br/>                 g.Dispose();<br/>             }<br/> <br/>             pbRobot.Top = pbRobot.Top + IncY;<br/>             pbRobot.Left = pbRobot.Left + IncX;<br/>         }</pre>
<p>The main application with <span class="packt_screen">Show Beams</span> selected:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fb6a16c0-f7d0-44b8-bc20-4a7ceebe3f0d.png"/></div>
<div class="CDPAlignCenter CDPAlign"/>
<p>With our application running, the AGV is successfully navigating obstacles and both the path and the beams are displayed. <span class="packt_screen">Angle</span> is the angle that our AGV is currently facing, and the sensor readings relate to the front, left, and right beam sensors being displayed:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/87ac468b-2c87-4fe5-a07d-b945909592a1.png"/></div>
<div class="CDPAlignCenter CDPAlign"/>
<p>Our AGV is making a successful complete pass through the obstacle course and continuing on:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7d199b8f-9732-4772-8656-66974d25dfd1.png"/></div>
<div class="CDPAlignCenter CDPAlign"/>
<div class="CDPAlignCenter CDPAlign"/>
<p><span class="packt_screen">Track Path</span> and <span class="packt_screen">Show Beams</span> can be separately selected:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8de50b78-3434-4fc5-98ad-1ecb5f4fb606.png"/></div>
<p>This shows how, using the left and right mouse buttons, we can add obstacles and gateways to obstruct and allow the AGV to pass through, respectively:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/9f480da2-fa75-4d2c-b1e5-8725c66c4193.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter we learned about various types of fuzzy logic implementation and saw exactly how easy it was to add this logic to our application using AForge.NET. In our next chapter, we will embark on a journey deep into self-organizing maps, taking our machine learning repertoire to the next level. If you remember your art classes from elementary school, this chapter is sure to bring back memories!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">References</h1>
                </header>
            
            <article>
                
<p>AForge.NET: Copyright © AForge.NET, 2006-2013</p>


            </article>

            
        </section>
    </body></html>