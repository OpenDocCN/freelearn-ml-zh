- en: '18'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regression with Copilot Chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The stock of a corporation signifies ownership in the corporation. A single
    share of the stock represents a claim on the fractional assets and the earnings
    of the corporation in proportion to the total number of shares. For example, if
    an investor owns 50 shares of stock in a company that has, in total, 1,000 shares,
    then that investor (or shareholder) would own and have a claim on 5% of the company’s
    assets and earnings.
  prefs: []
  type: TYPE_NORMAL
- en: The stocks of a company can be traded between shareholders and other parties
    via stock exchanges and organizations. Major stock exchanges include the New York
    Stock Exchange, NASDAQ, the London Stock Exchange Group, the Shanghai Stock Exchange,
    and the Hong Kong Stock Exchange. The prices that a stock is traded at fluctuate
    essentially due to the law of supply and demand. At any one moment, the supply
    is the number of shares that are in the hands of public investors, the demand
    is the number of shares investors want to buy, and the price of the stock moves
    up and down to attain and maintain equilibrium.
  prefs: []
  type: TYPE_NORMAL
- en: 'Investors generally want to buy low and sell high. This seems straightforward
    enough but putting it into practice is exceedingly tough because it is incredibly
    difficult to predict whether a stock price will increase or decrease. Fundamental
    analysis and technical analysis are the two main research areas that aim to comprehend
    the reasons and circumstances that influence price fluctuations or even forecast
    future stock prices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fundamental analysis**: This stream focuses on the fundamental elements that
    affect a company’s value and operations, such as the macroeconomic environment,
    the state of the industry, and the company’s management and competitors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical analysis**: On the other hand, this uses statistical analysis of
    historical trading activity, such as price movement, volume, and time, to forecast
    future price movements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will explore the second technique using the Apple dataset
    to predict stock prices and help investors decide whether to buy or not.
  prefs: []
  type: TYPE_NORMAL
- en: Regression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start by asking Copilot Chat for the definition of regression:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: What is regression?
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Regression is a statistical method used in data analysis which investigates
    the relationship between a dependent (target) and independent variable(s) (predictor).
    This method is mostly used for forecasting, time series modeling, and finding
    the causal effect relationship between the variables. For example, the relationship
    between rainfall and soil erosion or the relationship between salary and years
    of experience.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: You may notice in your chatbox that GitHub Copilot is suggesting the next context,
    highlighted in blue, asking, “**What are the different types of regression?**”.
    You can click on this to get the answer. This demonstrates how Copilot is a powerful
    tool that assists users effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Dataset overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This dataset contains Apple’s (AAPL) stock data spanning 10 years. Insights
    from this data can be used to build useful price forecasting algorithms to aid
    investment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make the following notes about this dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: Data is collected and aggregated from 25 exchanges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is updated weekly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This dataset contains 1-minute, 5-minute, 30-minute, and 1-hour bars (open/high/low/close/volume)
    for AAPL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out-of-hours trades are included. Prices are adjusted for splits and dividends.
    Dataset available at [https://www.kaggle.com/datasets/tarunpaparaju/apple-aapl-historical-stock-data](https://www.kaggle.com/datasets/tarunpaparaju/apple-aapl-historical-stock-data).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore the dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To better illustrate this regression approach, it is necessary to have suitable
    predictors for our target. The dataset recorded more direct elements to the stock.
    Five values illustrating movements in the price over one unit of time (usually
    one day, but it can also be one week or one month) are key trading indicators.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open**: The starting price for a given trading day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Close**: The final price on that day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High**: The highest prices at which the stock traded on that day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low**: The lowest prices at which the stock traded on that day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volume**: The total number of shares traded before the market closed on that
    day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompt strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the TAG (Task-Action-Guidance) prompt pattern.
    Here’s how we can help frame our project to help us author our initial prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task**: Regression analysis on Apple stock value through history'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Action**: We will need to instruct the AI assistant to tell us what steps
    to take'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Guidance**: The guidance should be us describing the dataset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your initial prompt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like with other chapters in this book, we start with a prompt providing
    as much context as possible about what we want to do and the shape of the dataset.
    The idea is that we set a high-level context for our AI tool, which helps guide
    it throughout the rest of our prompts.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m performing a regression project to forecast stock prices using the Apple
    Historical Stock dataset. This will aid investors in making informed decisions
    about buying or not buying stocks. The workflow includes loading the dataset,
    exploring its contents, splitting the dataset, building a regression model, and
    evaluating its performance. But remember I want to learn it step by step. Let’s
    start with loading the dataset. I am storing the dataset in `<file path>`. Here’s
    the shape of the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open**: The starting price for a given trading day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Close**: The final price on that day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High**: The highest prices at which the stock traded on that day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low**: The lowest prices at which the stock traded on that day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volume**: The total number of shares traded before the market closed on that
    day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Sure, let’s start by loading the dataset. We’ll use the pandas library in Python
    to do this. Replace `<file-path>` with the path where your file is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the Python code to load the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After running this code, you should see the first few rows of your dataset printed
    out. This will give you a preliminary view of your data.
  prefs: []
  type: TYPE_NORMAL
- en: For the next steps, you might want to explore the dataset, clean the data if
    necessary, split the dataset into a training set and a test set, build a regression
    model using the training set, and then evaluate the model’s performance using
    the test set.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try the output generated by Copilot and see if it works. Modify the `file_path`
    variable to point to the location of your dataset and then execute the code below
    in a code cell in a notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output you should see after running the code above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will focus on historical prices (the five recorded values) and performance
    to predict future prices. Let’s start by checking the data types.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Check the data types.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the data types of the columns in your `DataFrame`, you can use the
    `dtypes` attribute. Here’s how you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will print out the name of each column along with its data type. This is
    useful to know because certain operations can only be performed on certain types
    of data. For example, you can’t perform numerical operations on a string.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try this and see if it works. Run the code `print(df.types)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, use the above output to query our AI tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is the output, Date object Close/Last object Volume int64 Open object
    High object Low object dtype: object'
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: It appears that the ‘Date’ column and the price columns (‘Close/Last’, ‘Open’,
    ‘High’, ‘Low’) are being read as ‘object’ type, which is essentially a string
    in pandas. However, for your analysis, you would want ‘Date’ to be in a datetime
    format and the price columns to be of a float type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you can convert the data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code first converts the ‘Date’ column to datetime format using `pd.to_datetime()`.
    Then it loops over each price column, removes the dollar sign from each value,
    and converts the column to float type. Finally, it prints out the data types of
    the columns again to confirm the changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try these suggestions above to convert our columns by running the below
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output, which is the columns correctly converted
    to suitable types instead of being strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s tell Copilot about the result to ensure it tells us what to do next.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is the output, Date datetime64[ns] Close/Last float64 Volume int64 Open
    float64 High float64 Low float64 dtype: object'
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now your ‘Date’ column is of type ‘datetime64[ns]’ and your price columns
    (‘Close/Last’, ‘Open’, ‘High’, ‘Low’) are of type ‘float64’. This means you can
    now perform numerical operations on your price columns and time series analysis
    on your ‘Date’ column.
  prefs: []
  type: TYPE_NORMAL
- en: The next steps could be to perform exploratory data analysis, such as checking
    for missing values, visualizing the distribution of your variables, or examining
    the correlation between different variables. You might also want to split your
    data into a training set and a test set in preparation for building your regression
    model.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Exploratory data analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Guided by the output on what to do next, we decide to check the missing values
    in our dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Check missing values.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check for missing values in your `DataFrame`, you can use the `isnull()`
    function along with the `sum()` function in pandas. Here’s how you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will print out the number of missing values in each column of your `DataFrame`.
    If a column has zero missing values, that means there are no missing values in
    that column. If a column has a number greater than zero, that’s the number of
    missing values in that column.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The response from Copilot says to check for null values and provides code for
    how to do so. Let’s run the suggested code in a code cell in a Notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With this output, provide it to Copilot to see what to do next:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is the output, Date 0 Close/Last 0 Volume 0 Open 0 High 0 Low 0 dtype:
    int64'
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Great! The output indicates that there are no missing values in your dataset.
    Each column has 0 missing values. This is good news because it means you don’t
    have to handle missing data, which can be a complex process.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in your analysis could be to perform some exploratory data analysis
    (EDA). This might include visualizing your data, checking for outliers, or examining
    the relationships between variables. After that, you can proceed to split your
    data into a training set and a test set, and then build your regression model.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Great, we had no missing values and it seems like the next steps should be visual
    analysis and checking for outliers. With that knowledge, let’s craft an appropriate
    prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Visualize data and check for outliers.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visualizing the data can be done using various libraries in Python, such as
    Matplotlib or Seaborn. For checking outliers, boxplots can be very useful. Here’s
    how you can create boxplots for your price columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code will create a 2x2 grid of plots, with each plot being a boxplot of
    one of your price columns. Boxplots are useful for visualizing the distribution
    of data and identifying potential outliers. In a boxplot, an outlier is typically
    represented as a point that is located outside the whiskers of the boxplot.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code above suggests using the matplotlib and seaborn libraries and also
    contains code to create a boxplot visualization; let’s run said code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see results similar to the following boxplots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A group of blue and black boxes  Description automatically generated](img/B21232_18_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.1: Boxplots of our dataset'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to learn more about our variables and their relationship.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Examine the relationships between variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: To examine the relationships between variables, you can use a correlation matrix
    and a heatmap. The correlation matrix will give you numerical values that represent
    how closely related two variables are, while the heatmap will give you a visual
    representation of these relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code first calculates the correlation matrix using the `corr()` function,
    which returns a `DataFrame` where each cell represents the correlation coefficient
    between two variables. Then it plots a heatmap using this correlation matrix.
    The `annot=True` argument allows the correlation coefficients to be plotted on
    the heatmap, and the `cmap='coolwarm'` argument sets the color scheme of the heatmap.
  prefs: []
  type: TYPE_NORMAL
- en: The correlation coefficient ranges from -1 to 1\. A value close to 1 implies
    a high positive correlation while a value close to -1 implies a high negative
    correlation. A value close to 0 implies no correlation.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The response says we should create a correlation matrix and visualize it via
    a heatmap. Let’s try the suggested code above and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output from the code above:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a graph  Description automatically generated](img/B21232_18_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.2: Heatmap'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the heatmap, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: The diagonal is always 1 because it shows the correlation of each variable with
    itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Close/Last, Open, High, and Low have a high positive correlation with each other
    (0.92), indicating that as one of these variables increases, the others tend to
    also increase. This is typical for stock data, as these prices move closely together
    throughout the trading day.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volume shows a negative correlation with Close/Last, Open, High, and Low (-0.61).
    This suggests that on days when the volume of shares traded is higher, the prices
    may tend to be lower, or vice versa.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As shown in the screenshot below, Copilot recommends the next step following
    the analysis of variable relationships. We will choose this and see what it says.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s ask Copilot what to do next.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the next step after examining the relationships between variables?
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step after examining the relationships between variables is typically
    to prepare your data for modeling. This can involve several sub-steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature Selection**: Based on your correlation analysis, you might decide
    to drop some features that are not correlated with your target variable, or to
    avoid multicollinearity, drop one of two features that are highly correlated with
    each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Splitting**: You’ll need to split your data into a training set and
    a test set. A common split is 80% of the data for training and 20% for testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Scaling**: Depending on the model you plan to use, you might need to
    scale your data so that all features have a similar range of values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once your data is prepared, you can proceed to build your regression model.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Data splitting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, let’s prepare for the creation of the model. Before we can create
    the model, we need to split up our data into training data and test sets to verify
    the model later.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the step of splitting the data.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Absolutely, splitting the data into a training set and a test set is a crucial
    step in preparing your data for modeling. We’ll use the `train_test_split` function
    from `sklearn.model_selection` to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we are going to predict the ‘Close/Last’ price, here’s how you
    can split your data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This code first defines the feature variables X and the target variable y. Then
    it splits these into a training set and a test set, with 80% of the data going
    to the training set and 20% going to the test set. The `random_state` parameter
    is used for reproducibility - using the same `random_state` will ensure that you
    get the same train/test split every time you run the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, the code above shows us how to split up our dataset; let’s try this
    code next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we don’t have an output to show as we assigned the results to
    variables. Let’s, however, print that next.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Print the shape of samples.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the shape of your training and test samples, you can use the shape
    attribute. Here’s how you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will print out the number of rows and columns in your training set and
    test set. The number of rows should be the same between `X_train` and `y_train`,
    and between `X_test` and `y_test`. The number of columns in `X_train` and `X_test`
    should be the same, and `y_train` and `y_test` should each have just one column
    (since they represent the target variable).
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The suggested code is straightforward, as it consists of a set of print statements.
    Let’s try said code by running it in a code cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output similar to the below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Build a regression model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve split up the data, let’s train the model next, or at least that’s
    what we expect Copilot to say if we ask it for the next step. Let’s create a prompt
    asking just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the next step after splitting the data?
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: After splitting the data, the next step is to create and train your regression
    model using the training data. Depending on the nature of your data and the problem
    you’re trying to solve, you might choose a simple linear regression model, or
    a more complex model like polynomial regression or ridge regression.
  prefs: []
  type: TYPE_NORMAL
- en: Once the model is trained, you can use it to make predictions on the test data.
    Then, you evaluate the performance of the model by comparing these predictions
    to the actual values in the test data. Common metrics for evaluating regression
    models include Mean Absolute Error (MAE), Mean Squared Error (MSE), and R-squared.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, just as we thought, the next step is to train the model. Let’s create
    a prompt asking for more detailed information on how to train the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Create and train a regression model.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Sure, let’s create and train a simple Linear Regression model using the training
    data. We’ll use the `LinearRegression` class from `sklearn.linear_model` to do
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you can create and train your model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This code first creates a Linear Regression model. Then it trains the model
    using the fit method and the training data. After this step, your model is ready
    to make predictions on unseen data.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that if your data has a non-linear relationship, you might need
    to use a more complex model like Polynomial Regression or a tree-based model.
    Also, if your features are not on the same scale, you might need to scale your
    data before training the model.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve received a response on using linear regression and the sklearn library.
    Note that you might need to install said library before proceeding. Once you’ve
    ensured sklearn is installed, proceed to run the suggested code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output from running the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We’re clearly getting an error back, so let’s see if Copilot can help with this
    error. As usual, include context like the error text to get a good response.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: I am getting this error after running the code,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: The error message suggests that the model is having trouble handling the ‘Date’
    column because it’s in datetime format, and the model expects numerical input.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common approach to deal with datetime data is to extract features from
    it, such as the year, month, day, etc. Here’s how you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code first extracts the year, month, and day from the ‘Date’ column and
    adds them as new columns in the DataFrame. Then it drops the original ‘Date’ column.
    Finally, it tries to fit the model again.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this is a simple approach and might not be the best way to
    handle datetime data for your specific problem. The best approach depends on the
    nature of your data and the problem you’re trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: So, our `Date` column was the problem. The model training can only handle numerical
    data. It seems the response suggested we should extract features from the `Date`
    column though, like year, month, and day, to preserve the info, but in numerical
    form. Additionally, we should then drop the `Date` column as we got what we wanted
    from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try running the suggested code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You should now see your code running without any issues. Let’s tell Copilot
    about this fact and see if it suggests how we can proceed.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks, that works.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: You’re welcome! I’m glad to hear that it worked. Now that your model is trained,
    the next step is usually to use the model to make predictions on your test data.
    After that, you can evaluate the performance of your model by comparing these
    predictions to the actual values in your test data. If you have any more questions
    or need further assistance, feel free to ask.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As suggested by the response, Copilot recommends asking the following: What
    are some common metrics for evaluating regression models? Let’s select this and
    see what it says.'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s ask Copilot about evaluation metrics.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: What are some common metrics for evaluating regression models?
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several common metrics for evaluating the performance of regression
    models:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mean Absolute Error (MAE)**: This is the average of the absolute differences
    between the predicted and actual values. It gives an idea of how wrong the predictions
    were.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mean Squared Error (MSE)**: This is the average of the squared differences
    between the predicted and actual values. Squaring the differences amplifies the
    impact of large errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Root Mean Squared Error (RMSE)**: This is the square root of the MSE. It
    has the same units as the output variable, making it easier to interpret than
    the MSE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**R-squared (R²)**: This is the proportion of the variance in the dependent
    variable that is predictable from the independent variables. It provides a measure
    of how well the model’s predictions fit the actual data. A value of 1 means the
    model perfectly predicts the actual values, while a value of 0 means the model
    does not predict the actual values at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adjusted R-squared**: This is a modified version of R-squared that has been
    adjusted for the number of predictors in the model. It increases only if the new
    term improves the model more than would be expected by chance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these metrics has its own strengths and weaknesses, and the choice of
    which to use depends on the specific problem and the goals of the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to evaluate and with what metrics, let’s make predictions
    next given our testing data, and see what we get in response.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Make predictions and evaluate the model using different metrics.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Sure, let’s use the trained model to make predictions on the test data. Then,
    we’ll evaluate these predictions using Mean Absolute Error (MAE), Mean Squared
    Error (MSE), Root Mean Squared Error (RMSE), and R-squared (R^²). We’ll use the
    metrics module from sklearn to calculate these metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code first uses the model to make predictions on the test data. Then it
    calculates the MAE, MSE, RMSE, and R^² by comparing these predictions to the actual
    values in the test data. Finally, it prints out these metrics.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: The code contains both metrics and calls a `predict()` function that produces
    a response from the model; let’s try this and see if it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response similar to the one below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Let’s provide Copilot with the response below to learn what we should do next.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Great! The output shows the calculated metrics for your regression model.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mean Absolute Error (MAE)**: The average absolute difference between the
    predicted and actual values is approximately 0.46\. This means that on average,
    your predictions are about 0.46 units away from the actual values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mean Squared Error (MSE)**: The average squared difference between the predicted
    and actual values is approximately 0.42\. This metric is more sensitive to large
    errors than MAE because it squares the differences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Root Mean Squared Error (RMSE)**: The square root of the MSE is approximately
    0.65\. This metric is in the same units as the output variable, making it easier
    to interpret than the MSE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**R-squared (R²)**: The proportion of the variance in the dependent variable
    that is predictable from the independent variables is approximately 0.9999\. This
    is very close to 1, which indicates that your model explains almost all of the
    variability of the response data around its mean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, these metrics suggest that your model is performing very well on the
    test data.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to have a sense of how well the model is performing by comparing
    predicted values to actual values, so let’s create a prompt to reflect that request.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Display a comparison of predicted values versus actual values.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should receive a response similar to the response below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sure, you can compare the predicted values with the actual values by visualizing
    them in a plot. Here’s how you can do it using matplotlib:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a scatter plot where the x-axis represents the index of the
    test set and the y-axis represents the target variable. The actual values are
    plotted in blue and the predicted values are plotted in red. This allows you to
    visually compare the predictions made by the model to the actual values.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The suggested code seems to want to create a scatter plot to better compare
    our predicted values compared to our test data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output from running the above code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with red dots  Description automatically generated](img/B21232_18_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.3: Actual versus predicted data'
  prefs: []
  type: TYPE_NORMAL
- en: We can see how the predicted data matches the actual data quite well. Let’s
    try to sum up our learning next.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of using regression to predict a value, let’s take the same data but
    treat it as a classification problem and predict whether the stock price will
    go up or down the next day.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regression is a fundamental concept in machine learning used to predict a continuous
    outcome variable based on one or more predictor variables. It involves identifying
    the relationship between a dependent variable (often called the target) and one
    or more independent variables (features). We saw that, given our dataset, we were
    able to find correlations for certain variables. We also found that we could include
    columns like Date, but to include these, we needed to extract the important numerical
    parts from those columns, namely the year, month, and date.
  prefs: []
  type: TYPE_NORMAL
- en: Regression has many applications in other sectors, like healthcare and marketing.
    From a prompt perspective, it’s a good idea to set the context early on and show
    Copilot the shape of the data, which will then help you ask Copilot what to do
    next.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use the same dataset while using GitHub Copilot
    to help us write some code.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/aicode](https://packt.link/aicode)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code510410532445718281.png)'
  prefs: []
  type: TYPE_IMG
