<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;Traffic Stops and Crash Locations &#x2013; When Two Datasets Are Better Than One"><div class="book" id="1AT9A2-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Traffic Stops and Crash Locations – When Two Datasets Are Better Than One</h1></div></div></div><p class="calibre6">If you remember from <a class="calibre1" title="Chapter 4. Traffic Stops – Barking Up the Wrong Tree?" href="part0032_split_000.html#UGI01-a18db0be6c20485ba81f22e43ca13055">Chapter 4</a>, <span class="strong"><em class="calibre11">Traffic Stops – Barking Up the Wrong Tree?</em></span>, we used a decision tree to help us determine if a person received a ticket or a warning based on several seasonality factors like time of day, day of the week, and the like. Ultimately, we could not find a relationship. Your first inclination might be to throw out the dataset, which I think is a mistake because there might be data gold in them thar hills, but we are just using the wrong model. Also, if a single dataset is not profitable, I typically start augmenting that set with others to see if the combination of features will provide a more satisfactory answer. In this chapter, let's go back to our Code-4-Good group and see if we can both augment the traffic stop dataset and apply some different models that will help us formulate interesting questions and answers. Perhaps even if we are not asking the right questions, the computer can help us ask the right questions too.</p></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Traffic Stops and Crash Locations &#x2013; When Two Datasets Are Better Than One">
<div class="book" title="Unsupervised learning"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec38" class="calibre1"/>Unsupervised learning</h1></div></div></div><p class="calibre6">To this point in the book, we<a id="id339" class="calibre1"/> have used several different models to answer our questions: linear regression, logistic regression, and kNN to name a few. Although different in their methodology, they share a common thread; we told the computer the answer (called the dependent or <span class="strong"><em class="calibre11">y</em></span> variable) and then provided a series of features (called independent or <span class="strong"><em class="calibre11">x</em></span> variables) that can be associated with that answer. Consider the following diagram for example:</p><div class="mediaobject"><img src="../images/00085.jpeg" alt="Unsupervised learning" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">We then presented the computer with some combination of independent variables that it had not seen before <a id="id340" class="calibre1"/>and asked it to guess the answer:</p><div class="mediaobject"><img src="../images/00086.jpeg" alt="Unsupervised learning" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">We then compared to the known answers via the test and, if it did a good job guessing, we would use the model in production:</p><div class="mediaobject"><img src="../images/00087.jpeg" alt="Unsupervised learning" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">This methodology of<a id="id341" class="calibre1"/> telling the computer the answer ahead of time is called <a id="id342" class="calibre1"/>
<span class="strong"><em class="calibre11">supervised learning</em></span>. The term <span class="strong"><em class="calibre11">supervised</em></span> is used because we provide the computer an answer explicitly and then tell it which model to use.</p><p class="calibre6">There is another class of models that do not provide the answer to the computer. This class is called <span class="strong"><em class="calibre11">unsupervised learning</em></span>. If your mental model of <span class="strong"><em class="calibre11">unsupervised learning</em></span> is the chaos that engulfs a sixth grade class when a substitute teacher shows up the day before summer vacation, you are not far off. Okay, maybe not <span class="strong"><em class="calibre11">that</em></span> bad. With unsupervised learning, we hand the computer a data frame of only attributes and ask it to tell us about the data. With that information, we can then narrow down the data that might help us make insightful business decisions. For example, let's say you send this data frame to the computer:</p><div class="mediaobject"><img src="../images/00088.jpeg" alt="Unsupervised learning" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">It might tell you that the data seems to cluster in two areas:</p><div class="mediaobject"><img src="../images/00089.jpeg" alt="Unsupervised learning" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Although you might have eye-balled this relationship on this simple 2D data frame, the task becomes much<a id="id343" class="calibre1"/> harder, if not impossible, when adding more rows and features. In this chapter, we are going to use the k-means model to do this kind of clustering.</p><p class="calibre6">Also, we can use the computer to tell us what features are useful in a data frame and what features are just noise. For example, consider this dataset:</p><div class="informalexample"><table border="1" class="calibre19"><colgroup class="calibre20"><col class="calibre21"/><col class="calibre21"/><col class="calibre21"/></colgroup><thead class="calibre22"><tr class="calibre23"><th valign="bottom" class="calibre24">
<p class="calibre25">Hours Of Studying</p>
</th><th valign="bottom" class="calibre24">
<p class="calibre25">Number Of Beers</p>
</th><th valign="bottom" class="calibre24">
<p class="calibre25">StudyLocation</p>
</th></tr></thead><tbody class="calibre26"><tr class="calibre23"><td valign="top" class="calibre27">
<p class="calibre25">2</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">4</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">Dorm</p>
</td></tr><tr class="calibre23"><td valign="top" class="calibre27">
<p class="calibre25">1</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">5</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">Dorm</p>
</td></tr><tr class="calibre23"><td valign="top" class="calibre27">
<p class="calibre25">6</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">0</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">Dorm</p>
</td></tr><tr class="calibre23"><td valign="top" class="calibre27">
<p class="calibre25">5</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">1</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">Dorm</p>
</td></tr><tr class="calibre23"><td valign="top" class="calibre27">
<p class="calibre25">2</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">8</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">Dorm</p>
</td></tr><tr class="calibre23"><td valign="top" class="calibre27">
<p class="calibre25">4</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">4</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">Dorm</p>
</td></tr></tbody></table></div><p class="calibre6">Will the inclusion of <span class="strong"><strong class="calibre7">StudyLocation</strong></span> in our data frame lead to any insights? The answer is no, because the values are all the same. In this <a id="id344" class="calibre1"/>chapter, we are going to use<a id="id345" class="calibre1"/> <span class="strong"><strong class="calibre7">Principle Component Analysis</strong></span> (<span class="strong"><strong class="calibre7">PCA</strong></span>) to this kind of feature filtering; it will tell us what features are important and what can be safely removed.</p></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Traffic Stops and Crash Locations &#x2013; When Two Datasets Are Better Than One">
<div class="book" title="Unsupervised learning">
<div class="book" title="k-means"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec59" class="calibre1"/>k-means</h2></div></div></div><p class="calibre6">As mentioned in the <a id="id346" class="calibre1"/>prior section, k-means is an unsupervised technique: observations are grouped based on mean of<a id="id347" class="calibre1"/> each cluster. Let's take a look at k-means in action. Open up Visual Studio and create a new Visual F# Windows Library Project. Rename the <code class="literal">Script.fsx</code> file to <code class="literal">kmeans.fsx</code>. Open up the <span class="strong"><strong class="calibre7">NuGet Package Manager</strong></span> console and enter the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">PM&gt; install-package Accord.MachineLearning</strong></span>
</pre></div><p class="calibre6">Next, go to the script and replace all of the contents with this:</p><div class="informalexample"><pre class="programlisting">#r "../packages/Accord.3.0.2/lib/net40/Accord.dll"
#r "../packages/Accord.Math.3.0.2/lib/net40/Accord.Math.dll"
#r "../packages/Accord.Statistics.3.0.2/lib/net40/Accord.Statistics.dll"
#r "../packages/Accord.MachineLearning.3.0.2/lib/net40/Accord.MachineLearning.dll"

open Accord.MachineLearning</pre></div><p class="calibre6">Next, let's create an array of different beverages that are served at our local restaurant:</p><div class="informalexample"><pre class="programlisting">let drinks = ["Boones Farm", 0;
                "Mad Dog", 1;
                "Night Train", 2;
                "Buckfast", 3;
                "Smirnoff", 4;
                "Bacardi", 5;
                "Johhnie Walker", 6;
                "Snow", 7;
                "Tsingtao", 8;
                "Budweiser", 9;
                "Skol", 10;
                "Yanjing", 11;
                "Heineken", 12;
                "Harbin", 13]</pre></div><p class="calibre6">Sending this to the FSI, you will see the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val drinks : (string * int) list =</strong></span>
<span class="strong"><strong class="calibre7">  [("Boones Farm", 0); ("Mad Dog", 1); ("Night Train", 2); ("Buckfast", 3);</strong></span>
<span class="strong"><strong class="calibre7">   ("Smirnoff", 4); ("Bacardi", 5); ("Johhnie Walker", 6); ("Snow", 7);</strong></span>
<span class="strong"><strong class="calibre7">   ("Tsingtao", 8); ("Budweiser", 9); ("Skol", 10); ("Yanjing", 11);</strong></span>
<span class="strong"><strong class="calibre7">   ("Heineken", 12); ("Harbin", 13)]</strong></span>

<span class="strong"><strong class="calibre7">&gt;</strong></span>
</pre></div><p class="calibre6">Go back to the script and enter in some records of some patrons of the restaurant. We are using a float value <a id="id348" class="calibre1"/>because that is what Accord expects as an<a id="id349" class="calibre1"/> input.:</p><div class="informalexample"><pre class="programlisting">let observations = [|[|1.0;2.0;3.0|];[|1.0;1.0;0.0|];
                                             [|5.0;4.0;4.0|];[|4.0;4.0;5.0|];[|4.0;5.0;5.0|];[|6.0;4.0;5.0|];
                                             [|11.0;8.0;7.0|];[|12.0;8.0;9.0|];[|10.0;8.0;9.0|]|]</pre></div><p class="calibre6">Sending that to the REPL gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val observations : float [] [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|[|1.0; 2.0; 3.0|]; [|1.0; 1.0; 0.0|]; [|5.0; 4.0; 4.0|]; [|4.0; 4.0; 5.0|];</strong></span>
<span class="strong"><strong class="calibre7">    [|4.0; 5.0; 5.0|]; [|6.0; 4.0; 5.0|]; [|11.0; 8.0; 7.0|];</strong></span>
<span class="strong"><strong class="calibre7">    [|12.0; 8.0; 9.0|]; [|10.0; 8.0; 9.0|]|]</strong></span>
</pre></div><p class="calibre6">You will notice that there are nine different patrons and each had three drinks. Patron number 1 had a Boone's Farm, a Mad Dog, and a Night Train. With this data ready, let's run a k-means against it. Enter this into the script file:</p><div class="informalexample"><pre class="programlisting">let numberOfClusters = 3
let kmeans = new KMeans(numberOfClusters);
let labels = kmeans.Compute(observations)</pre></div><p class="calibre6">When you send this to the FSI, you will see the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val numberOfClusters : int = 3</strong></span>
<span class="strong"><strong class="calibre7">val kmeans : KMeans</strong></span>
<span class="strong"><strong class="calibre7">val labels : int [] = [|0; 0; 1; 1; 1; 1; 2; 2; 2|]</strong></span>
</pre></div><p class="calibre6">This output takes each patron and assigns them to one of the three clusters. For example, Patrons number 1 and 2 are in cluster number 0. If we wanted more observations in each cluster, we could change the <code class="literal">numberOfClusters</code> like this:</p><div class="informalexample"><pre class="programlisting">let numberOfClusters = 2
let kmeans = new KMeans(numberOfClusters);
let labels = kmeans.Compute(observations)</pre></div><p class="calibre6">And sending that to the FSI would give the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val numberOfClusters : int = 2</strong></span>
<span class="strong"><strong class="calibre7">val kmeans : KMeans</strong></span>
<span class="strong"><strong class="calibre7">val labels : int [] = [|1; 1; 1; 1; 1; 1; 0; 0; 0|]</strong></span>
</pre></div><p class="calibre6">Notice that the computer does not try to label or otherwise assign any value to each of the clusters. The data scientist would then need to assign a meaningful value, if one is possible. Go back to the script and change the <code class="literal">numberOfClusters</code> back to three and resend to the FSI. Looking<a id="id350" class="calibre1"/> at the input array, we can say that the cluster assigned <code class="literal">0</code> is for fortified wine drinkers, cluster <code class="literal">1</code> is for hard liquor drinkers, and cluster <code class="literal">2</code> is for beer drinkers. However, sometimes you may not be able to tell what each cluster means by eye-balling the input <a id="id351" class="calibre1"/>array. In that case, you can ask Accord for some (limited) help. Enter this into the script file:</p><div class="informalexample"><pre class="programlisting">kmeans.Clusters.[0]</pre></div><p class="calibre6">Sending this to the FSI will give the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val it : KMeansCluster =</strong></span>
<span class="strong"><strong class="calibre7">  Accord.MachineLearning.KMeansCluster</strong></span>
<span class="strong"><strong class="calibre7">    {Covariance = [[4.3; 2.6; 3.2]</strong></span>
<span class="strong"><strong class="calibre7">                   [2.6; 2.266666667; 2.733333333]</strong></span>
<span class="strong"><strong class="calibre7">                   [3.2; 2.733333333; 3.866666667]];</strong></span>
<span class="strong"><strong class="calibre7">     Index = 0;</strong></span>
<span class="strong"><strong class="calibre7">     Mean = [|3.5; 3.333333333; 3.666666667|];</strong></span>
<span class="strong"><strong class="calibre7">     Proportion = 0.6666666667;}</strong></span>
</pre></div><p class="calibre6">Notice the mean is mid-threes, which is a low number as we are counting from 0 to 13. We could say that category 0's label should be <span class="strong"><em class="calibre11">Buckfast</em></span>-like drinkers, which is generally correct.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Traffic Stops and Crash Locations &#x2013; When Two Datasets Are Better Than One">
<div class="book" title="Unsupervised learning">
<div class="book" title="Principle Component Analysis (PCA)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec60" class="calibre1"/>Principle Component Analysis (PCA)</h2></div></div></div><p class="calibre6">Another common task we can do with unsupervised learning is to help us throw out features that are not relevant. If you remember from the last chapter, we used a stepwise regression to<a id="id352" class="calibre1"/> determine the best features when building our model and then used Occum's Razor to toss insignificant features. One<a id="id353" class="calibre1"/> of the more common things you can do with PCA is use this unsupervised model as a way of picking the best<a id="id354" class="calibre1"/> features—the <span class="strong"><strong class="calibre7">principle components</strong></span> of the frame.</p><p class="calibre6">Add another script file to your project and name it <code class="literal">pca.fsx</code>. Add in the following code:</p><div class="informalexample"><pre class="programlisting">#r "../packages/Accord.3.0.2/lib/net40/Accord.dll"
#r "../packages/Accord.Math.3.0.2/lib/net40/Accord.Math.dll"
#r "../packages/Accord.Statistics.3.0.2/lib/net40/Accord.Statistics.dll"

open Accord.Statistics.Analysis


let sourceMatrix = [|[|2.5; 2.4|];[|0.5; 0.7|];[|2.2; 2.9|];
                    [|1.9; 2.2|];[|3.1; 3.0|];[|2.3; 2.7|];[|2.0; 1.6|];
                    [|1.0; 1.1|];[|1.5; 1.6|]; [|1.1; 0.9|]|] </pre></div><p class="calibre6">Sending this to the FSI gives the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val sourceMatrix : float [] [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|[|2.5; 2.4|]; [|0.5; 0.7|]; [|2.2; 2.9|]; [|1.9; 2.2|]; [|3.1; 3.0|];</strong></span>
<span class="strong"><strong class="calibre7">    [|2.3; 2.7|]; [|2.0; 1.6|]; [|1.0; 1.1|]; [|1.5; 1.6|]; [|1.1; 0.9|]|]</strong></span>
</pre></div><p class="calibre6">In this case, the <code class="literal">sourceMatix</code> is a list of students that studied for a certain number of hours for an exam<a id="id355" class="calibre1"/> and the number of beers that they consumed before the exam. For example, the first student studied 2.5 hours and drank 2.4 beers. Unlike similar examples you have seen in the book so far, you will notice that there is not a dependent variable (Y) in this frame. We don't know if these students passed or not. But with just these features, we can determine which <a id="id356" class="calibre1"/>ones would be the most useful for an analysis. You might be saying to yourself, "How is that possible?" Without going too much into the math, the PCA will look at the variance of each of the variables under a series of scenarios. If the variable can explain differences, it is given a higher score. If it cannot, it is given a lower one.</p><p class="calibre6">Let's see what PCA tells us about this dataset. Enter this code into the script:</p><div class="informalexample"><pre class="programlisting">let pca = new PrincipalComponentAnalysis(sourceMatrix, AnalysisMethod.Center)
pca.Compute()
pca.Transform(sourceMatrix)
pca.ComponentMatrix</pre></div><p class="calibre6">Sending this to the REPL, we will get the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val pca : PrincipalComponentAnalysis</strong></span>
<span class="strong"><strong class="calibre7">val it : float [,] = [[0.6778733985; -0.7351786555]</strong></span>
<span class="strong"><strong class="calibre7">                      [0.7351786555; 0.6778733985]]</strong></span>
</pre></div><p class="calibre6">You will notice that the output of the <code class="literal">ComponentMatrix</code> property is a 2 x 2 array with the complementary value as a cross. In formal terms, this jagged array is called an eigenvector and the contents of the array are called eigenvalues. If you start working deeply with PCA, you will need to come up to speed with what those words mean and the implications of the values. For our purposes here, we can safely ignore these values (unless you want to toss around the word, eigenvalue, at your next family gathering).</p><p class="calibre6">The important property that we do need to pay attention to with PCA is the component proportions. Go back to the script file and enter this:</p><div class="informalexample"><pre class="programlisting">pca.ComponentProportions</pre></div><p class="calibre6">Sending this to the REPL gives the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val it : float [] = [|0.9631813143; 0.03681868565|]</strong></span>
</pre></div><p class="calibre6">These values are<a id="id357" class="calibre1"/> important for our analysis. Notice how adding these two values together amounts to 100 percent? These percentages tell you the amount of variance (and therefore the amount of usefulness) in the data frame. In this case, the hours of studying is 96 percent of the variance with the amount of beer being only 4 percent, so if we wanted to use this data in some kind of analysis, we would certainly pick the hours of studying and safely<a id="id358" class="calibre1"/> discard the beer drinking. Note that if we increased the range of beers being drunk, the percentages would shift and perhaps we would want to use both variables. This is a fairly simple example with two features. PCA really shines when you have lots and lots of features and you need to determine their usefulness.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Traffic stop and crash exploration"><div class="book" id="1BRPS2-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec39" class="calibre1"/>Traffic stop and crash exploration</h1></div></div></div><p class="calibre6">With the k-means and PCA theory under our belts, let's see what we can do with open data. If you<a id="id359" class="calibre1"/> remember, we had a dataset for traffic stops. Let's bring in two more datasets: the number of car crashes over the same time period, and also the amount of precipitation on the day of the crash/ticket.</p></div>

<div class="book" title="Traffic stop and crash exploration">
<div class="book" title="Preparing the script and the data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec61" class="calibre1"/>Preparing the script and the data</h2></div></div></div><p class="calibre6">In Visual Studio, create<a id="id360" class="calibre1"/> a new Visual F# Library<a id="id361" class="calibre1"/> Project called <code class="literal">Hack4Good.Traffic</code>:</p><div class="mediaobject"><img src="../images/00090.jpeg" alt="Preparing the script and the data" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Once the project is<a id="id362" class="calibre1"/> created, rename the <code class="literal">Script.fsx</code> file to <code class="literal">Clustering.fsx</code>:</p><div class="mediaobject"><img src="../images/00091.jpeg" alt="Preparing the script and the data" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Next, open the <a id="id363" class="calibre1"/>NuGet Package Manager console and enter this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">PM&gt; install-package Accord.MachineLearning</strong></span>
</pre></div><p class="calibre6">Inside <code class="literal">Clustering.fsx</code>, enter in the following code into the script:</p><div class="informalexample"><pre class="programlisting">#r "System.Data.Entity.dll"
#r "FSharp.Data.TypeProviders.dll"
#r "System.Data.Linq.dll"
#r "../packages/Accord.3.0.2/lib/net40/Accord.dll"
#r "../packages/Accord.Math.3.0.2/lib/net40/Accord.Math.dll"
#r "../packages/Accord.Statistics.3.0.2/lib/net40/Accord.Statistics.dll"
#r "../packages/Accord.MachineLearning.3.0.2/lib/net40/Accord.MachineLearning.dll"

open System
open System.Linq
open System.Data.Linq
open System.Data.Entity
open Accord.MachineLearning
open System.Collections.Generic
open Accord.Statistics.Analysis
open Microsoft.FSharp.Data.TypeProviders

[&lt;Literal&gt;]
let connectionString = "data source=nc54a9m5kk.database.windows.net;initial catalog=Traffic;user id=chickenskills@nc54a9m5kk;password=sk1lzm@tter;"
type Geolocation = {Latitude: float; Longitude: float} 

type EntityConnection = SqlEntityConnection&lt;connectionString,Pluralize = true&gt;
let context = EntityConnection.GetDataContext()</pre></div><p class="calibre6">When<a id="id364" class="calibre1"/> you send this to the FSI, you will <a id="id365" class="calibre1"/>see the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val connectionString : string =</strong></span>
<span class="strong"><strong class="calibre7">  "data source=nc54a9m5kk.database.windows.net;initial catalog=T"+[61 chars]</strong></span>
<span class="strong"><strong class="calibre7">type Geolocation =</strong></span>
<span class="strong"><strong class="calibre7">  {Latitude: float;</strong></span>
<span class="strong"><strong class="calibre7">   Longitude: float;}</strong></span>
<span class="strong"><strong class="calibre7">type EntityConnection =</strong></span>
<span class="strong"><strong class="calibre7">  class</strong></span>
<span class="strong"><strong class="calibre7">    static member GetDataContext : unit -&gt; EntityConnection.ServiceTypes.SimpleDataContextTypes.EntityContainer</strong></span>
<span class="strong"><strong class="calibre7">     + 1 overload</strong></span>
<span class="strong"><strong class="calibre7">    nested type ServiceTypes</strong></span>
<span class="strong"><strong class="calibre7">  end</strong></span>
<span class="strong"><strong class="calibre7">val context :</strong></span>
<span class="strong"><strong class="calibre7">  EntityConnection.ServiceTypes.SimpleDataContextTypes.EntityContainer</strong></span>
</pre></div><p class="calibre6">With this prep code out of the way, let's bring down the stop data from the database. Put the following code into the script file:</p><div class="informalexample"><pre class="programlisting">//Stop Data
type TrafficStop = {StopDateTime: DateTime; Geolocation: Geolocation; DispositionId: int}
let trafficStops = 
    context.dbo_TrafficStops 
    |&gt; Seq.map(fun ts -&gt; {StopDateTime = ts.StopDateTime.Value; 
                          Geolocation = {Latitude = Math.Round(ts.Latitude.Value,3); 
                          Longitude = Math.Round(ts.Longitude.Value,3)}; 
                          DispositionId = ts.DispositionId.Value})
    |&gt; Seq.toArray</pre></div><p class="calibre6">When you send it to<a id="id366" class="calibre1"/> the REPL, you will see the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">type TrafficStop =</strong></span>
<span class="strong"><strong class="calibre7">  {StopDateTime: DateTime;</strong></span>
<span class="strong"><strong class="calibre7">   Geolocation: Geolocation;</strong></span>
<span class="strong"><strong class="calibre7">   DispositionId: int;}</strong></span>
<span class="strong"><strong class="calibre7">val trafficStops : TrafficStop [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|{StopDateTime = 6/30/2012 12:36:38 AM;</strong></span>
<span class="strong"><strong class="calibre7">     Geolocation = {Latitude = 35.789;</strong></span>
<span class="strong"><strong class="calibre7">                    Longitude = -78.829;};</strong></span>
<span class="strong"><strong class="calibre7">     DispositionId = 7;}; {StopDateTime = 6/30/2012 12:48:38 AM;</strong></span>
<span class="strong"><strong class="calibre7">                           Geolocation = {Latitude = 35.821;</strong></span>
<span class="strong"><strong class="calibre7">                                          Longitude = -78.901;};</strong></span>
<span class="strong"><strong class="calibre7">                           DispositionId = 15;};</strong></span>
<span class="strong"><strong class="calibre7">    {StopDateTime = 6/30/2012 1:14:29 AM;</strong></span>
<span class="strong"><strong class="calibre7">     Geolocation = {Latitude = 35.766;</strong></span>
</pre></div><p class="calibre6">All of this data should be familiar to you from <a class="calibre1" title="Chapter 4. Traffic Stops – Barking Up the Wrong Tree?" href="part0032_split_000.html#UGI01-a18db0be6c20485ba81f22e43ca13055">Chapter 4</a>, <span class="strong"><em class="calibre11">Traffic Stops – Barking Up the Wrong Tree?</em></span>. The only<a id="id367" class="calibre1"/> real difference is that there is now a geolocation type that holds both latitude and longitude. Notice that we assign whatever values are in the database first in this line:</p><div class="informalexample"><pre class="programlisting">    |&gt; Seq.map(fun ts -&gt; {StopDateTime = ts.StopDateTime.Value; 
                          Geolocation = {Latitude = Math.Round(ts.Latitude.Value,3); 
                          Longitude = Math.Round(ts.Longitude.Value,3)}; 
                          DispositionId = ts.DispositionId.Value})</pre></div><p class="calibre6">Also, you will notice that <a id="id368" class="calibre1"/>we are making the values to three decimal point precision with the <code class="literal">Math.Round</code>. With this data local, let's bring in the crash <a id="id369" class="calibre1"/>data. Enter the following code into the script:</p><div class="informalexample"><pre class="programlisting">//Crash Data
type TrafficCrash = {CrashDateTime: DateTime;  Geolocation: Geolocation; CrashSeverityId: int; CrashTypeId: int; }
let trafficCrashes= 
    context.dbo_TrafficCrashes 
    |&gt; Seq.filter(fun tc -&gt; tc.MunicipalityId = Nullable&lt;int&gt;(13))
    |&gt; Seq.filter(fun tc -&gt; not (tc.Latitude = Nullable&lt;float&gt;()))
    |&gt; Seq.map(fun tc -&gt; {CrashDateTime=tc.CrashDateTime.Value; 
                          Geolocation = {Latitude =Math.Round(tc.Latitude.Value,3); 
                        Longitude=Math.Round(tc.Longitude.Value,3)};
                        CrashSeverityId=tc.CrashSeverityId.Value; 
                        CrashTypeId =tc.CrashTypeId.Value})
    |&gt; Seq.toArray</pre></div><p class="calibre6">Sending this to the FSI gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">type TrafficCrash =</strong></span>
<span class="strong"><strong class="calibre7">  {CrashDateTime: DateTime;</strong></span>
<span class="strong"><strong class="calibre7">   Geolocation: Geolocation;</strong></span>
<span class="strong"><strong class="calibre7">   CrashSeverityId: int;</strong></span>
<span class="strong"><strong class="calibre7">   CrashTypeId: int;}</strong></span>
<span class="strong"><strong class="calibre7">val trafficCrashes : TrafficCrash [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|{CrashDateTime = 12/30/2011 1:00:00 AM;</strong></span>
<span class="strong"><strong class="calibre7">     Geolocation = {Latitude = 35.79;</strong></span>
<span class="strong"><strong class="calibre7">                    Longitude = -78.781;};</strong></span>
<span class="strong"><strong class="calibre7">     CrashSeverityId = 4;</strong></span>
<span class="strong"><strong class="calibre7">     CrashTypeId = 3;}; {CrashDateTime = 12/30/2011 3:12:00 AM;</strong></span>
<span class="strong"><strong class="calibre7">                         Geolocation = {Latitude = 35.783;</strong></span>
<span class="strong"><strong class="calibre7">                                        Longitude = -78.781;};</strong></span>
<span class="strong"><strong class="calibre7">                         CrashSeverityId = 3;</strong></span>
<span class="strong"><strong class="calibre7">                         CrashTypeId = 24;};</strong></span>
</pre></div><p class="calibre6">We have one more dataset we want to use: the traffic conditions for each day. Enter the following into the script:</p><div class="informalexample"><pre class="programlisting">//Weather Data
type DailyPercipitation = {WeatherDate: DateTime; Amount: int; }
let dailyWeather = 
    context.dbo_DailyPercipitation 
    |&gt; Seq.map(fun dw -&gt; {WeatherDate=dw.RecordDate; Amount=dw.Amount;})
    |&gt; Seq.toArray</pre></div><p class="calibre6">Sending this to<a id="id370" class="calibre1"/> the FSI gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">type DailyPercipitation =</strong></span>
<span class="strong"><strong class="calibre7">  {WeatherDate: DateTime;</strong></span>
<span class="strong"><strong class="calibre7">   Amount: int;}</strong></span>
<span class="strong"><strong class="calibre7">val dailyWeather : DailyPercipitation [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|{WeatherDate = 1/9/2012 12:00:00 AM;</strong></span>
<span class="strong"><strong class="calibre7">     Amount = 41;}; {WeatherDate = 1/10/2012 12:00:00 AM;</strong></span>
<span class="strong"><strong class="calibre7">                     Amount = 30;}; {WeatherDate = 1/11/2012 12:00:00 AM;</strong></span>
<span class="strong"><strong class="calibre7">                                     Amount = 5;};</strong></span>
<span class="strong"><strong class="calibre7">    {WeatherDate = 1/12/2012 12:00:00 AM;</strong></span>
</pre></div><p class="calibre6">With these three datasets <a id="id371" class="calibre1"/>available, let's combine the traffic stop and traffic crash datasets together into a single data frame to see if there is anything going on with geolocation.</p></div></div>

<div class="book" title="Traffic stop and crash exploration">
<div class="book" title="Geolocation analysis"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec62" class="calibre1"/>Geolocation analysis</h2></div></div></div><p class="calibre6">Go to the script file and add the following:</p><div class="informalexample"><pre class="programlisting">let stopData = 
    trafficStops
    |&gt; Array.countBy(fun ts -&gt; ts.Geolocation)</pre></div><p class="calibre6">Sending this to the REPL gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val stopData : (Geolocation * int) [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|({Latitude = 35.789;</strong></span>
<span class="strong"><strong class="calibre7">      Longitude = -78.829;}, 178); ({Latitude = 35.821;</strong></span>
<span class="strong"><strong class="calibre7">                                     Longitude = -78.901;}, 8);</strong></span>
<span class="strong"><strong class="calibre7">    ({Latitude = 35.766;</strong></span>
<span class="strong"><strong class="calibre7">      Longitu…</strong></span>
</pre></div><p class="calibre6">This code should look familiar to<a id="id372" class="calibre1"/> you by now; we are counting up the number of traffic stops by geolocation. For the first record, geopoint 35.789/-78.829 had 178 traffic stops.</p><p class="calibre6">Next, go back to the script and enter the following:</p><div class="informalexample"><pre class="programlisting">let crashData =
    trafficCrashes
    |&gt; Array.countBy(fun tc -&gt; tc.Geolocation)</pre></div><p class="calibre6">Sending this to the REPL gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val crashData : (Geolocation * int) [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|({Latitude = 35.79;</strong></span>
<span class="strong"><strong class="calibre7">      Longitude = -78.781;}, 51); ({Latitude = 35.783;</strong></span>
</pre></div><p class="calibre6">This code is identical to<a id="id373" class="calibre1"/> the stop data; we are counting up the number of traffic crashes by geolocation. For the first record, geopoint 35.790/-78.781 had 51 traffic crashes.</p><p class="calibre6">Our next step is to combine these two datasets into a single data frame that we can send to Accord. As for most things in F#, let's use types and functions to achieve this. Go back to the script file and enter the following:</p><div class="informalexample"><pre class="programlisting">type GeoTraffic = {Geolocation:Geolocation; CrashCount: int; StopCount: int}

let trafficGeo = 
    Enumerable.Join(crashData, stopData, 
                (fun crashData -&gt; fst crashData), 
                (fun stopData -&gt; fst stopData), 
                (fun crashData stopData -&gt; { Geolocation = fst crashData; StopCount = snd crashData ; CrashCount = snd stopData }))
                |&gt; Seq.toArray</pre></div><p class="calibre6">When you send this to the FSI, you will see something like the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">type GeoTraffic =</strong></span>
<span class="strong"><strong class="calibre7">  {Geolocation: Geolocation;</strong></span>
<span class="strong"><strong class="calibre7">   CrashCount: int;</strong></span>
<span class="strong"><strong class="calibre7">   StopCount: int;}</strong></span>
<span class="strong"><strong class="calibre7">val trafficGeo : GeoTraffic [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|{Geolocation = {Latitude = 35.79;</strong></span>
<span class="strong"><strong class="calibre7">                    Longitude = -78.781;};</strong></span>
<span class="strong"><strong class="calibre7">     CrashCount = 9;</strong></span>
<span class="strong"><strong class="calibre7">     StopCount = 51;}; {Geolocation = {Latitude = 35.783;</strong></span>
<span class="strong"><strong class="calibre7">                                       Longitude = -78.781;};</strong></span>
<span class="strong"><strong class="calibre7">                        CrashCount = 16;</strong></span>
<span class="strong"><strong class="calibre7">                        StopCount = 5;};</strong></span>
<span class="strong"><strong class="calibre7">    {Geolocation = {Latitude = 35.803;</strong></span>
<span class="strong"><strong class="calibre7">                    Longitude = -78.775;};</strong></span>
<span class="strong"><strong class="calibre7">     CrashCount = 76;</strong></span>
<span class="strong"><strong class="calibre7">     StopCount = 2;};</strong></span>
</pre></div><p class="calibre6">There is some new code here that can seem intimidating at first (at least, it was to me). We are using the LINQ class Enumerable's <span class="strong"><em class="calibre11">Join</em></span> method to join the <code class="literal">crashData</code> and <code class="literal">stopData</code> together. The <span class="strong"><em class="calibre11">Join</em></span> method takes<a id="id374" class="calibre1"/> in several parameters:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The first dataset (in this case <code class="literal">crashData</code>).</li><li class="listitem">The second dataset (in this case <code class="literal">stopData</code>).</li><li class="listitem">A lambda that extracts the value from the first dataset, which we will use to join. In this <a id="id375" class="calibre1"/>case, the first item of the tuple, which is the geolocation value.</li><li class="listitem">A lambda that extracts the value from the second dataset, which we will use to join. In this case, the first item of the tuple, which is the geolocation value.</li><li class="listitem">A lambda that specifies what the output of the join operation will look like. In this case, it is the record type called <code class="literal">GeoTraffic</code> that we defined on the first line of this code block.</li></ul></div><p class="calibre6">The key thing to realize about using the Join method is that it only keeps records that are in both datasets (an inner join to you SQL fans). This means if there is a geolocation that has one traffic ticket and no traffic stops, it is dropped from our analysis. If you want to do an outer join, there is the<a id="id376" class="calibre1"/> <span class="strong"><em class="calibre11">GroupJoin</em></span> method that does this. Since we are only really interested in high-activity areas, an inner join seems more appropriate.</p><p class="calibre6">With our data frame created, we are now ready to send the data to Accord's k-means. If you remember, Accord's k-means wants the input to be a jagged array of floats. Therefore, we have one last transformation. Go to the script file and enter the following:</p><div class="informalexample"><pre class="programlisting">let kmeansInput = 
    trafficGeo 
    |&gt; Array.map(fun cs -&gt; [|float cs.CrashCount; float cs.StopCount |])</pre></div><p class="calibre6">Sending to the FSI, we get the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val kmeansInput : float [] [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|[|9.0; 51.0|]; [|16.0; 5.0|]; [|76.0; 2.0|]; [|10.0; 1.0|]; [|80.0; 7.0|];</strong></span>
<span class="strong"><strong class="calibre7">    [|92.0; 27.0|]; [|8.0; 2.0|]; [|104.0; 11.0|]; [|47.0; 4.0|];</strong></span>
<span class="strong"><strong class="calibre7">    [|36.0; 16.0</strong></span>
</pre></div><p class="calibre6">Go back to the script file and enter the following:</p><div class="informalexample"><pre class="programlisting">let numberOfClusters = 3
let kmeans = new KMeans(numberOfClusters)
let labels = kmeans.Compute(kmeansInput.ToArray())
kmeans.Clusters.[0]
kmeans.Clusters.[1]
kmeans.Clusters.[2]</pre></div><p class="calibre6">Sending to the REPL, we will get the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val numberOfClusters : int = 3</strong></span>
<span class="strong"><strong class="calibre7">val kmeans : KMeans</strong></span>
<span class="strong"><strong class="calibre7">val labels : int [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|1; 1; 0; 1; 0; 0; 1; 0; 0; 1; 0; 0; 0; 1; 1; 0; 1; 1; 0; 0; 0; 2; 1; 0; 1;</strong></span>
<span class="strong"><strong class="calibre7">    2; 0; 2;</strong></span>
</pre></div><p class="calibre6">Woot! We have a k-means working on our traffic data. If you inspect each of the clusters, you will see the<a id="id377" class="calibre1"/> following:</p><div class="informalexample"><pre class="programlisting">val it : KMeansCluster =
  Accord.MachineLearning.KMeansCluster
    {Covariance = [[533.856744; 25.86726804]
                   [25.86726804; 42.23152921]];
     Index = 0;
     Mean = [|67.50515464; 6.484536082|];
     Proportion = 0.1916996047;}
&gt; 
val it : KMeansCluster =
  Accord.MachineLearning.KMeansCluster
    {Covariance = [[108.806009; 8.231942669]
                   [8.231942669; 16.71306776]];
     Index = 1;
     Mean = [|11.69170984; 2.624352332|];
     Proportion = 0.7628458498;}
&gt; 
val it : KMeansCluster =
  Accord.MachineLearning.KMeansCluster
    {Covariance = [[5816.209486; -141.4980237]
                   [-141.4980237; 194.4189723]];
     Index = 2;
     Mean = [|188.8695652; 13.34782609|];
     Proportion = 0.04545454545;}</pre></div><p class="calibre6">We have three clusters. I pulled the means and the proportions from each of the clusters and put them into a spreadsheet like this:</p><div class="informalexample"><table border="1" class="calibre19"><colgroup class="calibre20"><col class="calibre21"/><col class="calibre21"/><col class="calibre21"/></colgroup><thead class="calibre22"><tr class="calibre23"><th valign="bottom" class="calibre24">
<p class="calibre25">Crashes</p>
</th><th valign="bottom" class="calibre24">
<p class="calibre25">Stops</p>
</th><th valign="bottom" class="calibre24">
<p class="calibre25">% of records</p>
</th></tr></thead><tbody class="calibre26"><tr class="calibre23"><td valign="top" class="calibre27">
<p class="calibre25">67.5</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">6.48</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">20.2%</p>
</td></tr><tr class="calibre23"><td valign="top" class="calibre27">
<p class="calibre25">11.69</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">2.62</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">76.3%</p>
</td></tr><tr class="calibre23"><td valign="top" class="calibre27">
<p class="calibre25">188.87</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">13.35</p>
</td><td valign="top" class="calibre27">
<p class="calibre25">4.5%</p>
</td></tr></tbody></table></div><p class="calibre6">Looking at all the three clusters, it is notable that there are a lot more traffic crashes than stops. Also of interest is that the first and second cluster have about a 10:1 ratio of crashes to stops but the really high crash areas have a higher proportion of crashes to stops—about 14:1. It seems reasonable to conclude that there are a few high-crash areas in town and the<a id="id378" class="calibre1"/> police are very active there, but they could be even more active. I would name each cluster after their activity level: (low, medium, and high). If the geolocation was not in our data frame (a majority of the points in town), we could call that <span class="strong"><em class="calibre11">no activity</em></span>.</p><p class="calibre6">Finally, enter this into the script file:</p><div class="informalexample"><pre class="programlisting">let trafficGeo' = Array.zip trafficGeo labels</pre></div><p class="calibre6">Sending this to the FSI gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val trafficGeo' : (GeoTraffic * int) [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|({Geolocation = {Latitude = 35.79;</strong></span>
<span class="strong"><strong class="calibre7">                     Longitude = -78.781;};</strong></span>
<span class="strong"><strong class="calibre7">      CrashCount = 9;</strong></span>
<span class="strong"><strong class="calibre7">      StopCount = 51;}, 1); ({Geolocation = {Latitude = 35.783;</strong></span>
<span class="strong"><strong class="calibre7">                                             Longitude = -78.781;};</strong></span>
<span class="strong"><strong class="calibre7">                              CrashCount = 16;</strong></span>
<span class="strong"><strong class="calibre7">                              StopCount = 5;}, 1);</strong></span>
</pre></div><p class="calibre6">We have seen <code class="literal">.zip</code> before. We are merging our data frame that contains the geolocation, number of stops, and number of crashes with the labels frame that came out k-means. Then we can look up a given geolocation and see its cluster assignment. For example, geolocation 35.790/-78.781 is in Cluster 1—or medium activity.</p></div></div>

<div class="book" title="Traffic stop and crash exploration">
<div class="book" title="PCA"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec63" class="calibre1"/>PCA</h2></div></div></div><p class="calibre6">Now that we have a pretty good sense of the data via k-means, let's see if we can use PCA to uncover even <a id="id379" class="calibre1"/>more insights in our traffic data. Instead of location, let's look at date. As we found in <a class="calibre1" title="Chapter 4. Traffic Stops – Barking Up the Wrong Tree?" href="part0032_split_000.html#UGI01-a18db0be6c20485ba81f22e43ca13055">Chapter 4</a>, <span class="strong"><em class="calibre11">Traffic Stops – Barking Up the Wrong Tree?</em></span>, using our decision tree, there was nothing we could conclude with different bins of date/time and our traffic tickets. Perhaps augmenting the stop data with crash and weather will lead to something.</p><p class="calibre6">Go back into the <code class="literal">Clustering.fsx</code> script file and enter the following:</p><div class="informalexample"><pre class="programlisting">let crashCounts =
    trafficCrashes
    |&gt; Array.countBy(fun tc -&gt; tc.CrashDateTime.DayOfYear)</pre></div><p class="calibre6">Sending this to the FSI gives the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val crashCounts : (int * int) [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|(364, 10); (365, 3); (1, 2); (2, 3); (3, 12); (4, 5); (5, 3); (6, 1);</strong></span>
<span class="strong"><strong class="calibre7">    (7, 9); (8, 6); (9, 10); (10, 6); (11, 9);</strong></span>
</pre></div><p class="calibre6">This code is very much like the code we already wrote when creating the <code class="literal">crashData</code> for k-means. In this case, we are counting up traffic crashes by <code class="literal">DayOfYear</code>. <code class="literal">DayOfYear</code> assigns each day of the year an index value. For example, January 1 gets a 1, January 2 gets a 2 and December 31 gets a 365 or 366, depending on if it is a leap year or not. Notice that it is<a id="id380" class="calibre1"/> one-based because <code class="literal">DateTime.DayOfYear</code> is one-based.</p><p class="calibre6">Go back into the script file and enter the following:</p><div class="informalexample"><pre class="programlisting">let stopCounts = 
    trafficStops
    |&gt; Array.countBy(fun ts -&gt; ts.StopDateTime.DayOfYear)</pre></div><p class="calibre6">Sending this to the FSI gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val stopCounts : (int * int) [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|(182, 58); (183, 96); (184, 89); (185, 65); (38, 65);</strong></span>
</pre></div><p class="calibre6">As you can probably guess, this sums up the number of traffic stops by the day of the year. Pressing onward, go to the script file and enter the following:</p><div class="informalexample"><pre class="programlisting">let weatherData' =
    dailyWeather
    |&gt; Array.map(fun w -&gt; w.WeatherDate.DayOfYear, w.Amount)</pre></div><p class="calibre6">Sending this to the REPL gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val weatherData' : (int * int) [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|(9, 41); (10,` 30); (11, 5); (12, 124);</strong></span>
</pre></div><p class="calibre6">Just like crash and stop data, this creates a dataset with the amount of precipitation by day of year. You will notice that the data was already at the date level (sometimes called the level of atomicity), so an <code class="literal">Array.map</code> was used to transform the date; we don't need to use <code class="literal">countBy</code>.</p><p class="calibre6">With the initial datasets created, we now need a way to join all three together. The <code class="literal">Enumerable.Join</code> method that we used in the k-means example will not do here, so we will have to build our own joiner function. Go into the script file and enter the following:</p><div class="informalexample"><pre class="programlisting">let getItem dataSet item  =
    let found = dataSet |&gt; Array.tryFind(fun sd -&gt; fst(sd) = item)
    match found with
    | Some value -&gt; snd value
    | None -&gt; 0</pre></div><p class="calibre6">When you send this to the FSI, you will get the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val getItem : dataSet:('a * int) [] -&gt; item:'a -&gt; int when 'a : equality</strong></span>
</pre></div><p class="calibre6">This is a pretty complicated function signature. It might help if I added parameter hints to the method as shown in the following code:</p><div class="informalexample"><pre class="programlisting">let getItem (dataSet:(int*int)[], item:int)  =
    let found = dataSet |&gt; Array.tryFind(fun sd -&gt; fst(sd) = item)
    match found with
    | Some value -&gt; snd value
    | None -&gt; 0</pre></div><p class="calibre6">When you send this to the FSI, you will get the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val getItem : dataSet:(int * int) [] * item:int -&gt; int</strong></span>
</pre></div><p class="calibre6">This should be slightly more accessible but less generic, which is fine because all of our datasets (crash, stops, and weather) are arrays of <code class="literal">int*int</code>. Reading the output, we see that <code class="literal">getItem</code> is a function that takes in one parameter named dataset that is an array of <code class="literal">int</code> tuples <code class="literal">(int * int)[]</code> and another parameter named item that is an int. The function then <a id="id381" class="calibre1"/>attempts to find the tuple in the array whose <code class="literal">fst</code> has the same value as the item. If it is found, it returns the second value of the tuple. If it does not find the item in the array, it returns <code class="literal">0</code>.</p><p class="calibre6">This function will work well for all three of our datasets (crash, stops, and weather) because all three only hold records for days they have observations. For traffic stops, this is not a problem because there was at least one traffic stop on each day of the year. However, there were 16 days where there were no traffic crashes recorded, so <code class="literal">stopData</code> has 350 records and there were over 250 days where there was not any precipitation, so <code class="literal">weatherData</code> only has 114 records.</p><p class="calibre6">Since the first way of creating <code class="literal">getItem</code> is more generic and idiomatic to F#, I will use it for the remaining part of the chapter. Both the examples are in the example script file that you can download.</p><p class="calibre6">Going back to the script, enter the following:</p><div class="informalexample"><pre class="programlisting">type TrafficDay = {DayNumber:int; CrashCount: int; StopCount: int; RainAmount: int}

let trafficDates = 
    [|1..366|]
    |&gt; Array.map(fun d -&gt; {DayNumber=d;
                          CrashCount=getItem crashCounts d;
                          StopCount=getItem stopCounts d;
                          RainAmount=getItem weatherData' d})</pre></div><p class="calibre6">When you send this to the REPL, you will see the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">type TrafficDay =</strong></span>
<span class="strong"><strong class="calibre7">  {DayNumber: int;</strong></span>
<span class="strong"><strong class="calibre7">   CrashCount: int;</strong></span>
<span class="strong"><strong class="calibre7">   StopCount: int;</strong></span>
<span class="strong"><strong class="calibre7">   RainAmount: int;}</strong></span>
<span class="strong"><strong class="calibre7">val trafficDates : TrafficDay [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|{DayNumber = 1;</strong></span>
<span class="strong"><strong class="calibre7">     CrashCount = 2;</strong></span>
<span class="strong"><strong class="calibre7">     StopCount = 49;</strong></span>
<span class="strong"><strong class="calibre7">     RainAmount = 0;}; {DayNumber = 2;</strong></span>
<span class="strong"><strong class="calibre7">                        CrashCount = 3;</strong></span>
<span class="strong"><strong class="calibre7">                        StopCount = 43;</strong></span>
<span class="strong"><strong class="calibre7">                        RainAmount = 0;};</strong></span>
</pre></div><p class="calibre6">The first line creates a record type that contains the number of crashes, stops, and precipitation for the day. I used rain as the field name because we rarely get snow in North Carolina and I want to rub it in to<a id="id382" class="calibre1"/> any reader who lives up north. Of course, when we do get snow, it is borderline Armageddon.</p><p class="calibre6">The next block of code is where we create our final data frame. First, an integer array is created with every day of the year. A mapper function is then applied that calls <code class="literal">getItem</code> three times for each item of the array: the first time for <code class="literal">crashData</code>, the second for stop data, and finally for weather data. The results are put into the <code class="literal">TrafficDay</code> record.</p><p class="calibre6">With the data frame setup, we are now ready for Accord. Go to the script file and enter the following:</p><div class="informalexample"><pre class="programlisting">let pcaInput = 
    trafficDates 
    |&gt; Array.map(fun td -&gt; [|float td.CrashCount; float td.StopCount; float td.RainAmount |])</pre></div><p class="calibre6">When you send it to the REPL, you will get the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val pcaInput : float [] [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|[|2.0; 49.0; 0.0|]; [|3.0; 43.0; 0.0|]; [|12.0; 52.0; 0.0|];</strong></span>
<span class="strong"><strong class="calibre7">    [|5.0; 102.0; 0.0|];</strong></span>
</pre></div><p class="calibre6">This is a jagged array that Accord wants. Go back to the script and enter the following:</p><div class="informalexample"><pre class="programlisting">let pca = new PrincipalComponentAnalysis(pcaInput, AnalysisMethod.Center)
pca.Compute()
pca.Transform(pcaInput)
pca.ComponentMatrix
pca.ComponentProportions</pre></div><p class="calibre6">When you send this to the REPL, you will get the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val pca : PrincipalComponentAnalysis</strong></span>
<span class="strong"><strong class="calibre7">val it : unit = ()</strong></span>

<span class="strong"><strong class="calibre7">&gt; </strong></span>
<span class="strong"><strong class="calibre7">val it : float [] [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|[|-43.72753865; 26.15506878; -4.671924583|];</strong></span>

<span class="strong"><strong class="calibre7">val it : float [,] = [[0.00127851745; 0.01016388954; 0.999947529]</strong></span>
<span class="strong"><strong class="calibre7">                      [0.01597172498; -0.999821004; 0.01014218229]</strong></span>
<span class="strong"><strong class="calibre7">                      [0.9998716265; 0.01595791997; -0.001440623449]]</strong></span>
<span class="strong"><strong class="calibre7">&gt; </strong></span>
<span class="strong"><strong class="calibre7">val it : float [] = [|0.9379825626; 0.06122702459; 0.0007904128341|]</strong></span>
<span class="strong"><strong class="calibre7">&gt;</strong></span>



<span class="strong"><strong class="calibre7">&gt;</strong></span>
</pre></div><p class="calibre6">This shows that 94 percent of the variance in our data frame is from crashes, not stops or the weather. This is<a id="id383" class="calibre1"/> interesting because common wisdom is that, once it rains (or &lt;gasp&gt; snows &lt;gasp&gt;) in North Carolina, traffic accidents spike. Although that might make a good press story, this one-year sample does not bear it out.</p></div></div>

<div class="book" title="Traffic stop and crash exploration">
<div class="book" title="Analysis summary"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec64" class="calibre1"/>Analysis summary</h2></div></div></div><p class="calibre6">We now have a couple of models that point to some interesting ideas:</p><div class="book"><ul class="itemizedlist"><li class="listitem">There are a<a id="id384" class="calibre1"/> few locations that account for most of the traffic crashes and tickets in town</li><li class="listitem">Weather is not as important as you might think</li></ul></div><p class="calibre6">With this knowledge, we are ready to put machine learning to work for us.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="The Code-4-Good application"><div class="book" id="1CQAE2-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec40" class="calibre1"/>The Code-4-Good application</h1></div></div></div><p class="calibre6">Let's create a <a id="id385" class="calibre1"/>Windows application that helps people drive more safely. In addition, let's make the application "smart" so that it will progressively get more accurate. Let's start in Visual Studio with the project you have already created.</p></div>

<div class="book" title="The Code-4-Good application">
<div class="book" title="Machine learning assembly"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec65" class="calibre1"/>Machine learning assembly</h2></div></div></div><p class="calibre6">Go into the <span class="strong"><strong class="calibre7">Solution </strong></span><a id="id386" class="calibre1"/>
<span class="strong"><strong class="calibre7">Explorer</strong></span> and rename <code class="literal">Library1.fs</code> to <code class="literal">TrafficML.fs</code>. Add a reference to <code class="literal">System.Data</code>, <code class="literal">System.Data.Entity</code>, <code class="literal">System.Data.Linq</code>, and <code class="literal">FSharp.Data.TypeProviders</code>:</p><div class="mediaobject"><img src="../images/00092.jpeg" alt="Machine learning assembly" class="calibre8"/><div class="caption"><p class="calibre18">Adding references</p></div></div><p class="calibre9"> </p><p class="calibre6">Go into<a id="id387" class="calibre1"/> the <code class="literal">TrafficML.fs</code> file and enter the following code:</p><div class="informalexample"><pre class="programlisting">namespace Hack4Good.Traffic

open System
open System.Linq
open System.Data.Linq
open System.Data.Entity
open Accord.MachineLearning
open System.Collections.Generic
open Accord.Statistics.Analysis
open Microsoft.FSharp.Data.TypeProviders

type Geolocation = {Latitude: float; Longitude: float}
type private EntityConnection = SqlEntityConnection&lt;"data source=nc54a9m5kk.database.windows.net;initial catalog=Traffic;user id=chickenskills@nc54a9m5kk;password=sk1lzm@tter;",Pluralize = true&gt;
type TrafficStop = {StopDateTime: DateTime; Geolocation: Geolocation; DispositionId: int}
type TrafficCrash = {CrashDateTime: DateTime;  Geolocation: Geolocation; CrashSeverityId: int; CrashTypeId: int; }
type GeoTraffic = {Geolocation:Geolocation; CrashCount: int; StopCount: int}
type GeoTraffic' = {Geolocation:Geolocation; CrashCount: int; StopCount: int; Cluster: int}</pre></div><p class="calibre6">I know it feels weird not to send code you just wrote to FSI, but there is no way of getting immediate feedback of the code you wrote in a compliable file. We will be addressing this in the next <a id="id388" class="calibre1"/>chapter when we talk TDD. Until then, just compile the project to make sure you are on the right track.</p><p class="calibre6">Back to the <code class="literal">TrafficML.fs</code> file, enter the following wall of code or copy it from the book's download:</p><div class="informalexample"><pre class="programlisting">type TrafficML(connectionString:string) = 
    let context = EntityConnection.GetDataContext(connectionString)

        let trafficStops = 
        context.dbo_TrafficStops 
        |&gt; Seq.map(fun ts -&gt; {StopDateTime = ts.StopDateTime.Value; 
                             Geolocation = {Latitude =Math.Round(ts.Latitude.Value,3); 
                             Longitude=Math.Round(ts.Longitude.Value,3)}; 
                             DispositionId = ts.DispositionId.Value})
        |&gt; Seq.toArray

    let trafficCrashes= 
        context.dbo_TrafficCrashes 
        |&gt; Seq.filter(fun tc -&gt; tc.MunicipalityId = Nullable&lt;int&gt;(13))
        |&gt; Seq.filter(fun tc -&gt; not (tc.Latitude = Nullable&lt;float&gt;()))
        |&gt; Seq.map(fun tc -&gt; {CrashDateTime=tc.CrashDateTime.Value; 
                            Geolocation = {Latitude =Math.Round(tc.Latitude.Value,3); 
                            Longitude=Math.Round(tc.Longitude.Value,3)};
                            CrashSeverityId=tc.CrashSeverityId.Value; 
                            CrashTypeId =tc.CrashTypeId.Value})
        |&gt; Seq.toArray

    let stopData = 
        trafficStops
        |&gt; Array.countBy(fun ts -&gt; ts.Geolocation)

    let crashData =
        trafficCrashes
        |&gt; Array.countBy(fun tc -&gt; tc.Geolocation)

    let trafficGeo = 
        Enumerable.Join(crashData, stopData, 
                    (fun crashData -&gt; fst crashData), 
                    (fun stopData -&gt; fst stopData), 
                    (fun crashData stopData -&gt; { GeoTraffic.Geolocation = fst crashData; 
                       StopCount = snd crashData ; 
                       CrashCount = snd stopData }))
                    |&gt; Seq.toArray

    let kmeansInput = 
        trafficGeo 
        |&gt; Array.map(fun cs -&gt; [|float cs.CrashCount; float cs.StopCount |])
                        
    let numberOfClusters = 3
    let kmeans = new KMeans(numberOfClusters)
    let labels = kmeans.Compute(kmeansInput.ToArray())
    let trafficGeo' = Array.zip trafficGeo labels
                      |&gt; Array.map(fun (tg,l) -&gt; {Geolocation=tg.Geolocation;CrashCount=tg.CrashCount;StopCount=tg.StopCount;Cluster=l} ) </pre></div><p class="calibre6">This code is very similar to the k-means code we wrote in the <code class="literal">Clustering.fsx</code> script file. Notice that all the work of getting the data, shaping it, and running a k-means on it happens in the constructor of the <code class="literal">TrafficML</code> type. This means every time you create a new instance of the class from another location, you are making database calls and running the model. Also, notice that the connection string is hardcoded into the <code class="literal">SqlEntity</code> type <a id="id389" class="calibre1"/>provider for the type but then passed in via the constructor parameter when <code class="literal">GetDataContext()</code> is actually called. This allows you to move to code around environments (dev/test/prod). The downside is that you need to have your DEV environment exposed always so that the type is generated. One way to avoid this is to hardcode your Entity Framework <code class="literal">.edmx</code>/schema into the project.</p><p class="calibre6">Go back to the <code class="literal">TrafficML.fs</code> file and enter in the following function to the <code class="literal">TrafficML</code> type:</p><div class="informalexample"><pre class="programlisting">    member this.GetCluster(latitude: float, longitude: float, distance: float) =
        let geolocation = {Latitude=latitude; Longitude=longitude}
        let found = trafficGeo' 
                    |&gt; Array.map(fun gt -&gt; gt,(haversine gt.Geolocation geolocation))
                    |&gt; Array.filter(fun (gt,d) -&gt; d &lt; distance)
                    |&gt; Array.sortByDescending(fun (gt,d) -&gt; gt.Cluster)
        match found.Length with
        | 0 -&gt; -1
        | _ -&gt; let first = found |&gt; Array.head
               let gt = fst first
               gt.Cluster</pre></div><p class="calibre6">This does a search of the<a id="id390" class="calibre1"/> geolocations. If there is a match, the cluster is returned. If there is no match, <span class="strong"><em class="calibre11">a-1</em></span> is returned, signifying that there was not a match. We now have enough to make a first pass at creating a real time "smart" traffic application.</p></div></div>

<div class="book" title="The Code-4-Good application">
<div class="book" title="The UI"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec66" class="calibre1"/>The UI</h2></div></div></div><p class="calibre6">In the <span class="strong"><strong class="calibre7">Solution Explorer</strong></span>, add a<a id="id391" class="calibre1"/> new Visual C# WPF Application:</p><div class="mediaobject"><img src="../images/00093.jpeg" alt="The UI" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">After the project is created, add a reference from the C# UI project to the F# one, <code class="literal">System.Configuration</code> and <code class="literal">System.Device</code>:</p><div class="mediaobject"><img src="../images/00094.jpeg" alt="The UI" class="calibre8"/></div><p class="calibre9"> </p><div class="mediaobject"><img src="../images/00095.jpeg" alt="The UI" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">As a quick preparatory note, you are supposed to follow MVVM and command relay patterns when writing WFP applications which we will not cover in this book. This is a book about machine learning, not coddling humans via a delightful UI, so I code up enough of the<a id="id392" class="calibre1"/> UI just to get it to work. If you are interested in doing WPF following best practices, consider <span class="strong"><em class="calibre11">Windows Presentation Foundation 4.5 Cookbook</em></span>.</p><p class="calibre6">Inside the UI project, open up the <code class="literal">MainWindow.xaml</code> file, locate the <code class="literal">Grid</code> element, and enter in this XAML inside the grid:</p><div class="informalexample"><pre class="programlisting">&lt;Button x:Name="crashbutton" Content="Crash" Click="notifyButton_Click" HorizontalAlignment="Left" Height="41" Margin="31,115,0,0" VerticalAlignment="Top" Width="123"/&gt;
&lt;Button x:Name="stopButton" Content="Stop" Click="notifyButton_Click" HorizontalAlignment="Left" Height="41" Margin="171,115,0,0" VerticalAlignment="Top" Width="132"/&gt;
&lt;TextBlock x:Name="statusTextBlock" HorizontalAlignment="Left" Height="100" Margin="31,10,0,0" TextWrapping="Wrap" Text="Current Status: No Risk" VerticalAlignment="Top" Width="272"/&gt;</pre></div><p class="calibre6">Next, open up <code class="literal">MainWindow.xaml.cs</code> and enter the following <code class="literal">using</code> statements to the block of <code class="literal">using</code> at the top of the file:</p><div class="informalexample"><pre class="programlisting">using System.Configuration;
using System.Device.Location;</pre></div><p class="calibre6">Your file should look like the following:</p><div class="mediaobject"><img src="../images/00096.jpeg" alt="The UI" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Inside the <code class="literal">MainWindow</code> class, enter three class-level variables:</p><div class="informalexample"><pre class="programlisting">        TrafficML _trafficML = null;
        GeoCoordinateWatcher _watcher = null;
        String _connectionString = null;</pre></div><p class="calibre6">Your file<a id="id393" class="calibre1"/> should look like the following:</p><div class="mediaobject"><img src="../images/00097.jpeg" alt="The UI" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Then, in the <code class="literal">MainWindow()</code> constructor, add in the following code below <code class="literal">InitializeComponent()</code>:</p><div class="informalexample"><pre class="programlisting">            InitializeComponent();
            _connectionString = ConfigurationManager.ConnectionStrings["trafficDatabase"].ConnectionString;
            _trafficML = new TrafficML(_connectionString);

            _watcher = new GeoCoordinateWatcher(GeoPositionAccuracy.High);
            _watcher.PositionChanged += Watcher_PositionChanged;
            bool started = this._watcher.TryStart(false, TimeSpan.FromMilliseconds(2000));
            StartUpdateLoop();</pre></div><p class="calibre6">Your file should look like this:</p><div class="mediaobject"><img src="../images/00098.jpeg" alt="The UI" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Next, create the<a id="id394" class="calibre1"/> <code class="literal">Watcher_PositionChanged</code> method for the event handler:</p><div class="informalexample"><pre class="programlisting">        private void Watcher_PositionChanged(object sender, GeoPositionChangedEventArgs&lt;GeoCoordinate&gt; e)
        {
            var location = e.Position.Location;
            var latitude = Double.Parse(location.Latitude.ToString("00.000"));
            var longitude = Double.Parse(location.Longitude.ToString("00.000"));

            var cluster = _trafficML.GetCluster(latitude, longitude);
            var status = "No Risk";
            switch(cluster)
            {
                case 0:
                    status = "Low Risk";
                    break;
                case 1:
                    status = "Medium Risk";
                    break;
                case 2:
                    status = "High Risk";
                    break;
                default:
                    status = "No Risk";
                    break;
            }
            this.statusTextBlock.Text = "Current Status: " + status;

        }</pre></div><p class="calibre6">Next, create a loop to refresh the <code class="literal">MachineLearning</code> model every minute:</p><div class="informalexample"><pre class="programlisting">        private async Task StartUpdateLoop()
        {
            while (true)
            {
                await Task.Delay(TimeSpan.FromMinutes(1.0));
                _trafficML = await Task.Run(() =&gt; new TrafficML(_connectionString));
            }
        }</pre></div><p class="calibre6">Finally, add an <a id="id395" class="calibre1"/>event handler placeholder for the button clicks on the screen:</p><div class="informalexample"><pre class="programlisting">        private void notifyButton_Click(object sender, RoutedEventArgs e)
        {
            //TODO
        }</pre></div><p class="calibre6">If you collapse the code to definitions (<span class="strong"><em class="calibre11">CTRL</em></span> + <span class="strong"><em class="calibre11">M</em></span>, <span class="strong"><em class="calibre11">L</em></span>), your code should look like the following:</p><div class="mediaobject"><img src="../images/00099.jpeg" alt="The UI" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Next, go into <span class="strong"><strong class="calibre7">Solution Explorer</strong></span>, right-click to add a new <span class="strong"><strong class="calibre7">Application Configuration</strong></span> file:</p><div class="mediaobject"><img src="../images/00100.jpeg" alt="The UI" class="calibre8"/><div class="caption"><p class="calibre18">Adding new Application Configuration file</p></div></div><p class="calibre9"> </p><p class="calibre6">Inside that <code class="literal">app.config</code> file, replace the contents with this XML (replace the connection string with your <a id="id396" class="calibre1"/>connection string if you are using a local instance of the database):</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
    &lt;startup&gt; 
        &lt;supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" /&gt;
    &lt;/startup&gt;
  &lt;connectionStrings&gt;
    &lt;add name="trafficDatabase" 
         connectionString="data source=nc54a9m5kk.database.windows.net;initial catalog=Traffic;
         user id=chickenskills@nc54a9m5kk;password=sk1lzm@tter;" /&gt;
  &lt;/connectionStrings&gt;
&lt;/configuration&gt;</pre></div><p class="calibre6">Go to <span class="strong"><strong class="calibre7">Solution</strong></span><a id="id397" class="calibre1"/>
<span class="strong"><strong class="calibre7"> Explorer</strong></span> and make the UI project the startup project:</p><div class="mediaobject"><img src="../images/00101.jpeg" alt="The UI" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Compile your project. If all is well, try to run it. You should get a warning dialog like this:</p><div class="mediaobject"><img src="../images/00102.jpeg" alt="The UI" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">And then you will get a screen like this:</p><div class="mediaobject"><img src="../images/00103.jpeg" alt="The UI" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Once you <a id="id398" class="calibre1"/>completely take in the awesomeness of the user experience, stop running the application. So far, this is pretty good. If we put this application on a location-aware device (like a GPS) in the car and drive around, the status bar will warn us if we are within a quarter mile of a geolocation that might have a crash or stop risk. However, if we want to give ourselves more of a heads up, we need to add a bit more of code.</p></div></div>

<div class="book" title="The Code-4-Good application">
<div class="book" title="Adding distance calculations"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec67" class="calibre1"/>Adding distance calculations</h2></div></div></div><p class="calibre6">Go back to the F# project<a id="id399" class="calibre1"/> and open up the <code class="literal">TrafficML.fs</code> file. Locate the last line of the constructor. It looks like the following code:</p><div class="informalexample"><pre class="programlisting">    let trafficGeo' = Array.zip trafficGeo labels
                      |&gt; Array.map(fun (tg,l) -&gt; {Geolocation=tg.Geolocation;CrashCount=tg.CrashCount;StopCount=tg.StopCount;Cluster=l} ) </pre></div><p class="calibre6">Below this line, enter the following:</p><div class="informalexample"><pre class="programlisting">    let toRadian x = (Math.PI/180.0) * x

    let haversine x y =
        let dlon = toRadian (x.Longitude - y.Longitude)
        let dLat = toRadian (x.Latitude - y.Latitude)
        let a0 = pown (Math.Sin(dLat/2.0)) 2
        let a1 = Math.Cos(toRadian(x.Latitude)) * Math.Cos(toRadian(y.Latitude))
        let a2 = pown (Math.Sin(dlon/2.0)) 2
        let a = a0 + a1 * a2
        let c = 2.0 * Math.Atan2(sqrt(a),sqrt(1.0-a))
        let R = 3956.0
        R * c</pre></div><p class="calibre6">These two functions allow us to calculate the distance between geolocations. Since the earth is curved, we <a id="id400" class="calibre1"/>can't simply subtract the latitudes and longitudes between the two geolocations. The Haversine formula is the most common way to do this calculation.</p><p class="calibre6">Go to the end of the file and add the following:</p><div class="informalexample"><pre class="programlisting">    member this.GetCluster(latitude: float, longitude: float, distance: float) =
        let geolocation = {Latitude=latitude; Longitude=longitude}
        let found = trafficGeo' |&gt; Array.map(fun gt -&gt; gt,(haversine gt.Geolocation geolocation))
                                |&gt; Array.filter(fun (gt,d) -&gt; d &lt; distance)
                                |&gt; Array.sortByDescending(fun (gt,d) -&gt; gt.Cluster)
        match found.Length with
        | 0 -&gt; -1
        | _ -&gt; let first = found |&gt; Array.head
               let gt = fst first
               gt.Cluster </pre></div><p class="calibre6">What we are doing is overloading the <code class="literal">GetCluster</code> function with an additional parameter called distance. Using this input distance, we can calculate how far it is between the geolocation parameter and every geolocation in our <code class="literal">trafficGeo</code> array. If there are any matches, we sort by the highest number of cluster (<code class="literal">sortByDescending</code>) and return it.</p><p class="calibre6">Go back to our UI project and open the <code class="literal">MainWindow.xaml.cs</code> file and locate the <code class="literal">Watcher_PositionChanged</code> method. Find the following line of code:</p><div class="informalexample"><pre class="programlisting">var cluster = _trafficML.GetCluster(latitude, longitude);</pre></div><p class="calibre6">Replace it with the following line of code:</p><div class="informalexample"><pre class="programlisting">var cluster = _trafficML.GetCluster(latitude, longitude, 2.0);</pre></div><p class="calibre6">We now have a two mile<a id="id401" class="calibre1"/> heads-up to any problem area on the roads.</p></div></div>

<div class="book" title="The Code-4-Good application">
<div class="book" title="Augmenting with human observations"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec68" class="calibre1"/>Augmenting with human observations</h2></div></div></div><p class="calibre6">There is one <a id="id402" class="calibre1"/>more thing we want to do to our UI. If you look at some of the <span class="strong"><em class="calibre11">crowd source</em></span> road applications like Waze, they provide real-time notifications. Our app bases its classification based on historical data. However, if we were driving down the street in an area that was classified as<a id="id403" class="calibre1"/> <span class="strong"><em class="calibre11">low risk</em></span>, and we saw a traffic crash, we would want to elevate<a id="id404" class="calibre1"/> the location to a <span class="strong"><em class="calibre11">high risk</em></span>. Ideally, all the users of our application would get this update and override the model's classification of the geolocation (at least for the time being) and then we would update our database so that, as we retrain our model, the information gets more accurate.</p><p class="calibre6">Go to the <code class="literal">notifyButton_Click</code> event holder and replace <code class="literal">//TODO</code> with the following:</p><div class="informalexample"><pre class="programlisting">            var location = _watcher.Position.Location;
            var latitude = Double.Parse(location.Latitude.ToString("00.000"));
            var longitude = Double.Parse(location.Longitude.ToString("00.000"));
            _trafficML.AddGeolocationToClusterOverride(latitude, longitude);</pre></div><p class="calibre6">The compiler will complain to you because we have not implemented the <code class="literal">AddGeolocationToClusterOverride</code> yet. Go back over to the F# project and open the <code class="literal">TrafficML.fs</code> file. At the very bottom, add the following:</p><div class="informalexample"><pre class="programlisting">    member this.AddGeolocationToClusterOverride(latitude: float, longitude: float)  =
        let clusterOverride = EntityConnection.ServiceTypes.dbo_ClusterOverride()
        clusterOverride.Latitude &lt;- latitude
        clusterOverride.Longitude &lt;- longitude
        clusterOverride.Cluster &lt;- 2
        clusterOverride.OverrideDateTime &lt;- DateTime.UtcNow
        context.dbo_ClusterOverride.AddObject(clusterOverride)
        context.DataContext.SaveChanges() |&gt; ignore</pre></div><p class="calibre6">We now have a way of updating the database for any override. Note that you will not be able to write to the shared database on Azure that was created for this book, but you will be able to write to your local copy. As a final step, go up to where we created the <code class="literal">trafficGeo</code> on the following line:</p><div class="informalexample"><pre class="programlisting">    let trafficGeo' = Array.zip trafficGeo labels
                      |&gt; Array.map(fun (tg,l) -&gt; {Geolocation=tg.Geolocation;CrashCount=tg.CrashCount;StopCount=tg.StopCount;Cluster=l} ) </pre></div><p class="calibre6">Replace that line with the following code block:</p><div class="informalexample"><pre class="programlisting">    let overrides = context.dbo_ClusterOverride
                    |&gt; Seq.filter(fun co -&gt; (DateTime.UtcNow - co.OverrideDateTime) &gt; TimeSpan(0,5,0))
                    |&gt; Seq.toArray

        let checkForOverride (geoTraffic:GeoTraffic') =
        let found = overrides
                    |&gt; Array.tryFind(fun o -&gt; o.Latitude = geoTraffic.Geolocation.Latitude &amp;&amp; 
                    o.Longitude = geoTraffic.Geolocation.Longitude)
        match found.IsSome with
        | true -&gt; {Geolocation=geoTraffic.Geolocation;
                  CrashCount=geoTraffic.CrashCount;
                  StopCount=geoTraffic.StopCount;
                  Cluster=found.Value.Cluster}
        | false -&gt; geoTraffic

    let trafficGeo' = Array.zip trafficGeo labels
                      |&gt; Array.map(fun (tg,l) -&gt; {Geolocation=tg.Geolocation;
                       CrashCount=tg.CrashCount;
                       StopCount=tg.StopCount;
                       Cluster=l} ) 
                      |&gt; Array.map(fun gt -&gt; checkForOverride(gt))</pre></div><p class="calibre6">This block goes to the database and pulls down all overrides that occurred within the last 5 minutes and<a id="id405" class="calibre1"/> places them in the overrides array. It then creates a function called <code class="literal">checkForOverride</code> that takes in the <code class="literal">geoTraffic</code> value. If the latitude and longitude match the override table, the <code class="literal">geoTraffic</code> value is replaced with a new value that has the override value assigned by the database and not from the k-means model. If no match is found, the original value is returned. Finally, we pipe this function to the creation of <code class="literal">trafficGeo</code>. Note that if you try and execute this on our shared server, it will throw an exception because you don't have rights to write to the database. Hopefully, though, the intention is clear with this example. With that, we have a real-time system where we combine machine learning and human observations to give our end user the best possible predictions.</p></div></div>
<div class="book" title="Summary" id="1DOR01-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec41" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">We covered a lot of ground in this chapter. We looked at k-means and PCA to help us find hidden relationships in our traffic datasets. We then built an application that took advantage of the insights we gleaned to make drivers more aware and, hopefully, safer. This application is unique because it blended both real-time machine learning modeling and human observations to provide the best possible outcome for the driver.</p><p class="calibre6">In the next chapter, we are going to look at some of the limitations of our coding so far in this book and see if we can improve on both model and feature selection.</p></div></body></html>