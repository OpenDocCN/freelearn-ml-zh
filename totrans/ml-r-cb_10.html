<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;10.&#xA0;Association Analysis and Sequence Mining"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Association Analysis and Sequence Mining</h1></div></div></div><p class="calibre7">In this chapter, we will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Transforming data into transactions</li><li class="listitem">Displaying transactions and associations </li><li class="listitem">Mining associations with the Apriori rule</li><li class="listitem">Pruning redundant rules</li><li class="listitem">Visualizing associations rules</li><li class="listitem">Mining frequent itemsets with Eclat</li><li class="listitem">Creating transactions with temporal information</li><li class="listitem">Mining frequent sequential patterns with cSPADE</li></ul></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Association Analysis and Sequence Mining">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec112" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre7">Enterprises accumulate a large amount of transaction data (for example, sales orders from retailers, invoices, and shipping documentations) from daily operations. Finding hidden relationships in the data can be useful, such as, "What products are often bought together?" or "What are the subsequent purchases after buying a cell phone?" To answer these two questions, we need to perform association analysis and frequent sequential pattern mining on a transaction dataset.</p><p class="calibre7">Association analysis <a id="id804" class="calibre1"/>is an approach to find interesting relationships within a transaction dataset. A famous association between products is that <span class="strong"><em class="calibre8">customers who buy diapers also buy beer</em></span>. While this association may sound unusual, if retailers can use this kind of information or rule to cross-sell products to their customers, there is a high likelihood that they can increase their sales.</p><p class="calibre7">Association analysis is used to find a correlation between <span class="strong"><strong class="calibre2">itemsets</strong></span>, but what if you want to find out the<a id="id805" class="calibre1"/> order in which items are frequently purchased? To achieve this, you can adopt <a id="id806" class="calibre1"/>frequent sequential pattern mining to find frequent subsequences from transaction datasets with temporal information. You can then use the mined frequent subsequences to predict customer shopping sequence orders, web click streams, biological sequences, and usages in other applications.</p><p class="calibre7">In this chapter, we will cover recipes to create and inspect transaction datasets, performing association analysis with an Apriori algorithm, visualizing associations in various graph formats, and finding frequent itemsets using the Eclat algorithm. Lastly, we will create transactions with temporal information and use the cSPADE algorithm to discover frequent sequential patterns.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Transforming data into transactions"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec113" class="calibre1"/>Transforming data into transactions</h1></div></div></div><p class="calibre7">Before <a id="id807" class="calibre1"/>creating a mining association rule, you need to<a id="id808" class="calibre1"/> transform the data into transactions. In the following recipe, we will introduce how to transform either a list, matrix, or data frame into transactions.</p></div>

<div class="book" title="Transforming data into transactions">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec389" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">In this recipe, we will generate three different datasets in a list, matrix, or data frame. We can then transform the generated dataset into transactions.</p></div></div>

<div class="book" title="Transforming data into transactions">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec390" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre7">Perform the following steps to transform different formats of data into transactions:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, you have to install and load the package <code class="email">arule</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; install.packages("arules")</strong></span>
<span class="strong"><strong class="calibre2">&gt; library(arules)</strong></span>
</pre></div></li><li class="listitem" value="2">You can then make a list with three vectors containing purchase records:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; tr_list = list(c("Apple", "Bread", "Cake"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("Apple", "Bread", "Milk"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("Bread", "Cake", "Milk"))</strong></span>
<span class="strong"><strong class="calibre2">&gt; names(tr_list) = paste("Tr",c(1:3), sep = "")</strong></span>
</pre></div></li><li class="listitem" value="3">Next, you can use the <code class="email">as</code> function to transform the data frame into transactions:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; trans = as(tr_list, "transactions")</strong></span>
<span class="strong"><strong class="calibre2">&gt; trans</strong></span>
<span class="strong"><strong class="calibre2">transactions in sparse format with</strong></span>
<span class="strong"><strong class="calibre2"> 3 transactions (rows) and</strong></span>
<span class="strong"><strong class="calibre2"> 4 items (columns)</strong></span>
</pre></div></li><li class="listitem" value="4">You<a id="id809" class="calibre1"/> can also transform the matrix <a id="id810" class="calibre1"/>format data into transactions:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; tr_matrix = matrix(</strong></span>
<span class="strong"><strong class="calibre2">+   c(1,1,1,0,</strong></span>
<span class="strong"><strong class="calibre2">+     1,1,0,1,</strong></span>
<span class="strong"><strong class="calibre2">+     0,1,1,1), ncol = 4)</strong></span>
<span class="strong"><strong class="calibre2">&gt; dimnames(tr_matrix) =  list(</strong></span>
<span class="strong"><strong class="calibre2">+   paste("Tr",c(1:3), sep = ""),</strong></span>
<span class="strong"><strong class="calibre2">+   c("Apple","Bread","Cake", "Milk")</strong></span>
<span class="strong"><strong class="calibre2">+   )</strong></span>
<span class="strong"><strong class="calibre2">&gt; trans2 =  as(tr_matrix, "transactions")</strong></span>
<span class="strong"><strong class="calibre2">&gt; trans2</strong></span>
<span class="strong"><strong class="calibre2">transactions in sparse format with</strong></span>
<span class="strong"><strong class="calibre2"> 3 transactions (rows) and</strong></span>
<span class="strong"><strong class="calibre2"> 4 items (columns)</strong></span>
</pre></div></li><li class="listitem" value="5">Lastly, you can transform the data frame format datasets into transactions:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; Tr_df = data.frame(</strong></span>
<span class="strong"><strong class="calibre2">+   TrID= as.factor(c(1,2,1,1,2,3,2,3,2,3)),</strong></span>
<span class="strong"><strong class="calibre2">+   Item = as.factor(c("Apple","Milk","Cake","Bread",</strong></span>
<span class="strong"><strong class="calibre2">+                      "Cake","Milk","Apple","Cake",</strong></span>
<span class="strong"><strong class="calibre2">+                      "Bread","Bread"))  </strong></span>
<span class="strong"><strong class="calibre2">+ )</strong></span>
<span class="strong"><strong class="calibre2">&gt; trans3 = as(split(Tr_df[,"Item"], Tr_df[,"TrID"]), "transactions")</strong></span>
<span class="strong"><strong class="calibre2">&gt; trans3</strong></span>
<span class="strong"><strong class="calibre2">transactions in sparse format with</strong></span>
<span class="strong"><strong class="calibre2"> 3 transactions (rows) and</strong></span>
<span class="strong"><strong class="calibre2"> 4 items (columns)</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Transforming data into transactions">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec391" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre7">Before mining frequent itemsets or using the association rule, it is important to prepare the dataset by the class of transactions. In this recipe, we demonstrate how to transform a dataset from a list, matrix, and data frame format to transactions. In the first step, we generate the dataset in a list format containing three vectors of purchase records. Then, after we have assigned a transaction ID to each transaction, we transform the data into transactions using the <code class="email">as</code> function.</p><p class="calibre7">Next, we<a id="id811" class="calibre1"/> demonstrate how to transform the data from <a id="id812" class="calibre1"/>the matrix format into transactions. To denote how items are purchased, one should use a binary incidence matrix to record the purchase behavior of each transaction with regard to different items purchased. Likewise, we can use an <code class="email">as</code> function to transform the dataset from the matrix format into transactions.</p><p class="calibre7">Lastly, we illustrate how to transform the dataset from the data frame format into transactions. The data frame contains two factor-type vectors: one is a transaction ID named <code class="email">TrID</code>, while the other shows purchased items (named in <code class="email">Item</code>) with regard to different transactions. Also, one can use the <code class="email">as</code> function to transform the data frame format data into transactions.</p></div></div>

<div class="book" title="Transforming data into transactions">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec392" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">transactions</code> class is used to represent transaction data for rules or frequent pattern mining. It is an extension of the <code class="email">itemMatrix</code> class. If you are interested in how to use the two different classes to represent transaction data, please use the <code class="email">help</code> function to refer to the following documents:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; help(transactions)</strong></span>
<span class="strong"><strong class="calibre2">&gt; help(itemMatrix)</strong></span>
</pre></div></li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Displaying transactions and associations"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec114" class="calibre1"/>Displaying transactions and associations</h1></div></div></div><p class="calibre7">The <code class="email">arule</code> package uses its own <code class="email">transactions</code> class to store transaction data. As such, we must <a id="id813" class="calibre1"/>use the generic function provided by <code class="email">arule</code> to display transactions <a id="id814" class="calibre1"/>and association rules. In this recipe, we will illustrate how to display transactions and association rules via various functions in the <code class="email">arule</code> package.</p></div>

<div class="book" title="Displaying transactions and associations">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec393" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Ensure that you have completed the previous recipe by generating transactions and storing these in the variable, <code class="email">trans</code>.</p></div></div>

<div class="book" title="Displaying transactions and associations">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec394" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre7">Perform the<a id="id815" class="calibre1"/> following steps to display transactions and associations:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, you <a id="id816" class="calibre1"/>can obtain a LIST representation of the transaction data:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; LIST(trans)</strong></span>
<span class="strong"><strong class="calibre2">$Tr1</strong></span>
<span class="strong"><strong class="calibre2">[1] "Apple" "Bread" "Cake" </strong></span>

<span class="strong"><strong class="calibre2">$Tr2</strong></span>
<span class="strong"><strong class="calibre2">[1] "Apple" "Bread" "Milk" </strong></span>

<span class="strong"><strong class="calibre2">$Tr3</strong></span>
<span class="strong"><strong class="calibre2">[1] "Bread" "Cake"  "Milk"</strong></span>
</pre></div></li><li class="listitem" value="2">Next, you can use the <code class="email">summary</code> function to show a summary of the statistics and details of the transactions:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; summary(trans)</strong></span>
<span class="strong"><strong class="calibre2">transactions as itemMatrix in sparse format with</strong></span>
<span class="strong"><strong class="calibre2"> 3 rows (elements/itemsets/transactions) and</strong></span>
<span class="strong"><strong class="calibre2"> 4 columns (items) and a density of 0.75 </strong></span>

<span class="strong"><strong class="calibre2">most frequent items:</strong></span>
<span class="strong"><strong class="calibre2">  Bread   Apple    Cake    Milk (Other) </strong></span>
<span class="strong"><strong class="calibre2">      3       2       2       2       0 </strong></span>

<span class="strong"><strong class="calibre2">element (itemset/transaction) length distribution:</strong></span>
<span class="strong"><strong class="calibre2">sizes</strong></span>
<span class="strong"><strong class="calibre2">3 </strong></span>
<span class="strong"><strong class="calibre2">3 </strong></span>

<span class="strong"><strong class="calibre2">   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </strong></span>
<span class="strong"><strong class="calibre2">      3       3       3       3       3       3 </strong></span>

<span class="strong"><strong class="calibre2">includes extended item information - examples:</strong></span>
<span class="strong"><strong class="calibre2">  labels</strong></span>
<span class="strong"><strong class="calibre2">1  Apple</strong></span>
<span class="strong"><strong class="calibre2">2  Bread</strong></span>
<span class="strong"><strong class="calibre2">3   Cake</strong></span>

<span class="strong"><strong class="calibre2">includes extended transaction information - examples:</strong></span>
<span class="strong"><strong class="calibre2">  transactionID</strong></span>
<span class="strong"><strong class="calibre2">1           Tr1</strong></span>
<span class="strong"><strong class="calibre2">2           Tr2</strong></span>
<span class="strong"><strong class="calibre2">3           Tr3</strong></span>
</pre></div></li><li class="listitem" value="3">You <a id="id817" class="calibre1"/>can<a id="id818" class="calibre1"/> then display transactions using the <code class="email">inspect</code> function:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; inspect(trans)</strong></span>
<span class="strong"><strong class="calibre2">  items   transactionID</strong></span>
<span class="strong"><strong class="calibre2">1 {Apple,              </strong></span>
<span class="strong"><strong class="calibre2">   Bread,              </strong></span>
<span class="strong"><strong class="calibre2">   Cake}            Tr1</strong></span>
<span class="strong"><strong class="calibre2">2 {Apple,              </strong></span>
<span class="strong"><strong class="calibre2">   Bread,              </strong></span>
<span class="strong"><strong class="calibre2">   Milk}            Tr2</strong></span>
<span class="strong"><strong class="calibre2">3 {Bread,              </strong></span>
<span class="strong"><strong class="calibre2">   Cake,               </strong></span>
<span class="strong"><strong class="calibre2">   Milk}            Tr3</strong></span>
</pre></div></li><li class="listitem" value="4">In addition to this, you can filter the transactions by size:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; filter_trains = trans[size(trans) &gt;=3]</strong></span>
<span class="strong"><strong class="calibre2">&gt; inspect(filter_trains)</strong></span>
<span class="strong"><strong class="calibre2">  items   transactionID</strong></span>
<span class="strong"><strong class="calibre2">1 {Apple,              </strong></span>
<span class="strong"><strong class="calibre2">   Bread,              </strong></span>
<span class="strong"><strong class="calibre2">   Cake}            Tr1</strong></span>
<span class="strong"><strong class="calibre2">2 {Apple,              </strong></span>
<span class="strong"><strong class="calibre2">   Bread,              </strong></span>
<span class="strong"><strong class="calibre2">   Milk}            Tr2</strong></span>
<span class="strong"><strong class="calibre2">3 {Bread,              </strong></span>
<span class="strong"><strong class="calibre2">   Cake,               </strong></span>
<span class="strong"><strong class="calibre2">   Milk}            Tr3</strong></span>
</pre></div></li><li class="listitem" value="5">Also, you can use the image function to visually inspect the transactions:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; image(trans)</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00201.jpeg" alt="How to do it..." class="calibre9"/><div class="caption"><p class="calibre12">Visual inspection of transactions</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="6">To visually<a id="id819" class="calibre1"/> show the frequency/support bar plot, one <a id="id820" class="calibre1"/>can use <code class="email">itemFrequenctPlot</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; itemFrequencyPlot (trans)</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00202.jpeg" alt="How to do it..." class="calibre9"/><div class="caption"><p class="calibre12">Item frequency bar plot of transactions</p></div></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Displaying transactions and associations">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec395" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre7">As the<a id="id821" class="calibre1"/> transaction data is the base for mining associations <a id="id822" class="calibre1"/>and frequent patterns, we have to learn how to display the associations to gain insights and determine how associations are built. The <code class="email">arules</code> package provides various methods to inspect transactions. First, we use the <code class="email">LIST</code> function to obtain the list representation of the transaction data. We can then use the <code class="email">summary</code> function to obtain information, such as basic descriptions, most frequent items, and the transaction length distribution.</p><p class="calibre7">Next, we use the <code class="email">inspect</code> function to display the transactions. Besides displaying all transactions, one can first filter the transactions by size and then display the associations by using the <code class="email">inspect</code> function. Furthermore, we can use the <code class="email">image</code> function to visually inspect the transactions. Finally, we illustrate how to use the frequency/support bar plot to display the relative item frequency of each item.</p></div></div>

<div class="book" title="Displaying transactions and associations">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec396" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">Besides using <code class="email">itemFrequencyPlot</code> to show the frequency/bar plot, you can use the <code class="email">itemFrequency</code> function to show the support distribution. For more details, please use the <code class="email">help</code> function to view the following document:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; help(itemFrequency)</strong></span>
</pre></div></li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Mining associations with the Apriori rule"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec115" class="calibre1"/>Mining associations with the Apriori rule</h1></div></div></div><p class="calibre7">Association mining is a technique that can discover interesting relationships hidden in transaction datasets. This approach first finds all frequent itemsets, and generates strong association rules from frequent itemsets. Apriori is the most well-known association mining<a id="id823" class="calibre1"/> algorithm, which identifies frequent<a id="id824" class="calibre1"/> individual items first and then performs a breadth-first search strategy to extend individual items to larger itemsets until larger frequent itemsets cannot be found. In this recipe, we will introduce how to perform association analysis using the Apriori rule.</p></div>

<div class="book" title="Mining associations with the Apriori rule">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec397" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">In this recipe, we will use the built-in transaction dataset, <code class="email">Groceries</code>, to demonstrate how to perform association analysis with the Apriori algorithm in the <code class="email">arules</code> package. Please make sure that the <code class="email">arules</code> package is installed and loaded first.</p></div></div>

<div class="book" title="Mining associations with the Apriori rule">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec398" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre7">Perform <a id="id825" class="calibre1"/>the following steps to analyze the association<a id="id826" class="calibre1"/> rules:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, you need to load the dataset <code class="email">Groceries</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; data(Groceries)</strong></span>
</pre></div></li><li class="listitem" value="2">You can then examine the summary of the <code class="email">Groceries</code> dataset:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; summary(Groceries)</strong></span>
</pre></div></li><li class="listitem" value="3">Next, you can use <code class="email">itemFrequencyPlot</code> to examine the relative item frequency of itemsets:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; itemFrequencyPlot(Groceries, support = 0.1, cex.names=0.8, topN=5)</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00203.jpeg" alt="How to do it..." class="calibre9"/><div class="caption"><p class="calibre12">The top five item frequency bar plot of groceries transactions</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="4">Use <code class="email">apriori</code> to discover rules with the support over 0.001 and confidence over 0.5:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; rules = apriori(Groceries, parameter = list(supp = 0.001, conf = 0.5, target= "rules"))</strong></span>
<span class="strong"><strong class="calibre2">&gt; summary(rules)</strong></span>
<span class="strong"><strong class="calibre2">set of 5668 rules</strong></span>

<span class="strong"><strong class="calibre2">rule length distribution (lhs + rhs):sizes</strong></span>
<span class="strong"><strong class="calibre2">   2    3    4    5    6 </strong></span>
<span class="strong"><strong class="calibre2">  11 1461 3211  939   46 </strong></span>

<span class="strong"><strong class="calibre2">   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </strong></span>
<span class="strong"><strong class="calibre2">   2.00    3.00    4.00    3.92    4.00    6.00 </strong></span>

<span class="strong"><strong class="calibre2">summary of quality measures:</strong></span>
<span class="strong"><strong class="calibre2">    support           confidence          lift       </strong></span>
<span class="strong"><strong class="calibre2"> Min.   :0.001017   Min.   :0.5000   Min.   : 1.957  </strong></span>
<span class="strong"><strong class="calibre2"> 1st Qu.:0.001118   1st Qu.:0.5455   1st Qu.: 2.464  </strong></span>
<span class="strong"><strong class="calibre2"> Median :0.001322   Median :0.6000   Median : 2.899  </strong></span>
<span class="strong"><strong class="calibre2"> Mean   :0.001668   Mean   :0.6250   Mean   : 3.262  </strong></span>
<span class="strong"><strong class="calibre2"> 3rd Qu.:0.001729   3rd Qu.:0.6842   3rd Qu.: 3.691  </strong></span>
<span class="strong"><strong class="calibre2"> Max.   :0.022267   Max.   :1.0000   Max.   :18.996  </strong></span>

<span class="strong"><strong class="calibre2">mining info:</strong></span>
<span class="strong"><strong class="calibre2">      data ntransactions support confidence</strong></span>
<span class="strong"><strong class="calibre2"> Groceries          9835   0.001        0.5</strong></span>
</pre></div></li><li class="listitem" value="5">We <a id="id827" class="calibre1"/>can then inspect the first few<a id="id828" class="calibre1"/> rules:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; inspect(head(rules))</strong></span>
<span class="strong"><strong class="calibre2">  lhs                    rhs              support confidence     lift</strong></span>
<span class="strong"><strong class="calibre2">1 {honey}             =&gt; {whole milk} 0.001118454  0.7333333 2.870009</strong></span>
<span class="strong"><strong class="calibre2">2 {tidbits}           =&gt; {rolls/buns} 0.001220132  0.5217391 2.836542</strong></span>
<span class="strong"><strong class="calibre2">3 {cocoa drinks}      =&gt; {whole milk} 0.001321810  0.5909091 2.312611</strong></span>
<span class="strong"><strong class="calibre2">4 {pudding powder}    =&gt; {whole milk} 0.001321810  0.5652174 2.212062</strong></span>
<span class="strong"><strong class="calibre2">5 {cooking chocolate} =&gt; {whole milk} 0.001321810  0.5200000 2.035097</strong></span>
<span class="strong"><strong class="calibre2">6 {cereals}           =&gt; {whole milk} 0.003660397  0.6428571 2.515917</strong></span>
</pre></div></li><li class="listitem" value="6">You can sort rules by confidence and inspect the first few rules:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; rules=sort(rules, by="confidence", decreasing=TRUE)</strong></span>
<span class="strong"><strong class="calibre2">&gt; inspect(head(rules))</strong></span>
<span class="strong"><strong class="calibre2">  lhs                     rhs                    support confidence     lift</strong></span>
<span class="strong"><strong class="calibre2">1 {rice,                                                                    </strong></span>
<span class="strong"><strong class="calibre2">   sugar}              =&gt; {whole milk}       0.001220132          1 3.913649</strong></span>
<span class="strong"><strong class="calibre2">2 {canned fish,                                                             </strong></span>
<span class="strong"><strong class="calibre2">   hygiene articles}   =&gt; {whole milk}       0.001118454          1 3.913649</strong></span>
<span class="strong"><strong class="calibre2">3 {root vegetables,                                                         </strong></span>
<span class="strong"><strong class="calibre2">   butter,                                                                  </strong></span>
<span class="strong"><strong class="calibre2">   rice}               =&gt; {whole milk}       0.001016777          1 3.913649</strong></span>
<span class="strong"><strong class="calibre2">4 {root vegetables,                                                         </strong></span>
<span class="strong"><strong class="calibre2">   whipped/sour cream,                                                      </strong></span>
<span class="strong"><strong class="calibre2">   flour}              =&gt; {whole milk}       0.001728521          1 3.913649</strong></span>
<span class="strong"><strong class="calibre2">5 {butter,                                                                  </strong></span>
<span class="strong"><strong class="calibre2">   soft cheese,                                                             </strong></span>
<span class="strong"><strong class="calibre2">   domestic eggs}      =&gt; {whole milk}       0.001016777          1 3.913649</strong></span>
<span class="strong"><strong class="calibre2">6 {citrus fruit,                                                            </strong></span>
<span class="strong"><strong class="calibre2">   root vegetables,                                                         </strong></span>
<span class="strong"><strong class="calibre2">   soft cheese}        =&gt; {other vegetables} 0.001016777          1 5.168156</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Mining associations with the Apriori rule">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec399" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre7">The <a id="id829" class="calibre1"/>purpose of association mining is to discover <a id="id830" class="calibre1"/>associations among items from the transactional database. Typically, the process of association mining proceeds by finding itemsets that have the support greater than the minimum support. Next, the process uses the frequent itemsets to generate strong rules (for example, <code class="email">milk =&gt; bread</code>; a customer who buys milk is likely to buy bread) that have the confidence greater than minimum the confidence. By definition, an association rule can be expressed in the form of <span class="strong"><em class="calibre8">X=&gt;Y</em></span>, where X and Y are disjointed itemsets. We can measure the strength of associations between two terms: support and confidence. Support shows how much of the percentage of a rule is applicable within a dataset, while confidence indicates the probability of both X and Y appearing in the same transaction:</p><div class="book"><ul class="itemizedlist"><li class="listitem">
Support = <span class="strong"><img src="../images/00204.jpeg" alt="How it works..." class="calibre24"/></span></li><li class="listitem">
Confidence = <span class="strong"><img src="../images/00205.jpeg" alt="How it works..." class="calibre24"/></span></li></ul></div><p class="calibre7">Here, <span class="strong"><img src="../images/00206.jpeg" alt="How it works..." class="calibre24"/></span> refers to the frequency of a particular itemset; <span class="strong"><em class="calibre8">N</em></span> denotes the populations.</p><p class="calibre7">As <a id="id831" class="calibre1"/>support and confidence are metrics for the <a id="id832" class="calibre1"/>strength rule only, you might still obtain many redundant rules with a high support and confidence. Therefore, we can use the third measure, lift, to evaluate the quality (ranking) of the rule. By definition, lift indicates the strength of a rule over the random co-occurrence of X and Y, so we can formulate lift in the following form:</p><p class="calibre7">Lift = <span class="strong"><img src="../images/00207.jpeg" alt="How it works..." class="calibre24"/></span>
</p><p class="calibre7">Apriori is the best known algorithm for mining associations, which performs a level-wise, breadth-first algorithm to count the candidate itemsets. The process of Apriori starts by finding frequent itemsets (a set of items that have minimum support) level-wisely. For example, the process starts with finding frequent 1-itemsets. Then, the process continues by using frequent 1-itemsets to find frequent 2-itemsets. The process iteratively discovers new frequent k+1-itemsets from frequent k-itemsets until no frequent itemsets are found.</p><p class="calibre7">Finally, the process utilizes frequent itemsets to generate association rules:</p><div class="mediaobject"><img src="../images/00208.jpeg" alt="How it works..." class="calibre9"/><div class="caption"><p class="calibre12">An illustration of Apriori algorithm (Where support = 2)</p></div></div><p class="calibre10"> </p><p class="calibre7">In this recipe, we use the Apriori algorithm to find association rules within transactions. We use the built-in <code class="email">Groceries</code> dataset, which contains one month of real-world point-of-sale transaction data from a typical grocery outlet. We then use the <code class="email">summary</code> function to obtain the<a id="id833" class="calibre1"/> summary statistics of the <code class="email">Groceries</code> dataset. The summary statistics shows that the dataset contains 9,835 transactions, which<a id="id834" class="calibre1"/> are categorized into 169 categories. In addition to this, the summary shows information, such as most frequent items, itemset distribution, and example extended item information within the dataset. We can then use <code class="email">itemFrequencyPlot</code> to visualize the five most frequent items with support over 0.1.</p><p class="calibre7">Next, we apply the Apriori algorithm to search for rules with support over 0.001 and confidence over 0.5. We then use the <code class="email">summary</code> function to inspect detailed information on the generated rules. From the output summary, we find the Apriori algorithm generates 5,668 rules with support over 0.001 and confidence over 0.5. Further, we can find the rule length distribution, summary of quality measures, and mining information. In the summary of the quality measurement, we find descriptive statistics of three measurements, which are support, confidence, and lift. Support is the proportion of transactions containing a certain itemset. Confidence is the correctness percentage of the rule. Lift is the response target association rule divided by the average response.</p><p class="calibre7">To explore some generated rules, we can use the <code class="email">inspect</code> function to view the first six rules of the 5,668 generated rules. Lastly, we can sort rules by confidence and list rules with the most confidence. Therefore, we find that <code class="email">rich sugar</code> associated to <code class="email">whole milk</code> is the most confident rule with the support equal to 0.001220132, confidence equal to 1, and lift equal to 3.913649.</p></div></div>

<div class="book" title="Mining associations with the Apriori rule">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec400" class="calibre1"/>See also</h2></div></div></div><p class="calibre7">For those<a id="id835" class="calibre1"/> interested in the research results using <a id="id836" class="calibre1"/>the <code class="email">Groceries</code> dataset, and how the support, confidence, and lift measurement are defined, you can refer to the following papers:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Michael Hahsler, Kurt Hornik, and Thomas Reutterer (2006) <span class="strong"><em class="calibre8">Implications of probabilistic data modeling for mining association rules</em></span>. <span class="strong"><em class="calibre8">In M. Spiliopoulou, R. Kruse</em></span>, <span class="strong"><em class="calibre8">C. Borgelt</em></span>, <span class="strong"><em class="calibre8">A</em></span></li><li class="listitem">Nuernberger, and W. Gaul, editors, <span class="strong"><em class="calibre8">From Data and Information Analysis to Knowledge Engineering, Studies in Classification</em></span>, <span class="strong"><em class="calibre8">Data Analysis, and Knowledge Organization</em></span>, <span class="strong"><em class="calibre8">pages 598–605</em></span>. <span class="strong"><em class="calibre8">Springer-Verlag</em></span></li></ul></div><p class="calibre7">Also, in addition to using the <code class="email">summary</code> and <code class="email">inspect</code> functions to inspect association rules, you can use <code class="email">interestMeasure</code> to obtain additional interest measures:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; head(interestMeasure(rules, c("support", "chiSquare", "confidence", "conviction","cosine", "coverage", "leverage", "lift","oddsRatio"), Groceries))</strong></span>
</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Pruning redundant rules"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec116" class="calibre1"/>Pruning redundant rules</h1></div></div></div><p class="calibre7">Among the generated rules, we sometimes find repeated or redundant rules (for example, one rule is<a id="id837" class="calibre1"/> the super rule or subset of another rule). In this recipe, we will show you how to prune (or remove) repeated or redundant rules.</p></div>

<div class="book" title="Pruning redundant rules">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec401" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">In this recipe, you have to complete the previous recipe by generating rules and have it stored in the variable <code class="email">rules</code>.</p></div></div>

<div class="book" title="Pruning redundant rules">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec402" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre7">Perform the following steps to prune redundant rules:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, follow these steps to find redundant rules:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; rules.sorted = sort(rules, by="lift")</strong></span>
<span class="strong"><strong class="calibre2">&gt; subset.matrix = is.subset(rules.sorted, rules.sorted)</strong></span>
<span class="strong"><strong class="calibre2">&gt; subset.matrix[lower.tri(subset.matrix, diag=T)] = NA</strong></span>
<span class="strong"><strong class="calibre2">&gt; redundant = colSums(subset.matrix, na.rm=T) &gt;= 1</strong></span>
</pre></div></li><li class="listitem" value="2">You can then remove redundant rules:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; rules.pruned = rules.sorted[!redundant]</strong></span>
<span class="strong"><strong class="calibre2">&gt; inspect(head(rules.pruned))</strong></span>
<span class="strong"><strong class="calibre2">  lhs                        rhs                  support confidence     lift</strong></span>
<span class="strong"><strong class="calibre2">1 {Instant food products,                                                    </strong></span>
<span class="strong"><strong class="calibre2">   soda}                  =&gt; {hamburger meat} 0.001220132  0.6315789 18.99565</strong></span>
<span class="strong"><strong class="calibre2">2 {soda,                                                                     </strong></span>
<span class="strong"><strong class="calibre2">   popcorn}               =&gt; {salty snack}    0.001220132  0.6315789 16.69779</strong></span>
<span class="strong"><strong class="calibre2">3 {flour,                                                                    </strong></span>
<span class="strong"><strong class="calibre2">   baking powder}         =&gt; {sugar}          0.001016777  0.5555556 16.40807</strong></span>
<span class="strong"><strong class="calibre2">4 {ham,                                                                      </strong></span>
<span class="strong"><strong class="calibre2">   processed cheese}      =&gt; {white bread}    0.001931876  0.6333333 15.04549</strong></span>
<span class="strong"><strong class="calibre2">5 {whole milk,                                                               </strong></span>
<span class="strong"><strong class="calibre2">   Instant food products} =&gt; {hamburger meat} 0.001525165  0.5000000 15.03823</strong></span>
<span class="strong"><strong class="calibre2">6 {other vegetables,                                                         </strong></span>
<span class="strong"><strong class="calibre2">   curd,                                                                     </strong></span>
<span class="strong"><strong class="calibre2">   yogurt,                                                                   </strong></span>
<span class="strong"><strong class="calibre2">   whipped/sour cream}    =&gt; {cream cheese }  0.001016777  0.5882353 14.83409</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Pruning redundant rules">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec403" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre7">The two <a id="id838" class="calibre1"/>main constraints of association mining are to choose between the support and confidence. For example, if you use a high support threshold, you might remove rare item rules without considering whether these rules have a high confidence value. On the other hand, if you choose to use a low support threshold, the association mining can produce huge sets of redundant association rules, which make these rules difficult to utilize and analyze. Therefore, we need to prune redundant rules so we can discover meaningful information from these generated rules.</p><p class="calibre7">In this recipe, we demonstrate how to prune redundant rules. First, we search for redundant rules. We sort the rules by a lift measure, and then find subsets of the sorted rules using the <code class="email">is.subset</code> function, which will generate an <code class="email">itemMatrix</code> object. We can then set the lower triangle of the matrix to NA. Lastly, we compute <code class="email">colSums</code> of the generated matrix, of which <code class="email">colSums &gt;=1</code> indicates that the specific rule is redundant.</p><p class="calibre7">After we have found the redundant rules, we can prune these rules from the sorted rules. Lastly, we can examine the pruned rules using the <code class="email">inspect</code> function.</p></div></div>

<div class="book" title="Pruning redundant rules">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec404" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">In <a id="id839" class="calibre1"/>order to find subsets or supersets of rules, you can use the <code class="email">is.superset</code> and <code class="email">is.subset</code> functions on the association rules. These two methods may generate an <code class="email">itemMatrix</code> object to show which rule is the superset or subset of other rules. You can refer to the <code class="email">help</code> function for more information:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; help(is.superset)</strong></span>
<span class="strong"><strong class="calibre2">&gt; help(is.subset)</strong></span>
</pre></div></li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Visualizing association rules"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec117" class="calibre1"/>Visualizing association rules</h1></div></div></div><p class="calibre7">Besides<a id="id840" class="calibre1"/> listing rules as text, you can visualize association rules, making it easier to find the relationship between itemsets. In the following recipe, we will introduce how to use the <code class="email">aruleViz</code> package to visualize the association rules.</p></div>

<div class="book" title="Visualizing association rules">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec405" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">In this recipe, we will continue using the <code class="email">Groceries</code> dataset. You need to have completed the previous recipe by generating the pruned rule <code class="email">rules.pruned</code>.</p></div></div>

<div class="book" title="Visualizing association rules">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec406" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre7">Perform the following steps to visualize the association rule:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, you need to install and load the package <code class="email">arulesViz</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; install.packages("arulesViz")</strong></span>
<span class="strong"><strong class="calibre2">&gt; library(arulesViz)</strong></span>
</pre></div></li><li class="listitem" value="2">You can then make a scatter plot from the pruned rules:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; plot(rules.pruned)</strong></span>
</pre></div><p class="calibre26"> </p><div class="mediaobject"><img src="../images/00209.jpeg" alt="How to do it..." class="calibre9"/><div class="caption"><p class="calibre12">The scatter plot of pruned association rules</p></div></div><p class="calibre13"> </p><p class="calibre26">
</p></li><li class="listitem" value="3">Additionally, to <a id="id841" class="calibre1"/>prevent overplotting, you can add jitter to the scatter plot:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; plot(rules.pruned, shading="order", control=list(jitter=6))</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00210.jpeg" alt="How to do it..." class="calibre9"/><div class="caption"><p class="calibre12">The scatter plot of pruned association rules with jitters</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="4">We <a id="id842" class="calibre1"/>then produce new rules with <code class="email">soda</code> on the left-hand side using the Apriori algorithm:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; soda_rule=apriori(data=Groceries, parameter=list(supp=0.001,conf = 0.1, minlen=2), appearance = list(default="rhs",lhs="soda"))</strong></span>
</pre></div></li><li class="listitem" value="5">Next, you can plot <code class="email">soda_rule</code> in a graph plot:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; plot(sort(soda_rule, by="lift"), method="graph", control=list(type="items"))</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00211.jpeg" alt="How to do it..." class="calibre9"/><div class="caption"><p class="calibre12">Graph plot of association rules</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="6">Also, the association rules can be visualized in a balloon plot:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; plot(soda_rule, method="grouped")</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00212.jpeg" alt="How to do it..." class="calibre9"/><div class="caption"><p class="calibre12">Balloon plot of association rules</p></div></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Visualizing association rules">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec407" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre7">Besides presenting association rules as text, one can use <code class="email">arulesViz</code> to visualize association rules. The <code class="email">arulesViz</code> is an <code class="email">arules</code> extension package, which provides many visualization<a id="id843" class="calibre1"/> techniques to explore association rules. To start using <code class="email">arulesViz</code>, first install and load the package <code class="email">arulesViz</code>. We then use the pruned rules generated in the previous recipe to make a scatter plot. As per the figure in step 2, we find the rules are shown as points within the scatter plot, with the x-axis in support and y-axis in confidence. The shade of color shows the lift of the rule; the darker the shade, the higher the lift. Next, in order to prevent overplotting points, we can include the jitter as an argument in the control list. The plot with the jitter added is provided in the figure in step 3.</p><p class="calibre7">In addition to plotting the rules in a scatter plot, <code class="email">arulesViz</code> enables you to plot rules in a graph and grouped matrix. Instead of printing all the rules on a single plot, we choose to produce new rules with <code class="email">soda</code> on the left-hand side. We then sort the rules by using the lift and visualize the rules in the graph in the figure in step 4. From the graph, every itemset is presented in a vertex and their relationship is presented in an edge. The figure (step 4) shows it is clear that the rule with <code class="email">soda</code> on the left-handside to <code class="email">whole milk</code> on the right-handside has the maximum support, for the size of the node is greatest. Also, the rule shows that <code class="email">soda</code> on the left-hand side to <code class="email">bottled water</code> on the right-hand side has the maximum lift as the shade of color in the circle is the darkest. We can then use the same data with <code class="email">soda</code> on the left-handside to generate a grouped matrix, which is a balloon plot shown in the figure in step 5, with the left-handside rule as column labels and the right-handside as row labels. Similar to the graph plot in the figure in step 4, the size of the balloon in the figure in step 5 shows the support of the rule, and the color of the balloon shows the lift of the rule.</p></div></div>

<div class="book" title="Visualizing association rules">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec408" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">In this <a id="id844" class="calibre1"/>recipe, we introduced three visualization methods to plot association rules. However, <code class="email">arulesViz</code> also provides features to plot parallel coordinate plots, double-decker plots, mosaic plots, and other related charts. For those who are interested in how these plots work, you may refer to: Hahsler, M., and Chelluboina, S. (2011). <span class="strong"><em class="calibre8">Visualizing association rules: Introduction to the R-extension package arulesViz. R project module</em></span>.</li><li class="listitem">In addition to generating a static plot, you can generate an interactive plot by setting interactive equal to TRUE through the following steps:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; plot(rules.pruned,interactive=TRUE)</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00213.jpeg" alt="See also" class="calibre9"/><div class="caption"><p class="calibre12">The interactive scatter plots</p></div></div><p class="calibre13"> </p></li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Mining frequent itemsets with Eclat"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec118" class="calibre1"/>Mining frequent itemsets with Eclat</h1></div></div></div><p class="calibre7">In addition to the Apriori algorithm, you can use the Eclat algorithm to generate frequent itemsets. As <a id="id845" class="calibre1"/>the Apriori algorithm performs a breadth-first search to scan the complete database, the support counting is rather time consuming. Alternatively, if the database fits into the memory, you can use the Eclat algorithm, which performs a depth-first search to count the supports. The Eclat algorithm, therefore, performs quicker than the Apriori algorithm. In this recipe, we introduce how to use the Eclat algorithm to generate frequent itemsets.</p></div>

<div class="book" title="Mining frequent itemsets with Eclat">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec409" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">In this<a id="id846" class="calibre1"/> recipe, we will continue using the dataset <code class="email">Groceries</code> as our input data source.</p></div></div>

<div class="book" title="Mining frequent itemsets with Eclat">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec410" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre7">Perform the following steps to generate a frequent itemset using the Eclat algorithm:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Similar to the Apriori method, we can use the <code class="email">eclat</code> function to generate the frequent itemset:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; frequentsets=eclat(Groceries,parameter=list(support=0.05,maxlen=10))</strong></span>
</pre></div></li><li class="listitem" value="2">We can then obtain the summary information from the generated frequent itemset:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; summary(frequentsets)</strong></span>
<span class="strong"><strong class="calibre2">set of 31 itemsets</strong></span>

<span class="strong"><strong class="calibre2">most frequent items:</strong></span>
<span class="strong"><strong class="calibre2">      whole milk other vegetables           yogurt </strong></span>
<span class="strong"><strong class="calibre2">               4                2                2 </strong></span>
<span class="strong"><strong class="calibre2">      rolls/buns      frankfurter          (Other) </strong></span>
<span class="strong"><strong class="calibre2">               2                1               23 </strong></span>

<span class="strong"><strong class="calibre2">element (itemset/transaction) length distribution:sizes</strong></span>
<span class="strong"><strong class="calibre2"> 1  2 </strong></span>
<span class="strong"><strong class="calibre2">28  3 </strong></span>

<span class="strong"><strong class="calibre2">   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </strong></span>
<span class="strong"><strong class="calibre2">  1.000   1.000   1.000   1.097   1.000   2.000 </strong></span>

<span class="strong"><strong class="calibre2">summary of quality measures:</strong></span>
<span class="strong"><strong class="calibre2">    support       </strong></span>
<span class="strong"><strong class="calibre2"> Min.   :0.05236  </strong></span>
<span class="strong"><strong class="calibre2"> 1st Qu.:0.05831  </strong></span>
<span class="strong"><strong class="calibre2"> Median :0.07565  </strong></span>
<span class="strong"><strong class="calibre2"> Mean   :0.09212  </strong></span>
<span class="strong"><strong class="calibre2"> 3rd Qu.:0.10173  </strong></span>
<span class="strong"><strong class="calibre2"> Max.   :0.25552  </strong></span>

<span class="strong"><strong class="calibre2">includes transaction ID lists: FALSE </strong></span>

<span class="strong"><strong class="calibre2">mining info:</strong></span>
<span class="strong"><strong class="calibre2">      data ntransactions support</strong></span>
<span class="strong"><strong class="calibre2"> Groceries          9835    0.05</strong></span>
</pre></div></li><li class="listitem" value="3">Lastly, we<a id="id847" class="calibre1"/> can examine the top ten support frequent itemsets:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; inspect(sort(frequentsets,by="support")[1:10])</strong></span>
<span class="strong"><strong class="calibre2">   items                 support</strong></span>
<span class="strong"><strong class="calibre2">1  {whole milk}       0.25551601</strong></span>
<span class="strong"><strong class="calibre2">2  {other vegetables} 0.19349263</strong></span>
<span class="strong"><strong class="calibre2">3  {rolls/buns}       0.18393493</strong></span>
<span class="strong"><strong class="calibre2">4  {soda}             0.17437722</strong></span>
<span class="strong"><strong class="calibre2">5  {yogurt}           0.13950178</strong></span>
<span class="strong"><strong class="calibre2">6  {bottled water}    0.11052364</strong></span>
<span class="strong"><strong class="calibre2">7  {root vegetables}  0.10899847</strong></span>
<span class="strong"><strong class="calibre2">8  {tropical fruit}   0.10493137</strong></span>
<span class="strong"><strong class="calibre2">9  {shopping bags}    0.09852567</strong></span>
<span class="strong"><strong class="calibre2">10 {sausage}          0.09395018</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Mining frequent itemsets with Eclat">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec411" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre7">In this recipe, we introduce another algorithm, Eclat, to perform frequent itemset generation. Though Apriori is a straightforward and easy to understand association mining method, the algorithm has the disadvantage of generating huge candidate sets and performs inefficiently in support counting, for it takes multiple scans of databases. In contrast to Apriori, Eclat uses equivalence classes, depth-first searches, and set intersections, which greatly improves the speed in support counting.</p><p class="calibre7">In Apriori, the algorithm uses a horizontal data layout to store transactions. On the other hand, Eclat uses a vertical data layout to store a list of transaction IDs (<code class="email">tid</code>) for each item. Then, Eclat determines the support of any k+1-itemset by intersecting tid-lists of two k-itemsets. Lastly, Eclat utilizes frequent itemsets to generate association rules:</p><div class="mediaobject"><img src="../images/00214.jpeg" alt="How it works..." class="calibre9"/><div class="caption"><p class="calibre12">An illustration of Eclat algorithm</p></div></div><p class="calibre10"> </p><p class="calibre7">Similar <a id="id848" class="calibre1"/>to the recipe using the Apriori algorithm, we can use the <code class="email">eclat</code> function to generate a frequent itemset with a given support (assume support = 2 in this case) and maximum length.</p><div class="mediaobject"><img src="../images/00215.jpeg" alt="How it works..." class="calibre9"/><div class="caption"><p class="calibre12">Generating frequent itemset</p></div></div><p class="calibre10"> </p><p class="calibre7">We can then use the <code class="email">summary</code> function to obtain summary statistics, which include: most frequent items, itemset length distributions, summary of quality measures, and mining information. Finally, we can sort frequent itemsets by the support and inspect the top ten support frequent itemsets.</p></div></div>

<div class="book" title="Mining frequent itemsets with Eclat">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec412" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">Besides <a id="id849" class="calibre1"/>Apriori and Eclat, another popular association mining algorithm is <span class="strong"><strong class="calibre2">FP-Growth</strong></span>. Similar to Eclat, this takes a depth-first search to count supports. However, there is no existing R package that you can download from CRAN that contains this algorithm. However, if you are <a id="id850" class="calibre1"/>interested in knowing how to apply the FP-growth algorithm in your transaction dataset, you can refer to Christian Borgelt's page at <a class="calibre1" href="http://www.borgelt.net/fpgrowth.html">http://www.borgelt.net/fpgrowth.html</a> for more information.</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating transactions with temporal information"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec119" class="calibre1"/>Creating transactions with temporal information</h1></div></div></div><p class="calibre7">In addition to mining interesting associations within the transaction database, we can mine<a id="id851" class="calibre1"/> interesting sequential patterns using transactions with temporal information. In the following recipe, we demonstrate how to create transactions with temporal information.</p></div>

<div class="book" title="Creating transactions with temporal information">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec413" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">In this recipe, we will generate transactions with temporal information. We can use the generated transactions as the input source for frequent sequential pattern mining.</p></div></div>

<div class="book" title="Creating transactions with temporal information">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec414" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre7">Perform the following steps to create transactions with temporal information:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, you need to install and load the package <code class="email">arulesSequences</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; install.packages("arulesSequences")</strong></span>
<span class="strong"><strong class="calibre2">&gt; library(arulesSequences)</strong></span>
</pre></div></li><li class="listitem" value="2">You can first create a list with purchasing records:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; tmp_data=list(c("A"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("A","B","C"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("A","C"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("D"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("C","F"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("A","D"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("C"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("B","C"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("A","E"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("E","F"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("A","B"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("D","F"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("C"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("B"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("E"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("G"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("A","F"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("C"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("B"),</strong></span>
<span class="strong"><strong class="calibre2">+                c("C"))</strong></span>
</pre></div></li><li class="listitem" value="3">You <a id="id852" class="calibre1"/>can then turn the list into transactions and add temporal information:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt;names(tmp_data) = paste("Tr",c(1:20), sep = "")</strong></span>
<span class="strong"><strong class="calibre2">&gt;trans =  as(tmp_data,"transactions")</strong></span>
<span class="strong"><strong class="calibre2">&gt;transactionInfo(trans)$sequenceID=c(1,1,1,1,1,2,2,2,2,3,3,3,3,3,4,4,4,4,4,4)</strong></span>
<span class="strong"><strong class="calibre2">&gt;transactionInfo(trans)$eventID=c(10,20,30,40,50,10,20,30,40,10,20,30,40,50,10,20,30,40,50,60)</strong></span>
<span class="strong"><strong class="calibre2">&gt; trans</strong></span>
<span class="strong"><strong class="calibre2">transactions in sparse format with</strong></span>
<span class="strong"><strong class="calibre2"> 20 transactions (rows) and</strong></span>
<span class="strong"><strong class="calibre2"> 7 items (columns)</strong></span>
</pre></div></li><li class="listitem" value="4">Next, you can use the <code class="email">inspect</code> function to inspect the transactions:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; inspect(head(trans))</strong></span>
<span class="strong"><strong class="calibre2">  items transactionID sequenceID eventID</strong></span>
<span class="strong"><strong class="calibre2">1 {A}             Tr1          1      10</strong></span>
<span class="strong"><strong class="calibre2">2 {A,                                   </strong></span>
<span class="strong"><strong class="calibre2">   B,                                   </strong></span>
<span class="strong"><strong class="calibre2">   C}             Tr2          1      20</strong></span>
<span class="strong"><strong class="calibre2">3 {A,                                   </strong></span>
<span class="strong"><strong class="calibre2">   C}             Tr3          1      30</strong></span>
<span class="strong"><strong class="calibre2">4 {D}             Tr4          1      40</strong></span>
<span class="strong"><strong class="calibre2">5 {C,                                   </strong></span>
<span class="strong"><strong class="calibre2">   F}             Tr5          1      50</strong></span>
<span class="strong"><strong class="calibre2">6 {A,                                   </strong></span>
<span class="strong"><strong class="calibre2">   D}             Tr6          2      10</strong></span>
</pre></div></li><li class="listitem" value="5">You can then obtain the summary information of the transactions with the temporal information:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; summary(trans)</strong></span>
<span class="strong"><strong class="calibre2">transactions as itemMatrix in sparse format with</strong></span>
<span class="strong"><strong class="calibre2"> 20 rows (elements/itemsets/transactions) and</strong></span>
<span class="strong"><strong class="calibre2"> 7 columns (items) and a density of 0.2214286 </strong></span>

<span class="strong"><strong class="calibre2">most frequent items:</strong></span>
<span class="strong"><strong class="calibre2">      C       A       B       F       D (Other) </strong></span>
<span class="strong"><strong class="calibre2">      8       7       5       4       3       4 </strong></span>

<span class="strong"><strong class="calibre2">element (itemset/transaction) length distribution:</strong></span>
<span class="strong"><strong class="calibre2">sizes</strong></span>
<span class="strong"><strong class="calibre2"> 1  2  3 </strong></span>
<span class="strong"><strong class="calibre2">10  9  1 </strong></span>

<span class="strong"><strong class="calibre2">   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </strong></span>
<span class="strong"><strong class="calibre2">   1.00    1.00    1.50    1.55    2.00    3.00 </strong></span>

<span class="strong"><strong class="calibre2">includes extended item information - examples:</strong></span>
<span class="strong"><strong class="calibre2">  labels</strong></span>
<span class="strong"><strong class="calibre2">1      A</strong></span>
<span class="strong"><strong class="calibre2">2      B</strong></span>
<span class="strong"><strong class="calibre2">3      C</strong></span>

<span class="strong"><strong class="calibre2">includes extended transaction information - examples:</strong></span>
<span class="strong"><strong class="calibre2">  transactionID sequenceID eventID</strong></span>
<span class="strong"><strong class="calibre2">1           Tr1          1      10</strong></span>
<span class="strong"><strong class="calibre2">2           Tr2          1      20</strong></span>
<span class="strong"><strong class="calibre2">3           Tr3          1      30</strong></span>
</pre></div></li><li class="listitem" value="6">You <a id="id853" class="calibre1"/>can also read the transaction data in a basket format:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; zaki=read_baskets(con = system.file("misc", "zaki.txt", package = "arulesSequences"), info = c("sequenceID","eventID","SIZE"))</strong></span>
<span class="strong"><strong class="calibre2">&gt; as(zaki, "data.frame")</strong></span>
<span class="strong"><strong class="calibre2">   transactionID.sequenceID transactionID.eventID transactionID.SIZE     items</strong></span>
<span class="strong"><strong class="calibre2">1                         1                    10                  2     {C,D}</strong></span>
<span class="strong"><strong class="calibre2">2                         1                    15                  3   {A,B,C}</strong></span>
<span class="strong"><strong class="calibre2">3                         1                    20                  3   {A,B,F}</strong></span>
<span class="strong"><strong class="calibre2">4                         1                    25                  4 {A,C,D,F}</strong></span>
<span class="strong"><strong class="calibre2">5                         2                    15                  3   {A,B,F}</strong></span>
<span class="strong"><strong class="calibre2">6                         2                    20                  1       {E}</strong></span>
<span class="strong"><strong class="calibre2">7                         3                    10                  3   {A,B,F}</strong></span>
<span class="strong"><strong class="calibre2">8                         4                    10                  3   {D,G,H}</strong></span>
<span class="strong"><strong class="calibre2">9                         4                    20                  2     {B,F}</strong></span>
<span class="strong"><strong class="calibre2">10                        4                    25                  3   {A,G,H}</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Creating transactions with temporal information">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec415" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre7">Before mining frequent sequential patterns, you are required to create transactions with the <a id="id854" class="calibre1"/>temporal information. In this recipe, we introduce two methods to obtain transactions with temporal information. In the first method, we create a list of transactions, and assign a transaction ID for each transaction. We use the <code class="email">as</code> function to transform the list data into a transaction dataset. We then add <code class="email">eventID</code> and <code class="email">sequenceID</code> as temporal information; <code class="email">sequenceID</code> is the sequence that the event belongs to, and <code class="email">eventID</code> indicates when the event occurred. After generating transactions with temporal information, one can use this dataset for frequent sequential pattern mining.</p><p class="calibre7">In addition to creating your own transactions with temporal information, if you already have data stored in a text file, you can use the <code class="email">read_basket</code> function from <code class="email">arulesSequences</code> to read the transaction data into the basket format. We can also read the transaction dataset for further frequent sequential pattern mining.</p></div></div>

<div class="book" title="Creating transactions with temporal information">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec416" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">arulesSequences</code> function provides two additional data structures, <code class="email">sequences</code> and <code class="email">timedsequences</code>, to present pure sequence data and sequence data with the time information. For those who are interested in these two collections, please use the help function to view the following documents:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; help("sequences-class")</strong></span>
<span class="strong"><strong class="calibre2">&gt; help("timedsequences-class")</strong></span>
</pre></div></li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Mining frequent sequential patterns with cSPADE"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec120" class="calibre1"/>Mining frequent sequential patterns with cSPADE</h1></div></div></div><p class="calibre7">In contrast to association mining, which only discovers relationships between itemsets, we <a id="id855" class="calibre1"/>may be interested in exploring patterns shared among transactions where a set of itemsets occurs sequentially.</p><p class="calibre7">One of the most famous frequent sequential pattern mining algorithms is the <span class="strong"><strong class="calibre2">Sequential PAttern Discovery using Equivalence classes</strong></span> (<span class="strong"><strong class="calibre2">SPADE</strong></span>) algorithm, which employs the characteristics <a id="id856" class="calibre1"/>of a vertical database to perform an intersection on an ID list with an efficient lattice search and allows us to place constraints on mined sequences. In this recipe, we will demonstrate how to use cSPADE to mine frequent sequential patterns.</p></div>

<div class="book" title="Mining frequent sequential patterns with cSPADE">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec417" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">In this recipe, you have to complete the previous recipes by generating transactions with the temporal information and have it stored in the variable <code class="email">trans</code>.</p></div></div>

<div class="book" title="Mining frequent sequential patterns with cSPADE">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec418" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre7">Perform the following steps to mine the frequent sequential patterns:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, you can use the <code class="email">cspade</code> function to generate frequent sequential patterns:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; s_result=cspade(trans,parameter = list(support = 0.75),control = list(verbose = TRUE))</strong></span>
</pre></div></li><li class="listitem" value="2">You can then examine the summary of the frequent sequential patterns:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; summary(s_result)</strong></span>
<span class="strong"><strong class="calibre2">set of 14 sequences with</strong></span>

<span class="strong"><strong class="calibre2">most frequent items:</strong></span>
<span class="strong"><strong class="calibre2">      C       A       B       D       E (Other) </strong></span>
<span class="strong"><strong class="calibre2">      8       5       5       2       1       1 </strong></span>

<span class="strong"><strong class="calibre2">most frequent elements:</strong></span>
<span class="strong"><strong class="calibre2">    {C}     {A}     {B}     {D}     {E} (Other) </strong></span>
<span class="strong"><strong class="calibre2">      8       5       5       2       1       1 </strong></span>

<span class="strong"><strong class="calibre2">element (sequence) size distribution:</strong></span>
<span class="strong"><strong class="calibre2">sizes</strong></span>
<span class="strong"><strong class="calibre2">1 2 3 </strong></span>
<span class="strong"><strong class="calibre2">6 6 2 </strong></span>

<span class="strong"><strong class="calibre2">sequence length distribution:</strong></span>
<span class="strong"><strong class="calibre2">lengths</strong></span>
<span class="strong"><strong class="calibre2">1 2 3 </strong></span>
<span class="strong"><strong class="calibre2">6 6 2 </strong></span>

<span class="strong"><strong class="calibre2">summary of quality measures:</strong></span>
<span class="strong"><strong class="calibre2">    support      </strong></span>
<span class="strong"><strong class="calibre2"> Min.   :0.7500  </strong></span>
<span class="strong"><strong class="calibre2"> 1st Qu.:0.7500  </strong></span>
<span class="strong"><strong class="calibre2"> Median :0.7500  </strong></span>
<span class="strong"><strong class="calibre2"> Mean   :0.8393  </strong></span>
<span class="strong"><strong class="calibre2"> 3rd Qu.:1.0000  </strong></span>
<span class="strong"><strong class="calibre2"> Max.   :1.0000  </strong></span>

<span class="strong"><strong class="calibre2">includes transaction ID lists: FALSE </strong></span>

<span class="strong"><strong class="calibre2">mining info:</strong></span>
<span class="strong"><strong class="calibre2">  data ntransactions nsequences support</strong></span>
<span class="strong"><strong class="calibre2"> trans            20          4    0.75</strong></span>
</pre></div></li><li class="listitem" value="3">Transform<a id="id857" class="calibre1"/> a generated sequence format data back to the data frame:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; as(s_result, "data.frame")</strong></span>
<span class="strong"><strong class="calibre2">        sequence support</strong></span>
<span class="strong"><strong class="calibre2">1          &lt;{A}&gt;    1.00</strong></span>
<span class="strong"><strong class="calibre2">2          &lt;{B}&gt;    1.00</strong></span>
<span class="strong"><strong class="calibre2">3          &lt;{C}&gt;    1.00</strong></span>
<span class="strong"><strong class="calibre2">4          &lt;{D}&gt;    0.75</strong></span>
<span class="strong"><strong class="calibre2">5          &lt;{E}&gt;    0.75</strong></span>
<span class="strong"><strong class="calibre2">6          &lt;{F}&gt;    0.75</strong></span>
<span class="strong"><strong class="calibre2">7      &lt;{A},{C}&gt;    1.00</strong></span>
<span class="strong"><strong class="calibre2">8      &lt;{B},{C}&gt;    0.75</strong></span>
<span class="strong"><strong class="calibre2">9      &lt;{C},{C}&gt;    0.75</strong></span>
<span class="strong"><strong class="calibre2">10     &lt;{D},{C}&gt;    0.75</strong></span>
<span class="strong"><strong class="calibre2">11 &lt;{A},{C},{C}&gt;    0.75</strong></span>
<span class="strong"><strong class="calibre2">12     &lt;{A},{B}&gt;    1.00</strong></span>
<span class="strong"><strong class="calibre2">13     &lt;{C},{B}&gt;    0.75</strong></span>
<span class="strong"><strong class="calibre2">14 &lt;{A},{C},{B}&gt;    0.75</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Mining frequent sequential patterns with cSPADE">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec419" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre7">The <a id="id858" class="calibre1"/>object of sequential pattern mining is to discover sequential relationships or patterns in transactions. You can use the pattern mining result to predict future events, or recommend items to users.</p><p class="calibre7">One popular <a id="id859" class="calibre1"/>method of sequential pattern mining is SPADE. SPADE uses a vertical data layout to store a list of IDs. In these, each input sequence in the database is called SID, and each event in a given input sequence is called EID. The process of SPADE is performed by generating patterns level-wisely by an Apriori candidate generation. In detail, SPADE generates subsequent n-sequences from joining (n-1)-sequences from the intersection of ID lists. If the number of sequences is greater than the <span class="strong"><strong class="calibre2">minimum support</strong></span> (<span class="strong"><strong class="calibre2">minsup</strong></span>), we can consider the sequence to be frequent enough. The algorithm stops <a id="id860" class="calibre1"/>until the process cannot find more frequent sequences:</p><div class="mediaobject"><img src="../images/00216.jpeg" alt="How it works..." class="calibre9"/><div class="caption"><p class="calibre12">An illustration of SPADE algorithm</p></div></div><p class="calibre10"> </p><p class="calibre7">In this recipe, we illustrate how to use a frequent sequential pattern mining algorithm, cSPADE, to mine frequent sequential patterns. First, as we have transactions with temporal information loaded in the variable <code class="email">trans</code>, we can use the <code class="email">cspade</code> function with the support over 0.75 to generate frequent sequential patterns in the <code class="email">sequences</code> format. We can then obtain summary information, such as most frequent items, sequence size distributions, a summary of quality measures, and mining information. Lastly, we can transform<a id="id861" class="calibre1"/> the generated <code class="email">sequence</code> information back to the data frame format, so we can examine the sequence and support of frequent sequential patterns with the support over 0.75.</p></div></div>

<div class="book" title="Mining frequent sequential patterns with cSPADE">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec420" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">If you are interested in the concept and design of the SPADE algorithm, you can refer to the original published paper: M. J. Zaki. (2001). <span class="strong"><em class="calibre8">SPADE: An Efficient Algorithm for Mining Frequent Sequences. Machine Learning Journal</em></span>, 42, 31–60.</li></ul></div></div></div></body></html>