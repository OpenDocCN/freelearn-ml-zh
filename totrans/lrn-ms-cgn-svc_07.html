<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Building Recommendation Systems for Businesses"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Building Recommendation Systems for Businesses</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>"By leveraging Azure Machine Learning and the Recommendations API, we have launched a new Personalized Commerce Experience for retailers that grows shopper conversion and engagement on any channel."</em></span>
</p><p> – Frank Kouretas, Chief Product Officer at Orckestra</p></blockquote></div><p>In the previous chapter, we covered the remaining language APIs. In this chapter, we will look at the Recommendations Solution template. This is a template for Microsoft Azure that contains the resources required to run Recommendations Solution. This is a solution well suited for e-commerce applications, where you can recommend different items based on different criteria. Recommending items in an online store is a process that can be very time-consuming if it is done by following a rule set. The Recommendations Solution allows us to utilize the power of machine learning to get good recommendations, potentially increasing the number of sales.</p><p>This chapter will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Deploying the Recommendations Solution template</li><li class="listitem" style="list-style-type: disc">Training the recommendation model</li><li class="listitem" style="list-style-type: disc">Consuming recommendations</li></ul></div><div class="section" title="Providing personalized recommendations"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec40"/>Providing personalized recommendations</h1></div></div></div><p>If you run an e-commerce site, a feature that is nice for your customers to have is recommendations. Using the Recommendation Solution, you can easily add this. Utilizing Microsoft Azure Machine Learning, the API can be trained to recognize items that should be recommended.</p><p>There <a class="indexterm" id="id389"/>are two common scenarios for recommendations, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Item-to-Item Recommendations (I2I)</strong></span>: I2I is<a class="indexterm" id="id390"/> the scenario where certain items are often viewed after <a class="indexterm" id="id391"/>other items. Typically, this will be in the form of <span class="emphasis"><em>people who visited this item also visited this other item</em></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Customer-to-Item Recommendations (U2I)</strong></span>: U2I is the scenario <a class="indexterm" id="id392"/>where you utilize a customer's previous actions <a class="indexterm" id="id393"/>to recommend items. If you sell movies, for example, then you can recommend other movies based on a customer's previous movie choices.</li></ul></div><p>The<a class="indexterm" id="id394"/> general steps to use the Recommendation Solution are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Deploy the <a class="indexterm" id="id395"/>template in Azure</li><li class="listitem">Import the catalog data (the items in your e-commerce site)</li><li class="listitem">Import usage data</li><li class="listitem">Train a recommendation model</li><li class="listitem">Consume recommendations</li></ol></div><p>If you have not already done so, you should sign up for an API key at <a class="ulink" href="https://portal.azure.com">https://portal.azure.com</a>.</p><div class="section" title="Deploying the Recommendation Solution template in Azure"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec57"/>Deploying the Recommendation Solution template in Azure</h2></div></div></div><p>To <a class="indexterm" id="id396"/>deploy <a class="indexterm" id="id397"/>the Recommendations Solution, you must have an active Microsoft Azure subscription.</p><p>Head over to <a class="ulink" href="https://github.com/Microsoft/Product-Recommendations/tree/master/deploy">https://github.com/Microsoft/Product-Recommendations/tree/master/deploy</a> to start the deployment. Click on <span class="strong"><strong>Deploy to Azure</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Deploying the Recommendation Solution template in Azure" src="graphics/B12373_07_01.jpg"/></div><p>This<a class="indexterm" id="id398"/> will take you to the following <a class="indexterm" id="id399"/>page in Microsoft Azure:</p><div class="mediaobject"><img alt="Deploying the Recommendation Solution template in Azure" src="graphics/B12373_07_02.jpg"/></div><p>Enter the<a class="indexterm" id="id400"/> required information, accept <a class="indexterm" id="id401"/>the terms and conditions, and click on <span class="strong"><strong>Purchase</strong></span>. This will start the process of deploying the required resources for the Recommendations Solution.</p><p>After a few minutes, the deployment is done. You are now ready to upload data to train a model.</p></div><div class="section" title="Importing catalog data"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec58"/>Importing catalog data</h2></div></div></div><p>With the solution deployed, we <a class="indexterm" id="id402"/>can add catalog data. This is where you would typically add items from your database. Items need to be uploaded as files. The files need to be in CSV format.</p><p>The following table describes the data that is required for each item in your catalog:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Item ID</p>
</td><td style="text-align: left" valign="top">
<p>A unique identifier for a given item</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Item name</p>
</td><td style="text-align: left" valign="top">
<p>The name of the item</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Item category</p>
</td><td style="text-align: left" valign="top">
<p>The category for the item, such as hardware, software, book genre, and so on</p>
</td></tr></tbody></table></div><p>In addition, there are a few data fields that are optional. These are described in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Description</p>
</td><td style="text-align: left" valign="top">
<p>A description of the item</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Feature list</p>
</td><td style="text-align: left" valign="top">
<p>A comma-separated feature list that can enhance recommendations</p>
</td></tr></tbody></table></div><p>A file that has all the data included may have items that look like the following:</p><div class="informalexample"><pre class="programlisting">C9F00168, Kiruna Flip Cover, Accessories, Description of item, compatibility = lumia, hardware type = mobile</pre></div><p>It is typically better to add features as this improves the recommendations. Any new item that has little usage is unlikely to be recommended if no features exist.</p><p>Features should be categorical. This means that a feature can be a price range. A price alone would not serve as a good feature.</p><p>You can add up to 20 features per item. When a catalog containing features for items is uploaded, you need to perform a rank build. This will rank each feature, where features of a higher ranking will typically be better to use.</p><p>The code example for<a class="indexterm" id="id403"/> this chapter contains a sample catalog. We will use this for the following example. Alternatively, you can download some data from Microsoft from <a class="ulink" href="http://aka.ms/RecoSampleData">http://aka.ms/RecoSampleData</a>. We want to use the data from <code class="literal">MsStoreData.zip</code>.</p><p>With the files downloaded, we can upload the catalog to our storage. This can be done by heading to your newly created storage account and creating a new blob container for the catalog, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Importing catalog data" src="graphics/B12373_07_03.jpg"/></div><p>Click on <span class="strong"><strong>Upload</strong></span>, browse to the sample files you downloaded, and choose the <code class="literal">catalog.csv</code> file. This will upload the catalog.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>Note that the catalog file is not required, but it is recommended that you upload it in order to supply it to the model.</p><p>The maximum number of items in a catalog is 100,000. Any given catalog file cannot be larger than 200 MB. If your file is larger, and you still have more items, you can upload several files.</p></div></div></div><div class="section" title="Importing usage data"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec59"/>Importing usage data</h2></div></div></div><p>The next step we need to <a class="indexterm" id="id404"/>make is to upload usage data. This is a file describing all the transactions from your customers in the past. The file contains rows, with transactions, where each transaction is a comma-separated line containing data.</p><p>The required data fields are as follows:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>User ID</p>
</td><td style="text-align: left" valign="top">
<p>A unique identifier for each customer</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Item ID</p>
</td><td style="text-align: left" valign="top">
<p>A unique identifier for items that correlate to the catalog</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Time</p>
</td><td style="text-align: left" valign="top">
<p>The time of the transaction</p>
</td></tr></tbody></table></div><p>In addition, it is possible to have a field called <code class="literal">Event</code>. This describes the type of transaction. The allowed values for this field are <code class="literal">Click</code>, <code class="literal">RecommendationClick</code>, <code class="literal">AddShopCart</code>, <code class="literal">RemoveShopCart</code>, and <code class="literal">Purchase</code>.</p><p>Given the preceding example from the catalog, a line in the usage file may look as follows:</p><div class="informalexample"><pre class="programlisting">    00030000D16C4237, C9F00168, 2015/08/04 T 11:02:37, Purchase</pre></div><p>The maximum file size for a usage file is 200 MB.</p><p>The quality of recommendations relies on the amount of usage data. Typically, you should have about 20 transactions registered per item. This means that if you have 100 items in the catalog, you should aim for 2,000 transactions in the usage file.</p><p>Note that the current maximum number of transactions that the API accepts is 5 million. If new transactions are added above this maximum, the oldest data will be deleted.</p><p>Again, you can find an example usage file at <a class="ulink" href="http://aka.ms/RecoSampleData">http://aka.ms/RecoSampleData</a>. Create another blob container called <code class="literal">usage</code> and click on <span class="strong"><strong>Upload</strong></span>. Upload all the usage files from the sample folder.</p></div><div class="section" title="Training a model"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec60"/>Training a model</h2></div></div></div><p>With the catalog and usage <a class="indexterm" id="id405"/>data in place, it is time to train a model.</p><div class="section" title="Starting to train"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec48"/>Starting to train</h3></div></div></div><p>To start a training process, we need<a class="indexterm" id="id406"/> to make an API call to an endpoint on the newly created app service. This can be done using a tool, such as Postman, or through your own application. We will use Postman for the purposes of this book.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>To <a class="indexterm" id="id407"/>download Postman, please visit <a class="ulink" href="https://www.getpostman.com/">https://www.getpostman.com/</a>.</p></div></div><p>The training process can be started by sending a POST request to the following URL:</p><div class="informalexample"><pre class="programlisting">https://&lt;service_name&gt;.azurewebsites.net/api/models</pre></div><p>The request must include a header, <code class="literal">x-api-key</code>, with your API key. It must also include another header, <code class="literal">Content-Type</code>, which should be set to <code class="literal">application/json</code>.</p><p>In addition, the <a class="indexterm" id="id408"/>request must contain a body containing the following:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Mandatory</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">description</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>Textual description.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">blobContainerName</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>Name of the blob container where the catalog and usage data are stored.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">usageRelativePath</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>Relative path to either a virtual directory that contains the usage file(s) or a specific usage file to be used for training.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">catalogFileRelativePath</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>Relative path to the catalog file.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">evaluationUsageRelativePath</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>Relative path to either a virtual directory that contains the usage file(s) or to a specific usage file to be used for evaluation.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">supportThreshold</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>How conservative the model is, measured in the number of cooccurrences of items to be considered for modeling.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">cooccurrenceUnit</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>Indicates how to group usage events before counting cooccurrence.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">similarityFunction</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>Defines the similarity function to be used. Can be Jaccard, Cooccurrence, or Lift.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">enableColdItemPlacement</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This will be either <code class="literal">true</code> or <code class="literal">false</code>. Indicates whether recommendations should push cold items via feature similarity.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">enableColdToColdRecommendations</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This will be either <code class="literal">true</code> or <code class="literal">false</code>. Indicates whether or not the similarity between pairs of cold items should be calculated.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">enableUserAffinity</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This will be either <code class="literal">true</code> or <code class="literal">false</code>. Defines whether the event type and time of event should be considered as inputs to the result.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">enableBackfilling</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This will be either <code class="literal">true</code> or <code class="literal">false</code>. This will backfill with popular items if not enough relevant items are returned.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">allowSeedItemsInRecommendations</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This will be either <code class="literal">true</code> or <code class="literal">false</code>. Determines whether input items can be returned as results.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">decayPeriodInDays</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>The decay period in days. The longer the time since an event has occurred, the less weight the event will have.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">enableUserToItemRecommendations</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This will be either <code class="literal">true</code> or <code class="literal">false</code>. If <code class="literal">true</code>, the user ID will be taken into account when personalized recommendations are requested.</p>
</td></tr></tbody></table></div><p>A <a class="indexterm" id="id409"/>successful call may yield the following result:</p><div class="mediaobject"><img alt="Starting to train" src="graphics/B12373_07_04.jpg"/></div><p>The <code class="literal">id</code> field returned can be used to check the training status.</p></div><div class="section" title="Verifying the completion of training"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec49"/>Verifying the completion of training</h3></div></div></div><p>Using the ID returned in the<a class="indexterm" id="id410"/> previous request, we can now run a <code class="literal">GET</code> request to the following endpoint:</p><div class="informalexample"><pre class="programlisting">https://&lt;service_name&gt;.azurewebsites.net/api/models/&lt;model_id&gt;</pre></div><p>This request requires a header, <code class="literal">x-api-key</code>, containing your API key. A successful request may give the following response:</p><div class="mediaobject"><img alt="Verifying the completion of training" src="graphics/B12373_07_05.jpg"/><div class="caption"><p>Response of GET request</p></div></div><p>As you can see, a <code class="literal">modelStatus</code> field is presented. Once this is <code class="literal">Completed</code>, the model is trained and ready to <a class="indexterm" id="id411"/>be used. You will also be presented with statistics, such as the duration of training, among other details.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>If you prefer to use a user interface for the model training, you can visit https://&lt;your_service&gt;.azurewebsites.net/ui.</p></div></div></div></div><div class="section" title="Consuming recommendations"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec61"/>Consuming recommendations</h2></div></div></div><p>To <a class="indexterm" id="id412"/>use the recommendation models we just created, we will create a new example application. Create this using the MVVM template we created previously.</p><p>At the time of writing, there is no client package for the recommendations API. This means that we need to rely on web requests, as we saw in <a class="link" href="ch06.html" title="Chapter 6. Understanding Text">Chapter 6</a>, <span class="emphasis"><em>Understanding Text</em></span>. To speed up the development time, copy the <code class="literal">WebRequest.cs</code> file from the example code in <a class="link" href="ch06.html" title="Chapter 6. Understanding Text">Chapter 6</a>, <span class="emphasis"><em>Understanding Text</em></span>. Paste this file into the <code class="literal">Model</code> folder, and make sure that you update the namespace.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>Remember to add references to System.Web and System.Runtime.Serialization.</p></div></div><p>As there is no need for much UI, we are going to add everything in the <code class="literal">MainView.xaml</code> file. We are going to need two <code class="literal">ComboBox</code> elements. These will list our recommendation models and catalog items. We also need a <code class="literal">Button</code> element to get the recommendations and a <code class="literal">TextBox</code> element to show the resultant recommendations.</p><p>The corresponding <code class="literal">ViewModel</code>, <code class="literal">MainViewModel.cs</code>, will need properties to correspond to the UI elements. Add an <code class="literal">ObservableCollection</code> of a <code class="literal">RecommendationModel </code>type to hold our models. We will look at the type in a bit. We need a property of a <code class="literal">RecommendationModel </code>type to hold the selected model. Add an <code class="literal">ObservableCollection</code> property of a <code class="literal">Product </code>type with a corresponding <code class="literal">Product</code> property for the available and selected properties. We will also need a <code class="literal">string</code> property for the results and an <code class="literal">ICommand</code> property for our button.</p><p>Add a <code class="literal">private</code> member of a <code class="literal">WebRequest </code>type so that we can call the API.</p><p>Add a new file called <code class="literal">Product</code> in the <code class="literal">Model</code> folder. To use the items from our catalog, we will load the catalog file into the application, creating a <code class="literal">Product</code> for each item. Ensure that <code class="literal">Product</code> looks as follows:</p><div class="informalexample"><pre class="programlisting">    public class Product { 
        public string Id { get; set; } 
        public string Name { get; set; } 
        public string Category { get; set; }
        public Product(string id, string name, string category) { 
            Id = id; 
            Name = name; 
            Category = category; 
        } 
    } </pre></div><p>We<a class="indexterm" id="id413"/> need the <code class="literal">Id</code> of an item, as well as the <code class="literal">Name </code>and the <code class="literal">Category</code>.</p><p>The constructor should create a <code class="literal">WebRequest</code> object, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    public MainViewModel() 
    { 
        _webRequest = new WebRequest ("https://&lt;YOUR_WEB_SERVICE&gt;.azurewebsites.net/api/models/", "API_KEY_HERE"); 
        RecommendCommand = new DelegateCommand(RecommendBook, CanRecommendBook); 
 
        Initialize(); 
    } </pre></div><p>When we create the <code class="literal">WebRequest</code> object, we specify the recommendation endpoint and our API key. The <code class="literal">RecommendCommand</code> phrase is the <code class="literal">ICommand</code> object, as a <code class="literal">DelegateCommand</code>. We need to specify the action to be executed and the conditions under which we are allowed to execute the command. We should be allowed to execute the command if we have selected a recommendation model and a product.</p><p>The <code class="literal">Initialize</code> phrase will make sure that we fetch our recommendation models and products, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    private async void Initialize() { 
        await GetModels(); 
        GetProducts(); 
    } </pre></div><p>The <code class="literal">GetModels</code> method will make a call to the API, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    private async Task GetModels() 
    { 
        List&lt;RecommandationModel&gt; models = await _webRequest.GetModels(HttpMethod.Get); </pre></div><p>This call is a <code class="literal">GET</code> request, so we specify this in <code class="literal">GetModels</code>. A successful call should result in a JSON response that we then deserialize into a <code class="literal">RecommendationModel</code> object. This is a data contract, so add a file called <code class="literal">Models.cs</code> in a folder called <code class="literal">Contracts</code>.</p><p>A <a class="indexterm" id="id414"/>successful result will give the following output:</p><div class="informalexample"><pre class="programlisting">[
   { 
      "id": "string",
      "description": "string",
      "creationTime": "string",
      "modelStatus": "string"
   }
   {...}
   {...}
] </pre></div><p>We have an array of <code class="literal">models</code>. Each item in this array has an <code class="literal">id</code>, <code class="literal">name</code>, <code class="literal">description</code>, <code class="literal">createdDateTime</code>, <code class="literal">activeBuildId</code>, and <code class="literal">catalogDisplayName</code>. Make sure that the <code class="literal">RecommendationModels</code> class contains this data.</p><p>If the call succeeds, we add the models to the <code class="literal">ObservableCollection</code> of available models, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">        foreach (RecommandationModel model in models) { 
            AvailableModels.Add(model); 
        }          
        SelectedModel = AvailableModels.FirstOrDefault(); 
    } </pre></div><p>When all items are added, we set the <code class="literal">SelectedModel</code> to the first available option.</p><p>To add the items from our catalog, we need to read from the catalog file. In the example code provided with the book, this file is added to the project and copied to the output directory. The <code class="literal">GetProducts</code> method will look as follows:</p><div class="informalexample"><pre class="programlisting">    private void GetProducts() { 
        try { 
            var reader = new StreamReader (File.OpenRead("catalog.csv")); 
 
            while(!reader.EndOfStream) { 
                string line = reader.ReadLine(); 
                var productInfo = line.Split(','); 
 
                AvailableProducts.Add(new Product(productInfo[0], productInfo[1], productInfo[2])); 
            } 
 
            SelectedProduct = AvailableProducts.FirstOrDefault(); 
        } 
        catch(Exception ex) { 
            Debug.WriteLine(ex.Message); 
        } 
    } </pre></div><p>This is a basic file operation, reading in each line from the catalog. For each item, we get the required information, creating a <code class="literal">Product</code> for each item. This is then added to the <code class="literal">AvailableProducts</code> in the <code class="literal">ObservableCollection</code> property, and the <code class="literal">SelectedProduct</code> is the first available.</p><p>Now<a class="indexterm" id="id415"/> that we have our recommendation models and our products, we can execute the recommendation request, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    private async void RecommendProduct(object obj) 
    {  
        List&lt;RecommendedItem&gt; recommendations = await _webRequest.RecommendItem(HttpMethod.Get, $"{SelectedModel.id}/recommend?item={SelectedProduct.Id}"); </pre></div><p>The call to get the recommendations is a <code class="literal">GET</code> request. This requires us to add <code class="literal">itemIds</code>.</p><p>The <code class="literal">itemIds</code> parameter must be the ID of a selected product.</p><p>We call the <code class="literal">RecommendItem</code> method on the <code class="literal">_webRequest</code> object. This is a <code class="literal">GET</code> request, and we need to specify the ID of the <code class="literal">SelectedModel</code> in the query string. We also need to add a bit to the query string so that we reach the correct endpoint. A successful response will result in JSON output, which will look as follows:</p><div class="informalexample"><pre class="programlisting">[
   { 
      "recommendedItemId": "string",
      "score": "float"
   },
   {...}
   {...}
] </pre></div><p>The result consists of an array of objects. Each item will have a <code class="literal">recommendedItemId</code> and a <code class="literal">score</code>. The score gives an indication of how likely a customer is to want the given item.</p><p>This result should be deserialized into a list of data contracts of a <code class="literal">RecommandedItem </code>type, so make sure you add this in the <code class="literal">Contracts</code> folder.</p><p>When we have made a successful call, we want to display this in the UI, as follows:</p><div class="informalexample"><pre class="programlisting">        if(recommendations.Count == 0) { 
            Recommendations = "No recommendations found"; 
            return; 
        } 
         StringBuilder sb = new StringBuilder(); 
        sb.Append("Recommended items:\n\n"); </pre></div><p>First, we <a class="indexterm" id="id416"/>check to see whether we have any recommendations. If we do not have any, we will not move on. If we do have any items, we create a <code class="literal">StringBuilder</code> to format our output, as follows:</p><div class="informalexample"><pre class="programlisting">        foreach(RecommendedItem recommendedItem in recommendations)  { 
            sb.AppendFormat("Score: {0}n", recommendedItem.score); 
            sb.AppendFormat("Item ID: {0}\n", item.id); 
 
            sb.Append("n"); 
        } 
        Recommendations = sb.ToString(); 
    } </pre></div><p>We loop through all the <code class="literal">recommendedItems</code>. We output the <code class="literal">score</code> and the <code class="literal">id</code>. This will be printed in the UI.</p><p>A successful test run may give the following result:</p><div class="mediaobject"><img alt="Consuming recommendations" src="graphics/B12373_07_06.jpg"/></div><p>There are <a class="indexterm" id="id417"/>a few special cases to note:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the item list contains a single item that does not exist in the catalog, then an empty result is returned</li><li class="listitem" style="list-style-type: disc">If the item list contains some items that are not in the catalog, then these are removed from the query</li><li class="listitem" style="list-style-type: disc">If the item list contains only cold items (items that have no usage data connected to them), then the most popular recommendation is returned</li><li class="listitem" style="list-style-type: disc">If the item list contains some cold items, then recommendations are returned for the other items</li></ul></div><div class="section" title="Recommending items based on prior activities"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec50"/>Recommending items based on prior activities</h3></div></div></div><p>To make <a class="indexterm" id="id418"/>recommendations based on user activity, we need a list of users. As such a list would be too cumbersome to create just for an example, we will only look at the steps and parameters that are required to make this kind of recommendation.</p><p>The endpoint for this usage is a bit different, as it is another <code class="literal">GET</code> call. In code, it would look as follows:</p><div class="informalexample"><pre class="programlisting">    $"{SelectedModel.id}/recommend/user?{queryString.ToString()}" </pre></div><p>The parameters in the query string are as follows:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Parameter</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">userId</code> (required)</p>
</td><td style="text-align: left" valign="top">
<p>A unique identifier of a given user.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">numberOfResults</code> (required)</p>
</td><td style="text-align: left" valign="top">
<p>The number of recommendations returned.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">itemsIds</code> (optional)</p>
</td><td style="text-align: left" valign="top">
<p>A list or single ID of the selected item(s).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">includeMetadata</code> (optional)</p>
</td><td style="text-align: left" valign="top">
<p>If true, then the item's metadata will be included.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">buildId</code> (optional)</p>
</td><td style="text-align: left" valign="top">
<p>A number identifying the build we want to use. If none is specified, then the active build is used.</p>
</td></tr></tbody></table></div><p>A successful call will result in the same JSON output as the other recommendation models. Recommended items will, of course, be based on users' past activities.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Note that, to be able to use this, U2I must be set to <code class="literal">true</code> when creating a model build.</p></div></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec41"/>Summary</h1></div></div></div><p>In this chapter, we dived into the recommendations API. We learned how to set up recommendation models using existing catalog and usage data. Using these models, we learned how to utilize these in a simple example application.</p><p>In the next chapter, we will start with the knowledge APIs. We will learn how to structure natural language queries and evaluate query expressions. In addition, we will learn how to add autocompletion to natural language queries.</p></div></body></html>