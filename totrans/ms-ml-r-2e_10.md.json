["```py\n    > library(arules)\n\n    > library(arulesViz)\n\n    > data(Groceries) \n    > head(Groceries) \n    transactions in sparse format with\n     9835 transactions (rows) and\n     169 items (columns)\n\n    > str(Groceries)\n    Formal class 'transactions' [package \"arules\"] with 3 slots\n      ..@ data :Formal class 'ngCMatrix' [package \"Matrix\"] with 5 \n        slots\n      .. .. ..@ i : int [1:43367] 13 60 69 78 14 29 98 24 15 29 ...\n      .. .. ..@ p : int [1:9836] 0 4 7 8 12 16 21 22 27 28 ...\n      .. .. ..@ Dim : int [1:2] 169 9835\n      .. .. ..@ Dimnames:List of 2\n      .. .. .. ..$ : NULL\n      .. .. .. ..$ : NULL\n      .. .. ..@ factors : list()\n      ..@ itemInfo :'data.frame': 169 obs. of 3 variables:\n      .. ..$ labels: chr [1:169] \"frankfurter\" \"sausage\" \"liver loaf\" \n        \"ham\" ...\n      .. ..$ level2: Factor w/ 55 levels \"baby food\",\"bags\",..: 44 44 \n      44 44 44 44\n      44 42 42 41 ...\n      .. ..$ level1: Factor w/ 10 levels \"canned food\",..: 6 6 6 6 6 6 \n      6 6 6 6 \n      ...\n      ..@ itemsetInfo:'data.frame': 0 obs. of 0 variables\n\n```", "```py\n    > itemFrequencyPlot(Groceries, topN = 10, type = \"absolute\")\n\n```", "```py\n    > itemFrequencyPlot(Groceries, topN = 15)\n\n```", "```py\n    > rules <- apriori(Groceries, parameter = list(supp = 0.001, conf = \n      0.9, maxlen=4))\n\n```", "```py\n    > rules\n    set of 67 rules\n\n```", "```py\n    > options(digits = 2)\n\n    > rules <- sort(rules, by = \"lift\", decreasing = TRUE)\n\n    > inspect(rules[1:5])\n      lhs                 rhs                support confidence lift\n    1 {liquor, red/blush wine}     => {bottled beer}      0.0019       \n       0.90 11.2\n    2 {root vegetables, butter, cream cheese }      => {yogurt}            \n       0.0010       0.91  6.5\n    3 {citrus fruit, root vegetables, soft cheese}=> {other vegetables}  \n       0.0010       1.00  5.2\n    4 {pip fruit, whipped/sour cream, brown bread}=> {other vegetables}  \n       0.0011       1.00  5.2\n    5 {butter,whipped/sour cream, soda}    => {other vegetables}  \n       0.0013       0.93  4.8\n\n```", "```py\n    > rules <- sort(rules, by = \"confidence\", decreasing = TRUE) \n    > inspect(rules[1:5])\n      lhs             rhs                support confidence lift\n    1 {citrus fruit, root vegetables, soft cheese}=> {other vegetables}  \n      0.0010          1  5.2\n    2 {pip fruit, whipped/sour cream, brown bread}=> {other vegetables}  \n      0.0011          1  5.2\n    3 {rice, sugar}  => {whole milk}        0.0012          1  3.9\n    4 {canned fish, hygiene articles} => {whole milk} 0.0011   1  3.9\n    5 {root vegetables, butter, rice} => {whole milk} 0.0010   1  3.9\n\n```", "```py\n    > tab <- crossTable(Groceries)\n\n```", "```py\n    > tab[1:3, 1:3]\n                frankfurter sausage liver loaf\n    frankfurter         580      99          7\n    sausage              99     924         10\n    liver loaf            7      10         50\n\n```", "```py\n    > table[\"bottled beer\",\"bottled beer\"]\n    [1] 792\n\n```", "```py\n    > table[\"bottled beer\",\"canned beer\"]\n    [1] 26\n\n```", "```py\n > beer.rules <- apriori(data = Groceries, parameter = list(support \n      = 0.0015, confidence = 0.3), appearance = list(default = \"lhs\",\n        rhs = \"bottled beer\"))\n\n    > beer.rules\n    set of 4 rules\n\n```", "```py\n    > beer.rules <- sort(beer.rules, decreasing = TRUE, by = \"lift\")\n\n    > inspect(beer.rules)\n      lhs                   rhs            support confidence lift\n    1 {liquor, red/blush wine} => {bottled beer}  0.0019  0.90 11.2\n    2 {liquor}               => {bottled beer}    0.0047  0.42  5.2\n    3 {soda, red/blush wine} => {bottled beer}    0.0016  0.36  4.4\n    4 {other vegetables, red/blush wine} => {bottled beer}0.0015 0.31  \n      3.8\n\n```", "```py\n    > tab[\"bottled beer\", \"red/blush wine\"]\n    [1] 48\n\n    > tab[\"red/blush wine\", \"red/blush wine\"]\n    [1] 189\n\n    > 48/189\n    [1] 0.25\n\n    > tab[\"white wine\", \"white wine\"]\n    [1] 187\n\n    > tab[\"bottled beer\", \"white wine\"]\n    [1] 22\n\n    > 22/187\n    [1] 0.12\n\n```", "```py\n    > plot(beer.rules, method = \"graph\", measure = \"lift\", shading = \n    \"confidence\")\n\n```", "```py\n    > ratings <- c(3, 5, 5, 5, 1, 1, 5, 2, 5, 1, 1, 5, 3, 5, 1, 5, 4 \n      ,2, 4, 3, 4, 2, 1, 4)\n\n    > ratingMat <- matrix(ratings, nrow = 6)\n\n    > rownames(ratingMat) <- c(\"Homer\", \"Marge\", \"Bart\", \"Lisa\", \n      \"Flanders\", \"Me\")\n\n    > colnames(ratingMat) <- c(\"Avengers\", \"American Sniper\", \"Les \n      Miserable\", \"Mad Max\")\n\n    > ratingMat\n    Avengers  American Sniper  Les Miserable   Mad    Max\n    Homer        3               5             3       4\n    Marge        5               2             5       3\n    Bart         5               5             1       4\n    Lisa         5               1             5       2\n    Flanders     1               1             4       1\n    Me           1               5             2       4\n\n```", "```py\n    > svd <- svd(ratingMat)\n\n    > svd\n    $d\n    [1] 16.1204848  6.1300650  3.3664409  0.4683445\n\n    $u\n               [,1]       [,2]       [,3]        [,4]\n    [1,] -0.4630576  0.2731330  0.2010738 -0.27437700\n    [2,] -0.4678975 -0.3986762 -0.0789907  0.53908884\n    [3,] -0.4697552  0.3760415 -0.6172940 -0.31895450\n    [4,] -0.4075589 -0.5547074 -0.1547602 -0.04159102\n    [5,] -0.2142482 -0.3017006  0.5619506 -0.57340176\n    [6,] -0.3660235  0.4757362  0.4822227  0.44927622\n\n    $v\n               [,1]       [,2]        [,3]       [,4]\n    [1,] -0.5394070 -0.3088509 -0.77465479 -0.1164526\n    [2,] -0.4994752  0.6477571  0.17205756 -0.5489367\n    [3,] -0.4854227 -0.6242687  0.60283871 -0.1060138\n    [4,] -0.4732118  0.3087241  0.08301592  0.8208949\n\n```", "```py\n    > sum(svd$d)\n    [1] 26.08534\n\n    > var <- sum(svd$d[1:2])\n\n    > var\n    [1] 22.25055\n\n    > var/sum(svd$d)\n    [1] 0.8529908\n\n```", "```py\n    > f1 <- function(x) {\n    score = 0\n    for(i in 1:n )\n       score <- score + svd$u[,i] %*% t(svd$v[,i]) * svd$d[i]\n    return(score)}\n\n```", "```py\n    > n = 4\n\n    > f1(svd)\n         [,1] [,2] [,3] [,4]\n    [1,]    3    5    3    4\n    [2,]    5    2    5    3\n    [3,]    5    5    1    4\n    [4,]    5    1    5    2\n    [5,]    1    1    4    1\n    [6,]    1    5    2    4\n\n```", "```py\n    > n = 2\n\n    > f1(svd)\n                [,1]      [,2]     [,3]     [,4]\n    [1,] 3.509402 4.8129937 2.578313 4.049294\n    [2,] 4.823408 2.1843483 5.187072 2.814816\n    [3,] 3.372807 5.2755495 2.236913 4.295140\n    [4,] 4.594143 1.0789477 5.312009 2.059241\n    [5,] 2.434198 0.5270894 2.831096 1.063404\n    [6,] 2.282058 4.8361913 1.043674 3.692505\n\n```", "```py\n    > library(psych)\n\n    > pca <- principal(ratingMat, nfactors = 2, rotate = \"none\")\n\n    > pca\n    Principal Components Analysis\n    Call: principal(r = ratingMat, nfactors = 2, rotate =\n    \"none\")\n    Standardized loadings (pattern matrix) based upon correlation \n      matrix\n                      PC1   PC2   h2    u2\n    Avengers        -0.09  0.98 0.98 0.022\n    American Sniper  0.99 -0.01 0.99 0.015\n    Les Miserable   -0.90  0.18 0.85 0.150\n    Mad Max          0.92  0.29 0.93 0.071\n\n                                PC1  PC2\n    SS loadings           2.65 1.09\n    Proportion Var        0.66 0.27\n    Cumulative Var        0.66 0.94\n    Proportion Explained  0.71 0.29\n    Cumulative Proportion 0.71 1.00\n\n```", "```py\n    > library(recommenderlab)\n\n    > data(Jester5k)\n\n    > Jester5k\n    5000 x 100 rating matrix of class 'realRatingMatrix' with\n    362106 ratings.\n\n```", "```py\n    > as(Jester5k[10,], \"list\")\n    $u12843\n       j1    j2    j3    j4    j5 ...\n    -1.99 -6.89  2.09 -4.42 -4.90 ...\n\n```", "```py\n    > rowMeans(Jester5k[10,])\n    u12843 \n      -1.6\n\n    > colMeans(Jester5k[,1])\n    j1 \n    0.92\n\n```", "```py\n    > hist(getRatings(Jester5k), breaks=100)\n\n```", "```py\n    > hist(getRatings(normalize(Jester5k)), breaks = 100)\n\n```", "```py\n    > set.seed(123)\n\n    > e <- evaluationScheme(Jester5k, method=\"split\", \n    train=0.8, given=15, goodRating=5)\n\n    >  e\n    Evaluation scheme with 15 items given\n    Method: 'split' with 1 run(s).\n    Training set proportion: 0.800\n    Good ratings: >=5.000000\n    Data set: 5000 x 100 rating matrix of class\n    'realRatingMatrix' with 362106\n     ratings.\n\n```", "```py\n    > recommenderRegistry$get_entries(dataType =\n    \"realRatingMatrix\")\n\n    $ALS_realRatingMatrix\n Recommender method: ALS for realRatingMatrix\n Description: Recommender for explicit ratings based on latent \n      factors, calculated by alternating least squares algorithm.\n Reference: Yunhong Zhou, Dennis Wilkinson, Robert Schreiber, Rong \n      Pan (2008).\n    Large-Scale Parallel Collaborative Filtering for the Netflix Prize, \n      4th Int'l   \n    Conf. Algorithmic Aspects in Information and Management, LNCS 5034.\n Parameters:\n normalize lambda n_factors n_iterations min_item_nr seed\n 1 NULL 0.1 10 10 1 NULL\n\n $ALS_implicit_realRatingMatrix\n Recommender method: ALS_implicit for realRatingMatrix\n Description: Recommender for implicit data based on latent factors, \n    calculated by alternating least squares algorithm.\n Reference: Yifan Hu, Yehuda Koren, Chris Volinsky (2008). \n      Collaborative\n    Filtering for Implicit Feedback Datasets, ICDM '08 Proceedings of \n      the 2008 \n    Eighth IEEE International Conference on Data Mining, pages 263-272.\n Parameters:\n lambda alpha n_factors n_iterations min_item_nr seed\n 1 0.1 10 10 10 1 NULL\n\n $IBCF_realRatingMatrix\n Recommender method: IBCF for realRatingMatrix\n Description: Recommender based on item-based collaborative \n      filtering.\n Reference: NA\n Parameters:\n k method normalize normalize_sim_matrix alpha na_as_zero\n 1 30 \"Cosine\" \"center\" FALSE 0.5 FALSE\n\n $POPULAR_realRatingMatrix\n Recommender method: POPULAR for realRatingMatrix\n Description: Recommender based on item popularity.\n Reference: NA\n Parameters:\n normalize aggregationRatings aggregationPopularity\n 1 \"center\" new(\"standardGeneric\" new(\"standardGeneric\"\n\n $RANDOM_realRatingMatrix\n Recommender method: RANDOM for realRatingMatrix\n Description: Produce random recommendations (real ratings).\n Reference: NA\n Parameters: None\n\n $RERECOMMEND_realRatingMatrix\n Recommender method: RERECOMMEND for realRatingMatrix\n Description: Re-recommends highly rated items (real ratings).\n Reference: NA\n Parameters:\n randomize minRating\n 1 1 NA\n\n $SVD_realRatingMatrix\n Recommender method: SVD for realRatingMatrix\n Description: Recommender based on SVD approximation with column-mean \n   imputation.\n Reference: NA\n Parameters:\n k maxiter normalize\n 1 10 100 \"center\"\n\n $SVDF_realRatingMatrix\n Recommender method: SVDF for realRatingMatrix\n Description: Recommender based on Funk SVD with gradient descend.\n Reference: NA\n Parameters:\n k gamma lambda min_epochs max_epochs min_improvement normalize\n 1 10 0.015 0.001 50 200 1e-06 \"center\"\n verbose\n 1 FALSE\n\n $UBCF_realRatingMatrix\n Recommender method: UBCF for realRatingMatrix\n Description: Recommender based on user-based collaborative \n     filtering.\n Reference: NA\n Parameters:\n method nn sample normalize\n 1 \"cosine\" 25 FALSE \"center\" \n\n```", "```py\n    > ubcf <- Recommender(getData(e,\"train\"), \"UBCF\")\n\n    > ibcf <- Recommender(getData(e,\"train\"), \"IBCF\")\n\n    > svd <- Recommender(getData(e, \"train\"), \"SVD\")\n\n    > popular <- Recommender(getData(e, \"train\"), \"POPULAR\")\n\n    > pca <- Recommender(getData(e, \"train\"), \"PCA\")\n\n    > random <- Recommender(getData(e, \"train\"), \"RANDOM\")\n\n```", "```py\n    > user_pred <- predict(ubcf, getData(e, \"known\"), type = \"ratings\")\n\n    > item_pred <- predict(ibcf, getData(e, \"known\"), type = \"ratings\")\n\n    > svd_pred <- predict(svd, getData(e, \"known\"), type = \"ratings\")\n\n    > pop_pred <- predict(popular, getData(e, \"known\"), type = \n       \"ratings\")\n\n    > rand_pred <- predict(random, getData(e, \"known\"), type = \n       \"ratings\")\n\n```", "```py\n    > P1 <- calcPredictionAccuracy(user_pred, getData(e,\n    \"unknown\"))\n\n    > P1\n    RMSE  MSE  MAE \n    4.5 19.9  3.5\n\n    > P2 <- calcPredictionAccuracy(item_pred, getData(e, \"unknown\"))\n\n    > P3 <- calcPredictionAccuracy(svd_pred, getData(e, \"unknown\")) \n    > P4 <- calcPredictionAccuracy(pop_pred, getData(e, \"unknown\"))\n\n    > P5 <- calcPredictionAccuracy(rand_pred, getData(e, \"unknown\"))\n\n    > error <- rbind(P1, P2, P3, P4, P5)\n\n    > rownames(error) <- c(\"UBCF\", \"IBCF\", \"SVD\", \"Popular\", \"Random\")\n\n    > error\n            RMSE MSE  MAE\n UBCF     4.5  20  3.5\n IBCF     4.6  22  3.5\n SVD      4.6  21  3.7\n Popular  4.5  20  3.5\n Random   6.3  40  4.9 \n\n```", "```py\n    > algorithms <- list(POPULAR = list(name = \"POPULAR\"),\n    UBCF =list(name = \"UBCF\"), IBCF = list(name = \"IBCF\"))\n\n    > algorithms\n    $POPULAR\n    $POPULAR$name\n    [1] \"POPULAR\"\n\n    $UBCF\n    $UBCF$name\n    [1] \"UBCF\"\n\n    $IBCF\n    $IBCF$name\n    [1] \"IBCF\"\n\n```", "```py\n    > evlist <- evaluate(e, algorithms, n = c(5, 10, 15))\n    POPULAR run \n    1  [0.07sec/4.7sec] \n    UBCF run \n    1  [0.04sec/8.9sec] \n    IBCF run \n     1  [0.45sec/0.32sec]3\n\n```", "```py\n > set.seed(1)    \n\n > avg(evlist)\n    $POPULAR\n TP    FP    FN    TN   precision  recall   TPR    FPR\n 5  2.07  2.93  12.9  67.1       0.414   0.182 0.182 0.0398\n 10 3.92  6.08  11.1  63.9       0.393   0.331 0.331 0.0828\n 15 5.40  9.60   9.6  60.4       0.360   0.433 0.433 0.1314\n\n $UBCF\n TP    FP    FN    TN   precision   recall   TPR    FPR\n 5   2.07  2.93  12.93  67.1      0.414    0.179 0.179 0.0398\n 10  3.88  6.12  11.11  63.9      0.389    0.326 0.326 0.0835\n 15  5.41  9.59   9.59  60.4      0.360    0.427 0.427 0.1312\n\n $IBCF\n TP    FP    FN    TN    precision   recall    TPR   FPR\n 5   1.02  3.98  14.0  66.0        0.205   0.0674 0.0674 0.0558\n 10  2.35  7.65  12.6  62.4        0.235   0.1606 0.1606 0.1069\n 15  3.72 11.28  11.3  58.7        0.248   0.2617 0.2617 0.1575 \n\n```", "```py\n    > plot(evlist, legend = \"topleft\", annotate = TRUE)\n\n```", "```py\n    > plot(evlist, \"prec\", legend = \"bottomright\", annotate = TRUE)\n\n```", "```py\n    > R1 <- Recommender(Jester5k, method = \"POPULAR\")\n\n    > R1\n    Recommender of type 'POPULAR' for 'realRatingMatrix' \n    learned using 5000 users.\n\n```", "```py\n    > recommend <- predict(R1, Jester5k[1:2], n = 5)\n\n    > as(recommend, \"list\")\n    $u2841\n [1] \"j89\" \"j72\" \"j76\" \"j88\" \"j83\"\n\n $u15547\n [1] \"j89\" \"j93\" \"j76\" \"j88\" \"j91\" \n\n```", "```py\n    > rating <- predict(R1, Jester5k[300:309], type = \"ratings\")\n\n    > rating\n    10 x 100 rating matrix of class 'realRatingMatrix' with 322\n    ratings.\n\n    > as(rating, \"matrix\")[, 71:73]\n              j71  j72     j73\n u7628  -2.042 1.50 -0.2911\n u8714      NA   NA      NA\n u24213 -2.935   NA -1.1837\n u13301  2.391 5.93  4.1419\n u10959     NA   NA      NA\n u23430 -0.432 3.11      NA\n u11167 -1.718 1.82  0.0333\n u4705  -1.199 2.34  0.5519\n u24469 -1.583 1.96  0.1686\n u13534 -1.545 2.00      NA \n\n```", "```py\n    > Jester.bin <- binarize(Jester5k, minRating = 5)\n\n```", "```py\n    > Jester.bin <- Jester.bin[rowCounts(Jester.bin) > 10]\n\n    > Jester.bin\n    3054 x 100 rating matrix of class 'binaryRatingMatrix' with 84722 \n      ratings.\n\n```", "```py\n    > set.seed(456)\n\n    > e.bin <- evaluationScheme(Jester.bin, method = \"cross-\n      validation\", k = 5, given = 10)\n\n```", "```py\n    > algorithms.bin <- list(\"random\" = list(name = \"RANDOM\", param = \n      NULL), \"popular\" = list(name = \"POPULAR\", param = NULL), \"UBCF\" = \n        list(name = \"UBCF\"))\n\n```", "```py\n    > results.bin <- evaluate(e.bin, algorithms.bin, n = c(5, 10, 15))\n    RANDOM run \n    1  [0sec/0.41sec] \n    2  [0.01sec/0.39sec] \n    3  [0sec/0.39sec] \n    4  [0sec/0.41sec] \n    5  [0sec/0.4sec] \n    POPULAR run \n    1  [0.01sec/3.79sec] \n    2  [0sec/3.81sec] \n    3  [0sec/3.82sec] \n    4  [0sec/3.92sec] \n    5  [0.02sec/3.78sec] \n    UBCF run \n    1  [0sec/5.94sec] \n    2  [0sec/5.92sec] \n    3  [0sec/6.05sec] \n    4  [0sec/5.86sec] \n     5  [0sec/6.09sec]\n\n```", "```py\n    > plot(results.bin, legend = \"topleft\")\n\n```", "```py\n    > plot(results.bin, \"prec\", legend = \"bottomright\")\n\n```", "```py\n > df <- read.csv(\"sequential.csv\") \n > str(df)\n 'data.frame': 5000 obs. of 9 variables:\n $ Cust_Segment: Factor w/ 4 levels \"Segment1\",\"Segment2\",..: 1 1 1 \n    1 1 1 1 1 1 1 ...\n $ Purchase1 : Factor w/ 7 levels \"Product_A\",\"Product_B\",..: 1 2 7 \n    3 1 4 1 4 4 4 ...\n\n```", "```py\n > table(df$Cust_Segment)\n\n Segment1 Segment2 Segment3 Segment4 \n 2900      572      554      974 \n\n > table(df$Purchase1)\n\n Product_A Product_B Product_C Product_D Product_E Product_F \n    Product_G \n 1451       765       659      1060       364       372       \n    329\n\n```", "```py\n > table(unlist(df[, -1]))\n\n Product_A Product_B Product_C Product_D Product_E Product_F \n    Product_G \n 3855      3193      3564      3122      1688      1273   915   \n    22390\n\n```", "```py\n > dfCount <- count(df, Purchase1, Purchase2)\n\n > dfCount <- arrange(dfCount, desc(n))\n\n > dim(dfCount)\n [1] 56 3\n > head(dfCount)\n Source: local data frame [6 x 3]\n Groups: Purchase1 [4]\n\n Purchase1 Purchase2     n\n <fctr>    <fctr> <int>\n 1 Product_A Product_A   548\n 2 Product_D             548\n 3 Product_B             346\n 4 Product_C Product_C   345\n 5 Product_B Product_B   291\n 6 Product_D Product_D   281\n\n```", "```py\n > seq <- seqdef(df[, -1], xtstep = 1)\n\n > head(seq)\n Sequence \n 1 Product_A-Product_A------ \n 2 Product_B------- \n 3 Product_G-Product_B-Product_B-Product_C-Product_B-Product_B-\n    Product_B- \n      Product_G\n 4 Product_C------- \n 5 Product_A------- \n 6 Product_D-------\n\n```", "```py\n > seqiplot(seq)\n\n```", "```py\n > seqdplot(seq)\n\n```", "```py\n > seqdplot(seq, group = df$Cust_Segment)\n\n```", "```py\n > seqmsplot(seq, group = df$Cust_Segment)\n\n```", "```py\n > seqmtplot(seq, group = df$Cust_Segment)\n\n```", "```py\n > seqE <- seqecreate(seq)\n\n > subSeq <- seqefsub(seqE, pMinSupport = 0.05)\n\n > plot(subSeq[1:10], col = \"dodgerblue\")\n\n```", "```py\n > seqMat <- seqtrate(seq)\n [>] computing transition rates for states\n\n     /Product_A/Product_B/Product_C/Product_D/\n       Product_E/Product_F/Product_G ...\n\n > options(digits = 2) # make output easier to read\n\n > seqMat[2:4, 1:3]\n [-> ] [-> Product_A] [-> Product_B]\n [Product_A ->]  0.19          0.417          0.166\n [Product_B ->]  0.26          0.113          0.475\n [Product_C ->]  0.19          0.058          0.041\n\n```", "```py\n > seqMat[, 1] [ ->] [Product_A ->] [Product_B ->] [Product_C ->] \n      [Product_D ->] \n 1.00           0.19           0.26           0.19           0.33 \n [Product_E ->] [Product_F ->] [Product_G ->] \n 0.18           0.25           0.41\n\n```"]