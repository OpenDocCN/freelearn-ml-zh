- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Transforming Numerical Variables
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换数值变量
- en: The statistical methods that are used in data analysis make certain assumptions
    about the data. For example, in the general linear model, it is assumed that the
    values of the dependent variable (the target) are independent, that there is a
    linear relationship between the target and the independent (predictor) variables,
    and that the residuals – that is, the difference between the predictions and the
    real values of the target – are normally distributed and centered at `0`. When
    these assumptions are not met, the resulting probabilistic statements might not
    be accurate. To correct for failure in the assumptions and thus improve the performance
    of the models, we can transform variables before the analysis.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据分析中使用的数据统计方法对数据做出某些假设。例如，在一般线性模型中，假设因变量（目标）的值是独立的，目标变量与自变量（预测变量）之间存在线性关系，以及残差——即预测值与目标真实值之间的差异——是正态分布且中心在`0`。当这些假设不成立时，产生的概率陈述可能不准确。为了纠正假设失败并提高模型性能，我们可以在分析之前对变量进行转换。
- en: When we transform a variable, we replace its original values with a function
    of that variable. Transforming variables with mathematical functions helps reduce
    variable skewness, improves the value spread, and sometimes unmasks linear and
    additive relationships between predictors and the target. Commonly used mathematical
    transformations include the logarithm, reciprocal, power, and square and cube
    root transformations, as well as the Box-Cox and Yeo-Johnson transformations.
    This set of transformations is commonly referred to as **variance stabilizing
    transformations**. Variance stabilizing transformations intend to bring the distribution
    of the variable to a more symmetric – that is, Gaussian – shape. In this chapter,
    we will discuss when to use each transformation and then implement them using
    NumPy, scikit-learn, and Feature-engine.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们转换一个变量时，我们用该变量的函数替换其原始值。使用数学函数转换变量有助于减少变量的偏度，提高值的分布范围，有时可以揭示预测变量与目标之间的线性关系和加性关系。常用的数学转换包括对数、倒数、幂、平方和立方根转换，以及Box-Cox和Yeo-Johnson转换。这一系列转换通常被称为**方差稳定转换**。方差稳定转换旨在将变量的分布带到更对称——即高斯——的形状。在本章中，我们将讨论何时使用每种转换，然后使用NumPy、scikit-learn和Feature-engine实现它们。
- en: 'This chapter contains the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下食谱：
- en: Transforming variables with the logarithm function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对数函数转换变量
- en: Transforming variables with the reciprocal function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用倒数函数转换变量
- en: Using the square root to transform variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平方根转换变量
- en: Using power transformations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用幂转换
- en: Performing Box-Cox transformations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行Box-Cox转换
- en: Performing Yeo-Johnson transformations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行Yeo-Johnson转换
- en: Transforming variables with the logarithm function
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对数函数转换变量
- en: The logarithm function is a powerful transformation for dealing with positive
    data with a right-skewed distribution (observations accumulate at lower values
    of the variable). A common example is the `income` variable, with a heavy accumulation
    of values toward lower salaries. The logarithm transformation has a strong effect
    on the shape of the variable distribution.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对数函数是对处理具有右偏分布（观测值在变量的较低值处累积）的正面数据的一种强大转换。一个常见的例子是`收入`变量，其值在较低工资处有大量累积。对数转换对变量分布的形状有强烈的影响。
- en: In this recipe, we will perform logarithmic transformation using NumPy, scikit-learn,
    and Feature-engine. We will also create a diagnostic plot function to evaluate
    the effect of the transformation on the variable distribution.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用NumPy、scikit-learn和Feature-engine执行对数转换。我们还将创建一个诊断图函数来评估转换对变量分布的影响。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To evaluate the variable distribution and understand whether a transformation
    improves value spread and stabilizes the variance, we can visually inspect the
    data with histograms and **Quantile-Quantile** (**Q-Q**) plots. A Q-Q plot helps
    us determine whether two variables show a similar distribution. In a Q-Q plot,
    we plot the quantiles of one variable against the quantiles of the second variable.
    If we plot the quantiles of the variable of interest against the expected quantiles
    of the normal distribution, then we can determine whether our variable is also
    normally distributed. If the variable is normally distributed, the points in the
    Q-Q plot will fall along a 45-degree diagonal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估变量分布并了解变换是否改善了值分布并稳定了方差，我们可以通过直方图和**分位数-分位数**（**Q-Q**）图来直观地检查数据。Q-Q图帮助我们确定两个变量是否显示出相似的分布。在Q-Q图中，我们绘制一个变量的分位数与另一个变量的分位数。如果我们绘制感兴趣变量的分位数与正态分布的预期分位数，那么我们可以确定我们的变量是否也是正态分布的。如果变量是正态分布的，Q-Q图中的点将沿着45度对角线分布。
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A quantile is the value below which there is a certain fraction of data points
    in the distribution. Thus, the 20th quantile is the point in the distribution
    at which 20% of the observations fall below and 80% above that value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 分位数是分布中低于某个数据点分数的值。因此，第20分位数是分布中20%的观测值低于且80%高于该值的点。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s begin by importing the libraries and getting the dataset ready:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入库并准备数据集：
- en: 'Import the required Python libraries and dataset:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的Python库和数据集：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s load the California housing dataset into a pandas DataFrame:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将加利福尼亚住房数据集加载到pandas DataFrame中：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s explore the distributions of all the variables in the dataset by plotting
    histograms with pandas:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过使用pandas绘制直方图来探索数据集中所有变量的分布：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the following output, we can see that the `MedInc` variable shows a mild
    right-skewed distribution, variables such as `AveRooms` and `Population` are heavily
    right-skewed, and the `HouseAge` variable shows an even spread of values across
    its range:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到`MedInc`变量显示出轻微的右偏分布，例如`AveRooms`和`Population`这样的变量具有严重的右偏分布，而`HouseAge`变量在其范围内显示出值的均匀分布：
- en: figure 3
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图3
- en: '![Figure 3.1 – Histograms with the distribution of the numerical variables](img/B22396_03_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 数值变量的直方图分布](img/B22396_03_01.jpg)'
- en: Figure 3.1 – Histograms with the distribution of the numerical variables
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 数值变量的直方图分布
- en: 'To evaluate the effect of the transformation on the variable distribution,
    we’ll create a function that takes a DataFrame and a variable name as inputs and
    plots a histogram next to a Q-Q plot:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了评估变换对变量分布的影响，我们将创建一个函数，该函数接受DataFrame和变量名作为输入，并在直方图旁边绘制Q-Q图：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s plot the distribution of the `MedInc` variable with the function from
    *step 4*:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用第4步中的函数绘制`MedInc`变量的分布图：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following output shows that `MedInc` has a right-skewed distribution:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下输出显示`MedInc`具有右偏分布：
- en: '![Figure 3.2 – A histogram and Q-Q plot of the MedInc variable](img/B22396_03_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – `MedInc`变量的直方图和Q-Q图](img/B22396_03_02.jpg)'
- en: Figure 3.2 – A histogram and Q-Q plot of the MedInc variable
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – `MedInc`变量的直方图和Q-Q图
- en: 'Now, let’s transform the data with the logarithm:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用对数变换数据：
- en: 'First, let’s make a copy of the original DataFrame:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们复制原始DataFrame：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ve created a copy so that we can modify the values in the copy and not in
    the original DataFrame, which we need for the rest of this recipe.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建了一个副本，这样我们就可以修改副本中的值，而不是原始DataFrame中的值，这对于本食谱的其余部分是必要的。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If we execute `X_tf = X` instead of using pandas’ `copy()`function, `X_tf` will
    not be a copy of the DataFrame; instead, it will be another view of the same data.
    Therefore, changes made in `X_tf` will be reflected in `X` as well.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行`X_tf = X`而不是使用pandas的`copy()`函数，`X_tf`将不是DataFrame的副本；相反，它将是相同数据的另一个视图。因此，对`X_tf`所做的更改也将反映在`X`中。
- en: 'Let’s make a list with the variables that we want to transform:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个包含我们想要变换的变量的列表：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s apply the logarithmic transformation with NumPy to the variables from
    *step 7* and capture the transformed variables in the new DataFrame:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用NumPy对第7步中的变量进行对数变换，并将变换后的变量捕获到新的DataFrame中：
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the logarithm transformation can only be applied to strictly positive
    variables. If the variables have zero or negative values, sometimes, it is useful
    to add a constant to make those values positive. We could add a constant value
    of `1` using `X_tf[vars] = np.log(X[vars] +` `1)`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，对数变换只能应用于严格正数变量。如果变量有零或负值，有时添加一个常数使这些值变为正数是有用的。我们可以使用`X_tf[vars] = np.log(X[vars]
    + 1)`添加一个常数值`1`。
- en: 'Let’s check the distribution of `MedInc` after the transformation with the
    diagnostic function from *step 4*:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用*步骤 4* 中的诊断函数检查变换后的`MedInc`分布：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the following output, we can see that the logarithmic transformation returned
    a more evenly distributed variable that better approximates the theoretical normal
    distribution in the Q-Q plot:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到对数变换返回了一个分布更均匀的变量，在Q-Q图中更好地逼近理论正态分布：
- en: "![Figure 3.3 – A histogram and Q-Q plot of the MedInc variable after the logarithm\
    \ transformation\uFEFF](img/B22396_03_03.jpg)"
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 对数变换后 MedInc 变量的直方图和 Q-Q 图](img/B22396_03_03.jpg)'
- en: Figure 3.3 – A histogram and Q-Q plot of the MedInc variable after the logarithm
    transformation
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 对数变换后 MedInc 变量的直方图和 Q-Q 图
- en: Go ahead and plot the other transformed variables to familiarize yourself with
    the effect of the logarithm transformation on distributions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 继续绘制其他变换后的变量，以便熟悉对数变换对分布的影响。
- en: Now, let’s apply the logarithmic transformation with `scikit-learn`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`scikit-learn`应用对数变换。
- en: 'Let’s import `FunctionTransformer()`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入`FunctionTransformer()`：
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before we proceed, we need to take a copy of the original dataset, as we did
    in *step 6*.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要复制原始数据集，就像我们在*步骤 6* 中做的那样。
- en: 'We’ll set up the transformer to apply the logarithm and to be able to revert
    the transformed variable to its original representation:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将设置变换器以应用对数变换，并能够将变换后的变量恢复到其原始表示：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If we set up `FunctionTransformer()` with the default parameter, `validate=False`,
    we don’t need to fit the transformer before transforming the data. If we set `validate`
    to `True`, the transformer will check the data input to the `fit` method. The
    latter is useful when fitting the transformer with a DataFrame so that it learns
    and stores the variable names.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用默认参数`validate=False`设置`FunctionTransformer()`，在变换数据之前不需要拟合变换器。如果我们把`validate`设置为`True`，变换器将检查`fit`方法的数据输入。后者在用DataFrame拟合变换器时很有用，以便它学习并存储变量名。
- en: 'Let’s transform the positive variables from *step 7*:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将*步骤 7* 中的正变量进行变换：
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Scikit-learn transformers return NumPy arrays and transform the entire DataFrame
    by default. In this case, we assigned the results of the array directly to our
    existing DataFrame. We can change the returned format through the `set_output`
    method and we can restrict the variables to transform with `ColumnTransformer()`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Scikit-learn变换器返回NumPy数组，并默认变换整个DataFrame。在这种情况下，我们将数组的输出结果直接赋值给我们的现有DataFrame。我们可以通过`set_output`方法更改返回的格式，并且我们可以通过`ColumnTransformer()`限制要变换的变量。
- en: Check the results of the transformation with the diagnostic function from *step
    4*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*步骤 4* 中的诊断函数检查变换的结果。
- en: 'Let’s now revert the transformation to the original variable representation:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将变换恢复到原始变量表示：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you check the distribution by executing `diagnostic_plots(X_tf, "MedInc")`,
    you should see a plot that is identical to that returned by *step 5*.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你通过执行`diagnostic_plots(X_tf, "MedInc")`检查分布，你应该看到一个与*步骤 5* 返回的相同的图。
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To add a constant value to the variables, in case they are not strictly positive,
    use `transformer = FunctionTransformer(lambda x: np.log(x +` `1))`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '要给变量添加一个常数，以防它们不是严格正数，可以使用`transformer = FunctionTransformer(lambda x: np.log(x
    + 1))`。'
- en: Now, let’s apply the logarithm transformation with Feature-engine.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Feature-engine应用对数变换。
- en: 'Let’s import the `LogTransformer()`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入`LogTransformer()`：
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We’ll set up the transformer to transform the variables from *step 7* and then
    fit the transformer to the dataset:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将设置变换器以变换*步骤 7* 中的变量，然后拟合变换器到数据集：
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the `variables` argument is left as `None`, `LogTransformer()` applies the
    logarithm to all the numerical variables found during `fit()`. Alternatively,
    we can indicate which variables to modify, as we did in *step 15*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`variables`参数留为`None`，`LogTransformer()`将对`fit()`期间找到的所有数值变量应用对数变换。或者，我们可以指定要修改的变量，就像我们在*步骤
    15* 中做的那样。
- en: 'Finally, let’s transform the data:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们进行数据变换：
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`X_tf` is a copy of the `X` DataFrame, where the variables from *step 7* are
    transformed with the logarithm.'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`X_tf`是`X` DataFrame的一个副本，其中*步骤7*中的变量通过对数进行了变换。'
- en: 'We can also revert the transformed variables to their original representation:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以将变换后的变量恢复到其原始表示：
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you check the distribution of the variables after *step 17*, they should
    be identical to those of the original data.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你检查*步骤17*之后的变量分布，它们应该与原始数据相同。
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Feature-engine has a dedicated transformer that adds constant values to the
    variables before the applying the logarithm transformation. Check the *There’s
    more…* section later in this recipe for more details.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Feature-engine有一个专门的转换器，在应用对数变换之前向变量添加常数值。请在此菜谱的*更多内容…*部分查看更多详细信息。
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we applied the logarithm transformation to a subset of positive
    variables using NumPy, scikit-learn, and Feature-engine.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用NumPy、scikit-learn和Feature-engine对正变量子集应用了对数变换。
- en: To compare the effect of the transformation on the variable distribution, we
    created a diagnostic function to plot a histogram next to a Q-Q plot. To create
    the Q-Q plot, we used `scipy.stats.probplot()`, which plotted the quantiles of
    the variable of interest in the *y* axis versus the quantiles of a theoretical
    normal distribution, which we indicated by setting the `dist` parameter to `norm`
    in the *x* axis. We used `matplotlib` to display the plot by setting the `plot`
    parameter to `plt`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较变换对变量分布的影响，我们创建了一个诊断函数，用于在直方图旁边绘制Q-Q图。为了创建Q-Q图，我们使用了`scipy.stats.probplot()`，它在*y*轴上绘制了感兴趣变量的分位数，与在*x*轴上设置`dist`参数为`norm`的理论正态分布的分位数进行比较。我们使用`matplotlib`通过设置`plot`参数为`plt`来显示图表。
- en: With `plt.figure()` and `figsize`, we adjusted the size of the figure and, with
    `plt.subplot()`, we organized the two plots in `one` row with `two` columns –
    that is, one plot next to the other. The numbers within `plt.subplot()` indicated
    the number of rows, the number of columns, and the place of the plot in the figure,
    respectively. We placed the histogram in position 1 and the Q-Q plot in position
    2 – that is, left and right, respectively.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`plt.figure()`和`figsize`，我们调整了图表的大小，并使用`plt.subplot()`将两个图表组织在一行两列中——也就是说，一个图表紧挨着另一个图表。`plt.subplot()`中的数字分别表示行数、列数和图表在图中的位置。我们将直方图放在位置1，将Q-Q图放在位置2——也就是说，左和右，分别。
- en: To test the function, we plotted a histogram and a Q-Q plot for the `MedInc`
    variable before the transformation and observed that `MedInc` was not normally
    distributed. Most observations were at the left of the histogram and the values
    deviated from the 45-degree line in the Q-Q plot at both ends of the distribution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试函数，我们在变换之前为`MedInc`变量绘制了直方图和Q-Q图，观察到`MedInc`并不是正态分布。大多数观测值位于直方图的左侧，并且在分布的两端，Q-Q图中的值偏离了45度线。
- en: Next, using `np.log()`, we applied the logarithm to a slice of the DataFrame
    with four positive variables. To evaluate the effect of the transformation, we
    plotted a histogram and Q-Q plot of the transformed `MedInc` variable. We observed
    that, after the logarithm transformation, the values were more centered in the
    histogram and that, in the Q-Q plot, they only deviated from the 45-degree line
    toward the ends of the distribution.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`np.log()`，我们对DataFrame中四个正变量的一个子集应用了对数变换。为了评估变换的效果，我们绘制了变换后的`MedInc`变量的直方图和Q-Q图。我们观察到，在对数变换之后，值在直方图中更加集中，并且在Q-Q图中，它们只在分布的两端偏离了45度线。
- en: Next, we used the `FunctionTransformer()` from scikit-learn, which applies any
    user-defined function to a dataset. We passed `np.log()` as an argument to apply
    the logarithm transformation and NumPy’s `exp()` for the inverse transformation
    to `FunctionTransfomer()`. With the `transform()` method, we transformed a slice
    of the DataFrame with the positive variables by using the logarithm. With `inverse_transform()`,
    we reverted the variable values to their original representation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用了scikit-learn的`FunctionTransformer()`，它将任何用户定义的函数应用于数据集。我们将`np.log()`作为参数传递以应用对数变换，并将NumPy的`exp()`用于逆变换到`FunctionTransformer()`。使用`transform()`方法，我们通过对数变换对DataFrame中正变量的一个子集进行了变换。使用`inverse_transform()`，我们将变量值恢复到其原始表示。
- en: Finally, we used Feature-engine’s `LogTransformer()` and specified the variables
    to transform in a list using the `variables` argument. With `fit()`, the transformer
    checked that the variables were numerical and positive, and with `transform()`,
    it applied `np.log()` under the hood to transform the selected variables. With
    `inverse_transform()`, we reverted the transformed variables to their original
    representations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用了 Feature-engine 的 `LogTransformer()` 并使用 `variables` 参数指定要转换的变量列表。使用
    `fit()`，转换器检查变量是否为数值且为正，使用 `transform()`，在底层应用 `np.log()` 来转换选定的变量。使用 `inverse_transform()`，我们将转换后的变量恢复到其原始表示。
- en: There’s more…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Feature-engine has a dedicated transformer for adding a constant value to variables
    that are not strictly positive, before applying the logarithm: `LogCpTransformer()`.
    `LogCpTransformer()` can:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Feature-engine 有一个专门的转换器用于在应用对数之前向不是严格正的变量添加常数：`LogCpTransformer()`。`LogCpTransformer()`
    可以：
- en: Add the same constant to all variables
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相同的常数添加到所有变量中
- en: Automatically identify and add the minimum value required to make the variables
    positive
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动识别并添加使变量为正所需的最小值
- en: Add different values defined by the user to different variables.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户定义的不同值添加到不同的变量中。
- en: 'You can find a code implementation of `LogCpTransformer()` in this book’s GitHub
    repository: [https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variable-transformation/Recipe-1-logarithmic-transformation.ipynb](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variable-transformation/Recipe-1-logarithmic-transformation.ipynb)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的 GitHub 仓库中找到 `LogCpTransformer()` 的代码实现：[https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variable-transformation/Recipe-1-logarithmic-transformation.ipynb](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variable-transformation/Recipe-1-logarithmic-transformation.ipynb)
- en: Transforming variables with the reciprocal function
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用逆函数变换变量
- en: The reciprocal function is defined as 1/x. It is often useful when we have ratios
    – that is, values resulting from the division of two variables. Examples of this
    are **population density** – that is, people per area – and, as we will see in
    this recipe, **house occupancy** – that is, the number of occupants per house.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 逆函数定义为 1/x。当我们有比率时，它通常很有用，即两个变量的除法结果。这类例子包括**人口密度**，即每单位面积的人数，以及我们将在本食谱中看到的**房屋占用率**，即每户的人数。
- en: The reciprocal transformation is not defined for the `0` value, and although
    it is defined for negative values, it is mainly useful for transforming positive
    variables.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 逆变换对于 `0` 值未定义，尽管对于负值是定义的，但它主要用于转换正变量。
- en: In this recipe, we will implement the reciprocal transformation using `NumPy`,
    `scikit-learn`, and `Feature-engine`, and compare its effect on variable distribution
    using histograms and a Q-Q plot.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用 `NumPy`、`scikit-learn` 和 `Feature-engine` 实现逆变换，并使用直方图和 Q-Q 图比较其对变量分布的影响。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let’s begin by importing the libraries and getting the dataset ready:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入库并准备数据集：
- en: 'Import the required Python libraries and data:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的 Python 库和数据：
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s load the California housing dataset:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载加利福尼亚住房数据集：
- en: '[PRE18]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To evaluate variable distributions, we’ll create a function that takes a DataFrame
    and a variable name as inputs and plots a histogram next to a Q-Q plot:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了评估变量分布，我们将创建一个函数，该函数接受 DataFrame 和变量名作为输入，并在 Q-Q 图旁边绘制直方图：
- en: '[PRE19]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let’s plot the distribution of the `AveOccup` variable, which specifies
    the average occupancy of the house:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们绘制 `AveOccup` 变量的分布图，该变量指定了房屋的平均占用率：
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `AveOccup` variable shows a very strong right-skewed distribution, as shown
    in the following output:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AveOccup` 变量显示出非常强的右偏分布，如下面的输出所示：'
- en: '![Figure 3.4 – A histogram and Q-Q plot of the AveOccup variable](img/B22396_03_04.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – AveOccup 变量的直方图和 Q-Q 图](img/B22396_03_04.jpg)'
- en: Figure 3.4 – A histogram and Q-Q plot of the AveOccup variable
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – AveOccup 变量的直方图和 Q-Q 图
- en: Note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `AveOccup` variable refers to the average number of household members –
    that is, the ratio between the number of people and the number of houses in a
    certain area. This is a promising variable for a reciprocal transformation. You
    can find more details about the variables and the dataset by executing `data =
    fetch_california_housing()` followed by `print(data.DESCR)`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`AveOccup` 变量指的是平均家庭人数——即某区域内人数与房屋数量的比率。这是一个适合倒数转换的有前途的变量。您可以通过执行 `data = fetch_california_housing()`
    然后跟 `print(data.DESCR)` 来找到更多关于变量和数据集的详细信息。'
- en: Now, let’s apply the reciprocal transformation with NumPy.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 NumPy 应用倒数转换。
- en: 'First, let’s make a copy of the original DataFrame so that we can modify the
    values in the copy and not in the original one, which we will need for the rest
    of this recipe:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们复制原始 DataFrame，以便我们可以修改副本中的值，而不是原始 DataFrame 中的值，这对于本食谱的其余部分是必需的：
- en: '[PRE21]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that executing `X_tf = X` instead of using pandas’ `copy()` creates
    an additional view of the same data. Therefore, changes that are made in `X_tf`
    will be reflected in `X` as well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，执行 `X_tf = X` 而不是使用 pandas 的 `copy()` 会创建相同数据的额外视图。因此，在 `X_tf` 中所做的更改也会反映在
    `X` 中。
- en: 'Let’s apply the reciprocal transformation to the `AveOccup` variable:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将倒数转换应用于 `AveOccup` 变量：
- en: '[PRE22]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s check the distribution of the `AveOccup` variable after the transformation
    with the diagnostic function we created in *step 3*:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用我们在 *第 3 步* 中创建的诊断函数检查转换后 `AveOccup` 变量的分布：
- en: '[PRE23]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: After the transformation, `AveOccup` is now the ratio of the number of houses
    and the number of people in a certain area – in other words, houses per citizen.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后，`AveOccup` 现在是某个区域内房屋数量与人口数量的比率——换句话说，每公民房屋数。
- en: 'Here, we can see a dramatic change in the distribution of the `AveOccup` variable
    after the reciprocal transformation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到倒数转换后 `AveOccup` 变量分布的显著变化：
- en: "![Figure 3.5 – A histogram and Q-Q plot of the AveOccup variable after the\
    \ reciproc\uFEFFal transfo\uFEFFrmation](img/B22396_03_05.jpg)"
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 倒数转换后 AveOccup 变量的直方图和 Q-Q 图](img/B22396_03_05.jpg)'
- en: Figure 3.5 – A histogram and Q-Q plot of the AveOccup variable after the reciprocal
    transformation
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 倒数转换后 AveOccup 变量的直方图和 Q-Q 图
- en: Now, let’s apply the reciprocal transformation with `scikit-learn`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `scikit-learn` 应用倒数转换。
- en: 'Let’s import the `FunctionTransformer()`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入 `FunctionTransformer()`：
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s set up the transformer by passing `np.reciprocal` as an argument:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过传递 `np.reciprocal` 作为参数来设置转换器：
- en: '[PRE25]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By default, `FunctionTransformer()` does not need to be fit before transforming
    the data.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`FunctionTransformer()` 在转换数据之前不需要拟合。
- en: 'Now, let’s make a copy of the original dataset and transform the variable:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们复制原始数据集并转换变量：
- en: '[PRE26]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can check the effect of the transformation using the function from *step
    3*.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用 *第 3 步* 中的函数来检查转换的效果。
- en: Note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The inverse transformation of the reciprocal function is also the reciprocal
    function. Hence, if you re-apply `transform()` to the transformed data, you will
    revert it to its original representation. A better practice would be to set the
    `inverse_transform` parameter of the `FunctionTransformer()` to `np.reciprocal`
    as well.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 倒数函数的逆变换也是倒数函数。因此，如果您重新对转换后的数据应用 `transform()`，您将将其还原为其原始表示。更好的做法是将 `FunctionTransformer()`
    的 `inverse_transform` 参数设置为 `np.reciprocal`。
- en: Now, let’s apply the reciprocal transformation with `feature-engine`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `feature-engine` 应用倒数转换。
- en: 'Let’s import the `ReciprocalTransformer()`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入 `ReciprocalTransformer()`：
- en: '[PRE27]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s set up the transformer to modify the `AveOccup` variable and then fit
    it to the dataset:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置转换器以修改 `AveOccup` 变量，然后将其拟合到数据集中：
- en: '[PRE28]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the `variables` argument is set to `None`, the transformer applies the reciprocal
    function to *all the numerical variables* in the dataset. If some of the variables
    contain a `0` value, the transformer will raise an error.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将 `variables` 参数设置为 `None`，则转换器将倒数函数应用于数据集中的 *所有数值变量*。如果某些变量包含 `0` 值，转换器将引发错误。
- en: 'Let’s transform the selected variable in our dataset:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将数据集中的选定变量进行转换：
- en: '[PRE29]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`ReciprocalTransformer()` will return a new pandas DataFrame containing the
    original variables, where the variable indicated in *step 12* is transformed with
    the reciprocal function.'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ReciprocalTransformer()` 将返回一个新的包含原始变量的 pandas DataFrame，其中在第 *12 步* 指示的变量通过倒数函数进行了转换。'
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we applied the reciprocal transformation using NumPy, scikit-learn,
    and Feature-engine.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们使用NumPy、scikit-learn和Feature-engine应用了倒数转换。
- en: To evaluate the variable distribution, we used the function to plot a histogram
    next to a Q-Q plot that we described in the *How it works…* section of the *Transforming
    variables with the logarithm function* recipe earlier in this chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估变量分布，我们使用了函数来绘制直方图和Q-Q图，这些图在我们本章前面关于“使用对数函数转换变量”的*How it works…*部分中进行了描述。
- en: We plotted the histogram and Q-Q plot of the `AveOccup` variable, which showed
    a heavy right-skewed distribution; most of its values were at the left of the
    histogram and they deviated from the 45-degree line toward the right end of the
    distribution in the Q-Q plot.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制了`AveOccup`变量的直方图和Q-Q图，这显示了严重的右偏分布；其大部分值位于直方图的左侧，并且在Q-Q图中偏离了向右端分布的45度线。
- en: To carry out the reciprocal transformation, we applied `np.reciprocal()` to
    the variable. After the transformation, `AveOccup`’s values were more evenly distributed
    across the value range and followed the theoretical quantiles of the normal distribution
    in the Q-Q plot more closely.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行互变转换，我们对变量应用了`np.reciprocal()`。转换后，`AveOccup`的值在值范围内分布得更均匀，并且在Q-Q图中更紧密地遵循正态分布的理论分位数。
- en: Next, we used `np.reciprocal()` with scikit-learn’s `FunctionTransformer()`.
    The `transform()` method applied `np.reciprocal()` to the dataset.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用scikit-learn的`FunctionTransformer()`与`np.reciprocal()`。`transform()`方法将`np.reciprocal()`应用于数据集。
- en: Note
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To restrict the effect of `FunctionTransformer()` to a group of variables, use
    the `ColumnTransformer()`. To change the output to a pandas DataFrame, set the
    transform output to pandas.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`FunctionTransformer()`的效果限制为一组变量，请使用`ColumnTransformer()`。要将输出更改为pandas DataFrame，请将转换输出设置为pandas。
- en: Finally, we used Feature-engine’s `ReciprocalTransformer()` to specifically
    modify one variable. With `fit()`, the transformer checked that the variable was
    numerical. With `transform()`, the transformer applied `np.reciprocal()` under
    the hood to transform the variable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用Feature-engine的`ReciprocalTransformer()`专门修改了一个变量。通过`fit()`，转换器检查变量是否为数值型。通过`transform()`，转换器在幕后应用`np.reciprocal()`以转换变量。
- en: Feature-engine’s `ReciprocalTransformer()` provides functionality to revert
    the variable to its original representation out of the box via the `inverse_transform()`
    method.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Feature-engine的`ReciprocalTransformer()`通过`inverse_transform()`方法提供将变量恢复到其原始表示的功能。
- en: Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Using the transformers from scikit-learn or Feature-engine, instead of NumPy’s
    `reciprocal()` function, allows us to apply the reciprocal function as an additional
    step of a feature engineering pipeline within the `Pipeline` object from scikit-learn.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用scikit-learn或Feature-engine的转换器，而不是NumPy的`reciprocal()`函数，允许我们在scikit-learn的`Pipeline`对象中作为特征工程管道的额外步骤应用倒数函数。
- en: The difference between `FunctionTransformer()` and `ReciprocalTransformer()`
    is that the first one can apply any user-specified transformation, whereas the
    latter only applies the reciprocal function. scikit-learn returns NumPy arrays
    by default and transforms all variables in the dataset. Feature-engine’s transformer,
    on the other hand, returns pandas DataFrames and can modify subsets of variables
    within the data without using additional classes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`FunctionTransformer()`与`ReciprocalTransformer()`之间的区别在于，前者可以应用任何用户指定的转换，而后者仅应用倒数函数。scikit-learn默认返回NumPy数组并转换数据集中的所有变量。另一方面，Feature-engine的转换器返回pandas
    DataFrame，并且可以在不使用额外类的情况下修改数据中的变量子集。'
- en: Using the square root to transform variables
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用平方根转换变量
- en: The square root transformation, **√x**, as well as its variations, the Anscombe
    transformation, **√(x+3/8)**, and the Freeman-Tukey transformation, **√x + √(x+1)**,
    are variance stabilizing transformations that transform a variable with a Poisson
    distribution into one with an approximately standard Gaussian distribution. The
    square root transformation is a form of power transformation where the exponent
    is **1/2** and is only defined for positive values.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 平方根转换，**√x**，以及其变体，Anscombe转换，**√(x+3/8)**，和Freeman-Tukey转换，**√x + √(x+1)**，是方差稳定转换，可以将具有泊松分布的变量转换为具有近似标准高斯分布的变量。平方根转换是一种幂转换形式，其指数为**1/2**，并且仅对正值有定义。
- en: The Poisson distribution is a probability distribution that indicates the number
    of times an event is likely to occur. In other words, it is a count distribution.
    It is right-skewed and its variance equals its mean. Examples of variables that
    could follow a Poisson distribution are the number of financial items of a customer,
    such as the number of current accounts or credit cards, the number of passengers
    in a vehicle, and the number of occupants in a household.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 泊松分布是一种概率分布，表示事件可能发生的次数。换句话说，它是一种计数分布。它是右偏斜的，其方差等于其均值。可能遵循泊松分布的变量示例包括客户的金融项目数量，例如当前账户或信用卡的数量，车辆上的乘客数量，以及家庭中的居住者数量。
- en: In this recipe, we will implement square root transformations using NumPy, scikit-learn,
    and Feature-engine.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 NumPy、scikit-learn 和 Feature-engine 实现平方根变换。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We’ll start by creating a dataset with two variables whose values are drawn
    from a Poisson distribution:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个包含两个变量的数据集，这两个变量的值是从泊松分布中抽取的：
- en: 'Let’s begin by importing the necessary libraries:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先导入必要的库：
- en: '[PRE30]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s create a DataFrame with two variables drawn from a Poisson distribution
    with mean values of `2` and `3`, respectively, and `10000` observations:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个包含两个变量的 DataFrame，这两个变量分别从均值为 `2` 和 `3` 的泊松分布中抽取，并且有 `10000` 个观测值：
- en: '[PRE31]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let’s create a function that takes a DataFrame and a variable name as inputs
    and plots a bar graph with the number of observations per value next to a Q-Q
    plot:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，该函数接受 DataFrame 和变量名作为输入，并在 Q-Q 图旁边绘制每个值的观测数条形图：
- en: '[PRE32]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s create a bar plot and a Q-Q plot for one of the variables in the data
    using the function from *step 3*:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用第 *3* 步中的函数创建一个条形图和 Q-Q 图，用于数据中的一个变量：
- en: '[PRE33]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we can see the Poisson distribution in the output:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到输出中的泊松分布：
- en: "![Figure 3.6 – The bar and Q-Q pl\uFEFFots of the counts1 variable](img/B22396_03_06.jpg)"
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – counts1 变量的条形图和 Q-Q 图](img/B22396_03_06.jpg)'
- en: Figure 3.6 – The bar and Q-Q plots of the counts1 variable
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – counts1 变量的条形图和 Q-Q 图
- en: 'Now, let’s make a copy of the dataset:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们复制数据集：
- en: '[PRE34]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let’s apply the square root transformation to both variables:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将平方根变换应用于两个变量：
- en: '[PRE35]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s round the values to two decimals for a nicer visualization:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将值四舍五入到两位小数，以便更好地可视化：
- en: '[PRE36]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s plot the distribution of `counts1` after the transformation:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们绘制 `counts1` 变量变换后的分布图：
- en: '[PRE37]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We see a more **stabilized** variance, as the dots in the Q-Q plot follow the
    45-degree diagonal more closely:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们看到方差更加 **稳定**，因为 Q-Q 图中的点更接近 45 度对角线：
- en: "![Figure 3.7 – The bar and Q-Q plots of the counts1 variable after th\uFEFF\
    e square root transformation](img/B22396_03_07.jpg)"
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 平方根变换后 counts1 变量的条形图和 Q-Q 图](img/B22396_03_07.jpg)'
- en: Figure 3.7 – The bar and Q-Q plots of the counts1 variable after the square
    root transformation
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 平方根变换后 counts1 变量的条形图和 Q-Q 图
- en: Now, let’s apply the square root transformation with `scikit-learn`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `scikit-learn` 应用平方根变换：
- en: 'Let’s import `FunctionTransformer()` and set up it to perform a square root
    transformation:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入 `FunctionTransformer()` 并将其设置为执行平方根变换：
- en: '[PRE38]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If we wanted to round the values as we did in *step 7*, we can set up the transformer
    using `transformer = FunctionTransformer(func=lambda x:` `np.round(np.sqrt(x),
    2))`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们想要像在第 *7* 步中那样四舍五入值，我们可以使用 `transformer = FunctionTransformer(func=lambda
    x: np.round(np.sqrt(x), 2))` 设置变换器。'
- en: 'Let’s make a copy of the data and transform the variables:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们复制数据并变换变量：
- en: '[PRE39]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Go ahead and check the result of the transformation as we did in *step 8*.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照我们在 *第 8 步* 中所做的那样，继续检查变换的结果。
- en: 'To apply the square root with Feature-engine instead, we use the `PowerTransformer()`
    with an exponent of 0.5:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使用 Feature-engine 应用平方根变换，我们使用指数为 0.5 的 `PowerTransformer()`：
- en: '[PRE40]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we fit the transformer to the data:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将变换器拟合到数据上：
- en: '[PRE41]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The transformer automatically identifies the numerical variables, which we can
    explore by executing `root_t.variables_`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 变换器自动识别数值变量，我们可以通过执行 `root_t.variables_` 来探索。
- en: 'Finally, let’s transform the data:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们对数据进行变换：
- en: '[PRE42]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`PowerTransformer()` returns a pandas DataFrame with the transformed variables.'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PowerTransformer()` 返回一个包含变换变量的 pandas DataFrame。'
- en: How it works…
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we applied the square root transformation using NumPy, scikit-learn,
    and Feature-engine.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了 NumPy、scikit-learn 和 Feature-engine 实现了平方根变换。
- en: We used NumPy’s `sqrt()` function either directly or within scikit-learn’s `FunctionTrasnformer()`
    to determine the variables’ square root. Alternatively, we used Feature-engine’s
    `PowerTransformer()`, setting the exponent to 0.5, that of the square root function.
    NumPy modified the variables directly. The transformers of scikit-learn and Feature-engine
    modified the variables when calling the `transform()` method.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用NumPy的`sqrt()`函数直接或在其内部使用scikit-learn的`FunctionTransformer()`来确定变量的平方根。或者，我们使用Feature-engine的`PowerTransformer()`，将指数设置为平方根函数的0.5。NumPy直接修改了变量。scikit-learn和Feature-engine的转换器在调用`transform()`方法时修改了变量。
- en: Using power transformations
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用幂变换
- en: Power functions are mathematical transformations that follow the ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mi>X</mi><mi>t</mi></msub><mo>=</mo><msup><mi>X</mi><mrow><mi>l</mi><mi>a</mi><mi>m</mi><mi>b</mi><mi>d</mi><mi>a</mi></mrow></msup></mrow></mrow></math>](img/15.png)
    format, where lambda can take any value. The square and cube root transformations
    are special cases of power transformations where lambda is 1/2 or 1/3, respectively.
    The challenge resides in finding the value for the lambda parameter. The Box-Cox
    transformation, which is a generalization of the power transformations, finds
    the optimal lambda value via maximum likelihood. We will discuss the Box-Cox transformation
    in the following recipe. In practice, we will try different lambda values and
    visually inspect the variable distribution to determine which one offers the best
    transformation. In general, if the data is right-skewed – that is, if observations
    accumulate toward lower values – we use a lambda value that is smaller than 1,
    while if the data is left-skewed – that is, there are more observations around
    higher values – then we use a lambda value that is greater than 1.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 幂函数是遵循![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mi>X</mi><mi>t</mi></msub><mo>=</mo><msup><mi>X</mi><mrow><mi>l</mi><mi>a</mi><mi>m</mi><mi>b</mi><mi>d</mi><mi>a</mi></mrow></msup></mrow></mrow></math>](img/15.png)格式的数学变换，其中lambda可以取任何值。平方根和立方根变换是幂变换的特殊情况，其中lambda分别为1/2和1/3。挑战在于找到lambda参数的值。Box-Cox变换，作为幂变换的推广，通过最大似然估计找到最优的lambda值。我们将在下一个菜谱中讨论Box-Cox变换。在实践中，我们将尝试不同的lambda值，并通过视觉检查变量分布来确定哪一个提供了最佳的变换。一般来说，如果数据是右偏斜的——也就是说，如果观测值累积在较低值附近——我们使用小于1的lambda值，而如果数据是左偏斜的——也就是说，在较高值附近的观测值更多——那么我们使用大于1的lambda值。
- en: In this recipe, we will carry out power transformations using NumPy, scikit-learn,
    and Feature-engine.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用NumPy、scikit-learn和Feature-engine执行幂变换。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s begin by importing the libraries and getting the dataset ready:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入库并准备好数据集：
- en: 'Import the required Python libraries and classes:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的Python库和类：
- en: '[PRE43]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s load the California housing dataset into a pandas DataFrame:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将加利福尼亚住房数据集加载到一个pandas DataFrame中：
- en: '[PRE44]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To evaluate variable distributions, we’ll create a function that takes a DataFrame
    and a variable name as inputs and plots a histogram next to a Q-Q plot:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了评估变量分布，我们将创建一个函数，该函数接受一个DataFrame和一个变量名作为输入，并在Q-Q图旁边绘制直方图：
- en: '[PRE45]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let’s plot the distribution of the `Population` variable with the previous
    function:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用之前的功能绘制`Population`变量的分布图：
- en: '[PRE46]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the plots returned by the previous command, we can see that `Population`
    is heavily skewed to the right:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前一个命令返回的图表中，我们可以看到`Population`严重向右偏斜：
- en: "![Figure 3.8 – A histogram and \uFEFFQ-Q plot of the Population variable](img/B22396_03_08.jpg)"
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – `Population`变量的直方图和Q-Q图](img/B22396_03_08.jpg)'
- en: Figure 3.8 – A histogram and Q-Q plot of the Population variable
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – `Population`变量的直方图和Q-Q图
- en: Now, let’s apply a power transformation to the `MedInc` and `Population` variables.
    As both are skewed to the right, an exponent smaller than *1* might return a better
    spread of the variable values.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对`MedInc`和`Population`变量应用幂变换。由于这两个变量都向右偏斜，一个小于*1*的指数可能会使变量值分布得更好。
- en: 'Let’s capture the variables to transform in a list:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将要变换的变量捕获到一个列表中：
- en: '[PRE47]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let’s make a copy of the DataFrame and then apply a power transformation to
    the variables from *step 5,* where the exponent is `0.3`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们复制DataFrame，然后对*步骤5*中的变量应用幂变换，其中指数为`0.3`：
- en: '[PRE48]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With `np.power()`, we can apply any power transformation by changing the value
    of the exponent in the second position of the function.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`np.power()`，我们可以通过改变函数第二个位置中的指数值来应用任何幂变换。
- en: 'Let’s examine the change in the distribution of `Population`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查 `Population` 分布的变化：
- en: '[PRE49]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As shown in the plots returned by the previous command, `Population` is now
    more evenly distributed across the value range and follows the quantiles of the
    normal distribution more closely:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前一个命令返回的图所示，`Population` 现在在值范围内分布得更均匀，并且更接近正态分布的分位数：
- en: "![Figure 3.9 – A histogram and Q-Q plot of the Populatio\uFEFFn variable after\
    \ the transformation](img/B22396_03_09.jpg)"
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 3.9 – 变换后的 Population 变量的直方图和 Q-Q 图](img/B22396_03_09.jpg)'
- en: Figure 3.9 – A histogram and Q-Q plot of the Population variable after the transformation
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.9 – 变换后的 Population 变量的直方图和 Q-Q 图
- en: Now, let’s apply a power transformation with scikit-learn.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 scikit-learn 应用幂变换。
- en: 'Let’s set up `FunctionTransformer()` with a power transformation with an exponent
    of `0.3`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置 `FunctionTransformer()`，使用指数为 `0.3` 的幂变换：
- en: '[PRE50]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let’s make a copy of the DataFrame and transform the variables from *step 5*:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们复制 DataFrame 并将 *步骤 5* 中的变量进行转换：
- en: '[PRE51]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: That’s it – we can now examine the variable distribution. Finally, let’s perform
    an exponential transformation with Feature-engine.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样 – 我们现在可以检查变量分布了。最后，让我们使用 Feature-engine 执行指数变换。
- en: 'Let’s set up `PowerTransformer()` with an exponent of `0.3` to transform the
    variables from *step 5*. Then, we’ll fit it to the data:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置 `PowerTransformer()`，指数为 `0.3`，以转换 *步骤 5* 中的变量。然后，我们将它拟合到数据中：
- en: '[PRE52]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If we don’t define the variables to transform, `PowerTransformer()` will select
    and transform all of the numerical variables in the DataFrame.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不定义要转换的变量，`PowerTransformer()` 将选择并转换 DataFrame 中的所有数值变量。
- en: 'Finally, let’s transform those two variables:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们转换这两个变量：
- en: '[PRE53]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The transformer returns a DataFrame containing the original variables, where
    the two variables specified in *step 5* are transformed with the power function.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器返回一个包含原始变量的 DataFrame，其中 *步骤 5* 中指定的两个变量使用幂函数进行了转换。
- en: How it works...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we applied power transformations using NumPy, scikit-learn,
    and Feature-engine.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用了 NumPy、scikit-learn 和 Feature-engine 应用了幂变换。
- en: To apply power functions with NumPy, we applied the `power()` method to the
    slice of the dataset containing the variables to transform. To apply this transformation
    with scikit-learn, we set up the `FunctionTransformer()`with `np.power()` within
    a `lambda` function, using `0.3` as the exponent. To apply power functions with
    Feature-engine, we set up the `PowerTransformer()` with a list of the variables
    to transform and an exponent of `0.3`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 NumPy 应用幂函数，我们应用了 `power()` 方法到包含要转换的变量的数据集切片。要使用 scikit-learn 应用此转换，我们在
    `lambda` 函数中设置了 `FunctionTransformer()`，使用 `np.power()`，并将 `0.3` 作为指数。要使用 Feature-engine
    应用幂函数，我们设置了 `PowerTransformer()`，其中包含要转换的变量列表和指数 `0.3`。
- en: scikit-learn and Feature-engine transformers applied the transformation when
    we called the `transform()` method. scikit-learn’s `FunctionTransformer()` modifies
    the entire dataset and returns NumPy arrays by default. To return pandas DataFrames,
    we need to set the transform output to pandas, and to apply the transformation
    to specific variables, we can use `ColumnTransformer()`. Feature-engine’s `PowerTransformer()`,
    on the other hand, can apply the transformation to a subset of variables out of
    the box, returning pandas DataFrames by default.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `transform()` 方法时，scikit-learn 和 Feature-engine 转换器应用了变换。scikit-learn
    的 `FunctionTransformer()` 修改整个数据集，并默认返回 NumPy 数组。要返回 pandas DataFrame，我们需要将转换输出设置为
    pandas，并且要应用转换到特定变量，我们可以使用 `ColumnTransformer()`。另一方面，Feature-engine 的 `PowerTransformer()`
    可以直接应用于变量子集，并默认返回 pandas DataFrame。
- en: Performing Box-Cox transformations
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 Box-Cox 变换
- en: 'The Box-Cox transformation is a generalization of the power family of transformations
    and is defined as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Box-Cox 变换是幂变换家族的推广，定义为如下：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msup><mi>y</mi><mrow><mo>(</mo><mi>λ</mi><mo>)</mo></mrow></msup><mo>=</mo><mfrac><mrow><mo>(</mo><msup><mi>y</mi><mi>λ</mi></msup><mo>−</mo><mn>1</mn><mo>)</mo></mrow><mi>λ</mi></mfrac><mi>i</mi><mi>f</mi><mi>λ</mi><mo>≠</mo><mn>0</mn></mrow></mrow></math>](img/16.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msup><mi>y</mi><mrow><mo>(</mo><mi>λ</mi><mo>)</mo></mrow></msup><mo>=</mo><mfrac><mrow><mo>(</mo><msup><mi>y</mi><mi>λ</mi></msup><mo>−</mo><mn>1</mn><mo>)</mo></mrow><mi>λ</mi></mfrac><mi>i</mi><mi>f</mi><mi>λ</mi><mo>≠</mo><mn>0</mn></mrow></mrow></math>](img/16.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msup><mi>y</mi><mrow><mo>(</mo><mi>λ</mi><mo>)</mo></mrow></msup><mo>=</mo><mi>log</mi><mfenced
    open="(" close=")"><mi>y</mi></mfenced><mi>i</mi><mi>f</mi><mi>λ</mi><mo>=</mo><mn>0</mn></mrow></mrow></math>](img/17.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msup><mi>y</mi><mrow><mo>(</mo><mi>λ</mi><mo>)</mo></mrow></msup><mo>=</mo><mi>log</mi><mfenced
    open="(" close=")"><mi>y</mi></mfenced><mi>i</mi><mi>if</mi><mi>λ</mi><mo>=</mo><mn>0</mn></mrow></mrow></math>](img/17.png)'
- en: Here, *y* is the variable and *λ* is the transformation parameter. It includes
    important special cases of transformations, such as untransformed *(λ = 1)*, the
    logarithm *(λ = 0)*, the reciprocal *(λ = - 1)*, the square root (when *λ* *=
    0.5*, it applies a scaled and shifted version of the square root function), and
    the cube root.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*y* 是变量，*λ* 是转换参数。它包括变换的重要特殊情况，例如未转换的 *(λ = 1)*，对数 *(λ = 0)*，倒数 *(λ = -
    1)*，平方根（当 *λ* *= 0.5* 时，它应用了一个缩放和移动的平方根函数），以及立方根。
- en: The Box-Cox transformation evaluates several values of *λ* using the maximum
    likelihood and selects the *λ* parameter that returns the best transformation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Box-Cox 转换使用最大似然估计评估 *λ* 的几个值，并选择返回最佳转换的 *λ* 参数。
- en: In this recipe, we will perform the Box-Cox transformation using scikit-learn
    and Feature-engine.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 scikit-learn 和 Feature-engine 执行 Box-Cox 转换。
- en: Note
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The Box-Cox transformation can only be used on positive variables. If your variables
    have negative values, try the Yeo-Johnson transformation, which is described in
    the next recipe, *Performing Yeo-Johnson transformation*. Alternatively, you can
    shift the variable distribution by adding a constant before the transformation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Box-Cox 转换只能用于正变量。如果你的变量有负值，尝试使用下一道菜谱中描述的 Yeo-Johnson 转换，即*执行 Yeo-Johnson 转换*。或者，你可以在转换前添加一个常数来改变变量的分布。
- en: How to do it...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s begin by importing the necessary libraries and getting the dataset ready:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入必要的库并准备好数据集：
- en: 'Import the required Python libraries and classes:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的 Python 库和类：
- en: '[PRE54]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let’s load the California housing dataset into a pandas DataFrame:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将加利福尼亚住房数据集加载到 pandas DataFrame 中：
- en: '[PRE55]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let’s drop the `Latitude` and `Longitude` variables:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们删除 `Latitude` 和 `Longitude` 变量：
- en: '[PRE56]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let’s inspect the variable distributions with histograms:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用直方图检查变量分布：
- en: '[PRE57]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the following output, we can see that the `MedInc` variable shows a mild
    right-skewed distribution, variables such as `AveRooms` and `Population` are heavily
    right-skewed, and the `HouseAge` variable shows an even spread of values across
    its range:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到 `MedInc` 变量显示出轻微的右偏分布，例如 `AveRooms` 和 `Population` 这样的变量具有严重的右偏分布，而
    `HouseAge` 变量在其范围内显示出值的均匀分布：
- en: '![Figure 3.10 – Histograms of the numerical variables](img/B22396_03_10.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 数值变量的直方图](img/B22396_03_10.jpg)'
- en: Figure 3.10 – Histograms of the numerical variables
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 数值变量的直方图
- en: 'Let’s capture the variable names in a list since we will use these in the following
    step:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在下一步中使用这些变量之前，将变量名捕获到一个列表中：
- en: '[PRE58]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let’s create a function that will plot Q-Q plots for all the variables in the
    data in two rows with three plots each:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，该函数将为数据中的所有变量绘制 Q-Q 图，每行两个，每个三个：
- en: '[PRE59]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, let’s display the Q-Q plots using the preceding function:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用前面的函数显示 Q-Q 图：
- en: '[PRE60]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'By looking at the following plots, we can corroborate that the variables are
    not normally distributed:'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过查看以下图表，我们可以证实变量不是正态分布的：
- en: '![Figure 3.11 – Q-Q plots of the numerical variables](img/B22396_03_11.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 数值变量的 Q-Q 图](img/B22396_03_11.jpg)'
- en: Figure 3.11 – Q-Q plots of the numerical variables
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 数值变量的 Q-Q 图
- en: Next, let’s carry out the Box-Cox transformation using scikit-learn.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 scikit-learn 执行 Box-Cox 转换。
- en: 'Let’s set up `PowerTransformer()` to apply the Box-Cox transformation and fit
    it to the data so that it finds the optimal *λ* parameter:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置 `PowerTransformer()` 以应用 Box-Cox 转换并将其拟合到数据中，以便找到最优的 *λ* 参数：
- en: '[PRE61]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To avoid data leakage, the *λ* parameter should be learned from the train set
    and then used to transform the train and test sets. Thus, remember to split your
    data into train and test sets before fitting `PowerTransformer()`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免数据泄露，*λ* 参数应该从训练集中学习，然后用于转换训练集和测试集。因此，在拟合 `PowerTransformer()` 之前，请记住将你的数据分成训练集和测试集。
- en: 'Now, let’s transform the dataset:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们转换数据集：
- en: '[PRE62]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: scikit-learn’s `PowerTransformer()` stores the learned lambdas in its `lambdas_`
    attribute, which you can display by executing `transformer.lambdas_`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: scikit-learn 的 `PowerTransformer()` 将学习到的 lambda 值存储在其 `lambdas_` 属性中，你可以通过执行
    `transformer.lambdas_` 来显示它。
- en: 'Let’s inspect the distributions of the transformed data with histograms:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过直方图检查变换后数据的分布：
- en: '[PRE63]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the following output, we can see that the variables’ values are more evenly
    spread across their ranges:'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到变量的值在其范围内分布得更均匀：
- en: '![Figure 3.12 – Histograms of the variables after the transformation](img/B22396_03_12.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 变换后变量的直方图](img/B22396_03_12.jpg)'
- en: Figure 3.12 – Histograms of the variables after the transformation
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 变换后变量的直方图
- en: 'Now, let’s return Q-Q plots of the transformed variables:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们返回变换后变量的 Q-Q 图：
- en: '[PRE64]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the following output, we can see that, after the transformation, the variables
    follow the theoretical normal distribution more closely:'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到，经过变换后，变量更接近理论上的正态分布：
- en: "![Figure 3.13 – Q-Q plots o\uFEFFf the variables after the transformation](img/B22396_03_13.jpg)"
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 变换后变量的 Q-Q 图](img/B22396_03_13.jpg)'
- en: Figure 3.13 – Q-Q plots of the variables after the transformation
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 变换后变量的 Q-Q 图
- en: Now, let’s implement the Box-Cox transformation with Feature-engine.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Feature-engine 实现 Box-Cox 变换。
- en: 'Let’s set up `BoxCoxTransformer()` to transform all the variables in the dataset
    and then fit it to the data:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置 `BoxCoxTransformer()` 以转换数据集中的所有变量，并将其拟合到数据：
- en: '[PRE65]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, let’s go ahead and transform the variables:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续变换变量：
- en: '[PRE66]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The transformation returns a pandas DataFrame containing the modified variables.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变换返回一个包含修改后变量的 pandas DataFrame。
- en: Note
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`PowerTransformer()` from scikit-learn will transform the entire dataset. On
    the other hand, `BoxCoxTransformer()` from Feature-engine can modify a subset
    of the variables, if we pass their names in a list to the `variables` parameter
    when setting up the transformer. If the `variables` parameter is set to `None`,
    the transformer will transform all numerical variables seen during `fit()`.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: scikit-learn 的 `PowerTransformer()` 将转换整个数据集。另一方面，Feature-engine 的 `BoxCoxTransformer()`
    可以修改变量子集，如果我们设置转换器时将它们的名称列表传递给 `variables` 参数。如果将 `variables` 参数设置为 `None`，转换器将在
    `fit()` 期间转换所有遇到的数值变量。
- en: 'The optimal lambdas for the Box-Cox transformation are stored in the `lambda_dict_`
    attribute. Let’s inspect them:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Box-Cox 变换的最佳 lambda 值存储在 `lambda_dict_` 属性中。让我们检查一下：
- en: '[PRE67]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The output of the previous command is the following:'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一条命令的输出如下：
- en: '[PRE68]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now you know how to implement the Box-Cox transformation with two different
    Python libraries.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何使用两个不同的 Python 库实现 Box-Cox 变换。
- en: How it works...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: scikit-learn’s `PowerTransformer()` can apply both Box-Cox and Yeo-Johnson transformations,
    so we specified the transformation when setting up the transformer by passing
    the b`ox-cox` string. Next, we fit the transformer to the data so that the transformer
    learned the optimal lambdas for each variable. The learned lambdas were stored
    in the `lambdas_` attribute. Finally, we used the `transform()` method to transform
    the variables.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: scikit-learn 的 `PowerTransformer()` 可以应用 Box-Cox 和 Yeo-Johnson 变换，因此我们在设置转换器时通过传递
    `box-cox` 字符串指定了转换。接下来，我们将转换器拟合到数据，以便转换器学习每个变量的最佳 lambda 值。学习到的 lambda 值存储在 `lambdas_`
    属性中。最后，我们使用 `transform()` 方法转换变量。
- en: Note
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that to return DataFrames instead of arrays, you need to specify the
    transform output through the `set_output()` method. You can apply the transformation
    to a subset of values by using the `ColumnTransformer()`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，要返回 DataFrames 而不是数组，你需要通过 `set_output()` 方法指定转换输出。你可以通过使用 `ColumnTransformer()`
    将转换应用于值子集。
- en: Finally, we applied the Box-Cox transformation using Feature-engine. We initialized
    `BoxCoxTransformer()`, leaving the parameter `variables` set the `None`. Due to
    this, the transformer automatically found the numerical variables in the data
    during `fit()`. We fit the transformer to the data so that it learned the optimal
    lambdas per variable, which were stored in `lambda_dict_`, and transformed the
    variables using the `transform()` method. Feature-engine’s `BoxCoxTransformer()`
    can take the entire DataFrame as input and it yet modify only the selected variables.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 Feature-engine 应用了 Box-Cox 转换。我们初始化 `BoxCoxTransformer()`，将参数 `variables`
    设置为 `None`。因此，转换器在 `fit()` 期间自动找到了数据中的数值变量。我们将转换器拟合到数据中，使其学习每个变量的最佳 λ 值，这些值存储在
    `lambda_dict_` 中，并使用 `transform()` 方法转换变量。Feature-engine 的 `BoxCoxTransformer()`
    可以接受整个 DataFrame 作为输入，并且只修改选定的变量。
- en: There’s more…
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can apply the Box-Cox transformation with the SciPy library. For a code
    implementation, visit this book’s GitHub repository: [https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variable-transformation/Recipe-5-Box-Cox-transformation.ipynb](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variable-transformation/Recipe-5-Box-Cox-transformation.ipynb)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 SciPy 库应用 Box-Cox 转换。有关代码实现，请访问本书的 GitHub 仓库：[https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variable-transformation/Recipe-5-Box-Cox-transformation.ipynb](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variable-transformation/Recipe-5-Box-Cox-transformation.ipynb)
- en: Performing Yeo-Johnson transformations
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 Yeo-Johnson 转换
- en: 'The Yeo-Johnson transformation is an extension of the Box-Cox transformation
    that is no longer constrained to positive values. In other words, the Yeo-Johnson
    transformation can be used on variables with zero and negative values, as well
    as positive values. These transformations are defined as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Yeo-Johnson 转换是 Box-Cox 转换的扩展，不再受正值约束。换句话说，Yeo-Johnson 转换可以用于具有零和负值的变量，以及正值变量。这些转换如下定义：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>λ</mml:mi></mml:mrow></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>λ</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/18.png);
    if λ ≠ 0 and X >= 0'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>λ</mml:mi></mml:mrow></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>λ</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/18.png);
    如果 λ ≠ 0 且 X >= 0'
- en: ln(X + 1 ); if λ = 0 and X >= 0
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ln(X + 1 ); 如果 λ = 0 且 X >= 0
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>−</mo><mstyle
    scriptlevel="+1"><mfrac><mrow><msup><mrow><mo>(</mo><mo>−</mo><mi>X</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mrow><mn>2</mn><mo>−</mo><mi>λ</mi></mrow></msup><mo>−</mo><mn>1</mn></mrow><mrow><mn>2</mn><mo>−</mo><mi>λ</mi></mrow></mfrac></mstyle></mrow></mrow></math>](img/19.png);
    if λ ≠ 2 and X < 0'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>−</mo><mstyle
    scriptlevel="+1"><mfrac><mrow><msup><mrow><mo>(</mo><mo>−</mo><mi>X</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mrow><mn>2</mn><mo>−</mo><mi>λ</mi></mrow></msup><mo>−</mo><mn>1</mn></mrow><mrow><mn>2</mn><mo>−</mo><mi>λ</mi></mrow></mfrac></mstyle></mrow></mrow></math>](img/19.png);
    如果 λ ≠ 2 且 X < 0'
- en: -ln(-X + 1); if λ = 2 and X < 0
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -ln(-X + 1); 如果 λ = 2 且 X < 0
- en: When the variable has only positive values, then the Yeo-Johnson transformation
    is like the Box-Cox transformation of the variable plus one. If the variable has
    only negative values, then the Yeo-Johnson transformation is like the Box-Cox
    transformation of the negative of the variable plus one, at the power of *2- λ*.
    If the variable has a mix of positive and negative values, the Yeo-Johnson transformation
    applies different powers to the positive and negative values.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量只有正值时，Yeo-Johnson 转换类似于变量加一的 Box-Cox 转换。如果变量只有负值，那么 Yeo-Johnson 转换类似于变量负值的
    Box-Cox 转换加一，乘以 *2- λ* 的幂。如果变量既有正值又有负值，Yeo-Johnson 转换会对正负值应用不同的幂。
- en: In this recipe, we will perform the Yeo-Johnson transformation using scikit-learn
    and Feature-engine.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将使用 scikit-learn 和 Feature-engine 执行 Yeo-Johnson 转换。
- en: How to do it...
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let’s begin by importing the necessary libraries and getting the dataset ready:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入必要的库并准备数据集：
- en: 'Import the required Python libraries and classes:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的Python库和类：
- en: '[PRE69]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let’s load the California housing dataset into a pandas DataFrame and then
    drop the `Latitude` and `Longitude` variables:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将加利福尼亚住房数据集加载到pandas DataFrame中，然后删除`Latitude`和`Longitude`变量：
- en: '[PRE70]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We can evaluate the variable distribution with histograms and Q-Q plots, as
    we did in *steps 4* to *7* of the *Performing Box-Cox* *transformations* recipe.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用直方图和Q-Q图评估变量分布，就像我们在*步骤4*到*7*的*执行Box-Cox变换*菜谱中所做的那样。
- en: Now, let’s apply the Yeo-Johnson transformation with scikit-learn.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用scikit-learn应用Yeo-Johnson变换。
- en: 'Let’s set up `PowerTransformer()` with the `yeo-johnson` transformation:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置`PowerTransformer()`使用`yeo-johnson`变换：
- en: '[PRE71]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let’s fit the transformer to the data:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将转换器拟合到数据中：
- en: '[PRE72]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The *λ* parameter should be learned from the train set and then used to transform
    the train and test sets. Thus, remember to separate your data into train and test
    sets before fitting `PowerTransformer()`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '*λ*参数应该从训练集中学习，然后用于变换训练集和测试集。因此，在拟合`PowerTransformer()`之前，请记住将你的数据分为训练集和测试集。'
- en: 'Now, let’s transform the dataset:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们转换数据集：
- en: '[PRE73]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`PowerTransformer()` stores the learned parameters in its `lambda_` attribute,
    which you can return by executing `transformer.lambdas_`.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`PowerTransformer()`将其学习到的参数存储在其`lambda_`属性中，你可以通过执行`transformer.lambdas_`来返回。'
- en: 'Let’s inspect the distributions of the transformed data with histograms:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用直方图检查变换数据的分布：
- en: '[PRE74]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the following output, we can see that the variables’ values are more evenly
    spread across their ranges:'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到变量的值在其范围内分布得更均匀：
- en: '![Figure 3.14 – Histograms of the variables after the yeo-Johnson transformation](img/B22396_03_14.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14 – yeo-Johnson变换后变量的直方图](img/B22396_03_14.jpg)'
- en: Figure 3.14 – Histograms of the variables after the yeo-Johnson transformation
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – yeo-Johnson变换后变量的直方图
- en: Finally, let’s implement the Yeo-Johnson transformation with Feature-engine.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用Feature-engine实现Yeo-Johnson变换。
- en: 'Let’s set up `YeoJohnsonTransformer()` to transform all numerical variables
    and then fit it to the data:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置`YeoJohnsonTransformer()`以转换所有数值变量，然后将其拟合到数据中：
- en: '[PRE75]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the `variables` argument is left set to `None`, the transformer selects and
    transforms all the numerical variables in the dataset. Alternatively, we can pass
    the names of the variables to modify in a list.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`variables`参数设置为`None`，转换器将选择并转换数据集中所有的数值变量。或者，我们可以传递一个包含要修改的变量名称的列表。
- en: Compared to `PowerTransformer()` from scikit-learn, Feature-engine’s transformer
    can take the entire DataFrame as an argument of the `fit()` and `transform()`
    methods, and yet it will only modify the selected variables.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 与scikit-learn的`PowerTransformer()`相比，Feature-engine的转换器可以将整个DataFrame作为`fit()`和`transform()`方法的参数，同时它只会修改选定的变量。
- en: 'Let’s transform the variables:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转换变量：
- en: '[PRE76]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`YeoJohnsonTransformer()` stores the best parameters per variable in its `lambda_dict_`
    attribute, which we can display as follows:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`YeoJohnsonTransformer()`将其每个变量的最佳参数存储在其`lambda_dict_`属性中，我们可以如下显示：'
- en: '[PRE77]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The previous command returns the following dictionary:'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的命令返回以下字典：
- en: '[PRE78]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Now you know how to implement the Yeo-Johnson transformation with two different
    open source libraries.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用两个不同的开源库实现Yeo-Johnson变换。
- en: How it works...
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we applied the Yeo-Johnson transformation using `scikit-learn`
    and `Feature-engine`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了`scikit-learn`和`Feature-engine`应用了Yeo-Johnson变换。
- en: '`scikit-learn`’s `PowerTransformer()` can apply both Box-Cox and Yeo-Johnson
    transformations, so we specified the transformation with the `yeo-johnson` string.
    The `standardize` argument allowed us to determine whether we wanted to standardize
    (scale) the transformed values. Next, we fit the transformer to the DataFrame
    so that it learned the optimal lambdas for each variable. `PowerTransformer()`
    stored the learned lambdas in its `lambdas_` attribute. Finally, we used the `transform()`
    method to return the transformed variables. We set the transform output to `pandas`
    to return DataFrames after the transformation.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`scikit-learn`的`PowerTransformer()`可以应用Box-Cox和Yeo-Johnson变换，因此我们使用`yeo-johnson`字符串指定了变换。`standardize`参数允许我们确定是否想要标准化（缩放）变换后的值。接下来，我们将转换器拟合到DataFrame，以便它为每个变量学习最优的λ值。`PowerTransformer()`将学习到的λ值存储在其`lambdas_`属性中。最后，我们使用`transform()`方法返回变换后的变量。我们将变换输出设置为`pandas`，以便在变换后返回DataFrame。'
- en: After that, we applied the Yeo-Johnson transformation using Feature-engine.
    We set up `YeoJohnsonTransformer()` so that it transforms all numerical variables
    seen during `fit()`. We fitted the transformer to the data so that it learned
    the optimal lambdas per variable, which were stored in `lambda_dict_`, and finally
    transformed the variables using the `transform()` method. Feature-engine’s `YeoJohnnsonTransformer()`
    can take the entire DataFrame as input, yet it will only transform the selected
    variables.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用Feature-engine应用了Yeo-Johnson转换。我们设置了`YeoJohnsonTransformer()`，以便在`fit()`过程中转换所有数值变量。我们将转换器拟合到数据上，以便它学习每个变量的最优lambda值，这些值存储在`lambda_dict_`中，并最终使用`transform()`方法转换变量。Feature-engine的`YeoJohnnsonTransformer()`可以接受整个DataFrame作为输入，但它只会转换选定的变量。
- en: There’s more…
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'We can apply the Yeo-Johnson transformation with the SciPy library. For a code
    implementation, visit this book’s GitHub repository: [https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Second-Edition/blob/main/ch03-variable-transformation/Recipe-6-Yeo-Johnson-transformation.ipynb](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Second-Edition/blob/main/ch03-variable-transformation/Recipe-6-Yeo-Johnson-transformation.ipynb)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用SciPy库应用Yeo-Johnson转换。有关代码实现，请访问本书的GitHub仓库：[https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Second-Edition/blob/main/ch03-variable-transformation/Recipe-6-Yeo-Johnson-transformation.ipynb](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Second-Edition/blob/main/ch03-variable-transformation/Recipe-6-Yeo-Johnson-transformation.ipynb)
