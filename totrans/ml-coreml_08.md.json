["```py\n{\n    \"key_id\":\"5891796615823360\",\n    \"word\":\"nose\",\n    \"countrycode\":\"AE\",\n    \"timestamp\":\"2017-03-01 20:41:36.70725 UTC\",\n    \"recognized\":true,\n    \"drawing\":[[[129,128,129,129,130,130,131,132,132,133,133,133,133,...]]]\n }\n```", "```py\n[\n    [ // First stroke\n    [x0, x1, x2, x3, ...],\n    [y0, y1, y2, y3, ...],\n    [t0, t1, t2, t3, ...]\n ],\n    [ // Second stroke\n    [x0, x1, x2, x3, ...],\n    [y0, y1, y2, y3, ...],\n    [t0, t1, t2, t3, ...]\n ],\n    ... // Additional strokes\n ]\n```", "```py\nif let rJson = loadedJSON[\"small_raw_airplane\"],\n    let sJson = loadedJSON[\"small_simplified_airplane\"]{\n\n    if let rSketch = StrokeSketch.createFromJSON(json: rJson[0] as?   [String:Any]),\n        let sSketch = StrokeSketch.createFromJSON(json: sJson[0] as? [String:Any]){\n        drawSketch(sketch: rSketch)\n        drawSketch(sketch: sSketch)\n    }\n\n    if let rSketch = StrokeSketch.createFromJSON(json: rJson[1] as? [String:Any]),\n        let sSketch = StrokeSketch.createFromJSON(json: sJson[1] as? [String:Any]){\n        drawSketch(sketch: rSketch)\n        drawSketch(sketch: sSketch)\n    }\n}\n```", "```py\npublic func simplify() -> StrokeSketch{\n    let copy = self.copy() as! StrokeSketch     \n}\n```", "```py\nlet minPoint = copy.minPoint\nlet maxPoint = copy.maxPoint\nlet scale = CGPoint(x: maxPoint.x-minPoint.x, y:maxPoint.y-minPoint.y)\n\nvar width : CGFloat = 255.0\nvar height : CGFloat = 255.0\n\n// adjust aspect ratio\nif scale.x > scale.y{\n    height *= scale.y/scale.x\n} else{\n    width *= scale.y/scale.x\n} \n```", "```py\nfor i in 0..<copy.strokes.count{\n    copy.strokes[i].points = copy.strokes[i].points.map({ (pt) -> CGPoint in\n        let x : CGFloat = CGFloat(Int(((pt.x - minPoint.x)/scale.x) * width))\n        let y : CGFloat = CGFloat(Int(((pt.y - minPoint.y)/scale.y) * height))        \n        return CGPoint(x:x, y:y)\n    })\n}   \n```", "```py\ncopy.strokes = copy.strokes.map({ (stroke) -> Stroke in\n    return stroke.simplify()\n})\n\nreturn copy\n```", "```py\npublic extension CGPoint{\n\n    public static func getSquareSegmentDistance(p0:CGPoint,\n                                                p1:CGPoint,\n                                                p2:CGPoint) -> CGFloat{\n        let x0 = p0.x, y0 = p0.y\n        var x1 = p1.x, y1 = p1.y\n        let x2 = p2.x, y2 = p2.y\n        var dx = x2 - x1\n        var dy = y2 - y1\n\n        if dx != 0.0 && dy != 0.0{\n            let numerator = (x0 - x1)\n                * dx + (y0 - y1)\n                * dy\n            let denom = dx * dx + dy * dy\n            let t = numerator / denom\n\n            if t > 1.0{\n                x1 = x2\n                y1 = y2\n            } else{\n                x1 += dx * t\n                y1 += dy * t\n            }\n        }\n\n        dx = x0 - x1\n        dy = y0 - y1\n\n        return dx * dx + dy * dy\n    }\n} \n```", "```py\npublic extension Stroke{\n}\n```", "```py\nfunc simplifyDPStep(points:[CGPoint], first:Int, last:Int,\n                    tolerance:CGFloat, simplified: inout [CGPoint]){\n\n    var maxSqDistance = tolerance\n    var index = 0\n\n    for i in first + 1..<last{\n        let sqDist = CGPoint.getSquareSegmentDistance(\n            p0: points[i],\n            p1: points[first],\n            p2: points[last])\n\n        if sqDist > maxSqDistance {\n            maxSqDistance = sqDist\n            index = i\n        }\n    }\n\n    if maxSqDistance > tolerance{\n        if index - first > 1 {\n            simplifyDPStep(points: points,\n                           first: first,\n                           last: index,\n                           tolerance: tolerance,\n                           simplified: &simplified)\n        }\n\n        simplified.append(points[index])\n\n        if last - index > 1{\n            simplifyDPStep(points: points,\n                           first: index,\n                           last: last,\n                           tolerance: tolerance,\n                           simplified: &simplified)\n        }\n    }\n} \n```", "```py\npublic func simplify(epsilon:CGFloat=3.0) -> Stroke{\n\n    var simplified: [CGPoint] = [self.points.first!]\n\n    self.simplifyDPStep(points: self.points,\n                        first: 0, last: self.points.count-1,\n                        tolerance: epsilon * epsilon,\n                        simplified: &simplified)\n\n    simplified.append(self.points.last!)\n\n    let copy = self.copy() as! Stroke\n    copy.points = simplified\n\n    return copy\n}\n```", "```py\n  if let rJson = loadedJSON[\"small_raw_airplane\"],\n    let sJson = loadedJSON[\"small_simplified_airplane\"]{\n\n    if let rSketch = StrokeSketch.createFromJSON(json: rJson[2] as? [String:Any]),\n        let sSketch = StrokeSketch.createFromJSON(json: sJson[2] as? [String:Any]){\n        drawSketch(sketch: rSketch)\n        drawSketch(sketch: sSketch)\n        drawSketch(sketch: rSketch.simplify())\n    }\n}\n```", "```py\nextension StrokeSketch{\n\n    public static func preprocess(_ sketch:StrokeSketch)\n        -> MLMultiArray?{\n        let arrayLen = NSNumber(value:75 * 3) \n\n        guard let array = try? MLMultiArray(shape: [arrayLen],\n                                            dataType: .double)\n            else{ return nil }\n\n        let simplifiedSketch = sketch.simplify()\n\n    }\n}     \n```", "```py\nlet minPoint = simplifiedSketch.minPoint\nlet maxPoint = simplifiedSketch.maxPoint\nlet scale = CGPoint(x: maxPoint.x-minPoint.x,\n                    y:maxPoint.y-minPoint.y)\n\nvar data = Array<Double>()\n\nfor i in 0..<simplifiedSketch.strokes.count{\n    for j in 0..<simplifiedSketch.strokes[i].points.count{\n        let point = simplifiedSketch.strokes[i].points[j]\n        let x = (point.x-minPoint.x)/scale.x\n        let y = (point.y-minPoint.y)/scale.y\n        let z = j == simplifiedSketch.strokes[i].points.count-1\n            ? 1 : 0\n\n        data.append(Double(x))\n        data.append(Double(y))\n        data.append(Double(z))\n    }\n```", "```py\nlet dataStride : Int = 3\nfor i in stride(from: dataStride, to:data.count, by: dataStride){\n    data[i - dataStride] = data[i] - data[i - dataStride] \n    data[i - (dataStride-1)] = data[i+1] - data[i - (dataStride-1)] \n    data[i - (dataStride-2)] = data[i+2] \n}\n\ndata.removeLast(3)\n```", "```py\nvar dataIdx : Int = 0\nlet startAddingIdx = max(array.count-data.count, 0)\n\nfor i in 0..<array.count{\n    if i >= startAddingIdx{\n        array[i] = NSNumber(value:data[dataIdx])\n        dataIdx = dataIdx + 1\n    } else{\n        array[i] = NSNumber(value:0)\n    }\n}\n\nreturn array\n```", "```py\nlet model = quickdraw()\n\nif let json = loadedJSON[\"small_raw_airplane\"]{\n    if let sketch = StrokeSketch.createFromJSON(json: json[0] as? [String:Any]){\n        if let x = StrokeSketch.preprocess(sketch){\n            if let predictions = try? model.prediction(input:quickdrawInput(strokeSeq:x)){\n                print(\"Class label \\(predictions.classLabel)\")\n                print(\"Class label probability/confidence \\(predictions.classLabelProbs[\"airplane\"] ?? 0)\")\n            }\n        }\n    }\n}\n```", "```py\nfunc makePrediction(key:String, index:Int) -> String{\n    if let json = loadedJSON[key]{\n        if let sketch = StrokeSketch.createFromJSON(\n            json: json[index] as? [String:Any]){\n            if let x = StrokeSketch.preprocess(sketch){\n                if let predictions = try? model.prediction(input:quickdrawInput(strokeSeq:x)){\n                    return \"\\(predictions.classLabel) \\(predictions.classLabelProbs[predictions.classLabel] ?? 0)\"\n                }\n            }\n        }\n    }\n\n    return \"None\"\n}\n```", "```py\nprint(makePrediction(key: \"small_raw_airplane\", index: 0))\nprint(makePrediction(key: \"small_raw_alarm_clock\", index: 1))\nprint(makePrediction(key: \"small_raw_bee\", index: 2))\nprint(makePrediction(key: \"small_raw_sailboat\", index: 3))\nprint(makePrediction(key: \"small_raw_train\", index: 4))\nprint(makePrediction(key: \"small_raw_truck\", index: 5))\nprint(makePrediction(key: \"small_simplified_airplane\", index: 0))\n```", "```py\nif let json = loadedJSON[\"small_raw_bee\"]{\n    if let sketch = StrokeSketch.createFromJSON(json: json[2] as? [String:Any]){\n        let strokeCount = sketch.strokes.count\n        print(\"\\(sketch.label ?? \"\" ) sketch has \\(strokeCount) strokes\")\n\n        for i in (0..<strokeCount-1).reversed(){\n            let copyOfSketch = sketch.copy() as! StrokeSketch\n            copyOfSketch.strokes.removeLast(i)\n            if let x = StrokeSketch.preprocess(copyOfSketch){\n                if let predictions = try? model.prediction(input:quickdrawInput(strokeSeq:x)){\n                    let label = predictions.classLabel\n                    let probability = String(format: \"%.2f\", predictions.classLabelProbs[predictions.classLabel] ?? 0)\n\n                    print(\"Guessing \\(label) with probability of \\(probability) using \\(copyOfSketch.strokes.count) strokes\")\n                }\n            }\n        }\n    }\n} \n```", "```py\nlet compiledUrl = try MLModel.compileModel(at: modelUrl)\nlet model = try MLModel(contentsOf: compiledUrl)\n```", "```py\nprivate var SyncTimestampKey : String{\n    get{\n        return \"model_sync_timestamp\"\n    }\n}\n\nprivate var ModelUrlKey : String{\n    get{\n        return \"model_url\"\n    }\n}\n\nprivate var isModelStale : Bool{\n    get{\n        if let modelUrl = UserDefaults.standard.string(\n            forKey: self.ModelUrlKey){\n            if !FileManager.default.fileExists(atPath: modelUrl){\n                return true\n            }\n        }\n\n        let daysToUpdate : Int = 10\n        let lastUpdated = Date(timestamp:UserDefaults.standard.integer(forKey: SyncTimestampKey))\n\n        guard let numberOfDaysSinceUpdate = NSCalendar.current.dateComponents([.day], from: lastUpdated, to: Date()).day else{\n            fatalError(\"Failed to calculated elapsed days since the model was updated\")\n        }\n        return numberOfDaysSinceUpdate >= daysToUpdate\n    }\n}\n```", "```py\nprivate func downloadModel() -> URL?{\n    guard let modelUrl = URL(\n        string:\"https://github.com/joshnewnham/MachineLearningWithCoreML/blob/master/CoreMLModels/Chapter8/quickdraw.mlmodel?raw=true\") else{\n            fatalError(\"Invalid URL\")\n    }\n\n    var tempUrl : URL?\n\n    let sessionConfig = URLSessionConfiguration.default\n    let session = URLSession(configuration: sessionConfig)\n\n    let request = URLRequest(url:modelUrl)\n\n let semaphore = DispatchSemaphore(value: 0)\n\n    let task = session.downloadTask(with: request) { (tempLocalUrl, response, error) in\n        if let tempLocalUrl = tempLocalUrl, error == nil {\n            tempUrl = tempLocalUrl\n        } else {\n            fatalError(\"Error downloading model \\(String(describing: error?.localizedDescription))\")\n        }\n\n semaphore.signal()\n    }\n    task.resume()\n _ = semaphore.wait(timeout: .distantFuture)\n\n    return tempUrl\n}\n```", "```py\nprivate func syncModel(){\n    queryQueue.async {\n\n        if self.isModelStale{\n            guard let tempModelUrl = self.downloadModel() else{\n                return\n            }\n\n            guard let compiledUrl = try? MLModel.compileModel(\n                at: tempModelUrl) else{\n                fatalError(\"Failed to compile model\")\n            }\n\n            let appSupportDirectory = try! FileManager.default.url(\n                for: .applicationSupportDirectory,\n                in: .userDomainMask,\n                appropriateFor: compiledUrl,\n                create: true)\n\n            let permanentUrl = appSupportDirectory.appendingPathComponent(\n                compiledUrl.lastPathComponent)\n            do {\n                if FileManager.default.fileExists(\n                    atPath: permanentUrl.absoluteString) {\n                    _ = try FileManager.default.replaceItemAt(\n                        permanentUrl,\n                        withItemAt: compiledUrl)\n                } else {\n                    try FileManager.default.copyItem(\n                        at: compiledUrl,\n                        to: permanentUrl)\n                }\n            } catch {\n                fatalError(\"Error during copy: \\(error.localizedDescription)\")\n            }\n\n            UserDefaults.standard.set(Date.timestamp,\n                                      forKey: self.SyncTimestampKey)\n            UserDefaults.standard.set(permanentUrl.absoluteString,\n                                      forKey:self.ModelUrlKey)\n        }\n\n        guard let modelUrl = URL(\n            string:UserDefaults.standard.string(forKey: self.ModelUrlKey) ?? \"\")\n            else{\n            fatalError(\"Invalid model Url\")\n        }\n\n        self.model = try? MLModel(contentsOf: modelUrl)\n    }\n}\n```", "```py\nguard let tempModelUrl = self.downloadModel() else{\n    return\n}\n\nguard let compiledUrl = try? MLModel.compileModel(\n    at: tempModelUrl) else{\n    fatalError(\"Failed to compile model\")\n}\n```", "```py\nlet appSupportDirectory = try! FileManager.default.url(\n    for: .applicationSupportDirectory,\n    in: .userDomainMask,\n    appropriateFor: compiledUrl,\n    create: true)\n\nlet permanentUrl = appSupportDirectory.appendingPathComponent(\n    compiledUrl.lastPathComponent)\ndo {\n    if FileManager.default.fileExists(\n        atPath: permanentUrl.absoluteString) {\n        _ = try FileManager.default.replaceItemAt(\n            permanentUrl,\n            withItemAt: compiledUrl)\n    } else {\n        try FileManager.default.copyItem(\n            at: compiledUrl,\n            to: permanentUrl)\n    }\n} catch {\n    fatalError(\"Error during copy: \\(error.localizedDescription)\")\n}\n\nUserDefaults.standard.set(Date.timestamp,\n                          forKey: self.SyncTimestampKey)\nUserDefaults.standard.set(permanentUrl.absoluteString,\n                          forKey:self.ModelUrlKey)\n```", "```py\ninit() {\n    syncModel()\n}\n```", "```py\nextension CGPoint{\n    public static func getSquareSegmentDistance(\n        p0:CGPoint,\n        p1:CGPoint,\n        p2:CGPoint) -> CGFloat{\n        let x0 = p0.x, y0 = p0.y\n        var x1 = p1.x, y1 = p1.y\n        let x2 = p2.x, y2 = p2.y\n        var dx = x2 - x1\n        var dy = y2 - y1\n\n        if dx != 0.0 && dy != 0.0{\n            let numerator = (x0 - x1) * dx + (y0 - y1) * dy\n            let denom = dx * dx + dy * dy\n            let t = numerator / denom\n\n            if t > 1.0{\n                x1 = x2\n                y1 = y2\n            } else{\n                x1 += dx * t\n                y1 += dy * t\n            }\n        }\n\n        dx = x0 - x1\n        dy = y0 - y1\n\n        return dx * dx + dy * dy\n    }\n}\n```", "```py\nextension Stroke{\n\n    public func simplify(epsilon:CGFloat=3.0) -> Stroke{\n\n        var simplified: [CGPoint] = [self.points.first!]\n\n        self.simplifyDPStep(points: self.points,\n                            first: 0, last: self.points.count-1,\n                            tolerance: epsilon * epsilon,\n                            simplified: &simplified)\n\n        simplified.append(self.points.last!)\n\n        let copy = self.copy() as! Stroke\n        copy.points = simplified\n\n        return copy\n    }\n\n    func simplifyDPStep(points:[CGPoint],\n                        first:Int,\n                        last:Int,\n                        tolerance:CGFloat,\n                        simplified: inout [CGPoint]){\n\n        var maxSqDistance = tolerance\n        var index = 0\n\n        for i in first + 1..<last{\n            let sqDist = CGPoint.getSquareSegmentDistance(\n                p0: points[i],\n                p1: points[first],\n                p2: points[last])\n\n            if sqDist > maxSqDistance {\n                maxSqDistance = sqDist\n                index = i\n            }\n        }\n\n        if maxSqDistance > tolerance{\n            if index - first > 1 {\n                simplifyDPStep(points: points,\n                               first: first,\n                               last: index,\n                               tolerance: tolerance,\n                               simplified: &simplified)\n            }\n\n            simplified.append(points[index])\n\n            if last - index > 1{\n                simplifyDPStep(points: points,\n                               first: index,\n                               last: last,\n                               tolerance: tolerance,\n                               simplified: &simplified)\n            }\n        }\n    }\n}\n```", "```py\nimport UIKit\nimport CoreML\n\nextension StrokeSketch{\n\n}\n```", "```py\npublic func simplify() -> StrokeSketch{\n    let copy = self.copy() as! StrokeSketch\n    copy.scale = 1.0\n\n    let minPoint = copy.minPoint\n    let maxPoint = copy.maxPoint\n    let scale = CGPoint(x: maxPoint.x-minPoint.x,\n                        y:maxPoint.y-minPoint.y)\n\n    var width : CGFloat = 255.0\n    var height : CGFloat = 255.0\n\n    if scale.x > scale.y{\n        height *= scale.y/scale.x\n    } else{\n        width *= scale.y/scale.x\n    }\n\n    // for each point, subtract the min and divide by the max\n    for i in 0..<copy.strokes.count{\n        copy.strokes[i].points = copy.strokes[i].points.map({\n            (pt) -> CGPoint in\n            let x : CGFloat = CGFloat(\n                Int(((pt.x - minPoint.x)/scale.x) * width)\n            )\n            let y : CGFloat = CGFloat(\n                Int(((pt.y - minPoint.y)/scale.y) * height)\n            )\n\n            return CGPoint(x:x, y:y)\n        })\n    }\n\n    copy.strokes = copy.strokes.map({ (stroke) -> Stroke in\n        return stroke.simplify()\n    })\n\n    return copy\n}\n```", "```py\npublic static func preprocess(_ sketch:StrokeSketch)\n    -> MLMultiArray?{\n    let arrayLen = NSNumber(value:75 * 3) \n\n    let simplifiedSketch = sketch.simplify()\n\n    guard let array = try? MLMultiArray(shape: [arrayLen],\n                                        dataType: .double)\n        else{ return nil }\n\n    let minPoint = simplifiedSketch.minPoint\n    let maxPoint = simplifiedSketch.maxPoint\n    let scale = CGPoint(x: maxPoint.x-minPoint.x,\n                        y:maxPoint.y-minPoint.y)\n\n    var data = Array<Double>()\n    for i in 0..<simplifiedSketch.strokes.count{\n        for j in 0..<simplifiedSketch.strokes[i].points.count{\n            let point = simplifiedSketch.strokes[i].points[j]\n            let x = (point.x-minPoint.x)/scale.x\n            let y = (point.y-minPoint.y)/scale.y\n            let z = j == simplifiedSketch.strokes[i].points.count-1 ?\n                1 : 0\n\n            data.append(Double(x))\n            data.append(Double(y))\n            data.append(Double(z))\n        }\n    }\n\n    let dataStride : Int = 3\n    for i in stride(from: dataStride, to:data.count, by: dataStride){\n        data[i - dataStride] = data[i] - data[i - dataStride] \n        data[i - (dataStride-1)] = data[i+1] - data[i - (dataStride-1)] \n        data[i - (dataStride-2)] = data[i+2] // EOS\n    }\n\n    data.removeLast(3)\n\n    var dataIdx : Int = 0\n    let startAddingIdx = max(array.count-data.count, 0)\n\n    for i in 0..<array.count{\n        if i >= startAddingIdx{\n            array[i] = NSNumber(value:data[dataIdx])\n            dataIdx = dataIdx + 1\n        } else{\n            array[i] = NSNumber(value:0)\n        }\n    }\n\n    return array\n}\n```", "```py\nclass quickdrawInput : MLFeatureProvider {\n\n    var strokeSeq: MLMultiArray\n\n    var featureNames: Set<String> {\n        get {\n            return [\"strokeSeq\"]\n        }\n    }\n\n    func featureValue(for featureName: String) -> MLFeatureValue? {\n        if (featureName == \"strokeSeq\") {\n            return MLFeatureValue(multiArray: strokeSeq)\n        }\n        return nil\n    }\n\n    init(strokeSeq: MLMultiArray) {\n        self.strokeSeq = strokeSeq\n    }\n}\n```", "```py\nif let strokeSketch = sketch as? StrokeSketch, let\n    x = StrokeSketch.preprocess(strokeSketch){\n\n    if let modelOutput = try! model?.prediction(from:quickdrawInput(strokeSeq:x)){\n        if let classPredictions = modelOutput.featureValue(\n            for: \"classLabelProbs\")?.dictionaryValue as? [String:Double]{\n\n            let sortedClassPredictions = classPredictions.sorted(\n                by: { (kvp1, kvp2) -> Bool in\n                kvp1.value > kvp2.value\n            })\n\n            return sortedClassPredictions\n        }\n    }\n}\n\nreturn nil\n```"]