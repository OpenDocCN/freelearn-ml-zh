<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Designing Functions and Interfaces</h1>
                </header>
            
            <article>
                
<p>This chapter will continue looking at the fundamental concepts of Julia. The topics that we have chosen here will provide a solid foundation of the key concepts of Julia programming. In particular, we will discuss the core Julia programming <span>techniques that are </span>related to functions and interfaces. Functions are the fundamental building blocks of software. Interfaces are contractual relationships between different components of the software. Effective use of functions and interfaces is a must for building robust applications.</p>
<p><span>The following topics will be covered in this chapter:</span></p>
<ul>
<li>Functions</li>
<li>Multiple <span>dispatch</span></li>
<li>Parametric methods</li>
<li>Interfaces</li>
</ul>
<p>As part of the learning process, we will go over a use case of game design. More specifically, we will pretend that we are building a space war game that contains a game board with spaceships and asteroid pieces. We will build functions that move the game pieces around and equip the spaceships with weapons to blow things up.</p>
<p>By the end of this chapter, you will have the necessary knowledge to design and develop functions effectively. Through the use of multiple <span>dispatch </span>and parametric methods, your application will become more extendable. Once you have learned these techniques, you should also be able to design a system that contains pluggable components based on interfaces.</p>
<p>I can't wait any longer. Let's get started!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The sample source code is located at <a href="https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter03">https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter03</a>.</p>
<p>The code is tested in a Julia 1.3.0 environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing functions</h1>
                </header>
            
            <article>
                
<p>Function is a core construct in Julia for defining the behaviors of an application. In fact, Julia works more like a procedural/functional programming language as opposed <span>to an object-oriented programming language. In object-oriented programming, you focus on building classes and defining functions for those classes. In Julia, you focus on building functions that operate on data types or data structures.</span></p>
<p><span>In this section, we will demonstrate how functions are defined and the powerful features that come with functions.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Our use case – a space war game</h1>
                </header>
            
            <article>
                
<p>Throughout this chapter, we will illustrate programming concepts by building parts of a space war game. The design of the game is very simple and straightforward. It consists of game pieces such as spaceships and asteroids that are scattered around a two-dimensional grid. These game pieces are called widgets in our program.</p>
<p>Let's first define our data types as follows:</p>
<pre># Space war game!<br/><br/>mutable struct Position<br/>    x::Int<br/>    y::Int<br/>end<br/><br/>struct Size<br/>    width::Int<br/>    height::Int<br/>end<br/><br/>struct Widget<br/>    name::String<br/>    position::Position<br/>    size::Size<br/>end</pre>
<p>As data types are central to our design, this warrants a little more explanation:</p>
<ul>
<li>The <kbd>Position</kbd> type is used to store the coordinates of a game piece. It is represented by two integers: <kbd>x</kbd> and <kbd>y</kbd>.</li>
<li>The <kbd>Size</kbd> type is used to store the size of a game piece. It is represented <span>by</span> two integers: <kbd>width</kbd> and <kbd>height</kbd>.</li>
<li>The <kbd>Widget</kbd> type is used to hold a single game piece. It is represented by a <kbd>name</kbd>, <kbd>position</kbd>, and <kbd>size</kbd>.</li>
</ul>
<p>Note that the <kbd>Position</kbd> type is mutable because we expect our game pieces to move around by just updating their coordinates.</p>
<p>Next, we will go over a number of topics related to how functions are defined.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining functions</h1>
                </header>
            
            <article>
                
<p>There are actually two different syntaxes that we can use to define a function:</p>
<ul>
<li>The first way is a simple one-liner that contains both the signature and body of the function.</li>
<li>The second way uses the <kbd>function</kbd> keyword with the signature, followed by the code block and the <kbd>end</kbd> keyword.</li>
</ul>
<p>If the function is simple enough—for example, if it just has a single instruction—then it is usually more preferable to write the function in a single line. This style of function definition is very common for scientific computing projects, as many functions simply mimic the corresponding mathematical formulae.</p>
<p>For our game, we can just write four functions for moving the game pieces around the board by modifying the coordinates of the widget:</p>
<pre># single-line functions<br/>move_up!(widget, v)    = widget.position.y -= v<br/>move_down!(widget, v)  = widget.position.y += v<br/>move_left!(widget, v)  = widget.position.x -= v<br/>move_right!(widget, v) = widget.position.x += v</pre>
<p>It is indeed quite idiomatic in Julia to write single-line functions. People coming from a different background may find it more intuitive to write the following, more verbose, form. There is nothing wrong with this; both forms work just fine:</p>
<pre># long version<br/>function move_up!(widget, v)<br/>    widget.position.y -= v<br/>end</pre>
<p>There are a few things to bear in mind about how these functions are written:</p>
<ul>
<li><strong>Use of underscore</strong>: The preceding function names use an underscore to separate the words. According to the official Julia manual, the convention is to just smash the words together without any separators unless it becomes too confusing or hard to read. My personal opinion is that underscore should always be used for multi-word function names because it enhances the readability and makes the code more consistent.</li>
<li><strong>Use of exclamation mark</strong><span>: The preceding function names contain exclamation mark to indicate that the function mutates the state of the object that is being passed into the function. This is a good practice because it reminds the developer that there will be side effects when calling the function.</span></li>
<li><strong>Duck typing</strong>:<strong> </strong><span>You may wonder why the function</span> arguments are not annotated with any type information. I<span>n the</span> <kbd>move_up!</kbd> <span>function, although we do not have any type annotation, we expect the</span> <kbd>widget</kbd> <span>argument to have the</span> <kbd>Widget</kbd> <span>type and</span> <kbd>v</kbd><span> to have the</span> <kbd>Int</kbd><span> type wh</span>en the function is used. This is an interesting topic, and we will discuss it further in the next section.</li>
</ul>
<p>As you can see, defining functions is a fairly straightforward task, and the way Julia handles function arguments is quite interesting. We will go over this next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Annotating function arguments</h1>
                </header>
            
            <article>
                
<p>In a statically typed language without any polymorphism, such as C or Fortran, every argument must be specified with the exact type. Julia, however, is dynamically typed and supports duck typing—<em>if it walks like a duck and quacks like a duck, then it is a duck</em>. Type information is not required in the source code at all. Instead, the compiler looks at runtime types that you pass into the function and compiles the appropriate method specialized for those types. The process of deducing types throughout a method body based on the argument types is called <strong>type inference</strong>. </p>
<p>Therefore, there is no need to annotate function arguments with type information at all. People sometimes get the impression that putting type annotations all over their Julia code will improve performance. That is not usually the case. For method signatures, types have no effect on performance: they are only useful to control dispatch.</p>
<p>So, what would you choose? Annotate arguments with types or not?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Untyped arguments</h1>
                </header>
            
            <article>
                
<p>When function arguments are not annotated with type information, the function is actually more flexible. Why? That's because it can work with any type that you pass into the function. Let's say that, in the future, the coordinate system is changed from <kbd>Int</kbd> to <kbd>Float64</kbd>. When this happens, the function will not need to be changed: it just works!</p>
<p>In contrast, keeping everything untyped may not be the best idea either because the function cannot really work with every possible data type that is defined in the world. In addition, it could often lead to obscure exception messages and make the program more difficult to debug. For instance, if we were to pass an <kbd>Int</kbd> value as the <kbd>Widget</kbd> argument to the <kbd>move_up!</kbd> function by mistake, then it will complain about the type not having a <kbd>position</kbd> field:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2f002970-d5a3-4330-a80f-9b4932e66fc3.png" style="width:26.42em;height:3.42em;"/></p>
<p>The error message is quite obscure. Is there anything that we can do to make debugging a little easier? The answer is that we could provide the type of function arguments. Let's see how this can be done.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Typed arguments</h1>
                </header>
            
            <article>
                
<p>We know that our implementation of the <kbd>move</kbd> functions comes with some implicit design assumptions:</p>
<ul>
<li>The value of <kbd>v</kbd> should be a numerical value, as implied by the <kbd>+</kbd> or <kbd>-</kbd> operator.</li>
<li>The <kbd>widget</kbd> <span>has to be a</span> <kbd>Widget</kbd><span> object, or at least something that contains a</span> <kbd>Position</kbd> <span>object, as implied by the access of the</span> <kbd>position</kbd> <span>field.</span></li>
</ul>
<p>For these reasons, it's generally safer to define functions with some type information. Having said that, the <kbd>move_up!</kbd> function can be redefined as follows:</p>
<pre>move_up!(widget::Widget, v::Int) = widget.position.y -= v</pre>
<p>If we just define all <kbd>move</kbd> functions the same way, then debugging becomes easier. Suppose that we make the same mistake as we did in the preceding code by passing an integer as the first argument: we will now receive a more sensible error message:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7f2f41a4-84ce-4c4b-bc3a-23ff2bcc9019.png" style="width:40.83em;height:6.08em;"/></p>
<p>So instead of trying to run the function and failing miserably with an unknown effect, the Julia compiler will now tell us that the method does not exist for the argument types that we pass into the function.</p>
<p>Before we move on to the next topic, let's at least play a little bit of the game. In order to display these objects more nicely in the Julia REPL, we can define some <kbd>show</kbd> functions, as follows:</p>
<pre># Define pretty print functions<br/>Base.show(io::IO, p::Position) = print(io, "(", p.x, ",", p.y, ")")<br/>Base.show(io::IO, s::Size) = print(io, s.width, " x ", s.height)<br/>Base.show(io::IO, w::Widget) = print(io, w.name, " at ", w.position, " size ", w.size)</pre>
<p>These <kbd>Base.show</kbd> functions provide the implementation that is used when <kbd>Position</kbd>, <kbd>Size</kbd>, or <kbd>Widget</kbd> objects need to be shown at the specific I/O device, such as the REPL. By defining these functions, we get a much nicer output. </p>
<p>Note that the <kbd>show</kbd> function for the <kbd>Widget</kbd> type prints the name, position, and size of the widget. The respective <kbd>show</kbd> functions for the <kbd>Position</kbd> and <kbd>Size</kbd> types are going to be called from the <kbd>print</kbd> function. </p>
<div class="packt_tip">The <kbd>show</kbd> function comes with another form, <kbd>show(io, mime, x)</kbd>, so that the value <kbd>x</kbd> can be displayed in different formats for different MIME types. <br/>
<br/>
MIME stands for Multipurpose Internet Mail Extensions. It is also called Media Type. It is a standard that is used to specify the type of a data stream. For example, <kbd>text/plain</kbd> represents a plain text stream and <kbd>text/html</kbd> represents a text stream that has HTML content.<br/>
<br/>
The default MIME type for a <kbd>show</kbd> function is <kbd>text/plain</kbd>, which is essentially the type we use in a Julia REPL environment. If we use Julia in a notebook environment, such as Jupyter, then we can provide a <kbd>show</kbd> function that provides additional formatting in HTML using the MIME type of <kbd>text/html</kbd>.</div>
<p>Finally, let's give it a test drive. We can move around an asteroid game piece by calling various <kbd>move</kbd> functions, as follows:</p>
<pre># let's test these functions<br/>w = Widget("asteroid", Position(0, 0), Size(10, 20))<br/>move_up!(w, 10)<br/>move_down!(w, 10)<br/>move_left!(w, 20)<br/>move_right!(w, 20)<br/><br/># should be back to position (0,0)<br/>print(w) </pre>
<p>The result is as follows. Note that the output of the asteroid widget is formatted exactly as how we coded it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/526794fa-c712-4d76-902e-32da1a2ae163.png" style="width:25.58em;height:16.00em;"/></p>
<p>Defining functions with typed arguments is generally considered a good practice because the function can only work with the specific data types of the arguments. Also, from a client usage perspective, you can clearly see what is required by the function just by looking at the function definition.</p>
<div class="packt_infobox">Sometimes it is more beneficial to define a function with untyped arguments. The standard <kbd>print</kbd> function, for instance, has a function signature that looks like <kbd>print(io::IO, x)</kbd>. The intention is that the <kbd>print</kbd> function is guaranteed to work with all possible data types. <br/>
<br/>
Generally speaking, this should be an exception rather than the norm. In most situations, it makes more sense to use typed arguments.</div>
<p><span>Next, we will discuss how to provide default values for the arguments. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with optional arguments</h1>
                </header>
            
            <article>
                
<p>Sometimes, we do not want to hardcode any values in a function. The general solution is to extract the hardcoded values and work them into function arguments. In Julia, we can also provide default values for the arguments. When we have default values, then the arguments become optional.</p>
<p>To illustrate this concept, let's write a function that makes a bunch of asteroids:</p>
<pre># Make a bunch of asteroids<br/>function make_asteroids(N::Int, pos_range = 0:200, size_range = 10:30)<br/>    pos_rand() = rand(pos_range)<br/>    sz_rand() = rand(size_range)<br/>    return [Widget("Asteroid #$i", <br/>                Position(pos_rand(), pos_rand()), <br/>                Size(sz_rand(), sz_rand())) <br/>        for i in 1:N]<br/>end</pre>
<p>The function takes an argument of <kbd>N</kbd> for the number of asteroids. It also accepts a position range, <kbd>pos_range</kbd>, and <kbd>size_range</kbd>, for creating randomly sized asteroids that are placed randomly on our game map. You may notice that we have also defined two single-line functions, <kbd>pos_rand</kbd> and <kbd>sz_rand</kbd>, directly inside the body of the <kbd>make_asteroid</kbd> function. These functions only exist within the scope of the function.</p>
<p>Let's try this out without specifying any value for <kbd>pos_range</kbd> or <kbd>size_range</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/852f06fe-fa4d-4781-b68f-a37eec559383.png" style="width:22.08em;height:9.25em;"/></p>
<p>But the fact that they are optional also allows us to provide custom values. For instance, we can place the asteroids closer to each other by specifying a much narrower range:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/853a8162-0baa-4421-a20e-7989d36bf73f.png" style="width:24.92em;height:9.50em;"/></p>
<p>Where does the magic come from? If you hit the <em>Tab</em> key while entering the <kbd>make_asteroid</kbd> function from the REPL, you may notice that the single function definition ends up with three methods. </p>
<div class="packt_infobox">What are functions and methods?<br/>
<br/>
Functions are <em>generic</em> in Julia. This means that we can extend the purpose of a function by defining various methods that have the same name, but take different types of argument.<br/>
<br/>
Hence, every function in Julia may be associated to one or more <span>associated</span> methods.</div>
<p>Internally, Julia automatically creates these three methods, one for each signature:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f472c6a9-b180-4283-b218-ecf93c16d941.png" style="width:37.00em;height:8.42em;"/></p>
<p>Another way to find the methods of a function is to just use the <kbd>methods</kbd> function that comes from the Julia <kbd>Base</kbd> package:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f3c45f0d-cb27-4043-aa83-b4c4ae445c62.png" style="width:39.92em;height:6.92em;"/></p>
<p>Of course, we can fully specify all arguments as such:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/845db025-091e-4565-9c9e-62c7c8c39843.png" style="width:32.33em;height:8.58em;"/></p>
<p>As you can see, it is quite convenient to provide default values for positional arguments. In the case that the default values are generally accepted, the calling function becomes simpler because it does not have to specify all arguments.</p>
<p>Something feels a little weird here, though—the code is becoming more difficult to read: <kbd>make_asteroids(5, 100:5:200, 200:10:500)</kbd>. What does <kbd>5</kbd>, <kbd>100:5:200</kbd>, and <kbd>200:10:500</kbd> mean? These arguments look quite opaque, and the programmer may not remember what they mean without looking up the source code or the manual. There has to be a better way! Next, we will check how to solve this problem using keyword arguments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utilizing keyword arguments</h1>
                </header>
            
            <article>
                
<p>A drawback of optional arguments is that they must be in the same order in which they are defined. When there are more arguments, it is not easily readable which values are bound to which arguments from the call site. In that case, we may use keyword arguments to improve readability.</p>
<p>Let's redefine the <kbd>make_asteroid</kbd> function as follows:</p>
<pre>function make_asteroids2(N::Int; pos_range = 0:200, size_range = 10:30)<br/>    pos_rand() = rand(pos_range)<br/>    sz_rand() = rand(size_range)<br/>    return [Widget("Asteroid #$i", <br/>                Position(pos_rand(), pos_rand()), <br/>                Size(sz_rand(), sz_rand())) <br/>        for i in 1:N]<br/>end</pre>
<p>The only difference between this function and the one from the previous section is just a single character. The positional arguments (in this case, <kbd>N</kbd>) and keyword arguments (<kbd>pos_range</kbd> and <kbd>size_range</kbd>) just need to be separated by a <kbd>;</kbd> character. </p>
<p>From the caller's perspective, keyword arguments must be passed with the names of the arguments:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cb4455fc-589c-49d9-bef1-b258566c80e8.png" style="width:33.00em;height:8.83em;"/></p>
<p>Using keyword arguments has made the code a lot more readable! In fact, the keyword arguments do not even need to be passed in the same order as they were defined in the function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0316c188-b6b5-4c38-9ce2-e0d610df0b2e.png" style="width:39.42em;height:8.50em;"/></p>
<p>Another cool feature is that keyword arguments do not have to carry any default values. For example, we could define the same function where the first argument <kbd>N</kbd> becomes a mandatory keyword argument:</p>
<pre>function make_asteroids3(; N::Int, pos_range = 0:200, size_range = 10:30)<br/>    pos_rand() = rand(pos_range)<br/>    sz_rand() = rand(size_range)<br/>    return [Widget("Asteroid #$i", <br/>                Position(pos_rand(), pos_rand()), <br/>                Size(sz_rand(), sz_rand())) <br/>        for i in 1:N]<br/>end</pre>
<p>At this point, we could just call the function with <kbd>N</kbd> specified:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cda73710-d1be-4c26-990f-c2a774e677e8.png" style="width:23.67em;height:7.08em;"/></p>
<p>Using keyword arguments is a good way to write self-documenting code. Some open source packages, such as Plots, make extensive use of keyword arguments. It works very well when a function needs many arguments.</p>
<div class="packt_tip">While we specify default values for keyword arguments in this example, they are not really required. In the case that there is no default value, the keyword argument becomes mandatory when the function is called.</div>
<p>Another cool feature is that we can pass a variable number of arguments to a function. We will look into this next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accepting variable numbers of arguments</h1>
                </header>
            
            <article>
                
<p>Sometimes, it is more convenient if the function can just accept any number of arguments. In this case, we can add three dots <kbd>...</kbd> to a function argument and Julia will automatically roll up all passed arguments into a single variable. This feature is known as <strong>slurping</strong>.</p>
<p>Here is an example:</p>
<pre># Shoot any number of targets<br/>function shoot(from::Widget, targets::Widget...)<br/>    println("Type of targets: ", typeof(targets))<br/>    for target in targets<br/>        println(from.name, " --&gt; ", target.name)<br/>    end<br/>end</pre>
<p>In the <kbd>shoot</kbd> function, we first print the type of the <kbd>targets</kbd> variable and then print every shot that was fired. Let's set up the game pieces first:</p>
<pre>spaceship = Widget("Spaceship", Position(0, 0), Size(30,30))<br/>target1 = asteroids[1]<br/>target2 = asteroids[2]<br/>target3 = asteroids[3]</pre>
<p>Now we can start shooting! Let's first call the <kbd>shoot</kbd> function by passing a single target and then do that again by passing three targets:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/12802734-0bd9-445e-8bdb-274296744e1a.png" style="width:29.92em;height:12.17em;"/></p>
<p>It turns out that the arguments are just combined as a tuple and bound to a single <kbd>targets</kbd><span> variable. In this case, we just iterate the tuple and perform an action on each of them.</span></p>
<p>Slurping is a fantastic way to combine function arguments and handle them all together. This makes it possible to call the function with any number of arguments.</p>
<p>Next, we will learn about a similar feature called splatting, which essentially performs the opposite function of slurping.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Splatting arguments </h1>
                </header>
            
            <article>
                
<p>Slurping is very useful in its own right, but the triple-dot notation actually has a second usage. At the call site, when a variable is followed by three periods, the variable will be automatically assigned as multiple function arguments. This feature is known as <strong>splatting</strong>. In fact, this mechanism is very similar to slurping, except that it is doing the opposite action. We will take a look at an example.</p>
<p>Let's say that we have written a function to arrange a couple of spaceships in a specific formation:</p>
<pre># Special arrangement before attacks<br/>function triangular_formation!(s1::Widget, s2::Widget, s3::Widget)<br/>    x_offset = 30<br/>    y_offset = 50<br/>    s2.position.x = s1.position.x - x_offset<br/>    s3.position.x = s1.position.x + x_offset<br/>    s2.position.y = s3.position.y = s1.position.y - y_offset<br/>    (s1, s2, s3)<br/>end</pre>
<p>We have also constructed a couple of spaceships ahead of a space war:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0ed21f74-7033-4038-b1a6-94b9677020a9.png" style="width:34.92em;height:10.33em;"/></p>
<p>We can now call the <kbd>triangular_formation!</kbd> function using the splatting technique, which involves appending three periods after the function argument:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/53f37537-a8aa-4643-9f84-ff8074117318.png" style="width:26.67em;height:10.00em;"/></p>
<p>In this case, the three elements inside the <kbd>spaceships</kbd> vector are distributed to the three arguments as the <kbd>triangular_formation!</kbd><span> </span>function expects. </p>
<div class="packt_infobox">Splatting can <span>technically work with any collection type—vector and tuple. It should work as long as the variable being splatted supports the general iteration interface. </span></div>
<div class="packt_infobox">In addition, you <span>may wonder what happens when the number of elements in the variable does not equal the number of arguments as defined in the function.</span><br/>
<br/>
You are encouraged to check this behavior out as an exercise.</div>
<p>Splatting is a good way to build up function arguments and then pass them into the function directly without having to split them up into separate arguments. It is therefore quite convenient.</p>
<p>Next, we will discuss how functions can be passed around to provide higher-order programming facilities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding first-class functions</h1>
                </header>
            
            <article>
                
<p>Functions are said to be <strong>first-class</strong> when they can be assigned to variables or struct fields, passed into functions, returned from a function, and so on. They are treated as first-class citizens just like regular data types. We will now take a look at how functions can be passed around like regular data values.</p>
<p>Let's design a new function that can propel a spaceship to leap in a random direction for a random distance. You may recall from the beginning of this chapter that we have already defined four <kbd>move</kbd> functions—<kbd>move_up!</kbd>, <kbd>move_down!</kbd>, <kbd>move_left!</kbd>, and <kbd>move_right!</kbd>. Here's our strategy:</p>
<ol>
<li>Create a <kbd>random_move</kbd> <span>function </span>that returns one of the possible <kbd>move</kbd> functions. This provides the basis for choosing a direction.</li>
<li>Create a <kbd>random_leap!</kbd> <span>function </span>that moves the spaceship using the specified <kbd>move</kbd> function and leap distance.</li>
</ol>
<p>The code is as follows:</p>
<pre>function random_move()<br/>    return rand([move_up!, move_down!, move_left!, move_right!])<br/>end<br/><br/>function random_leap!(w::Widget, move_func::Function, distance::Int)<br/>    move_func(w, distance)<br/>    return w<br/>end</pre>
<p>As you can see, the <kbd>random_move</kbd> function returns a function that is randomly chosen from the array of <kbd>move</kbd> functions. The <kbd>random_leap!</kbd> function accepts a <kbd>move</kbd> function, <kbd>move_func</kbd>, as an argument and then it just makes the call with the widget and distance. Let's test the <kbd>random_leap!</kbd><span> </span>function now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e128f4d3-99e1-4fc4-b016-86db90f6141e.png" style="width:31.83em;height:12.08em;"/></p>
<p>We have successfully called a randomly chosen <kbd>move</kbd> function. All of this can be done easily because we can store functions as if they are regular variables. The first-class nature makes it very convenient.</p>
<p>Next, we will learn about anonymous functions. Anonymous functions are commonly used in Julia programs because they are a quick way to make a function and pass it around to other functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing anonymous functions</h1>
                </header>
            
            <article>
                
<p>Sometimes, we just want to create a simple function and pass it around without assigning it a name. This style of programming is actually fairly common in functional programming languages. We can illustrate its use with an example.</p>
<p class="mce-root">Suppose that we want to explode all of the asteroids. One way to do this is to define an <kbd>explode</kbd> function and pass it into the <kbd>foreach</kbd> function as follows:</p>
<pre class="mce-root">function explode(x)<br/>    println(x, " exploded!")<br/>end<br/><br/>function clean_up_galaxy(asteroids)<br/>    foreach(explode, asteroids)<br/>end</pre>
<p class="mce-root">The results look good:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/abb9cecd-9cb4-4fcc-9436-65ef7aa95761.png" style="width:25.58em;height:8.50em;"/></p>
<p class="mce-root">We can achieve the same effect if we just pass an anonymous function into <kbd>foreach</kbd>:</p>
<pre class="mce-root">function clean_up_galaxy(asteroids)<br/>    foreach(x -&gt; println(x, " exploded!"), asteroids)<br/>end</pre>
<p class="mce-root">The syntax of the anonymous function contains the argument variables, followed by the thin arrow <kbd>-&gt;</kbd> and the function body. In this case, we only have a single argument. If we have more arguments, then we can write them as a tuple that is enclosed in parentheses. An anonymous function can also be assigned to a variable and passed around. Let's say we want to explode the spaceships as well: </p>
<pre class="mce-root">function clean_up_galaxy(asteroids, spaceships)<br/>    ep = x -&gt; println(x, " exploded!")<br/>    foreach(ep, asteroids)<br/>    foreach(ep, spaceships)<br/>end</pre>
<p class="mce-root">We can see that there are some advantages for using anonymous functions:</p>
<ul>
<li class="mce-root">There is no need to come up with a function name and pollute the namespace of the module.</li>
<li class="mce-root">The anonymous function logic is available at the call site, so the code is easier to read.</li>
<li class="mce-root">The code is slightly more compact.</li>
</ul>
<p>By now, we have gone over most of the pertinent details regarding how to define and use functions. The next topic, do-syntax, is closely related to anonymous functions. It is a great way to enhance code readability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using do-syntax</h1>
                </header>
            
            <article>
                
<p class="mce-root">When working with anonymous functions, we may end up having a code block that is in the middle of a function call, making the code more difficult to read. The do-syntax is a great way to address this problem and produce clear, easy-to-read code.</p>
<p class="mce-root">To illustrate the concept, let's build up a new use case for our battle fleet. In particular, we will enhance our spaceships with the ability to launch missiles. We also want to support the requirement that launching a weapon requires that the spaceship is in a healthy state. </p>
<p class="mce-root">We can define a <kbd>fire</kbd> function that takes a <kbd>launch</kbd> function and a spaceship. The <kbd>launch</kbd> function is executed only when the spaceship is healthy. Why do we want to take a function as an argument? Because we want to make it flexible so that, later on, we can use the same <kbd>fire</kbd> function to launch laser beams and other possible weapons:</p>
<pre class="mce-root"># Random healthiness function for testing<br/>healthy(spaceship) = rand(Bool)<br/><br/># make sure that the spaceship is healthy before any operation <br/>function fire(f::Function, spaceship::Widget)<br/>    if healthy(spaceship)<br/>        f(spaceship)<br/>    else<br/>        println("Operation aborted as spaceship is not healthy")<br/>    end<br/>    return nothing<br/>end</pre>
<p class="mce-root">Let's try this out using an anonymous function to fire the missile:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/13905790-cf10-42d0-ab3f-975b2177a9fc.png" style="width:34.17em;height:6.58em;"/></p>
<p class="mce-root">So far so good. But what happens if we need a more complex procedure to fire missiles? For example, say that we would like to move the spaceship up before firing and move it back down afterward:</p>
<pre class="mce-root">fire(s -&gt; begin<br/>        move_up!(s, 100)<br/>        println(s, " launched missile!")<br/>        move_down!(s, 100)<br/>    end, spaceship)</pre>
<p class="mce-root">The syntax now looks quite ugly. Fortunately, we can rewrite the code using the do-syntax and make it more readable:</p>
<pre class="mce-root">fire(spaceship) do s<br/>    move_up!(s, 100)<br/>    println(s, " launched missile!")<br/>    move_down!(s, 100)<br/>end</pre>
<p>How does it work? Well, the syntax is translated so that the do-block is turned into an anonymous function and it is then just inserted as the first argument of the function.</p>
<p>An interesting usage of the do-syntax can be found in Julia's <kbd>open</kbd> function. Because reading a file involves opening and closing a file handler, the <kbd>open</kbd> function is designed to accept an anonymous function that takes an <kbd>IOStream</kbd> and do something with it, while the opening/closing housekeeping tasks are handled by the <kbd>open</kbd> function itself. </p>
<p>The idea is quite simple, so let's just replicate it here with our own <kbd>process_file</kbd> function:</p>
<pre>function process_file(func::Function, filename::AbstractString)<br/>    ios = nothing<br/>    try<br/>        ios = open(filename)<br/>        func(ios)<br/>    finally<br/>        close(ios)<br/>    end<br/>end</pre>
<p>Using the do-syntax, we can focus on developing the logic of file processing without having to worry about the housekeeping chores, such as opening and closing files. Consider the following code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9655030d-b3a1-4997-85cd-c4dda6d5d999.png" style="width:25.83em;height:5.83em;"/></p>
<p>As you can see, the do-syntax can be useful in two ways:</p>
<ul>
<li>It makes the code more readable by rearranging the anonymous function argument in a block format.</li>
<li>It allows the anonymous functions to be wrapped in a context for which additional logic can be executed before or after the function.</li>
</ul>
<p>Next, we will take a look at multiple dispatch, which is a unique feature that is not commonly found in object-oriented languages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Multiple Dispatch</h1>
                </header>
            
            <article>
                
<p>Multiple dispatch is one of the most unique features in the Julia programming language. They are used extensively in the Julia Base library, <kbd>stdlib</kbd>, as well as many open source packages. In this section, we will explore how multiple dispatch work and how one can utilize them effectively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is a dispatch?</h1>
                </header>
            
            <article>
                
<p>A dispatch is the process by which a function is selected for execution. You may wonder why there is any controversy in selecting which function to execute. When we develop a function, we give it a name, some arguments, and a block of code that it should execute. If we come up with unique names for all functions in a system, then there will be no ambiguity. However, there are often times when we want to reuse the same function name and apply it to different data types for similar types of operation.</p>
<p>Examples are abundant in Julia's Base library. For example, the <kbd>isascii</kbd> function has three methods, and each one takes a different argument type:</p>
<pre>isascii(c::Char) <br/>isascii(s::AbstractString) <br/>isascii(c::AbstractChar) </pre>
<p><span>Depending on the type of the argument, the proper method is dispatched and executed. </span>When we call the <kbd>isascii</kbd> function with a <kbd>Char</kbd> object, the first method is dispatched. Likewise, when we call it with a <kbd>String</kbd> object, which is a subtype of <kbd>AbstractString</kbd>, then the second method is dispatched. Sometimes, the type of the argument being passed to the method is not known until runtime, and in that case, the proper method is dispatched right at that moment, depending on the specific value being passed. This behavior is called <strong>dynamic dispatch</strong>.</p>
<p>Dispatch is a key concept that will come up over and over again. It is important that we understand the rules as related to how a function being dispatched. We will go over these next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Matching to the narrowest types</h1>
                </header>
            
            <article>
                
<p>As discussed in <a href="48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml">Chapter 2</a>, <em>Modules, Packages, and Data Type Concepts</em>, we can define functions that take abstract types as arguments. When it comes to dispatch, Julia will find the method that matches the narrowest type in the arguments.</p>
<p>To illustrate this concept, let's return to our favorite example in this chapter regarding spaceships and asteroids! In fact, we will improve our data types as follows:</p>
<pre># A thing is anything that exist in the universe.<br/># Concrete type of Thing should always have the following fields:<br/>#     1. position<br/>#     2. size<br/>abstract type Thing end<br/><br/># Functions that are applied for all Thing's<br/>position(t::Thing) = t.position<br/>size(t::Thing) = t.size<br/>shape(t::Thing) = :unknown</pre>
<p>Here, we have defined an abstract type, <kbd>Thing</kbd>, which can be anything that exists in the universe. When we design this type, we expect its concrete subtypes will have the standard <kbd>position</kbd> and <kbd>size</kbd> fields. Therefore, we just happily define <kbd>position</kbd> and <kbd>size</kbd> functions for <kbd>Thing</kbd>. By default, we do not want to assume any shape of anything, so the <kbd>shape</kbd> function for <kbd>Thing</kbd> only returns an <kbd>:unknown</kbd> symbol. </p>
<p>To make things more interesting, we will equip our spaceships with two types of weapon—laser and missiles. In Julia, we can conveniently define them as <strong>enums</strong>:</p>
<pre># Type of weapons<br/>@enum Weapon Laser Missile</pre>
<p>Here, the <kbd>@enum</kbd> macro defines a new type called <kbd>Weapon</kbd>. The only values of the <kbd>Weapon</kbd> type are <kbd>Laser</kbd> and <kbd>Missile</kbd>. Enums are a good way to define typed constants. Internally, they define numeric values for each constant, and so it should be quite performant.</p>
<p>Now, we can define the <kbd>Spaceship</kbd> and <kbd>Asteroid</kbd> concrete types as follows:</p>
<pre># Spaceship <br/>struct Spaceship &lt;: Thing<br/>    position::Position<br/>    size::Size<br/>    weapon::Weapon<br/>end<br/>shape(s::Spaceship) = :saucer<br/><br/># Asteroid <br/>struct Asteroid &lt;: Thing<br/>    position::Position<br/>    size::Size<br/>end</pre>
<p>Note that both <kbd>Spaceship</kbd> and <kbd>Asteroid</kbd> include <kbd>position</kbd> and <kbd>size</kbd> fields as part of our design contract. In addition, we have a <kbd>weapon</kbd> field added for the <kbd>Spaceship</kbd> type. Because we have designed our state-of-the-art spaceships like saucers, we have defined the <kbd>shape</kbd> function for the <kbd>Spaceship</kbd> type <span>as well</span><span>. Let's test it out:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c159226a-fae3-44ff-95a0-2f13543b2903.png" style="width:34.17em;height:17.08em;"/></p>
<p>We have now created two spaceships and two asteroids. Let's turn our focus to the results of the preceding <kbd>shape</kbd> function calls for a moment. When it was called with a spaceship object <kbd>s1</kbd>, it was dispatched to <kbd>shape(s::Spaceship)</kbd> and returned <kbd>:saucer</kbd>. When it was called with an asteroid object, it was dispatched to <kbd>shape(t::Thing)</kbd> because there are no other matches for the <kbd>Asteroid</kbd> object.</p>
<p>To recap, Julia's dispatch mechanism always looks for the function with the narrowest type in the arguments. Judging between <kbd>shape(s::Spaceship)</kbd> and <kbd>shape(t:Thing)</kbd>, it will choose to execute <kbd>shape(s::Spaceship)</kbd> for a <kbd>Spaceship</kbd> argument.</p>
<p>Are you familiar with <span>multiple dispatch?</span> If not, don't worry. In the next section, we will dive deep into how multiple dispatch works in Julia.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dispatching with multiple arguments</h1>
                </header>
            
            <article>
                
<p>So far, we have only seen dispatch examples for methods that take a single argument. We can extend the same concept for multiple arguments, and that's simply called multiple dispatch. </p>
<p>So how does it work when multiple arguments are involved? Let's say we continue developing our space war game with the ability to detect collisions between different objects. To look at this in detail, we'll go through a sample implementation.</p>
<p>First, define functions that can check whether two rectangles overlap each other:</p>
<pre>struct Rectangle<br/>    top::Int<br/>    left::Int<br/>    bottom::Int<br/>    right::Int<br/>    # return two upper-left and lower-right points of the rectangle<br/>    Rectangle(p::Position, s::Size) = <br/>        new(p.y+s.height, p.x, p.y, p.x+s.width)<br/>end<br/><br/># check if the two rectangles (A &amp; B) overlap<br/>function overlap(A::Rectangle, B::Rectangle)<br/>    return A.left &lt; B.right &amp;&amp; A.right &gt; B.left &amp;&amp;<br/>        A.top &gt; B.bottom &amp;&amp; A.bottom &lt; B.top<br/>end</pre>
<p>Then, we can define a function that returns <kbd>true</kbd> when two <kbd>Thing</kbd> objects collide. This function can be called for any combination of <kbd>Spaceship</kbd> and <kbd>Asteroid</kbd> objects:</p>
<pre>function collide(A::Thing, B::Thing)<br/>    println("Checking collision of thing vs. thing")<br/>    rectA = Rectangle(position(A), size(A))<br/>    rectB = Rectangle(position(B), size(B))<br/>    return overlap(rectA, rectB)<br/>end</pre>
<p>Of course, this is a <span>really </span>naive idea because we know that spaceships and asteroids have different shapes, possibly nonrectangular ones. Nonetheless, this is not a bad default implementation.</p>
<p>Let's run a quick test before we go further. Note that I have intentionally suppressed the output of the return values only because they're unimportant for our discussion here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e60f1e68-d13c-4a81-ae58-ff7e4e3e9f6a.png" style="width:19.83em;height:13.08em;"/></p>
<p>Knowing that the collision-detection logic may be different depending on the type of objects, we can further define these methods:</p>
<pre>function collide(A::Spaceship, B::Spaceship)<br/>    println("Checking collision of spaceship vs. spaceship")<br/>    return true   # just a test<br/>end </pre>
<p>With this new method, based upon the narrowest-type selection process, we can safely handle spaceship-spaceship collision detection. Let's prove my claim with the same test as the preceding code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5489630e-75fb-4f86-b167-bd27cc636009.png" style="width:23.33em;height:12.67em;"/></p>
<p>It looks good. If we just continue defining the rest of the functions, then everything will be covered and perfect!</p>
<p>Multiple dispatch is indeed a simple concept. Essentially, all function arguments are considered when Julia tries to determine which function needs to be dispatched. The same rule applies—the narrowest type always wins!</p>
<p>Unfortunately, sometimes it is unclear which function needs to be dispatched. Next, we will look into how this can happen and how the problem can be resolved.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Possible ambiguities during dispatch </h1>
                </header>
            
            <article>
                
<p>Of course, we can always define all possible methods with concrete type arguments; however, that may not be the most desirable option when designing software. Why? It's because the number of combinations in argument types could be overwhelming, and it is often unnecessary to enumerate them all. In our game example here, we only need to detect collisions between two types—<kbd>spaceship</kbd> and <kbd>asteroid</kbd>. So we just need to define 2 x 2 = 4 methods; however, imagine what we would do when we have 10 types of object. We would then have to define 100 methods!</p>
<p>The idea of abstract types can save us. Let's just imagine that we do have to support 10 concrete data types. If the other eight data types have similar shapes, then we could cut down the number of methods tremendously by accepting an abstract type as one of the arguments. How? Let's take a look:</p>
<pre>function collide(A::Asteroid, B::Thing)<br/>    println("Checking collision of asteroid vs. thing")<br/>    return true<br/>end<br/><br/>function collide(A::Thing, B::Asteroid)<br/>    println("Checking collision of thing vs. asteroid")<br/>    return false<br/>end</pre>
<p><span>These two functions provide the default implementation for detecting collisions between an <kbd>Asteroid</kbd> and any <kbd>Thing</kbd>. The first method can handle the first argument being <kbd>Asteroid</kbd> and the second argument being any subtype of <kbd>Thing</kbd>. If we were to have 10 concrete types in total, this single method can handle 10 scenarios. Likewise, the second method can handle the other 10 scenarios. Let's just have a quick check:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5fe541ee-d03c-43f6-83ae-a04bb4c6e881.png" style="width:24.50em;height:7.17em;"/></p>
<p><span>Great! these two calls are working fine. Let's finish our test:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/46487813-1879-4ca5-9127-92a6ce27e2dd.png" style="width:39.25em;height:8.58em;"/></p>
<p><span>But wait, what happened when we tried to check the collision between two asteroids? Well, the Julia runtime has detected an ambiguity here. When we pass two <kbd>Asteroid</kbd> arguments, it is unclear whether we want to execute </span><kbd>collide(A::Thing, B::Asteroid)</kbd> or <kbd>collide(A::Asteroid, B::Thing)</kbd>. Both methods seem to be able to take the task, but neither of their signatures is narrower than the other, and so it just gave up and throws an error. </p>
<p>Fortunately, it actually suggested a fix as part of the error message. A possible fix is to define a new method, <kbd>collide(::Asteroid, ::Asteroid)</kbd>, as follows:</p>
<pre>function collide(A::Asteroid, B::Asteroid)<br/>    println("Checking collision of asteroid vs. asteroid")<br/>    return true # just a test<br/>end</pre>
<p><span>Because it has the narrowest signature, Julia can properly dispatch to this new method when two asteroids are passed to the </span><kbd>collide</kbd><span> function. Once this method is defined, there will be no more ambiguity. Let's try again. The result is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dafd456f-9b4c-43c6-b322-4b15f6452855.png" style="width:27.00em;height:4.25em;"/></p>
<p>As you can see, when you encounter ambiguity for multiple dispatch, it can be resolved easily by creating a function with more specific types in its arguments. The Julia runtime will not try to guess what you want to do. As a developer, we need to provide clear instructions to the computer.</p>
<p>However, ambiguities may not be obvious from just looking at the code. In order to reduce the risk of hitting the problem at runtime, we can proactively detect which part of the code may introduce such ambiguities. Fortunately, Julia already provides a convenient tool to identify ambiguities. We will take a look at that in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Detecting ambiguities</h1>
                </header>
            
            <article>
                
<p>It is often difficult to find ambiguous methods until you happen to hit a specific use case at runtime. That's not good. I don't know about you, but software engineers like me don't like surprises in production!</p>
<p>Fortunately, Julia provides a function in the <kbd>Test</kbd> package for detecting ambiguities. We can try this out using a similar test. Consider the following code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1c0cd4f8-e830-4c24-8350-fa401dd8f6d5.png" style="width:20.83em;height:11.25em;"/></p>
<p>We have created a small module in the REPL that defines three <kbd>foo</kbd> methods. It's a classic example of ambiguous methods—if we pass two integer arguments, then it is unclear whether the second or the third <kbd>foo</kbd> method should be executed. Now, let's use the <span class="pl-c1"><kbd>detect_ambiguities</kbd> function and see if it can detect the problem:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6738a537-9dc2-4bec-b9d1-f74c687318b3.png" style="width:40.25em;height:5.92em;"/></p>
<p>The result is telling us that the <kbd><span class="pl-c1">foo</span>(x<span class="pl-k">::</span><span class="pl-c1">Integer</span>, y)</kbd> and <kbd><span class="pl-c1">foo</span>(x, y<span class="pl-k">::</span><span class="pl-c1">Integer</span>)</kbd> functions are ambiguous. As we've already learned how to fix that problem, we can do that and test again:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7b4ed642-482e-4f3d-9783-be086d149712.png" style="width:25.33em;height:14.58em;"/></p>
<p>In fact, the <kbd>detect_ambiguities</kbd> function is even more useful when you have functions that extend functions from other modules. In this case, you can just call the <span><kbd>detect_ambiguities</kbd> function with the modules that you want to check all together. Here's how it works when you pass two modules:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8e7a4bb3-71fd-4a78-a7dc-2b542ce705cc.png" style="width:29.58em;height:20.58em;"/></p>
<p>In this hypothetical example, the <kbd>Foo4</kbd> module imports the <kbd>Foo2.foo</kbd> function and extends it by adding a new method. The <kbd>Foo2</kbd> module by itself would be ambiguous, but combining both modules resolves the ambiguity.</p>
<p>So when should we make use of this great detective function? A good way to do this is to add the <kbd><span>detect_ambiguities</span></kbd> test in the module's automated test suite so that it is executed in the continuous integration pipeline for every build.</p>
<p>Now that we know how to use this ambiguity detection tool, we can use multiple dispatch without fear! In the next section, we will go over another aspect of dispatch called dynamic dispatch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding dynamic dispatch</h1>
                </header>
            
            <article>
                
<p>Julia's dispatch mechanism is unique not only because of its multiple dispatch features, but also the way that it treats function arguments dynamically when deciding where to dispatch.</p>
<p> Let's say we want to randomly pick two objects and check whether they collide. We can define the function as follows:</p>
<pre># randomly pick two things and check<br/>function check_randomly(things)<br/>    for i in 1:5<br/>        two = rand(things, 2)<br/>        collide(two...)<br/>    end<br/>end</pre>
<p>Let's run it and see what happens:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/96f136c4-abed-4f9f-b3ce-9ea8baad0c17.png" style="width:29.83em;height:8.92em;"/></p>
<p>We can see that different <kbd>collide</kbd> methods are called depending on the types of the arguments that are passed in the <kbd>two</kbd> variable.</p>
<div class="packt_infobox">This kind of dynamic behavior can be found as polymorphism in object-oriented programming languages. The main difference is that Julia supports multiple dispatch, utilizing all arguments for dispatch at runtime. By contrast, in Java, only the object being invoked is used for dynamic dispatch. Once the proper class is identified for dispatch, the method arguments are then used for static dispatch when there are several overloaded methods with the same name. </div>
<p>Multiple dispatch is a powerful feature. When combined with custom data types, it allows the developer to control which methods are called for different scenarios. If you are more interested in multiple dispatch, you can watch a video on YouTube with the title <em>The Unreasonable Effectiveness of Multiple Dispatch</em>. It is a presentation by Stefan Karpinski, recorded at the JuliaCon 2019 conference.</p>
<p>Next, we will look into how function arguments can be parameterized for additional flexibility and expressiveness.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Leveraging parametric methods</h1>
                </header>
            
            <article>
                
<p>Julia's type system and multiple dispatch feature provide a powerful foundation for writing extendable code. As it turns out, we can also use parametric types in function arguments. We can call these parametric methods. Parametric methods provide an interesting way to express what data types may be matched during dispatch.</p>
<p>In the following sections, we will go over how to utilize parametric methods in our game.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using type parameters</h1>
                </header>
            
            <article>
                
<p>When defining functions, we have an option to annotate each argument with type information. The type of an argument can be a regular abstract type, concrete type, or a parametric type. Let's consider this sample function for exploding an array of game pieces:</p>
<pre># explode an array of objects<br/>function explode(things::AbstractVector{Any})<br/>    for t in things<br/>        println("Exploding ", t)<br/>    end<br/>end</pre>
<p><span>The <kbd>things</kbd> argument is annotated with </span><kbd>AbstractVector{Any}</kbd><span>, which means that it can be any <kbd>AbstractVector</kbd> type that contains any object that is a subtype of <kbd>Any</kbd> (which is really just everything). </span>To make the method parametric, we can just rewrite it with a <kbd>T</kbd> <span>type parameter </span><span>as follows:</span></p>
<pre># explode an array of objects (parametric version)<br/>function explode(things::AbstractVector{T}) where {T}<br/>    for t in things<br/>        println("Exploding ", t)<br/>    end<br/>end</pre>
<p>Here, the <kbd>explode</kbd> function can accept any <kbd>AbstractVector</kbd> with the parameter <kbd>T</kbd>, which can be any subtype of <kbd>Any</kbd>. So, if we just pass a vector of <kbd>Asteroid</kbd> objects—that is, <kbd>Vector{Asteroid}</kbd>—it should just work. It also works if we pass a vector of symbols—that is, <kbd>Vector{Symbol}</kbd>. Let's give it a try:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/31715df8-97e0-4c6b-9c15-6248ae3558bd.png" style="width:19.33em;height:9.25em;"/></p>
<p>Note that <span class="s2"><kbd>Vector{Asteroid}</kbd> is actually a subtype of <kbd>AbstractVector{Asteroid}</kbd>. In general, we can say that <kbd>SomeType{T}</kbd> is a subtype of <kbd>SomeOtherType{T}</kbd> whenever <kbd>SomeType</kbd> is a subtype of <kbd>SomeOtherType</kbd>. But, if we are unsure, it is easy to check:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/330c1cfc-9dd3-4c90-bfb9-643f02bc930f.png" style="width:29.33em;height:3.75em;"/></p>
<p>Perhaps we don't really want the <kbd>explode</kbd> function to take a vector of anything. Since this function is written for our space war game, we could restrict the function to accept a vector of any type that is a subtype of <kbd>Thing</kbd>. It can be easily achieved as follows:</p>
<pre># Same function with a more narrow type<br/>function explode(things::AbstractVector{T}) where {T &lt;: Thing}<br/>    for t in things<br/>        println("Exploding thing =&gt; ", t)<br/>    end<br/>end</pre>
<p>The <kbd>where</kbd> notation is used to further qualify the parameter with superclass information. Whenever a type parameter is used in the function signature, we must accompany it with a <kbd>where</kbd> clause for the same parameter(s).</p>
<p>Type parameters in function arguments allow us to specify a class of data types that fit within the constraint indicated inside the <kbd>where</kbd> clause. The preceding <kbd>explode</kbd> function can take a vector containing any subtype of <kbd>Thing</kbd>. This means that the function is generic in the sense that it can be dispatched with an unlimited number of types, as long as it satisfies the constraint.</p>
<p>Next, we will explore the use of abstract types as an alternative way to specify function arguments. At first glance, it looks fairly similar to using parametric types; however, there is a slight difference, which we will explain in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Replacing abstract types with type parameters</h1>
                </header>
            
            <article>
                
<p>In general, we can replace any abstract type with a type parameter in the function signature. When we do this, we will end up with a parametric method that has the same semantics as the original one.</p>
<p>This is not an unimportant observation. Let's see if we can demonstrate this behavior with an example.</p>
<p>Suppose that we are building a <kbd>tow</kbd> function so that a spaceship can tow away something in the universe, as follows:</p>
<pre># specifying abstract/concrete types in method signature<br/>function tow(A::Spaceship, B::Thing)<br/>    "tow 1"<br/>end</pre>
<p>The <kbd>tow</kbd> function is currently defined with a concrete <kbd>Spaceship</kbd> <span>type</span><span> </span><span>and an abstract</span> <kbd>Thing</kbd><span> </span><span>type</span><span> </span><span>argument. If we want to see the methods defined for this function, we can use the</span> <kbd>methods</kbd><span> function to display what is stored in Julia's method table:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d3a19533-a7ea-466b-be6e-ebd45dae2e4d.png" style="width:28.83em;height:4.42em;"/></p>
<p>The same method signature comes back perfectly, as expected.</p>
<p>Now, let's define a parametric method where we use a type parameter for the argument <kbd>B</kbd>:</p>
<pre># equivalent of parametric type <br/>function tow(A::Spaceship, B::T) where {T &lt;: Thing}<br/>    "tow 2"<br/>end</pre>
<p>We have now defined a new method with a different signature syntax. But is it really a different method? Let's check:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5a55466c-c637-48ef-972e-045238fa7504.png" style="width:41.33em;height:5.17em;"/></p>
<p>We can see that the methods list still only has one entry, which means that the new method definition has replaced the original one. It should not be too surprising, however. The new method signature, while looking different from the one before, does have the same meaning as the original one. Ultimately, the second argument <kbd>B</kbd> still accepts any type that is a subtype of <kbd>Thing</kbd>.</p>
<p>So, why do we even go through all the trouble to do this? Well, there is no reason to turn this method into a parametric one in this case. But go through the next section, and you will see why doing this can be useful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enforcing type consistency in using parameters </h1>
                </header>
            
            <article>
                
<p>One of the most useful features with type parameters is that they can be used to enforce type consistency.</p>
<p>Let's say we want to create a new function that groups two <kbd>Thing</kbd> objects together. As we don't really care about what concrete types are passed, we can just write a single function that does the work:</p>
<pre>function group_anything(A::Thing, B::Thing)<br/>    println("Grouped ", A, " and ", B)<br/>end</pre>
<p>We can also run some trivial tests quickly to ensure that all four combinations of spaceships and asteroids are working:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7e19fa57-a73c-4b21-a95e-57a20b65941d.png" style="width:36.75em;height:13.50em;"/></p>
<div class="packt_infobox">You may wonder how we get such a nice output <span>regarding</span> the specific weapons. As we have learned previously, we can extend the <kbd>show</kbd> function from the Base package with our types. You can find our implementation of the <kbd>show</kbd> function in the book's GitHub repository.</div>
<p>Now, all is good, but then we realize that the requirement is slightly different from what we thought originally. Rather than grouping any kind of object, the function should be able to group the same kinds of objects only—that is, it's okay to group spaceship with spaceship and asteroid with asteroid, but not spaceship with asteroid. So what can we do here? An easy solution is to just throw a type parameter in the method signature:</p>
<pre>function group_same_things(A::T, B::T) where {T &lt;: Thing}<br/>    println("Grouped ", A, " and ", B)<br/>end</pre>
<p>In this function, we have annotated both arguments with type <kbd>T</kbd>, and we specify that <kbd>T</kbd> must be a subtype of <kbd>Thing</kbd>. Because both arguments use the same type, we are now instructing the system to dispatch to this method only if both arguments have the same type. We can now try the same four test cases as before, as shown in the following code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5ebaf0c2-8b13-4e9d-9d10-11eba14776d4.png" style="width:40.42em;height:26.67em;"/></p>
<p>Effectively, we can now ensure that the method is only dispatched when the arguments have the same type. This is one of the few reasons why it is a good idea to use type parameters for function arguments.</p>
<p>Next, we will talk about another reason to use type parameters—extracting type information from the method signature.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extracting type information from the method signature</h1>
                </header>
            
            <article>
                
<p>Sometimes, we want to find out the parameter type within the method body. This is actually very easy to do. <span>As it turns out, all parameters are also bound as a variable that we can access in the method body itself. The implementation of the standard <kbd>eltype</kbd> function provides a good example for such usage:</span></p>
<pre>eltype(things::AbstractVector{T}) where {T &lt;: Thing} = T</pre>
<p>We can see that the type parameter <kbd>T</kbd> is referenced in the body. Let's how it works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/48f85bfb-e129-4e0a-aff4-d6dbbc4fcf87.png" style="width:17.33em;height:10.17em;"/></p>
<p>In the first call, because all objects in the array have the <kbd>Spaceship</kbd> type, the <kbd>Spaceship</kbd> type is returned, and likewise for the second call, where <kbd>Asteroid</kbd> is returned. The third call returns <kbd>Thing</kbd> because we have a mixed number of <kbd>Spaceship</kbd> and <kbd>Asteroid</kbd> objects. These types can be further examined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e86caba5-4a62-4734-a4d0-98ecfdadda9f.png" style="width:16.17em;height:9.25em;"/></p>
<p>In summary, we can build more flexible functions by using type parameters in function definitions. From an expressiveness perspective, each type parameter can cover a whole class of data types. We can also use the same type parameter in multiple arguments to enforce type consistency. Finally, we can easily extract type information directly from the method signature. </p>
<p>Now, let's move on and discuss the last topic of this chapter – interfaces.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with interfaces</h1>
                </header>
            
            <article>
                
<p>In this section, we will explore how to design and work with interfaces in Julia. Unlike other mainstream programming languages, Julia does not have a formal way to define interfaces. This informality may make some people <span>a little uneasy</span><span>. Nonetheless, interfaces do exist and are used extensively in many Julia programs. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing and developing interfaces</h1>
                </header>
            
            <article>
                
<p>Interfaces are behavioral contracts. A behavior is defined by a set of functions that operates on one or more specific objects). In Julia, the contract is purely conventional and is not formally specified. To illustrate this concept, let's create a module that contains the logic of taking an object anywhere from the galaxy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the Vehicle interface</h1>
                </header>
            
            <article>
                
<p>We shall first create a module called <kbd>Vehicle</kbd>. The purpose of this module is to implement our space-travel logic. As we want to keep this module generic, we will design an interface that any object can implement in order to participate in our space-travel program.</p>
<p>The structure of the module consists of four sections, as indicated by the following embedded comments:</p>
<pre>module Vehicle<br/># 1. Export/Imports<br/># 2. Interface documentation<br/># 3. Generic definitions for the interface<br/># 4. Game logic <br/>end # module</pre>
<p>Let's see how the code is actually written in the module:</p>
<ol>
<li>The first section exports a single function called <kbd>go!</kbd>:</li>
</ol>
<pre style="padding-left: 60px"># 1. Export/Imports<br/>export go!</pre>
<ol start="2">
<li>The second code segment is merely documentation:</li>
</ol>
<pre style="padding-left: 60px"># 2. Interface documentation<br/># A vehicle (v) must implement the following functions:<br/>#<br/># power_on!(v) - turn on the vehicle's engine<br/># power_off!(v) - turn off the vehicle's engine<br/># turn!(v, direction) - steer the vehicle to the specified direction <br/># move!(v, distance) - move the vehicle by the specified distance<br/># position(v) - returns the (x,y) position of the vehicle</pre>
<ol start="3">
<li>The third code segment contains generic definitions of the functions:</li>
</ol>
<pre style="padding-left: 60px"># 3. Generic definitions for the interface<br/>function power_on! end<br/>function power_off! end<br/>function turn! end<br/>function move! end<br/>function position end</pre>
<ol start="4">
<li>Finally, the last code segment contains the space-travel logic:</li>
</ol>
<pre style="padding-left: 60px"># 4. Game logic <br/><br/># Returns a travel plan from current position to destination<br/>function travel_path(position, destination)<br/>    return round(π/6, digits=2), 1000 # just a test<br/>end<br/><br/># Space travel logic<br/>function go!(vehicle, destination) <br/>    power_on!(vehicle)<br/>    direction, distance = travel_path(position(vehicle), destination)<br/>    turn!(vehicle, direction)<br/>    move!(vehicle, distance)<br/>    power_off!(vehicle)<br/>    nothing<br/>end</pre>
<p>The <kbd>travel_path</kbd> function calculates the direction and distance to travel from the current position to the final destination. It is expected to return a tuple. For testing purposes, we are just returning hardcoded values.</p>
<p><span>The <kbd>go!</kbd> function expects that the vehicle object being passed in the first argument is some kind of space vehicle. Furthermore, the logic also expects the vehicle to exhibit certain behavior, such as being able to turn on the engine, steer in the right direction, move a certain distance, and so on. </span></p>
<p>If a client program wants to call the<span> </span><kbd>go!</kbd><span> </span>function, it must pass a type that implements the expected interface as assumed by this logic. But how does one know what functions to implement? Well, it is defined as part of the documentation as spelled out in the comment from the<span> </span><em>Interface Documentation</em><span> </span>code segment:</p>
<pre># A vehicle must implement the following functions:<br/><br/># power_on!(v) - turn on the vehicle's engine<br/># power_off!(v) - turn off the vehicle's engine<br/># turn!(v, direction) - steer the vehicle to the specified direction <br/># move!(v, distance) - move the vehicle by the specified distance<br/># position(v) - returns the (x,y) position of the vehicle</pre>
<p>Another clue is that the required functions are defined in the previous code as empty generic functions—that is, functions without any signature or body:</p>
<pre>function power_on! end<br/>function power_off! end<br/>function turn! end<br/>function move! end<br/>function position end</pre>
<p>So far, we have written the interface's contractual requirements as comments in the code. It is generally better to do this as Julia doc strings so that the requirements can be generated and published to an online website or printed as hard copy. We could do something like this for every function specified in the interface:</p>
<pre>"""<br/>Power on the vehicle so it is ready to go.<br/>"""<br/>function power_on! end</pre>
<p>The <kbd>Vehicle</kbd> module is now completed, and as part of the source code, we have set certain expectations. If any object wants to participate in our space-travel program, it must implement the five functions—<kbd>power_on!</kbd>, <kbd>power_off!</kbd>, <kbd>turn!</kbd>, <kbd>move!</kbd>, and <kbd>position</kbd>.</p>
<p>Next, we will design a new fighter jet line for the space-travel program!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing FighterJet </h1>
                </header>
            
            <article>
                
<p>Now that we understand what to expect from the <kbd>Vehicle</kbd> interface, we can develop something that actually implements the interface. We will create a new <kbd>FighterJets</kbd> module and define the <kbd>FighterJet</kbd> data type as follows:</p>
<pre>"FighterJet is a very fast vehicle with powerful weapons."<br/>mutable struct FighterJet<br/><br/>    "power status: true = on, false = off"<br/>    power::Bool <br/><br/>    "current direction in radians"<br/>    direction::Float64<br/><br/>    "current position coordinate (x,y)"<br/>    position::Tuple{Float64, Float64} <br/><br/>end</pre>
<p>To conform to the <kbd>Vehicle</kbd> interface defined previously, we must first import the generic functions from the <kbd>Vehicle</kbd> module and then implement the logic for operating the <kbd>FighterJet</kbd> vehicle. Here is the code for the <kbd>power_on</kbd> and <kbd>power_off</kbd> functions:</p>
<pre># Import generic functions<br/>import Vehicle: power_on!, power_off!, turn!, move!, position<br/><br/># Implementation of Vehicle interface<br/>function power_on!(fj::FighterJet)<br/>    fj.power = true<br/>    println("Powered on: ", fj)<br/>    nothing<br/>end<br/><br/>function power_off!(fj::FighterJet)<br/>    fj.power = false<br/>    println("Powered off: ", fj)<br/>    nothing<br/>end</pre>
<p>Of course, a real fighter jet may be a bit more involved than just setting a Boolean field to either <kbd>true</kbd> or <kbd>false</kbd>. For testing purposes, we also print something to the console so that we know what is happening. Let's also define the function to steer the direction:</p>
<pre>function turn!(fj::FighterJet, direction)<br/>    fj.direction = direction<br/>    println("Changed direction to ", direction, ": ", fj)<br/>    nothing<br/>end</pre>
<p>Again, the logic for the <kbd>turn!</kbd> function here is as simple as changing the direction field and printing some text on the console. The <kbd>move!</kbd> function is a little more interesting:</p>
<pre>function move!(fj::FighterJet, distance) <br/>    x, y = fj.position<br/>    dx = round(distance * cos(fj.direction), digits = 2)<br/>    dy = round(distance * sin(fj.direction), digits = 2)<br/>    fj.position = (x + dx, y + dy)<br/>    println("Moved (", dx, ",", dy, "): ", fj)<br/>    nothing<br/>end</pre>
<p>Here, we have used the trigonometric functions <kbd>sin</kbd> and <kbd>cos</kbd> to calculate the new position that the fighter jet will be traveling to. Finally, we must implement the <kbd>position</kbd> function, which returns the current position of the fighter jet:</p>
<pre>function position(fj::FighterJet)<br/>    fj.position<br/>end</pre>
<p>Now that the <kbd>FighterJet</kbd> type fully implements the interface, we can utilize the game logic as expected. Let's give it a spin by creating a new <kbd>FighterJet</kbd> object and invoke the <kbd>go!</kbd> function as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/887ebe5d-a4d8-4b13-8cd7-104eb4c2f2d6.png" style="width:32.42em;height:12.08em;"/></p>
<p>In a nutshell, implementing an interface is a fairly simple task. The key is to understand what functions are required to implement an interface and make sure that the custom data type can support those functions. As a professional developer, we should clearly document the interface functions so that there is no confusion about what needs to be implemented.</p>
<p>At this point, we can consider the interface that we just designed as <strong>hard contracts</strong>. They are hard in the sense that all of the functions specified in our interface must be implemented by any object participating in our space-travel program. In the next section, we will go over <strong>soft contracts</strong>, which correspond to interface functions that may be optional.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling soft contracts</h1>
                </header>
            
            <article>
                
<p>Sometimes, certain interface contracts are not absolutely required when a default behavior can be assumed by the interface. The functions that are not mandatory may be referred to as soft contracts.</p>
<p>Let's say we want to add a new function for landing a vehicle. Most vehicles have wheels, but some don't, especially high-tech ones! So, as part of the landing procedure, we must engage the wheels only when necessary.</p>
<p>How do we design a soft contract for an interface? In this case, we can assume that most future vehicles have no wheels and therefore the default behavior does not require engaging the wheels. Here, in the <kbd>Vehicle</kbd> module, we can add the <kbd>engage_wheel!</kbd> function to document and provide a default implementation, as follows:</p>
<pre># 2. Interface documentation<br/># A vehicle (v) must implement the following functions:<br/>#<br/># power_on!(v) - turn on the vehicle's engine<br/># power_off!(v) - turn off the vehicle's engine<br/># turn!(v, direction) - steer the vehicle to the specified direction <br/># move!(v, distance) - move the vehicle by the specified distance<br/># position(v) - returns the (x,y) position of the vehicle<br/># engage_wheels!(v) - engage wheels for landing. Optional.<br/><br/># 3. Generic definitions for the interface<br/># hard contracts<br/># ...<br/># soft contracts<br/>engage_wheels!(args...) = nothing</pre>
<p>The documentation clearly states that the <kbd>engage_wheels!</kbd> function is optional. Because of this, rather than providing an empty generic function, we have implemented an actual <kbd>engage_wheel!</kbd> function that does absolutely nothing and just returns a value of <kbd>nothing</kbd>. The landing logic is then written as follows:</p>
<pre># Landing<br/>function land!(vehicle)<br/>    engage_wheels!(vehicle)<br/>    println("Landing vehicle: ", vehicle)<br/>end</pre>
<p>Now, if the caller provides a vehicle type that implements the <kbd>engage_wheels!</kbd> function, then it will be used; otherwise, the call to <span><kbd>engage_wheels!</kbd> would invoke the generic function and do nothing. </span></p>
<p><span>I will leave it to the reader to complete this exercise by creating another vehicle type that implements the <kbd>engage_wheel!</kbd> function. (Sorry: the vehicle you develop is probably not very <em>high-tech</em> since it has wheels.)</span></p>
<p>A soft contract is a simple way to provide a default implementation for optional interface functions. Next, we will look into a slightly more formal method to declare whether a data type supports certain interface elements. We will call them <em>traits</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using interface traits</h1>
                </header>
            
            <article>
                
<p class="mce-root">Occasionally, you may encounter a situation where you need to determine whether a data type implements an interface. The information about whether a data type exhibits certain behavior is also called a trait.</p>
<p>How do we implement traits for an interface? In the <kbd>Vehicle</kbd> module, we can add a new function, as follows:</p>
<pre># trait<br/>has_wheels(vehicle) = error("Not implemented.")</pre>
<p>This default implementation simply raises an error, and that's intentional. This trait function is expected to be implemented by any vehicle data types. In the interface code, the landing function can make use of the trait function for a more refined logic:</p>
<pre># Landing (using trait)<br/>function land2!(vehicle)<br/>    has_wheels(vehicle) &amp;&amp; engage_wheels!(vehicle)<br/>    println("Landing vehicle: ", vehicle)<br/>end</pre>
<p>Generally speaking, trait functions just need to return a binary answer, <kbd>true</kbd> or <kbd>false</kbd>; however, it is entirely up to the developer how to design the trait. For example, it is perfectly reasonable to define the trait function so that it returns the type of landing gear—<kbd>:wheels</kbd>, <kbd>:slider</kbd>, or <kbd>:none</kbd>.</p>
<p>It is a good idea to define traits as simply as possible. As you may recall, the interface that we implemented for our fighter jet in the previous section requires five functions—<kbd>power_on!</kbd>, <kbd>power_off!</kbd>, <kbd>move!</kbd>, <kbd>turn!</kbd>, and <kbd>position</kbd>. From a design perspective, we can create different traits:</p>
<ul>
<li><kbd>has_power()</kbd>: returns <kbd>true</kbd> if the vehicle needs to be powered on/off</li>
<li><kbd>can_move()</kbd>: returns <kbd>true</kbd> if the vehicle is able to move</li>
<li><kbd>can_turn()</kbd>: returns <kbd>true</kbd> if the vehicle can turn in any direction</li>
<li><kbd>location_aware()</kbd>: returns <kbd>true</kbd> if the vehicle can keep track of its location</li>
</ul>
<p>Once we have these small building blocks, we can define more complex traits that are composed of these simple ones. For example, we can define a trait called <kbd>smart_vehicle</kbd> that supports all of the four traits that we listed. In addition, we can define a <kbd>solar_vehicle</kbd> trait, which is used for vehicles that rely on solar power and is always on.</p>
<p>Using traits is a very powerful technique to model object behaviors. There are some patterns that are built around how to implement traits in practice. We will discuss these more extensively in <a href="962e7c27-570f-498e-89b9-d9075c58cd45.xhtml"/><a href="962e7c27-570f-498e-89b9-d9075c58cd45.xhtml">Chapter 5</a>, <em>Reusability Patterns.</em></p>
<p>At this point, you should feel more comfortable about designing interfaces in Julia. They are relatively simple to understand and develop. While Julia does not provide any formal syntax for interface specification, it is not difficult to come up with our own convention. With the help of traits, we can even implement more dynamic behavior for our objects. </p>
<p>We have now concluded all topics in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we started our journey by discussing how to define functions and make use of various types of function arguments, such as positional arguments, keyword arguments, and variable arguments. We talked about how to use splatting to auto assign the elements of an array or tuple to function arguments. We explored first-class functions by assigning them to variables and passing them around in functional calls. We learned how to create anonymous functions and use the do-syntax to make code more readable.</p>
<p>We then discussed Julia's dispatch mechanism and introduced the concept of multiple dispatch. We realized that ambiguity may exist and so we reviewed the standard tools for detecting ambiguities. We have learned how dispatch is dynamic in nature. We looked at  parametric methods and how they could be useful in several use cases, such as enforcing type consistency and extracting type information from the type parameters. </p>
<p>We learned how to design interfaces. We realized that there is no formal language syntax for defining interfaces in Julia, but we also recognize defining interfaces is straightforward and easy to do. We came to know that sometimes it is acceptable to have soft contracts so that the developer does not have to implement all interface functions. Finally, we wrapped up the discussion with the concept of traits and how they can be useful for querying whether a data type implements a specific interface.</p>
<p>In the next chapter, we will discuss two more major features in the Julia language—macros and meta programming. Macros are very useful in creating new syntax that makes the code clean and easy to maintain. Just take a deep breath and keep going!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>How are positional arguments different from keyword arguments?</li>
<li>What is the difference between splatting and slurping?</li>
<li>What is the purpose of using the do-syntax?</li>
<li>What tool is available for detecting method ambiguities as related to multiple dispatch?</li>
<li>How do you ensure that the same concrete type is passed to a function in a parametric method?</li>
<li>How are interfaces implemented without any formal language syntax?</li>
<li>How do you implement traits, and how are traits useful?</li>
</ol>


            </article>

            
        </section>
    </body></html>