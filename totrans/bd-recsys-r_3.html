<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Recommender Systems"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Recommender Systems</h1></div></div></div><p>This chapter shows some popular recommendation techniques. In addition, we will implement some of them in R.</p><p>We will deal with the following techniques:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Collaborative filtering</strong></span>: This is the branch of techniques that we will explore in detail. The <a class="indexterm" id="id78"/>algorithms are based on information about similar users or similar items. The two sub-branches are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Item-based collaborative filtering</strong></span>: This recommends to a user the<a class="indexterm" id="id79"/> items<a class="indexterm" id="id80"/> that are most similar to the user's purchases</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>User-based collaborative filtering</strong></span>: This recommends to a user the<a class="indexterm" id="id81"/> items<a class="indexterm" id="id82"/> that are the most preferred by similar users</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Content-based filtering</strong></span>: This<a class="indexterm" id="id83"/> is for each user; it defines a user profile and identify the items that match it.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Hybrid filtering</strong></span>: This<a class="indexterm" id="id84"/> combines different techniques.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Knowledge-based filtering</strong></span>: This <a class="indexterm" id="id85"/>is uses explicit knowledge about users and items.</li></ul></div><div class="section" title="R package for recommendation – recommenderlab"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>R package for recommendation – recommenderlab</h1></div></div></div><p>In this chapter, we<a class="indexterm" id="id86"/> will build recommender systems using <code class="literal">recommenderlab</code>, which <a class="indexterm" id="id87"/>is an R <a class="indexterm" id="id88"/>package for collaborative filtering. This section will present a quick overview of this package. First, let's install it, if we haven't done so already:</p><div class="informalexample"><pre class="programlisting">if(!"recommenderlab" %in% rownames(installed.packages())){install.packages("recommenderlab")}</pre></div><p>Now, we can load the package. Then, using the <code class="literal">help</code> function, we can take a look at its documentation:</p><div class="informalexample"><pre class="programlisting">library("recommenderlab")
help(package = "recommenderlab")</pre></div><p>When we<a class="indexterm" id="id89"/> run the preceding <a class="indexterm" id="id90"/>command in RStudio, a help file containing some links and a list of functions will open.</p><p>The examples that you will see in this chapter contain some random components. In order to be able to reproduce the code obtaining the same output, we need to run this line:</p><div class="informalexample"><pre class="programlisting">set.seed(1)</pre></div><p>We are now ready to start exploring <code class="literal">recommenderlab</code>.</p><div class="section" title="Datasets"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>Datasets</h2></div></div></div><p>Like many other R packages, <code class="literal">recommenderlab</code> contains some datasets that can be used to play around <a class="indexterm" id="id91"/>with the functions:</p><div class="informalexample"><pre class="programlisting">data_package &lt;- data(package = "recommenderlab")
data_package$results[, "Item"]</pre></div><div class="section" title="Jester5k, MSWeb, and MovieLense"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec06"/>Jester5k, MSWeb, and MovieLense</h3></div></div></div><p>In our examples, we <a class="indexterm" id="id92"/>will use the <code class="literal">MovieLense</code> dataset; <a class="indexterm" id="id93"/>the data is about movies. The table contains the<a class="indexterm" id="id94"/> ratings that the users give to movies. Let's load the data and take a look at it:</p><div class="informalexample"><pre class="programlisting">data(MovieLense)
MovieLense
## 943 x 1664 rating matrix of class 'realRatingMatrix' with 99392 ratings.</pre></div><p>Each row of <code class="literal">MovieLense</code> corresponds to a user, and each column corresponds to a movie. There are more than <span class="emphasis"><em>943 x 1664 = 1,500,000</em></span> combinations between a user and a movie. Therefore, storing the complete matrix would require more than 1,500,000 cells. However, not every user has watched every movie. Therefore, there are fewer than 100,000 ratings, and the matrix is sparse. The <code class="literal">recommenderlab</code> package allows us to store it in a compact way.</p></div></div><div class="section" title="The class for rating matrices"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>The class for rating matrices</h2></div></div></div><p>In this section, we will explore <code class="literal">MovieLense</code> in detail:</p><div class="informalexample"><pre class="programlisting">class(MovieLense)
## [1] "realRatingMatrix"
## attr(,"package")
## [1] "recommenderlab"</pre></div><p>The <code class="literal">realRatingMatrix</code> class is defined by <code class="literal">recommenderlab</code>, and <code class="literal">ojectsojectsb</code> contains <a class="indexterm" id="id95"/>sparse rating matrices. Let's take a look at the methods that we can apply on the objects of this class:</p><div class="informalexample"><pre class="programlisting">methods(class = class(MovieLense))</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">[</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">dimnames&lt;-</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Recommender</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">binarize</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">dissimilarity</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">removeKnownRatings</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">calcPredictionAccuracy</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">evaluationScheme</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">rowCounts</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">calcPredictionAccuracy</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">getData.frame</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">rowMeans</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">colCounts</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">getList</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">rowSds</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">colMeans</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">getNormalize</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">rowSums</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">colSds</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">getRatings</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">sample</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">colSums</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">getTopNLists</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">show</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">denormalize</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">image</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">similarity</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dim</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">normalize</code></p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dimnames</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">nratings</code></p>
</td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><p>Some methods that are applicable to matrices have been redefined in a more optimized way. For instance, we can use <code class="literal">dim</code> to extract the number of rows and columns, and <code class="literal">colSums</code> to compute the sum of each column. In addition, there are new methods that are specific for recommendation systems.</p><p>Usually, rating matrices are sparse matrices. For this reason, the <code class="literal">realRatingMatrix</code> class supports a compact storage of sparse matrices. Let's compare the size of <code class="literal">MovieLense</code> with the corresponding R matrix:</p><div class="informalexample"><pre class="programlisting">object.size(MovieLense)
## 1388448 bytes
object.size(as(MovieLense, "matrix"))
## 12740464 bytes</pre></div><p>We can compute how many times the <code class="literal">recommenderlab</code> matrix is more compact:</p><div class="informalexample"><pre class="programlisting">object.size(as(MovieLense, "matrix")) / object.size(MovieLense)
## 9.17604692433566 bytes</pre></div><p>As expected, <code class="literal">MovieLense</code> occupies much less space than the equivalent standard R matrix. The rate is about <span class="emphasis"><em>1:9</em></span>, and the reason is the sparsity of <code class="literal">MovieLense</code>. A standard R matrix object<a class="indexterm" id="id96"/> stores all the missing values as 0s, so it stores 15 times more cells.</p></div><div class="section" title="Computing the similarity matrix"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Computing the similarity matrix</h2></div></div></div><p>Collaborative filtering algorithms are based on measuring the similarity between users or between items. For this purpose, <code class="literal">recommenderlab</code> contains the <code class="literal">similarity</code> function. The supported<a class="indexterm" id="id97"/> methods to compute similarities are <code class="literal">cosine</code>, <code class="literal">pearson</code>, and <code class="literal">jaccard</code>.</p><p>For instance, we might want to determine how similar the first five users are with each other. Let's compute this using the <code class="literal">cosine</code> distance:</p><div class="informalexample"><pre class="programlisting">similarity_users &lt;- similarity(MovieLense[1:4, ], method = "cosine", which = "users")</pre></div><p>The <code class="literal">similarity_users</code> object contains all the dissimilarities. Let's explore it:</p><div class="informalexample"><pre class="programlisting">class(similarity_users)
## [1] "dist"</pre></div><p>As expected, <code class="literal">similarity_users</code> is an object containing distances. Since <code class="literal">dist</code> is a base R class, we can use it in different ways. For instance, we could use <code class="literal">hclust</code> to build a hierarchic clustering model.</p><p>We can also convert <code class="literal">similarity_users</code> into a matrix and visualize it:</p><div class="informalexample"><pre class="programlisting">as.matrix(similarity_users)</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>1</p>
</th><th style="text-align: left" valign="bottom">
<p>2</p>
</th><th style="text-align: left" valign="bottom">
<p>3</p>
</th><th style="text-align: left" valign="bottom">
<p>4</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">0</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.1689</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.03827</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.06635</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">0.1689</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.09707</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.1531</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">0.03827</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.09707</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.3334</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">0.06635</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.1531</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.3334</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0</code></p>
</td></tr></tbody></table></div><p>Using <code class="literal">image</code>, we can visualize the matrix. Each row and each column corresponds to a user, and each cell corresponds to the similarity between two users:</p><div class="informalexample"><pre class="programlisting">image(as.matrix(similarity_users), main = "User similarity")</pre></div><p>The more red the cell is, the more similar two users are. Note that the diagonal is red, since it's comparing each user with itself:</p><div class="mediaobject"><img alt="Computing the similarity matrix" src="graphics/B03888_03_01.jpg"/></div><p>Using the<a class="indexterm" id="id98"/> same approach, we can compute and visualize the similarity between the first four items:</p><div class="informalexample"><pre class="programlisting">similarity_items &lt;- similarity(MovieLense[, 1:4], method = "cosine", which = "items")
as.matrix(similarity_items)</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>Toy Story (1995)</p>
</th><th style="text-align: left" valign="bottom">
<p>GoldenEye (1995)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><span class="strong"><strong>Toy Story (1995)</strong></span></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.4024</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><span class="strong"><strong>GoldenEye (1995)</strong></span></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.4024</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><span class="strong"><strong>Four Rooms (1995)</strong></span></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.3302</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.2731</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><span class="strong"><strong>Get Shorty (1995)</strong></span></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.4549</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.5026</code></p>
</td></tr></tbody></table></div><p>The table continues as follows:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>Four Rooms (1995)</p>
</th><th style="text-align: left" valign="bottom">
<p>Get Shorty (1995)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><span class="strong"><strong>Toy Story (1995)</strong></span></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.3302</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.4549</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><span class="strong"><strong>GoldenEye (1995)</strong></span></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.2731</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.5026</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><span class="strong"><strong>Four Rooms (1995)</strong></span></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.3249</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><span class="strong"><strong>Get Shorty (1995)</strong></span></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.3249</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0</code></p>
</td></tr></tbody></table></div><p>Similar to the <a class="indexterm" id="id99"/>preceding screenshot, we can visualize the matrix using this image:</p><div class="informalexample"><pre class="programlisting">image(as.matrix(similarity_items), main = "Item similarity")</pre></div><div class="mediaobject"><img alt="Computing the similarity matrix" src="graphics/B03888_03_02.jpg"/></div><p>The similarity is the base of collaborative filtering models.</p></div><div class="section" title="Recommendation models"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Recommendation models</h2></div></div></div><p>The <code class="literal">recommenderlab</code> package contains some options for the recommendation algorithm. We can <a class="indexterm" id="id100"/>display the model applicable to the <code class="literal">realRatingMatrix</code> objects using <code class="literal">recommenderRegistry$get_entries</code>:</p><div class="informalexample"><pre class="programlisting">recommender_models &lt;- recommenderRegistry$get_entries(dataType = "realRatingMatrix")</pre></div><p>The <code class="literal">recommender_models</code> object contains some information about the models. First, let's see<a class="indexterm" id="id101"/> which models we have:</p><div class="informalexample"><pre class="programlisting">names(recommender_models)</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Models</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">IBCF_realRatingMatrix</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">PCA_realRatingMatrix</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">POPULAR_realRatingMatrix</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">RANDOM_realRatingMatrix</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">SVD_realRatingMatrix</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">UBCF_realRatingMatrix</code></p>
</td></tr></tbody></table></div><p>Let's take a look at their descriptions:</p><div class="informalexample"><pre class="programlisting">lapply(recommender_models, "[[", "description")
## $IBCF_realRatingMatrix
## [1] "Recommender based on item-based collaborative filtering (real data)."
##
## $PCA_realRatingMatrix
## [1] "Recommender based on PCA approximation (real data)."
##
## $POPULAR_realRatingMatrix## [1] "Recommender based on item popularity (real data)."
##
## $RANDOM_realRatingMatrix
## [1] "Produce random recommendations (real ratings)."
##
## $SVD_realRatingMatrix
## [1] "Recommender based on SVD approximation (real data)."
##
## $UBCF_realRatingMatrix
## [1] "Recommender based on user-based collaborative filtering (real data)."</pre></div><p>Out of them, we will use <code class="literal">IBCF</code> and <code class="literal">UBCF</code>.</p><p>The <code class="literal">recommender_models</code> object also contains some other information, such as its parameters:</p><div class="informalexample"><pre class="programlisting">recommender_models$IBCF_realRatingMatrix$parameters</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Parameter</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">k</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">30</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">method</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Cosine</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">normalize</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">center</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">normalize_sim_matrix</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">FALSE</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">alpha</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.5</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">na_as_zero</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">FALSE</code></p>
</td></tr></tbody></table></div><p>For a more detailed description of the package and some use cases, you can take a look at the package vignette. You can find all the material by typing <code class="literal">help(package = "recommenderlab")</code>.</p><p>The <code class="literal">recommenderlab</code> package is a good and flexible package to perform recommendation. If we combine its models with other R tools, we will have a powerful framework <a class="indexterm" id="id102"/>to explore the data and build recommendation models.</p><p>In the next section, we will explore a dataset of <code class="literal">recommenderlab</code> using some of its tools.</p></div></div></div>
<div class="section" title="Data exploration"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Data exploration</h1></div></div></div><p>In this section, we <a class="indexterm" id="id103"/>will explore the <code class="literal">MovieLense</code> dataset. For this purpose, we will use <code class="literal">recommenderlab</code> to build recommender systems and <code class="literal">ggplot2</code> to visualize their results. Let's load the packages and the data:</p><div class="informalexample"><pre class="programlisting">library("recommenderlab")
library("ggplot2")
data(MovieLense)
class(MovieLense)
## [1] "realRatingMatrix"
## attr(,"package")
## [1] "recommenderlab"</pre></div><p><code class="literal">MovieLense</code> is a <code class="literal">realRatingMatrix</code> object containing a dataset about movie ratings. Each row corresponds to a user, each column to a movie, and each value to a rating.</p><div class="section" title="Exploring the nature of the data"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Exploring the nature of the data</h2></div></div></div><p>Let's take a quick<a class="indexterm" id="id104"/> look at <code class="literal">MovieLense</code>. As explained in the previous section, there are some generic methods that can be applied to <code class="literal">realRatingMatrix</code> objects. We can extract their size using <code class="literal">dim</code>:</p><div class="informalexample"><pre class="programlisting">dim(MovieLense)
## [1]  943 1664</pre></div><p>There are <code class="literal">943</code> users and <code class="literal">1664</code> movies. Since <code class="literal">realRatingMatrix</code> is an S4 class, the components of the objects are contained in <code class="literal">MovieLense</code> slots. We can see all the slots using <code class="literal">slotNames</code>, which displays all the data stored within an object:</p><div class="informalexample"><pre class="programlisting">slotNames(MovieLense)
## [1] "data"      "normalize"
MovieLense contains a data slot. Let's take a look at it.
class(MovieLense@data)
## [1] "dgCMatrix"
## attr(,"package")
## [1] "Matrix"
dim(MovieLense@data)
## [1]  943 1664</pre></div><p><code class="literal">MovieLense@data</code> belongs to the <code class="literal">dgCMatrix</code> class that inherits from <code class="literal">Matrix</code>. In order to perform <a class="indexterm" id="id105"/>custom data exploration, we might need to access this slot.</p></div><div class="section" title="Exploring the values of the rating"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>Exploring the values of the rating</h2></div></div></div><p>Starting <a class="indexterm" id="id106"/>from the slot data, we can explore the matrix. Let's take a look at the ratings. We can convert the matrix into a vector and explore its values:</p><div class="informalexample"><pre class="programlisting">vector_ratings &lt;- as.vector(MovieLense@data)
unique(vector_ratings)
## [1] 5 4 0 3 1 2
The ratings are integers in the range 0-5. Let's count the occurrences of each of them.
table_ratings &lt;- table(vector_ratings)
table_ratings</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Rating</p>
</th><th style="text-align: left" valign="bottom">
<p>Occurrences</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">0</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">1469760</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">1</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">6059</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">2</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">11307</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">3</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">27002</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">4</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">33947</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">5</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">21077</code></p>
</td></tr></tbody></table></div><p>According to the documentation, a rating equal to 0 represents a missing value, so we can remove them from <code class="literal">vector_ratings</code>:</p><div class="informalexample"><pre class="programlisting">vector_ratings &lt;- vector_ratings[vector_ratings != 0]</pre></div><p>Now, we can build a frequency plot of the ratings. In order to visualize a bar plot with frequencies, we can use <code class="literal">ggplot2</code>. Let's convert them into categories using factor and build a quick chart:</p><div class="informalexample"><pre class="programlisting">vector_ratings &lt;- factor(vector_ratings)</pre></div><p>Let's visualize their distribution using <code class="literal">qplot</code>:</p><div class="informalexample"><pre class="programlisting">qplot(vector_ratings) + ggtitle("Distribution of the ratings")</pre></div><p>The <a class="indexterm" id="id107"/>following image shows the distribution of the ratings:</p><div class="mediaobject"><img alt="Exploring the values of the rating" src="graphics/B03888_03_03.jpg"/></div><p>Most of the ratings are above <span class="strong"><strong>2,</strong></span> and the most common is <span class="strong"><strong>4</strong></span>.</p></div><div class="section" title="Exploring which movies have been viewed"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Exploring which movies have been viewed</h2></div></div></div><p>Starting with <code class="literal">MovieLense</code>, we can easily extract quick results using methods such as the following<a class="indexterm" id="id108"/> ones:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">colCounts</code>: This is the number of non-missing values for each column</li><li class="listitem" style="list-style-type: disc"><code class="literal">colMeans</code>: This is the average value for each column</li></ul></div><p>For instance, which are the most viewed movies? We can use <code class="literal">colCounts</code> for this purpose. First, let's count the views for each movie:</p><div class="informalexample"><pre class="programlisting">views_per_movie &lt;- colCounts(MovieLense)</pre></div><p>Then, we can sort the movies by number of views:</p><div class="informalexample"><pre class="programlisting">table_views &lt;- data.frame(
  movie = names(views_per_movie),
  views = views_per_movie
  )
table_views &lt;- table_views[order(table_views$views, decreasing = TRUE), ]</pre></div><p>Now, we can<a class="indexterm" id="id109"/> visualize the first six rows and build a histogram:</p><div class="informalexample"><pre class="programlisting">ggplot(table_views[1:6, ], aes(x = movie, y = views)) + geom_bar(stat="identity") + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + ggtitle("Number of views of the top movies")</pre></div><p>The following image shows the number of views of the top movies:</p><div class="mediaobject"><img alt="Exploring which movies have been viewed" src="graphics/B03888_03_04.jpg"/></div><p>In the preceding chart, you can notice that <span class="strong"><strong>Star Wars (1977)</strong></span> is the most viewed movie, exceeding the <a class="indexterm" id="id110"/>others by about 100 views.</p></div><div class="section" title="Exploring the average ratings"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Exploring the average ratings</h2></div></div></div><p>We can<a class="indexterm" id="id111"/> identify the top-rated movies by computing the average rating of each of them. For this purpose, we can use <code class="literal">colMeans</code>; it automatically ignores the 0s, since they represent missing values. Let's take a look at the distribution of the average movie rating:</p><div class="informalexample"><pre class="programlisting">average_ratings &lt;- colMeans(MovieLense)</pre></div><p>Let's build the chart using <code class="literal">qplot</code>:</p><div class="informalexample"><pre class="programlisting">qplot(average_ratings) + stat_bin(binwidth = 0.1) + ggtitle("Distribution of the average movie rating")</pre></div><p>The following image shows the distribution of the average movie rating:</p><div class="mediaobject"><img alt="Exploring the average ratings" src="graphics/B03888_03_05.jpg"/></div><p>The highest value is around 3, and there are a few movies whose rating is either 1 or 5. Probably, the<a class="indexterm" id="id112"/> reason is that these movies received a rating from a few people only, so we shouldn't take them into account. We can remove the movies whose number of views is below a defined threshold, for instance, below <code class="literal">100</code>:</p><div class="informalexample"><pre class="programlisting">average_ratings_relevant &lt;- average_ratings[views_per_movie &gt; 100]</pre></div><p>Let's build the chart:</p><div class="informalexample"><pre class="programlisting">qplot(average_ratings_relevant) + stat_bin(binwidth = 0.1) + ggtitle(paste("Distribution of the relevant average ratings"))</pre></div><p>The following image shows the distribution of the relevant average ratings:</p><div class="mediaobject"><img alt="Exploring the average ratings" src="graphics/B03888_03_06.jpg"/></div><p>All the<a class="indexterm" id="id113"/> rankings are between 2.3 and 4.5. As expected, we removed the extremes. The highest value changes, and now, it is around 4.</p></div><div class="section" title="Visualizing the matrix"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Visualizing the matrix</h2></div></div></div><p>We can visualize the matrix by building a heat map whose colors represent the ratings. Each row<a class="indexterm" id="id114"/> of the matrix corresponds to a user, each column to a movie, and each cell to its rating. For this purpose, we can use the generic method: <code class="literal">image</code>. The <code class="literal">recommenderlab</code> package redefined the method image for <code class="literal">realRatingMatrix</code> objects.</p><p>Let's build the heatmap using <code class="literal">image</code>:</p><div class="informalexample"><pre class="programlisting">image(MovieLense, main = "Heatmap of the rating matrix")</pre></div><p>The following image displays the heatmap of the rating matrix:</p><div class="mediaobject"><img alt="Visualizing the matrix" src="graphics/B03888_03_07.jpg"/></div><p>We can notice a white area in the top-right region. The reason is that the row and columns are sorted.</p><p>Since there <a class="indexterm" id="id115"/>are too many users and items, this chart is hard to read. We can build another chart zooming in on the first rows and columns.</p><p>Let's build the heat map using <code class="literal">image</code>:</p><div class="informalexample"><pre class="programlisting">image(MovieLense[1:10, 1:15], main = "Heatmap of the first rows and columns")</pre></div><p>The following image shows the heatmap of the first rows and columns:</p><div class="mediaobject"><img alt="Visualizing the matrix" src="graphics/B03888_03_08.jpg"/></div><p>Some users saw more movies than the others. However, this chart is just displaying some random users and items. What if, instead, we select the most relevant users and items? This means visualizing only the users who have seen many movies and the movies that have been seen <a class="indexterm" id="id116"/>by many users. To identify and select the most relevant users and movies, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Determine the minimum number of movies per user.</li><li class="listitem">Determine the minimum number of users per movie.</li><li class="listitem">Select the users and movies matching these criteria.</li></ol></div><p>For instance, we can visualize the top percentile of users and movies. In order to do this, we use the <code class="literal">quantile</code> function:</p><div class="informalexample"><pre class="programlisting">min_n_movies &lt;- quantile(rowCounts(MovieLense), 0.99)
min_n_users &lt;- quantile(colCounts(MovieLense), 0.99)
min_n_movies
##    99%
## 440.96
min_n_users
##    99%
## 371.07</pre></div><p>Now, we can visualize the rows and columns matching the criteria.</p><p>Let's build the heat map using <code class="literal">image</code>:</p><div class="informalexample"><pre class="programlisting">image(MovieLense[rowCounts(MovieLense) &gt; min_n_movies, colCounts(MovieLense) &gt; min_n_users], main = "Heatmap of the top users and movies")</pre></div><p>The following image displays the heatmap of the top users and movies:</p><div class="mediaobject"><img alt="Visualizing the matrix" src="graphics/B03888_03_09.jpg"/></div><p>Let's take account of the users having watched more movies. Most of them have seen all the top movies, and this is not surprising. We can notice some columns that are darker than the others. These columns represent the highest-rated movies. Conversely, darker rows represent <a class="indexterm" id="id117"/>users giving higher ratings. Because of this, we might need to normalize the data.</p><p>In this section, we have explored the data. In the next section, we will process and transform it in order to have the inputs for the recommendation models.</p></div></div>
<div class="section" title="Data preparation"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Data preparation</h1></div></div></div><p>This section will <a class="indexterm" id="id118"/>show you how to prepare the data to be used in recommender models. Follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select the relevant data.</li><li class="listitem">Normalize the data.</li></ol></div><div class="section" title="Selecting the most relevant data"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Selecting the most relevant data</h2></div></div></div><p>When we <a class="indexterm" id="id119"/>explored the data, we noticed that the table contains:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Movies that have been viewed only a few times. Their ratings might be biased because of lack of data.</li><li class="listitem" style="list-style-type: disc">Users who rated only a few movies. Their ratings might be biased.</li></ul></div><p>We need to determine the minimum number of users per movie and vice versa. The correct solution comes from an iteration of the entire process of preparing the data, building a recommendation model, and validating it. Since we are implementing the model for the first time, we can use a rule of thumb. After having built the models, we can come back and modify the data preparation.</p><p>We will define <code class="literal">ratings_movies</code> containing the matrix that we will use. It takes account of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Users who have rated at least 50 movies</li><li class="listitem" style="list-style-type: disc">Movies that have been watched at least 100 times</li></ul></div><p>The preceding points are defined in the following code:</p><div class="informalexample"><pre class="programlisting">ratings_movies &lt;- MovieLense[rowCounts(MovieLense) &gt; 50, colCounts(MovieLense) &gt; 100] ratings_movies
## 560 x 332 rating matrix of class 'realRatingMatrix' with 55298 ratings.</pre></div><p>The <code class="literal">ratings_movies</code> object contains about half of the users and a fifth of the movies in comparison with <code class="literal">MovieLense</code>.</p></div><div class="section" title="Exploring the most relevant data"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Exploring the most relevant data</h2></div></div></div><p>Using the<a class="indexterm" id="id120"/> same approach as we did in the previous section, let's visualize the top 2 percent of users and movies in the new matrix:</p><div class="informalexample"><pre class="programlisting"># visualize the top matrix
min_movies &lt;- quantile(rowCounts(ratings_movies), 0.98)
min_users &lt;- quantile(colCounts(ratings_movies), 0.98)</pre></div><p>Let's build the heatmap:</p><div class="informalexample"><pre class="programlisting">image(ratings_movies[rowCounts(ratings_movies) &gt; min_movies, colCounts(ratings_movies) &gt; min_users], main = "Heatmap of the top users and movies")</pre></div><p>The following image displays the heatmap of the top users and movies:</p><div class="mediaobject"><img alt="Exploring the most relevant data" src="graphics/B03888_03_10.jpg"/></div><p>As we already<a class="indexterm" id="id121"/> noticed, some rows are darker than the others. This might mean that some users give higher ratings to all the movies. However, we have visualized the top movies only. In order to have an overview of all the users, let's take a look at the distribution of the average rating by user:</p><div class="informalexample"><pre class="programlisting">average_ratings_per_user &lt;- rowMeans(ratings_movies)</pre></div><p>Let's visualize the distribution:</p><div class="informalexample"><pre class="programlisting">qplot(average_ratings_per_user) + stat_bin(binwidth = 0.1) + ggtitle("Distribution of the average rating per user")</pre></div><p>The following image shows the distribution of the average rating per user:</p><div class="mediaobject"><img alt="Exploring the most relevant data" src="graphics/B03888_03_11.jpg"/></div><p>As <a class="indexterm" id="id122"/>suspected, the average rating varies a lot across different users.</p></div><div class="section" title="Normalizing the data"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Normalizing the data</h2></div></div></div><p>Having <a class="indexterm" id="id123"/>users who give high (or low) ratings to all their movies might bias the results. We can remove this effect by normalizing the data in such a way that the average rating of each user is 0. The prebuilt <code class="literal">normalize</code> function does it automatically:</p><div class="informalexample"><pre class="programlisting">ratings_movies_norm &lt;- normalize(ratings_movies)</pre></div><p>Let's take a look at the average rating by users:</p><div class="informalexample"><pre class="programlisting">sum(rowMeans(ratings_movies_norm) &gt; 0.00001)
## [1] 0</pre></div><p>As expected, the mean rating of each user is <code class="literal">0</code> (apart from the approximation error). We can visualize the new matrix using <code class="literal">image</code>. Let's build the heat map:</p><div class="informalexample"><pre class="programlisting"># visualize the normalized matrix
image(ratings_movies_norm[rowCounts(ratings_movies_norm) &gt; min_movies, colCounts(ratings_movies_norm) &gt; min_users], main = "Heatmap of the top users and movies")</pre></div><p>The following image shows the heatmap of the top users and movies:</p><div class="mediaobject"><img alt="Normalizing the data" src="graphics/B03888_03_12.jpg"/></div><p>The first difference that we can notice is the colors, and this is because the data is continuous. Previously, the rating was an integer between 1 and 5. After the normalization, the rating can be any number between -5 and 5.</p><p>There are still some lines that are more blue and some that are more red. The reason is that we are<a class="indexterm" id="id124"/> visualizing only the top movies. We already checked that the average rating is 0 for each user.</p></div><div class="section" title="Binarizing the data"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Binarizing the data</h2></div></div></div><p>Some recommendation models work on binary data, so we might want to binarize our data, that is, define<a class="indexterm" id="id125"/> a table containing only 0s and 1s. The 0s will be either treated as missing values or as bad ratings.</p><p>In our case, we can either:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Define a matrix having 1 if the user rated the movie, and 0 otherwise. In this case, we are losing the information about the rating.</li><li class="listitem" style="list-style-type: disc">Define a matrix having 1 if the rating is above or equal to a definite threshold (for example, 3), and 0 otherwise. In this case, giving a bad rating to a movie is equivalent to not having rated it.</li></ul></div><p>Depending on the<a class="indexterm" id="id126"/> context, one choice is more appropriate than the other.</p><p>The function to binarize the data is <code class="literal">binarize</code>. Let's apply it to our data. First, let's define a matrix equal to 1 if the movie has been watched, that is if its rating is at least <code class="literal">1</code>:</p><div class="informalexample"><pre class="programlisting">ratings_movies_watched &lt;- binarize(ratings_movies, minRating = 1)</pre></div><p>Let's take a look at the results. In this case, we will have black-and-white charts so that we can visualize a larger portion of users and movies, for example, 5 percent. Similarly, let's select this 5 percent using <code class="literal">quantile</code>. The row and column counts are the same as the original matrix, so we can still apply <code class="literal">rowCounts</code> and <code class="literal">colCounts</code> on <code class="literal">ratings_movies</code>:</p><div class="informalexample"><pre class="programlisting">min_movies_binary &lt;- quantile(rowCounts(ratings_movies), 0.95)
min_users_binary &lt;- quantile(colCounts(ratings_movies), 0.95)</pre></div><p>Let's build the heat map:</p><div class="informalexample"><pre class="programlisting">image(ratings_movies_watched[rowCounts(ratings_movies) &gt; min_movies_binary,colCounts(ratings_movies) &gt; min_users_binary], main = "Heatmap of the top users and movies")</pre></div><p>The following image shows the heat map of the top users and movies:</p><div class="mediaobject"><img alt="Binarizing the data" src="graphics/B03888_03_13.jpg"/></div><p>Only a few <a class="indexterm" id="id127"/>cells contain unwatched movies. This is just because we selected the top users and movies.</p><p>Let's use the same approach to compute and visualize the other binary matrix The cells having a rating above the threshold will have their value equal to 1 and the other cells will be 0s:</p><div class="informalexample"><pre class="programlisting">ratings_movies_good &lt;- binarize(ratings_movies, minRating = 3)</pre></div><p>Let's build the heat map:</p><div class="informalexample"><pre class="programlisting">image(ratings_movies_good[rowCounts(ratings_movies) &gt; min_movies_binary, colCounts(ratings_movies) &gt; min_users_binary], main = "Heatmap of the top users and movies")</pre></div><p>The following image shows the heatmap of the top users and movies:</p><div class="mediaobject"><img alt="Binarizing the data" src="graphics/B03888_03_14.jpg"/></div><p>As expected, we<a class="indexterm" id="id128"/> have more white cells now. Depending on the model, we can leave the ratings matrix as it is or normalize/binarize it.</p><p>In this section, we prepared the data to perform recommendations. In the upcoming sections, we will build collaborative filtering models.</p></div></div>
<div class="section" title="Item-based collaborative filtering"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Item-based collaborative filtering</h1></div></div></div><p>Collaborative filtering is a branch of recommendation that takes account of the information <a class="indexterm" id="id129"/>about different users. The word "collaborative" refers to the fact that users collaborate with each other to recommend items. In fact, the algorithms take account of user purchases and preferences. The starting point is a rating matrix in which rows correspond to users and columns correspond to items.</p><p>This section will show you an example of item-based collaborative filtering. Given a new user, the algorithm considers the user's purchases and recommends similar items. The core algorithm is based on these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">For each two items, measure how similar they are in terms of having received similar ratings by similar users</li><li class="listitem">For each item, identify the <span class="emphasis"><em>k</em></span>-most similar items</li><li class="listitem">For each user, identify the items that are most similar to the user's purchases</li></ol></div><p>In this<a class="indexterm" id="id130"/> chapter, we will see the overall approach to building an IBCF model. In addition, the upcoming sections will show its details.</p><div class="section" title="Defining the training and test sets"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Defining the training and test sets</h2></div></div></div><p>We will build the model using a part of the <code class="literal">MovieLense</code> dataset (the training set) and apply it on the <a class="indexterm" id="id131"/>other part (the test set). Since it's <a class="indexterm" id="id132"/>not a topic of this chapter, we will not evaluate the model, but will only recommend movies to the users in the test set.</p><p>The two sets are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Training set</strong></span>: This <a class="indexterm" id="id133"/>set includes users from which the model learns</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Test set</strong></span>: This <a class="indexterm" id="id134"/>set includes users to whom we recommend movies</li></ul></div><p>The algorithm automatically normalizes the data, so we can use <code class="literal">ratings_movies</code> that contains relevant users and movies of <code class="literal">MovieLense</code>. We defined <code class="literal">ratings_movies</code> in the previous section as the subset of <code class="literal">MovieLense</code> users who have rated at least 50 movies and movies that have been rated at least 100 times.</p><p>First, we randomly define the <code class="literal">which_train</code> vector that is <code class="literal">TRUE</code> for users in the training set and <code class="literal">FALSE</code> for the others. We will set the probability in the training set as 80 percent:</p><div class="informalexample"><pre class="programlisting">which_train &lt;- sample(x = c(TRUE, FALSE), size = nrow(ratings_movies), replace = TRUE, prob = c(0.8, 0.2))
head(which_train)
## [1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE</pre></div><p>Let's define the training and the test sets:</p><div class="informalexample"><pre class="programlisting">recc_data_train &lt;- ratings_movies[which_train, ]
recc_data_test &lt;- ratings_movies[!which_train, ]</pre></div><p>If we want to recommend items to each user, we could just use the <span class="emphasis"><em>k</em></span>-fold:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Split the users randomly into five groups</li><li class="listitem" style="list-style-type: disc">Use a group as a test set and the other groups as training sets</li><li class="listitem" style="list-style-type: disc">Repeat it for each group</li></ul></div><p>This is a sample code:</p><div class="informalexample"><pre class="programlisting">which_set &lt;- sample(x = 1:5, size = nrow(ratings_movies), replace = TRUE)
for(i_model in 1:5) {
  which_train &lt;- which_set == i_model
  recc_data_train &lt;- ratings_movies[which_train, ]
  recc_data_test &lt;- ratings_movies[!which_train, ]
  # build the recommender
}</pre></div><p>In order to<a class="indexterm" id="id135"/> show how this package <a class="indexterm" id="id136"/>works, we split the data into training and test sets manually. You can also do this automatically in <code class="literal">recommenderlab</code> using the <code class="literal">evaluationScheme</code> function. This function also contains some tools to evaluate models that we will use in the <a class="link" href="ch04.html" title="Chapter 4. Evaluating the Recommender Systems">Chapter 4</a>, <span class="emphasis"><em>Evaluating the Recommender Systems</em></span>, which is about model evaluation.</p><p>Now, we have the inputs to build and validate the model.</p></div><div class="section" title="Building the recommendation model"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Building the recommendation model</h2></div></div></div><p>The function <a class="indexterm" id="id137"/>to build models is <code class="literal">recommender</code> and its inputs are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Data</strong></span>: This is the training set</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Method</strong></span>: This is the name of the technique</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Parameters</strong></span>: These are some optional parameters of the technique</li></ul></div><p>The model is called IBCF, which stands for item-based collaborative filtering. Let's take a look at its parameters:</p><div class="informalexample"><pre class="programlisting">recommender_models &lt;- recommenderRegistry$get_entries(dataType = "realRatingMatrix")
recommender_models$IBCF_realRatingMatrix$parameters</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Parameters</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">k</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">30</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">method</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Cosine</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">normalize</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">center</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">normalize_sim_matrix</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">FALSE</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">alpha</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">0.5</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">na_as_zero</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">FALSE</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">minRating</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">NA</code></p>
</td></tr></tbody></table></div><p>Some relevant parameters are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">k</code>: In the first step, the algorithm computes the similarities among each pair of items. Then, for each item, it identifies its <span class="emphasis"><em>k</em></span> most similar items and stores it.</li><li class="listitem" style="list-style-type: disc"><code class="literal">method</code>: This is the similarity function. By default, it is <code class="literal">Cosine</code>. Another popular option is <code class="literal">pearson</code>.</li></ul></div><p>At the<a class="indexterm" id="id138"/> moment, we can just set them to their defaults. In order to show how to change parameters, we are setting <code class="literal">k = 30</code>, which is the default. We are now ready to build a recommender model:</p><div class="informalexample"><pre class="programlisting">recc_model &lt;- Recommender(data = recc_data_train, method = "IBCF", parameter = list(k = 30))recc_model
## Recommender of type 'IBCF' for 'realRatingMatrix' ## learned using 111 users.
class(recc_model)
## [1] "Recommender"
## attr(,"package")
## [1] "recommenderlab"</pre></div><p>The <code class="literal">recc_model</code> class is an object of the <code class="literal">Recommender</code> class containing the model.</p></div><div class="section" title="Exploring the recommender model"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Exploring the recommender model</h2></div></div></div><p>Using <code class="literal">getModel</code>, we<a class="indexterm" id="id139"/> can extract some details about the model, such as its description and parameters:</p><div class="informalexample"><pre class="programlisting">model_details &lt;- getModel(recc_model)
model_details$description
## [1] "IBCF: Reduced similarity matrix"
model_details$k
## [1] 30</pre></div><p>The <code class="literal">model_details$sim</code> component contains the similarity matrix. Let's check its structure:</p><div class="informalexample"><pre class="programlisting">class(model_details$sim)
## [1] "dgCMatrix"
## attr(,"package")
## [1] "Matrix"
dim(model_details$sim)
## [1] 332 332</pre></div><p>As expected, <code class="literal">model_details$sim</code> is a square matrix whose size is equal to the number of items. We can explore a part of it using <code class="literal">image</code>:</p><div class="informalexample"><pre class="programlisting">n_items_top &lt;- 20</pre></div><p>Let's<a class="indexterm" id="id140"/> build the heat map:</p><div class="informalexample"><pre class="programlisting">image(model_details$sim[1:n_items_top, 1:n_items_top], main = "Heatmap of the first rows and columns")</pre></div><p>The following image displays heatmap of the first rows and columns:</p><div class="mediaobject"><img alt="Exploring the recommender model" src="graphics/B03888_03_15.jpg"/></div><p>Most of the values are equal to 0. The reason is that each row contains only <code class="literal">k</code> elements. Let's check it:</p><div class="informalexample"><pre class="programlisting">model_details$k
## [1] 30
row_sums &lt;- rowSums(model_details$sim &gt; 0)
table(row_sums)
## row_sums
##  30
## 332</pre></div><p>As expected, each row has <code class="literal">30</code> elements greater than <code class="literal">0</code>. However, the matrix is not supposed to be symmetric. In fact, the number of non-null elements for each column depends on how many times the corresponding movie was included in the top <span class="emphasis"><em>k</em></span> of another <a class="indexterm" id="id141"/>movie. Let's check the distribution of the number of elements by column:</p><div class="informalexample"><pre class="programlisting">col_sums &lt;- colSums(model_details$sim &gt; 0)</pre></div><p>Let's build the distribution chart:</p><div class="informalexample"><pre class="programlisting">qplot(col_sums) + stat_bin(binwidth = 1) + ggtitle("Distribution of the column count")</pre></div><p>The following image displays the distribution of the column count:</p><div class="mediaobject"><img alt="Exploring the recommender model" src="graphics/B03888_03_16.jpg"/></div><p>As expected, there are a few movies that are similar to many others. Let's see which are the movies with the most elements:</p><div class="informalexample"><pre class="programlisting">which_max &lt;- order(col_sums, decreasing = TRUE)[1:6]
rownames(model_details$sim)[which_max]</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Movie</p>
</th><th style="text-align: left" valign="bottom">
<p>col_sum</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">Sling Blade (1996)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">62</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Usual Suspects, The (1995)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">60</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Fargo (1996)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">58</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Vertigo (1958)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">58</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Stargate (1994)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">57</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Godfather (1972)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">55</code></p>
</td></tr></tbody></table></div></div><div class="section" title="Applying the recommender model on the test set"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Applying the recommender model on the test set</h2></div></div></div><p>Now, we <a class="indexterm" id="id142"/>are able to recommend movies to the users in the test set. We will define <code class="literal">n_recommended</code> that specifies the number of items to recommend to each user. This section will show you the most popular approach to computing a weighted sum:</p><div class="informalexample"><pre class="programlisting">n_recommended &lt;- 6</pre></div><p>For each user, the algorithm extracts its rated movies. For each movie, it identifies all its similar items, starting from the similarity matrix. Then, the algorithm ranks each similar item in this way:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Extract the user rating of each purchase associated with this item. The rating is used as a weight.</li><li class="listitem" style="list-style-type: disc">Extract the similarity of the item with each purchase associated with this item.</li><li class="listitem" style="list-style-type: disc">Multiply each weight with the related similarity.</li><li class="listitem" style="list-style-type: disc">Sum everything up.</li></ul></div><p>Then, the algorithm identifies the top <span class="emphasis"><em>n</em></span> recommendations:</p><div class="informalexample"><pre class="programlisting">recc_predicted &lt;- predict(object = recc_model, newdata = recc_data_test, n = n_recommended)
recc_predicted
## Recommendations as 'topNList' with n = 6 for 449 users.</pre></div><p>The <code class="literal">recc_predicted</code> object contains the recommendations. Let's take a look at its structure:</p><div class="informalexample"><pre class="programlisting">class(recc_predicted)
## [1] "topNList"## attr(,"package")## [1] "recommenderlab"
slotNames(recc_predicted)
## [1] "items"      "itemLabels" "n"</pre></div><p>The slots are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">items</code>: This is the list with the indices of the recommended items for each user</li><li class="listitem" style="list-style-type: disc"><code class="literal">itemLabels</code>: This is the name of the items</li><li class="listitem" style="list-style-type: disc"><code class="literal">n</code>: This is the number of recommendations</li></ul></div><p>For instance, these are the recommendations for the first user:</p><div class="informalexample"><pre class="programlisting">recc_predicted@items[[1]]
## [1] 201 182 254 274 193 297</pre></div><p>We <a class="indexterm" id="id143"/>can extract the recommended movies from <code class="literal">recc_predicted@item</code> labels:</p><div class="informalexample"><pre class="programlisting">recc_user_1 &lt;- recc_predicted@items[[1]]movies_user_1 &lt;- recc_predicted@itemLabels[recc_user_1]
movies_user_1</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Index</p>
</th><th style="text-align: left" valign="bottom">
<p>Movie</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">201</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Schindler's List (1993)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">182</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Secrets and Lies (1996)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">254</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Trainspotting (1996)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">274</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">The Deer Hunter (1978)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">193</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">L.A. Confidential (1997)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">297</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">The Manchurian Candidate (1962)</code></p>
</td></tr></tbody></table></div><p>We can define a matrix with the recommendations for each user:</p><div class="informalexample"><pre class="programlisting">recc_matrix &lt;- sapply(recc_predicted@items, function(x){
  colnames(ratings_movies)[x]
})
dim(recc_matrix)
## [1]   6 449</pre></div><p>Let's visualize the recommendations for the first four users:</p><div class="informalexample"><pre class="programlisting">recc_matrix[, 1:4]</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">Schindler's List (1993)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Babe (1995)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Secrets and Lies (1996)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">The Usual Suspects (1995)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Trainspotting (1996)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Taxi Driver (1976)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Deer Hunter (1978)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Blade Runner (1982)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">L.A. Confidential (1997)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Welcome to the Dollhouse (1995)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Manchurian Candidate, The (1962)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">The Silence of the Lambs (1991)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Batman Forever (1995)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Strictly Ballroom (1992)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Stargate (1994)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">L.A. Confidential (1997)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Star Trek III: The Search for Spock (1984)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Cold Comfort Farm (1995)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Tin Cup (1996)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">12 Angry Men (1957)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Courage Under Fire (1996)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Vertigo (1958)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Dumbo (1941)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">A Room with a View (1986)</code></p>
</td></tr></tbody></table></div><p>Now, we<a class="indexterm" id="id144"/> can identify the most recommended movies. For this purpose, we will define a vector with all the recommendations, and we will build a frequency plot:</p><div class="informalexample"><pre class="programlisting">number_of_items &lt;- factor(table(recc_matrix))chart_title &lt;- "Distribution of the number of items for IBCF"</pre></div><p>Let's build the distribution chart:</p><div class="informalexample"><pre class="programlisting">qplot(number_of_items) + ggtitle(chart_title)</pre></div><p>The following image shows the distribution of the number of items for IBCF:</p><div class="mediaobject"><img alt="Applying the recommender model on the test set" src="graphics/B03888_03_17.jpg"/></div><p>Most <a class="indexterm" id="id145"/>of the movies have been recommended only a few times, and a few movies have been recommended many times. Let's see which are the most popular movies:</p><div class="informalexample"><pre class="programlisting">number_of_items_sorted &lt;- sort(number_of_items, decreasing = TRUE)
number_of_items_top &lt;- head(number_of_items_sorted, n = 4)
table_top &lt;- data.frame(names(number_of_items_top), number_of_items_top)
table_top</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>names.number_of_items_top</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">Mr. Smith Goes to Washington (1939)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Mr. Smith Goes to Washington (1939)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Babe (1995)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Babe (1995)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Maltese Falcon (1941)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">The Maltese Falcon (1941)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">L.A. Confidential (1997)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">L.A. Confidential (1997)</code></p>
</td></tr></tbody></table></div><p>The preceding table continues as follows:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>number_of_items_top</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">Mr. Smith Goes to Washington (1939)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">55</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Babe (1995)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">38</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Maltese Falcon (1941)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">35</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">L.A. Confidential (1997)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">34</code></p>
</td></tr></tbody></table></div><p>IBCF recommends items on the basis of the similarity matrix. It's an eager-learning model, that is, once it's built, it doesn't need to access the initial data. For each item, the model stores the <span class="emphasis"><em>k</em></span>-most similar, so the amount of information is small once the model is built. This is an advantage in the presence of lots of data.</p><p>In addition, this algorithm is efficient and scalable, so it works well with big rating matrices. Its accuracy is rather good, compared with other recommendation models.</p><p>In the next section, we will explore another branch of techniques: user-based collaborative filtering.</p></div></div>
<div class="section" title="User-based collaborative filtering"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>User-based collaborative filtering</h1></div></div></div><p>In the previous <a class="indexterm" id="id146"/>section, the algorithm was based on items and the steps to identify recommendations were as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identify which items are similar in terms of having been purchased by the same people</li><li class="listitem" style="list-style-type: disc">Recommend to a new user the items that are similar to its purchases</li></ul></div><p>In this <a class="indexterm" id="id147"/>section, we will use the opposite approach. First, given a new user, we will identify its similar users. Then, we will recommend the top-rated items purchased by similar users. This approach is called user-based collaborative filtering. For each new user, these are the steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Measure how similar each user is to the new one. Like IBCF, popular similarity measures are correlation and cosine.</li><li class="listitem">Identify the most similar users. The options are:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Take account of the top <span class="emphasis"><em>k</em></span> users (<span class="emphasis"><em>k</em></span>-nearest_neighbors)</li><li class="listitem" style="list-style-type: disc">Take account of the users whose similarity is above a defined threshold</li></ul></div></li><li class="listitem">Rate the items purchased by the most similar users. The rating is the average rating among similar users and the approaches are:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Average rating</li><li class="listitem" style="list-style-type: disc">Weighted average rating, using the similarities as weights</li></ul></div></li><li class="listitem">Pick the top-rated items.</li></ol></div><p>Like we did in the previous chapter, we will build a training and a test set. Now, we can start building the model directly.</p><div class="section" title="Building the recommendation model"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Building the recommendation model</h2></div></div></div><p>The R command <a class="indexterm" id="id148"/>to build the model is the same as the previous chapter. Now, the technique is called UBCF:</p><div class="informalexample"><pre class="programlisting">recommender_models &lt;- recommenderRegistry$get_entries(dataType = "realRatingMatrix")
recommender_models$UBCF_realRatingMatrix$parameters</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Parameter</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">method</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">cosine</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">nn</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">25</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">sample</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">FALSE</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">normalize</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">center</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">minRating</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">NA</code></p>
</td></tr></tbody></table></div><p>Some relevant parameters are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">method</code>: This shows how to compute the similarity between users</li><li class="listitem" style="list-style-type: disc"><code class="literal">nn</code>: This shows the number of similar users</li></ul></div><p>Let's build a <a class="indexterm" id="id149"/>recommender model leaving the parameters to their defaults:</p><div class="informalexample"><pre class="programlisting">recc_model &lt;- Recommender(data = recc_data_train, method = "UBCF")recc_model
## Recommender of type 'UBCF' for 'realRatingMatrix' ## learned using 451 users.</pre></div><p>Let's extract some details about the model using <code class="literal">getModel</code>:</p><div class="informalexample"><pre class="programlisting">model_details &lt;- getModel(recc_model)</pre></div><p>Let's take a look at the components of the model:</p><div class="informalexample"><pre class="programlisting">names(model_details)</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Element</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">description</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">data</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">method</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">nn</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">sample</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">normalize</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">minRating</code></p>
</td></tr></tbody></table></div><p>Apart from the description and parameters of <code class="literal">model</code>, <code class="literal">model_details</code> contains a data slot:</p><div class="informalexample"><pre class="programlisting">model_details$data
## 451 x 332 rating matrix of class 'realRatingMatrix' with 43846 ratings.
## Normalized using center on rows.</pre></div><p>The <code class="literal">model_details$data</code> object contains the rating matrix. The reason is that UBCF is a lazy-learning technique, which means that it needs to access all the data to perform a prediction.</p></div><div class="section" title="Applying the recommender model on the test set"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Applying the recommender model on the test set</h2></div></div></div><p>In the<a class="indexterm" id="id150"/> same way as the IBCF, we can determine the top six recommendations for each new user:</p><div class="informalexample"><pre class="programlisting">n_recommended &lt;- 6
recc_predicted &lt;- predict(object = recc_model, newdata = recc_data_test, n = n_recommended) recc_predicted
## Recommendations as 'topNList' with n = 6 for 109 users.</pre></div><p>We can define a matrix with the recommendations to the test set users:</p><div class="informalexample"><pre class="programlisting">recc_matrix &lt;- sapply(recc_predicted@items, function(x){colnames(ratings_movies)[x]
})
dim(recc_matrix)
## [1]   6 109</pre></div><p>Let's <a class="indexterm" id="id151"/>take a look at the first four users:</p><div class="informalexample"><pre class="programlisting">recc_matrix[, 1:4]</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Usual Suspects (1995)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Lone Star (1996)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Shawshank Redemption (1994)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">This Is Spinal Tap (1984)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Contact (1997)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">The Wrong Trousers (1993)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Godfather (1972)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Hoop Dreams (1994)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Nikita (La Femme Nikita) (1990)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Mighty Aphrodite (1995)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Twelve Monkeys (1995)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Big Night (1996)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Silence of the Lambs (1991)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">The Usual Suspects (1995)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Shawshank Redemption (1994)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">The Wrong Trousers (1993)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Jaws (1975)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Monty Python and the Holy Grail (1974)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Schindler's List (1993)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">GoodFellas (1990)</code></p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p><code class="literal">The Godfather (1972)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Fargo (1996)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">2001: A Space Odyssey (1968)</code></p>
</td></tr></tbody></table></div><p>We can also compute how many times each movie got recommended and build the related frequency histogram:</p><div class="informalexample"><pre class="programlisting">number_of_items &lt;- factor(table(recc_matrix))
chart_title &lt;- "Distribution of the number of items for UBCF"</pre></div><p>Let's build the distribution chart:</p><div class="informalexample"><pre class="programlisting">qplot(number_of_items) + ggtitle(chart_title)</pre></div><p>The following image displays the distribution of the numbers of items for UBCF:</p><div class="mediaobject"><img alt="Applying the recommender model on the test set" src="graphics/B03888_03_18.jpg"/></div><p>Compared <a class="indexterm" id="id152"/>with the IBCF, the distribution has a longer tail. This means that there are some movies that are recommended much more often than the others. The maximum is 29, compared with 11 for IBCF.</p><p>Let's take a look at the top titles:</p><div class="informalexample"><pre class="programlisting">number_of_items_sorted &lt;- sort(number_of_items, decreasing = TRUE)
number_of_items_top &lt;- head(number_of_items_sorted, n = 4)
table_top &lt;- data.frame(names(number_of_items_top), number_of_items_top)
table_top</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>names.number_of_items_top</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">Schindler's List (1993)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Schindler's List (1993)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Shawshank Redemption (1994)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">The Shawshank Redemption (1994)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Silence of the Lambs (1991)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">The Silence of the Lambs (1991)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Godfather (1972)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">The Godfather (1972)</code></p>
</td></tr></tbody></table></div><p>The preceding table is continued as follows:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>number_of_items_top</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">Schindler's List (1993)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">36</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Shawshank Redemption (1994)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">34</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Silence of the Lambs (1991)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">29</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Godfather (1972)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">27</code></p>
</td></tr></tbody></table></div><p>Comparing the results of UBCF with IBCF helps in understanding the algorithm better. <a class="indexterm" id="id153"/>UBCF needs to access the initial data, so it is a lazy-learning model. Since it needs to keep the entire database in memory, it doesn't work well in the presence of a big rating matrix. Also, building the similarity matrix requires a lot of computing power and time.</p><p>However, UBCF's accuracy is proven to be slightly more accurate than IBCF, so it's a good option if the dataset is not too big.</p></div><div class="section" title="Collaborative filtering on binary data"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Collaborative filtering on binary data</h2></div></div></div><p>In the previous<a class="indexterm" id="id154"/> two sections, we built recommendation <a class="indexterm" id="id155"/>models based on user preferences, since the data displayed the rating for each purchase. However, this information is not always available. The following two scenarios can take place:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We know which items have been purchased, but not their ratings</li><li class="listitem" style="list-style-type: disc">For each user, we don't know which items it purchased, but we know which items it likes</li></ul></div><p>In these contexts, we can build a user-item matrix whose values would be 1 if the user purchased (or liked) the item, and 0 otherwise. This case is different from the previous cases, so it should be treated separately. Similar to the other cases, the techniques are item-based and user-based.</p><p>In our case, starting from <code class="literal">ratings_movies</code>, we can build a <code class="literal">ratings_movies_watched</code> matrix whose values will be 1 if the user viewed the movie, and 0 otherwise. We built it in one of the <span class="emphasis"><em>Binarizing the data</em></span> sections.</p></div><div class="section" title="Data preparation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Data preparation</h2></div></div></div><p>We can<a class="indexterm" id="id156"/> build <code class="literal">ratings_movies_watched</code> using the binarize method:</p><div class="informalexample"><pre class="programlisting">ratings_movies_watched &lt;- binarize(ratings_movies, minRating = 1)</pre></div><p>Let's take a quick look at the data. How many movies (out of 332) did each user watch? Let's build the distribution chart:</p><div class="informalexample"><pre class="programlisting">qplot(rowSums(ratings_movies_watched)) + stat_bin(binwidth = 10) + geom_vline(xintercept = mean(rowSums(ratings_movies_watched)), col = "red", linetype = "dashed") + ggtitle("Distribution of movies by user")</pre></div><p>The <a class="indexterm" id="id157"/>following image shows a distribution of movies by user:</p><div class="mediaobject"><img alt="Data preparation" src="graphics/B03888_03_19.jpg"/></div><p>On the average, each user watched about 100 movies, and only a few watched more than 200 movies.</p><p>In order to build a recommendation model, let's define a training set and a test set:</p><div class="informalexample"><pre class="programlisting">which_train &lt;- sample(x = c(TRUE, FALSE), size = nrow(ratings_movies), replace = TRUE, prob = c(0.8, 0.2))
recc_data_train &lt;- ratings_movies[which_train, ]
recc_data_test &lt;- ratings_movies[!which_train, ]</pre></div><p>We <a class="indexterm" id="id158"/>are now ready to build the IBCF and UBCF models.</p></div><div class="section" title="Item-based collaborative filtering on binary data"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Item-based collaborative filtering on binary data</h2></div></div></div><p>The first step with IBCF is defining a similarity between items. In the case of binary data, distances <a class="indexterm" id="id159"/>such as the correlation and the <a class="indexterm" id="id160"/>cosine don't work properly. A good alternative is the Jaccard index. Given two items, the index is computed as the number of users purchasing both the items divided by the number of users purchasing at least one of them. Let's start from <span class="inlinemediaobject"><img alt="Item-based collaborative filtering on binary data" src="graphics/B03888_03_20.jpg"/></span> and <span class="inlinemediaobject"><img alt="Item-based collaborative filtering on binary data" src="graphics/B03888_03_21.jpg"/></span>, which are the sets of users purchasing the first and second item, respectively. The "∩" symbol refers to the intersection of two sets, that is, the items contained in both. The "U" symbol refers to the union of two sets, that is, the items contained in at least one of them. The Jaccard index is the number of elements in the intersection between the two sets, divided by the number of elements in their union.</p><div class="mediaobject"><img alt="Item-based collaborative filtering on binary data" src="graphics/B03888_03_22.jpg"/></div><p>We can build the IBCF filtering model using the same commands as in the previous chapters. The only difference is the input parameter method equal to <code class="literal">Jaccard</code>:</p><div class="informalexample"><pre class="programlisting">recc_model &lt;- Recommender(data = recc_data_train, method = "IBCF", parameter = list(method = "Jaccard"))
model_details &lt;- getModel(recc_model)</pre></div><p>Like in the previous sections, we can recommend six items to each of the users in the test set:</p><div class="informalexample"><pre class="programlisting">n_recommended &lt;- 6
recc_predicted &lt;- predict(object = recc_model, newdata = recc_data_test, n = n_recommended)
recc_matrix &lt;- sapply(recc_predicted@items, function(x){colnames(ratings_movies)[x]
})</pre></div><p>Let's see the recommendations for the first four users.</p><div class="informalexample"><pre class="programlisting">recc_matrix[, 1:4]</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">L.A. Confidential (1997)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Hoop Dreams (1994)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Evita (1996)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Quiz Show (1994)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Being There (1979)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Strictly Ballroom (1992)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Chasing Amy (1997)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">This Is Spinal Tap (1984)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Dr. Strangelove or: How I Learned to Stop Worrying and Love the Bomb (1963)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">What's Eating Gilbert Grape (1993)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Full Monty (1997)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">The Wrong Trousers (1993)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Gone with the Wind (1939)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Cop Land (1997)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Citizen Kane (1941)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Lost Highway (1997)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">On Golden Pond (1981)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Kolya (1996)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Emma (1996)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Secrets and Lies (1996)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">One Flew Over the Cuckoo's Nest (1975)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Everyone Says I Love You (1996)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Philadelphia Story (1940)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Boogie Nights (1997)</code></p>
</td></tr></tbody></table></div><p>The <a class="indexterm" id="id161"/>approach is similar to IBCF using a rating<a class="indexterm" id="id162"/> matrix. Since we are not taking account of the ratings, the result will be less accurate.</p></div></div>
<div class="section" title="User-based collaborative filtering on binary data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>User-based collaborative filtering on binary data</h1></div></div></div><p>Similar to IBCF, we need to use the Jaccard index for UBCF. Given two users, the index is computed as<a class="indexterm" id="id163"/> the number of items <a class="indexterm" id="id164"/>purchased by both the users divided by the number of items purchased by at least one of them. The mathematical symbols are the same as in the previous section:</p><div class="mediaobject"><img alt="User-based collaborative filtering on binary data" src="graphics/B03888_03_23.jpg"/></div><p>Let's build the recommender model:</p><div class="informalexample"><pre class="programlisting">recc_model &lt;- Recommender(data = recc_data_train, method = "UBCF", parameter = list(method = "Jaccard"))</pre></div><p>Using the same commands as IBCF, let's recommend six movies to each user, and let's take a look at the first four users:</p><div class="informalexample"><pre class="programlisting">n_recommended &lt;- 6
recc_predicted &lt;- predict(object = recc_model, newdata = recc_data_test,n = n_recommended)
recc_matrix &lt;- sapply(recc_predicted@items, function(x){colnames(ratings_movies)[x]
})
dim(recc_matrix)
## [1]   6 109
recc_matrix[, 1:4]</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Shawshank Redemption (1994)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Titanic (1997)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Casablanca (1942)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Cinema Paradiso (1988)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Braveheart (1995)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Lone Star (1996)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Terminator (1984)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">L.A. Confidential (1997)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Usual Suspects (1995)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Singin' in the Rain (1952)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Twelve Monkeys (1995)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Leaving Las Vegas (1995)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Titanic (1997)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Monty Python and the Holy Grail (1974)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Usual Suspects, The (1995)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">The Shawshank Redemption (1994)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Groundhog Day (1993)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Schindler's List (1993)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Shawshank Redemption (1994)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Young Frankenstein (1974)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">The Blues Brothers (1980)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">The Usual Suspects (1995)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Monty Python and the Holy Grail (1974)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">North by Northwest (1959)</code></p>
</td></tr></tbody></table></div><p>The results are different from IBCF.</p><p>These<a class="indexterm" id="id165"/> techniques assumed that the 0s are <a class="indexterm" id="id166"/>missing values. However, there is also the option to treat them as bad ratings. There is a branch of technique that deals with binary matrices only.</p><p>Most of the users don't give ratings to items, so there are several real-life cases of 0-1 matrices. That's why it's important to know how to build recommender systems in these contexts.</p><div class="section" title="Conclusions about collaborative filtering"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Conclusions about collaborative filtering</h2></div></div></div><p>This book<a class="indexterm" id="id167"/> focuses on collaborative filtering as it's the most popular branch of recommendation. Also, it's the only one that is supported by <code class="literal">recommenderlab</code>.</p><p>However, collaborative filtering is not always the most suitable technique. This chapter provides an <a class="indexterm" id="id168"/>overview of its limitations and some alternatives.</p><div class="section" title="Limitations of collaborative filtering"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec07"/>Limitations of collaborative filtering</h3></div></div></div><p>Collaborative<a class="indexterm" id="id169"/> filtering has some limitations. When dealing with new users and/or new items, the algorithm has these potential problems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the new user hasn't seen any movie yet, neither the IBCF nor the UBCF is able to recommend any item. Unless the IBCF knows the items purchased by the new user, it can't work. The UBCF needs to know which users have similar preferences to the new one, but we don't know about its ratings.</li><li class="listitem" style="list-style-type: disc">If the new item hasn't been purchased by anyone, it will never be recommended. IBCF matches items that have been purchased by the same users, so it won't match the new item with any of the others. UBCF recommends to each user items purchased by similar users, and no one purchased the new item. So, the algorithm won't recommend it to anyone.</li></ul></div><p>Then, we might not be able to include them, and this challenge is called a cold start problem. In order to include new users and/or items, we need to take account of other information such as user profiles and item descriptions.</p><p>Another limitation of collaborative filtering is that it takes account of rating matrices only. In many contexts, we have some additional information that can improve the recommendations. In addition, user preferences are not always available, or they might be incomplete.</p><p>In the upcoming sections, we will look at some other approaches.</p></div></div></div>
<div class="section" title="Content-based filtering"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Content-based filtering</h1></div></div></div><p>Another popular <a class="indexterm" id="id170"/>branch of techniques is content-based filtering. The algorithms start with a description of items, and they don't need to take account of different users at the same time. For each user, the algorithms recommend items that are similar to its past purchases.</p><p>Here are the steps to perform a recommendation:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define item descriptions.</li><li class="listitem">Define user profiles based on purchases.</li><li class="listitem">Recommend to each user the items matching its profile</li></ol></div><p>User profiles are based on their purchases, so the algorithms recommend items similar to past purchases.</p></div>
<div class="section" title="Hybrid recommender systems"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Hybrid recommender systems</h1></div></div></div><p>In many situations, we are able to build different collaborative and content-based filtering models. What if we take account of all of them at the same time? In machine learning, the approach of<a class="indexterm" id="id171"/> combining different models usually leads to better results.</p><p>A simple example is collaborative filtering combined with information about users and/or items. In the case of IBCF, the distance between items can take account of user preferences and item descriptions at the same time. Even in UBCF, the distance between users can take account of their preferences and personal data.</p><p>In the case of recommendation, these models are called hybrids. There are different ways to combine filtering models.</p><p>Parallelized hybrid systems run the recommenders separately and combine their results. There are a few options such as the following ones:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Define a rule to pick one of the results for each user. The rule can be based on the user profile and/or on the recommendation.</li><li class="listitem" style="list-style-type: disc">Compute an average of the rankings. The average can be weighted.</li></ul></div><p>Pipelined hybrid systems run the recommenders in sequence. The output of each model is an input for the next.</p><p>Monolithic hybrid systems integrate the approaches in the same algorithm. Some options are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Feature combination</strong></span>: This<a class="indexterm" id="id172"/> can be learned from different types of inputs. For example, an algorithm can take account of ratings, user profiles, and item descriptions.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Feature augmentation</strong></span>: This builds the input of a recommender by combining<a class="indexterm" id="id173"/> different data sources.</li></ul></div></div>
<div class="section" title="Knowledge-based recommender systems"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Knowledge-based recommender systems</h1></div></div></div><p>There are <a class="indexterm" id="id174"/>situations where collaborative and content-based filtering don't work.</p><p>In these contexts, we can use explicit knowledge about users and products, and recommendation criteria. This branch of techniques is called knowledge-based. There are a variety of techniques, and they depend on the data and on the business problem. For this reason, it's <a class="indexterm" id="id175"/>hard to define some techniques that are applicable in different contexts.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Summary</h1></div></div></div><p>Among the different techniques for recommendation, collaborative filtering is the easiest to implement. In addition, content-based filtering algorithms depend on the context, and it's still possible to build them in R.</p><p>This chapter showed you different approaches to recommendation by focusing on collaborative filtering. The next chapter will show you how to test and evaluate the recommendation techniques.</p></div></body></html>