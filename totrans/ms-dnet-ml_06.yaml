- en: Chapter 6. AdventureWorks Redux – k-NN and Naïve Bayes Classifiers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。AdventureWorks Redux – k-NN and Naïve Bayes Classifiers
- en: Let's jump back to AdventureWorks and put our software engineer hat back on.
    A couple weeks after your successful implementation of a model to improve high-margin
    bike sales to individual customers, the CEO comes to your desk and says, "Can
    you help us with a problem? If you were not aware, we started out as a bike-only
    company. Then, in May of 2013, we added additional merchandise to our product
    offering. Although it went well in the beginning, we seem to have plateaued. We
    want to try to push a bit harder in this area. Through some basic PowerBI reporting,
    we see that anywhere from 86 percent to 88 percent of the customers who buy a
    bike also buy additional merchandise at the time of purchase."
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到AdventureWorks，重新戴上我们的软件工程师帽子。在你成功实施了一个模型来提高向个人客户销售高利润自行车后的几周，CEO来到你的办公桌前说：“你能帮助我们解决一个问题吗？如果你不知道，我们最初是一家只卖自行车的公司。然后在2013年5月，我们增加了我们的产品线。尽管一开始进展顺利，但我们似乎已经达到了顶峰。我们想在这个领域再努力一些。通过一些基本的PowerBI报告，我们看到购买自行车的客户中有86%到88%在购买时也购买了额外的商品。”
- en: '| Year Month | Cross | Solo | Total | %Cross |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 年月 | 交叉 | 独立 | 总计 | %交叉 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **201305** | 25 | 295 | 320 | 7.8% |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| **201305** | 25 | 295 | 320 | 7.8% |'
- en: '| **201306** | 429 | 69 | 498 | 86.1% |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| **201306** | 429 | 69 | 498 | 86.1% |'
- en: '| **201307** | 441 | 56 | 497 | 88.7% |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| **201307** | 441 | 56 | 497 | 88.7% |'
- en: '| **201308** | 525 | 83 | 608 | 86.3% |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| **201308** | 525 | 83 | 608 | 86.3% |'
- en: '| **201309** | 536 | 68 | 604 | 88.7% |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| **201309** | 536 | 68 | 604 | 88.7% |'
- en: '| **201310** | 649 | 100 | 749 | 86.6% |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| **201310** | 649 | 100 | 749 | 86.6% |'
- en: '| **201311** | 868 | 136 | 1,004 | 86.5% |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **201311** | 868 | 136 | 1,004 | 86.5% |'
- en: '| **201312** | 698 | 99 | 797 | 87.6% |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **201312** | 698 | 99 | 797 | 87.6% |'
- en: '| **201401** | 800 | 97 | 897 | 89.2% |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **201401** | 800 | 97 | 897 | 89.2% |'
- en: '| **201402** | 702 | 96 | 798 | 88.0% |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **201402** | 702 | 96 | 798 | 88.0% |'
- en: '| **201403** | 891 | 135 | 1,026 | 86.8% |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **201403** | 891 | 135 | 1,026 | 86.8% |'
- en: '| **201404** | 965 | 121 | 1,086 | 88.9% |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **201404** | 965 | 121 | 1,086 | 88.9% |'
- en: '| **201405** | 1,034 | 152 | 1,186 | 87.2% |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **201405** | 1,034 | 152 | 1,186 | 87.2% |'
- en: '| **TOTAL** | 8,563 | 1,507 | 10,070 | 85.0% |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **总计** | 8,563 | 1,507 | 10,070 | 85.0% |'
- en: '![AdventureWorks Redux – k-NN and Naïve Bayes Classifiers](img/00077.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![AdventureWorks Redux – k-NN and Naïve Bayes Classifiers](img/00077.jpeg)'
- en: The CEO continues, "We would love to be able to get that up above 90 percent.
    We launched an expensive marketing campaign, but it really didn't move the needle.
    Is there any way you can help us be more focused and identify those people on
    the fence for cross-selling opportunities?"
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: CEO继续说：“我们非常希望能够将这个比例提高到90%以上。我们发起了一项昂贵的营销活动，但它并没有真正推动指针的移动。你能否帮助我们更加专注，并识别那些处于交叉销售机会边缘的客户？”
- en: You say, "Sure," and immediately start thinking of a way to implement her instructions.
    Perhaps if you could identify some unique characteristics of those customers who
    buy additional merchandise compared to those customers who do not, a more targeted
    method might be implemented to get more people to buy additional merchandise.
    You immediately think of classification models like **K-Nearest Neighbor** (**k-NN**)
    and **Naïve Bayes**. Since you are not sure which one might work, you decide to
    try them both out.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你回答：“当然可以，”然后立即开始思考如何实施她的指示。也许如果你能识别出那些购买额外商品的客户与那些没有购买额外商品的客户的一些独特特征，就可以实施一个更有针对性的方法来吸引更多人购买额外商品。你立刻想到了分类模型，如**K-Nearest
    Neighbor**（k-NN）和**朴素贝叶斯**。由于你不确定哪一个可能有效，你决定尝试它们两个。
- en: k-Nearest Neighbors (k-NN)
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: k-Nearest Neighbors (k-NN)
- en: 'k-NN stands for k-Nearest Neighbors and is one of the most basic classification
    models available. Since a picture is worth a thousand words, let''s take a look
    at k-NN from a graphical perspective. Consider a group of students who spent some
    amount of time studying and also drinking beers the night before the exam. On
    a graph, it looks like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: k-NN代表k-Nearest Neighbors，是可用的最基本分类模型之一。因为“一图胜千言”，让我们从图形的角度来看一下k-NN。考虑一组在考试前一晚花了一些时间学习和喝酒的学生。在图表上，它看起来像这样：
- en: '![k-Nearest Neighbors (k-NN)](img/00078.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![k-Nearest Neighbors (k-NN)](img/00078.jpeg)'
- en: If I added a seventh student to the graph like this, would you think that the
    student passed or failed the exam?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在图表中添加一个像这样的第七个学生，你会认为这个学生通过了还是失败了考试？
- en: '![k-Nearest Neighbors (k-NN)](img/00079.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![k-Nearest Neighbors (k-NN)](img/00079.jpeg)'
- en: You would likely say they are a star—they passed the exam. If I asked you why,
    you would probably say that are more like the other stars. This kind of mental
    processing is very much how our minds work—if everyone in your neighborhood buys
    a Japanese car and thinks it has high quality, you are more likely to buy one
    too if you are looking for a high quality car. In fact, much of marketing is based
    on the k-NN theory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说他们是一个明星——他们通过了考试。如果我问你为什么，你可能会说他们更像是其他明星。这种心理处理方式非常类似于我们的思维方式——如果你们邻居都买日本车并认为它们质量高，那么如果你在寻找一辆高质量的车，你更有可能也会买一辆。事实上，市场营销中的很大一部分是基于
    k-NN 理论的。
- en: 'Unlike the brain, which makes associations effortlessly, k-NN actually uses
    some math to classify. Going back to our seventh student, k-NN would put them
    in the passing students'' group because the distance it is from the other passing
    students is short relative to the distance from the failing students:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与大脑能够轻松建立关联不同，k-NN 实际上使用了一些数学来分类。回到我们的第七个学生，k-NN 会把他们放入通过考试的学生组，因为与其他通过考试的学生相比，他们之间的距离较短，而与未通过考试的学生相比距离较远：
- en: '![k-Nearest Neighbors (k-NN)](img/00080.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![k-Nearest Neighbors (k-NN)](img/00080.jpeg)'
- en: In fact, one of the simplest k-NN implementations is to take the average of
    all of the items of the category (five hours of studies and drinking one beer
    for the stars, on average) and measure that distance to the new item. Hopefully,
    the name k-NN makes sense now—for a given new item K, what are its nearest neighbors?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，k-NN 最简单的实现之一就是取该类别所有项目的平均值（平均五小时学习和喝一杯啤酒），然后测量这个距离到新项目。希望现在 k-NN 的名字对你来说有了一定的意义——对于一个给定的新项目
    K，它的最近邻是什么？
- en: k-NN example
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: k-NN 示例
- en: 'Let''s take a look at k-NN in action using **Accord.NET**. Open up Visual Studio
    and create a new Visual F# Windows Library project called `Classification`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 **Accord.NET** 来实际操作 k-NN。打开 Visual Studio 并创建一个名为 `Classification`
    的新 Visual F# Windows Library 项目：
- en: '![k-NN example](img/00081.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![k-NN example](img/00081.jpeg)'
- en: 'Go into the `Script.fsx` file and remove all of its contents. Rename `Scipt.fsx`
    to `k-NNAccord.fsx`. Open up **NuGet Package Manager** console and enter this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 `Script.fsx` 文件并删除其所有内容。将 `Scipt.fsx` 重命名为 `k-NNAccord.fsx`。打开 **NuGet 包管理器**
    控制台并输入以下内容：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Go back to your script and enter in the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 回到你的脚本，输入以下代码：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Send this to the REPL to see the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些发送到 REPL，你会看到以下结果：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Most of this code should look familiar to you by now. The inputs represent
    six students with two characteristics: how many hours they spent studying the
    night before an exam and how much beer they drank. The outputs represent whether
    they passed the exam: `1` if they passed, `0` if they did not. The class''s value
    tells Accord that there are two types of values to consider. In this case, those
    values are the hours spent in studying and the quantity of beer consumed. The
    `k` value tells Accord how many data points we want to use for the calculation
    for each class. If we changed that to `4`, then we would have included one failing
    student with the three passing students (and vice versa), which would have watered
    down our result.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这段代码应该对你来说已经很熟悉了。输入代表六个学生的两个特征：他们在考试前一晚学习了多少小时以及他们喝了多少啤酒。输出代表他们是否通过了考试：`1`代表通过，`0`代表未通过。班级的值告诉
    Accord 有两种类型的值需要考虑。在这种情况下，这些值是学习时间和啤酒消费量。`k` 值告诉 Accord 对于每个类别我们希望使用多少个数据点进行计算。如果我们将其改为
    `4`，那么我们就会包括一个未通过考试的学生和三个通过考试的学生（反之亦然），这会稀释我们的结果。
- en: 'Go back to the script and enter these lines that represent the seventh student:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 回到脚本中，输入代表第七个学生的以下行：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When you send it to the FSI, you will see that student number `7` will most
    likely pass the exam:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将其发送到 FSI 时，你会看到学生编号 `7` 很可能通过考试：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As I mentioned earlier, k-NN is one of the most basic machine learning models
    you can use, but in certain circumstances it can be surprisingly powerful. One
    of the more common adjustments to k-NN is weighing the distance from the neighbors.
    The closer a point is to the neighbors, the more weight that distance gets. The
    biggest criticism of k-NN is that it can overweigh if there are many observations
    that center around one point, so it is important to have a balanced dataset, if
    possible.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，k-NN 是你可以使用的最基础的机器学习模型之一，但在某些情况下它可以非常强大。对 k-NN 更常见的一种调整是权衡邻居的距离。一个点离邻居越近，这个距离的权重就越大。k-NN
    最主要的批评之一是，如果有很多观察值围绕一个点，它可能会过度权衡，因此如果可能的话，拥有一个平衡的数据集是很重要的。
- en: Naïve Bayes
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Naïve Bayes
- en: Naïve Bayes is a classification model that attempts to predict if an entity
    belongs to a series of predefined sets. When you aggregate all the sets together,
    you have a pretty good estimation of the final result. In order to illustrate,
    let's go back to the tennis example that we used when talking about decision trees.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 简单贝叶斯是一种分类模型，试图预测一个实体是否属于一系列预定义的集合。当你将这些集合汇总在一起时，你会有一个相当好的最终结果估计。为了说明，让我们回到我们讨论决策树时使用的网球示例。
- en: 'We have the following observations for two weeks:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两周的观察，我们有以下发现：
- en: '| Day | Outlook | Temperature | Humidity | Wind | PlayTennis? |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 天 | 天气展望 | 温度 | 湿度 | 风 | 打网球？ |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | sunny | Hot | High | weak | No |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 晴朗 | 炎热 | 高 | 弱 | 无 |'
- en: '| 1 | sunny | Hot | High | strong | No |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 晴朗 | 炎热 | 高 | 强 | 否 |'
- en: '| 2 | overcast | Hot | High | weak | Yes |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 阴天 | 炎热 | 高 | 弱 | 是 |'
- en: '| 3 | rain | Mild | High | weak | Yes |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 雨 | 温和 | 高 | 弱 | 是 |'
- en: '| 4 | rain | Cool | Normal | weak | Yes |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 雨 | 凉爽 | 正常 | 弱 | 是 |'
- en: '| 5 | rain | Cool | Normal | strong | No |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 雨 | 凉爽 | 正常 | 强 | 否 |'
- en: '| 6 | overcast | Cool | Normal | strong | Yes |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 阴天 | 凉爽 | 正常 | 强 | 是 |'
- en: '| 7 | sunny | Mild | High | weak | No |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 晴朗 | 温和 | 高 | 弱 | 否 |'
- en: '| 8 | sunny | Cool | Normal | weak | yes |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 晴朗 | 凉爽 | 正常 | 弱 | 是 |'
- en: '| 9 | rain | Mild | Normal | weak | yes |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 雨 | 温和 | 正常 | 弱 | 是 |'
- en: '| 10 | sunny | Mild | Normal | strong | yes |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 晴朗 | 温和 | 正常 | 强 | 是 |'
- en: '| 11 | overcast | Mild | High | strong | yes |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 阴天 | 温和 | 高 | 强 | 是 |'
- en: '| 12 | overcast | Hot | Normal | weak | yes |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 阴天 | 炎热 | 正常 | 弱 | 是 |'
- en: '| 13 | rain | Mild | High | strong | no |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 雨 | 温和 | 高 | 强 | 否 |'
- en: 'For each one of the classes, let''s break down whether they wound up playing
    tennis that day and then do a percentage for each possibility:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一类，让我们分析他们那天是否打网球，然后为每种可能性计算一个百分比：
- en: '| ID | Outlook | Yes | No | % Yes | % No |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| ID | 天气展望 | 是 | 否 | % 是 | % 否 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | sunny | 2 | 3 | 0.22 | 0.60 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 晴朗 | 2 | 3 | 0.22 | 0.60 |'
- en: '| 1 | overcast | 4 | 0 | 0.44 | 0.00 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 阴天 | 4 | 0 | 0.44 | 0.00 |'
- en: '| 2 | rain | 3 | 2 | 0.33 | 0.40 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 雨 | 3 | 2 | 0.33 | 0.40 |'
- en: '|   | **Total** | 9 | 5 | 1.00 | 1.00 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|   | **总计** | 9 | 5 | 1.00 | 1.00 |'
- en: '|   |   |   |   |   |   |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |'
- en: '| **ID** | **Temperature** | **Yes** | **No** | **% Yes** | **% No** |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | **温度** | **是** | **否** | **% 是** | **% 否** |'
- en: '| 0 | hot | 2 | 2 | 0.22 | 0.40 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 热 | 2 | 2 | 0.22 | 0.40 |'
- en: '| 1 | mild | 4 | 2 | 0.44 | 0.40 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 温和 | 4 | 2 | 0.44 | 0.40 |'
- en: '| 2 | cool | 3 | 1 | 0.33 | 0.20 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 凉爽 | 3 | 1 | 0.33 | 0.20 |'
- en: '|   | **Total** | 9 | 5 | 1.00 | 1.00 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|   | **总计** | 9 | 5 | 1.00 | 1.00 |'
- en: '|   |   |   |   |   |   |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |'
- en: '| **ID** | **Humidity** | **Yes** | **No** | **% Yes** | **% No** |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | **湿度** | **是** | **否** | **% 是** | **% 否** |'
- en: '| 0 | high | 3 | 4 | 0.33 | 0.80 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 高 | 3 | 4 | 0.33 | 0.80 |'
- en: '| 1 | normal | 6 | 1 | 0.67 | 0.20 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 正常 | 6 | 1 | 0.67 | 0.20 |'
- en: '|   | **Total** | 9 | 5 | 1.00 | 1.00 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|   | **总计** | 9 | 5 | 1.00 | 1.00 |'
- en: '|   |   |   |   |   |   |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |'
- en: '| **ID** | **Wind** | **Yes** | **No** | **% Yes** | **% No** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | **风** | **是** | **否** | **% 是** | **% 否** |'
- en: '| 0 | weak | 6 | 2 | 0.67 | 0.40 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 弱 | 6 | 2 | 0.67 | 0.40 |'
- en: '| 1 | strong | 3 | 3 | 0.33 | 0.60 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 强 | 3 | 3 | 0.33 | 0.60 |'
- en: '|   | **Total** | 9 | 5 | 1.00 | 1.00 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|   | **总计** | 9 | 5 | 1.00 | 1.00 |'
- en: '|   |   |   |   |   |   |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |'
- en: '| **ID** | **Final** | **Yes** | **No** | **% Yes** | **% No** |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | **最终** | **是** | **否** | **% 是** | **% 否** |'
- en: '| 0 | Play | 9 | 5 | 0.64 | 0.36 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 打 | 9 | 5 | 0.64 | 0.36 |'
- en: 'With these grids available, we can then predict if a person will or will not
    play tennis for a series of conditions. For example, will a person play on a sunny,
    cool day with high humidity and strong winds? We can pull the percentages from
    each grid:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有这些网格可用时，我们就可以预测一个人在一系列条件下是否会打网球。例如，一个人会在晴朗、凉爽、高湿度和大风的日子里打网球吗？我们可以从每个网格中提取百分比：
- en: '|   |   | Yes | No |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|   |   | 是 | 否 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **Outlook** | sunny | 0.222 | 0.600 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **天气展望** | 晴朗 | 0.222 | 0.600 |'
- en: '| **Temperature** | cool | 0.333 | 0.200 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **温度** | 凉爽 | 0.333 | 0.200 |'
- en: '| **Humidity** | high | 0.333 | 0.800 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **湿度** | 高 | 0.333 | 0.800 |'
- en: '| **Wind** | strong | 0.333 | 0.600 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **风** | 强 | 0.333 | 0.600 |'
- en: '|   | **final** | 0.643 | 0.357 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|   | **最终** | 0.643 | 0.357 |'
- en: 'And then the values can be multiplied together for each possibility:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以将每个可能性的值相乘：
- en: Probability of Yes = 0.222 * 0.333 * 0.333 * 0.333 * 0.643 = 0.005
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的概率 = 0.222 * 0.333 * 0.333 * 0.333 * 0.643 = 0.005
- en: Probability of No = 0.600 * 0.200 * 0.800 * 0.600 * 0.357 = 0.021
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否的概率 = 0.600 * 0.200 * 0.800 * 0.600 * 0.357 = 0.021
- en: 'You can see that there is a higher percentage not playing than playing. We
    can also take the two percentages and compare them to each other like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到不打球的比例高于打球的比例。我们还可以将这两个百分比进行比较，如下所示：
- en: '*0.005 + 0.021 = 0.026*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*0.005 + 0.021 = 0.026*'
- en: '*0.005/0.026 = 0.205 and 0.021/0.026 = 0.795*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*0.005/0.026 = 0.205 和 0.021/0.026 = 0.795*'
- en: There is about a 20 percent chance of playing tennis and 80 percent chance of
    not playing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 打网球的可能性大约有20%，而不打的可能性有80%。
- en: Naïve Bayes in action
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 朴素贝叶斯在行动
- en: 'Let''s see how Accord.NET calculates a Naïve Bayes model. Go to Visual Studio
    and add a new script file called `NaiveBayesAccord.fsx`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Accord.NET是如何计算朴素贝叶斯模型的。转到Visual Studio并添加一个名为`NaiveBayesAccord.fsx`的新脚本文件：
- en: 'In that script, add the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个脚本中，添加以下代码：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you send them to the FSI, you will see the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将它们发送到FSI时，你会看到以下内容：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The inputs are the values turned into integers. Consider the following example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是将值转换为整数。考虑以下示例：
- en: '| Outlook | ID |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 展望 | ID |'
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Sunny | 0 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 晴朗 | 0 |'
- en: '| Overcast | 1 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 多云 | 1 |'
- en: '| Rain | 2 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 雨 | 2 |'
- en: '|   |   |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|   |   |'
- en: '| **Temperature** | **ID** |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **温度** | **ID** |'
- en: '| Hot | 0 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 炎热 | 0 |'
- en: '| Mild | 1 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 温和 | 1 |'
- en: '| Cool | 2 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 酷 | 2 |'
- en: '|   |   |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|   |   |'
- en: '| **Humidity** | **ID** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **湿度** | **ID** |'
- en: '| High | 0 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 高 | 0 |'
- en: '| Normal | 1 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 正常 | 1 |'
- en: '|   |   |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|   |   |'
- en: '| **Wind** | **ID** |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **风** | **ID** |'
- en: '| Weak | 0 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 弱 | 0 |'
- en: '| Strong | 1 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 强 | 1 |'
- en: The position in each array is *[outlook;temperature;humidity;wind]*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组中的位置是 *[展望;温度;湿度;风]*。
- en: 'The outputs are the result values turned into integers:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果是结果值转换为整数：
- en: '| Play | ID |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 打球 | ID |'
- en: '| --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| No | 0 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 否 | 0 |'
- en: '| Yes | 1 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 是 | 1 |'
- en: 'The symbols value is an array that tells Accord the total number of possible
    values for each feature. For example, the first position is for outlook and there
    are three possible values: (0, 1, 2).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 符号值是一个数组，它告诉Accord每个特征的可能的值的总数。例如，第一个位置是展望，有三个可能的值：(0, 1, 2)。
- en: 'Go back to the script and add in the Naïve Bayes calculation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '返回脚本并添加朴素贝叶斯计算： '
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Sending to the REPL gives the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据发送到REPL会得到以下结果：
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The error is calculated by Accord re-running its estimate several times and
    comparing the actual to the expected. A good way of interpreting the error is
    that the lower the number is better, and the domain dictates if the actual number
    is "good enough". For example, a 14 percent error is great for social experiments,
    where humans are capable for random and unpredictable behaviors. Conversely, a
    14 percent error rate for predicting airplane engine failure would not be considered
    acceptable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是通过Accord重新运行其估计多次并比较实际值与预期值来计算的。解释错误的一个好方法是，数字越低越好，领域决定了实际数字是否“足够好”。例如，14%的错误率对于人类能够进行随机和不可预测行为的社交实验来说是非常好的。相反，对于预测飞机引擎故障，14%的错误率是不可接受的。
- en: 'Finally, let''s see a prediction for sunny outlook, mild temperature, normal
    humidity, and weak wind. Go to the script and add this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看对晴朗天气、温和温度、正常湿度和弱风的预测。转到脚本并添加以下内容：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Sending to the REPL gives us the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据发送到REPL会得到以下结果：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So we will be playing tennis on that day.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在那天打网球。
- en: One thing to keep in mind while using Naïve Bayes
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用朴素贝叶斯时需要注意的一件事
- en: 'Created in the 1950s, Naïve Bayes is a highly effective classification model
    that has stood the test of time. In fact, many spam filters today still use, in
    part, Naïve Bayes. The biggest advantages of using Naïve Bayes are its simplicity
    and its ability to, well, be right. The biggest downside is the key assumption
    that every *x* variable is completely and utterly independent. If there is any
    chance that the *x* variables are collinear, Naïve Bayes breaks down. Also, Naïve
    Bayes, historically, has been applied to datasets that are Gaussian—that it follows
    a bell curve. If you are not familiar with a bell curve, it is a distribution
    of data where the most observations occur in the middle values with the outliers
    to both sides of the middle having roughly the same number of observations. Here
    is an example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪50年代创建的朴素贝叶斯是一种非常有效的分类模型，它经受了时间的考验。事实上，今天许多垃圾邮件过滤器部分仍在使用朴素贝叶斯。使用朴素贝叶斯的最大优点是其简单性和正确性的能力。最大的缺点是关键假设是每个
    *x* 变量都是完全且完全独立的。如果 *x* 变量有任何可能存在共线性，朴素贝叶斯就会失效。此外，从历史上看，朴素贝叶斯被应用于高斯分布的数据集——即它遵循钟形曲线。如果你不熟悉钟形曲线，它是一种数据分布，其中大多数观测值发生在中间值，中间两侧的异常值具有大致相同数量的观测值。以下是一个例子：
- en: '![One thing to keep in mind while using Naïve Bayes](img/00082.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![使用朴素贝叶斯时需要注意的一件事](img/00082.jpeg)'
- en: 'In contrast, a skewed distribution has the most observations at one end or
    the other:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，偏斜分布的观测值最多在一端或另一端：
- en: '![One thing to keep in mind while using Naïve Bayes](img/00083.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![使用朴素贝叶斯时需要注意的一件事](img/00083.jpeg)'
- en: When you use Naïve Bayes, you will have to make sure the distribution you select
    matches your data. Let's now see if k-NN and/or Naïve Bayes can help us with AdventureWorks.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用朴素贝叶斯时，您必须确保选择的分布与您的数据匹配。现在让我们看看k-NN和/或朴素贝叶斯是否可以帮助我们处理AdventureWorks。
- en: AdventureWorks
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AdventureWorks
- en: In this section, we are going to take the knowledge that we gained in [Chapter
    5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055 "Chapter 5. Time
    Out – Obtaining Data"), *Time Out – Obtaining Data*, to extract and transform
    data and apply both k-NN and Naïve Bayes machine learning models. Let's see if
    none, one, or both methodologies will help us increase cross-sales.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将利用我们在[第5章](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "第5章。时间暂停 – 获取数据")，“时间暂停 – 获取数据”中获得的知识，提取和转换数据，并应用k-NN和朴素贝叶斯机器学习模型。让我们看看这三种方法中是否有任何一种可以帮助我们提高交叉销售。
- en: Getting the data ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备数据
- en: 'Go into Visual Studio and add another script called `AdventureWorks.fsx`. Open
    up the script, remove all of the contents, and open **NuGet Package Manager**
    console. In the package manager, run the following lines:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 进入Visual Studio并添加另一个名为`AdventureWorks.fsx`的脚本。打开脚本，删除所有内容，并打开**NuGet包管理器**控制台。在包管理器中，运行以下行：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Go back to the script file and add the following references:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 返回脚本文件并添加以下引用：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next add the following lines of code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接着添加以下代码行：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you remember from [Chapter 5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "Chapter 5. Time Out – Obtaining Data"), *Time Out – Obtaining Data*, this is
    creating our type provider to pull data from the database. Send everything so
    far to the REPL to see the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得[第5章](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "第5章。时间暂停 – 获取数据")，“时间暂停 – 获取数据”，这是创建我们的类型提供者以从数据库中提取数据。将到目前为止的所有内容发送到REPL以查看以下结果：
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Go back to the script and add this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 返回脚本并添加以下内容：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Sending this to the FSI gives the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到FSI得到以下结果：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is also from [Chapter 5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "Chapter 5. Time Out – Obtaining Data"), *Time Out – Obtaining Data*; we are overriding
    the `in` operator to handle null values in the database.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是从[第5章](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055 "第5章。时间暂停
    – 获取数据")，“时间暂停 – 获取数据”中来的；我们正在重写`in`运算符以处理数据库中的空值。
- en: 'Go back to the script and add the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 返回脚本并添加以下代码：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Sending this to the REPL, we get:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，我们得到：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Even though we haven''t seen this exact code before, we have seen code that
    is pretty close. In this block, we are creating a computational expression. We
    are joining together the `SalesOrderHeader`, `SalesOrderDetail`, `Products`, and
    `Customer` tables so we can select only the records we are interested in for this
    analysis. This would be: all bike sales to individual customers after May 1, 2013\.
    Notice that we are returning two integers as a tuple: the `SalesOrderId` and the
    `CustomerId`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们之前没有见过这段代码，但我们见过与之非常相似的代码。在这个块中，我们正在创建一个计算表达式。我们将`SalesOrderHeader`、`SalesOrderDetail`、`Products`和`Customer`表连接起来，以便我们只选择对这次分析感兴趣的记录。这将是：2013年5月1日之后所有针对个人客户的自行车销售。请注意，我们正在以元组的形式返回两个整数：`SalesOrderId`和`CustomerId`。
- en: 'Go back to the script and add the following code block:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 返回脚本并添加以下代码块：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Sending this to the FSI gives us the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到FSI，我们得到以下结果：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can probably tell, this creates an array of unique `CustomerIds`. Since
    a customer might have bought two bikes, they might have two `SalesOrderIds` so
    we need to call the `distinctBy` high-ordered function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，这创建了一个唯一的`CustomerIds`数组。由于一个客户可能购买了两辆自行车，他们可能有两个`SalesOrderIds`，因此我们需要调用`distinctBy`高阶函数。
- en: 'Go back to the script and enter this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 返回脚本并输入以下内容：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Send this to the FSI to get this (it takes a couple of seconds):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到FSI以获取以下结果（这可能需要几秒钟）：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a similar query to the first one. Here we are joining together the same
    four tables and then selecting both the `SalesOrderId` and the `SalesOrderDetailId`
    for the customers we have already identified. We then apply the `countBy` high-order
    function to count up all of the details for each order. If there is only one `OrderDetailId`,
    then only the bike was purchased. If there is more than one, then the customer
    purchased items along with the bike.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个与第一个类似的查询。这里我们将相同的四个表连接起来，然后选择我们已识别的客户的`SalesOrderId`和`SalesOrderDetailId`。然后我们应用`countBy`高阶函数来计算每个订单的所有细节。如果只有一个`OrderDetailId`，那么只购买了自行车。如果有多个，那么客户还购买了其他物品。
- en: 'We now have to pull individual details for a given customer. Since the database
    is in third normal form, these details are scattered across many tables. Instead
    of generating a pretty nasty expression, let''s use the built-in view that has
    already been created in the database: `vIndividualCustomer`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须获取特定客户的详细信息。由于数据库处于第三范式，这些细节散布在许多表中。我们不如使用数据库中已经创建的内置视图：`vIndividualCustomer`。
- en: The catch is that the EF type provider cannot handle views at the time of this
    writing. The answer to this problem is another type provider.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题是，EF类型提供程序在撰写本文时无法处理视图。这个问题的答案是另一个类型提供程序。
- en: 'Go to the script and enter this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到脚本并输入以下内容：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Sending this to the REPL, you can see the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，你可以看到以下结果：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Each record is a beast! It looks like the database has a field called `IndividualSurvey`
    that contains data about some of the customers that was collected on a survey.
    Interestingly, they decide to store it as XML. I think this proves the axiom that
    if given a datatype, developers will use it, whether it make sense or not. In
    any event, how are we going to parse this XML? I''ll give you a hint: it rhymes
    with *hype divider*. That''s right, the XML type provider. Go back to the script
    and add this code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每条记录都是一个怪物！看起来数据库有一个名为`IndividualSurvey`的字段，其中包含一些客户在调查中收集的数据。有趣的是，他们决定将其存储为XML。我认为这证明了这样一个公理：如果给定了数据类型，开发者会使用它，无论它是否有意义。无论如何，我们如何解析这个XML？我会给你一个提示：它与*hype
    divider*押韵。没错，就是XML类型提供程序。返回到脚本并添加以下代码：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Sending this to the REPL gives us the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，我们得到以下结果：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The XML type provider takes a representative sample to generate the types. In
    this case, `sampleXML` is being used to generate the types. With this type provider
    handling the heavy lifting of parsing the XML for us, we can now create a data
    structure for each `CustomerId` and their demographic information in an easy-to-use
    format.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: XML类型提供程序使用一个代表性样本来生成类型。在这种情况下，`sampleXML`被用来生成类型。有了这个类型提供程序为我们处理解析XML的重活，我们现在可以为每个`CustomerId`及其人口统计信息创建一个易于使用的格式的数据结构。
- en: 'Go back to the script and enter this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到脚本并输入以下内容：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Sending this to the FSI gives us the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到FSI，我们得到以下结果：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There is not much new code here. Since we have to take into account customers
    that do not have demographic information recorded, we are using `Option` types.
    If there is demographic information, a `Some` is returned with the values. If
    not, a `None` is returned. We then filter that to only give us the customers with
    demographic records and distinct is called to make sure that we have only one
    record per customer.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多新的代码。由于我们必须考虑那些没有记录人口统计信息的客户，我们正在使用`Option`类型。如果有人口统计信息，则返回一个包含值的`Some`。如果没有，则返回`None`。然后我们过滤这些信息，只给我们带有人口记录的客户，并调用`distinct`以确保每个客户只有一个记录。
- en: 'With the customer demographic ready, we can now build a final data frame that
    contains all of the information we need. Go back to the script file and enter
    this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户人口统计信息准备就绪后，我们现在可以构建一个包含我们所需所有信息的最终数据框。返回到脚本文件并输入以下内容：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Sending this to the FSI, you can see the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到FSI，你可以看到以下结果：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We now have a tuple with three elements: `OrderId`, `CustomerId`, and the demographic
    information. Note that the output still shows the demographic information as XML
    though we will be able to see in a second that indeed, those elements are part
    of the demographic type.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个包含三个元素的元组：`OrderId`、`CustomerId`以及人口统计信息。请注意，输出仍然显示人口统计信息为XML，尽管我们将在下一秒看到，这些元素实际上是人口类型的一部分。
- en: 'Go into the script file and enter this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 进入脚本文件并输入以下内容：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Sending this to the REPL gives us the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，我们得到以下结果：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`getMultiOrderIndForOrderId` is a function that takes in the `orderId` and
    finds the record in the `orderDetailsCounts` frame. If there is more than one,
    it returns `true`. If there is only one order (just the bike), it returns `false`.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`getMultiOrderIndForOrderId` 是一个函数，它接受 `orderId` 并在 `orderDetailsCounts` 数据帧中查找记录。如果有多个，则返回
    `true`。如果只有一个订单（只有自行车），则返回 `false`。'
- en: 'With that function, we can create a tuple that has `orderId`, `multiOrderind`,
    and the demographics. I think we are ready to start doing some modeling! Before
    we start, we need to ask ourselves one question: what values do we want to use?
    The *y* variable is clear—the `multiOrderInd`. But which one of the demographic
    values do we want to plug into our model as *x* variables? Since we want to change
    our website to account for the model results, we probably need variables that
    are usable on the site. Some features like `BirthDate` are available if the person
    logs into our site via their Facebook or Google accounts, those accounts have
    that information accurately populated and the user agrees to let our site access
    that information. Those are big *ifs*. Alternatively, we might be able to use
    the inferred analytics via the cookies that advertisers place on the user''s device,
    but that is also an imprecise measure, depending on the feature used. It is better
    to design our model assuming that any information that will be input to the model
    will be accurately self-reported, and let''s give the user an incentive to accurately
    self-report. This means education, yearly income, and other sensitive measures
    are out. Let''s look at the gender and marital status, which we should be able
    to get from the user, if asked correctly. So our model will be *MultiOrder = Gender
    + MartialStatus + E*.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，我们可以创建一个包含 `orderId`、`multiOrderind` 和人口统计信息的元组。我认为我们准备好开始建模了！在我们开始之前，我们需要问自己一个问题：我们想使用哪些值？`y`
    变量很明确——`multiOrderInd`。但我们在模型中作为 `x` 变量插入哪个人口统计值呢？由于我们想要根据模型结果调整我们的网站，我们可能需要可以在网站上使用的变量。如果用户通过Facebook或Google账户登录我们的网站，那么这些账户将准确填写相关信息，并且用户同意我们的网站访问这些信息，那么这些特征（如
    `BirthDate`）是可用的。这些都是很大的 `ifs`。或者，我们可能能够使用广告商放置在用户设备上的cookie进行推断分析，但这也是一个依赖于所使用特征的粗略度量。最好假设将输入到模型中的任何信息都将被准确自我报告，并让用户有动力准确自我报告。这意味着教育、年收入和其他敏感措施都不适用。让我们看看性别和婚姻状况，如果我们正确询问，我们应该能够从用户那里得到这些信息。因此，我们的模型将是
    `MultiOrder = Gender + MartialStatus + E`。
- en: 'Go to the script and enter this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到脚本并输入以下内容：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Sending this to the REPL, we see the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，我们看到以下结果：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Since Accord deals with input `float` values and output `int` values, we need
    a function to convert the features of our attributes (current as strings) to those
    types. If you want to make sure we have all of the cases covered, you can also
    send this to the FSI:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Accord处理输入 `float` 值和输出 `int` 值，我们需要一个函数将我们的属性特征（目前是字符串）转换为这些类型。如果你想确保我们涵盖了所有情况，你也可以将此发送到FSI：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There is one danger with how the `getValues` function is written. If you remember
    from the previous chapter, dealing with missing values is an ongoing concern when
    doing any kind of modeling. The functions deal with the null issue by running
    away from it. Consider the `getValuesForGender` function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`getValues` 函数的编写方式有一个风险。如果你还记得上一章，处理缺失值在进行任何类型的建模时都是一个持续关注的问题。这些函数通过避开这个问题来处理null问题。考虑
    `getValuesForGender` 函数：'
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If a gender code comes in as `UNK`, `YOMAMA`, null, or any other string, it
    gets assigned the female code. This means we would be over reporting the number
    of females in our model. We can get away with that with this dataset because every
    record had values `M` or `F`, but if they did not, we would need a way to handle
    the incorrect values. In this case, I would create some code like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果性别代码为 `UNK`、`YOMAMA`、null 或任何其他字符串，它将被分配为女性代码。这意味着我们可能会高报模型中女性的数量。由于这个数据集中每个记录都有
    `M` 或 `F` 的值，我们可以这样处理，但如果它们没有，我们就需要一种处理错误值的方法。在这种情况下，我会创建一些像这样的代码：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This would balance the inferred values equally across males and females. In
    any event, let's get to modeling.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在男性和女性之间平衡推断值。无论如何，让我们开始建模。
- en: k-NN and AdventureWorks data
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: k-NN 和 AdventureWorks 数据
- en: 'Go back to the script and enter this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到脚本并输入以下内容：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Sending this to the REPL gives us the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，我们得到以下结果：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now that we have our model set up, let''s pass in the four possible scenarios.
    Go to the script and enter this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了模型，让我们传递四个可能的场景。转到脚本并输入以下内容：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Sending this to the FSI give us the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到FSI，我们得到以下内容：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So it looks like single women are NOT buying multiple items.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所以看起来单身女性并没有购买多个商品。
- en: Naïve Bayes and AdventureWorks data
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 朴素贝叶斯和AdventureWorks数据
- en: 'Go back to the script and enter this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 返回脚本并输入以下内容：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Sending that to the FSI gives us the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到FSI，我们得到以下内容：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'So we have a Naïve Bayes with a 15 percent error. Not great, but let''s press
    on. Enter in the same four options for `gender`/`martialStatus` in the script
    file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个15%错误的朴素贝叶斯模型。不太好，但让我们继续前进。在脚本文件中输入相同的四个选项用于`gender`/`martialStatus`：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When you send it to the REPL, you will get the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将其发送到REPL时，你会得到以下内容：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Rut Row Raggy. Looks like we have a problem. In fact, we do. If you remember
    the previous description of using the Naïve Bayes model, it needs to have the
    values distributed along a bell curve to be effective. 90 percent of the bike
    purchases have a cross-sale—which means we are heavily skewed. No matter what
    kind of tweaks you do to the model, you can't get around the fact that you are
    multiplying by 0.9 to Yes for `multiPurchase`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Rut Row Raggy。看起来我们遇到了问题。事实上，我们确实遇到了。如果你还记得之前关于使用朴素贝叶斯模型的描述，它需要值沿着钟形曲线分布才能有效。90%的自行车购买有交叉销售——这意味着我们严重倾斜。无论你对模型进行何种调整，都无法改变你将`multiPurchase`的值乘以0.9的事实。
- en: Making use of our discoveries
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用我们的发现
- en: What should we do? We have a k-NN telling us that single women are not buying
    additional items and we have Naïve Bayes being no help at all. We could do some
    more classification models, but let's assume we feel good enough about our analysis
    and want to go to production with this model. How should we do that? A key issue
    to consider is that the model is based on some static data in one of our database
    tables that is not updated via the normal transactions of the company. This means
    we really don't need to retrain the model frequently. Another problem we have
    is that we need to figure out the gender and marital status of the people ordering
    our bikes. Perhaps we are asking the wrong question. Instead of asking how to
    get the gender and marital status of the user, what if we already knew it? You
    may be thinking that we don't know because we haven't asked yet. But we might—based
    on the bike selected for purchase!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该怎么做？我们有k-NN告诉我们单身女性不会购买额外商品，而朴素贝叶斯则完全无助于我们。我们可以尝试更多的分类模型，但让我们假设我们对分析感到足够满意，并希望使用这个模型投入生产。我们应该怎么做？一个需要考虑的关键问题是，模型基于我们数据库表中的一些静态数据，这些数据不是通过公司的正常交易进行更新的。这意味着我们实际上不需要频繁地重新训练模型。我们遇到的另一个问题是，我们需要确定订购我们自行车的客户的性别和婚姻状况。也许我们提出的问题是错误的。不是询问如何获取用户的性别和婚姻状况，如果我们已经知道了会怎样？你可能认为我们不知道，因为我们还没有询问。但我们可以——基于用户选择的自行车！
- en: Getting the data ready
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备数据
- en: 'Go back into the script and enter this code block:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 返回脚本并输入以下代码块：
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Sending this to the REPL, we see the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，我们看到以下内容：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Hopefully, this code should look pretty boring to you by now. It is creating
    a tuple of `customerId` and `ProductId` from all of the bike sales.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在这段代码对你来说已经显得相当无聊了。它正在从所有自行车销售中创建一个由`customerId`和`ProductId`组成的元组。
- en: 'Go back to the script and enter this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 返回脚本并输入以下内容：
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Sending this to the REPL, we can see the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，我们可以看到以下内容：
- en: '[PRE49]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This code block is shaping our data for Accord by creating a frame of tuples
    of `customerId`, `productId`, and `singleFemaleInd`. We are almost ready to throw
    this data at a model, but we still need to determine which model we want to use.
    We are trying to determine the probability of a customer being a single female
    based on the bike purchased. This seems like a question that is well-suited for
    a logistic regression ([Chapter 3](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 3. More AdventureWorks Regression"), *More AdventureWorks Regression*).
    The issue is that each bike needs to become a feature in this regression:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码块正在为Accord调整我们的数据，创建一个由`customerId`、`productId`和`singleFemaleInd`组成的元组框架。我们几乎准备好将此数据投向模型，但我们仍然需要确定我们想要使用哪个模型。我们试图确定客户购买自行车的概率，以确定客户是否为单身女性。这似乎是一个非常适合逻辑回归的问题（[第3章](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "第3章。更多AdventureWorks回归")，*更多AdventureWorks回归*）。问题是，每辆自行车都需要成为这个回归中的一个特征：
- en: '*singleFemale = BikeId0 + BikeId1 + BikeId2 + BikeIdN + E*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*singleFemale = BikeId0 + BikeId1 + BikeId2 + BikeIdN + E*'
- en: 'If you throw this code into your script and send it to the FSI, you will see
    we have 80 different bike IDs:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此代码放入脚本中并发送到 FSI，你会看到我们有 80 个不同的自行车 ID：
- en: '[PRE50]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: So how do we create an input of 80 features from the original frame? Certainly
    not by hand. Let's see if Accord can help us.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何从原始数据框中创建 80 个特征作为输入呢？当然不是手动创建。让我们看看 Accord 是否能帮我们。
- en: Expanding features
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展特征
- en: 'Open up the script you were using from the previous section and enter this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 打开上一节中使用的脚本，并输入以下内容：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Sending this to the REPL, we see the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到 REPL，我们看到以下内容：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'What we are doing is taking the `customerDemo` frame and selecting the `productId`.
    We are then sending that array to Accord''s `Tools.Expand` method that explodes
    the array so that each value becomes its own feature. Graphically, it looks like
    this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是从 `customerDemo` 数据框中选择 `productId`。然后我们将该数组发送到 Accord 的 `Tools.Expand`
    方法，该方法将数组展开，使每个值都成为其自身的特征。从图形上看，它看起来像这样：
- en: '![Expanding features](img/00084.jpeg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![扩展特征](img/00084.jpeg)'
- en: 'As you can guess after reading [Chapter 5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "Chapter 5. Time Out – Obtaining Data"), *Time Out – Obtaining Data*, this is
    considered a sparse data frame. With the input and output ready, go back to the
    script file and enter this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在阅读[第 5 章](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "第 5 章。休息时间 – 获取数据")后所猜想的，“休息时间 – 获取数据”，这被认为是一个稀疏数据框。输入和输出准备就绪后，回到脚本文件并输入以下内容：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Before you send this to the REPL, let me warn you. The reason we identify a
    sparse frame is that computing a regression on 80 features takes a while. So hit
    *ALT* + *ENTER* and go get a cup of coffee. From Starbucks. Across town. Eventually,
    you will get this back:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将此发送到 REPL 之前，让我提醒你。我们之所以识别出稀疏数据框，是因为在 80 个特征上进行回归计算需要一段时间。所以按 *ALT* + *ENTER*
    并去喝杯咖啡。从星巴克。在镇上。最终，你会得到这个：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'And when we filter at the coefficient table, we can see that there is one bike
    model that is favored by single women. Add this to your script file and send to
    the FSI:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在系数表中过滤时，我们可以看到有一个自行车模型受到单身女性的青睐。将此添加到您的脚本文件中，并发送到 FSI：
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: So perhaps when a person purchases item number `765`, we try to give them an
    incentive to buy other products, either via a coupon or a really slick website
    experience. This is where an excellent UX person with a knowledgeable marketing
    person can pay dividends. Since I am neither, I will leave that exercise to the
    reader.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，也许当一个人购买编号为 `765` 的商品时，我们试图通过优惠券或一个非常酷的网站体验来激励他们购买其他产品。这正是优秀用户体验人员和知识渊博的市场人员可以发挥作用的领域。由于我既不是用户体验人员也不是市场人员，我将把这个练习留给读者。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we took a look at two common machine learning classifiers:
    k-Nearest Neighbors and Naïve Bayes. We saw them both in action with our AdventureWorks
    dataset to see if we can increase cross sales. We saw that k-NN had some limited
    success and Naïve Bayes was not useful. We then used our old friend logistic regression
    to help us narrow down a specific bike model that can be used to promote cross
    sales. Finally, we considered that since the data is ad hoc, we can''t implement
    any real-time training on our website. We would want to periodically run this
    analysis to see if our original findings continued to hold.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了两种常见的机器学习分类器：k-最近邻和朴素贝叶斯。我们使用 AdventureWorks 数据集对它们进行了实际操作，以查看我们是否可以增加交叉销售。我们发现
    k-NN 有一些有限的成功，而朴素贝叶斯则没有用。然后我们使用我们老朋友逻辑回归来帮助我们缩小可以用于促进交叉销售的特定自行车模型。最后，我们考虑到数据是临时的，我们无法在我们的网站上实施任何实时训练。我们希望定期运行此分析，以查看我们的原始发现是否仍然成立。
- en: 'In the next chapter, we are going to take off our software engineer hat and
    put on our data scientist hat to see if we can do anything with that traffic stop
    data. We are going to look at augmenting the original dataset with another dataset
    and then using a couple of clustering models: k-means and PCA. See you on the
    next page!'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将摘下软件工程师的帽子，戴上数据科学家的帽子，看看我们是否可以对那些交通拦截数据做些什么。我们将考虑使用另一个数据集来增强原始数据集，然后使用几个聚类模型：k-均值和
    PCA。下一页见！
