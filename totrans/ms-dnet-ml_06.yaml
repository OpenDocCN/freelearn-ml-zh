- en: Chapter 6. AdventureWorks Redux – k-NN and Naïve Bayes Classifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's jump back to AdventureWorks and put our software engineer hat back on.
    A couple weeks after your successful implementation of a model to improve high-margin
    bike sales to individual customers, the CEO comes to your desk and says, "Can
    you help us with a problem? If you were not aware, we started out as a bike-only
    company. Then, in May of 2013, we added additional merchandise to our product
    offering. Although it went well in the beginning, we seem to have plateaued. We
    want to try to push a bit harder in this area. Through some basic PowerBI reporting,
    we see that anywhere from 86 percent to 88 percent of the customers who buy a
    bike also buy additional merchandise at the time of purchase."
  prefs: []
  type: TYPE_NORMAL
- en: '| Year Month | Cross | Solo | Total | %Cross |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **201305** | 25 | 295 | 320 | 7.8% |'
  prefs: []
  type: TYPE_TB
- en: '| **201306** | 429 | 69 | 498 | 86.1% |'
  prefs: []
  type: TYPE_TB
- en: '| **201307** | 441 | 56 | 497 | 88.7% |'
  prefs: []
  type: TYPE_TB
- en: '| **201308** | 525 | 83 | 608 | 86.3% |'
  prefs: []
  type: TYPE_TB
- en: '| **201309** | 536 | 68 | 604 | 88.7% |'
  prefs: []
  type: TYPE_TB
- en: '| **201310** | 649 | 100 | 749 | 86.6% |'
  prefs: []
  type: TYPE_TB
- en: '| **201311** | 868 | 136 | 1,004 | 86.5% |'
  prefs: []
  type: TYPE_TB
- en: '| **201312** | 698 | 99 | 797 | 87.6% |'
  prefs: []
  type: TYPE_TB
- en: '| **201401** | 800 | 97 | 897 | 89.2% |'
  prefs: []
  type: TYPE_TB
- en: '| **201402** | 702 | 96 | 798 | 88.0% |'
  prefs: []
  type: TYPE_TB
- en: '| **201403** | 891 | 135 | 1,026 | 86.8% |'
  prefs: []
  type: TYPE_TB
- en: '| **201404** | 965 | 121 | 1,086 | 88.9% |'
  prefs: []
  type: TYPE_TB
- en: '| **201405** | 1,034 | 152 | 1,186 | 87.2% |'
  prefs: []
  type: TYPE_TB
- en: '| **TOTAL** | 8,563 | 1,507 | 10,070 | 85.0% |'
  prefs: []
  type: TYPE_TB
- en: '![AdventureWorks Redux – k-NN and Naïve Bayes Classifiers](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The CEO continues, "We would love to be able to get that up above 90 percent.
    We launched an expensive marketing campaign, but it really didn't move the needle.
    Is there any way you can help us be more focused and identify those people on
    the fence for cross-selling opportunities?"
  prefs: []
  type: TYPE_NORMAL
- en: You say, "Sure," and immediately start thinking of a way to implement her instructions.
    Perhaps if you could identify some unique characteristics of those customers who
    buy additional merchandise compared to those customers who do not, a more targeted
    method might be implemented to get more people to buy additional merchandise.
    You immediately think of classification models like **K-Nearest Neighbor** (**k-NN**)
    and **Naïve Bayes**. Since you are not sure which one might work, you decide to
    try them both out.
  prefs: []
  type: TYPE_NORMAL
- en: k-Nearest Neighbors (k-NN)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'k-NN stands for k-Nearest Neighbors and is one of the most basic classification
    models available. Since a picture is worth a thousand words, let''s take a look
    at k-NN from a graphical perspective. Consider a group of students who spent some
    amount of time studying and also drinking beers the night before the exam. On
    a graph, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![k-Nearest Neighbors (k-NN)](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If I added a seventh student to the graph like this, would you think that the
    student passed or failed the exam?
  prefs: []
  type: TYPE_NORMAL
- en: '![k-Nearest Neighbors (k-NN)](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You would likely say they are a star—they passed the exam. If I asked you why,
    you would probably say that are more like the other stars. This kind of mental
    processing is very much how our minds work—if everyone in your neighborhood buys
    a Japanese car and thinks it has high quality, you are more likely to buy one
    too if you are looking for a high quality car. In fact, much of marketing is based
    on the k-NN theory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the brain, which makes associations effortlessly, k-NN actually uses
    some math to classify. Going back to our seventh student, k-NN would put them
    in the passing students'' group because the distance it is from the other passing
    students is short relative to the distance from the failing students:'
  prefs: []
  type: TYPE_NORMAL
- en: '![k-Nearest Neighbors (k-NN)](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In fact, one of the simplest k-NN implementations is to take the average of
    all of the items of the category (five hours of studies and drinking one beer
    for the stars, on average) and measure that distance to the new item. Hopefully,
    the name k-NN makes sense now—for a given new item K, what are its nearest neighbors?
  prefs: []
  type: TYPE_NORMAL
- en: k-NN example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at k-NN in action using **Accord.NET**. Open up Visual Studio
    and create a new Visual F# Windows Library project called `Classification`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![k-NN example](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go into the `Script.fsx` file and remove all of its contents. Rename `Scipt.fsx`
    to `k-NNAccord.fsx`. Open up **NuGet Package Manager** console and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to your script and enter in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Send this to the REPL to see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this code should look familiar to you by now. The inputs represent
    six students with two characteristics: how many hours they spent studying the
    night before an exam and how much beer they drank. The outputs represent whether
    they passed the exam: `1` if they passed, `0` if they did not. The class''s value
    tells Accord that there are two types of values to consider. In this case, those
    values are the hours spent in studying and the quantity of beer consumed. The
    `k` value tells Accord how many data points we want to use for the calculation
    for each class. If we changed that to `4`, then we would have included one failing
    student with the three passing students (and vice versa), which would have watered
    down our result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the script and enter these lines that represent the seventh student:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When you send it to the FSI, you will see that student number `7` will most
    likely pass the exam:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As I mentioned earlier, k-NN is one of the most basic machine learning models
    you can use, but in certain circumstances it can be surprisingly powerful. One
    of the more common adjustments to k-NN is weighing the distance from the neighbors.
    The closer a point is to the neighbors, the more weight that distance gets. The
    biggest criticism of k-NN is that it can overweigh if there are many observations
    that center around one point, so it is important to have a balanced dataset, if
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Naïve Bayes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Naïve Bayes is a classification model that attempts to predict if an entity
    belongs to a series of predefined sets. When you aggregate all the sets together,
    you have a pretty good estimation of the final result. In order to illustrate,
    let's go back to the tennis example that we used when talking about decision trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the following observations for two weeks:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Day | Outlook | Temperature | Humidity | Wind | PlayTennis? |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | sunny | Hot | High | weak | No |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | sunny | Hot | High | strong | No |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | overcast | Hot | High | weak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | rain | Mild | High | weak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | rain | Cool | Normal | weak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | rain | Cool | Normal | strong | No |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | overcast | Cool | Normal | strong | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | sunny | Mild | High | weak | No |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | sunny | Cool | Normal | weak | yes |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | rain | Mild | Normal | weak | yes |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | sunny | Mild | Normal | strong | yes |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | overcast | Mild | High | strong | yes |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | overcast | Hot | Normal | weak | yes |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | rain | Mild | High | strong | no |'
  prefs: []
  type: TYPE_TB
- en: 'For each one of the classes, let''s break down whether they wound up playing
    tennis that day and then do a percentage for each possibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ID | Outlook | Yes | No | % Yes | % No |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | sunny | 2 | 3 | 0.22 | 0.60 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | overcast | 4 | 0 | 0.44 | 0.00 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | rain | 3 | 2 | 0.33 | 0.40 |'
  prefs: []
  type: TYPE_TB
- en: '|   | **Total** | 9 | 5 | 1.00 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **ID** | **Temperature** | **Yes** | **No** | **% Yes** | **% No** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | hot | 2 | 2 | 0.22 | 0.40 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | mild | 4 | 2 | 0.44 | 0.40 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | cool | 3 | 1 | 0.33 | 0.20 |'
  prefs: []
  type: TYPE_TB
- en: '|   | **Total** | 9 | 5 | 1.00 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **ID** | **Humidity** | **Yes** | **No** | **% Yes** | **% No** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | high | 3 | 4 | 0.33 | 0.80 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | normal | 6 | 1 | 0.67 | 0.20 |'
  prefs: []
  type: TYPE_TB
- en: '|   | **Total** | 9 | 5 | 1.00 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **ID** | **Wind** | **Yes** | **No** | **% Yes** | **% No** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | weak | 6 | 2 | 0.67 | 0.40 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | strong | 3 | 3 | 0.33 | 0.60 |'
  prefs: []
  type: TYPE_TB
- en: '|   | **Total** | 9 | 5 | 1.00 | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **ID** | **Final** | **Yes** | **No** | **% Yes** | **% No** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Play | 9 | 5 | 0.64 | 0.36 |'
  prefs: []
  type: TYPE_TB
- en: 'With these grids available, we can then predict if a person will or will not
    play tennis for a series of conditions. For example, will a person play on a sunny,
    cool day with high humidity and strong winds? We can pull the percentages from
    each grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   |   | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Outlook** | sunny | 0.222 | 0.600 |'
  prefs: []
  type: TYPE_TB
- en: '| **Temperature** | cool | 0.333 | 0.200 |'
  prefs: []
  type: TYPE_TB
- en: '| **Humidity** | high | 0.333 | 0.800 |'
  prefs: []
  type: TYPE_TB
- en: '| **Wind** | strong | 0.333 | 0.600 |'
  prefs: []
  type: TYPE_TB
- en: '|   | **final** | 0.643 | 0.357 |'
  prefs: []
  type: TYPE_TB
- en: 'And then the values can be multiplied together for each possibility:'
  prefs: []
  type: TYPE_NORMAL
- en: Probability of Yes = 0.222 * 0.333 * 0.333 * 0.333 * 0.643 = 0.005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Probability of No = 0.600 * 0.200 * 0.800 * 0.600 * 0.357 = 0.021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see that there is a higher percentage not playing than playing. We
    can also take the two percentages and compare them to each other like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*0.005 + 0.021 = 0.026*'
  prefs: []
  type: TYPE_NORMAL
- en: '*0.005/0.026 = 0.205 and 0.021/0.026 = 0.795*'
  prefs: []
  type: TYPE_NORMAL
- en: There is about a 20 percent chance of playing tennis and 80 percent chance of
    not playing.
  prefs: []
  type: TYPE_NORMAL
- en: Naïve Bayes in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how Accord.NET calculates a Naïve Bayes model. Go to Visual Studio
    and add a new script file called `NaiveBayesAccord.fsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In that script, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When you send them to the FSI, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The inputs are the values turned into integers. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Outlook | ID |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Sunny | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Overcast | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Rain | 2 |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **Temperature** | **ID** |'
  prefs: []
  type: TYPE_TB
- en: '| Hot | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Mild | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Cool | 2 |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **Humidity** | **ID** |'
  prefs: []
  type: TYPE_TB
- en: '| High | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Normal | 1 |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **Wind** | **ID** |'
  prefs: []
  type: TYPE_TB
- en: '| Weak | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Strong | 1 |'
  prefs: []
  type: TYPE_TB
- en: The position in each array is *[outlook;temperature;humidity;wind]*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outputs are the result values turned into integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Play | ID |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| No | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Yes | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'The symbols value is an array that tells Accord the total number of possible
    values for each feature. For example, the first position is for outlook and there
    are three possible values: (0, 1, 2).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the script and add in the Naïve Bayes calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending to the REPL gives the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The error is calculated by Accord re-running its estimate several times and
    comparing the actual to the expected. A good way of interpreting the error is
    that the lower the number is better, and the domain dictates if the actual number
    is "good enough". For example, a 14 percent error is great for social experiments,
    where humans are capable for random and unpredictable behaviors. Conversely, a
    14 percent error rate for predicting airplane engine failure would not be considered
    acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s see a prediction for sunny outlook, mild temperature, normal
    humidity, and weak wind. Go to the script and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending to the REPL gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So we will be playing tennis on that day.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind while using Naïve Bayes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Created in the 1950s, Naïve Bayes is a highly effective classification model
    that has stood the test of time. In fact, many spam filters today still use, in
    part, Naïve Bayes. The biggest advantages of using Naïve Bayes are its simplicity
    and its ability to, well, be right. The biggest downside is the key assumption
    that every *x* variable is completely and utterly independent. If there is any
    chance that the *x* variables are collinear, Naïve Bayes breaks down. Also, Naïve
    Bayes, historically, has been applied to datasets that are Gaussian—that it follows
    a bell curve. If you are not familiar with a bell curve, it is a distribution
    of data where the most observations occur in the middle values with the outliers
    to both sides of the middle having roughly the same number of observations. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![One thing to keep in mind while using Naïve Bayes](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In contrast, a skewed distribution has the most observations at one end or
    the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![One thing to keep in mind while using Naïve Bayes](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When you use Naïve Bayes, you will have to make sure the distribution you select
    matches your data. Let's now see if k-NN and/or Naïve Bayes can help us with AdventureWorks.
  prefs: []
  type: TYPE_NORMAL
- en: AdventureWorks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to take the knowledge that we gained in [Chapter
    5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055 "Chapter 5. Time
    Out – Obtaining Data"), *Time Out – Obtaining Data*, to extract and transform
    data and apply both k-NN and Naïve Bayes machine learning models. Let's see if
    none, one, or both methodologies will help us increase cross-sales.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the data ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go into Visual Studio and add another script called `AdventureWorks.fsx`. Open
    up the script, remove all of the contents, and open **NuGet Package Manager**
    console. In the package manager, run the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to the script file and add the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you remember from [Chapter 5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "Chapter 5. Time Out – Obtaining Data"), *Time Out – Obtaining Data*, this is
    creating our type provider to pull data from the database. Send everything so
    far to the REPL to see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to the script and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the FSI gives the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is also from [Chapter 5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "Chapter 5. Time Out – Obtaining Data"), *Time Out – Obtaining Data*; we are overriding
    the `in` operator to handle null values in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the script and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though we haven''t seen this exact code before, we have seen code that
    is pretty close. In this block, we are creating a computational expression. We
    are joining together the `SalesOrderHeader`, `SalesOrderDetail`, `Products`, and
    `Customer` tables so we can select only the records we are interested in for this
    analysis. This would be: all bike sales to individual customers after May 1, 2013\.
    Notice that we are returning two integers as a tuple: the `SalesOrderId` and the
    `CustomerId`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the script and add the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the FSI gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can probably tell, this creates an array of unique `CustomerIds`. Since
    a customer might have bought two bikes, they might have two `SalesOrderIds` so
    we need to call the `distinctBy` high-ordered function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the script and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Send this to the FSI to get this (it takes a couple of seconds):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is a similar query to the first one. Here we are joining together the same
    four tables and then selecting both the `SalesOrderId` and the `SalesOrderDetailId`
    for the customers we have already identified. We then apply the `countBy` high-order
    function to count up all of the details for each order. If there is only one `OrderDetailId`,
    then only the bike was purchased. If there is more than one, then the customer
    purchased items along with the bike.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have to pull individual details for a given customer. Since the database
    is in third normal form, these details are scattered across many tables. Instead
    of generating a pretty nasty expression, let''s use the built-in view that has
    already been created in the database: `vIndividualCustomer`.'
  prefs: []
  type: TYPE_NORMAL
- en: The catch is that the EF type provider cannot handle views at the time of this
    writing. The answer to this problem is another type provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the script and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL, you can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Each record is a beast! It looks like the database has a field called `IndividualSurvey`
    that contains data about some of the customers that was collected on a survey.
    Interestingly, they decide to store it as XML. I think this proves the axiom that
    if given a datatype, developers will use it, whether it make sense or not. In
    any event, how are we going to parse this XML? I''ll give you a hint: it rhymes
    with *hype divider*. That''s right, the XML type provider. Go back to the script
    and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The XML type provider takes a representative sample to generate the types. In
    this case, `sampleXML` is being used to generate the types. With this type provider
    handling the heavy lifting of parsing the XML for us, we can now create a data
    structure for each `CustomerId` and their demographic information in an easy-to-use
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the script and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the FSI gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There is not much new code here. Since we have to take into account customers
    that do not have demographic information recorded, we are using `Option` types.
    If there is demographic information, a `Some` is returned with the values. If
    not, a `None` is returned. We then filter that to only give us the customers with
    demographic records and distinct is called to make sure that we have only one
    record per customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the customer demographic ready, we can now build a final data frame that
    contains all of the information we need. Go back to the script file and enter
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the FSI, you can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a tuple with three elements: `OrderId`, `CustomerId`, and the demographic
    information. Note that the output still shows the demographic information as XML
    though we will be able to see in a second that indeed, those elements are part
    of the demographic type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go into the script file and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`getMultiOrderIndForOrderId` is a function that takes in the `orderId` and
    finds the record in the `orderDetailsCounts` frame. If there is more than one,
    it returns `true`. If there is only one order (just the bike), it returns `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that function, we can create a tuple that has `orderId`, `multiOrderind`,
    and the demographics. I think we are ready to start doing some modeling! Before
    we start, we need to ask ourselves one question: what values do we want to use?
    The *y* variable is clear—the `multiOrderInd`. But which one of the demographic
    values do we want to plug into our model as *x* variables? Since we want to change
    our website to account for the model results, we probably need variables that
    are usable on the site. Some features like `BirthDate` are available if the person
    logs into our site via their Facebook or Google accounts, those accounts have
    that information accurately populated and the user agrees to let our site access
    that information. Those are big *ifs*. Alternatively, we might be able to use
    the inferred analytics via the cookies that advertisers place on the user''s device,
    but that is also an imprecise measure, depending on the feature used. It is better
    to design our model assuming that any information that will be input to the model
    will be accurately self-reported, and let''s give the user an incentive to accurately
    self-report. This means education, yearly income, and other sensitive measures
    are out. Let''s look at the gender and marital status, which we should be able
    to get from the user, if asked correctly. So our model will be *MultiOrder = Gender
    + MartialStatus + E*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the script and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Accord deals with input `float` values and output `int` values, we need
    a function to convert the features of our attributes (current as strings) to those
    types. If you want to make sure we have all of the cases covered, you can also
    send this to the FSI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one danger with how the `getValues` function is written. If you remember
    from the previous chapter, dealing with missing values is an ongoing concern when
    doing any kind of modeling. The functions deal with the null issue by running
    away from it. Consider the `getValuesForGender` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If a gender code comes in as `UNK`, `YOMAMA`, null, or any other string, it
    gets assigned the female code. This means we would be over reporting the number
    of females in our model. We can get away with that with this dataset because every
    record had values `M` or `F`, but if they did not, we would need a way to handle
    the incorrect values. In this case, I would create some code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This would balance the inferred values equally across males and females. In
    any event, let's get to modeling.
  prefs: []
  type: TYPE_NORMAL
- en: k-NN and AdventureWorks data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go back to the script and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our model set up, let''s pass in the four possible scenarios.
    Go to the script and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the FSI give us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So it looks like single women are NOT buying multiple items.
  prefs: []
  type: TYPE_NORMAL
- en: Naïve Bayes and AdventureWorks data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go back to the script and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending that to the FSI gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'So we have a Naïve Bayes with a 15 percent error. Not great, but let''s press
    on. Enter in the same four options for `gender`/`martialStatus` in the script
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When you send it to the REPL, you will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Rut Row Raggy. Looks like we have a problem. In fact, we do. If you remember
    the previous description of using the Naïve Bayes model, it needs to have the
    values distributed along a bell curve to be effective. 90 percent of the bike
    purchases have a cross-sale—which means we are heavily skewed. No matter what
    kind of tweaks you do to the model, you can't get around the fact that you are
    multiplying by 0.9 to Yes for `multiPurchase`.
  prefs: []
  type: TYPE_NORMAL
- en: Making use of our discoveries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What should we do? We have a k-NN telling us that single women are not buying
    additional items and we have Naïve Bayes being no help at all. We could do some
    more classification models, but let's assume we feel good enough about our analysis
    and want to go to production with this model. How should we do that? A key issue
    to consider is that the model is based on some static data in one of our database
    tables that is not updated via the normal transactions of the company. This means
    we really don't need to retrain the model frequently. Another problem we have
    is that we need to figure out the gender and marital status of the people ordering
    our bikes. Perhaps we are asking the wrong question. Instead of asking how to
    get the gender and marital status of the user, what if we already knew it? You
    may be thinking that we don't know because we haven't asked yet. But we might—based
    on the bike selected for purchase!
  prefs: []
  type: TYPE_NORMAL
- en: Getting the data ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go back into the script and enter this code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, this code should look pretty boring to you by now. It is creating
    a tuple of `customerId` and `ProductId` from all of the bike sales.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the script and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This code block is shaping our data for Accord by creating a frame of tuples
    of `customerId`, `productId`, and `singleFemaleInd`. We are almost ready to throw
    this data at a model, but we still need to determine which model we want to use.
    We are trying to determine the probability of a customer being a single female
    based on the bike purchased. This seems like a question that is well-suited for
    a logistic regression ([Chapter 3](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 3. More AdventureWorks Regression"), *More AdventureWorks Regression*).
    The issue is that each bike needs to become a feature in this regression:'
  prefs: []
  type: TYPE_NORMAL
- en: '*singleFemale = BikeId0 + BikeId1 + BikeId2 + BikeIdN + E*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you throw this code into your script and send it to the FSI, you will see
    we have 80 different bike IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: So how do we create an input of 80 features from the original frame? Certainly
    not by hand. Let's see if Accord can help us.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open up the script you were using from the previous section and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are doing is taking the `customerDemo` frame and selecting the `productId`.
    We are then sending that array to Accord''s `Tools.Expand` method that explodes
    the array so that each value becomes its own feature. Graphically, it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expanding features](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can guess after reading [Chapter 5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "Chapter 5. Time Out – Obtaining Data"), *Time Out – Obtaining Data*, this is
    considered a sparse data frame. With the input and output ready, go back to the
    script file and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you send this to the REPL, let me warn you. The reason we identify a
    sparse frame is that computing a regression on 80 features takes a while. So hit
    *ALT* + *ENTER* and go get a cup of coffee. From Starbucks. Across town. Eventually,
    you will get this back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'And when we filter at the coefficient table, we can see that there is one bike
    model that is favored by single women. Add this to your script file and send to
    the FSI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: So perhaps when a person purchases item number `765`, we try to give them an
    incentive to buy other products, either via a coupon or a really slick website
    experience. This is where an excellent UX person with a knowledgeable marketing
    person can pay dividends. Since I am neither, I will leave that exercise to the
    reader.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we took a look at two common machine learning classifiers:
    k-Nearest Neighbors and Naïve Bayes. We saw them both in action with our AdventureWorks
    dataset to see if we can increase cross sales. We saw that k-NN had some limited
    success and Naïve Bayes was not useful. We then used our old friend logistic regression
    to help us narrow down a specific bike model that can be used to promote cross
    sales. Finally, we considered that since the data is ad hoc, we can''t implement
    any real-time training on our website. We would want to periodically run this
    analysis to see if our original findings continued to hold.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we are going to take off our software engineer hat and
    put on our data scientist hat to see if we can do anything with that traffic stop
    data. We are going to look at augmenting the original dataset with another dataset
    and then using a couple of clustering models: k-means and PCA. See you on the
    next page!'
  prefs: []
  type: TYPE_NORMAL
