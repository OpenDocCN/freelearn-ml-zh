- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Support Multiple Viewports Using Responsive Web Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building web pages is a challenge. Not only do you need to craft these pages
    with HTML, CSS, and JavaScript to perform the tasks you set out, but you also
    need to ensure they are accessible to most users. Additionally, you need to ensure
    the pages render nicely regardless of whether the device is a PC, tablet, or mobile
    device, which means you need to consider aspects like screen size; the orientation
    of the device; that is, landscape or portrait; and pixel density.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different techniques to ensure your web pages look good on many
    devices, but it all starts with having a strategy, a vision for what the experience
    will be for the user depending on what device is used. Once you have that vision
    set, you can start to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Some choices you will need to make are how many columns should be listed, if
    your content is presented as columns. How should other things behave, like padding
    and margins? Should the content be centered or left-aligned? Should the content
    be stacked vertically or horizontally? Is there content that should be hidden
    on mobile devices? As you can see, there are many choices to make that affect
    what prompts you will need to use.
  prefs: []
  type: TYPE_NORMAL
- en: Using an AI assistant can be helpful when dealing with web layouts as there’s
    a lot of information you need to remember, so not only can you have the AI assistant
    remember all those details for easy lookup, but you can also utilize it to suggest
    different designs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain technical terms like viewports and media queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply different techniques to optimize rendering for different viewports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage the Copilot chat feature to improve our code. This is the “other” modality
    you can use in GitHub Copilot; it’s a chat window that lets you type the prompt
    and provides a response. This experience resembles an AI tool like ChatGPT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Business problem: e-commerce'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue to address the e-commerce use case that’s been worked
    on in the last three chapters. Building the functionality is one thing, but you
    must assume your users will want to interact with your website from many different
    devices and that experience must be good or they will go to a competitor’s website.
  prefs: []
  type: TYPE_NORMAL
- en: Problem and data domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many different devices out there: tablets, mobile phones, and small
    desktop screens to large ones. Pixel density is different. It’s not just a matter
    of shrinking or scaling up your site to fit this new device, but you might need
    to design a completely different experience that better suits the visual style
    of a specific device. There are also other concerns, like how much content we
    want to send to a smaller device if we assume the device has limitations, like
    how many concurrent downloads it can handle and what network speed it might have.
    It’s not unusual that a desktop machine with a wide resolution often has a great
    connection to the internet. Conversely, a mobile device might be on a 3G network
    or worse and you therefore need to adjust to that by requiring a lot fewer graphical
    resources, smaller JavaScript bundles, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the problem down into features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve seen in several chapters before this one how a good approach is identifying
    the features we need to implement. These features are less about reading and writing
    data and more about ensuring the design and interaction work well on prioritized
    devices. You might therefore have a feature breakdown looking like the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: Should render the basket page in a double-column design for landscape mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Portrait mode:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should render the basket page in a single column for portrait mode.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Should display menu actions at the bottom of the screen.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You should hide certain features, say, X, Y, Z (assuming X, Y, Z are available
    on a desktop with a wider screen). The point of this requirement is that you must
    “rethink” what a mobile experience is versus desktop, what features are central
    to the experience, and what features we only show if we have plenty of screen
    space to show it on.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Should support and render a visually appealing look for the following mobile
    devices: iPhone, X, Y, X, and Android.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Should render the page in < 1 second on a 3G connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the features are more connected to the user experience than
    any data domain.
  prefs: []
  type: TYPE_NORMAL
- en: Prompting strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our prompting strategy is like before, a blended approach of using the in-editor
    experience and adding prompts in open text files to bring up the **Chat** window
    in Copilot; mix these approaches to your discretion.
  prefs: []
  type: TYPE_NORMAL
- en: As for prompts, there should be enough context in these prompts to make Copilot
    aware that it will need to suggest a design for specific devices. Thus, it should
    be able to infer from context what resolutions, pixel density, and other details
    should influence the suggestions it’s about to generate. As for prompting pattern
    used, we will use the “Exploratory prompt pattern” described in *Chapter 2*.
  prefs: []
  type: TYPE_NORMAL
- en: Viewports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gone are the days when you only had to develop a web page to look nice on a
    PC. Today, your web page can be rendered on multiple different devices and it
    needs to look good on all of them or your customers might go elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in understanding how to build web pages is being familiar with
    some key concepts. The first concept is a viewport. A viewport is a part of the
    page visible to the user. The difference between a viewport and a window is that
    a viewport is a part of the window.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on what device is used, for example, a desktop screen or a mobile
    device, its size differs. When you write code to adjust to different sizes, to
    render nicely, it’s known as making the page “responsive.”
  prefs: []
  type: TYPE_NORMAL
- en: Media queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OK, so I’m dealing with different sizes of the screen depending on what type
    of device I’m using, so how do I write code that ensures the visual interface
    adjusts to the size of the device I’m using?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is to leverage a construct called media queries. A media query is
    a logical block in your CSS that identifies a specific condition and applies specific
    CSS if said condition is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine if there were code like the following; that’s basically how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Below is an example of a media query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code identifies a condition that says, if the viewport is currently
    at most 600 pixels wide (which is true for most mobile devices), then set the
    background color to light blue.
  prefs: []
  type: TYPE_NORMAL
- en: This example might feel a bit contrived; why would I want a different background
    color when I’m on a mobile device over a normal desktop? You wouldn’t, but the
    example above gives you an idea of how a media query identifies a viewport’s size
    and can apply specific CSS under certain conditions on the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: When to adjust to different viewports and make it responsive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A good reason for using responsive design is because you have a layout that
    looks great on desktop but might be too wide for mobile. For example, let’s say
    you have a web page with a menu to the left and a main area to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![page with a menu and a main area](img/B21232_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Page with a menu and a main area'
  prefs: []
  type: TYPE_NORMAL
- en: 'Were we to try to view this page on a mobile device, it would not look nice.
    It would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![non responsive page in mobile device](img/B21232_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Non-responsive page on a mobile device'
  prefs: []
  type: TYPE_NORMAL
- en: Above, we see how the device tries to view the page, but the main area is cut
    off. At this point, you as a designer need to consider how to solve this issue.
    One way is to align the content vertically using either flexbox or grid as techniques.
    The menu could go on top, for example, and the main area at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspecting the styles used for this page, you see the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, you can see how a grid, `display:grid`, is used to create
    the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also see how the menu is placed to the left, `grid-column: 1:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The main area is the second column, `grid-column: 2:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To improve this design so that it can be used on a device with a smaller screen,
    such as a mobile device, we can use the below prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: If mobile, set menu to row 1 and main to row 2.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting CSS is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, Copilot can take this prompt instruction and adjust the CSS
    accordingly. The code shifts the layout to having one column and two rows. Also,
    it ensures the menu is placed at the top and the main area at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting page now renders in the following way on a mobile device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![menu and main area rendered vertically in mobile viewport](img/B21232_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Menu and main area rendered vertically in mobile viewport'
  prefs: []
  type: TYPE_NORMAL
- en: Most browsers have built-in functionality for letting you resize the viewport,
    which helps you test your altered CSS. You can also change the window size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use case: make our product gallery responsive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this use case, we will take an e-commerce application that renders OK on
    a desktop but not OK on a mobile device, and fix the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here’s the HTML code for it. If you want to follow along, you can save
    the following code in a `products.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This should render something like the following (exact images may vary as these
    URLs produce random images) on desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![e-commerce product list page](img/B21232_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: E-commerce product list page'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, trying to render the same page on a mobile device makes it look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![e-commerce, product list, looks bad on mobile](img/B21232_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: E-commerce product list, looks bad on mobile'
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, we need to place ourselves in the CSS code and ask our
    AI assistant what we should do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place a prompt at the bottom of the CSS like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Switch from 3 columns to 1 on mobile device for gallery.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should be a media query like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Our new mobile rendering now looks like the image below, which is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21232_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: This shows an image gallery rendered on a mobile device in portrait
    mode'
  prefs: []
  type: TYPE_NORMAL
- en: Assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a newly hired frontend developer, you’ve been hired to maintain a memory
    game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The game looks something like the below image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![memory game](img/B21232_07_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Grids in a memory game'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your company wants you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure it renders as a 5x5 grid on desktop. For larger viewports, it doesn’t
    work well, but you should address that problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support mobile devices, meaning that it should render as a 5x5 grid but with
    half as big tiles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While fixing it for mobile devices, ensure the score in the top-right corner
    is moved to the middle and is centered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a developer, it’s now your job to adjust the code of this game using GitHub
    Copilot, using either inline editing of open text files or the Chat function in
    Copilot to ensure the code works well for different devices.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the solution to this assignment in the GitHub repository: [https://github.com/PacktPublishing/AI-Assisted-Software-Development-with-GitHub-Copilot-and-ChatGPT](https://github.com/PacktPublishing/AI-Assisted-Software-Development-with-GitHub-Copilot-and-ChatGPT)'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the code for the assignment is in one file. See if you can split it up into
    different files. Additionally, see if you can experiment with matched cards; try
    removing them or adding a class that shows they’re no longer part of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we discussed viewports as the central concept for responsive
    web design. To help us tackle different viewports, we used media queries.
  prefs: []
  type: TYPE_NORMAL
- en: We also continued working on our use case, the e-commerce site, and tried to
    ensure a product list renders nicely on mobile devices. The first thing is to
    realize that you have a problem, and we managed to identify that. Second, we came
    up with a strategy to solve the problem, which was to use media queries. Third,
    we implemented the strategy. Finally, we tested it to ensure it worked.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will shift from the frontend to the backend. The backend
    is made up of a Web API. We will continue with our use case, the e-commerce site,
    and build a Web API that will serve the product list primarily. Hopefully, though,
    it will become apparent how to add other resources to the Web API as well.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/aicode](https://packt.link/aicode)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code510410532445718281.png)'
  prefs: []
  type: TYPE_IMG
