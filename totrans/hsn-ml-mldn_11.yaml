- en: Using ML.NET with .NET Core and Forecasting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 .NET Core 和预测中使用 ML.NET
- en: Now that we have completed our deep dive into the various groups of algorithms
    ML.NET offers, we will begin to explore integrating ML.NET into a production application
    over the next few chapters. In this chapter, we will deep dive into a .NET Core
    console application building on the structure defined in previous chapters with
    a focus on hardening and error handling. The application we will be building uses
    forecasting to predict stock prices based on a series of trends. By the end of
    this chapter, you should have a firm grasp of designing and coding a production-grade
    .NET Core application with ML.NET.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经深入了解了 ML.NET 提供的各种算法组，接下来我们将开始探索在接下来的几章中将 ML.NET 集成到生产应用程序中。在本章中，我们将深入探讨一个基于前几章定义的结构构建的
    .NET Core 控制台应用程序，重点关注加固和错误处理。我们将构建的应用程序使用预测来根据一系列趋势预测股价。到本章结束时，您应该能够熟练地设计和编码一个具有
    ML.NET 的生产级 .NET Core 应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Breaking down the .NET Core application architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析 .NET Core 应用程序架构
- en: Creating the forecasting application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建预测应用程序
- en: Exploring additional production application enhancements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索额外的生产应用程序增强功能
- en: Breaking down the .NET Core application architecture
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析 .NET Core 应用程序架构
- en: 'As mentioned in [Chapter 1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml), *Getting
    Started with Machine Learning and ML.NET,* .NET Core 3.x is the preferred platform
    for using ML.NET due to the optimization done in the 3.0 release. In addition,
    .NET Core provides a singular coding framework to target Linux, macOS, and Windows,
    as noted in the following diagram:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 1 章](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml) 中所述，*开始使用机器学习和 ML.NET*，.NET
    Core 3.x 由于 3.0 版本中的优化，是使用 ML.NET 的首选平台。此外，.NET Core 提供了一个统一的编码框架，以针对 Linux、macOS
    和 Windows，如下面的图所示：
- en: '![](img/ea346e36-c0a4-4e3e-9056-f9501455b5e4.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea346e36-c0a4-4e3e-9056-f9501455b5e4.png)'
- en: .NET Core architecture
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core 架构
- en: From its inception in 2016, the underlying goals of .NET Core have been to provide
    rapid updates and feature parity with (the previously Windows-only) Microsoft
    .NET Framework. Over time and versions, the gap has gotten smaller by simply adding
    the APIs that were missing, using additional NuGet packages. One such example
    of this is `Microsoft.Windows.Compatibility` that provides 20,000 APIs not found
    in the Core framework including registry access, drawing, and Windows Permission
    Model access. This approach keeps the framework light and cross-platform but does
    introduce some design patterns to help you to develop your platform-specific applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2016 年成立以来，.NET Core 的基本目标是为用户提供快速更新和与（之前仅限 Windows 的）Microsoft .NET Framework
    的功能一致性。随着时间的推移和版本的更新，通过简单地添加缺失的 API、使用额外的 NuGet 包，差距已经缩小。其中一个例子是 `Microsoft.Windows.Compatibility`，它提供了
    20,000 个在 Core 框架中找不到的 API，包括注册表访问、绘图和 Windows 权限模型访问。这种方法保持了框架的轻量级和跨平台性，但确实引入了一些设计模式来帮助您开发特定平台的应用程序。
- en: Take, for instance, a Windows Desktop application that uses ML.NET to provide
    an **Intrusion Detection System** (**IDS**). A simple approach would be to write
    all of the code in a .NET Core **Windows Presentation Foundation** (**WPF**) application.
    However, this would tie you to Windows only without doing major refactoring. A
    better approach would be to create a .NET Core class library that contains all
    platform-agnostic code and then creates abstract classes or interfaces to implement
    the platform-specific code inside your platform application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个使用 ML.NET 提供入侵检测系统（**IDS**）的 Windows 桌面应用程序为例。一个简单的方法是将所有代码都写在一个 .NET Core
    **Windows Presentation Foundation**（**WPF**）应用程序中。然而，这将使您仅限于 Windows 而无法进行重大重构。更好的方法是创建一个包含所有平台无关代码的
    .NET Core 类库，然后创建抽象类或接口，在您的平台应用程序中实现特定平台的代码。
- en: .NET Core targets
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core 目标
- en: As mentioned previously, .NET Core offers a single framework to target Windows,
    macOS, and Linux. However, this doesn't just apply to console applications as
    we have used throughout this book. Recent work in .NET Core 3 has provided the
    ability to port existing .NET Framework WPF and Windows Forms applications to
    .NET Core 3, thereby enabling applications that rely on potentially years-old
    frameworks to use the latest .NET Core advancements. In addition, web applications
    that previously used ASP.NET can be migrated over to ASP.NET Core (ASP.NET WebForms
    does not currently have a migration path).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，.NET Core提供了一个单一框架来针对Windows、macOS和Linux。然而，这不仅仅适用于我们在这本书中使用的控制台应用程序。.NET
    Core 3最近的工作提供了将现有的.NET Framework WPF和Windows Forms应用程序迁移到.NET Core 3的能力，从而使得依赖于可能已经存在多年的框架的应用程序能够使用最新的.NET
    Core进步。此外，之前使用ASP.NET的Web应用程序也可以迁移到ASP.NET Core（目前ASP.NET WebForms没有迁移路径）。
- en: Another benefit of .NET Core targeting is the ability to compile with the `--self-contained`
    flag. This flag compiles your application or library and then bundles all necessary
    .NET Core framework files. This allows you to deploy your application without
    a .NET prerequisite during install. This does make your overall build output larger,
    but in a customer scenario, a ~100MB increase far outweighs the deployment hurdles
    of prerequisites.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core的目标之一是能够使用`--self-contained`标志进行编译。这个标志编译你的应用程序或库，然后将所有必要的.NET Core框架文件捆绑在一起。这允许你在安装时无需.NET先决条件即可部署你的应用程序。这确实会使你的整体构建输出更大，但在客户场景中，大约100MB的增加远远超过了先决条件的部署障碍。
- en: .NET Core future
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core的未来
- en: You might wonder what the future of .NET Framework, Mono, and .NET Core is.
    Fortunately, Microsoft, at the time of this writing, has confirmed that all existing
    frameworks will be migrated into a singular framework simply called .NET 5\. Previously,
    when making a decision on which framework to use, certain trade-offs were guaranteed.
    Hence, taking the benefits of each framework and unifying them for the first time
    will eliminate these trade-offs entirely. Take, for instance, Mono's **Ahead-Of-Time**
    (**AOT**) compilation or Xamarin's cross-platform UI support, which can be utilized
    inside an existing .NET Core 3.x application based on the information released.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道.NET Framework、Mono和.NET Core的未来是什么。幸运的是，在撰写本文时，微软已经确认所有现有框架都将迁移到一个单一的框架，这个框架简单地被称为.NET
    5。在此之前，在决定使用哪个框架时，某些权衡是不可避免的。因此，将每个框架的优点结合起来并首次实现统一，将完全消除这些权衡。例如，Mono的**即时编译**（**AOT**）或Xamarin的跨平台UI支持，这些都可以根据已发布的信息在现有的基于.NET
    Core 3.x的应用程序中使用。
- en: A preview of .NET 5 is expected in the first half of 2020, with a production
    release in November 2020.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 预计.NET 5的预览版将在2020年上半年发布，正式版将在2020年11月发布。
- en: Creating the stock price estimator application
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建股价估算应用程序
- en: As mentioned earlier, the application we will be creating is a stock price estimator.
    Given a set of stock prices across days, weeks, or years, the forecasting algorithm
    will internally identify trending patterns. Unlike previous chapters, the application
    will be architected to be plugged into a production pipeline.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将要创建的应用程序是一个股价估算器。给定一系列跨越几天、几周或几年的股价，预测算法将内部识别趋势模式。与之前的章节不同，该应用程序将被设计成可以插入到生产流程中。
- en: As with previous chapters, the completed project code, sample dataset, and project
    files can be downloaded from: [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter08](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter08).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，完成的项目代码、示例数据集和项目文件可以从以下链接下载：[https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter08](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter08)。
- en: Exploring the project architecture
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索项目架构
- en: Building upon the project architecture and code we created in previous chapters,
    the architecture we will be exploring in this chapter further enhances the architecture
    to be more structured and thereby more usable for an end user.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中创建的项目架构和代码的基础上，本章将要探索的架构将进一步增强架构，使其更加结构化，从而更适合最终用户使用。
- en: Like in some of the previous chapters, an additional NuGet package—`Microsoft.ML.TimeSeries`—is
    required to utilize the forecasting functionality in ML.NET. Version 1.3.1 is
    used in both the included example on GitHub and throughout this chapter's deep
    dive.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如同前几章中的一些章节，需要额外的NuGet包——`Microsoft.ML.TimeSeries`——来利用ML.NET中的预测功能。GitHub上包含的示例和本章的深入探讨中都使用了1.3.1版本。
- en: 'In the following screenshot, you will find the Visual Studio Solution Explorer
    view of the project. There are several new additions to the solution to facilitate
    the production use case we are targeting. We will review in detail each of the
    new files shown in the solution screenshot here later on in this chapter:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您将找到项目的 Visual Studio 解决方案资源管理器视图。为了便于我们针对的目标生产用例，解决方案中添加了几个新功能。我们将在本章后面详细审查解决方案屏幕截图中所显示的每个新文件：
- en: '![](img/fa567181-ad7a-4d3d-b62c-265416c722f1.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa567181-ad7a-4d3d-b62c-265416c722f1.png)'
- en: 'The `sampledata.csv` file contains 24 rows of stock prices. Feel free to adjust
    the data to fit your own observations or to adjust the trained model. Here is
    a snippet of the data:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampledata.csv`文件包含24行股票价格。请随意调整数据以适应您的观察或调整训练模型。以下是数据的片段：'
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each of these rows contains the stock price value we will populate into a `StockPrices`
    class object that we will review later on in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些每一行都包含我们将填充到`StockPrices`类对象中的股票价格值，我们将在本章后面进行审查。
- en: 'In addition to this, we added the `testdata.csv` file that contains additional
    data points to test the newly trained model against and evaluate it. Here is a
    snippet of the data inside of `testdata.csv`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还添加了包含用于测试新训练模型并评估它的额外数据点的`testdata.csv`文件。以下是`testdata.csv`内部数据的片段：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Diving into the code
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入代码
- en: For this application, as noted in the previous section, we are building on top
    of the work completed in previous chapters. However, for this chapter, we will
    be changing every file to support production use cases. For each file changed
    from previous chapters, we will review the changes made and the reasoning behind
    these changes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，我们是在前几章完成的工作基础上构建的。然而，对于本章，我们将更改每个文件以支持生产用例。对于从前几章更改的每个文件，我们将审查所做的更改及其背后的原因。
- en: 'Classes and enumerations that were changed or added are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是被更改或添加的类和枚举：
- en: '`ProgramActions`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgramActions`'
- en: '`CommandLineParser`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommandLineParser`'
- en: '`BaseML`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseML`'
- en: '`StockPrediction`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StockPrediction`'
- en: '`StockPrices`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StockPrices`'
- en: '`Predictor`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Predictor`'
- en: '`Trainer`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trainer`'
- en: '`ProgramArguments`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgramArguments`'
- en: '`Program`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Program`'
- en: The ProgramActions enumeration
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序动作枚举
- en: 'The following `ProgramActions` enumeration has been added to the solution to
    facilitate the use of a strongly typed and structured path for handling various
    actions the program performs:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`ProgramActions`枚举已被添加到解决方案中，以方便使用强类型和结构化的路径来处理程序执行的各种操作：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the case of this application, we only have two actions—`Training` and `Predicting`.
    However, as shown in previous chapters, you might also have a feature extraction
    step or maybe provide an evaluation step. This design pattern allows flexibility
    while also removing the **magic strings** problem mentioned at the beginning of
    this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本应用的情况下，我们只有两个动作——“训练”和“预测”。然而，如前几章所示，您可能还有一个特征提取步骤或可能提供一个评估步骤。这种设计模式既提供了灵活性，又消除了本章开头提到的“魔法字符串”问题。
- en: The CommandLineParser class
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`CommandLineParser`类'
- en: 'The `CommandLineParser` class provides a program-agnostic parser for handling
    command-line arguments. In previous chapters, we were manually parsing the indexes
    and mapping those values to arguments. On the other hand, this approach creates
    a flexible, easy-to-maintain and structured response object that maps arguments
    directly to the properties. Let''s now dive into the class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`CommandLineParser`类提供了一个程序无关的解析器，用于处理命令行参数。在前几章中，我们手动解析索引并将这些值映射到参数上。另一方面，这种方法创建了一个灵活、易于维护且结构化的响应对象，它将参数直接映射到属性。现在让我们深入了解这个类：'
- en: 'First, we define the function prototype:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义函数原型：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The use of generics (that is, `T`) creates a flexible approach to making this
    method unconstrained to just this application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型（即`T`）创建了一种灵活的方法，使此方法不受限于仅此应用。
- en: 'Next, we test for `null` arguments:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们测试`null`参数：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we test for empty arguments and let the user know default values are
    going to be used instead of failing, as in previous chapters:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们测试空参数，并告知用户将使用默认值而不是失败，如前几章所述：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After null and empty checks are performed, we then perform a multiple of two
    checks since all arguments are pairs:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行空和空检查之后，我们执行多个检查，因为所有参数都是成对的：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Continuing, we then create an object of the `T`type using the `Activator.CreateInstance`
    method:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续进行，然后我们使用 `Activator.CreateInstance` 方法创建 `T` 类型的对象：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ensure that, when creating class objects, the constructor has no arguments as
    this call would throw an exception if so. If you create an object with constructor
    parameters and without a parameterless constructor, use the overload of `Activator.CreateInstance`
    and pass in the required parameters.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在创建类对象时，构造函数没有参数，因为这个调用如果没有无参构造函数将会抛出异常。如果你创建了一个带有构造函数参数的对象而没有无参构造函数，请使用 `Activator.CreateInstance`
    的重载版本并传递所需的参数。
- en: 'Next, we utilize reflection to grab all of the properties of the `T` type:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用反射来获取 `T` 类型的所有属性：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have both the generic object created and the properties of that
    object, we then loop through each of the argument key/value pairs and set the
    property in the object:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了通用对象及其属性，然后我们遍历每个参数键/值对，并在对象中设置属性：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note the special case for the `IsEnum` function to handle our previously covered
    `ProgramActions` enumeration. Since a string value cannot be automatically converted
    to an enumeration, we needed to handle the string-to-enumeration conversion specifically
    with the `Enum.Parse` method. As written, the enumeration handler is generic if
    you add more enumerations to the `T` type.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `IsEnum` 函数的特殊情况，用于处理之前提到的 `ProgramActions` 枚举。由于字符串值不能自动转换为枚举，我们需要使用 `Enum.Parse`
    方法专门处理字符串到枚举的转换。按照目前的写法，如果添加更多的枚举到 `T` 类型，枚举处理器是通用的。
- en: The BaseML class
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`BaseML` 类'
- en: 'The `BaseML` class for this application has been streamlined to simply instantiate
    the `MLContext` object:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为此应用创建的 `BaseML` 类已经精简，只需实例化 `MLContext` 对象：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The StockPrediction class
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`StockPrediction` 类'
- en: 'The `StockPrediction` class is the container for our prediction values, as
    defined here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`StockPrediction` 类是我们预测值的容器，如这里定义的：'
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `StockForecast` property will hold our predicted stock values based on the
    model training and submitted value to the prediction engine. The `LowerBound`
    and `UpperBound` values hold the lowest and highest estimated values respectively.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`StockForecast` 属性将保存基于模型训练和提交给预测引擎的预测股票值。`LowerBound` 和 `UpperBound` 值分别保存最低和最高估计值。'
- en: The StockPrices class
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`StockPrices` 类'
- en: 'The `StockPrices` class contains our single floating-point value holding the
    stock price. To keep the code cleaner when populating the values, a constructor
    accepting the stock price value has been added:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`StockPrices` 类包含我们的单个浮点值，该值持有股票价格。为了在填充值时保持代码的整洁，添加了一个接受股票价格值的构造函数：'
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Predictor class
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Predictor` 类'
- en: 'The `Predictor` class, in comparison to previous chapters, has been streamlined
    and adapted to support forecasting:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章相比，`Predictor` 类已经精简并适应了预测功能：
- en: 'First, we adjust the `Predict` method to accept the newly defined `ProgramArguments`
    class object:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，调整 `Predict` 方法以接受新定义的 `ProgramArguments` 类对象：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we update the model `file.Exists` check to utilize the `arguments` object:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们更新模型 `file.Exists` 检查以利用 `arguments` 对象：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Similarly, we also update the prediction filename reference to the utilize
    the `arguments` object:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们还更新了预测文件名引用，以利用 `arguments` 对象：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we also modify the model open call to utilize the `arguments` object:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们还修改了模型打开调用以利用 `arguments` 对象：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then create the Time Series Engine object with our `StockPrices` and `StockPrediction`
    types:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用 `StockPrices` 和 `StockPrediction` 类型创建时间序列引擎对象：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we read the stock price prediction file into a string array:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将股票价格预测文件读入一个字符串数组：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Lastly, we iterate through each input, call the prediction engine, and display
    the estimated values:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们遍历每个输入，调用预测引擎，并显示估计值：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The Trainer class
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Trainer` 类'
- en: 'The `Trainer` class, akin to the `Predictor` class, received both streamlining
    and changes to account for the ML.NET forecasting algorithm:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trainer` 类，类似于 `Predictor` 类，对 ML.NET 预测算法进行了精简和修改：'
- en: 'First, update the function prototype to take the `ProgramArguments` object:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，更新函数原型以接受 `ProgramArguments` 对象：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we update the training file check to utilize the `argument` object:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们更新训练文件检查以利用 `argument` 对象：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Similarly, we then update the testing file check to utilize the `argument`
    object:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，我们随后更新测试文件检查以利用 `argument` 对象：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we load the `StockPrices` values from the training file:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从训练文件中加载 `StockPrices` 值：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then create the `Forecasting` object and utilize the `nameof`C# feature
    to avoid magic string references:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建 `Forecasting` 对象并利用 C# 的 `nameof` 特性来避免魔法字符串引用：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The input and output column name references are as we have seen in previous
    chapters. The `windowSize` property is the duration between the data points in
    the training set. For this application, we are using `7` to indicate a week's
    duration. The `seriesLength`property indicates the total duration of the dataset
    in this case. The `horizon` property indicates how many predicted values should
    be calculated when the model is run. In our case, we are asking for `5` predicted
    values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输入和输出列名引用与我们之前在章节中看到的一样。`windowSize` 属性是训练集中数据点之间的持续时间。对于这个应用程序，我们使用 `7` 来表示一周的持续时间。`seriesLength`
    属性表示数据集的总持续时间。`horizon` 属性表示在运行模型时应该计算多少个预测值。在我们的例子中，我们请求 `5` 个预测值。
- en: 'Lastly, we transform the model with the training data, call the `CreateTimeSeriesEngine`
    method, and write the model to disk:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用训练数据转换模型，调用 `CreateTimeSeriesEngine` 方法，并将模型写入磁盘：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The ProgramArguments class
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ProgramArguments` 类'
- en: 'This new class, as referred to earlier in this section, provides the one-to-one
    mapping of arguments to properties used throughout the application:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节前面所述，这个新类提供了应用程序中参数到属性的一对一映射：
- en: 'First, we define the properties that map directly to the command-line arguments:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义直接映射到命令行参数的属性：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Lastly, we populate default values for the properties:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为属性填充默认值：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Unlike previous chapters, if any property was not set as expected, the program
    would fail. This is fine for the developer experience; however, in the real world,
    end users will more than likely attempt to just run the application without any
    parameters.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章不同，如果任何属性没有按预期设置，程序将失败。这对于开发者体验来说是可以接受的；然而，在现实世界中，最终用户更有可能尝试在没有任何参数的情况下运行应用程序。
- en: The Program class
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Program` 类'
- en: 'Inside the `Program` class, the code has been simplified to utilize the new
    `CommandLineParser` class discussed earlier in this chapter. With the use of the
    `CommandLineParser` class, all of the actions have been switched to utilize strongly-typed
    enumerations:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program` 类中，代码已被简化以利用本章前面讨论的新 `CommandLineParser` 类。使用 `CommandLineParser`
    类，所有操作都已切换到使用强类型枚举：
- en: 'First, while relatively simplistic, clearing the screen of any previous run
    data is an improved UX:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，虽然相对简单，清除屏幕上的任何先前运行数据是一个改进的用户体验：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then use our new `CommandLineParser` class and associated `ParseArguments`
    method to create a strongly-typed argument object:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后使用我们新的 `CommandLineParser` 类及其相关的 `ParseArguments` 方法来创建一个强类型参数对象：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then can use a simplified and strongly typed switch case to handle our two
    actions:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用简化和强类型的 switch case 来处理我们的两个操作：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Running the application
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'To run the application, the process is nearly identical to the sample application
    in [Chapter 3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml), *Regression Model*,
    with the addition of passing in the test dataset when training:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行应用程序，过程几乎与第 3 章中示例应用程序的“回归模型”相同，只是在训练时传递测试数据集：
- en: 'Running the application without any arguments to train the model, we use the
    following step:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在没有参数的情况下运行应用程序以训练模型，我们使用以下步骤：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Running the application to make predicitons based on the included prediction
    data, we use the following step:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于包含的预测数据运行应用程序以进行预测，我们使用以下步骤：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Feel free to modify the values and see how the prediction changes based on
    the dataset that the model was trained on. A few areas of experimentation from
    this point might be to do the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 随意修改值并查看基于模型训练数据集的预测如何变化。从这个点开始，一些实验性的区域可能包括以下内容：
- en: Tweak the hyperparameters reviewed in the `Trainer` class, such as the `windowSize`,
    `seriesLength`, or `horizon` properties, to see how accuracy is affected.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整 `Trainer` 类中审查的超参数，如 `windowSize`、`seriesLength` 或 `horizon` 属性，以查看精度如何受到影响。
- en: Add significantly more data points—this may utilize a data feed of your favorite
    stock you watch.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加显著更多的数据点——这可能需要使用你关注的股票的数据源。
- en: Exploring additional production application enhancements
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索额外的生产应用程序增强
- en: Now that we have completed our deep dive, there are a couple of additional elements
    to possibly further enhance the application. A few ideas are discussed here.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了深入探讨，还有一些额外的元素可能可以进一步增强应用程序。这里讨论了一些想法。
- en: Logging
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: Logging utilizing NLog ([https://nlog-project.org/](https://nlog-project.org/))
    or a similar open source project is highly recommended as your application complexity
    increases. This will allow you to log to a file, console, or third-party logging
    solution such as Loggly at varying levels. For instance, if you deploy this application
    to a customer, breaking down the error level to at least Debug, Warning, and Error
    will be helpful when debugging issues remotely.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序复杂性的增加，强烈建议使用NLog([https://nlog-project.org/](https://nlog-project.org/))或类似的开源项目进行日志记录。这将允许你以不同的级别记录到文件、控制台或第三方日志解决方案，如Loggly。例如，如果你将此应用程序部署给客户，将错误级别至少分解为Debug、Warning和Error，在远程调试问题时将非常有帮助。
- en: Utilizing Reflection further
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步利用反射
- en: As noted earlier in this section to create flexibility and adaptability, we
    utilized `Reflection` to parse the command-line arguments. You could take this
    a step further and replace the switch case statement/standard flow in the `Program`
    class with an entirely reflection-based approach, meaning for every action defined
    in the application, it could inherit from an abstract `BaseAction` class and at
    runtime, based on the argument, call the appropriate class. For every new action,
    simply adding a new entry to the `ProgramActions` enumeration and then defining
    a class with that enumeration would be all that is required.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了创建灵活性和适应性，我们使用了`Reflection`来解析命令行参数。你可以更进一步，将`Program`类中的switch case语句/标准流程替换为完全基于反射的方法，这意味着对于应用程序中定义的每个操作，它都可以继承自一个抽象的`BaseAction`类，并在运行时根据参数调用适当的类。对于每个新的操作，只需向`ProgramActions`枚举中添加一个新条目，然后定义一个具有该枚举的类即可。
- en: Utilizing a database
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用数据库
- en: In a real-world scenario, the data provided to run predictions will more than
    likely come from a database. This database, whether it is a Postgres, SQL Server,
    or SQLite database (to name a few), can be accessed with Microsoft's Entity Framework
    Core or with ML.NET's built-in database loader method—`CreateDatabaseLoader`.
    This loader is akin to how we have loaded data from enumerable or text files with
    the extra steps of injecting SQL queries.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中，用于运行预测的数据很可能来自数据库。这个数据库，无论是Postgres、SQL Server还是SQLite数据库（仅举几个例子），可以使用Microsoft的Entity
    Framework Core或ML.NET内置的数据库加载方法`CreateDatabaseLoader`访问。这个加载器类似于我们如何从可枚举或文本文件中加载数据，只是增加了注入SQL查询的额外步骤。
- en: In a production scenario, given Entity Framework Core's performance and ability
    to use LINQ instead of plaintext over ML.NET's implementation (at the time of
    this writing), I would recommend using Entity Framework if database sources are
    utilized.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产场景中，鉴于Entity Framework Core的性能和能够使用LINQ而不是ML.NET实现（在撰写本文时）的能力，如果使用了数据库源，我建议使用Entity
    Framework。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we have deep-dived into what goes into a production-ready
    .NET Core application architecture using the work performed in previous chapters
    as a foundation. We also created a brand new stock price estimator using the forecasting
    algorithm in ML.NET. Lastly, we discussed some ways to further enhance a .NET
    Core application (and production applications in general).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了如何使用前几章的工作作为基础，构建一个生产就绪的.NET Core应用程序架构。我们还使用ML.NET中的预测算法创建了一个全新的股票价格估算器。最后，我们讨论了一些增强.NET
    Core应用程序（以及一般的生产应用程序）的方法。
- en: In the next chapter, we will deep dive into creating a production-file-classification
    web application using ML.NET's binary classification and ASP.NET Core's framework.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨使用ML.NET的二进制分类和ASP.NET Core框架创建一个生产级文件分类Web应用程序。
