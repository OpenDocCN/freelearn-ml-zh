- en: Using ML.NET with .NET Core and Forecasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have completed our deep dive into the various groups of algorithms
    ML.NET offers, we will begin to explore integrating ML.NET into a production application
    over the next few chapters. In this chapter, we will deep dive into a .NET Core
    console application building on the structure defined in previous chapters with
    a focus on hardening and error handling. The application we will be building uses
    forecasting to predict stock prices based on a series of trends. By the end of
    this chapter, you should have a firm grasp of designing and coding a production-grade
    .NET Core application with ML.NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the .NET Core application architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the forecasting application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring additional production application enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking down the .NET Core application architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in [Chapter 1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml), *Getting
    Started with Machine Learning and ML.NET,* .NET Core 3.x is the preferred platform
    for using ML.NET due to the optimization done in the 3.0 release. In addition,
    .NET Core provides a singular coding framework to target Linux, macOS, and Windows,
    as noted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea346e36-c0a4-4e3e-9056-f9501455b5e4.png)'
  prefs: []
  type: TYPE_IMG
- en: .NET Core architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From its inception in 2016, the underlying goals of .NET Core have been to provide
    rapid updates and feature parity with (the previously Windows-only) Microsoft
    .NET Framework. Over time and versions, the gap has gotten smaller by simply adding
    the APIs that were missing, using additional NuGet packages. One such example
    of this is `Microsoft.Windows.Compatibility` that provides 20,000 APIs not found
    in the Core framework including registry access, drawing, and Windows Permission
    Model access. This approach keeps the framework light and cross-platform but does
    introduce some design patterns to help you to develop your platform-specific applications.
  prefs: []
  type: TYPE_NORMAL
- en: Take, for instance, a Windows Desktop application that uses ML.NET to provide
    an **Intrusion Detection System** (**IDS**). A simple approach would be to write
    all of the code in a .NET Core **Windows Presentation Foundation** (**WPF**) application.
    However, this would tie you to Windows only without doing major refactoring. A
    better approach would be to create a .NET Core class library that contains all
    platform-agnostic code and then creates abstract classes or interfaces to implement
    the platform-specific code inside your platform application.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core targets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, .NET Core offers a single framework to target Windows,
    macOS, and Linux. However, this doesn't just apply to console applications as
    we have used throughout this book. Recent work in .NET Core 3 has provided the
    ability to port existing .NET Framework WPF and Windows Forms applications to
    .NET Core 3, thereby enabling applications that rely on potentially years-old
    frameworks to use the latest .NET Core advancements. In addition, web applications
    that previously used ASP.NET can be migrated over to ASP.NET Core (ASP.NET WebForms
    does not currently have a migration path).
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of .NET Core targeting is the ability to compile with the `--self-contained`
    flag. This flag compiles your application or library and then bundles all necessary
    .NET Core framework files. This allows you to deploy your application without
    a .NET prerequisite during install. This does make your overall build output larger,
    but in a customer scenario, a ~100MB increase far outweighs the deployment hurdles
    of prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core future
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might wonder what the future of .NET Framework, Mono, and .NET Core is.
    Fortunately, Microsoft, at the time of this writing, has confirmed that all existing
    frameworks will be migrated into a singular framework simply called .NET 5\. Previously,
    when making a decision on which framework to use, certain trade-offs were guaranteed.
    Hence, taking the benefits of each framework and unifying them for the first time
    will eliminate these trade-offs entirely. Take, for instance, Mono's **Ahead-Of-Time**
    (**AOT**) compilation or Xamarin's cross-platform UI support, which can be utilized
    inside an existing .NET Core 3.x application based on the information released.
  prefs: []
  type: TYPE_NORMAL
- en: A preview of .NET 5 is expected in the first half of 2020, with a production
    release in November 2020.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the stock price estimator application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the application we will be creating is a stock price estimator.
    Given a set of stock prices across days, weeks, or years, the forecasting algorithm
    will internally identify trending patterns. Unlike previous chapters, the application
    will be architected to be plugged into a production pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: As with previous chapters, the completed project code, sample dataset, and project
    files can be downloaded from: [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter08](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the project architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building upon the project architecture and code we created in previous chapters,
    the architecture we will be exploring in this chapter further enhances the architecture
    to be more structured and thereby more usable for an end user.
  prefs: []
  type: TYPE_NORMAL
- en: Like in some of the previous chapters, an additional NuGet package—`Microsoft.ML.TimeSeries`—is
    required to utilize the forecasting functionality in ML.NET. Version 1.3.1 is
    used in both the included example on GitHub and throughout this chapter's deep
    dive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you will find the Visual Studio Solution Explorer
    view of the project. There are several new additions to the solution to facilitate
    the production use case we are targeting. We will review in detail each of the
    new files shown in the solution screenshot here later on in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa567181-ad7a-4d3d-b62c-265416c722f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `sampledata.csv` file contains 24 rows of stock prices. Feel free to adjust
    the data to fit your own observations or to adjust the trained model. Here is
    a snippet of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each of these rows contains the stock price value we will populate into a `StockPrices`
    class object that we will review later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, we added the `testdata.csv` file that contains additional
    data points to test the newly trained model against and evaluate it. Here is a
    snippet of the data inside of `testdata.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Diving into the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this application, as noted in the previous section, we are building on top
    of the work completed in previous chapters. However, for this chapter, we will
    be changing every file to support production use cases. For each file changed
    from previous chapters, we will review the changes made and the reasoning behind
    these changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes and enumerations that were changed or added are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProgramActions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CommandLineParser`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BaseML`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StockPrediction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StockPrices`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Predictor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Trainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProgramArguments`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Program`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ProgramActions enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following `ProgramActions` enumeration has been added to the solution to
    facilitate the use of a strongly typed and structured path for handling various
    actions the program performs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the case of this application, we only have two actions—`Training` and `Predicting`.
    However, as shown in previous chapters, you might also have a feature extraction
    step or maybe provide an evaluation step. This design pattern allows flexibility
    while also removing the **magic strings** problem mentioned at the beginning of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The CommandLineParser class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CommandLineParser` class provides a program-agnostic parser for handling
    command-line arguments. In previous chapters, we were manually parsing the indexes
    and mapping those values to arguments. On the other hand, this approach creates
    a flexible, easy-to-maintain and structured response object that maps arguments
    directly to the properties. Let''s now dive into the class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the function prototype:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The use of generics (that is, `T`) creates a flexible approach to making this
    method unconstrained to just this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we test for `null` arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we test for empty arguments and let the user know default values are
    going to be used instead of failing, as in previous chapters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After null and empty checks are performed, we then perform a multiple of two
    checks since all arguments are pairs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing, we then create an object of the `T`type using the `Activator.CreateInstance`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that, when creating class objects, the constructor has no arguments as
    this call would throw an exception if so. If you create an object with constructor
    parameters and without a parameterless constructor, use the overload of `Activator.CreateInstance`
    and pass in the required parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we utilize reflection to grab all of the properties of the `T` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have both the generic object created and the properties of that
    object, we then loop through each of the argument key/value pairs and set the
    property in the object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note the special case for the `IsEnum` function to handle our previously covered
    `ProgramActions` enumeration. Since a string value cannot be automatically converted
    to an enumeration, we needed to handle the string-to-enumeration conversion specifically
    with the `Enum.Parse` method. As written, the enumeration handler is generic if
    you add more enumerations to the `T` type.
  prefs: []
  type: TYPE_NORMAL
- en: The BaseML class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `BaseML` class for this application has been streamlined to simply instantiate
    the `MLContext` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The StockPrediction class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `StockPrediction` class is the container for our prediction values, as
    defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `StockForecast` property will hold our predicted stock values based on the
    model training and submitted value to the prediction engine. The `LowerBound`
    and `UpperBound` values hold the lowest and highest estimated values respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The StockPrices class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `StockPrices` class contains our single floating-point value holding the
    stock price. To keep the code cleaner when populating the values, a constructor
    accepting the stock price value has been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The Predictor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Predictor` class, in comparison to previous chapters, has been streamlined
    and adapted to support forecasting:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we adjust the `Predict` method to accept the newly defined `ProgramArguments`
    class object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we update the model `file.Exists` check to utilize the `arguments` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we also update the prediction filename reference to the utilize
    the `arguments` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we also modify the model open call to utilize the `arguments` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create the Time Series Engine object with our `StockPrices` and `StockPrediction`
    types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we read the stock price prediction file into a string array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we iterate through each input, call the prediction engine, and display
    the estimated values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The Trainer class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Trainer` class, akin to the `Predictor` class, received both streamlining
    and changes to account for the ML.NET forecasting algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, update the function prototype to take the `ProgramArguments` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we update the training file check to utilize the `argument` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we then update the testing file check to utilize the `argument`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we load the `StockPrices` values from the training file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create the `Forecasting` object and utilize the `nameof`C# feature
    to avoid magic string references:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The input and output column name references are as we have seen in previous
    chapters. The `windowSize` property is the duration between the data points in
    the training set. For this application, we are using `7` to indicate a week's
    duration. The `seriesLength`property indicates the total duration of the dataset
    in this case. The `horizon` property indicates how many predicted values should
    be calculated when the model is run. In our case, we are asking for `5` predicted
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we transform the model with the training data, call the `CreateTimeSeriesEngine`
    method, and write the model to disk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The ProgramArguments class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This new class, as referred to earlier in this section, provides the one-to-one
    mapping of arguments to properties used throughout the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the properties that map directly to the command-line arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we populate default values for the properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Unlike previous chapters, if any property was not set as expected, the program
    would fail. This is fine for the developer experience; however, in the real world,
    end users will more than likely attempt to just run the application without any
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The Program class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `Program` class, the code has been simplified to utilize the new
    `CommandLineParser` class discussed earlier in this chapter. With the use of the
    `CommandLineParser` class, all of the actions have been switched to utilize strongly-typed
    enumerations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, while relatively simplistic, clearing the screen of any previous run
    data is an improved UX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use our new `CommandLineParser` class and associated `ParseArguments`
    method to create a strongly-typed argument object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We then can use a simplified and strongly typed switch case to handle our two
    actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the application, the process is nearly identical to the sample application
    in [Chapter 3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml), *Regression Model*,
    with the addition of passing in the test dataset when training:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the application without any arguments to train the model, we use the
    following step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the application to make predicitons based on the included prediction
    data, we use the following step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Feel free to modify the values and see how the prediction changes based on
    the dataset that the model was trained on. A few areas of experimentation from
    this point might be to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Tweak the hyperparameters reviewed in the `Trainer` class, such as the `windowSize`,
    `seriesLength`, or `horizon` properties, to see how accuracy is affected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add significantly more data points—this may utilize a data feed of your favorite
    stock you watch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring additional production application enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have completed our deep dive, there are a couple of additional elements
    to possibly further enhance the application. A few ideas are discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging utilizing NLog ([https://nlog-project.org/](https://nlog-project.org/))
    or a similar open source project is highly recommended as your application complexity
    increases. This will allow you to log to a file, console, or third-party logging
    solution such as Loggly at varying levels. For instance, if you deploy this application
    to a customer, breaking down the error level to at least Debug, Warning, and Error
    will be helpful when debugging issues remotely.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Reflection further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As noted earlier in this section to create flexibility and adaptability, we
    utilized `Reflection` to parse the command-line arguments. You could take this
    a step further and replace the switch case statement/standard flow in the `Program`
    class with an entirely reflection-based approach, meaning for every action defined
    in the application, it could inherit from an abstract `BaseAction` class and at
    runtime, based on the argument, call the appropriate class. For every new action,
    simply adding a new entry to the `ProgramActions` enumeration and then defining
    a class with that enumeration would be all that is required.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a real-world scenario, the data provided to run predictions will more than
    likely come from a database. This database, whether it is a Postgres, SQL Server,
    or SQLite database (to name a few), can be accessed with Microsoft's Entity Framework
    Core or with ML.NET's built-in database loader method—`CreateDatabaseLoader`.
    This loader is akin to how we have loaded data from enumerable or text files with
    the extra steps of injecting SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: In a production scenario, given Entity Framework Core's performance and ability
    to use LINQ instead of plaintext over ML.NET's implementation (at the time of
    this writing), I would recommend using Entity Framework if database sources are
    utilized.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have deep-dived into what goes into a production-ready
    .NET Core application architecture using the work performed in previous chapters
    as a foundation. We also created a brand new stock price estimator using the forecasting
    algorithm in ML.NET. Lastly, we discussed some ways to further enhance a .NET
    Core application (and production applications in general).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deep dive into creating a production-file-classification
    web application using ML.NET's binary classification and ASP.NET Core's framework.
  prefs: []
  type: TYPE_NORMAL
