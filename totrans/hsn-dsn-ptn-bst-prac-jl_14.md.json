["```py\n\"\"\"\n format(::Formatter, x::T) where {T <: Number}\n\nFormat a number `x` using the specified formatter.\nReturns a string.\n\"\"\"\nfunction format end\n```", "```py\nabstract type Formatter end\nstruct IntegerFormatter <: Formatter end\nstruct FloatFormatter <: Formatter end\n```", "```py\nformatter(::Type{T}) where {T <: Integer} = IntegerFormatter()\nformatter(::Type{T}) where {T <: AbstractFloat} = FloatFormatter()\nformatter(::Type{T}) where T = error(\"No formatter defined for type $T\")\n```", "```py\nusing Printf\nformat(nf::IntegerFormatter, x) = @sprintf(\"%d\", x)\nformat(nf::FloatFormatter, x) = @sprintf(\"%.2f\", x)\n```", "```py\nfunction test()\n    nf = formatter(Int)\n    println(format(nf, 1234))\n    nf = formatter(Float64)\n    println(format(nf, 1234))\nend\n```", "```py\nabstract type OS end\nstruct MacOS <: OS end\nstruct Windows <: OS end\n```", "```py\nabstract type Button end\nBase.show(io::IO, x::Button) = \n    print(io, \"'$(x.text)' button\")\n\nabstract type Label end\nBase.show(io::IO, x::Label) = \n    print(io, \"'$(x.text)' label\")\n```", "```py\n# Buttons\nstruct MacOSButton <: Button\n    text::String\nend\n\nstruct WindowsButton <: Button\n    text::String\nend\n\n# Labels\nstruct MacOSLabel <: Label\n    text::String\nend\n\nstruct WindowsLabel <: Label\n    text::String\nend\n```", "```py\n# Generic implementation using traits\ncurrent_os() = MacOS() # should get from system\nmake_button(text::String) = make_button(current_os(), text)\nmake_label(text::String) = make_label(current_os(), text)\n```", "```py\n# MacOS implementation\nmake_button(::MacOS, text::String) = MacOSButton(text)\nmake_label(::MacOS, text::String) = MacOSLabel(text)\n\n# Windows implementation\nmake_button(::Windows, text::String) = WindowsButton(text)\nmake_label(::Windows, text::String) = WindowsLabel(text)\n```", "```py\n# AppKey contains an app id and encryption key\nstruct AppKey\n    appid::String\n    value::UInt128\nend\n```", "```py\n# placeholder for AppKey object. \nconst appkey = Ref{AppKey}()\n```", "```py\nfunction construct()\n    global appkey\n    if !isassigned(appkey)\n        ak = AppKey(\"myapp\", rand(UInt128))\n        println(\"constructing $ak\")\n        appkey[] = ak\n    end\n    return nothing\nend\n```", "```py\nfunction test_multithreading()\n    println(\"Number of threads: \", Threads.nthreads())\n    global appkey\n    Threads.@threads for i in 1:8\n        construct()\n    end\nend\n```", "```py\nconst appkey_lock = Ref(ReentrantLock())\n```", "```py\ncar = Car() |>\n    add(Engine(\"4-cylinder 1600cc Engine\")) |>\n    add(Wheels(\"4x 20-inch wide wheels\")) |>\n    add(Chassis(\"Roadster Chassis\"))\n```", "```py\nfunction add(wheels::Wheels)\n    return function (c::Car)\n        c.wheels = wheels\n        return c\n    end\nend\n```", "```py\nmutable struct Account\n    id::Int\n    balance::Float64\nend\n\nstruct Customer\n    name::String\n    savingsAccount::Account\n    checkingAccount::Account\nend\n```", "```py\nfunction sample_customers()\n    a1 = Account(1, 100.0)\n    a2 = Account(2, 200.0)\n    c1 = Customer(\"John Doe\", a1, a2)\n\n    a3 = Account(3, 300.0)\n    a4 = Account(4, 400.0)\n    c2 = Customer(\"Brandon King\", a3, a4)\n\n    return [c1, c2]\nend\n```", "```py\nfunction test(copy_function::Function)\n    println(\"--- testing \", string(copy_function), \" ---\")\n    customers = sample_customers()\n    c = copy_function(customers)\n    c[1].checkingAccount.balance += 500\n    println(\"orig: \", customers[1].checkingAccount.balance)\n    println(\"new: \", c[1].checkingAccount.balance)\nend\n```", "```py\nmutable struct DepositRequest\n    id::Int\n    amount::Float64\nend\n```", "```py\n@enum Status CONTINUE HANDLED\n\nfunction update_account_handler(req::DepositRequest) \n    println(\"Deposited $(req.amount) to account $(req.id)\")\n    return CONTINUE\nend\n\nfunction send_gift_handler(req::DepositRequest)\n    req.amount > 100_000 && \n        println(\"=> Thank you for your business\")\n    return CONTINUE\nend\n\nfunction notify_customer(req::DepositRequest)\n    println(\"deposit is finished\")\n    return HANDLED\nend\n```", "```py\nhandlers = [\n    update_account_handler, \n    send_gift_handler,\n    notify_customer\n]\n```", "```py\nfunction apply(req::DepositRequest, handlers::AbstractVector{Function})\n    for f in handlers\n        status = f(req)\n        status == HANDLED && return nothing\n    end\nend\n```", "```py\nfunction test()\n    println(\"Test: customer depositing a lot of money\")\n    amount = 300_000\n    apply(DepositRequest(1, amount), handlers)\n\n    println(\"\\nTest: regular customer\")\n    amount = 1000\n    apply(DepositRequest(2, amount), handlers)\nend\n```", "```py\nabstract type Widget end\n\nmutable struct TextField <: Widget\n    id::Symbol\n    value::String\nend\n```", "```py\n# extract numeric value from a text field\nget_number(t::TextField) = parse(Float64, t.value)\n\n# set text field from a numeric value\nfunction set_number(t::TextField, x::Real)\n    println(\"* \", t.id, \" is being updated to \", x)\n    t.value = string(x)\n    return nothing\nend\n```", "```py\nBase.@kwdef struct App\n    amount_field::TextField\n    interest_rate_field::TextField\n    interest_amount_field::TextField\nend\n```", "```py\nfunction on_change_event(widget::Widget)\n    notify(app, widget)\nend\n```", "```py\n# Mediator logic - handling changes to the widget in this app\nfunction notify(app::App, widget::Widget)\n    if widget in (app.amount_field, app.interest_rate_field)\n        new_interest = get_number(app.amount_field) * get_number(app.interest_rate_field)/100\n        set_number(app.interest_amount_field, new_interest)\n    end\nend\n```", "```py\nfunction test()\n    # Show current state before testing\n    print_current_state()\n\n    # double principal amount from 100 to 200\n    set_number(app.amount_field, 200)\n    on_change_event(app.amount_field)\n    print_current_state()\nend\n```", "```py\nstruct Post\n    title::String\n    content::String\nend\n\nstruct Blog\n    author::String\n    posts::Vector{Post}\n    date_created::DateTime\nend\n```", "```py\nfunction Blog(author::String, post::Post)\n    return Blog(author, [post], now())\nend\n```", "```py\nversion_count(blog::Blog) = length(blog.posts)\n```", "```py\ncurrent_post(blog::Blog) = blog.posts[end]\n```", "```py\nfunction update!(blog::Blog; \n                 title = nothing, \n                 content = nothing)\n    post = current_post(blog)\n    new_post = Post(\n        something(title, post.title),\n        something(content, post.content)\n    )\n    push!(blog.posts, new_post)\n    return new_post\nend\n```", "```py\nfunction undo!(blog::Blog)\n    if version_count(blog) > 1\n        pop!(blog.posts)\n        return current_post(blog)\n    else\n        error(\"Cannot undo... no more previous history.\")\n    end\nend\n```", "```py\nfunction test()\n    blog = Blog(\"Tom\", Post(\"Why is Julia so great?\", \"Blah blah.\"))\n    update!(blog, content = \"The reasons are...\")\n\n    println(\"Number of versions: \", version_count(blog))\n    println(\"Current post\")\n    println(current_post(blog))\n\n    println(\"Undo #1\")\n    undo!(blog)\n    println(current_post(blog))\n\n    println(\"Undo #2\") # expect failure\n    undo!(blog)\n    println(current_post(blog))\nend\n```", "```py\nmutable struct Account\n    id::Int\n    customer::String\n    balance::Float64\nend\n```", "```py\nconst OBSERVERS = IdDict{Account,Vector{Function}}();\n```", "```py\nfunction register(a::Account, f::Function)\n    fs = get!(OBSERVERS, a, Function[])\n    println(\"Account $(a.id): registered observer function $(Symbol(f))\")\n    push!(fs, f)\nend\n```", "```py\nfunction Base.setproperty!(a::Account, field::Symbol, value)\n    previous_value = getfield(a, field)\n    setfield!(a, field, value)\n    fs = get!(OBSERVERS, a, Function[])\n    foreach(f -> f(a, field, previous_value, value), fs)\nend\n```", "```py\nfunction test_observer_func(a::Account, field::Symbol, previous_value, current_value)\n    println(\"Account $(a.id): $field was changed from $previous_value to $current_value\")\nend\n```", "```py\nfunction test()\n    a1 = Account(1, \"John Doe\", 100.00)\n    register(a1, test_observer_func)\n    a1.balance += 10.00\n    a1.customer = \"John Doe Jr.\"\n    return nothing\nend\n```", "```py\nabstract type AbstractState end\n\nstruct ListeningState <: AbstractState end\nstruct EstablishedState <: AbstractState end\nstruct ClosedState <: AbstractState end\n\nconst LISTENING = ListeningState()\nconst ESTABLISHED = EstablishedState()\nconst CLOSED = ClosedState()\n```", "```py\nstruct Connection{T <: AbstractState,S}\n    state::T\n    conn::S\nend\n```", "```py\n# Use multiple dispatch \nsend(c::Connection, msg) = send(c.state, c.conn, msg)\n\n# Implement `send` method for each state\nsend(::ListeningState, conn, msg) = error(\"No connection yet\")\nsend(::EstablishedState, conn, msg) = write(conn, msg * \"\\n\")\nsend(::ClosedState, conn, msg) = error(\"Connection already closed\")\n```", "```py\nfunction test(state, msg)\n    c = Connection(state, stdout)\n    try \n        send(c, msg)\n    catch ex\n        println(\"$(ex) for message '$msg'\")\n    end\n    return nothing\nend\n```", "```py\nfunction test()\n    test(LISTENING, \"hello world 1\")\n    test(CLOSED, \"hello world 2\")\n    test(ESTABLISHED, \"hello world 3\")\nend\n```", "```py\nabstract type Algo end\nstruct Memoized <: Algo end\nstruct Iterative <: Algo end\n```", "```py\nusing Memoize\n@memoize function _fib(n)\n    n <= 2 ? 1 : _fib(n-1) + _fib(n-2)\nend\n\nfunction fib(::Memoized, n)\n    println(\"Using memoization algorithm\")\n    _fib(n)\nend\n```", "```py\nfunction fib(algo::Iterative, n) \n    n <= 2 && return 1\n    prev1, prev2 = 1, 1\n    local curr\n    for i in 3:n\n        curr = prev1 + prev2\n        prev1, prev2 = curr, prev1\n    end\n    return curr\nend\n```", "```py\nfib(Memoized(), 10)\nfib(Iterative(), 10)\n```", "```py\nfunction fib(n)\n    algo = n > 50 ? Memoized() : Iterative()\n    return fib(algo, n)\nend\n```", "```py\nfunction run(data::DataFrame, response::Symbol, predictors::Vector{Symbol})\n    train, test = split_data(data, 0.7)\n    model = fit(train, response, predictors)\n    validate(test, model, response)\nend\n```", "```py\nfunction run2(data::DataFrame, response::Symbol, predictors::Vector{Symbol};\n            fit = fit, split_data = split_data, validate = validate)\n    train, test = split_data(data, 0.7)\n    model = fit(train, response, predictors)\n    validate(test, model, response)\nend\n```", "```py\nusing GLM\n\nfunction fit_glm(df::DataFrame, response::Symbol, predictors::Vector{Symbol})\n    formula = Term(response) ~ +(Term.(predictors)...)\n    return glm(formula, df, Normal(), IdentityLink())\nend\n```", "```py\nstruct MyArray{T} <: AbstractArray{T,1}\n    data::Node{T}\nend\n```", "```py\nfunction Base.size(ar::MyArray) \n    n = ar.data\n    count = 0\n    while next(n) !== nothing\n        n = next(n)\n        count += 1\n    end\n    return (1 + count, 1)\nend\n```", "```py\nfunction Base.getindex(ar::MyArray, idx::Int)\n    n = ar.data\n    for i in 1:(idx-1)\n        next_node = next(n)\n        next_node === nothing && throw(BoundsError(n.data, idx))\n        n = next_node\n    end\n    return value(n)\nend\n```", "```py\nstruct Holding\n    symbol::String\n    qty::Int\n    price::Float64\nend\n```", "```py\nstruct Portfolio\n    symbol::String\n    name::String\n    stocks::Vector{Holding}\n    subportfolios::Vector{Portfolio}\nend\n```", "```py\nfunction sample_portfolio()\n    large_cap = Portfolio(\"TOMKA\", \"Large Cap Portfolio\", [\n        Holding(\"AAPL\", 100, 275.15), \n        Holding(\"IBM\", 200, 134.21), \n        Holding(\"GOOG\", 300, 1348.83)])\n\n    small_cap = Portfolio(\"TOMKB\", \"Small Cap Portfolio\", [\n        Holding(\"ATO\", 100, 107.05), \n        Holding(\"BURL\", 200, 225.09), \n        Holding(\"ZBRA\", 300, 257.80)])\n\n    p1 = Portfolio(\"TOMKF\", \"Fund of Funds Sleeve\", [large_cap, small_cap])\n    p2 = Portfolio(\"TOMKG\", \"Special Fund Sleeve\", [Holding(\"C\", 200, 76.39)])\n    return Portfolio(\"TOMZ\", \"Master Fund\", [p1, p2])\nend\n```", "```py\nmarket_value(s::Holding) = s.qty * s.price\n```", "```py\nmarket_value(p::Portfolio) = \n    mapreduce(market_value, +, p.stocks, init = 0.0) +\n    mapreduce(market_value, +, p.subportfolios, init = 0.0)\n```"]