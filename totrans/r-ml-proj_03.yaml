- en: Implementing a Jokes Recommendation Engine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现笑话推荐引擎
- en: 'I am sure this is something you have experienced as well: while shopping for
    a cellphone on Amazon, you are also shown some product recommendations of mobile
    accessories, such as screen guards and phone cases. Not very surprisingly, most
    of us end up buying one or more of these recommendations! The primary purpose
    of a recommendation engine in an e-commerce site is to lure buyers into purchasing
    more from vendors. Of course, this is no different from a salesperson trying to
    up-sell or cross-sell to customers in a physical store.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信这也是你经历过的事情：在亚马逊上购买手机时，你也会看到一些手机配件的推荐，如屏幕保护膜和手机壳。不出所料，我们大多数人最终都会购买这些推荐中的一个或多个！电子商务网站上的推荐引擎的主要目的是吸引买家从供应商那里购买更多商品。当然，这与销售人员试图在实体店向客户推销或交叉销售并无不同。
- en: You may recollect the Customers Who Bought This Item Also Bought This heading
    on Amazon (or any e-commerce site) where recommendations are shown. The aim of
    these recommendations is to get you to buy not just one product but a product
    combo, therefore pushing the sales revenues in an upward direction. Recommendations
    on Amazon are so successful that McKinsey estimated that a whopping 35% of the
    overall sales made on Amazon is due to their recommendations!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得在亚马逊（或任何电子商务网站）上看到的“购买此商品的用户还购买了此商品”的标题，其中显示了推荐。这些推荐的目的是让你不仅仅购买一个产品，而是购买一个产品组合，从而推动销售额向上增长。亚马逊的推荐非常成功，麦肯锡估计，亚马逊总销售额中有高达35%是由于他们的推荐！
- en: 'In this chapter, we will learn about the theory and implementation of a recommendation
    engine to suggest jokes to users. To do this, we use the Jester''s jokes dataset
    that is available in the `recommenderlab` library of R. We will cover the following
    major topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于推荐引擎的理论和实现，以向用户推荐笑话。为此，我们使用R的`recommenderlab`库中可用的Jester笑话数据集。我们将涵盖以下主要主题：
- en: Fundamental aspects of recommendation engines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐引擎的基本方面
- en: Understanding the Jokes recommendation problem and the dataset
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解笑话推荐问题和数据集
- en: Recommendation system using an item-based collaborative filtering technique
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于物品的协同过滤技术的推荐系统
- en: Recommendation system using a user-based collaborative filtering technique
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于用户的协同过滤技术的推荐系统
- en: Recommendation system using an association-rule mining technique
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关联规则挖掘技术的推荐系统
- en: Content-based recommendation engine
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于内容的推荐引擎
- en: Hybrid recommendation system for Jokes recommendation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合笑话推荐系统
- en: Fundamental aspects of recommendation engines
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐引擎的基本方面
- en: 'While the basic intent of showing recommendations is to push sales, they actually
    serve just beyond the better sales concept. Highly personalized content is something
    recommendation engines are able to deliver. This essentially means that recommendation
    engines on a retail platform such as Amazon are able to offer the right content
    to the right customer at the right time through the right channel. It makes sense
    to provide personalized content; after all, there is no point in showing an irrelevant
    product to a customer. Also, with the lower attention spans of customers, businesses
    want to be able to maximize their selling opportunities by showing the right products
    and encouraging them to buy the right products. At a very high level, personalized
    content recommendation is achieved in AI in several ways:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然显示推荐的基本意图是推动销售，但它们实际上服务的概念远不止于此。高度个性化的内容是推荐引擎能够提供的东西。这本质上意味着零售平台（如亚马逊）上的推荐引擎能够通过正确的渠道在正确的时间向正确的客户提供正确的内容。提供个性化内容是有意义的；毕竟，向客户展示无关的产品是没有意义的。此外，随着客户注意力集中时间的缩短，企业希望通过展示正确的产品并鼓励他们购买正确的产品来最大化他们的销售机会。在人工智能中，个性化内容推荐可以通过以下几种方式实现：
- en: '**Mapping similar products that were bought together**:Let''s take an example
    of an online shopper who searched for school bags on a shopping website. Very
    likely, the shopper would be interested in buying additional school-related items
    when buying a school bag. Therefore, displaying school bags along with notebooks,
    pencils, pens, and pencil cases ensures a higher probability of additional sales.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射一起购买的产品**：让我们以一个在购物网站上搜索书包的在线购物者为例。购物者很可能在购买书包时还会购买其他与学校相关的物品。因此，将书包与笔记本、铅笔、钢笔和笔盒一起展示，可以确保更高的额外销售概率。'
- en: '**Recommendations based on customer demographics**:Showing high-end phones
    and stylish phone accessories as recommended products to conservative middle class
    customers, who generally look for steal deals, may not fetch a big upswing in
    sales of the recommended products. Instead, such customers might find these irrelevant
    recommendations to be annoying, therefore impacting their loyalty.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于客户人口统计的推荐**：向保守的中产阶级客户推荐高端手机和时尚的手机配件作为推荐产品，他们通常寻找划算的交易，可能不会大幅提升推荐产品的销售额。相反，这样的客户可能会觉得这些不相关的推荐令人烦恼，从而影响他们的忠诚度。'
- en: '**Recommendations based on similarities between customers**:Product recommendations
    to a customer are based on the products purchased or liked by other, similar customers.
    For example, recommending a newly-arrived cosmetic product to young women living
    in urban locations. The recommendation in this case is not just because of the
    attributes of the customer but because other customers of a similar type have
    bought this product. As the item grows in popularity among similar individuals,
    the product is chosen as the one to be recommended.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于客户之间相似性的推荐**：向客户推荐的产品是基于其他类似客户购买或喜欢的产品。例如，向居住在城市的年轻女性推荐新到的化妆品产品。在这种情况下，推荐不仅仅是因为客户的属性，还因为类似类型的其他客户购买了这款产品。随着该产品在类似个体中的流行，该产品被选为推荐的产品。'
- en: '**Recommendations based on product similarities**:If you search for a laptop
    backpack of a particular brand, along with the results of the searched item, you
    are also shown other brand laptop backpacks as recommendations. This recommendation
    is purely based on the similarity between the products.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于产品相似性的推荐**：如果您搜索特定品牌的笔记本电脑背包，除了搜索结果外，还会显示其他品牌笔记本电脑背包的推荐。这种推荐完全基于产品之间的相似性。'
- en: '**Recommendations based on the historical purchase profile of customers**:If
    a customer has always purchased a particular brand of jeans, they are shown recommendations
    of newer varieties of jeans of the particular brand they tend to purchase. These
    recommendations are purely based on the historical purchases of the customer.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于客户历史购买档案的推荐**：如果客户一直购买某个品牌的牛仔裤，他们会看到该品牌他们倾向于购买的牛仔裤的新品种的推荐。这些推荐完全基于客户的历史购买。'
- en: '**Hybrid recommendations**:It is possible that one or more recommendation approaches
    can be combined to arrive at the best recommendations for a customer. For example,
    a recommendation list can be arrived by using customer preferences inferred from
    the historical data as well as from the demographics information of the customer.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合推荐**：可能可以将一个或多个推荐方法结合起来，为顾客提供最佳的推荐。例如，可以通过使用从历史数据中推断出的客户偏好以及客户的人口统计信息来生成推荐列表。'
- en: Repurchase campaigns, newsletter recommendations, rebinding the sales from abandoned
    carts, customized discounts and offers, and smoothened browsing experience of
    e-commerce sites are some of the applications of recommendation systems in the
    online retail industry.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在线零售行业中，推荐系统的一些应用包括回购活动、新闻通讯推荐、重新绑定被遗弃购物车的销售额、定制折扣和优惠，以及电子商务网站的流畅浏览体验。
- en: 'Due to several prevalent use cases, it might appear that recommender systems
    are used in only in the e-commerce industry. However, this is not true. The following
    are some of the use cases of recommender systems in non e-commerce domains:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在几个常见的用例，可能会给人一种印象，即推荐系统仅在电子商务行业中使用。然而，事实并非如此。以下是一些推荐系统在非电子商务领域的用例：
- en: In the pharmaceutical industry, recommender systems are applied to identify
    drugs patients with certain characteristics that they will respond better to
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在制药行业中，推荐系统被应用于识别具有特定特征的药物，这些药物对患者的治疗效果会更好
- en: Stocks recommendation are done based on the stock picks of a successful group
    of people
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股票推荐是基于一组成功人士的股票选择进行的
- en: YouTube and online media use a recommendation engine to serve content that is
    similar to the content currently being watched by the user
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YouTube和在线媒体使用推荐引擎为用户当前观看的内容提供相似的内容
- en: Tourism recommendations are based on tourist spots that the user or similar
    users have visited
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旅游推荐是基于用户或类似用户访问过的旅游景点
- en: Identifying skills and personality traits of future employees in various roles
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别未来员工在不同角色中的技能和个性特征
- en: In the culinary sciences, dishes that go pair together can be explored through
    the application of recommender systems
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在烹饪科学中，可以通过应用推荐系统来探索可以搭配的菜肴。
- en: The list can grow to an enormous size, given that use cases for recommendation
    systems exist in almost every domain.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于推荐系统的用例几乎存在于每个领域，因此这个列表可以增长到巨大的规模。
- en: Now that we have a basic understanding of the concept of recommendation systems
    and the value it offers to business, we can now move to our next section, where
    we attempt to understand the Jester's Jokes recommendation dataset and the problems
    that could be solved by building a recommendation engine.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对推荐系统的概念及其对商业的价值有了基本的了解，我们可以进入下一部分，尝试理解Jester's Jokes推荐数据集以及构建推荐引擎可能解决的问题。
- en: Recommendation engine categories
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐引擎类别
- en: 'Prior to implementing our first recommender system, let''s explore the types
    of recommender systems in detail. The following diagram shows the broad categories
    of recommender systems:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施我们的第一个推荐系统之前，让我们详细探讨推荐系统的类型。以下图表显示了推荐系统的广泛类别：
- en: '![](img/1fadf08c-415c-415c-81d3-ef14bdba4077.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1fadf08c-415c-415c-81d3-ef14bdba4077.png)'
- en: Recommender system categories
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统类别
- en: Each of the techniques shown in the diagram may be used to build a recommender
    system model that is capable of suggesting jokes to the users. Let's briefly explore
    the various recommendation engine categories.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中展示的每种技术都可以用来构建一个能够向用户推荐笑话的推荐系统模型。让我们简要地探讨各种推荐引擎类别。
- en: Content-based filtering
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于内容的过滤
- en: Cognitive filtering, or content-based filtering, recommends items by comparing
    product attributes and customer profile attributes. The attributes of each product
    is represented as a set of tags or terms—typically the words that occur in a product
    description document. The customer profile is represented with the same terms
    and built by analyzing the content of products that have been seen or rated by
    the customer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 认知过滤，或基于内容的过滤，通过比较产品属性和客户档案属性来推荐物品。每个产品的属性表示为一组标签或术语——通常是出现在产品描述文档中的单词。客户档案用相同的术语表示，并通过分析客户查看或评分过的产品内容来构建。
- en: Collaborative filtering
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤
- en: Social filtering, or collaborative filtering, filters information by using the
    recommendations of other people. The principle behind collaborative filtering
    is that the customers who have appreciated the same items in the past have a high
    probability of displaying similar interests in the future as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 社会过滤，或称为协同过滤，通过使用其他人的推荐来过滤信息。协同过滤背后的原理是，过去欣赏过相同物品的客户在未来也有很高的可能性表现出相似的兴趣。
- en: We generally ask for reviews and recommendation from friends prior to watching
    a movie. A recommendation from a friend is more accepted than recommendations
    from others as we share some interests with our friends. This is the same principle
    on which collaborative filtering works.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常在观看电影之前向朋友寻求评论和推荐。朋友的推荐比其他人的推荐更容易被接受，因为我们与朋友有共同兴趣。这就是协同过滤工作的相同原理。
- en: 'Collaborative filtering can be further classified into memory-based and model-based
    as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 协同过滤可以进一步分为基于记忆和基于模型两种，如下所示：
- en: '**Memory-based**: In this method, user rating information is used to compute
    the likeness between users or items. This computed likeness is then used to come
    up with recommendations.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于记忆**：在此方法中，使用用户评分信息来计算用户或物品之间的相似度。然后使用这种计算出的相似度来提出推荐。'
- en: '**Model based**: Data mining methods are applied to recognize patterns in the
    data, and the learned patterns are then used to generate recommendations.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于模型**：数据挖掘方法被应用于识别数据中的模式，然后使用学习到的模式来生成推荐。'
- en: Hybrid filtering
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合过滤
- en: In this class of recommendation systems, we combine more than one type of recommendation
    system to come up with final recommendations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这类推荐系统中，我们结合了多种类型的推荐系统来得出最终的推荐。
- en: Getting started
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: To get started, you will have to download the supporting files from the GitHub
    link.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要从GitHub链接下载支持文件。
- en: Understanding the Jokes recommendation problem and the dataset
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解笑话推荐问题和数据集
- en: 'Dr. Ken Goldberg and his colleagues, Theresa Roeder, Dhruv Gupta, and Chris
    Perkins, introduced a dataset to the world through their paper *Eigentaste: A
    Constant Time Collaborative Filtering Algorithm*, which is pretty popular in the
    recommender-systems domain. The dataset is named the Jester''s jokes dataset.
    To create it, a number of users are presented with several jokes and they are
    asked to rate them. The ratings provided by the users for the various jokes formed
    the dataset. The data in this dataset is collected between April 1999 and May
    2003\. The following are the attributes of the dataset:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 肯·戈德堡博士及其同事，特蕾莎·罗德、德鲁夫·古普塔和克里斯·珀金斯，通过他们的论文《Eigentaste：一种常数时间协同过滤算法》向世界介绍了一个数据集，这篇论文在推荐系统领域相当受欢迎。这个数据集被称为
    Jester 笑话数据集。为了创建它，向许多用户展示了几个笑话，并要求他们进行评分。用户提供的各种笑话的评分构成了数据集。该数据集的数据收集于 1999 年
    4 月至 2003 年 5 月之间。以下是该数据集的属性：
- en: Over 11,000,000 ratings of 150 jokes from 79,681 users
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 79,681 个用户的 150 个笑话的超过 11,000,000 个评分
- en: 'Each row is a user (Row 1 = User #1)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '每一行代表一个用户（行 1 = 用户 #1）'
- en: 'Each column is a joke (Column 1 = Joke #1)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '每一列代表一个笑话（列 1 = 笑话 #1）'
- en: Ratings are given as real values from -10.00 to +10.00; -10 being the lowest
    possible rating and 10 being the highest
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评分以从 -10.00 到 +10.00 的实数值给出；-10 是最低可能的评分，10 是最高评分
- en: 99 corresponds to a null rating
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 99 代表空评分
- en: The `recommenderlab` package in R provides a subset of this original dataset
    provided by Dr. Ken Goldberg's group. We will make use of this subset for our
    projects covered in this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的 `recommenderlab` 包提供了由肯·戈德堡博士小组提供的原始数据集的一个子集。我们将利用这个子集来完成本章中涉及的项目。
- en: The `Jester5k` dataset provided in the `recommenderlab` library contains a 5,000
    x 100 rating matrix (5,000 users and 100 jokes) with ratings between -10.00 and
    +10.00\. All selected users have rated 36 or more jokes. The dataset is in the
    `realRatingMatrix` format. This is a special matrix format that the `recommenderlab`
    expects the data to be in, to apply the various functions that are packaged in
    the library.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`recommenderlab` 库中提供的 `Jester5k` 数据集包含一个 5,000 x 100 的评分矩阵（5,000 个用户和 100
    个笑话），评分介于 -10.00 到 +10.00 之间。所有选定的用户都评了 36 个或更多的笑话。该数据集以 `realRatingMatrix` 格式存在。这是
    `recommenderlab` 预期数据应采用的特殊矩阵格式，以便应用库中打包的各种函数。'
- en: 'As we are already aware, **exploratory data analysis** (**EDA**) is the first
    step for any data science project. Going by this principle, let''s begin by reading
    the data, and then proceed with the EDA step on the dataset:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，**探索性数据分析**（**EDA**）是任何数据科学项目的第一步。根据这一原则，让我们首先读取数据，然后对数据集进行 EDA 步骤：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will result in the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The data structure output is pretty self explanatory and we see it provides
    empirical evidence for the details we have discussed already. Let''s continue
    our EDA further:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构输出相当直观，我们看到它为我们已经讨论过的细节提供了经验证据。让我们继续我们的 EDA：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will result in the following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will result in the following output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will print the summary of the dataset using the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令打印数据集的摘要：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will result in the following output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will now plot the histogram:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将绘制直方图：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will result in the following output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/e25c8393-971a-4c48-8978-0889a87024b8.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e25c8393-971a-4c48-8978-0889a87024b8.png)'
- en: From the output, we see a somewhat normal distribution. It can also be seen
    that the positive ratings outnumber the negative ratings.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到一种相对正常的分布。我们还可以看到，正面评分的数量超过了负面评分的数量。
- en: 'The `Jester5K` dataset also provides a character vector called `JesterJokes`.
    The vector is of length 100\. These are the actual 100 jokes among others that
    were shown to the users to get the ratings. We could examine the jokes with the
    following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `Jester5K` dataset also provides a character vector called `JesterJokes`.
    The vector is of length 100\. These are the actual 100 jokes among others that
    were shown to the users to get the ratings. We could examine the jokes with the
    following command:'
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will result in the following output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Based on the 5,000 user ratings we have, we could perform additional EDA to
    identify the joke that is rated as best by the users. This can be done through
    the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们拥有的 5,000 个用户评分，我们可以进行额外的 EDA 来识别用户评分最高的笑话。这可以通过以下代码完成：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will result in the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We could perform additional EDA to visualize the univariate and multivariate
    analysis. This exploration will help us understand each of the variables in detail
    as well as the relationship between them. While we do not delve deep into each
    of these aspects, here are some thoughts that can be explored:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行额外的 EDA（探索性数据分析）来可视化单变量和多变量分析。这次探索将帮助我们详细了解每个变量以及它们之间的关系。虽然我们不会深入探讨这些方面的每一个，但以下是一些可以探索的想法：
- en: Exploring the users who always provide high ratings to most jokes
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索总是对大多数笑话给出高评分的用户
- en: Correlation between the ratings provided to jokes
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对笑话提供的评分之间的相关性
- en: Identification of users that are very critical
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别非常挑剔的用户
- en: Exploring the most popular jokes or least popular jokes
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索最受欢迎或最不受欢迎的笑话
- en: Identifying the jokes with the fewest ratings and identifying the associations
    between them
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别评分最少的笑话以及它们之间的关联
- en: Converting the DataFrame
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换 DataFrame
- en: We are going to use functions from an R library called `recommenderlab` to build
    recommendation engine projects in this chapter. Irrespective of the category of
    recommendation system we implement, there are some prerequisites that the dataset
    needs to satisfy to be able to apply the `recommenderlab` functions. The prebuilt
    `recommenderlab` functions for collaborative filtering expects `realRatingMatrix`
    to be supplied as input. In our case, the `Jester5k` dataset is already in this
    format, therefore, we could directly use this matrix to apply the `recommenderlab`
    functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用名为 `recommenderlab` 的 R 库中的函数来构建推荐引擎项目。无论我们实现哪种推荐系统类别，数据集都需要满足一些先决条件，以便能够应用
    `recommenderlab` 函数。用于协同过滤的预构建 `recommenderlab` 函数期望输入 `realRatingMatrix`。在我们的案例中，`Jester5k`
    数据集已经处于这种格式，因此，我们可以直接使用这个矩阵来应用 `recommenderlab` 函数。
- en: 'In case, we were to have our data as a R DataFrame and if we intend to convert
    into `realRatingMatrix`, the following steps may be performed:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的数据以 R DataFrame 的形式存在，并且我们打算将其转换为 `realRatingMatrix`，则可以执行以下步骤：
- en: 'Convert the DataFrame into an R matrix as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 DataFrame 转换为 R 矩阵，如下所示：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Convert the resultant matrix into `realRatingMatrix` with the help of the `as()`
    function as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `as()` 函数将结果矩阵转换为 `realRatingMatrix`，如下所示：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we assume that the name of the DataFrame is `df`, the code will convert
    it into a `realRatingMatrix` that can be used as input to the `recommenderlab`
    functions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设 DataFrame 的名称为 `df`，代码将将其转换为 `realRatingMatrix`，这可以作为 `recommenderlab`
    函数的输入。
- en: Dividing the DataFrame
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 划分 DataFrame
- en: 'Another prerequisite is to divide the dataset into train and test subsets.
    These subsets will be used in later sections to implement our recommendation systems
    and to measure the performance. The `evaluationScheme()` function from the `recommenderlab`
    library can be used to split the dataset into training and testing subsets. A
    number of user-specified parameters can be passed to this function. In the following
    code, `realRatingMatrix` is split according to an 80/20 training/testing split,
    with up to 20 items recommended for each user. Furthermore, we specify that any
    rating greater than `0` is to be considered a positive rating, in conformance
    with the predefined `[-10, 10]` rating scale. The `Jester5k` dataset can be divided
    into the train and test datasets with the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个先决条件是将数据集划分为训练集和测试集。这些子集将在后续部分用于实现我们的推荐系统并衡量性能。`recommenderlab` 库中的 `evaluationScheme()`
    函数可以用来将数据集划分为训练集和测试集。可以向此函数传递多个用户指定的参数。在下面的代码中，`realRatingMatrix` 根据一个 80/20 的训练/测试分割进行分割，每个用户最多推荐
    20 项。此外，我们指定任何大于 `0` 的评分应被视为正面评分，符合预定义的 `[-10, 10]` 评分范围。《Jester5k》数据集可以通过以下代码划分为训练集和测试集：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will result in the following output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From the output of the `evaluationScheme()` function, we can observe that the
    function yielded a single R object containing both the training and test subsets.
    This object will be used to define and evaluate a variety of recommender models.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `evaluationScheme()` 函数的输出中，我们可以观察到该函数生成了一个包含训练集和测试集的单一 R 对象。这个对象将被用来定义和评估各种推荐模型。
- en: Building a recommendation system with an item-based collaborative filtering
    technique
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于项目的协同过滤技术构建推荐系统
- en: 'The `recommenderlab` package of R offers the **item-based collaborative filtering**
    (**ITCF**) option to build a recommendation system. This is a very straightforward
    approach that just needs us to call the function and supply it with the necessary
    parameters. The parameters, in general, will have a lot of influence on the performance
    of the model; therefore, testing each parameter combination is the key to obtaining
    the best model for recommendations. The following are the parameters that can
    be passed to the `Recommender` function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: R的`recommenderlab`包提供了**基于物品的协同过滤**（**ITCF**）选项来构建推荐系统。这是一个非常直接的方法，只需要我们调用函数并提供必要的参数。通常，这些参数将对模型的表现产生很大影响；因此，测试每个参数组合是获得最佳推荐模型的关键。以下是可以传递给`Recommender`函数的参数：
- en: '**Data normalization**: Normalizing the ratings matrix is a key step in preparing
    the data for the recommendation engine. The process of normalization processes
    the ratings in the matrix by removing the rating bias. The possible values for
    this parameter are `NULL`, `Center`, and `Z-Score`.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据归一化**：归一化评分矩阵是准备数据以供推荐引擎使用的关键步骤。归一化过程通过消除评分偏差来处理矩阵中的评分。此参数的可能值是`NULL`、`Center`和`Z-Score`。'
- en: '**Distance**: This represents the type of similarity metric to be used within
    the model. The possible values for this parameter are Cosine similarity, Euclidean
    distance, and Pearson''s correlation.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**距离**：这表示模型中要使用的相似度度量类型。此参数的可能值是余弦相似度、欧几里得距离和皮尔逊相关系数。'
- en: 'With these parameter combinations, we could build and test 3 x 3 ITCF models. The
    basic intuition behind ITCF is that if a person likes item A, there is a good
    probability that they like item B as well, as long as items A and B are similar.
    It may be understood that the term *similar* does not indicate similarity between
    the items based on the item''s attributes, but, a similarity in user preferences,
    for example, a group of people that liked items A also liked item B. The following
    diagram shows the working principle of ITCF:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些参数组合，我们可以构建和测试3x3的ITCF模型。ITCF背后的基本直觉是，如果一个人喜欢物品A，那么他们也很可能喜欢物品B，只要A和B是相似的。这里的“相似”一词并不表示基于物品属性的相似性，而是指用户偏好的相似性，例如，喜欢物品A的一组人也喜欢物品B。以下图显示了ITCF的工作原理：
- en: '![](img/7c3012d9-a348-4945-b0e0-b9ac887cc18f.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![示例显示基于物品的协同过滤的工作原理](img/7c3012d9-a348-4945-b0e0-b9ac887cc18f.png)'
- en: Example showing the working of item based collaborative filtering
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 示例显示基于物品的协同过滤的工作原理
- en: Let's explore the diagram in a little more detail. In ITCF, the watermelon and
    grapes will form the similar-items neighborhood, which means that irrespective
    of users, different items that are equivalent will form a neighborhood. So when
    user X likes watermelon, the other item from the same neighborhood, which is grapes,
    will be recommended by the recommender system based on item-based collaborative
    filter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探索一下这个图。在ITCF中，西瓜和葡萄将形成相似物品的邻域，这意味着无论用户是谁，等效的不同物品都将形成一个邻域。所以当用户X喜欢西瓜时，来自同一邻域的其他物品，即葡萄，将由基于物品的协同过滤推荐系统推荐。
- en: 'ITCF involves the following three steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ITCF涉及以下三个步骤：
- en: '**Computing the item-based similarities through a distance measure**: This
    involves computing the distance between the items. The distance may be computed
    with one of the many distance measures, such as Cosine similarity, Euclidean distance,
    Manhattan distance, or Jaccard index. The output of this step is to obtain a similarity
    matrix where each cell corresponds to the similarity of the item specified on
    the row of the cell and the item specified on the column of the cell.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过距离度量计算基于物品的相似度**：这涉及到计算物品之间的距离。距离可以通过多种距离度量之一来计算，例如余弦相似度、欧几里得距离、曼哈顿距离或Jaccard指数。这一步骤的输出是获得一个相似度矩阵，其中每个单元格对应于单元格行上指定的物品与单元格列上指定的物品之间的相似度。'
- en: '**Predicting the targeted item rating for a specific user**: The rating is
    arrived at by computing the weighted sum of ratings made to the item very similar
    to the target item.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预测特定用户的目标物品评分**：评分是通过计算对与目标物品非常相似的物品所做的评分的加权总和得出的。'
- en: '**Recommending the top N items**: Once all the items are predicted, we recommend
    the top *N* items.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**推荐前N个最佳物品**：一旦所有物品都被预测出来，我们就推荐前*N*个物品。'
- en: 'Now, let''s build each one of the ITCF models and measure the performance against
    the test dataset. The following code trains the ITCF models with several parameter
    combinations:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建每个ITCF模型，并使用测试数据集来衡量其性能。以下代码使用几个参数组合训练ITCF模型：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We now have the ITCF models, so let''s get to computing the performance on
    the test data with each of the models we have created. The objective is to identify
    the best-performing ITCF model for this dataset. The following code gets the performance
    measurements with all the nine models on the test dataset:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了ITCF模型，所以让我们计算我们创建的每个模型在测试数据上的性能。目标是确定适用于此数据集的最佳性能ITCF模型。以下代码在测试数据集上获取所有九个模型的性能测量结果：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will result in the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We see the output that the ITCF recommendation application on data with the
    Euclidean distance yielded the best performance measurement.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，在具有欧几里得距离的数据上运行的ITCF推荐应用产生了最佳的性能测量结果。
- en: Building a recommendation system with a user-based collaborative filtering technique
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于用户协同过滤技术构建推荐系统
- en: The Jokes recommendation system we built earlier, with item-based filtering,
    uses the powerful `recommenderlab` library available in R. In this implementation
    of the **user-based collaborative filtering** (**UBCF**) approach, we make use
    of the same library.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前构建的基于项目的过滤器的笑话推荐系统，使用了R中可用的强大`recommenderlab`库。在这个**基于用户的协同过滤**（**UBCF**）方法的实现中，我们使用了相同的库。
- en: 'The following diagram shows the working principle of UBCF:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了UBCF的工作原理：
- en: '![](img/d22941f0-29d2-4c0e-8a79-5f065e5f527e.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d22941f0-29d2-4c0e-8a79-5f065e5f527e.png)'
- en: Example depicting working principle of user based collaborative filter
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 展示用户基于协同过滤器工作原理的示例
- en: 'To understand the concept better, let''s discuss the preceding diagram in detail.
    Let''s assume that there are three users: X,Y, and Z. In UBCF, users X and Z are
    very similar as both of them like strawberries and watermelons. User X also likes
    grapes and oranges. So a user-based collaborative filter recommends grapes and
    oranges to user Z. The idea is that similar people tend to like similar things.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个概念，让我们详细讨论前面的图表。假设有三个用户：X、Y和Z。在UBCF中，用户X和Z非常相似，因为他们都喜欢草莓和西瓜。用户X还喜欢葡萄和橙子。因此，基于用户的协同过滤器向用户Z推荐葡萄和橙子。这个想法是，相似的人倾向于喜欢相似的事物。
- en: 'The primary difference between a user-based collaborative filter and an item-based
    collaborative filter is demonstrated by the following recommendation captions
    often seen in online retail sites:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 用户协同过滤器和项目协同过滤器之间的主要区别可以通过以下在线零售网站上常见的推荐标题来展示：
- en: '**ITCF**: Customers who bought this item also bought'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ITCF**：购买此商品的用户还购买了'
- en: '**UBCF**: Customers similar to you bought'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UBCF**：与您相似的用户购买了'
- en: 'A user-based collaborative filter is built upon the following three key steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 基于以下三个关键步骤构建用户协同过滤器：
- en: 'Find the **k-nearest neighbors** (**KNN**) to the user *x*, using a similarity
    function, *w*, to measure the distance between each pair of users:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相似性函数*w*测量用户*x*与每个用户对之间的距离，找到**k个最近邻**（**KNN**）：
- en: '![](img/0052a429-61c2-4996-afe6-b51671d3ac79.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0052a429-61c2-4996-afe6-b51671d3ac79.png)'
- en: Predict the rating that user *x* will provide to all items the KNN has rated,
    but *x* has not.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预测用户*x*将对KNN已评分但*x*未评分的所有项目提供的评分。
- en: The *N* recommended items to user *x* is the top *N* items that have the best
    predicted ratings.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向用户*x*推荐的*N*个项目是具有最佳预测评分的前*N*个项目。
- en: In short, a user-item matrix is constructed during the UBCF process and based
    on similar users, the ratings of the unseen items of a user are predicted. The
    items that get the highest ratings among the predictions form the final list of
    recommendations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在UBCF过程中构建了用户-项目矩阵，并根据相似用户预测用户的未查看项目的评分。在预测中获得最高评分的项目构成了最终的推荐列表。
- en: 'The implementation of this project is very similar to ITCF as we are using
    the same library. The only change required in the code is to change the IBCF method
    to use UBCF. The following code block is the full code of the project implementation
    with UBCF:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的实现与ITCF非常相似，因为我们使用了相同的库。代码中唯一需要更改的是将IBCF方法更改为使用UBCF。以下代码块是使用UBCF的项目实现的全代码：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will result in the following output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Based on the UBCF output, we observe that the `Z-score` normalized data with
    Pearson's correlation as the distance has yielded the best performance measurement.
    Furthermore, if we want, the UBCF and ITCF results may be compared (testing needs
    to be done on the same test dataset) to arrive at a conclusion of accepting the best
    model among the 18 models that are built for the final recommendation engine deployment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根据UBCF输出，我们观察到使用皮尔逊相关系数作为距离的Z分数归一化数据产生了最佳性能度量。此外，如果我们愿意，可以比较UBCF和ITCF的结果（需要在同一测试数据集上进行测试），以得出接受为最终推荐引擎部署构建的18个模型中最佳模型的结论。
- en: The key point to observe in the code is the `UBCF` value that is passed to the `method`
    parameter. In the previous project, we built an item-based collaborative filter;
    all that is needed is for us to replace the value passed to the `method` parameter
    with IBCF.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中需要注意的关键点是传递给`method`参数的`UBCF`值。在先前的项目中，我们构建了一个基于项目的协同过滤器；我们只需要将传递给`method`参数的值替换为IBCF。
- en: Building a recommendation system based on an association-rule mining technique
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于关联规则挖掘技术构建推荐系统
- en: Association-rule mining, or market-basket analysis, is a very popular data mining
    technique used in the retail industry to identify the products that need to be
    kept together so as to encourage cross sales. An interesting aspect behind this
    algorithm is that historical invoices are mined to identify the products that
    are bought together.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 关联规则挖掘，或市场篮子分析，是一种在零售业中用于识别需要放在一起以鼓励交叉销售的产品的高度流行数据挖掘技术。这个算法的一个有趣方面是，通过挖掘历史发票来识别一起购买的产品。
- en: There are several off-the-shelf algorithms available to perform market-basket
    analysis. Some of them are Apriori, **equivalence class transformation** (**ECLAT**),
    and **frequent pattern growth** (**FP-growth**). We will learn to solve our problem
    of recommending jokes to users through applying the Apriori algorithm on the Jester
    jokes dataset. We will now learn the theoretical aspects that underpin the Apriori
    algorithm.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种现成的算法可用于执行市场篮子分析。其中一些是Apriori，**等价类转换**（**ECLAT**），和**频繁模式增长**（**FP-growth**）。我们将通过在Jester笑话数据集上应用Apriori算法来学习如何通过推荐笑话给用户来解决问题。我们现在将学习支撑Apriori算法的理论方面。
- en: The Apriori algorithm
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apriori算法
- en: The building blocks of the algorithm are the items that are found in any given
    transaction. Each transaction could have one or more items in it. The items that
    form a transaction are called an itemset. An example of a transaction is an invoice.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的构建块是任何给定事务中找到的项目。每个事务可能包含一个或多个项目。形成事务的项目称为项目集。一个事务的例子是发票。
- en: Given the transactions dataset, the objective is to find the items in data that
    are associated with each other. Association is measured as frequency of the occurrence
    of the items in the same context. For example, purchasing one product when another
    product is purchased represents an association rule. The association rule detects
    the common usage of items.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 给定事务数据集，目标是找到数据中相互关联的项目。关联性通过项目在相同上下文中的出现频率来衡量。例如，在购买另一个产品时购买一个产品代表一个关联规则。关联规则检测项目的共同使用情况。
- en: More formally, we can define association-rule mining as, given a set of items
    I = {I1,I2,..Im} and database of transactions D = {t1,t,2..tn}, where ti= { Ii1,Ii2..Iim}
    where Iik is element of, an association is an implication of X->Y where X,Y subset
    of I are set of items and X intersection Y is φ. In short, associations express
    an implication from X-> Y, where X and Y are itemsets.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，我们可以将关联规则挖掘定义为，给定一个项目集I = {I1, I2, .., Im}和事务数据库D = {t1, t2, .., tn}，其中ti
    = {Ii1, Ii2, .., Iim}，其中Iik是I的元素，一个关联是X->Y的蕴涵，其中X和Y是I的子集，且X和Y的交集是φ。简而言之，关联表达了从X->Y的蕴涵，其中X和Y是项目集。
- en: 'The algorithm can be better understood by an example. So, let''s consider the
    following table, which shows a representative list of sample transactions in a
    supermarket:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个例子可以更好地理解算法。所以，让我们考虑以下表格，它显示了超市中代表性样本事务的列表：
- en: '| **Transaction** | **Items** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **事务** | **项目** |'
- en: '| 1 | Milk, curd, chocolate |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 牛奶，酸奶，巧克力 |'
- en: '| 2 | Bread, butter |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 面包，黄油 |'
- en: '| 3 | Coke, jam |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 可乐，果酱 |'
- en: '| 4 | Bread, milk, butter, Coke |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 面包，牛奶，黄油，可乐 |'
- en: '| 5 | Bread, milk, butter, jam |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 面包，牛奶，黄油，果酱 |'
- en: Sample transactions in a super market
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 超市中的样本事务
- en: 'Let''s try to explore some fundamental concepts that will help us understand
    how the Apriori algorithm works:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试探索一些基本概念，这将帮助我们理解 Apriori 算法是如何工作的：
- en: '**Item**: An item is any individual product that is part of each of the transactions.
    For example, milk, Coke, and butter are all termed as items.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项**：任何单个产品，它是每个交易的一部分。例如，牛奶、可乐和黄油都被称为项。'
- en: '**Itemset**: Collection of one or more items. For example, *{butter, milk,
    coke}, {butter, milk}*.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项集**：一个或多个项目的集合。例如，*{butter, milk, coke}, {butter, milk}*。'
- en: '**Support count**: Frequency of occurrence of an itemset. For example, support
    count or *σ {butter, bread, milk} = 2*.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持计数**：项集出现的频率。例如，支持计数或 *σ {butter, bread, milk} = 2*。'
- en: '**Support**: A fraction of transactions that contain an itemset. For example, *s
    = {butter, bread, milk} = 2/5*.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持**：包含项集的交易的比例。例如，*s = {butter, bread, milk} = 2/5*。'
- en: '**Frequent itemset**: An itemset whose support is greater than the minimum
    threshold.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频繁项集**：支持度大于最小阈值的项集。'
- en: '**Support for an itemset in a context**: Fraction of contexts that contain
    both *X* and *Y*:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在上下文中项集的支持度**：同时包含 *X* 和 *Y* 的上下文的比例：'
- en: '![](img/d64f7390-23d7-409f-94cf-887150e51c11.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d64f7390-23d7-409f-94cf-887150e51c11.png)'
- en: So, *s* for *{milk, butter} -> {bread} will be s = σ {milk, butter, bread}/N
    = 2/5 = 0.4*
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*s* 对于 *{milk, butter} -> {bread}* 将是 s = σ {milk, butter, bread}/N = 2/5
    = 0.4
- en: '**Confidence**: Measures the strength of the rule, whereas support measures
    how often it should occur in the database. It computes how often items in *Y*
    occur in containing *X* through the following formula:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**置信度**：衡量规则强度，而支持度衡量它在数据库中应该出现的频率。它通过以下公式计算 *Y* 中项目在包含 *X* 中的出现频率：'
- en: '![](img/d00a906f-97da-40fc-8a56-293d0461bcc9.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d00a906f-97da-40fc-8a56-293d0461bcc9.png)'
- en: 'For example: For {bread} -> {butter}'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：对于 {bread} -> {butter}
- en: '*c or α = σ {butter, bread} / σ {bread} = 3/3 = 1*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*c 或 α = σ {butter, bread} / σ {bread} = 3/3 = 1*'
- en: 'Let''s consider another example confidence for *{curd} -> {bread}*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子，*{curd} -> {bread}* 的置信度：
- en: '*c or α = σ {curd,bread} / σ {bread} = 0/3 = 0*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*c 或 α = σ {curd,bread} / σ {bread} = 0/3 = 0*'
- en: 'The Apriori algorithm intends to generate all possible combinations of the
    itemsets from the list of the items and then prunes the itemsets that have met
    the predefined support and confidence parameter values that were passed to the
    algorithm. So, it may be understood that the Apriori algorithm is a two-step algorithm:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Apriori 算法旨在从项目的列表中生成所有可能的项集组合，然后剪枝那些已经达到预定义支持度和置信度参数值的项集。因此，可以理解 Apriori 算法是一个两步算法：
- en: Generating itemsets from the items
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目生成项集
- en: Evaluating and pruning the itemsets based on predefined support and confidence
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于预定义的支持度和置信度评估和剪枝项集
- en: Let's discuss step 1 in detail. Assume there are *n* items in the collection.
    The number of itemsets one could create is 2^*n*, and all these need to be evaluated
    in the second step in order to come up with the final results. Even considering
    just 100 different items, the number of itemsets generated is 1.27e+30! The huge
    number of itemsets poses a severe computational challenge.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论第一步。假设集合中有 *n* 个项目。可以创建的项集数量是 2^*n*，所有这些都需要在第二步中进行评估，以便得出最终结果。即使只考虑 100
    个不同的项目，生成的项集数量也是 1.27e+30！巨大的项集数量提出了严重的计算挑战。
- en: The Apriori algorithm overcomes this challenge by preempting the itemsets that
    are generally rare or less important. The Apriori principle states that *if an
    itemset is frequent, all of its subsets must also be frequent*. This means that
    if an item does not meet the predefined support threshold, then such item does
    not participate in the creation of itemsets. The Apriori algorithm thus comes
    up with restricted number of itemsets that are viable to be evaluated without
    encountering a computational challenge.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Apriori 算法通过预先排除那些通常很少见或不重要的项集来克服这一挑战。Apriori 原则指出，*如果一个项集是频繁的，那么它的所有子集也必须是频繁的*。这意味着如果一个项没有达到预定义的支持度阈值，那么这样的项就不会参与项集的创建。因此，Apriori
    算法提出了有限数量的项集，这些项集可以在不遇到计算挑战的情况下进行评估。
- en: 'The first step of the algorithm is iterative in nature. In the first iteration,
    it considers all itemsets of length 1, that is, each itemset contains only one
    item in it. Then each item is evaluated to eliminate the itemsets that are found
    to not meet the preset support threshold. The output of the first iteration is
    all itemsets of length 1 that meet the required support. This becomes the input
    for iteration 2, and now itemsets of length 2 are formed using only the final
    itemsets that are output in first iteration. Each of the itemsets formed during
    step 2 is checked again for the support threshold; if it is not met, such itemsets
    are eliminated. The iterations continue until no new itemsets can be created.
    The process of itemsets is illustrated in the following diagram:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的第一步本质上是迭代的。在第一次迭代中，它考虑所有长度为1的项集，也就是说，每个项集只包含一个项目。然后每个项目都会被评估以排除那些被发现没有达到预设支持阈值的项集。第一次迭代的结果是所有满足所需支持的长度的1项集。这成为第二次迭代的输入，现在使用第一次迭代中输出的最终项集形成长度为2的项集。在第二步中形成的每个项集都会再次检查支持阈值；如果没有达到，这样的项集就会被排除。迭代会一直持续到无法再创建新的项集。项集的过程在以下图中说明：
- en: '![](img/6eead20b-c634-450e-be63-eba894c02b86.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6eead20b-c634-450e-be63-eba894c02b86.png)'
- en: Illustration showing the itemsets creation in Apriori algorithm
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 展示Apriori算法中项集创建的插图
- en: Once we have all itemsets post all the step 1 iterations of the algorithm, step
    2 kicks in. Each of the itemsets generated is tested to check whether it meets
    the predefined confidence value. If it does not meet the threshold, such itemsets
    are eliminated from the final output.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了算法的第一步的所有迭代后的所有项集，第二步就开始了。生成的每个项集都会被测试，以检查它是否满足预定义的置信度值。如果它没有达到阈值，这样的项集就会被从最终输出中排除。
- en: 'At a stage where all iterations are complete and the final rules are the output
    from Apriori, we make use of a metric called lift to consume the relevant rules
    from the final output. Lift defines how much more likely one item or itemset is
    purchased relative to its typical rate of purchase, given that we know another
    item or itemset has been purchased. For each itemset, we get the lift measurement
    using the following formula:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有迭代都完成并且最终规则是Apriori的输出时，我们使用一个称为提升度的指标来从最终输出中消耗相关的规则。提升度定义了在已知另一个项目或项集已被购买的情况下，一个项目或项集相对于其典型购买率购买的可能性有多大。对于每个项集，我们使用以下公式来获取提升度测量值：
- en: '![](img/d40eaf00-9435-4131-9272-b62dc512c54b.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d40eaf00-9435-4131-9272-b62dc512c54b.png)'
- en: Let's delve a little deeper into understanding the lift metric. Assume that
    in a supermarket, milk and bread are bought together by chance. In such a case,
    a large number of transactions are expected to cover the milk and bread purchased.
    A lift (milk -> bread) of more than 1 implies that these items are found together
    more often than these items are purchased together by chance. We generally would
    look for lift values greater than 1 when evaluating the rules for their usefulness
    in business. A lift value higher than 1 indicates that the itemset generated is
    very strong, and therefore worth considering for implementation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解提升度指标。假设在一个超市里，牛奶和面包偶然一起被购买。在这种情况下，预计会有大量的交易涵盖购买的牛奶和面包。提升度（牛奶 -> 面包）超过1意味着这些商品比这些商品偶然一起购买的情况更频繁地一起被发现。在评估规则以评估其在商业中的有用性时，我们通常会寻找大于1的提升度值。高于1的提升度值表明生成的项集非常强大，因此值得考虑实施。
- en: 'Now, let''s implement the recommendation system using the Apriori algorithm:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Apriori算法来实现推荐系统：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will result in the following output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can see from the output that the `Jester5k` data in the `recommenderlab`
    library is in the `realRatingsMatrix` format. We are also aware that the cells
    in this matrix contain the ratings provided by the users for various jokes and
    we are aware that the ratings range between -10 to +10.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，`recommenderlab`库中的`Jester5k`数据是`realRatingsMatrix`格式。我们也知道这个矩阵中的单元格包含用户为各种笑话提供的评分，并且我们知道评分范围在-10到+10之间。
- en: 'Applying the Apriori algorithm on the `Jester5k` dataset give us an opportunity
    to understand the association between the jokes. However, prior to applying the
    Apriori algorithm, we will need to transform the dataset to binary values where
    1 represents a positive rating and 0 represents a negative rating or no rating.
    The `recommenderlab` library comes up with the `binarize()` function, which can
    perform the required operation for us. The following code binarizes the ratings
    matrix:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Jester5k` 数据集上应用 Apriori 算法为我们理解笑话之间的关联提供了机会。然而，在应用 Apriori 算法之前，我们需要将数据集转换为二进制值，其中
    1 代表正面评分，0 代表负面评分或无评分。`recommenderlab` 库提供了 `binarize()` 函数，它可以为我们执行所需的操作。以下代码将评分矩阵二值化：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will result in the following output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can observe from the output that `realRatingsMatrix` is successfully converted
    into `binaryRatingMatrix`. The Apriori algorithm that mines the associations expects
    a matrix to be passed as input rather than `binaryRatingMatrix`. We can very easily
    convert the `Jester5k_bin` object to the matrix format with the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以观察到，`realRatingsMatrix` 已成功转换为 `binaryRatingMatrix`。挖掘关联的 Apriori 算法期望输入一个矩阵而不是
    `binaryRatingMatrix`。我们可以非常容易地将 `Jester5k_bin` 对象转换为矩阵格式，以下代码可以完成此操作：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will result in the following output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '![](img/94f50034-68a7-44df-9c4e-653e4d103700.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94f50034-68a7-44df-9c4e-653e4d103700.png)'
- en: 'We see from the output that all the cells of the matrix are represented as
    `TRUE` and `FALSE`, but Apriori expects the cells to be numeric. Let''s now convert
    the cells into `1` and `0` for `TRUE` and `FALSE`, respectively, with the following
    code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，矩阵的所有单元格都表示为 `TRUE` 和 `FALSE`，但 Apriori 预期单元格应该是数字的。现在让我们使用以下代码将单元格转换为
    `1` 和 `0`，分别代表 `TRUE` 和 `FALSE`：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will result in the following output:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '![](img/5f7b4675-5f57-4d77-82bb-3768722b41c0.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f7b4675-5f57-4d77-82bb-3768722b41c0.png)'
- en: 'Now we are all set to apply the Apriori algorithm on the dataset. There are
    two parameters, `support` and `confidence`, that we need to pass to the algorithm.
    The algorithm mines the dataset based on these two parameter values. We pass `0.5`
    as the value for support and `0.8` as the value for confidence. The following
    line of code extracts the joke associations that exist in our Jester jokes dataset:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在数据集上应用 Apriori 算法。我们需要向算法传递两个参数，即 `support` 和 `confidence`。算法根据这两个参数值挖掘数据集。我们将
    `0.5` 作为支持值的输入，将 `0.8` 作为置信值的输入。以下代码行提取了存在于我们 Jester 笑话数据集中的笑话关联：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will result in the following output:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `rules` object that was created from the execution of the Apriori algorithm
    now has all the joke associations that were extracted and mined from the dataset.
    As we can see from the output, there are `78` jokes associations that were extracted
    in total. We can examine the rules with the following line of code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从执行 Apriori 算法创建的 `rules` 对象现在包含了从数据集中提取和挖掘的所有笑话关联。从输出中我们可以看到，总共提取了 `78` 个笑话关联。我们可以使用以下代码行来检查这些规则：
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will result in the following output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The output shown is just five rules out of the overall 78 rules that are in
    the list. The way to read each rule is that the joke shown on the left column
    (`lhs`) leads to the joke on the right column (`rhs`); that is, a user that liked
    the joke on `lhs` of the rule generally tends to like the joke shown on `rhs`.
    For example, in the first rule, if a user has liked joke `j48`, it is likely that
    they will also like `j50`, therefore it is worth recommending joke `j50` to the
    user that has only read joke `j48`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 展示的输出只是列表中 78 条规则中的五条。读取每条规则的方式是，左侧列（`lhs`）中显示的笑话导致右侧列（`rhs`）中的笑话；也就是说，喜欢规则左侧
    `lhs` 中笑话的用户通常也倾向于喜欢右侧 `rhs` 中显示的笑话。例如，在第一条规则中，如果一个用户喜欢了笑话 `j48`，那么他们很可能也会喜欢 `j50`，因此值得向只阅读了笑话
    `j48` 的用户推荐笑话 `j50`。
- en: 'While there are several rules generated by the Apriori algorithm, the strength
    of each rule is specified by a metric, called `lift`. This is a metric that describes
    the worthiness of a rule in a business context. Note that for a rule to be considered
    general, it has to have a lift that is less than or equal to `1`. A lift value
    greater than 1 signifies a better rule for implementing in business. The aim of
    the following lines of code is to get such strong rules to the top of the list:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Apriori算法生成了多条规则，但每条规则的强度由一个称为`提升度`的指标来指定。这是一个描述规则在商业环境中价值的指标。请注意，要使规则被认为是通用的，其提升度必须小于或等于`1`。大于1的提升度值表示在商业中实施更好的规则。以下代码行旨在将这样的强规则置于列表顶部：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will result in the following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/83ceb235-42e8-4278-8191-79cbceabdc2e.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/83ceb235-42e8-4278-8191-79cbceabdc2e.png)'
- en: It may be observed that the output shown is only a subset of the rules output.
    The first rule indicates that `j35` is a joke that can be recommended to a user
    that has already read jokes `j29` and `j50`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到，显示的输出只是规则输出的子集。第一条规则表明`j35`是一个可以推荐给已经阅读过笑话`j29`和`j50`的用户笑话。
- en: Likewise, we could just write a script to search all the jokes that a user has
    already read and match it with the left side of the rule; if a match is found,
    the corresponding right side of the rule can be recommended as the joke for the
    user.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以编写一个脚本来搜索用户已经阅读的所有笑话，并将其与规则的左侧进行匹配；如果找到匹配项，则可以将规则的对应右侧推荐给用户作为笑话。
- en: Content-based recommendation engine
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于内容的推荐引擎
- en: A recommendation engine that is solely based on the explicit or implicit feedback
    received from customers is termed as **content-based recommendation system**.
    Explicit feedback is the customer's expression of the interest through filling
    in a survey about preferences or rating jokes of interest or opting for newsletters
    related to the joke or adding the joke on the watchlist, and so on. Implicit feedback
    is more of a mellowed-out approach where a customer visits a page, clicks on a
    joke link, or just spends time reading a joke review on an e-commerce page. Based
    on the feedback received, similar jokes are recommended to the customers. It may
    be noted that content-based recommendations do not take into consideration the
    preferences and feedback of other customers in the system; instead, it is purely
    based on the personalized feedback from the specific customer.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 仅基于从客户那里收到的显式或隐式反馈的推荐引擎被称为**基于内容的推荐系统**。显式反馈是客户通过填写关于偏好的调查问卷、对感兴趣的笑话进行评分或选择与笑话相关的通讯录、将笑话添加到观察列表等方式表达的兴趣。隐式反馈则是一种更为温和的方法，例如客户访问一个页面、点击笑话链接，或者在电子商务页面上阅读笑话评论所花费的时间。根据收到的反馈，向客户推荐类似的笑话。需要注意的是，基于内容的推荐不考虑系统中其他客户的偏好和反馈；相反，它完全基于特定客户的个性化反馈。
- en: 'In the recommendation process, the system identifies the products that are
    already positively rated by the customer with the products that the customer has
    not rated and looks for equivalents. Products that are similar to the positively-rated
    ones are recommended to the customers. In this model, the customer''s preferences
    and behavior play a major role in incrementally fine-tuning the recommendations—that
    is, with each recommendation and based on whether the customer responded to the
    recommendation, the system learns incrementally to recommend differently. The
    following diagram is an illustration of how a content-based recommendation system
    works:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在推荐过程中，系统会识别出客户已经对某些产品给予好评的产品，以及客户尚未评价的产品，并寻找等效产品。与好评产品相似的产品会被推荐给客户。在这个模型中，客户的偏好和行为在逐步微调推荐中起着重要作用——也就是说，每次推荐后，根据客户是否对推荐做出响应，系统会逐步学习以提供不同的推荐。以下图表展示了基于内容的推荐系统是如何工作的：
- en: '![](img/62443519-42f8-4de0-9d16-df39c9b9205d.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62443519-42f8-4de0-9d16-df39c9b9205d.png)'
- en: Working of a content based recommendation system
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 基于内容的推荐系统的工作原理
- en: In our Jester jokes dataset, we have ratings given by users for various jokes
    as well as the content of the jokes themselves. Remember that the `JesterJokes`
    character vector incorporates the text present in the jokes themselves. Similarities
    between the texts present in the jokes can be used as one method to recommend
    jokes to users. The assumption is that if a person liked the content in a joke,
    and if there is another joke whose content is very similar, recommending the latter
    joke is probably going to be liked by the user.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的愚人笑话数据集中，我们包含了用户对各种笑话的评分以及笑话本身的内容。请记住，`JesterJokes`字符向量包含了笑话本身存在的文本。笑话中存在的文本相似性可以用作向用户推荐笑话的一种方法。假设是，如果一个人喜欢笑话中的内容，并且如果还有另一个笑话的内容非常相似，那么推荐这个后者的笑话可能会被用户喜欢。
- en: Additional metadata related to jokes is not given in the Jester jokes dataset,
    however such metadata may be created from the content of the jokes. For example,
    the length of the joke, number of nouns, number of funny terms present in the
    joke, and central theme in the joke. Processing the text is not purely a recommendation
    area but it involves using NLP techniques as well. As we will be covering NLP
    in a different chapter, we will not cover it here.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Jester笑话数据集中没有提供与笑话相关的额外元数据，然而，可以从笑话的内容中创建这样的元数据。例如，笑话的长度、笑话中名词的数量、笑话中出现的幽默词汇数量以及笑话的中心主题。文本处理不仅仅是推荐领域，它还涉及到使用NLP技术。由于我们将在不同的章节中介绍NLP，因此我们在这里不会涉及它。
- en: Differentiating between ITCF and content-based recommendations
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分基于ITCF和基于内容的推荐
- en: It might appear that item-based collaborative and content-based recommendations
    are the same. In reality, they are not the same. Let's touch upon the differences.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来基于项目的协同推荐和基于内容的推荐是相同的。实际上，它们并不相同。让我们谈谈它们之间的区别。
- en: ITCF is totally based on user-item rankings. When we compute the similarity
    between items, we do not include the item attributes and just compute the similarity
    of items based on all customers' ratings. So the similarity between items is computed
    based on the ratings instead of the metadata of item itself.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ITCF完全基于用户-项目排名。当我们计算项目之间的相似度时，我们不包含项目属性，只是基于所有顾客的评分来计算项目的相似度。因此，项目的相似度是基于评分而不是项目本身的元数据来计算的。
- en: In content-based recommendations, we make use of the content of both the user
    and the item. Generally, we construct a user profile and item profile using the
    content of a shared attribute space. For example, for a movie, we represent it
    with the actors in it and the genre (using binary coding, for example). For a
    user profile, we can do the same thing based on the user, such as some actors/genres.
    Then the similarity of user and item can be computed using cosine similarity,
    for example. This cosine measure leads to the recommendations.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于内容的推荐中，我们使用用户和项目的相关内容。通常，我们使用共享属性空间的内容来构建用户配置文件和项目配置文件。例如，对于一部电影，我们可以用其中的演员和类型（例如使用二进制编码）来表示它。对于用户配置文件，我们可以根据用户进行同样的操作，例如一些演员/类型。然后可以使用余弦相似度等方法计算用户和项目的相似度。这种余弦度量导致推荐的产生。
- en: Content-based filtering identifies products that are similar based on the tags
    assigned to each product. Each product is assigned weights on the basis of term
    frequency and inverse document frequency of each tag. After this, the user's probability
    of liking a product is calculated in order to arrive at the final recommendation
    list.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 基于内容的过滤通过识别每个产品上分配的标签来识别相似的产品。每个产品根据每个标签的词频和逆文档频率分配权重。之后，计算用户喜欢产品的概率，以便得出最终的推荐列表。
- en: While content-based recommendation systems are highly efficient and personalized,
    there is an inherent problem with this model. Let's understand the over-specialization
    problem of content-based recommendations with an example.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基于内容的推荐系统非常高效且个性化，但这种模型存在一个固有的问题。让我们通过一个例子来了解基于内容的推荐中过度专业化的难题。
- en: 'Assume there are the following five movie genres:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有以下五种电影类型：
- en: Comedy
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 喜剧
- en: Thriller
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惊悚片
- en: Science fiction
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 科幻
- en: Action
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作
- en: Romance
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爱情
- en: There is this customer, Jake, who generally watches thriller and science fiction
    movies. Based on this preference, the content-based recommendation engine will
    only recommend movies related to these genres and it is never going to recommend
    movies from other categories. This problem arises as content-based recommendation
    engine solely relies on the user's past behavior and preferences to determine
    the recommendation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有这样一个客户，杰克，他通常观看惊悚片和科幻电影。基于这个偏好，基于内容的推荐引擎只会推荐与这些类型相关的电影，并且永远不会推荐其他类别的电影。这个问题是由于基于内容的推荐引擎仅依赖于用户的过去行为和偏好来确定推荐。
- en: Unlike content-recommendation systems, in ITCF recommendations, similar products
    build neighborhoods based on positive preferences of customers. Therefore, the
    system generates recommendations with products in the neighborhood that a customer
    might prefer. ITCF does this by making use of the correlation between the items
    based on the ratings given them by different users, while collaborative filtering
    relies on past preferences or rating correlation between users and it is able
    to generate recommendations for similar products even from customer's interest
    domain. This technique can lead to bad predictions if the product is unpopular
    and very few users have given feedback about it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于内容的推荐系统不同，在ITCF推荐中，基于顾客的积极偏好构建相似产品的邻域。因此，系统会生成可能被顾客偏好的邻域中的产品推荐。ITCF通过利用不同用户给出的评分之间的相关性来实现这一点，而协同过滤则依赖于用户过去的偏好或评分相关性，它能够从顾客的兴趣领域生成相似产品的推荐。如果产品不受欢迎且很少用户对其给出反馈，这种技术可能导致不良预测。
- en: Building a hybrid recommendation system for Jokes recommendations
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为笑话推荐构建混合推荐系统
- en: 'We see that both content-based filtering and collaborative filtering have their
    strengths and weaknesses. To overcome the issues, organizations build recommender
    systems that combine two or more technique and they are termed hybrid recommendation
    models. An example of this is a combination of content-based, IBCF, UBCF, and
    model-based recommender engine. This takes into account all the possible aspects
    that contribute to making the most relevant recommendation to the user. The following
    diagram shows an example approach followed in hybrid recommendation engines:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，基于内容的过滤和协同过滤都有其优点和缺点。为了克服这些问题，组织构建了结合两种或更多技术的推荐系统，这些系统被称为混合推荐模型。一个例子是结合基于内容、IBCF、UBCF和基于模型的推荐引擎。这考虑了所有可能影响为用户做出最相关推荐的方面。以下图表展示了混合推荐引擎中遵循的示例方法：
- en: '![](img/de76d7c8-e602-45d1-a149-fba5f673ac84.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/de76d7c8-e602-45d1-a149-fba5f673ac84.png)'
- en: Sample approach to hybrid recommendation engine
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 混合推荐引擎的示例方法
- en: 'We need to note that there is no standard approach to achieving a hybrid recommendation
    engine. In order to combine recommendations, here are some suggested strategies:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注意到，实现混合推荐引擎没有标准的方法。为了结合推荐，以下是一些建议的策略：
- en: '**Voting**: Apply voting among the recommendation output obtained from individual
    recommender systems.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投票**：对从各个推荐系统中获得的推荐输出进行投票。'
- en: '**Rules-based selection**: We could devise rules that suggest weighting the
    output recommendations obtained from individual recommender systems. In this case,
    the output from recommender systems that got higher weights will be dominant and
    have more influence on the final recommendation outcome.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于规则的选取**：我们可以制定规则，建议对从各个推荐系统中获得的推荐输出进行加权。在这种情况下，获得更高权重的推荐系统的输出将占主导地位，并对最终推荐结果产生更大的影响。'
- en: '**Combination**: Recommendations from all the recommender engines are presented
    together. A final list of recommendations is just the union of all recommendation
    output obtained from individual recommender systems.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：将所有推荐引擎的推荐结果一起展示。最终的推荐列表只是从各个推荐系统中获得的所有推荐输出的并集。'
- en: '**Attribute integration**: Taking metadata from all recommender system to infuse
    it as input to another recommender.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性集成**：从所有推荐系统中提取元数据，将其作为输入提供给另一个推荐系统。'
- en: Again, what works for a problem may not work for another, therefore these strategies
    need to be tested individually prior to coming up with final recommendation strategy.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，对某个问题有效的方法可能对另一个问题不一定适用，因此这些策略在提出最终推荐策略之前需要单独进行测试。
- en: 'The `recommenderlab` library offers the `HybridRecommender` function which allows
    users to train multiple recommender engines on the same set of data in one go
    and combine the predictions. The function has a weights parameter that offers
    a way to specify the weight of each of the models that will be used to combine
    individual predictions to arrive at the final recommendation predictions on unseen
    data. Implementing a hybrid recommendation-engine-based project is super straightforward
    and not too different from the code we learned in item-based collaborative filtering
    or user-based collaborative filtering projects. Anyway, let''s write the code
    and build a hybrid recommendation engine for the `Jester5k` dataset:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`recommenderlab`库提供了`HybridRecommender`函数，允许用户一次性在相同的数据集上训练多个推荐器引擎并组合预测。该函数有一个权重参数，提供了一种指定将用于组合单个预测以到达最终推荐预测（针对未见数据）的每个模型的权重的途径。实现基于混合推荐引擎的项目非常简单，与我们在基于项目的协同过滤或基于用户的协同过滤项目中学习到的代码没有太大区别。无论如何，让我们编写代码并构建一个针对`Jester5k`数据集的混合推荐引擎：'
- en: '[PRE32]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code is what trains a hybrid recommender. This is where it differs
    from the `ITCF` or `UBCF` recommenders we''ve built. We can observe from the code
    that we have used four different recommender methods that will constitute the
    hybrid recommender. Let''s discuss each of these methods:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码是用来训练混合推荐器的。这就是它与我们所构建的`ITCF`或`UBCF`推荐器不同的地方。从代码中我们可以观察到，我们使用了四种不同的推荐器方法，这些方法将构成混合推荐器。让我们逐一讨论这些方法：
- en: The popular recommendation method simply recommends the popular jokes (determined
    by the number of ratings received) to users.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流行推荐方法简单地推荐流行的笑话（由收到的评分数量决定）给用户。
- en: The second recommender method we have used is item-based collaborative filtering
    method with non-normalized data but with distance being computed between items
    through cosine similarity.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用的第二种推荐器方法是基于项目的协同过滤方法，使用非归一化数据，但通过余弦相似度计算项目之间的距离。
- en: User-based collaborative filtering on `Z-score` normalized data with Euclidean
    distance being computed between users in the data.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Z-score`归一化的数据上基于用户进行基于`Z-score`的协同过滤，用户之间的距离通过欧几里得距离来计算。
- en: A random recommendation method that provides a random recommendation to the
    users.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种随机推荐方法，为用户提供随机推荐。
- en: 'By no means, we finalize that the combination of these four recommender methods
    is the best hybrid for this problem. The intention of this project is to demonstrate
    the implementation of the hybrid recommender. The choice of the methods involved
    is purely arbitrary. In reality, we may need to try multiple combinations to identify
    the best hybrid. The hybrid classifier is built using the following code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绝不认为这四种推荐器方法的组合是此问题的最佳混合。这个项目的目的是展示混合推荐器的实现。涉及的方法的选择完全是任意的。在现实中，我们可能需要尝试多种组合来识别最佳混合。混合分类器使用以下代码构建：
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will result in the following output:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Observe the weights assignment in the hybrid model. We see that the popular
    and random recommenders are assigned 20% weight each, whereas the `ITCF` and `UBCF`
    methods involved in the preceding hybrid are assigned 30% weight each. It is not
    mandatory to set the weights while building a hybrid recommender, in which case,
    equal weights are assigned to each of the methods involved in the hybrid recommender.
    Now that our model is ready, let''s make predictions and evaluate the performance
    with the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 观察混合模型中的权重分配。我们看到流行和随机推荐器各分配了20%的权重，而前一个混合中涉及的`ITCF`和`UBCF`方法各分配了30%的权重。在构建混合推荐器时设置权重不是强制性的，在这种情况下，混合推荐器中涉及的方法将分配相等的权重。现在我们的模型已经准备好了，让我们使用以下代码进行预测并评估性能：
- en: '[PRE35]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will result in the following output:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE36]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used the `recommenderlab` library extensively to build the
    various types of joke-recommendation engines based on the Jester jokes dataset.
    We also learned about the theoretical concepts behind the methods.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们广泛使用了`recommenderlab`库来构建基于Jester笑话数据集的各种类型的笑话推荐引擎。我们还了解了这些方法背后的理论概念。
- en: Recommender systems is an individual ML area on its own. This subject is so
    vast that it cannot be covered in just one chapter. Several types of recommendation
    systems exists and they may be applied to datasets in specific scenarios. Matrix
    factorization, singular-value decomposition approximation, most popular items,
    and SlopeOne are some techniques that may be employed to build recommendation
    systems. These techniques are outside the scope of this chapter as these are rarely
    used in business situations to build recommendation systems, and the aim of the
    chapter is provide exposure to more popular techniques. Further learning on recommendation
    engines could be in the direction of exploring and studying these rarely-used
    techniques and applying them to real-world problems.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统是一个独立的机器学习领域。这个主题非常广泛，无法仅在一章中涵盖。存在多种类型的推荐系统，并且它们可以应用于特定场景的数据集。矩阵分解、奇异值分解近似、最流行项和SlopeOne是一些可能用于构建推荐系统的技术。这些技术超出了本章的范围，因为这些技术很少在商业环境中用于构建推荐系统，而本章的目的是介绍更多流行的技术。关于推荐引擎的进一步学习可以是在探索和研究这些很少使用的技术，并将它们应用于现实世界问题的方向。
- en: The next chapter is focused on NLP techniques. We are going to implement a sentiment-analysis
    engine on Amazon product reviews using several popular techniques. We'll explore
    semantic and syntactic approaches to analyzing text and then apply them on the
    Amazon review corpus. I am all geared up to turn this page and move on to the
    next chapter. How about you?!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专注于自然语言处理技术。我们将使用几种流行的技术来实现亚马逊产品评论的情感分析引擎。我们将探索语义和句法方法来分析文本，然后将它们应用于亚马逊评论语料库。我已经准备好翻过这一页，进入下一章。你呢？
- en: References
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'While the `recommenderlab` library is super popular in the R community, this
    is not the only choice for building a recommendation system. Here are some other
    popular libraries you may rely on to implement recommendation engines:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`recommenderlab`库在R社区中非常受欢迎，但这并不是构建推荐系统的唯一选择。以下是一些你可能依赖的其他流行库来实现推荐引擎：
- en: '`rrecsys`: There are several popular recommendation systems, such as Global/Item/User-Average
    baselines, Item-Based KNN, FunkSVD, BPR, and weighted ALS for rapid prototyping.
    Refer to [https://cran.r-project.org/web/packages/rrecsys/index.htmlImplementations](https://cran.r-project.org/web/packages/rrecsys/index.htmlImplementations) for
    more information.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rrecsys`：有几个流行的推荐系统，如全局/项目/用户平均基线、基于项目的KNN、FunkSVD、BPR和加权ALS用于快速原型设计。有关更多信息，请参阅[https://cran.r-project.org/web/packages/rrecsys/index.htmlImplementations](https://cran.r-project.org/web/packages/rrecsys/index.htmlImplementations)。'
- en: '`recosystem`: The R wrapper of the `libmf` library ([http://www.csie.ntu.edu.tw/~cjlin/libmf/](http://www.csie.ntu.edu.tw/~cjlin/libmf/))
    for recommender system using matrix factorization. It is typically used to approximate
    an incomplete matrix using the product of two matrices in a latent space. Other
    common names for this task include collaborative filtering, matrix completion,
    and matrix recovery. High-performance multicore parallel computing is supported
    in this package.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recosystem`：这是`libmf`库的R语言包装器，用于矩阵分解的推荐系统（[http://www.csie.ntu.edu.tw/~cjlin/libmf/](http://www.csie.ntu.edu.tw/~cjlin/libmf/)）。它通常用于通过潜在空间中两个矩阵的乘积来近似一个不完整的矩阵。这项任务的常见名称还包括协同过滤、矩阵补全和矩阵恢复。此包支持高性能的多核并行计算。'
- en: '`rectools`: An advanced package for recommender systems to incorporate user
    and item covariate information, including item category preferences with parallel
    computation, novel variations on statistical latent factor model, focus group
    finder, NMF, ANOVA, and cosine models.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rectools`：这是一个高级推荐系统包，用于结合用户和项目协变量信息，包括具有并行计算的项类别偏好，统计潜在因子模型的创新变化，焦点小组发现者，NMF，方差分析和余弦模型。'
