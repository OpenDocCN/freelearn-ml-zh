# 第10章：探索时间序列分析

在上一章中，我们讨论了使用深度学习及其在处理自然语言这种非结构化数据时的强大适用性——一种序列数据。我们现在将关注的另一种序列数据是时间序列数据。我们可以将时间序列数据视为标准数据集，但包含基于时间的特征，从而在开发预测模型时开启了一组新的可能性。

时间序列数据中最常见的一个应用是一个称为时间序列分析的过程。我们可以将时间序列分析定义为数据**探索**和**预测**的一个领域，其中数据集是按照特定的**时间间隔**或**时间戳**进行排序或索引的。我们在生物技术和生命科学行业中每天都会遇到许多时间序列数据的例子。一些更侧重于实验室的领域包括基因表达和色谱法，以及非实验室领域，如需求预测和股价分析。

在本章中，我们将探讨几个不同领域，以更好地理解时间序列数据的分析，以及开发一个能够消费这些数据并构建一个稳健、预测性模型的方法。

随着我们探索这些领域，我们将涵盖以下主题：

+   理解时间序列数据

+   探索时间序列数据集的组成部分

+   教程 - 使用Prophet和LSTM预测产品需求

考虑到这一点，让我们开始吧！

# 理解时间序列数据

当涉及到使用**时间序列**数据时，有无数种方式来可视化和展示数据，以有效地传达一个想法或观点。在我们迄今为止使用的大多数数据中，我们处理了特征和标签，其中一组特征通常对应于感兴趣的标签。当涉及到时间序列数据时，我们往往放弃类别或标签的概念，更多地关注数据中的趋势。时间序列数据最常见的一个应用是**需求预测**的概念。正如其名称所暗示的，需求预测包括许多方法和工具，可以帮助提前预测特定商品或服务的需求。在本节中，我们将通过一个关于特定生物技术产品需求预测的数据集，了解时间序列分析的许多方面。

## 将时间序列数据视为结构化数据集

目前市场上有很多不同的生物技术产品，从农业转基因作物到单克隆抗体疗法应有尽有。在本节中，我们将通过使用`dataset_demand-forecasting_ts.csv`数据集来调查一种人用治疗品的销售数据，该数据集属于一家小型生物技术初创公司：

1.  考虑到这一点，让我们继续深入数据。我们将首先导入感兴趣的库，导入`CSV`文件，并查看数据的前几行：

    [PRE0]

    这将导致以下输出：

    ![图10.1 – 预测数据集的前几行](img/B17761_10_001.jpg)

    图10.1 – 预测数据集的前几行

    与我们过去使用过的许多其他数据集相比，这个数据集在意义上似乎要简单得多，因为我们只处理两列：`日期`和任何给定日期的`销售额`数量。我们还可以看到销售额是按天聚合的，从`2014-01-01`开始。如果我们使用`tail()`函数检查数据集的末尾，我们将看到数据集在`2020-12-23`结束——基本上为我们提供了6年的销售额数据来工作。

1.  我们可以使用`Plotly`库来可视化时间序列数据：

    [PRE1]

    执行`fig.show()`函数后，我们将收到以下输出：

    ![图10.2 – 销售数据集的时间序列图](img/B17761_10_002.jpg)

    图10.2 – 销售数据集的时间序列图

    我们可以立即对数据集做出一些初步观察：

    +   数据中存在大量的噪声和变异性。

    +   销售额随时间逐渐增加（我应该投资它们！）。

    +   销售额似乎存在季节性因素，销售额在12月达到峰值。

    为了更深入地探索这些想法并深入数据，我们需要分解时间序列方面。使用`日期`列，我们可以将数据集分解为年、月和日，以更好地了解数据的重复或**季节性**特征。

    重要提示

    数据集中的**季节性**指的是与该年份时间相关的季节性特征。例如，与流感疫苗相关的数据集通常在秋季相对于春季或夏季显示出增加的比率，为冬季（流感季节）做准备。

1.  首先，我们需要使用`to_datetime()`函数将`字符串`转换为`日期`类型：

    [PRE2]

    执行此命令后，我们将收到以下DataFrame作为输出：

    ![图10.3 – 显示新特征的销售额数据集的前五行](img/B17761_10_003.jpg)

    图10.3 – 显示新特征的销售额数据集的前五行

1.  在这里，我们可以看到我们能够分解时间序列方面，并产生比最初开始时更多的数据。让我们继续按`年`绘制数据：

    [PRE3]

    在绘制我们的数据后，我们将收到以下箱线图，它显示了每年的销售额。从统计学的角度来看，我们可以证实我们的初步观察，即销售额每年都在逐渐增加：

    ![图10.4 – 显示每年销售额增长的箱线图](img/B17761_10_004.png.jpg)

    图10.4 – 显示每年销售额增长的箱线图

1.  让我们继续绘制每个给定`月份`的相同图表：

    [PRE4]

    当我们将*x*-轴从年份改为月份时，我们将收到以下图表，证实我们的观察，即销售数据倾向于在1月（**1**）/12月（**12**）的时间框架内达到峰值：

    ![图10.5 – 显示每月季节性销售的箱线图](img/B17761_10_005.jpg)

    图10.5 – 显示每月季节性销售的箱线图

    之前，我们提到数据集中包含大量的噪声，即在数据中存在大量的波动。我们可以通过取**滚动平均**（**移动平均**）来解决这个问题并使数据归一化，这是一种用于帮助我们通过创建一系列平均值来分析数据点的计算方法。

1.  我们可以直接使用`rolling()`函数在我们的DataFrame中实现这一点：

    [PRE5]

1.  注意，在前面的代码中，我们使用了两个示例来通过使用20和100的窗口值来展示滚动平均的概念。使用`Plotly Go`，我们可以将原始原始数据和两个滚动平均值绘制在单个图表上：

    [PRE6]

    执行此代码后，我们将收到以下输出：

![图10.6 – 显示每月季节性销售的箱线图](img/B17761_10_006.jpg)

图10.6 – 显示销售数据滚动平均的箱线图

注意，原始数据集以淡色在背景中绘制，由表示20个`window`值的虚线曲线覆盖，以及表示100个`window`值的实线曲线在前景中。使用滚动平均值在尝试可视化和理解数据以及构建预测模型时可能很有用，正如我们将在本章后面看到的那样。

重要提示

**滚动平均**（**移动平均**）是一种计算方法，通过在整个特定范围内取移动平均值来平滑噪声数据集。这个范围通常被称为窗口，通常是最后*x*个数据点。

时间序列数据与我们在本书中迄今为止探索的大多数数据集非常不同。与其他数据集不同，时间序列数据通常被认为与几个**组成部分**一致，所有这些我们将在下一节中探讨。

# 探索时间序列数据集的组成部分

在本节中，我们将探讨通常被认为是时间序列数据集组成部分的四个主要项目，并将它们可视化。考虑到这一点，让我们开始吧！

时间序列数据集通常由四个主要组成部分组成：**水平**、**长期**趋势、**季节性**和**不规则噪声**，我们可以将这些分解成一种称为时间序列**分解**的方法。分解背后的主要目的是通过更抽象地思考数据来更好地了解数据集。我们可以将时间序列组成部分视为加法或乘法：

![图10.1 – 公式](img/B17761_10_001.png)

![图10.6 – 显示销售数据滚动平均的箱线图](img/B17761_10_002.png)

我们可以这样定义每个组成部分：

+   **水平**：数据集随时间变化的平均值

+   **长期趋势**：数据的一般方向，显示增加或减少

+   **季节性趋势**：短期重复性特征（天数、周数、月数）

+   **不规则趋势**：数据中的随机波动噪声

我们可以使用`statsmodels`库结合我们的数据集，通过以下简单步骤来更深入地探索和可视化这些化合物：

1.  首先，我们需要通过仅保留销售列、删除任何缺失值并将日期列设置为DataFrame的**索引**来调整我们的数据集：

    [PRE7]

1.  我们可以检查前几行以确认日期现在是我们的索引：![图10.7 – 调整后的数据集的前几行](img/B17761_10_007.jpg)

    图10.7 – 调整后的数据集的前几行

1.  接下来，我们将从`statsmodels`库中导入`seasonal_decompose`函数并将其应用于我们的`dataframe`：

    [PRE8]

1.  最后，我们可以使用内置的`plot()`函数绘制结果并查看结果：

    [PRE9]

    使用`show()`函数将给出以下输出：

![图10.8 – 季节分解函数的结果](img/B17761_10_008.png.jpg)

图10.8 – 季节分解函数的结果

在这里，我们可以看到本节中提到的四个组成部分。在第一个图表中，我们可以看到我们在上一节中计算的自回归移动平均。然后是**长期趋势**，它显示了整个数据集的稳步增长。然后我们可以看到数据集背后的**季节性**，证实了销售在12月和1月的时间框架内倾向于增加。最后，我们可以看到数据集中的**残差**数据或**噪声**。我们可以将这种噪声定义为未对其他主要类别做出贡献的项目。

分解数据集通常是为了更好地理解数据及其一些主要特征，这通常会改变你对数据集以及任何可以开发的给定预测模型的看法。我们将在下一节中学习如何开发两种常见的预测模型。

# 教程 – 使用Prophet和LSTM预测需求

在本教程中，我们将使用上一节中的销售数据集来开发两个稳健的需求预测模型。我们的主要目标将是使用销售数据来预测未来的需求。**需求预测**通常用于预测在给定日期或地点要销售的单元数量。全球各地的公司，尤其是那些处理对温度敏感或对时间敏感的药物的公司，依赖于这些模型来优化其供应链并确保满足患者的需求。

首先，我们将探索Facebook著名的**Prophet**库，然后开发一个定制的**长短期记忆**（**LSTM**）深度学习模型。考虑到这一点，让我们继续研究如何使用Prophet模型。

## 使用Prophet进行时间序列建模

Prophet是一个在2017年首次发布时就获得了数据科学界广泛关注的模型。作为一个既在**R**又在**Python**中可用的开源库，该模型很快被采用并广泛用作时间序列数据的主要预测模型之一。这个模型背后的最大好处之一也是其后果之一——它的高度抽象性质，使用户只需几行代码就能做出预测。这种有限的变异性可以是一种快速预测的好方法，但可能会阻碍模型开发过程，具体取决于手头的数据集。

在接下来的几页中，我们将开发一个使用我们的数据进行拟合的Prophet模型，以预测未来的销售并通过对实际销售数据进行比较来验证结果。让我们开始吧：

1.  首先，让我们使用`rolling()`函数来获取数据集的滚动平均值。然后，我们可以将这个值叠加到原始值上：

    [PRE10]

1.  这将产生以下输出：![图10.9 – 与原始数据集相关的滚动平均值](img/B17761_10_009.jpg)

    图10.9 – 与原始数据集相关的滚动平均值

    在这里，我们可以看到数据集现在要少得多**噪声**，更容易处理。我们可以使用**Prophet**库和我们的数据集通过以下四个基本步骤来创建预测：

1.  首先，我们需要将DataFrame重塑以与`Prophet`库集成。该库期望DataFrame包含两列——`ds`和`y`，其中`ds`是日期戳，`y`是我们正在处理的价值。我们可以使用以下代码将这个DataFrame重塑为一个新的DataFrame：

    [PRE11]

1.  与`sklearn`库的实现类似，我们可以创建一个Prophet模型的实例并将其`fit`到我们的数据集上：

    [PRE12]

1.  接下来，我们可以调用`make_future_dataframe()`函数和感兴趣的周期数。这将产生一个包含日期列的DataFrame：

    [PRE13]

1.  最后，我们可以使用`predict()`函数，将未来变量作为输入参数来做出预测。这将返回与数据集相关的多个统计值：

    [PRE14]

    我们可以限制数据集的范围到几个列，并检索以下DataFrame：

    ![图10.10 – Prophet预测函数的输出](img/B17761_10_010.jpg)

    图10.10 – Prophet预测函数的输出

1.  现在，我们可以使用**Prophet**实例的内置`plot()`函数来可视化我们的预测：

    [PRE15]

    这将产生以下输出，显示了原始的原始数据集、未来的预测以及一些上限和下限：

    ![图10.11 – 预测数据的图形表示](img/B17761_10_011.jpg)

    图10.11 – 预测数据的图形表示

1.  或者，我们可以通过使用数据的一部分来训练模型来测试模型的能力——例如，直到2018年为止的所有数据。然后，我们可以使用预测模型来预测剩余的时间，并将输出与实际数据进行比较。完成此操作后，我们将收到以下输出：

![图10.12 – 训练和测试数据的图形表示](img/B17761_10_012.jpg)

图10.12 – 训练和测试数据的图形表示

在这里，我们可以看到代表预测销售的虚线与实际值非常接近。我们还可以看到，模型没有预测曲线的极端值，因此可能需要额外的调整以达到更现实的预测。然而，**Prophet** 的高级特性可能在这方面有所限制。

从这里，我们可以看到准备数据和实现模型非常快，我们只用几行代码就完成了这项工作。在下一节中，我们将学习如何使用**Keras**开发**LSTM**。

## 使用LSTM进行时间序列建模

**LSTM**模型首次在1997年获得流行，然后在计算能力增加的近年再次流行。如您所回忆的，LSTMs是一种可以记住和忘记数据集中模式的**循环神经网络**（**RNN**）。这种模型的主要优点是其中到低级的特性，即相对于**Prophet**，需要更多的代码来实现。用户在模型开发过程中获得了极大的控制权，使他们能够将模型定制为几乎任何类型的数据库和任何类型的用例。考虑到这一点，让我们开始：

1.  使用相同的数据库，我们可以继续创建一个使用`20`个窗口的滚动平均值，以减少数据集中的噪声。然后，我们可以移除由此产生的缺失值：

    [PRE16]

1.  使用来自`sklearn`库的`MinMaxScaler`，我们可以继续对数据进行缩放：

    [PRE17]

1.  接下来，我们需要将数据分成我们的训练集和测试集。记住，我们的目标是向模型提供一些历史样本数据，并查看我们是否可以准确预测未来的需求。让我们继续使用数据集的75%来训练模型，并查看我们是否可以预测剩余的25%：

    [PRE18]

1.  由于我们正在处理时间序列数据，我们需要使用`lookback`来迭代训练模型。让我们继续选择一个`lookback`值为`100`，并使用我们的`dataset_generator`函数来创建我们的训练和测试集。我们可以将`lookback`值视为模型在数据中回溯的范围，以进行训练：

    [PRE19]

1.  如您从我们之前实现的LSTM模型中回忆的那样，我们需要在使用数据作为输入之前对数据进行`reshape`：

    [PRE20]

1.  最后，数据准备就绪后，我们可以继续准备模型本身。鉴于我们只处理一个特征，我们可以保持模型相对简单。首先，我们将使用Keras的`Sequential`类，然后添加一个具有两个节点的`LSTM`层，接着是一个具有单个输出值的`Dense`层：

    [PRE21]

1.  接下来，我们可以使用学习率为`0.001`的`Adam`优化器并编译模型：

    [PRE22]

1.  记住，我们可以使用`summary()`函数来查看编译后的模型：

    [PRE23]

    这将导致以下输出，它提供了对模型内部工作的洞察：

    ![图10.13 – Keras模型的摘要](img/B17761_10_013.jpg)

    图10.13 – Keras模型的摘要

1.  模型编译完成后，我们可以开始训练过程。我们可以调用`fit()`函数，将模型在训练数据集上拟合10个epoch：

    [PRE24]

1.  模型训练过程应该相对较快。一旦完成，我们可以通过在图表中可视化结果来查看`loss`值：

    [PRE25]

    这将导致以下输出，显示了损失随时间逐渐减少的过程：

    ![图10.14 – 随时间变化的模型损失](img/B17761_10_014.png.jpg)

    图10.14 – 随时间变化的模型损失

    在这里，我们可以看到`loss`值相当一致地下降，最终在9-10个epoch标记处达到平台期。请注意，我们在优化器中指定了学习率为`0.001`。如果我们将其增加到0.01，或者减少到0.0001，此图表的输出将非常不同。我们可以使用学习率作为优化模型性能的强大参数。尝试一下，看看损失的图形输出会是什么样子。

1.  模型训练完成后，我们可以继续使用该模型来预测感兴趣的值：

    [PRE26]

1.  数据准备就绪后，我们可以通过使用`matplotlib`绘制结果来可视化数据。首先，让我们使用`lightgrey`绘制原始数据集：

    [PRE27]

1.  接下来，我们可以使用`blue`绘制训练值：

    [PRE28]

1.  最后，我们可以使用`darkorange`和虚线来绘制预测值，以区分其两个对应物：

    [PRE29]

    执行此代码后，我们将得到以下输出：

![图10.15 – 使用LSTM模型的训练和测试数据集](img/B17761_10_015.png.jpg)

图10.15 – 使用LSTM模型的训练和测试数据集

在这里，我们可以看到这个相对简单的**LSTM**模型在利用我们提供的训练数据集进行预测方面非常有效。该模型不仅能够捕捉到值的总体趋势，而且还成功地捕捉到了值的季节性。

# 摘要

在本章中，我们试图分析和理解时间序列数据，并在不到15页的篇幅内开发了两个预测预测模型。我们的旅程从探索和分解时间序列数据开始，将其分解成更小的特征，这些特征通常可以与浅层机器学习模型一起使用。然后，我们研究了时间序列数据集的组成部分，以了解其底层结构。最后，我们开发了两个在行业中常用的最常见预测模型——Facebook的Prophet模型和基于Keras的LSTM模型。

在过去的几章中，我们开发了各种技术解决方案来解决常见的商业问题。在下一章中，我们将探讨使用Flask框架将这些模型如这些模型提供给最终用户的第一个步骤。
