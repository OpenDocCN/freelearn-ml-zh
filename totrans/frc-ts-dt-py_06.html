<html><head></head><body>
<div id="_idContainer154">
<h1 class="chapter-number" id="_idParaDest-70"><a id="_idTextAnchor375"/><a id="_idTextAnchor376"/><a id="_idTextAnchor377"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-71"><a id="_idTextAnchor378"/><span class="koboSpan" id="kobo.2.1">Forecasting Holiday Effects</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Because Prophet was designed to handle business forecasting cases, it is important to include the effects of holidays, which naturally play a large role in business activities. </span><span class="koboSpan" id="kobo.3.2">Just as bike-share commuters will ride more frequently in the summer than in the winter, or on Tuesdays than on Sundays, it is reasonable to hypothesize that they would ride less than otherwise expected on Thanksgiving, </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">for example.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Fortunately, Prophet includes robust support for including the effects of holidays in your forecasts. </span><span class="koboSpan" id="kobo.5.2">Furthermore, the techniques Prophet has for including the effects of holidays can be used to add any holiday-like event, such as the food festival that we will model in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Similar to the seasonality effects you learned about in the previous chapter, Prophet contains default holidays that you can apply to your models, as well as custom holidays that you can create yourself. </span><span class="koboSpan" id="kobo.7.2">This chapter will cover both situations. </span><span class="koboSpan" id="kobo.7.3">Additionally, you will learn how to control the strength of holiday effects using the technique that you learned to use for </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">seasonality: regularization.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, you will learn how to go about doing </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Adding default </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">country holidays</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Adding default state or </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">province holidays</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">custom holidays</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">multi-day holidays</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Regularizing holidays</span></span></li>
</ul>
<h1 id="_idParaDest-72"><a id="_idTextAnchor379"/><a id="_idTextAnchor380"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.21.1">The data files and code for the examples in this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">at </span></span><a href="https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition"><span class="No-Break"><span class="koboSpan" id="kobo.23.1">https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.24.1">.</span></span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor381"/><a id="_idTextAnchor382"/><span class="koboSpan" id="kobo.25.1">Adding default country holidays</span></h1>
<p><span class="koboSpan" id="kobo.26.1">Prophet </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.27.1">uses the</span><a id="_idTextAnchor383"/><span class="koboSpan" id="kobo.28.1"> Python </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">holidays</span></strong><span class="koboSpan" id="kobo.30.1"> package to populate a default list of holidays by country and, optionally, by state or province. </span><span class="koboSpan" id="kobo.30.2">To specify which region to build a holiday list for, Prophet requires the name or ISO code of that country. </span><span class="koboSpan" id="kobo.30.3">A complete list of all countries available, with their ISO codes, and also any states or provinces that can be included, can be viewed in the package’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">README</span></strong><span class="koboSpan" id="kobo.32.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">here: </span></span><a href="https://github.com/dr-prodigy/python-holidays#available-countries"><span class="No-Break"><span class="koboSpan" id="kobo.34.1">https://github.com/dr-prodigy/python-holidays#available-countries</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.35.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">To add the default holidays, Prophet includes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">add_country_holidays</span></strong><span class="koboSpan" id="kobo.38.1"> method, which simply takes the ISO code for that country. </span><span class="koboSpan" id="kobo.38.2">Let’s walk through an example using the Divvy dataset again, first adding holidays for the United States, and then including a few additional holidays specific to Illinois, as Divvy is located </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">in Chicago.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">We will begin just as we have learned to do with our other models in this book, by importing the necessary libraries, loading our data, and instantiating our model. </span><span class="koboSpan" id="kobo.40.2">As you learned how to do in </span><a href="B19630_05.xhtml#_idTextAnchor254"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.41.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.42.1">, </span><em class="italic"><span class="koboSpan" id="kobo.43.1">Working with Seasonality</span></em><span class="koboSpan" id="kobo.44.1">, we will set the seasonality mode to multiplicative and the yearly seasonality to a Fourier order </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.48.1">
import pandas as pd
import matplotlib.pyplot as plt
from prophet import Prophet
df = pd.read_csv('divvy_daily.csv')
df = df[['date', 'rides']]
df['date'] = pd.to_datetime(df['date'])
df.columns = ['ds', 'y']
model = Prophet(seasonality_mode='multiplicative',
                yearly_seasonality=4)</span></pre>
<p><span class="koboSpan" id="kobo.49.1">This next line is all that is required to populate the model with a list of holidays for the </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">United States:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.51.1">
model.add_country_holidays(country_name='US')</span></pre>
<p><span class="koboSpan" id="kobo.52.1">Now, to</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.53.1"> complete the model, all we need to do is call </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">fit</span></strong><span class="koboSpan" id="kobo.55.1"> as usual on the training DataFrame, mak</span><a id="_idTextAnchor384"/><span class="koboSpan" id="kobo.56.1">e our future DataFrame, and call </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">predict</span></strong><span class="koboSpan" id="kobo.58.1"> on it. </span><span class="koboSpan" id="kobo.58.2">We will plot the forecast and components to view </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">our results:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.60.1">
model.fit(df)
future = model.make_future_dataframe(periods=365)
forecast = model.predict(future)
fig = model.plot(forecast)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.61.1">The output forecast plot looks very similar to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.62.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.63.1">.7</span></em><span class="koboSpan" id="kobo.64.1"> from </span><a href="B19630_05.xhtml#_idTextAnchor254"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.65.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.66.1">, </span><em class="italic"><span class="koboSpan" id="kobo.67.1">Working </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.68.1">with Seasonality</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">:</span></span><a id="_idTextAnchor385"/></p>
<div>
<div class="IMG---Figure" id="_idContainer143">
<span class="koboSpan" id="kobo.70.1"><img alt="Figure 6.1 – Divvy forecast including US holidays" src="image/Fig_6.1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.71.1">Figure 6.1 – Divvy forecast including US holidays</span></p>
<p><span class="koboSpan" id="kobo.72.1">However, the eagle-eyed</span><a id="_idTextAnchor386"/><span class="koboSpan" id="kobo.73.1"> may notice some downward spikes around the middle of the year and the end of the year. </span><span class="koboSpan" id="kobo.73.2">To discern what those are, we will look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">components</span></strong><span class="koboSpan" id="kobo.75.1"> plot </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.77.1">
fig2 = model.plot_components(forecast)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.78.1">In the </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.79.1">output of those commands, the trend and both weekly and yearly seasonalities are again included and look much the same. </span><span class="koboSpan" id="kobo.79.2">However, there is a new plot shown: holidays, as seen here (note that the preceding code produces a full </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">components</span></strong><span class="koboSpan" id="kobo.81.1"> plot; the following figure is a crop of </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">that image):</span></span><a id="_idTextAnchor387"/></p>
<div>
<div class="IMG---Figure" id="_idContainer144">
<span class="koboSpan" id="kobo.83.1"><img alt="Figure 6.2 – Divvy US holidays component" src="image/Fig_6.2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.84.1">Figure 6.2 – Divvy US holidays component</span></p>
<p><span class="koboSpan" id="kobo.85.1">This shows spikes where Divvy deviates from the trend, each spike corresponding to a holiday. </span><span class="koboSpan" id="kobo.85.2">Each holiday</span><a id="_idTextAnchor388"/><span class="koboSpan" id="kobo.86.1"> shows decreased usage except for one, which occurs in the final quarter of each year. </span><span class="koboSpan" id="kobo.86.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">investigate this.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">We can view the holidays included in our model with </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">this command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.90.1">
model.train_holiday_names</span></pre>
<p><span class="koboSpan" id="kobo.91.1">This outputs a Python object containing an index and the holiday names included in </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">the model:</span></span></p>
<p class="IMG---Figure"><a id="_idTextAnchor389"/></p>
<div>
<div class="IMG---Figure" id="_idContainer145">
<span class="koboSpan" id="kobo.93.1"><img alt="Figure 6.3 – US holidays" src="image/Fig_6.3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.94.1">Figure 6.3 – US holidays</span></p>
<p><span class="koboSpan" id="kobo.95.1">Each of these holidays has been included in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">forecast</span></strong><span class="koboSpan" id="kobo.97.1"> DataFrame that was covered in </span><a href="B19630_02.xhtml#_idTextAnchor104"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.98.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.99.1">, </span><em class="italic"><span class="koboSpan" id="kobo.100.1">Getting Started with Prophet</span></em><span class="koboSpan" id="kobo.101.1">. </span><span class="koboSpan" id="kobo.101.2">For each holiday, three new columns are added for the predicted effect of that holiday, as well as lower and upper bounds for the uncertainty, for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">"New Year's Day"</span></strong><span class="koboSpan" id="kobo.103.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">"New Year's Day_lower"</span></strong><span class="koboSpan" id="kobo.105.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">"New Year's Day_upper"</span></strong><span class="koboSpan" id="kobo.107.1">. </span><span class="koboSpan" id="kobo.107.2">Using these new columns, we can see precisely what effect each holiday has on our forecast by printing the first non-zero value for each holiday in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">forecast</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.109.1"> DataFrame.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">To do this, let’s</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.111.1"> create a quick function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">first_non_zero</span></strong><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">The function takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">forecast</span></strong><span class="koboSpan" id="kobo.115.1"> DataFrame and</span><a id="_idTextAnchor390"/><span class="koboSpan" id="kobo.116.1"> the name of a holiday; it returns the first value for that holiday that does not equal zero. </span><span class="koboSpan" id="kobo.116.2">Then, we’ll use a Python list comprehension to loop over each holiday name and call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">first_non_zero</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.118.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.119.1">
def first_non_zero(fcst, holiday):
    return fcst[fcst[holiday] != 0][holiday].values[0]
pd.DataFrame({'holiday': model.train_holiday_names,
              'effect': [first_non_zero(forecast, holiday)
                         for holiday in \
                         model.train_holiday_names]})</span></pre>
<p><span class="koboSpan" id="kobo.120.1">Because each row of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">forecast</span></strong><span class="koboSpan" id="kobo.122.1"> DataFrame is a date, most of the values in each holiday column will be zero, as the holiday does not affect these dates. </span><span class="koboSpan" id="kobo.122.2">On the date the holiday occurs, the value will either be positive, indicating more ridership than otherwise expected, or negative, for </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">less ridership.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">Prophet models each holiday as having the same effect every year, so this value will be constant from year to year. </span><span class="koboSpan" id="kobo.124.2">Because we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">seasonality_mode='multiplicative'</span></strong><span class="koboSpan" id="kobo.126.1"> in this case, these effects are calculated as</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.127.1"> a percentage deviation from the trend (just to make it clear: the global </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">seasonality_mode</span></strong><span class="koboSpan" id="kobo.129.1"> affects holidays as well). </span><span class="koboSpan" id="kobo.129.2">The following table shows </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">these effects:</span></span><a id="_idTextAnchor391"/></p>
<div>
<div class="IMG---Figure" id="_idContainer146">
<span class="koboSpan" id="kobo.131.1"><img alt="Figure 6.4 – Holiday effect values" src="image/Fig_6.4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.132.1">Figure 6.4 – Holiday effect values</span></p>
<p><span class="koboSpan" id="kobo.133.1">Now, we can</span><a id="_idTextAnchor392"/><span class="koboSpan" id="kobo.134.1"> clearly see that </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">Columbus Day</span></strong><span class="koboSpan" id="kobo.136.1"> creates a 5% boost to ridership for Divvy. </span><span class="koboSpan" id="kobo.136.2">All other holidays have negative effects, with Labor Day having the strongest at 69% fewer riders than the trend would </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">otherwise predict.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">This process you’ve just learned is Prophet’s basic holiday functionality; it’s analogous to the default seasonalities produced when no additional arguments are provided to Prophet. </span><span class="koboSpan" id="kobo.138.2">It works great in many cases and is often all that the model will require. </span><span class="koboSpan" id="kobo.138.3">But, just as the </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.139.1">analyst can take finer control of seasonality effects, there are several techniques the analyst can use to control holidays beyond the default settings. </span><span class="koboSpan" id="kobo.139.2">In the next section, we’ll cover the process for adding holidays specific to a state </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">or province</span><a id="_idTextAnchor393"/><a id="_idTextAnchor394"/><span class="koboSpan" id="kobo.141.1">.</span></span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor395"/><span class="koboSpan" id="kobo.142.1">Adding default state/province holidays</span></h1>
<p><span class="koboSpan" id="kobo.143.1">Adding th</span><a id="_idTextAnchor396"/><span class="koboSpan" id="kobo.144.1">e </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.145.1">holidays specific to Illinois is not so straightforward, because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">add_country_holidays</span></strong><span class="koboSpan" id="kobo.147.1"> method only takes an argument for the country, but not the state or province. </span><span class="koboSpan" id="kobo.147.2">To add state- or province-level holidays, we need to use a new Prophet function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">make_holidays_df</span></strong><span class="koboSpan" id="kobo.149.1">. </span><span class="koboSpan" id="kobo.149.2">Let’s import </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">it here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.151.1">
from prophet.make_holidays import make_holidays_df</span></pre>
<p><span class="koboSpan" id="kobo.152.1">This function takes a list of years for which to populate the holidays as input, as well as arguments for the country and state or province. </span><span class="koboSpan" id="kobo.152.2">Note that you must use all years in your training DataFrame, as well as all the years for which you intend to predict. </span><span class="koboSpan" id="kobo.152.3">That is why, in the following code, we build a year list to contain all unique years in the training DataFrame. </span><span class="koboSpan" id="kobo.152.4">Then, because our </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">make_future_dataframe</span></strong><span class="koboSpan" id="kobo.154.1"> command will add one year to the forecast, we need to extend that year list to include one </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">additional year:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
year_list = df['ds'].dt.year.unique().tolist()
# Identify the final year, as an integer, and increase it by 1
year_list.append(year_list[-1] + 1)
holidays = make_holidays_df(year_list=year_list,
                            country='US',
                            state='IL')</span></pre>
<p><span class="koboSpan" id="kobo.157.1">Before moving on, let’s take a quick look at the format of this </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">holidays</span></strong><span class="koboSpan" id="kobo.159.1"> DataFrame by printing the first </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">five rows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.161.1">
holidays.head()</span></pre>
<p><span class="koboSpan" id="kobo.162.1">As you can see from the following output, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">holidays</span></strong><span class="koboSpan" id="kobo.164.1"> DataFrame consists of two columns, </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">ds</span></strong><span class="koboSpan" id="kobo.166.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">holiday</span></strong><span class="koboSpan" id="kobo.168.1">, with the date of the holiday and its </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">name, respectively</span><a id="_idTextAnchor397"/><span class="koboSpan" id="kobo.170.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer147">
<span class="koboSpan" id="kobo.171.1"><img alt="Figure 6.5 – Illinois holidays" src="image/Fig_6.5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.172.1">Figure 6.5 – Illinois holidays</span></p>
<p><span class="koboSpan" id="kobo.173.1">To load these holidays into our Prophet model, we simply pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">holidays</span></strong><span class="koboSpan" id="kobo.175.1"> DataFrame to our mode</span><a id="_idTextAnchor398"/><span class="koboSpan" id="kobo.176.1">l when we instantiate it and continue as we </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">have before:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.178.1">
model = Prophet(seasonality_mode='multiplicative',
                yearly_seasonality=4,
                holidays=holidays)
model.fit(df)
future = model.make_future_dataframe(periods=365)
forecast = model.predict(future)</span></pre>
<p><span class="koboSpan" id="kobo.179.1">If you go </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.180.1">ahead and call </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">model.train_holiday_names</span></strong><span class="koboSpan" id="kobo.182.1"> again, you will see four additional holidays specific to Illinois that are not official United States holidays: Lincoln’s Birthday, Casimir Pulaski Day, Election Day, and Lincoln’s </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">Birthday (Observed</span><a id="_idTextAnchor399"/><a id="_idTextAnchor400"/><span class="koboSpan" id="kobo.184.1">).</span></span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor401"/><span class="koboSpan" id="kobo.185.1">Creating custom holidays</span></h1>
<p><span class="koboSpan" id="kobo.186.1">The defau</span><a id="_idTextAnchor402"/><span class="koboSpan" id="kobo.187.1">lt </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.188.1">holidays for the United States include both Thanksgiving and Christmas, as they are official holidays. </span><span class="koboSpan" id="kobo.188.2">However, it’s quite plausible that Black Friday and Christmas Eve would also create ridership behavior that deviates from the expected trend. </span><span class="koboSpan" id="kobo.188.3">So, we naturally decide to include these in </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">our forecast.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">In this example, we will create a DataFrame of the default US holidays in a similar manner to how we created the DataFrame of the Illinois holidays previously, and then add our custom holidays to it. </span><span class="koboSpan" id="kobo.190.2">To create custom holidays, you simply need to create a DataFrame with two columns: </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">holiday</span></strong><span class="koboSpan" id="kobo.192.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">ds</span></strong><span class="koboSpan" id="kobo.194.1">. </span><span class="koboSpan" id="kobo.194.2">As done previously, it must include all occurrences of the holiday in the past (at least, as far back as your training data goes) and into the future that we intend </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">to forecast.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">In this example, we will start by creating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">holidays</span></strong><span class="koboSpan" id="kobo.198.1"> DataFrame populated with the default US holidays and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">year_list</span></strong><span class="koboSpan" id="kobo.200.1"> from the </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">previous example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.202.1">
holidays = make_holidays_df(year_list=year_list,
                            country='US')</span></pre>
<p><span class="koboSpan" id="kobo.203.1">We are going</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.204.1"> to en</span><a id="_idTextAnchor403"/><span class="koboSpan" id="kobo.205.1">rich this list of default holidays with our custom holidays, so now we will create two DataFrames with the specified columns (</span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">holiday</span></strong><span class="koboSpan" id="kobo.207.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">ds</span></strong><span class="koboSpan" id="kobo.209.1">), one for </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">Black Friday</span></strong><span class="koboSpan" id="kobo.211.1"> and one for </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">Christmas Eve</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.214.1">
black_friday = pd.DataFrame({'holiday': 'Black Friday',
                             'ds': pd.to_datetime(
                                 ['2014-11-28',
                                  '2015-11-27',
                                  '2016-11-25',
                                  '2017-11-24',
                                  '2018-11-23'])})
christmas_eve = pd.DataFrame({'holiday': 'Christmas Eve',
                              'ds': pd.to_datetime(
                                  ['2014-12-24',
                                   '2015-12-24',
                                   '2016-12-24',
                                   '2017-12-24',
                                   '2018-12-24'])})</span></pre>
<p><span class="koboSpan" id="kobo.215.1">Of course, you could create just one DataFrame with both holidays as individual rows, but for clarity, I have separated </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">them out.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">Finally, we just need to concatenate these three </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">holiday</span></strong><span class="koboSpan" id="kobo.219.1"> DataFrames </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">into one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
holidays = pd.concat([holidays, black_friday,
                      christmas_eve]).sort_values('ds')\
                      .reset_index(drop=True)</span></pre>
<p><span class="koboSpan" id="kobo.222.1">It is not strictly necessary to sort the values or reset the index, as we did in the preceding code, but it does make the DataFrame more visually clear if you intend to </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">inspect it.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">With our </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">holidays</span></strong><span class="koboSpan" id="kobo.226.1"> DataF</span><a id="_idTextAnchor404"/><span class="koboSpan" id="kobo.227.1">rame complete, we now pass it to Prophet when we instantiate the model, just as we did with the Illinois holidays previously, and continue to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">fit</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.229.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">predict</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.232.1">
model = Prophet(seasonality_mode='multiplicative',
                yearly_seasonality=4,
                holidays=holidays)
model.fit(df)
future = model.make_future_dataframe(periods=365)
forecast = model.predict(future)</span></pre>
<p><span class="koboSpan" id="kobo.233.1">Now, if you inspect the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">forecast</span></strong><span class="koboSpan" id="kobo.235.1"> DataFrame or your </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">components</span></strong><span class="koboSpan" id="kobo.237.1"> plot, you will indeed see two </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.238.1">additional holidays each year, one for Black Friday and one </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">for Thanksgiving.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">Creating holidays in this way allows for much more granular control over individual holidays. </span><span class="koboSpan" id="kobo.240.2">Next, we’ll look at some additional parameters you can use to tune </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">your holi</span><a id="_idTextAnchor405"/><a id="_idTextAnchor406"/><span class="koboSpan" id="kobo.242.1">days.</span></span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor407"/><span class="koboSpan" id="kobo.243.1">Creating multi-day holidays</span></h1>
<p><span class="koboSpan" id="kobo.244.1">Sometim</span><a id="_idTextAnchor408"/><span class="koboSpan" id="kobo.245.1">es, a holiday</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.246.1"> or other special event will span several days. </span><span class="koboSpan" id="kobo.246.2">Fortunately, Prophet includes functionality to handle these scenarios via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">window</span></strong><span class="koboSpan" id="kobo.248.1"> arguments. </span><span class="koboSpan" id="kobo.248.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">holidays</span></strong><span class="koboSpan" id="kobo.250.1"> DataFrame we have been building to populate our holidays in the previous examples can include the optional columns of </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">'lower_window'</span></strong><span class="koboSpan" id="kobo.252.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">'upper_window'</span></strong><span class="koboSpan" id="kobo.254.1">. </span><span class="koboSpan" id="kobo.254.2">These columns specify additional days either before or after the main holiday that Prophet </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">will model.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">For example, in the previous example, we modeled Christmas and Christmas Eve as two different holidays. </span><span class="koboSpan" id="kobo.256.2">Another method would have been just to model Christmas but include a </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">'lower_window'</span></strong><span class="koboSpan" id="kobo.258.1"> argument of </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">1</span></strong><span class="koboSpan" id="kobo.260.1">, telling Prophet to include a single day before Christmas as part of the holiday. </span><span class="koboSpan" id="kobo.260.2">This assumes, of course, that Christmas Eve will always fall on the day before Christmas. </span><span class="koboSpan" id="kobo.260.3">If, however, Christmas Eve were a holiday that floated and did not always fall immediately before Christmas, this </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">window</span></strong><span class="koboSpan" id="kobo.262.1"> method would not </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">be used.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">Every July, Chicago h</span><a id="_idTextAnchor409"/><span class="koboSpan" id="kobo.265.1">olds a 5-day festival called the </span><em class="italic"><span class="koboSpan" id="kobo.266.1">Taste of Chicago</span></em><span class="koboSpan" id="kobo.267.1">. </span><span class="koboSpan" id="kobo.267.2">It is the largest food festival in the world and Chicago’s largest festival of any kind. </span><span class="koboSpan" id="kobo.267.3">More than one million people attend each year to try food from nearly 100 different vendors or attend popular concerts each day. </span><span class="koboSpan" id="kobo.267.4">With such large crowds of people moving around the city, it would be surprising if it had no effect at all on Divvy’s ridership. </span><span class="koboSpan" id="kobo.267.5">In this example, we will model Taste of Chicago as a 5-day holiday and see what effect that has on </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">Divvy’s forecast.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">As done previously, we</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.270.1"> begin by creating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">holidays</span></strong><span class="koboSpan" id="kobo.272.1"> DataFrame with the default US holidays. </span><span class="koboSpan" id="kobo.272.2">Next, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">taste_of_chicago</span></strong><span class="koboSpan" id="kobo.274.1"> DataFrame with the dates set as the first day of th</span><a id="_idTextAnchor410"/><span class="koboSpan" id="kobo.275.1">e event each year of both our historical data and our forecast period. </span><span class="koboSpan" id="kobo.275.2">Deviating from the previous example, though, we also include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">'lower_window'</span></strong><span class="koboSpan" id="kobo.277.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">'upper_window'</span></strong><span class="koboSpan" id="kobo.279.1"> columns, setting the lower to </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">0</span></strong><span class="koboSpan" id="kobo.281.1"> (so we include no dates prior to the first day of the event) and the upper to </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">4</span></strong><span class="koboSpan" id="kobo.283.1"> (which includes four days after the first day of the event, for a total of five days). </span><span class="koboSpan" id="kobo.283.2">Then, we concatenate the DataFrames together </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
holidays = make_holidays_df(year_list=year_list,
                            country='US')
taste_of_chicago = \
pd.DataFrame({'holiday':'Taste of Chicago',
              'ds': pd.to_datetime(['2014-07-09',
                                    '2015-07-08',
                                    '2016-07-06',
                                    '2017-07-05',
                                    '2018-07-11']),
              'lower_window': 0,
              'upper_window': 4})
holidays = pd.concat([holidays, taste_of_chicago])\
                     .sort_values('ds')\
                     .reset_index(drop=True)</span></pre>
<p><span class="koboSpan" id="kobo.286.1">Now, let’s take a look at the first 10 rows of </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">the DataFrame:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.288.1">
holidays.head(10)</span></pre>
<p><span class="koboSpan" id="kobo.289.1">In the output, we </span><a id="_idTextAnchor411"/><span class="koboSpan" id="kobo.290.1">see the </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.291.1">additional columns, as well as the inclusion of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">Taste of </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Chicago</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.294.1"> h</span><a id="_idTextAnchor412"/><span class="koboSpan" id="kobo.295.1">oliday:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer148">
<span class="koboSpan" id="kobo.296.1"><img alt="Figure 6.6 – Holidays with windows" src="image/Fig_6.6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.297.1">Figure 6.6 – Holidays with windows</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.298.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.299.1">If you’re not familiar with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">NaN</span></strong><span class="koboSpan" id="kobo.301.1"> value in the preceding table, it stands for </span><em class="italic"><span class="koboSpan" id="kobo.302.1">Not a Number</span></em><span class="koboSpan" id="kobo.303.1">. </span><span class="koboSpan" id="kobo.303.2">It’s simply a placeholder in this case and has </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">no effect.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">And now, we will </span><a id="_idTextAnchor413"/><span class="koboSpan" id="kobo.306.1">proceed with fitting </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">our model:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.308.1">
model = Prophet(seasonality_mode='multiplicative',
                yearly_seasonality=4,
                holidays=holidays)
model.fit(df)
future = model.make_future_dataframe(periods=365)
forecast = model.predict(future)</span></pre>
<p><span class="koboSpan" id="kobo.309.1">To see what effect </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">Taste of Chicago</span></strong><span class="koboSpan" id="kobo.311.1"> has had on Divvy’s ridership, let’s take a look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">forecast</span></strong><span class="koboSpan" id="kobo.313.1"> DataFrame with this </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">print</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.315.1"> statement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.316.1">
print(forecast[forecast['ds'].isin(['2018-07-11',
                                    '2018-07-12',
                                    '2018-07-13',
                                    '2018-07-14',
                                    '2018-07-15']
                                  )][['ds',
                                      'Taste of Chicago']])</span></pre>
<p><span class="koboSpan" id="kobo.317.1">The output is the </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.318.1">contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">forecast</span></strong><span class="koboSpan" id="kobo.320.1"> DataFrame but limited to just the five days of the 2018 event, and the columns for the date and the effect of </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">Taste of Chicago</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.322.1">on rid</span><a id="_idTextAnchor414"/><span class="koboSpan" id="kobo.323.1">ership:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer149">
<span class="koboSpan" id="kobo.324.1"><img alt="Figure 6.7 – Effect of Taste of Chicago on ridership values" src="image/Fig_6.7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.325.1">Figure 6.7 – Effect of Taste of Chicago on ridership values</span></p>
<p><span class="koboSpan" id="kobo.326.1">We can see that the</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.327.1"> first day of the event had 3.6% fewer rides than would have been expected without the event, the second day had 1.9% more rides, and the third 6.8% more. </span><span class="koboSpan" id="kobo.327.2">The final 2 days both had about 2% more rides. </span><span class="koboSpan" id="kobo.327.3">The magnitudes of these numbers may n</span><a id="_idTextAnchor415"/><span class="koboSpan" id="kobo.328.1">ot be as large as you had expected, especially with the 4th of July causing a 55% reduction in ridership. </span><span class="koboSpan" id="kobo.328.2">And especially when taking into account that one of them is negative and the other positive, it’s possible that this result is not a meaningful signal but instead just due to random noise. </span><span class="koboSpan" id="kobo.328.3">In </span><a href="B19630_11.xhtml#_idTextAnchor728"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.329.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.330.1">, </span><em class="italic"><span class="koboSpan" id="kobo.331.1">Managing Uncertainty Intervals</span></em><span class="koboSpan" id="kobo.332.1">, you will learn how to verify whether this is a meaningful result </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">We can, however, visualize just this one holiday effect with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">plot_forecast_component</span></strong><span class="koboSpan" id="kobo.336.1"> function from Prophet’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">plot</span></strong><span class="koboSpan" id="kobo.338.1"> package. </span><span class="koboSpan" id="kobo.338.2">We need to import </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">it first:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.340.1">
from prophet.plot import plot_forecast_component</span></pre>
<p><span class="koboSpan" id="kobo.341.1">The function requires the first argument to be the model, the second argument to be the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">forecast</span></strong><span class="koboSpan" id="kobo.343.1"> DataFrame, and the third argument to be a string naming the component to plot; here, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">'Taste </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">of Chicago'</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
fig3 = plot_forecast_component(model,
                               forecast,
                               'Taste of Chicago',
                               figsize=(10.5, 3.25))
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.348.1">In the output, we can visualize exactly what the table in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.349.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.350.1">.7</span></em><span class="koboSpan" id="kobo.351.1"> displayed (except this time, we are displaying </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">all </span><a id="_idTextAnchor416"/><span class="koboSpan" id="kobo.353.1">years):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer150">
<span class="koboSpan" id="kobo.354.1"><img alt="Figure 6.8 – Taste of Chicago holiday effects" src="image/Fig_6.8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.355.1">Figure 6.8 – Taste of Chicago holiday effects</span></p>
<p><span class="koboSpan" id="kobo.356.1">The first day of th</span><a id="_idTextAnchor417"/><span class="koboSpan" id="kobo.357.1">e</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.358.1"> event shows reduced ridership, and the following four days show increased ridership. </span><span class="koboSpan" id="kobo.358.2">Now that we have learned the various ways you can add holidays to your forecasts, let’s look at one more tool for controlling holiday </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">effects: regular</span><a id="_idTextAnchor418"/><a id="_idTextAnchor419"/><span class="koboSpan" id="kobo.360.1">ization.</span></span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor420"/><span class="koboSpan" id="kobo.361.1">Regularizing holidays</span></h1>
<p><span class="koboSpan" id="kobo.362.1">The process of</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.363.1"> const</span><a id="_idTextAnchor421"/><span class="koboSpan" id="kobo.364.1">raining a model’s flexibility to help it generalize bett</span><a id="_idTextAnchor422"/><span class="koboSpan" id="kobo.365.1">er to new data is </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.366.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.367.1">regularization</span></strong><span class="koboSpan" id="kobo.368.1">. </span><a href="B19630_05.xhtml#_idTextAnchor254"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.369.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.370.1">, </span><em class="italic"><span class="koboSpan" id="kobo.371.1">Working with Seasonality,</span></em><span class="koboSpan" id="kobo.372.1"> featured a lengthy discussion about regularizing the effect of seasonality in Prophet. </span><span class="koboSpan" id="kobo.372.2">The mathematical procedure under Prophet’s hood is the same when regularizing both holiday and seasonality effects, so we can use the same concepts from the seasonality chapter and apply them </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">to holidays.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">In general, if you, as the analyst, find that your holidays have more control over your model than you expected, that is, if their absolute magnitudes are higher than you believe is accurate or necessary to model your problem, then you’ll want to consider regularization. </span><span class="koboSpan" id="kobo.374.2">Regularization will simply compress the magnitude of your holiday effects and forbid them from having as large an effect as they would otherwise. </span><span class="koboSpan" id="kobo.374.3">Prophet contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">holidays_prior_scale</span></strong><span class="koboSpan" id="kobo.376.1"> parameter to </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">control this.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">This is the same theory behind the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">seasonality_prior_scale</span></strong><span class="koboSpan" id="kobo.380.1"> parameter that we used in th</span><a id="_idTextAnchor423"/><span class="koboSpan" id="kobo.381.1">e previous chapter to regularize our seasonalities. </span><span class="koboSpan" id="kobo.381.2">Just as seasonalities can be regularized globally or locally, so can holidays. </span><span class="koboSpan" id="kobo.381.3">Let’s see how to d</span><a id="_idTextAnchor424"/><a id="_idTextAnchor425"/><span class="koboSpan" id="kobo.382.1">o </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">it next.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor426"/><span class="koboSpan" id="kobo.384.1">Global holiday regularization</span></h2>
<p><span class="koboSpan" id="kobo.385.1">Prophet essentially has a default prior </span><a id="_idIndexMarker253"/><a id="_idTextAnchor427"/><span class="koboSpan" id="kobo.386.1">probability distribution of guesses </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.387.1">for what effect a holiday may have and it uses this distribution to try</span><a id="_idTextAnchor428"/><span class="koboSpan" id="kobo.388.1"> to find the value that best fits the data. </span><span class="koboSpan" id="kobo.388.2">If that prior range of guesses is very far from reality, though, Prophet will struggle to find the best value. </span><span class="koboSpan" id="kobo.388.3">You can help it out a lot by giving it additional information about what values to expect so that it may update its prior distribution to better inform its guesses. </span><span class="koboSpan" id="kobo.388.4">Modifying the prior scale for holidays is how you provide this additional information </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">to Prophet.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">The values for </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">holidays_prior_scale</span></strong><span class="koboSpan" id="kobo.392.1"> unfortunately don’t make much intuitive sense. </span><span class="koboSpan" id="kobo.392.2">They are similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">regularization</span></strong><span class="koboSpan" id="kobo.394.1"> parameter in lasso regression in that they control the amount of shrinkage. </span><span class="koboSpan" id="kobo.394.2">However, you just need to remember that smaller values mean less flexibility—the holiday effect will be dampened through more regularization. </span><span class="koboSpan" id="kobo.394.3">By default, Prophet sets this value to 10. </span><span class="koboSpan" id="kobo.394.4">Reasonable values range from 10 down to 0.001 </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">or so.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">However, every dataset is different, so you’ll find that experimentation will help a lot, but just like the prior scales for seasonality, you’ll find that a holiday prior scale between 10 and 0.01 will work out well in most cases. </span><span class="koboSpan" id="kobo.396.2">To see the effect of this variable, let’s build one model using the default value of 10 and another model with a much smaller value </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">of 0.05.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">Let’s also </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.399.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">plot_forecast_component</span></strong><span class="koboSpan" id="kobo.401.1"> function we </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.402.1">learned about when plotting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">Taste of Chicago</span></strong><span class="koboSpan" id="kobo.404.1"> event, but this time, pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">'holidays'</span></strong><span class="koboSpan" id="kobo.406.1"> component to it, to plot all combined holiday effects together. </span><span class="koboSpan" id="kobo.406.2">First, we build the model with the default prior scale value (here, we explicitly set it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">10</span></strong><span class="koboSpan" id="kobo.408.1"> for clarity’s sake) and then plot only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">holidays</span></strong><span class="koboSpan" id="kobo.410.1"> component to see the </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">holiday effect:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.412.1">
model = Prophet(seasonality_mode='multiplicative',
                yearly_seasonality=4,
                holidays_prior_scale=10)
model.add_country_holidays(country_name='US')
model.fit(df)
future = model.make_future_dataframe(periods=365)
forecast = model.predict(future)
fig = plot_forecast_component(model, forecast, 'holidays')
</span><a id="_idTextAnchor429"/><span class="koboSpan" id="kobo.413.1">plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.414.1">The output of that code will be jus</span><a id="_idTextAnchor430"/><span class="koboSpan" id="kobo.415.1">t the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">holida</span><a id="_idTextAnchor431"/><span class="koboSpan" id="kobo.417.1">ys</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.418.1"> component:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer151">
<span class="koboSpan" id="kobo.419.1"><img alt="Figure 6.9 – The holidays component with no regularization" src="image/Fig_6.9.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.420.1">Figure 6.9 – The holidays component with no regularization</span></p>
<p><span class="koboSpan" id="kobo.421.1">With no </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.422.1">regularization, Thanksgiving (the longest bar in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.423.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.424.1">.9</span></em><span class="koboSpan" id="kobo.425.1">, which </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.426.1">we discovered earlier in this chapter to have the strongest effect of all holidays) reduces ridership by </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">about 65%.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">Now let’s build another model, the same in every way except with strong regularization, and plot the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">holidays</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.430.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.431.1">
model = Prophet(seasonality_mode='multiplicative',
                yearly_seasonality=4,
                holidays_prior_scale=0.05)
model.add_country_holidays(country_name='US')
model.fit(df)
future = model.make_future_dataframe(periods=365)
forecast = model.predict(future)
fig = plot_forecast_component(model, forecast, 'holidays')
plt.s</span><a id="_idTextAnchor432"/><span class="koboSpan" id="kobo.432.1">how()</span></pre>
<p><span class="koboSpan" id="kobo.433.1">Again, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">plot_forecast_component</span></strong><span class="koboSpan" id="kobo.435.1"> function to show on</span><a id="_idTextAnchor433"/><span class="koboSpan" id="kobo.436.1">ly the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">holid</span><a id="_idTextAnchor434"/><span class="koboSpan" id="kobo.438.1">ays</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.439.1"> component:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer152">
<span class="koboSpan" id="kobo.440.1"><img alt="Figure 6.10 – The holidays component with strong regularization" src="image/Fig_6.10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.441.1">Figure 6.10 – The holidays component with strong regularization</span></p>
<p><span class="koboSpan" id="kobo.442.1">When regularized, the plot appears similar to the plot of unregularized holidays, but with a few differences. </span><span class="koboSpan" id="kobo.442.2">First, we see the scale has changed a lot. </span><span class="koboSpan" id="kobo.442.3">The strongest holiday effect, when regularized, shows an 11.5% reduction in ridership, compared to the 65% reduction in the unregularized model. </span><span class="koboSpan" id="kobo.442.4">The second thing to notice is that the holidays haven’t been reduced by an equal proportion: now, Christmas has the strongest effect, not Thanksgiving. </span><span class="koboSpan" id="kobo.442.5">This is not an error, just an effect of how regularization works with this many variables interacting with </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">each other.</span></span></p>
<p><span class="koboSpan" id="kobo.444.1">Choosing a value for the prior scale can be more an art than a science. </span><span class="koboSpan" id="kobo.444.2">You may use your domain knowledge to adjust the value if the holidays’ effect seems stronger or weaker than your intuition suggests. </span><span class="koboSpan" id="kobo.444.3">If in doubt, experiment and see what works best. </span><span class="koboSpan" id="kobo.444.4">The most rigorous approach would be to use grid search with cross-validation, a topic that we will cover near the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">Using </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.447.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">holidays_prior_</span><a id="_idTextAnchor435"/><span class="koboSpan" id="kobo.449.1">scale</span></strong><span class="koboSpan" id="kobo.450.1"> parameter as we did</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.451.1"> previously adju</span><a id="_idTextAnchor436"/><span class="koboSpan" id="kobo.452.1">sts all holidays globally; each holiday across the board is regularized the same amount. </span><span class="koboSpan" id="kobo.452.2">For more control, Prophet provides functionality to adjust the prior scale for each individual holiday through the custom holiday interface. </span><span class="koboSpan" id="kobo.452.3">In the next example, we’ll see just</span><a id="_idTextAnchor437"/><a id="_idTextAnchor438"/><span class="koboSpan" id="kobo.453.1"> how to </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">do that.</span></span></p>
<h2 id="_idParaDest-79"><span class="koboSpan" id="kobo.455.1">Individual holiday reg</span><a id="_idTextAnchor439"/><span class="koboSpan" id="kobo.456.1">ularization</span></h2>
<p><span class="koboSpan" id="kobo.457.1">When adding a new </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.458.1">holiday, we created a DataFrame containing</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.459.1"> two required columns, </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">ds</span></strong><span class="koboSpan" id="kobo.461.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">holiday</span><a id="_idTextAnchor440"/></strong><span class="koboSpan" id="kobo.463.1">, and two optional columns, </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">lower_window</span></strong><span class="koboSpan" id="kobo.465.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">upper_window</span></strong><span class="koboSpan" id="kobo.467.1">. </span><span class="koboSpan" id="kobo.467.2">There is one final optional column we can include in this DataFrame, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">prior_scale</span></strong><span class="koboSpan" id="kobo.469.1">. </span><span class="koboSpan" id="kobo.469.2">If any holidays have no value in this column (or if the column doesn’t even exist in the DataFrame), then the holidays will revert to the global </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">holidays_prior_scale</span></strong><span class="koboSpan" id="kobo.471.1"> value that we saw in the previous example. </span><span class="koboSpan" id="kobo.471.2">In the following example, though, we will add this column and modify some holidays’ prior </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">scales individually.</span></span></p>
<p><span class="koboSpan" id="kobo.473.1">As we have</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.474.1"> done earlier, we will build the default holiday </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.475.1">list and add some additional holidays. </span><span class="koboSpan" id="kobo.475.2">This time around, we will add </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">Black Friday</span></strong><span class="koboSpan" id="kobo.477.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">Christmas Eve</span></strong><span class="koboSpan" id="kobo.479.1"> with a prior scale of </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">1</span></strong><span class="koboSpan" id="kobo.481.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">Taste of Chicago</span></strong><span class="koboSpan" id="kobo.483.1"> 5-day event with a prior scale of </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">0.1</span></strong><span class="koboSpan" id="kobo.485.1">. </span><span class="koboSpan" id="kobo.485.2">All other holidays will keep the default prior scale of </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">10</span></strong><span class="koboSpan" id="kobo.487.1">. </span><span class="koboSpan" id="kobo.487.2">First, we will use the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">year_list</span></strong><span class="koboSpan" id="kobo.489.1"> created previously to create our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">holidays</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.491.1"> DataFrame:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.492.1">
holidays = make_holidays_df(year_list=year_list,
                            country='US')</span></pre>
<p><span class="koboSpan" id="kobo.493.1">This is Prophet’s default list of holidays for the US; we want to enrich the list with our three additional holidays, so now we’ll create a DataFrame for each o</span><a id="_idTextAnchor441"/><span class="koboSpan" id="kobo.494.1">f them. </span><span class="koboSpan" id="kobo.494.2">Note that we specify </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">'p</span><a id="_idTextAnchor442"/><span class="koboSpan" id="kobo.496.1">rior_scale'</span></strong><span class="koboSpan" id="kobo.497.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">each holiday:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.499.1">
black_friday = pd.DataFrame({'holiday': 'Black Friday',
                             'ds': pd.to_datetime(
                                 ['2014-11-28',
                                  '2015-11-27',
                                  '2016-11-25',
                                  '2017-11-24',
                                  '2018-11-23']),
                             'prior_scale': 1})
christmas_eve = pd.DataFrame({'holiday': 'Christmas Eve',
                              'ds': pd.to_datetime(
                                  ['2014-12-24',
                                   '2015-12-24',
                                   '2016-12-24',
                                   '2017-12-24',
                                   '2018-12-24']),
                              'prior_scale': 1})
taste_of_chicago = \
pd.DataFrame({'holiday': 'Taste of Chicago',
              'ds': pd.to_datetime(['2014-07-09',
                                    '2015-07-08',
                                    '2016-07-06',
                                    '2017-07-05',
                                    '2018-07-11']),
              'lower_window': 0,
              'upper_window': 4,
              'prior_scale': 0.1})</span></pre>
<p><span class="koboSpan" id="kobo.500.1">The last step is to combine these </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">four DataFrames:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.502.1">
holidays = pd.concat([holidays,
                      black_friday,
                      christmas_eve,
                      taste_of_chicago]
                    ).sort_values('ds')\
                     .reset_index(drop=True)</span></pre>
<p><span class="koboSpan" id="kobo.503.1">In the </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.504.1">DataFrames for </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">Black Friday</span></strong><span class="koboSpan" id="kobo.506.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">Christmas Eve</span></strong><span class="koboSpan" id="kobo.508.1">, and</span><a id="_idTextAnchor443"/> <strong class="source-inline"><span class="koboSpan" id="kobo.509.1">Taste of Chicago</span></strong><span class="koboSpan" id="kobo.510.1">, we added that additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">prior_scale</span></strong><span class="koboSpan" id="kobo.512.1"> column. </span><span class="koboSpan" id="kobo.512.2">Let’s </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.513.1">print the first 16 rows of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">holidays</span></strong><span class="koboSpan" id="kobo.515.1"> DataFrame to </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">confirm this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.517.1">
holidays.head(16)</span></pre>
<p><span class="koboSpan" id="kobo.518.1">As you can see in the following table, we have our 10 default holidays, with no prior scale or windows added. </span><span class="koboSpan" id="kobo.518.2">We have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">Taste of Chicago</span></strong><span class="koboSpan" id="kobo.520.1"> event with the upper window for 4 additional days and a prior scale of </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">0.1</span></strong><span class="koboSpan" id="kobo.522.1">. </span><span class="koboSpan" id="kobo.522.2">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">Black Friday</span></strong><span class="koboSpan" id="kobo.524.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">Christmas Eve</span></strong><span class="koboSpan" id="kobo.526.1"> have prior scales of </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">1</span></strong><span class="koboSpan" id="kobo.528.1">. </span><span class="koboSpan" id="kobo.528.2">Prophet will apply the default prior scale where it’s </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.529.1">missing when it builds the model. </span><span class="koboSpan" id="kobo.529.2">Remember, </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">NaN</span></strong><span class="koboSpan" id="kobo.531.1">, for </span><em class="italic"><span class="koboSpan" id="kobo.532.1">Not a Number</span></em><span class="koboSpan" id="kobo.533.1">, means</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.534.1"> an e</span><a id="_idTextAnchor444"/><span class="koboSpan" id="kobo.535.1">mpty cell in </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">this case:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer153">
<span class="koboSpan" id="kobo.537.1"><img alt="Figure 6.11 – Holidays﻿ with prior scales" src="image/Fig_6.11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.538.1">Figure 6.11 – Holidays</span><a id="_idTextAnchor445"/><span class="koboSpan" id="kobo.539.1"> with prior scales</span></p>
<p><span class="koboSpan" id="kobo.540.1">With our </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">holidays</span></strong><span class="koboSpan" id="kobo.542.1"> Dat</span><a id="_idTextAnchor446"/><span class="koboSpan" id="kobo.543.1">aFrame built, we simply continue to instantiate our model, fit it, and predict in order to build </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">the forecast:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.545.1">
model = Prophet(seasonality_mode='multiplicative',
                yearly_seasonality=4,
                holidays=holidays,
                holidays_prior_scale=10)
model.fit(df)
future = model.make_future_dataframe(periods=365)
forecast = model.predict(future)</span></pre>
<p><span class="koboSpan" id="kobo.546.1">Now with </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.547.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">forecast</span></strong><span class="koboSpan" id="kobo.549.1"> DataFrame created, you can experiment on your own</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.550.1"> using the plotting tools you’ve learned about so far to explore </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">the results.</span></span></p>
<p><span class="koboSpan" id="kobo.552.1">Choosing an appr</span><a id="_idTextAnchor447"/><span class="koboSpan" id="kobo.553.1">opriate prior scale, both for holidays and for sea</span><a id="_idTextAnchor448"/><span class="koboSpan" id="kobo.554.1">sonalities, may sometimes be difficult. </span><span class="koboSpan" id="kobo.554.2">Prophet’s default values tend to work very well in most cases, but there may be times when you need to change them and struggle to find the best value. </span><span class="koboSpan" id="kobo.554.3">In these cases, cross-validation is your best approach. </span><span class="koboSpan" id="kobo.554.4">You will learn how to use cross-validation with an appropriate performance metric to optimize your Prophet models in </span><a href="B19630_13.xhtml#_idTextAnchor839"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.555.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.556.1">, </span><em class="italic"><span class="koboSpan" id="kobo.557.1">Evalua</span><a id="_idTextAnchor449"/><a id="_idTextAnchor450"/><span class="koboSpan" id="kobo.558.1">ting </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.559.1">Performance Metrics</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">.</span></span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor451"/><span class="koboSpan" id="kobo.561.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.562.1">In this chapter, you first learned how to add the default holidays for a country and then went a bit deeper by adding any state or province holidays. </span><span class="koboSpan" id="kobo.562.2">After that, you learned how to add custom holidays and expanded this technique to adjus</span><a id="_idTextAnchor452"/><span class="koboSpan" id="kobo.563.1">t for holidays that span multiple days. </span><span class="koboSpan" id="kobo.563.2">Finally, you learned what regularization is and how it is used to control overfitting, and how to apply it globally to all holidays in your model or more granularly by specifying different regularizations for each </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">individual holiday.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">Holidays often cause massive spikes in time series and ignoring their effects will cause Prophet to perform very poorly in its forecast results. </span><span class="koboSpan" id="kobo.565.2">The tools in this chapter will allow your models to accommodate these external events and provide a way to predict the effects running into </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.567.1">In the next chapter, we’ll look at the different growth modes available in Prophet. </span><span class="koboSpan" id="kobo.567.2">So far, all our models have had linear growth, but that may not be the only mode you will encounter in your </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">forecasting work!</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer155">
</div>
</div>
</body></html>