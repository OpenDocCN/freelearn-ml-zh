["```py\ntypedef Eigen::Matrix<float, 3, 3> MyMatrix33f;\n```", "```py\ntypedef Eigen::Matrix<float, 3, 1> MyVector3f;\n```", "```py\ntypedef Eigen::\n    Matrix<double, Eigen::Dynamic, Eigen::Dynamic>\n        MyMatrix;\n```", "```py\nMyMatrix33f a;\nMyVector3f v;\nMyMatrix m(10,15);\n```", "```py\na = MyMatrix33f::Zero(); // fill matrix elements with zeros\na = MyMatrix33f::Identity(); // fill matrix as Identity matrix\nv = MyVector3f::Random(); // fill matrix elements with random values\n```", "```py\na << 1,2,3,\n      4,5,6,\n      7,8,9;\n```", "```py\na(0,0) = 3;\n```", "```py\nint data[] = {1,2,3,4};\nEigen::Map<Eigen::RowVectorxi> v(data,4);\nstd::vector<float> data = {1,2,3,4,5,6,7,8,9};\nEigen::Map<MyMatrix33f> a(data.data());\n```", "```py\nusing namespace Eigen;\nauto a = Matrix2d::Random();\nauto b = Matrix2d::Random();\nauto result = a + b;\nresult = a.array() * b.array(); // element wise multiplication\nresult = a.array() / b.array();\na += b;\nresult = a * b; // matrix multiplication\n//Also it's possible to use scalars:\na = b.array() * 4;\n```", "```py\nEigen::Matrixxf m(4,4);\nEigen::Matrix2f b = m.block(1,1,2,2); // copying the middle\n                                     //part of matrix\nm.block(1,1,2,2) *= 4; // change values in original matrix\n```", "```py\nm.row(1).array() += 3;\nm.col(2).array() /= 4;\n```", "```py\nEigen::Matrixxf mat(2,4);\nEigen::Vectorxf v(2); // column vector\nmat.colwise() += v;\n```", "```py\nstd::vector<size_t> shape = { 3, 2, 4 };\nxt::xarray<double, xt::layout_type::row_major> a(shape);\n```", "```py\nstd::array<size_t, 3> shape = { 3, 2, 4 };\nxt::xtensor<double, 3> a(shape);\n```", "```py\nxt::xtensor_fixed<double, xt::xshape<3, 2, 4>> a;\n```", "```py\nxt::xarray<double> arr1{{1.0, 2.0, 3.0},\n{2.0, 5.0, 7.0},\n{2.0, 5.0, 7.0}}; // initialize a 3x3 array\n```", "```py\nstd::vector<uint64_t> shape = {2, 2};\nauto x = xt::ones(shape); // creates 2x2 matrix of 1s\nauto y = xt::zero(shape); // creates zero 2x2 matrix\nauto z = xt::eye(shape);  // creates 2x2 matrix with ones\n                          //on the diagonal\n```", "```py\nstd::vector<float> data{1,2,3,4};\nstd::vector<size_t> shape{2,2};\nauto data_x = xt::adapt(data, shape);\n```", "```py\nstd::vector<size_t> shape = {3, 2, 4};\nxt::xarray<float> a = xt::ones<float>(shape);\na(2,1,3) = 3.14f;\n```", "```py\nauto a = xt::random::rand<double>({2,2});\nauto b = xt::random::rand<double>({2,2});\nauto c = a + b;\na -= b;\nc = xt::linalg::dot(a,b);\nc = a + 5;\n```", "```py\nxt::xarray<int> a{\n  {1, 2, 3, 4}, \n  {5, 6, 7, 8}, \n  {9, 10, 11, 12}, \n  {13, 14, 15, 16}\n};\nauto b = xt::view(a, xt::range(1, 3), xt::range(1, 3));\n```", "```py\nauto m = xt::random::rand<double>({2,2});\nauto v = xt::random::rand<double>({2,1});\nauto c = m + v;\n```", "```py\ntypedef blaze::\n    StaticMatrix<float, 3UL, 3UL, blaze::columnMajor>\n        MyMatrix33f;\n```", "```py\ntypedef blaze::StaticVector<float, 3UL> MyVector3f;\n```", "```py\ntypedef blaze::DynamicMatrix<double> MyMatrix;\n```", "```py\nMyMatrix33f a;\nMyVector3f v;\nMyMatrix m(10, 15);\n```", "```py\na = blaze::zero<float>(3UL, 3UL); //  Zero matrix\na = blaze::IdentityMatrix<float>(3UL); //  Identity matrix\nblaze::Rand<float> rnd;\nv = blaze::generate(3UL, [&](size_t) { return rnd.generate(); }); \n// Random generated vector\n// Matrix filled from the initializer list\na = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n// Matrix filled with a single value\na = blaze::uniform(3UL, 3UL, 3.f);\n```", "```py\na(0,0) = 3;\n```", "```py\nstd::array<int, 4> data = {1, 2, 3, 4};\nblaze::CustomVector<int,\n                    blaze::unaligned,\n                    blaze::unpadded,\n                    blaze::rowMajor>\n    v2(data.data(), data.size());\nstd::vector<float> mdata = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nblaze::CustomMatrix<float,\n                    blaze::unaligned,\n                    blaze::unpadded,\n                    blaze::rowMajor>\n    a2(mdata.data(), 3UL, 3UL);\n```", "```py\nblaze::StaticMatrix<float, 2UL, 2UL> a = {{1, 2}, {3, 4}};\nauto b = a;\n// element wise operations\nblaze::StaticMatrix<float, 2UL, 2UL> result = a % b;\na = b * 4;\n// matrix operations\nresult = a + b;\na += b;\nresult = a * b;\n```", "```py\nblaze::StaticMatrix<float, 4UL, 4UL> m = {{1, 2, 3, 4},\n                                          {5, 6, 7, 8},\n                                          {9, 10, 11, 12},\n                                          {13, 14, 15, 16}}\n// make a view of the middle part of matrix\nauto b = blaze::submatrix<1UL, 1UL, 2UL, 2UL>(m);\n// change values in original matrix\nblaze::submatrix<1UL, 1UL, 2UL, 2UL>(m) *= 0;\n```", "```py\nblaze::row<1UL>(m) += 3;\nblaze::column<2UL>(m) /= 4;\n```", "```py\nblaze::DynamicMatrix<float, blaze::rowVector> mat = \n  blaze::uniform(4UL, 4UL, 2);\nblaze::DynamicVector<float, blaze::rowVector> vec = {1, 2, 3, 4};\nauto ex_vec = blaze::expand(vec, 4UL);\nmat += ex_vec;\n```", "```py\n( 3 4 5 6 )\n( 3 4 5 6 )\n( 3 4 5 6 )\n( 3 4 5 6 )\n```", "```py\naf::array a(3, 3, af::dtype::f32);\n```", "```py\naf::array v(3, af::dtype::f64);\n```", "```py\na = af::constant(0, 3, 3);  //  Zero matrix\na = af::identity(3, 3);    //  Identity matrix\nv = af::randu(3);         // Random generated vector\n// Matrix filled with a single value\na = af::constant(3, 3, 3);\n// Matrix filled from the initializer list\na = af::array(\n    af::dim4(3, 3),\n    {1.f, 2.f, 3.f, 4.f, 5.f, 6.f, 7.f, 8.f, 9.f});\n```", "```py\n1.0 4.0 7.0\n2.0 5.0 8.0\n3.0 6.0 9.0\n```", "```py\na(0,0) = 3;\n```", "```py\nstd::vector<float> mdata = {1, 2, 3, 4, 5, 6, 7, 8, 9};\na = af::array(3, 3, mdata.data());\n```", "```py\nauto a = af::array(af::dim4(2, 2), {1, 2, 3, 4});\na = a.as(af::dtype::f32);\nauto b = a.copy();\n// element wise operations\nauto result = a * b;\na = b * 4;\n// matrix operations\nresult = a + b;\na += b;\nresult = af::matmul(a, b);\n```", "```py\nseq - representing a linear sequence\nend - representing the last element of a dimension\nspan - representing the entire dimension\n```", "```py\nauto m = af::iota(af::dim4(4, 4));\nauto center = m(af::seq(1, 2), af::seq(1, 2));\n// modify a part of the matrix\ncenter *= 2;\n```", "```py\nm.row(1) += 3;\nm.col(2) /= 4;\n```", "```py\nauto mat = af::constant(2, 4, 4);\nauto vec = af::array(4, {1, 2, 3, 4});\nmat = af::batchFunc(\n    vec,\n    mat,\n    [](const auto& a, const auto& b) { return a + b; });\n```", "```py\n3.0  3.0  3.0  3.0\n4.0  4.0  4.0  4.0\n5.0  5.0  5.0  5.0\n6.0  6.0  6.0  6.0\n```", "```py\nDlib::matrix<double,3,1> y;\n```", "```py\nDlib::matrix<double> m(3,3);\n```", "```py\nm.set_size(6,6);\n```", "```py\nm = 54.2, 7.4, 12.1,\n  1, 2, 3,\n  5.9, 0.05, 1;\n```", "```py\ndouble data[] = {1,2,3,4,5,6};\nauto a = Dlib::mat(data, 2,3); // create matrix with size 2x3\n```", "```py\nm(1,2) = 3;\n```", "```py\nauto a = Dlib::identity_matrix<double>(3);\nauto b = Dlib::ones_matrix<double>(3,4);\nauto c = Dlib::randm(3,4); // matrix with random values\n                          //with size 3x3\n```", "```py\nauto c = a + b;\nauto e = a * b; // real matrix multiplication\nauto d  = Dlib::pointwise_multiply(a, b); // element wise\n                                          //multiplication\na += 5;\nauto t = Dlib::trans(a); // transpose matrix\n```", "```py\na = Dlib::rowm(b,0); // takes first row of matrix\na = Dlib::rowm(b,Dlib::range(0,1));//takes first two rows\na = Dlib::colm(b,0); // takes first column\n// takes a rectangular part from center: \na = Dlib::subm(b, range(1,2), range(1,2)); \n// initialize part of the matrix: \nDlib::set_subm(b,range(0,1), range(0,1)) = 7; \n// add a value to the part of the matrix:\nDlib::set_subm(b,range(0,1), range(0,1)) += 7;\n```", "```py\nDlib::matrix<float, 2,1> x;\nDlib::matrix<float, 2,3> m;\nDlib::set_colm(b,Dlib::range(0,1)) += x;\n```", "```py\ntypedef float DType;\nusing Matrix = Eigen::Matrix<DType, Eigen::Dynamic, Eigen::Dynamic>;\nint n = 10000;\nMatrix x(n,1);\nMatrix y(n,1);\nEigen::LeastSquaresConjugateGradient<Matrix> gd;\ngd.setMaxIterations(1000);\ngd.setTolerance(0.001) ;\ngd.compute(x);\nauto b = gddg.solve(y);\n```", "```py\nEigen::Matrixxf new_x(5, 2);\nnew_x << 1, 1, 1, 2, 1, 3, 1, 4, 1, 5;\nauto new_y = new_x.array().rowwise() * b.transpose().array();\n```", "```py\nauto b = (x.transpose() * x).ldlt().solve(x.transpose() * y);\n```", "```py\ntypedef blaze::DynamicMatrix<float,blaze::columnMajor> Matrix;\ntypedef blaze::DynamicVector<float,blaze::columnVector> Vector;\n// the first column of X is just 1 for the bias term\nMatrix x(n, 2UL);\nMatrix y(n, 1UL);\n```", "```py\n// calculate X^T*X\nauto xtx = blaze::trans(x) * x;\n// calculate the inverse of X^T*X\nauto inv_xtx = blaze::inv(xtx);\n// calculate X^T*y\nauto xty = blaze::trans(x) * y;\n// calculate the coefficients of the linear regression\nMatrix beta = inv_xtx * xty;\n```", "```py\nauto line_coeffs = blaze::expand(\n  blaze::row<0UL>(blaze::trans(beta)), new_x.rows());\nauto new_y = new_x % line_coeffs;\n```", "```py\nauto predict = [](auto& v, auto& w) {\n  return af::batchFunc(v, w, [](const auto& a, const auto& b) {\n    return af::sum(a * b, /*dim*/ 1);\n  });\n};\n```", "```py\n// the first column is for the bias term\naf::dim4 weights_dim(1, 2);\nauto train_weights = af::constant(0.f, weights_dim, af::dtype::f32);\n```", "```py\naf::array j, dj;  // cost value and its gradient\nfloat lr = 0.1f;  // learning rate\nint n_iter = 300;\nfor (int i = 0; i < n_iter; ++i) {\n  std::cout << \"Iteration \" << i << \":\\n\";\n  // get the cost\n  auto h = predict(x, train_weights);\n  auto diff = (y - h);\n  auto j = af::sum(diff * diff) / n;\n  af_print(j);\n  // find the gradient of cost\n  auto dm = (-2.f / n) * af::sum(x.col(1) * diff);\n  auto dc = (-2.f / n) * af::sum(diff);\n  auto dj = af::join(1, dc, dm);\n  // update the parameters via gradient descent\n  train_weights = train_weights - lr * dj;\n}\n```", "```py\n  auto h = predict(x, train_weights);\n  auto diff = (y – h);\n```", "```py\n  auto dm = (-2.f / n) * af::sum(x.col(1) * diff);\n  auto dc = (-2.f / n) * af::sum(diff);\n```", "```py\n  auto dj = af::join(1, dc, dm);\n  train_weights = train_weights - lr * dj;\n```", "```py\nauto j = af::sum(diff * diff) / n;\n```", "```py\nstd::vector<matrix<double>> x;\nstd::vector<float> y;\nkrr_trainer<KernelType> trainer;\ntrainer.set_kernel(KernelType());\ndecision_function<KernelType> df = trainer.train(x, y);\n```", "```py\nstd::vector<matrix<double>> new_x;\nfor (auto& v : x) {\n    auto prediction = df(v);\n    std::cout << prediction << std::endl;\n}\n```"]