["```py\nBenchmarkTools@v0.4.1\nDocStringExtensions@v0.6.0\nDocumenter@v0.21.0\nGitHub@v5.0.2\nIJulia@v1.14.1\nTraceur@v0.2.0\nURIParser@v0.4.0\n```", "```py\npkg> add PackageName@vX.Y.Z \n```", "```py\npkg> add IJulia@v1.14.1\n```", "```py\njulia> download(\"https://raw.githubusercontent.com/PacktPublishing/Julia-Programming-Projects/master/Chapter11/Project.toml\", \"Project.toml\")\npkg> activate . \npkg> instantiate\n```", "```py\n$ git config --global user.name \"<FULL_NAME>\" \n$ git config --global user.email \"<EMAIL>\" \n$ git config --global github.user \"<GITHUB_USERNAME>\" \n```", "```py\n$ git config --global user.name \"Adrian Salceanu\" \n```", "```py\n$ git config -l \nuser.name=Adrian Salceanu \nuser.email=**@**  \ngithub.user=essenciary \n```", "```py\njulia> ] # enter Pkg mode pkg> generate IssueReporter Generating project IssueReporter: IssueReporter/Project.toml IssueReporter/src/IssueReporter.jl \n```", "```py\nauthors = [\"Adrian Salceanu <*@*.com>\"] # actual email truncated \nname = \"IssueReporter\" \nuuid = \"7b29c13e-f3eb-11e8-2be5-fb20b77ad364\" \nversion = \"0.1.0\" \n\n[deps] \n```", "```py\nmodule IssueReporter \n\ngreet() = print(\"Hello World!\") \n\nend # module \n```", "```py\njulia> ; # enter shell mode \nshell> cd IssueReporter \njulia> ] # enter pkg mode \npkg> activate . \n(IssueReporter) pkg>  \n```", "```py\njulia> using IssueReporter \n[ Info: Precompiling IssueReporter [7b29c13e-f3eb-11e8-2be5-fb20b77ad364] \n\njulia> IssueReporter.greet() \nHello World! \n```", "```py\n(IssueReporter) pkg> add GitHub  \n```", "```py\n (IssueReporter) pkg> add URIParser \n```", "```py\n (IssueReporter) pkg> add Test\n```", "```py\n[deps] \nGitHub = \"bc5e4493-9b4d-5f90-b8aa-2b2bcaad7a26\" \nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\" \nURIParser = \"30578b45-9adc-5946-b283-645ec420af67\" \n```", "```py\njulia> using Test \n\njulia> @test 1 == 1 \nTest Passed \n\njulia> @test 'A' == 'a' \nTest Failed \n  Expression: 'A' == 'a' \n   Evaluated: 'A' == 'a' \nERROR: There was an error during testing \n# output omitted # \n```", "```py\njulia> @testset \"Example\" begin \n           @test :a == :a \n           @test 'x' == 'y' \n       end \nExample: Test Failed \n  Expression: 'x' == 'y' \n   Evaluated: 'x' == 'y' \n\nTest Summary: | Pass  Fail  Total \nExample       |    1     1      2 \nERROR: Some tests did not pass: 1 passed, 1 failed, 0 errored, 0 broken. \n# output omitted # \n```", "```py\njulia> @testset \"Example\" begin \n           error(\"Oh no!\") \n       end \nExample: Error During Test \n  Got an exception of type ErrorException outside of a @test \n  Oh no! \n\nTest Summary: | Error  Total \nExample       |     1      1 \nERROR: Some tests did not pass: 0 passed, 0 failed, 1 errored, 0 broken. \n# output omitted # \n```", "```py\njulia> mkdir(\"test\") \n\"test\" \n\njulia> touch(\"test/runtests.jl\") \n\"test/runtests.jl\" \n```", "```py\njulia> edit(\"test/runtests.jl\") \n```", "```py\nusing IssueReporter \nusing Test, URIParser, GitHub \n\n@testset \"Basic features\" begin \n  @testset \"Looking up an existing package returns a proper repo URI\" begin \n    @test IssueReporter.packageuri(\"DataFrames\") |> URIParser.isvalid \n  end \nend \n\"Basic features\". Within it, we have yet another test set, which contains the actual test. Finally, the test invokes a function called packageuri from the IssueReporter module, passing it the  DataFrames string as its argument. What we're trying to do here is get the GitHub URI for a package that we know exists and is registered, namely DataFrames. Then, we make sure that the URI is valid by passing it into the URIParser.isvalid method.\n```", "```py\n (IssueReporter) pkg> test\n```", "```py\n(IssueReporter) pkg> test \n   Testing IssueReporter \n Resolving package versions... \nLooking up an existing package returns a proper repo URI: Error During Test at IssueReporter/test/runtests.jl:7 \n  Test threw exception \n  Expression: IssueReporter.packageuri(\"DataFrames\") |> URIParser.isvalid \n  UndefVarError: packageuri not defined \nTest Summary:                                              | Error  Total \nBasic features                                             |     1      1 \n  Looking up an existing package returns a proper repo URI |     1      1 \nERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 1 errored, 0 broken. \nERROR: Package IssueReporter errored during testing \n# output omitted # \n```", "```py\ne3df1716-f71e-5df9-9e2d-98e193103c45 = { name = \"D3Trees\", path = \"D/D3Trees\" } \n```", "```py\n(IssueReporter) pkg> add Pkg \n```", "```py\njulia> DEPOT_PATH 3-element Array{String,1}: \"/Users/adrian/.julia\" \"/Applications/Julia-1.0.app/Contents/Resources/julia/local/share/julia\" \"/Applications/Julia-1.0.app/Contents/Resources/julia/share/julia\" \n```", "```py\n@testset \"Interacting with the registry\" begin \n  @testset \"The General registry is accessible\" begin \n    IssueReporter.generalregistrypath() |> Base.Filesystem.isdir \n  end \nend \n```", "```py\nfunction generalregistrypath() \n  for i in DEPOT_PATH \n    if isdir(joinpath(i, \"registries\", \"General\")) \n      return joinpath(i, \"registries\", \"General\") \n    end \n  end \nend \n```", "```py\nDict{String,Any} with 5 entries: \n  \"name\"        => \"General\" \n  \"repo\"        => \"https://github.com/JuliaRegistries/General.git\" \n  \"packages\"    => Dict{String,Any}(\"c786d6c3-4fbc-59fc-968c-e848efb65d2d\"=>Dict{String,Any}(\"name\"=>\"ScHoLP\",\"path\"=>\"S/ScHoLP\"),\"88634af6-177f-5301-88b8-7819386cfa38\"=>Dict{String,Any}(\"name\"=>\"SaferIntegers\",\"path\"=>\"S/SaferIntegers\")... \n  \"uuid\"        => \"23338594-aafe-5451-b93e-139f81909106\" \n  \"description\" => \"Official general Julia package registry where people  \n# output omitted #  \n```", "```py\nDict{String,Any} with 2358 entries: \n  \"c786d6c3-4fbc-59fc-968c-e848efb65d2d\" => Dict{String,Any}(\"name\"=>\"ScHoLP\",\"path\"=>\"S/ScHoLP\") \n  \"88634af6-177f-5301-88b8-7819386cfa38\" => Dict{String,Any}(\"name\"=>\"SaferIntegers\",\"path\"=>\"S/SaferIntegers\") \n  \"aa65fe97-06da-5843-b5b1-d5d13cad87d2\" => Dict{String,Any}(\"name\"=>\"SnoopCompile\",\"path\"=>\"S/SnoopCompile\") \n# output truncated # \n```", "```py\nfunction generalregistry() \n    TOML.parsefile(joinpath(generalregistrypath(), \"Registry.toml\"))[\"packages\"] |> values |> collect \nend \n```", "```py\n2358-element Array{Any,1}: \n Dict{String,Any}(\"name\"=>\"ScHoLP\",\"path\"=>\"S/ScHoLP\") \n Dict{String,Any}(\"name\"=>\"SaferIntegers\",\"path\"=>\"S/SaferIntegers\") \n Dict{String,Any}(\"name\"=>\"SnoopCompile\",\"path\"=>\"S/SnoopCompile\") \n# output truncated # \n```", "```py\nfunction searchregistry(pkgname::String) \n  for item in generalregistry() \n    item[\"name\"] == pkgname && return item \n  end \nend \n```", "```py\nfunction packageuri(pkgname::String) \n  TOML.parsefile(joinpath(generalregistrypath(), searchregistry(pkgname)[\"path\"], \"Package.toml\"))[\"repo\"] \nend \n```", "```py\nmodule IssueReporter \n\nusing Pkg, Pkg.TOML \n\nfunction generalregistrypath() \n  for i in DEPOT_PATH \n    if isdir(joinpath(i, \"registries\", \"General\")) \n      return joinpath(i, \"registries\", \"General\") \n    end \n  end \nend \n\nfunction generalregistry() \n    TOML.parsefile(joinpath(generalregistrypath(), \"Registry.toml\"))[\"packages\"] |> values |> collect \nend \n\nfunction searchregistry(pkgname::String) \n  for item in generalregistry() \n    item[\"name\"] == pkgname && return item \n  end \nend \n\nfunction packageuri(pkgname::String) \n  TOML.parsefile(joinpath(generalregistrypath(), searchregistry(pkgname)[\"path\"], \"Package.toml\"))[\"repo\"] \nend \n\nend # module \n```", "```py\n(IssueReporter) pkg> test \n```", "```py\njulia> IssueReporter.packageuri(\"DataFrames\") \nhttps://github.com/JuliaData/DataFrames.jl.git\n```", "```py\njulia> @time [x for x in 1:1_000_000]; \n  0.031727 seconds (55.85 k allocations: 10.387 MiB) \n```", "```py\njulia> function onetomil() \n [x for x in 1:1_000_000]\n end \nonetomil (generic function with 1 method) \n```", "```py\njulia> @time onetomil();\n  0.027002 seconds (65.04 k allocations: 10.914 MiB) \n```", "```py\njulia> @time onetomil();\n  0.002413 seconds (6 allocations: 7.630 MiB) \n```", "```py\n(IssueReporter) pkg> add BenchmarkTools \njulia> using BenchmarkTools \njulia> @benchmark onetomil() \nBenchmarkTools.Trial: \n  memory estimate:  7.63 MiB \n  allocs estimate:  2 \n  -------------- \n  minimum time:     1.373 ms (0.00% GC) \n  median time:      1.972 ms (0.00% GC) \n  mean time:        2.788 ms (34.06% GC) \n  maximum time:     55.129 ms (96.23% GC) \n  -------------- \n  samples:          1788 \n  evals/sample:     1 \n```", "```py\njulia> @btime onetomil(); \n  1.363 ms (2 allocations: 7.63 MiB) \n```", "```py\njulia> function f1() \n           x = 0 \n\n           for i in 1:10 \n               x += sin(i) \n           end \n\n           x \n       end \nf1 (generic function with 1 method) \n```", "```py\njulia> @code_warntype f1() \n```", "```py\n(IssueReporter) pkg> add Traceur \njulia> using Traceur \njulia> @trace f1() \n┌ Warning: x is assigned as Int64 \n└ @ REPL[94]:2 \n┌ Warning: x is assigned as Float64 \n└ @ REPL[94]:4 \n┌ Warning: f1 returns Union{Float64, Int64} \n└ @ REPL[94]:2 \n1.4111883712180104 \n```", "```py\njulia> function f2() \n           x = 0.0 \n\n           for i in 1:10 \n                  x += sin(i) \n           end \n\n           x \n       end \nf2 (generic function with 1 method) \n\njulia> @trace f2() \n1.4111883712180104\n```", "```py\njulia> @btime f1() \n  129.413 ns (0 allocations: 0 bytes) \n1.4111883712180104 \n\njulia> @btime f2() \n  79.241 ns (0 allocations: 0 bytes) \n1.4111883712180104 \n```", "```py\njulia> @code_warntype IssueReporter.packageuri(\"DataFrames\") \n```", "```py\nfunction generalregistrypath() :: String \n  for i in DEPOT_PATH \n    if isdir(joinpath(i, \"registries\", \"General\")) \n      return joinpath(i, \"registries\", \"General\") \n    end \n  end \n\n  \"\" \nend \n```", "```py\nfunction generalregistry() :: Vector{Dict{String,Any}} \n  if ! isempty(generalregistrypath()) \n    TOML.parsefile(joinpath(generalregistrypath(), \"Registry.toml\"))[\"packages\"] |> values |> collect \n  else \n     Dict{String,Any}[] \n   end \nend \n\nfunction searchregistry(pkgname::String) :: Dict{String,Any} \n  for item in generalregistry() \n    item[\"name\"] == pkgname && return item \n  end \n\n  Dict{String,Any}() \nend \n\nfunction packageuri(pkgname::String) :: String \n  pkg = searchregistry(pkgname) \n  isempty(pkg) && return \"\" \n  get!(TOML.parsefile(joinpath(generalregistrypath(), pkg[\"path\"], \"Package.toml\")), \"repo\", \"\") \nend \n```", "```py\njulia> @code_warntype IssueReporter.packageuri(\"DataFrames\") \n```", "```py\n@testset \"GitHub integration\" begin \n  delete!(ENV, \"GITHUB_ACCESS_TOKEN\") \n\n  @testset \"An undefined token should return false\" begin \n    @test ! IssueReporter.tokenisdefined() \n  end \n  @testset \"Attempting to access a token that is not set will error\" begin \n    @test_throws ErrorException IssueReporter.token() \n  end \n  # setup a mock token \n  ENV[\"GITHUB_ACCESS_TOKEN\"] = \"1234\" \n  @testset \"Token is defined\" begin \n    @test IssueReporter.tokenisdefined() \n  end \n @testset \"A valid token is a non empty string and has the set value\" begin \n    token = IssueReporter.token() \n    @test isa(token, String) && ! isempty(token) \n    @test token == \"1234\" \n  end \nend \n\n```", "```py\nfunction tokenisdefined() :: Bool \n    if ! haskey(ENV, \"GITHUB_ACCESS_TOKEN\") \n        secrets_path = joinpath(@__DIR__, \"secrets.jl\") \n        isfile(secrets_path) && include(secrets_path) \n        haskey(ENV, \"GITHUB_ACCESS_TOKEN\") || return false \n    end \n\n    true \nend \n\nfunction token() :: String \n    tokenisdefined() && return ENV[\"GITHUB_ACCESS_TOKEN\"] \n    error(\"\"\"ENV[\"GITHUB_ACCESS_TOKEN\"] is not set -- please make sure it's passed as a command line argument or defined in the `secrets.jl` file.\"\"\") \nend \n```", "```py\npkg> test \n```", "```py\njulia> write(\".gitignore\", \"secrets.jl\") \n```", "```py\nENV[\"GITHUB_ACCESS_TOKEN\"] = \"0cdf8672e66***\" # token truncated \n```", "```py\nGitHub.create_issue(\"<username>/<repo>\", auth = <GitHub.OAuth2>, params...) \n```", "```py\n@testset \"Adding GitHub issues\" begin \n  delete!(ENV, \"GITHUB_ACCESS_TOKEN\") \n\n  @testset \"Successful authentication should return a GitHub.OAuth2 instance\" begin \n    @test isa(IssueReporter.githubauth(), GitHub.OAuth2) \n  end \n  @testset \"Converting package name to GitHub id\" begin \n    @test IssueReporter.repoid(\"IssueReporter\") == \"essenciary/IssueReporter.jl\" \n  end \n  @testset \"Submitting an issue should result in a GitHub.Issue object\" begin \n    @test isa(IssueReporter.report(\"IssueReporter\", \"I found a bug\", \"Here is how you can reproduce the problem: ...\"), GitHub.Issue) \n  end \nend \n```", "```py\nusing Pkg, Pkg.TOML, GitHub, URIParser  # we've added URIParser and GitHub \n```", "```py\nfunction githubauth() \n  token() |> GitHub.authenticate \nend \n\nfunction repoid(package_name::String) \n  pkg_url = packageuri(package_name) |> URIParser.parse_url \n  repo_info = endswith(pkg_url.path, \".git\") ? \n                replace(pkg_url.path, r\".git$\"=>\"\") : \n                pkg_url.path \n  repo_info[2:end] \nend \n\nfunction report(package_name::String, title::String, body::String) \n  GitHub.create_issue(repoid(package_name), auth = githubauth(), \n                        params = Dict(:title => title, :body => body)) \nend \n```", "```py\n\"\"\" packageuri(pkgname::String) :: String \nTakes the name of a registered Julia package and returns the associated repo git URL. \nExamples ```", "```py \"\"\" function packageuri(pkgname::String) :: String # output truncated # end \n```", "```py\npackageuri function in the DocString. The problem here is that the documentation can get out of sync if we change the function declaration, but omit to update the documentation. Julia's package ecosystem provides a library that extends the default documentation functionality, named DocStringExtensions. It's a registered package, so it can be added with (IssueReporter) pkg> add DocStringExtensions. It provides a series of methods that can be used to automatically generate some of the repetitive parts of the documentation process. For example, once we add using DocStringExtensions to the IssueReporter module, we can replace the function declaration from the docstring with the $(SIGNATURES) *abbreviation*. We'll see how to do that right away.\n```", "```py\nmodule IssueReporter \n\nusing Pkg, Pkg.TOML, GitHub, URIParser, Documenter, DocStringExtensions \n\n# ... some functions omitted ... #\n\n\"\"\" \n$(SIGNATURES) \n\nTakes the name of a registered Julia package and returns the associated repo git URL. \n\n#Examples \n```", "```py \n\"\"\" \nfunction packageuri(pkgname::String) :: String \n    # ... function body omitted ... # \nend \n\n\"\"\" \n$(SIGNATURES) \n\nChecks if the required GitHub authentication token is defined. \n\"\"\" \nfunction tokenisdefined() :: Bool \n  # ... function body omitted ... # \nend \n\n# ... some functions omitted ... #\n\n\"\"\" \n$(SIGNATURES) \n\nConverts a registered Julia package name to the corresponding GitHub \"username/repo_name\" string. \n\n#Examples \n```", "```py \n\"\"\" \nfunction repoid(package_name::String) \n    # ... function body omitted ... # \nend \n\n# ... some functions omitted ... #\n\nend # module  \n```", "```py\nusing Pkg \npkg\"activate ..\" \npush!(LOAD_PATH,\"../src/\") \nusing Documenter, IssueReporter \n\nmakedocs(sitename = \"IssueReporter Documentation\") \n```", "```py\n# IssueReporter.jl Documentation \n```", "```py \n```", "```py \n## Functions \n```", "```py \n## Index \n```", "```py \n```", "```py\nDocumenter: setting up build directory. \nDocumenter: expanding markdown templates. \nDocumenter: building cross-references. \nDocumenter: running document checks. \n > checking for missing docstrings. \n > running doctests. \n > checking footnote links. \nDocumenter: populating indices. \nDocumenter: rendering document. \n```", "```py\njulia> cd(Pkg.dir(\"IssueReporter\")) \njulia> run(`hub create IssueReporter.jl`) \n```", "```py\n# IssueReporter.jl  \n`IssueReporter.jl` is a Julia package which makes it easy to report a new issue with a registered package. \nIn order to use it, it needs to be configured with a valid GitHub authentication token. Follow the instructions at \nhttps://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/ to generate a new token -- make sure \nthat it has the `repo` access. \nOnce you have the token, add it to the secrets.jl file. \nYou can now open issues by invoking: \n`IssueReporter.report(\"Julia package name\", \"issue title\", \"issue body\")` \n```", "```py\n$ git add . $ git commit -m \"initial commit\" $ git push origin master \n```"]