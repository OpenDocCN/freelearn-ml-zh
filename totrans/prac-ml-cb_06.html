<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Supervised Learning"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Supervised Learning</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Decision tree learning - Advance Health Directive for patients with chest pain</li><li class="listitem" style="list-style-type: disc">Decision tree learning - income-based distribution of real estate values</li><li class="listitem" style="list-style-type: disc">Decision tree learning - predicting the direction of stock movement</li><li class="listitem" style="list-style-type: disc">Naive Bayes - predicting the direction of stock movement</li><li class="listitem" style="list-style-type: disc">Random forest - currency trading strategy</li><li class="listitem" style="list-style-type: disc">Support vector machine - currency trading strategy</li><li class="listitem" style="list-style-type: disc">Stochastic gradient descent - adult income</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec29"/>Introduction</h1></div></div></div><p>
<span class="strong"><strong>Decision tree learning</strong></span>: Decision trees are very popular tools for classification and prediction problems. A decision tree is a classifier which recursively partitions the instance space or the variable set. Decision trees are represented as a tree structure where each node can be classified as either a leaf node or a decision node. A leaf node holds the value of the target attribute, while a decision node specifies the rule to be implemented on a single attribute-value. Each decision node splits the instance space into two or more sub-spaces according to a certain discrete function of the input attributes-values. Each test considers a single attribute, such that the instance space is partitioned according to the attribute's value. In the case of numeric attributes, the condition refers to a range. After implementing the rule on the decision node, a sub-tree is an outcome. Each of the leaf nodes holds a probability vector indicating the probability of the target attribute having a certain value. Instances are classified by navigating them from the root of the tree down to a leaf, according to the outcome of the tests along the path.</p><p>The key requirements to mine data with decision trees are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Attribute-value description</strong></span>: The object can be expressed as a fixed set of properties or attributes</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Predefined classes</strong></span>: The categories to which examples are to be assigned must be supervised data</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sufficient data</strong></span>: Use of multiple training cases</li></ul></div><p>
<span class="strong"><strong>Naive Bayes</strong></span>:<span class="strong"><strong> </strong></span>The naive Bayes is a supervised learning method. It is a linear classifier. It is based on the Bayes' theorem, which states that the presence of a particular feature of a class is unrelated to the presence of any other feature. It is a robust and efficient algorithm. Bayesian classifiers can predict class membership probabilities such as the probability that a given tuple belongs to a particular class. Bayesian belief networks is joint conditional probability distribution. It allows class-conditional independencies to be defined between subsets of variables. It provides a graphical model of a causal relationship on which learning can be performed.</p><p>
<span class="strong"><strong>Random forest</strong></span>: Random forests are collections of decision trees that provide predictions into the structure of data. They are a tool that pulls the power of multiple decision trees in judicious randomization, and ensemble learning to produce predictive models. They provide variable rankings, missing values, segmentations, and reporting for each record to ensure deep data understanding. After each tree is built, all the data is run down the tree. For each of the pairs of cases, vicinities are computed. If two cases occupy the same terminal node, their vicinities are increased by one. At the end of the run, normalization is carried out by dividing by the number of trees. Proximities are used in replacing missing data, locating outliers, and producing to reveal low-dimensional understandings of the data. The training data, which is out-of-bag data, is used to estimate classification error and to calculate the importance of variables.</p><p>Random forests run very efficiently on large databases, producing accurate results. They handle multiple variables without deletion, giving estimates of the importance of the variables to solve the classification problems. They generate an internal unbiased estimate of the generalization error as the forest building progresses. A random forest is an effective method for estimating missing data, and maintains accuracy when a large proportion of the data is missing.</p><p>
<span class="strong"><strong>Support vector machines</strong></span>: Machine learning algorithms use right set of features to solve learning problems. SVMs make use of a (nonlinear) mapping function φ which transforms data in the input space to data in the feature space in such a way as to render a problem linearly separable. The SVM then discovers the optimal separating hyperplane which is then mapped back into input space via φ-1. Among the possible hyperplanes, we select the one where the distance of the hyperplane from the closest data points (the margin) is as large as possible.</p></div></div>
<div class="section" title="Decision tree learning - Advance Health Directive for patients with chest pain"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Decision tree learning - Advance Health Directive for patients with chest pain</h1></div></div></div><p>An Advance Health Directive document states the directions regarding the future health care for an individual on various medical conditions. It guides an individual to make the right decision in case of emergency or as required. The document helps an individual to understand the nature and consequences of their health care decisions, understand the nature and effect of the directive, freely and voluntarily make these decisions, and communicate the decisions in some way.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec32"/>Getting ready</h2></div></div></div><p>In order to perform decision tree classification, we will be using a dataset collected from the heart patients dataset.</p><div class="section" title="Step 1 - collecting and describing the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec81"/>Step 1 - collecting and describing the data</h3></div></div></div><p>The dataset titled <code class="literal">Heart.csv</code> which is available in CSV format, will be used. The dataset is in standard format. There are 303 rows of data. There are 15 variables. The numeric variables are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Age</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Sex</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">RestBP</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Chol</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Fbs</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">RestECG</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">MaxHR</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ExAng</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Oldpeak</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Slope</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Ca</code></li></ul></div><p>The non-numeric variables are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ChestPain</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Thal</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">AHD</code></li></ul></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec33"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - exploring the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec82"/>Step 2 - exploring the data</h3></div></div></div><p>The following packages need to be loaded as the first step to be carried out:</p><pre class="programlisting">
<span class="strong"><strong>&gt; install.packages("tree")
&gt; install.packages("caret")
&gt; install.packages("e1071")
&gt; library(tree)
&gt; library(caret)</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>Version info: Code for this page was tested in R version 3.3.0 (2016-05-03).</p></div></div><p>Let's explore the data and understand the relationships between the variables. We'll begin by importing the CSV data file named <code class="literal">Heart.csv</code>. We will be saving the data to the <code class="literal">AHD_data</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; AHD_data &lt;- read.csv("d:/Heart.csv", header = TRUE)</strong></span>
</pre><p>Exploring the internal structure of the <code class="literal">AHD_data</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">AHD_data</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; str(AHD_data) </strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_001.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>Printing the <code class="literal">AHD_data</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">AHD_data</code> data frame. The <code class="literal">AHD_data</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(AHD_data)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_002.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>Exploring the dimensions of the <code class="literal">AHD_data</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">AHD_data</code> frame. The <code class="literal">AHD_data</code> data frame is passed as an input parameter. The result clearly states that there are 303 rows of data and 15 columns:</p><pre class="programlisting">
<span class="strong"><strong>    &gt;dim(AHD_data)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_003.jpg" alt="Step 2 - exploring the data"/></div><p>
</p></div><div class="section" title="Step 3 - preparing the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec83"/>Step 3 - preparing the data</h3></div></div></div><p>The data needs to be prepared for carrying out the model building and testing. Data is split into two parts--one for building the model and the other for testing the model which will be prepared.</p><p>The <code class="literal">createDataPartition()</code> function is used for creating splits of the data. <code class="literal">AHD_data</code> is passed as an argument to the function. Random sampling takes place. The percentage of data that goes to training is denoted by <code class="literal">p</code>. Here, the value of <code class="literal">p</code> is <code class="literal">0.5</code>, which means that 50% of the data is used for the training. <code class="literal">List = 'FALSE'</code> avoids returning the data as a list. The result is then stored in the data frame 
split
: 
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; split &lt;- createDataPartition(y=AHD_data$AHD, p = 0.5, list=FALSE)</strong></span>
</pre><p>The call to the data frame <code class="literal">split</code> displays training set data for training purposes:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; split</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_004.jpg" alt="Step 3 - preparing the data"/></div><p>
</p><p>The training data will be created. The <code class="literal">split</code> data frame is used to create the training data. The <code class="literal">train</code> data frame is used to store the values of the training data:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; train &lt;- AHD_data[split,]</strong></span>
</pre><p>Printing the training data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; train</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_005.jpg" alt="Step 3 - preparing the data"/></div><p>
</p><p>The testing data will be created. The <code class="literal">split</code> data frame is used to create the testing data. The <code class="literal">-</code> sign before the <code class="literal">split</code> data frame denotes all those rows of data which have not been considered for training purposes. The test data frame is used to store the values of the testing data:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; test &lt;- AHD_data[-split,]</strong></span>
</pre><p>Printing the testing data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; test</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_006.jpg" alt="Step 3 - preparing the data"/></div><p>
</p></div><div class="section" title="Step 4 - training the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec84"/>Step 4 - training the model</h3></div></div></div><p>The model will now be prepared and trained on the training dataset. Decision trees are used when datasets are divided into groups, as compared to investigating a numerical response and its relationship to a set of descriptor variables. The implementation of classification trees in R is carried out using the <code class="literal">tree()</code> function.</p><p>The <code class="literal">tree()</code> function is used to implement classification trees. A tree is grown by binary recursive partitioning. The <code class="literal">AHD</code> field on the training dataset is used to form classification trees. The resulting data frame is stored in the <code class="literal">trees</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; trees &lt;- tree(AHD ~., train)</strong></span>
</pre><p>A graphical version of the trees data frame will be displayed. The <code class="literal">plot()</code> function is a generic function for the plotting of R objects. The trees data frame is passed as a function value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; plot(trees)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_007.jpg" alt="Step 4 - training the model"/></div><p>
</p><p>Find the deviance or number of misclassifications by running a cross-validation experiment. The <code class="literal">cv.tree()</code> function will be used. The <code class="literal">trees</code> data frame object is passed. <code class="literal">FUN=prune.misclass</code> obtains a nested sequence of subtrees of the supplied data frame trees by recursively snipping off the least important splits. The result is stored in the <code class="literal">cv.trees</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; cv.trees &lt;- cv.tree(trees, FUN=prune.misclass)</strong></span>
</pre><p>Printing the results of data frame <code class="literal">cv.trees</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; cv.trees</strong></span>
</pre><p>The <code class="literal">$dev</code> field gives the deviance for each K.</p><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_008.jpg" alt="Step 4 - training the model"/></div><p>
</p><p>Using the <code class="literal">plot()</code> function data frame, <code class="literal">cv.trees</code> is displayed. The <code class="literal">$dev</code> value is on the <span class="emphasis"><em>y </em></span>axis (right side). The <code class="literal">$k</code> value is on the top. The <code class="literal">$size</code> value is on the <span class="emphasis"><em>x </em></span>axis.</p><p>As can be clearly seen, when <code class="literal">$size = 1</code>, <code class="literal">$k = 30.000000</code>, <code class="literal">$dev = 1</code>. We plot the data frame using:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; plot(cv.trees)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_009.jpg" alt="Step 4 - training the model"/></div><p>
</p></div><div class="section" title="Step 5- improving the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec85"/>Step 5- improving the model</h3></div></div></div><p>Let us improve the model by splitting the tree with the lowest deviance. The <code class="literal">prune.misclass()</code> function is called to split the tree. <code class="literal">prune.misclass</code> obtains a nested sequence of subtrees of the supplied data frame trees by recursively snipping off the least important splits. The result is stored in the <code class="literal">prune.trees</code> data frame. <code class="literal">best=4</code> indicates the size (for example, the number of terminal nodes) of a specific subtree in the cost-complexity sequence that is to be returned:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; prune.trees &lt;- prune.misclass(trees, best=4)</strong></span>
</pre><p>Using the <code class="literal">plot()</code> function data frame, <code class="literal">prune.trees</code> is displayed:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; plot(prune.trees)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_010.jpg" alt="Step 5- improving the model"/></div><p>
</p><p>Adding the text to the preceding pruned tree:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; text(prune.trees, pretty=0)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_011.jpg" alt="Step 5- improving the model"/></div><p>
</p><p>In order to predict the value based on a linear model object, we will use the <code class="literal">predict()</code> function. <code class="literal">prune.trees</code> is passed as an object. The <code class="literal">test</code> data object is passed as an object in which to look for variables with which to predict. The result will be stored in the <code class="literal">tree.pred</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; tree.pred &lt;- predict(prune.trees, test, type='class')</strong></span>
</pre><p>Displaying the variable <code class="literal">test.pred</code> values:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; tree.pred</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_012.jpg" alt="Step 5- improving the model"/></div><p>
</p><p>Summarizing the results of the model. The <code class="literal">confusionMatrix()</code> calculates the cross-tabulation of the observed and predicted classes. <code class="literal">tree.pred</code> is passed as a factor of predicted classes:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; confusionMatrix(tree.pred, test$AHD)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_013.jpg" alt="Step 5- improving the model"/></div><p>
</p></div></div></div>
<div class="section" title="Decision tree learning - income-based distribution of real estate values"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Decision tree learning - income-based distribution of real estate values</h1></div></div></div><p>Income has been an essential component of the attractive long-term total returns provided by real estate as an asset class. The annual income returns generated from investing in real estate have been more than 2.5 times higher than stocks and lagged bonds by only 50 basis points. Real estate often provides a steady source of income based on the rent paid by tenants.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec34"/>Getting ready</h2></div></div></div><p>In order to perform decision tree classification, we will be using a dataset collected from the real estate dataset.</p><div class="section" title="Step 1 - collecting and describing the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec86"/>Step 1 - collecting and describing the data</h3></div></div></div><p>The dataset titled <code class="literal">RealEstate.txt</code> will be used. This dataset is available in TXT format, titled <code class="literal">RealEstate.txt</code>. The dataset is in standard format. There are 20,640 rows of data. The 9 numerical variables are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MedianHouseValue</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">MedianIncome</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">MedianHouseAge</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TotalRooms</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TotalBedrooms</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Population</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Households</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Latitude</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Longitude</code></li></ul></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec35"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - exploring the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec87"/>Step 2 - exploring the data</h3></div></div></div><p>The following package needs to be loaded as the first step to be carried out:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; install.packages("tree")</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>Version info: Code for this page was tested in R version 3.3.0 (2016-05-03).</p></div></div><p>Let's explore the data and understand the relationships between the variables. We'll begin by importing the TXT data file named <code class="literal">RealEstate.txt</code>. We will be saving the data to the <code class="literal">realEstate</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; realEstate &lt;- read.table("d:/RealEstate.txt", header=TRUE)</strong></span>
</pre><p>Exploring the dimensions of the <code class="literal">realEstate</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">realEstate</code> frame. The <code class="literal">realEstate</code> data frame is passed as an input parameter. The result clearly states that there are 20,640 rows of data and 9 columns:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dim(realEstate)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_014.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>Exploring the internal structure of the <code class="literal">realEstate</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">realEstate</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; str(realEstate)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_015.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>Printing the <code class="literal">realEstate</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">realEstate</code> data frame. The <code class="literal">realEstate</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(realEstate)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_016.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>Printing the summary of the <code class="literal">realEstate</code> data frame. The <code class="literal">summary()</code> function is a multipurpose function. <code class="literal">summary()</code> is a generic function that provides a summary of the data related to the individual object or data frame. The <code class="literal">realEstate</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(realEstate)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_017.jpg" alt="Step 2 - exploring the data"/></div><p>
</p></div><div class="section" title="Step 3 - training the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec88"/>Step 3 - training the model</h3></div></div></div><p>The model will now be prepared on the dataset. Decision trees are a tool for classification and prediction. They represent rules which can be understood by humans and used in knowledge systems such as a database. They classify instances by starting at the root of the tree and moving through it until they reach a leaf node. The node specifies a test on a single attribute, the leaf indicates the value of the target attribute, and the edge splits off one attribute.</p><p>The <code class="literal">tree()</code> function is used to implement classification trees. A tree is grown by binary recursive partitioning. These models are computationally intensive techniques, since they recursively partition response variables into subsets based on their relationship to one or more predictor variables.</p><p>The formula expression is based on the sum of the variables <code class="literal">Latitude</code> and <code class="literal">Longitude</code>. The result of the sum is stored in the log value of <code class="literal">MedianHouseValue</code>. <code class="literal">data=realEstate</code> represents the data frame in which to preferentially interpret formula, weights, and subset.</p><p>The resulting data frame is stored in data frame <code class="literal">treeModel</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; treeModel &lt;- tree(log(MedianHouseValue) ~ Longitude + Latitude, data=realEstate) </strong></span>
</pre><p>A summary of the <code class="literal">treeModel</code> will be displayed. The summary displays the formula used, along with the number of terminal nodes or leaves in the trees. The statistical distribution of the residuals is also displayed.</p><p>The <code class="literal">summary()</code> function is used to display the statistical summary of <code class="literal">treeModel</code>. It is a generic that is used to produce the summaries of the results for various fitting functions. The data frame on which the summary is desired is <code class="literal">treeModel</code>, which is passed as an input parameter.</p><p>Deviance here means the mean squared error:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(treeModel)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_018.jpg" alt="Step 3 - training the model"/></div><p>
</p><p>A graphical version of the <code class="literal">treeModel</code> data frame will be displayed. The <code class="literal">plot()</code> function is a generic function for plotting R objects. The <code class="literal">treeModel</code> data frame is passed as a function value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; plot(treeModel) </strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_019.jpg" alt="Step 3 - training the model"/></div><p>
</p><p>After the graphical version of the <code class="literal">treeModel</code> data frame is displayed, text needs to be inserted to display the value at each node and the leaves. The <code class="literal">text()</code> function is used to insert strings given in the labels vector at the given coordinates:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; text(treeModel, cex=.75)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_020.jpg" alt="Step 3 - training the model"/></div><p>
</p></div><div class="section" title="Step 4 - comparing the predictions"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec89"/>Step 4 - comparing the predictions</h3></div></div></div><p>Comparing the predictions with the dataset which reflect the global price trend. We wish to summarize the frequency distribution of <code class="literal">MedianHouseValue</code> for ease of reporting or comparison. The most direct method is to use quantiles. Quantiles are points in a distribution that relate to the rank order of values in that distribution. The quantiles will divide the <code class="literal">MedianHouseValue</code> distribution such that there is a given proportion of an observation below the quantile.</p><p>
The 
<code class="literal">quantile()</code> function produces sample quantiles corresponding to the given probabilities. <code class="literal">realEstate$MedianHouseValue</code> is the numeric vector whose sample quantiles are wanted. The <code class="literal">quantile()</code> function returns <code class="literal">priceDecilesas</code> a vector of length:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; priceDeciles &lt;- quantile(realEstate$MedianHouseValue, 0:10/10)</strong></span>
</pre><p>Displaying the value of the <code class="literal">priceDeciles</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; priceDeciles</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_021.jpg" alt="Step 4 - comparing the predictions"/></div><p>
</p><p>Next, a summary of the <code class="literal">priceDeciles</code> will be displayed. The <code class="literal">summary()</code> function is used to display the statistical summary of the <code class="literal">priceDeciles</code>. The data frame for which the summary is desired is <code class="literal">priceDeciles</code>, which is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(priceDeciles)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_022.jpg" alt="Step 4 - comparing the predictions"/></div><p>
</p><p>Dividing the <code class="literal">priceDeciles</code> vector into different ranges. The <code class="literal">cut()</code> function divides the range of intervals according to which interval they fall into. The numeric vector <code class="literal">MedianHouseValue</code> of the <code class="literal">realEstate</code> data frame is to be converted to a factor by cutting:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; cutPrices &lt;- cut(realEstate$MedianHouseValue, priceDeciles, include.lowest=TRUE)</strong></span>
</pre><p>Printing the <code class="literal">cutPrices</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">cutPrices</code> data frame. The <code class="literal">cutPrices</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(cutPrices)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_023.jpg" alt="Step 4 - comparing the predictions"/></div><p>
</p><p>A summary of <code class="literal">cutPrices</code> will be displayed. The <code class="literal">summary()</code> function is used to display the statistical summary of the <code class="literal">treeModel</code>. The data frame on which the summary is desired is <code class="literal">cutPrices</code>, which is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(cutPrices)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_024.jpg" alt="Step 4 - comparing the predictions"/></div><p>
</p><p>Plotting the value of the <code class="literal">cutPrices</code>. The <code class="literal">plot()</code> function is a generic function for the plotting of R objects. The <code class="literal">cutPrices</code> data frame is passed as a function value. The longitude variable of the <code class="literal">realEstate</code> dataset represents the <span class="emphasis"><em>x</em></span> coordinates of points in the plot. The latitude variable of the <code class="literal">realEstate</code> dataset represents the <span class="emphasis"><em>y</em></span> coordinates of points in the plot. <code class="literal">col=grey(10:2/11)</code> represents the plot color. <code class="literal">pch=20</code> represents the size of the symbol to be used as the default in plotting points. <code class="literal">xlab="Longitude"</code> represents the title for the x axis, while <code class="literal">ylab="Latitude"</code> represents the title for the <span class="emphasis"><em>y</em></span> axis:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; plot(realEstate$Longitude, realEstate$Latitude, col=grey(10:2/11)[cutPrices], pch=20, xlab="Longitude",ylab="Latitude") </strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_025.jpg" alt="Step 4 - comparing the predictions"/></div><p>
</p><p>A summary of <code class="literal">Longitude</code> will be displayed. The <code class="literal">summary()</code> function is used to display the statistical summary:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(realEstate$Longitude)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_026.jpg" alt="Step 4 - comparing the predictions"/></div><p>
</p><p>Printing the <code class="literal">Longitude</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">Longitude</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(realEstate$Longitude)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_027.jpg" alt="Step 4 - comparing the predictions"/></div><p>
</p><p>A summary of <code class="literal">Latitude</code> will be displayed. The <code class="literal">summary()</code> function is used to display the statistical summary:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(realEstate$Latitude)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_028.jpg" alt="Step 4 - comparing the predictions"/></div><p>
</p><p>Printing the <code class="literal">Latitude</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">Latitude</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(realEstate$Latitude)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_029.jpg" alt="Step 4 - comparing the predictions"/></div><p>
</p><p>The <code class="literal">partition.tree()</code> function is used to partition a tree where two or more variables are involved. <code class="literal">treeModel</code> is passed as a tree object. <code class="literal">ordvars=c("Longitude","Latitude")</code> indicates the ordering in which the variables are to be used to plot. Longitude represents the <span class="emphasis"><em>x</em></span> axis, while <code class="literal">Latitude</code> represents the y axis. <code class="literal">add=TRUE</code> means adding to the existing plot:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; partition.tree(treeModel, ordvars=c("Longitude","Latitude"), add=TRUE)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_030.jpg" alt="Step 4 - comparing the predictions"/></div><p>
</p></div><div class="section" title="Step 5 - improving the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec90"/>Step 5 - improving the model</h3></div></div></div><p>The number of leaves in a tree controls the flexibility of the tree. The number of leaves indicates how many cells they partition the tree into. Each node has to contain a certain number of points, and adding a node has to reduce the error by at least a certain amount. The default value for <code class="literal">min.dev</code> is 0.01.</p><p>Next, we will reduce the value of <code class="literal">min.dev</code> to 0.001.</p><p>The <code class="literal">tree()</code> function is used to implement classification trees. The formula expression is based on the sum of the variables <code class="literal">Latitude</code> and <code class="literal">Longitude</code>. The result of the sum is stored in the log value of <code class="literal">MedianHouseValue</code>. <code class="literal">data=realEstate</code> represents the data frame in which to preferentially interpret formula, weights, and subset. The value for <code class="literal">min.dev</code> denotes the deviance that must be at least 0.001 times of the root node for the node to be split.</p><p>The resulting data frame is stored in the <code class="literal">treeModel2</code> data frame:
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; treeModel2 &lt;- tree(log(MedianHouseValue) ~ Longitude + Latitude, data=realEstate, mindev=0.001)</strong></span>
</pre><p>A summary of the <code class="literal">treeModel2</code> will be displayed. The summary displays the formula used, along with the number of terminal nodes or the leaves in the trees. The statistical distribution of the residuals is also displayed.</p><p>The <code class="literal">summary()</code> function is used to display the statistical summary of the <code class="literal">treeModel2</code>. The data frame on which the summary is desired is <code class="literal">treeModel2</code>, which is passed as an input parameter.</p><p>Deviance here means the mean squared error:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(treeModel2)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_031.jpg" alt="Step 5 - improving the model"/></div><p>
</p><p>When compared with the summary of <code class="literal">treeModel</code>, the value of leaves in <code class="literal">treeModel2</code> increases from 12 to 68. The value of deviance changes from 0.1666 to 0.1052 for <code class="literal">treeModel</code> and <code class="literal">treeModel2</code>, respectively.</p><p>A graphical version of the <code class="literal">treeModel2</code> data frame will be displayed. The <code class="literal">plot()</code> function is a generic function for plotting R objects. The <code class="literal">treeModel2</code> data frame is passed as a function value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; plot(treeModel2)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_032.jpg" alt="Step 5 - improving the model"/></div><p>
</p><p>After the graphical version of the <code class="literal">treeModel2</code> data frame is displayed, text needs to be inserted to display the value at each node and the leaves. The <code class="literal">text()</code> function is used to insert strings given in the vector labels at the given coordinates:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; text(treeModel2, cex=.65)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_033.jpg" alt="Step 5 - improving the model"/></div><p>
</p><p>Including all the variables in the formula extension.</p><p>The <code class="literal">tree()</code> function is used to implement classification trees. The formula expression is based on all the variables.</p><p>The resulting data frame is stored in the <code class="literal">treeModel3</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; treeModel3 &lt;- tree(log(MedianHouseValue) ~ ., data=realEstate)</strong></span>
</pre><p>A summary of <code class="literal">treeModel3</code> will be displayed. The summary displays the formula used along with the number of terminal nodes or the leaves in the trees. The statistical distribution of the residuals is also displayed.</p><p>The <code class="literal">summary()</code> function is used to display the statistical summary of <code class="literal">treeModel3</code>. The data frame on which the summary is desired is <code class="literal">treeModel3</code>, which is passed as an input parameter.</p><p>Deviance here means the mean squared error:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(treeModel3)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_034.jpg" alt="Step 5 - improving the model"/></div><p>
</p><p>The formula clearly states that all the variables of the <code class="literal">realEstate</code> dataset.</p><p>A graphical version of <code class="literal">treeModel3</code> data frame will be displayed. The <code class="literal">plot()</code> function is a generic function for plotting R objects. The <code class="literal">treeModel3</code> data frame is passed as a function value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; plot(treeModel3)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_035.jpg" alt="Step 5 - improving the model"/></div><p>
</p><p>After a graphical version of the <code class="literal">treeModel3</code> data frame is displayed, text needs to be inserted to display the value at each node and the leaves. The <code class="literal">text()</code> function is used to insert strings given in the vector labels at the given coordinates:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; text(treeModel3, cex=.75)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_036.jpg" alt="Step 5 - improving the model"/></div><p>
</p></div></div></div>
<div class="section" title="Decision tree learning - predicting the direction of stock movement"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Decision tree learning - predicting the direction of stock movement</h1></div></div></div><p>Stock trading is one of the most challenging problems statisticians are trying to solve. There are multiple technical indicators, such as trend direction, momentum or lack of momentum in the market, volatility for profit potential, and volume measures to monitor the popularity in the market, to name a few. These indicators can be used to create strategy to high-probability trading opportunities. Days/weeks/months can be spent discovering the relationships between technical indicators. An efficient and less time-consuming tool, such as a decision tree, can be used. The main advantage of a decision tree is that it is a powerful and easily interpretable algorithm, which gives a good head start.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec36"/>Getting ready</h2></div></div></div><p>In order to perform decision tree classification, we will be using a dataset collected from the stock markets dataset.</p><div class="section" title="Step 1 - collecting and describing the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec91"/>Step 1 - collecting and describing the data</h3></div></div></div><p>The dataset to be used is the Bank of America's daily closing stock value between 1<sup>st</sup> January, 2012 and 1<sup>st</sup> January, 2014. This dataset is freely available on <a class="ulink" href="https://yahoo.com/">https://yahoo.com/</a>, from where we will be downloading the data.</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec37"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - exploring the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec92"/>Step 2 - exploring the data</h3></div></div></div><p>The following package needs to be loaded as the first step to be carried out:</p><pre class="programlisting">
<span class="strong"><strong>&gt; install.packages("quantmod")
&gt; install.packages("rpart")
&gt; install.packages("rpart.plot")</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>Version info: Code for this page was tested in R version 3.3.0 (2016-05-03).</p></div></div><p>Each of the preceding libraries needs to be installed:</p><pre class="programlisting">
<span class="strong"><strong>&gt; library("quantmod")
&gt; library("rpart")
&gt; library("rpart.plot")</strong></span>
</pre><p>Let's download the data. We will begin by marking the start and end date for the time period in which the data is desired.</p><p>The <code class="literal">as.Date()</code> function is used to convert the character representation and objects of the <code class="literal">Date</code> class, which represents the calendar dates.</p><p>The start date for the dataset is stored in <code class="literal">startDate</code>, which represents the character vector representation of the calendar date. The format for representation is <span class="emphasis"><em>YYYY-MM-DD</em></span>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; startDate = as.Date("2012-01-01")</strong></span>
</pre><p>The end date for the dataset is stored in <code class="literal">endDate</code>, which represents the character vector representation of the calendar date. The format for representation is <span class="emphasis"><em>YYYY-MM-DD</em></span>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; endDate = as.Date("2014-01-01")</strong></span>
</pre><p>Load the data using the <code class="literal">getSymbols()</code> function. The function loads data from multiple sources, either local or remote. Data is fetched and saved in the <code class="literal">env</code> specified. The default value is <code class="literal">.GlobalEnv</code> for <code class="literal">env</code>. <code class="literal">BAC</code> is the character vector that specifies the name of the symbol to be loaded. <code class="literal">src = yahoo</code> specifies the sourcing method:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; getSymbols("BAC", env = .GlobalEnv,  src = "yahoo", from = startDate, to = endDate)</strong></span>
</pre></div><div class="section" title="Step 3 - calculating the indicators"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec93"/>Step 3 - calculating the indicators</h3></div></div></div><p>Relative Strength Index is calculated. It is a ratio of recent upward price movements to the absolute price movement. The <code class="literal">RSI()</code> function is used to calculate the Relative Strength Index. The <code class="literal">BAC</code> symbol is used as a price series. <code class="literal">n = 3</code> represents the number of periods for moving averages. The result is then stored in the <code class="literal">relativeStrengthIndex3</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; relativeStrengthIndex3 &lt;- RSI(Op(BAC), n= 3) </strong></span>
</pre><p>Displaying the <code class="literal">relativeStrengthIndex3</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; relativeStrengthIndex3</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_037.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Calculating the moving averages. The <span class="strong"><strong>exponential moving average</strong></span> is used for technical analysis and as a technical indicator. In a <span class="strong"><strong>simple moving average</strong></span>, each value in the series carries equal weight. The values outside of the time series are not included in the average. However, the exponential moving average is a cumulative calculation, including all data. There is a diminishing value of the past data, while the more recent data values have greater contribution.</p><p>
<code class="literal">EMA()</code> uses the <code class="literal">BAC</code> symbol and is used as a price series. <code class="literal">n = 5</code> represents the time period to average over. The result is then stored in the <code class="literal">exponentialMovingAverage5</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; exponentialMovingAverage5 &lt;- EMA(Op(BAC),n=5)</strong></span>
</pre><p>Displaying the <code class="literal">exponentialMovingAverage5</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; exponentialMovingAverage5</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_038.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Exploring the dimensions of the <code class="literal">exponentialMovingAverage5</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">exponentialMovingAverage5</code> frame. The <code class="literal">exponentialMovingAverage5</code> data frame is passed as an input parameter. The result clearly states that there are 502 rows of data and 1 column:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dim(exponentialMovingAverage5)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_039.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Exploring the internal structure of the <code class="literal">exponentialMovingAverage5</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">exponentialMovingAverage5</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; str(exponentialMovingAverage5)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_040.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Calculating the difference between the price and our calculated <code class="literal">exponentialMovingAverage5</code>, for example, the five-year exponential moving average values. The result is stored in the <code class="literal">exponentialMovingAverageDiff</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; exponentialMovingAverageDiff &lt;- Op(BAC)-exponentialMovingAverage5</strong></span>
</pre><p>Comparing the fast-moving average of a BAC series with a slow-moving average of a BAC series. <code class="literal">BAC</code> is passed as the price matrix. <code class="literal">fast = 12</code> represents the periods for fast-moving average, <code class="literal">slow = 26</code> represents the periods for slow-moving average, <code class="literal">signal = 9</code> represents the signal for moving average:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; MACD &lt;- MACD(Op(BAC),fast = 12, slow = 26, signal = 9)</strong></span>
</pre><p>Displaying the MACD value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; MACD</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_041.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Printing the MACD data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">MACD</code> data frame. The <code class="literal">MACD</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(MACD)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_042.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Grabbing the signal line to use as an indicator. The result is stored in the <code class="literal">MACDsignal</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; MACDsignal &lt;- MACD[,2]</strong></span>
</pre><p>Displaying the <code class="literal">MACDsignal</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; MACDsignal</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_043.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Determining the close to the midpoint of the high/low range. In order to determine the location of each day's close relative to the high/low range, a stochastic oscillator is used. The <code class="literal">SMI()</code> function is used for the momentum indicator.</p><p>
<code class="literal">BAC</code> is the matrix which contains high-low-close prices. <code class="literal">n = 13</code> indicates the number of periods. <code class="literal">slow=25</code> indicates the number of periods for double smoothing. <code class="literal">fast=2</code> indicates the number of periods for initial smoothing. <code class="literal">signal=9</code> indicates the number of periods for the signal line. The results are stored in the <code class="literal">stochasticOscillator</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; stochasticOscillator &lt;- SMI(Op(BAC),n=13,slow=25,fast=2,signal=9)</strong></span>
</pre><p>Displaying the <code class="literal">stochasticOscillator</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; stochasticOscillator</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_044.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Grabbing the oscillator to use as an indicator. The result is stored in the <code class="literal">stochasticOscillatorSignal</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; stochasticOscillatorSignal &lt;- stochasticOscillator[,1]</strong></span>
</pre><p>Displaying the <code class="literal">stochasticOscillatorSignal</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; stochasticOscillatorSignal</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_045.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p></div><div class="section" title="Step 4 - preparing variables to build datasets"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec94"/>Step 4 - preparing variables to build datasets</h3></div></div></div><p>Calculating the difference between the closing and opening prices. <code class="literal">Cl</code> stands for closing prices and <code class="literal">Op</code> for opening prices. The results are stored in the <code class="literal">PriceChange</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; PriceChange &lt;- Cl(BAC) - Op(BAC)</strong></span>
</pre><p>Displaying the <code class="literal">PriceChange</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; PriceChange</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_046.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Creating a binary classification variable. The <code class="literal">ifelse()</code> function uses a test expression to return the value, which is itself a vector, and is of the same length as the test expression. The vector returned has an element from <code class="literal">x</code> if the corresponding value of the <code class="literal">test</code> expression <code class="literal">is TRUE</code>, or from <code class="literal">y</code> if the corresponding value of <code class="literal">test</code> expression <code class="literal">is FALSE.</code>
</p><p>Here, <code class="literal">PriceChange&gt;0</code> is the test function, which is to be tested in a logical mode.<code class="literal">UP</code> and <code class="literal">DOWN</code> perform the logical test. The result is then stored in the <code class="literal">binaryClassification</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; binaryClassification &lt;- ifelse(PriceChange&gt;0,"UP","DOWN")</strong></span>
</pre><p>Displaying the <code class="literal">binaryClassification</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; binaryClassification</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_047.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Exploring the internal structure of the <code class="literal">binaryClassification</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. <code class="literal">binaryClassification</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; str(binaryClassification)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_048.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Creating the dataset to be used. The <code class="literal">data.frame()</code> function is used to create data frames based on a tightly coupled set of variables. These variables share the properties of matrices. The variables passed as parameters to <code class="literal">data.frame()</code> are <code class="literal">relativeStrengthIndex3</code>, <code class="literal">exponentialMovingAverageDiff</code>, <code class="literal">MACDsignal</code>, <code class="literal">stochasticOscillator</code>, and <code class="literal">binaryClassification</code>.</p><p>The result is then stored in the <code class="literal">DataSet</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; AAPLDataSetNew &gt;-
data.frame(weekDays,exponentialMovingAverageDiffRound,
binaryClassification) </strong></span>
</pre><p>Displaying the <code class="literal">DataSet</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; DataSet</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_049.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Printing the <code class="literal">DataSet</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">DataSet</code> data frame. The <code class="literal">DataSet</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(DataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_050.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Exploring the internal structure of the <code class="literal">DataSet</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">DataSet</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; str(DataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_051.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Naming the columns. The <code class="literal">c()</code> function is used to combine the arguments into vectors.</p><p>The variables passed as parameters to <code class="literal">c()</code> are <code class="literal">relativeStrengthIndex3</code>, <code class="literal">exponentialMovingAverageDiff</code>, <code class="literal">MACDsignal</code>, <code class="literal">stochasticOscillator</code>, and <code class="literal">binaryClassification</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; colnames(DataSet) &lt;- c("relativeStrengthIndex3", "exponentialMovingAverageDiff", "MACDsignal", "stochasticOscillator", "binaryClassification")</strong></span>
</pre><p>Displaying the <code class="literal">colnames(DataSet)</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; colnames(DataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_052.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Eliminating the data where the indicators are to be calculated:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; DataSet &lt;- DataSet[-c(1:33),]</strong></span>
</pre><p>Displaying the <code class="literal">DataSet</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; DataSet</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_053.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Printing the <code class="literal">DataSet</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">DataSet</code> data frame. The <code class="literal">DataSet</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(DataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_054.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Exploring the internal structure of the <code class="literal">DataSet</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">DataSet</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; str(DataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_055.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Exploring the dimensions of the <code class="literal">DataSet</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">DataSet</code> frame. The <code class="literal">DataSet</code> data frame is passed as an input parameter. The result clearly states that there are 469 rows of data and 5 columns:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dim(DataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_056.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Building a training dataset. Two-thirds of the elements in the <code class="literal">DataSet</code> data frame will be used as a training dataset, while one-third of the elements in the <code class="literal">DataSet</code> data frame will be used as a testing dataset.</p><p>The training dataset will be stored in <code class="literal">TrainingDataSet</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; TrainingDataSet &lt;- DataSet[1:312,]</strong></span>
</pre><p>Displaying the <code class="literal">TrainingDataSet</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; TrainingDataSet</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_057.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Exploring the internal structure of the <code class="literal">TrainingDataSet</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">TrainingDataSet</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; str(TrainingDataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_058.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>The training dataset will be stored in <code class="literal">TestDataSet</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; TestDataSet &lt;- DataSet[313:469,]</strong></span>
</pre><p>Displaying the <code class="literal">TestDataSet</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; TestDataSet</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_059.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Exploring the internal structure of the <code class="literal">TestDataSet</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">TestDataSet</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; str(TestDataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_060.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p></div><div class="section" title="Step 5 - building the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec95"/>Step 5 - building the model</h3></div></div></div><p>Building the tree model by specifying the indicators. The <code class="literal">rpart()</code> function will be used. It will fit the model. <code class="literal">binaryClassification</code> is the outcome, using the sum of <code class="literal">relativeStrengthIndex3</code>, <code class="literal">exponentialMovingAverageDiff</code>, <code class="literal">MACDsignal</code>, and <code class="literal">stochasticOscillator</code> as the predictors. <code class="literal">data=TrainingDataSet</code> represents the data frame. <code class="literal">cp=.001</code> represents the complexity parameter. The main role of the parameter is to save computing time by pruning off splits. The result is then stored in the <code class="literal">DecisionTree</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; DecisionTree &lt;- rpart(binaryClassification~relativeStrengthIndex3+exponentialMovingAverageDiff+MACDsignal+stochasticOscillator,data=TrainingDataSet, cp=.001)</strong></span>
</pre><p>Plotting the tree model. The <code class="literal">prp()</code> function will be used to plot the <code class="literal">DecisionTree</code> data frame. <code class="literal">type=2</code> shifts alternate nodes vertically:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; prp(DecisionTree,type=2)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/B04714_06_61.jpg" alt="Step 5 - building the model"/></div><p>
</p><p>Displaying the <code class="literal">cp</code> table for the <code class="literal">DecisionTree</code> data frame. The <code class="literal">printcp()</code> function is used. <code class="literal">DecisionTree</code> is passed as an input:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; printcp(DecisionTree)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_062.jpg" alt="Step 5 - building the model"/></div><p>
</p><p>Plotting the geometric mean for trees. <code class="literal">plotcp()</code> function is used. It provides the visual representation of the cross-validation results of the <code class="literal">DecisionTree</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; plotcp(DecisionTree,upper="splits")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_063.jpg" alt="Step 5 - building the model"/></div><p>
</p></div><div class="section" title="Step 6 - improving the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec96"/>Step 6 - improving the model</h3></div></div></div><p>Improving the model after pruning the tree. <code class="literal">prune()</code> is the function used. <code class="literal">DecisionTree</code> is the data frame that is passed as an input. <code class="literal">cp=0.041428</code> has been taken, since this is the lowest cross-validation error value (x error):</p><pre class="programlisting">
<span class="strong"><strong>    &gt; PrunedDecisionTree &lt;- prune(DecisionTree,cp=0.041428)</strong></span>
</pre><p>Plotting the <code class="literal">tree</code> model. The <code class="literal">prp()</code> function will be used to plot the <code class="literal">DecisionTree</code> data frame. <code class="literal">type=4</code> shifts alternate nodes vertically:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; prp(PrunedDecisionTree, type=4)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_064.jpg" alt="Step 6 - improving the model"/></div><p>
</p><p>Testing the model:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; table(predict(PrunedDecisionTree,TestDataSet), TestDataSet[,5],dnn=list('predicted','actual')) </strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_065.jpg" alt="Step 6 - improving the model"/></div><p>
</p></div></div></div>
<div class="section" title="Naive Bayes - predicting the direction of stock movement"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Naive Bayes - predicting the direction of stock movement</h1></div></div></div><p>Stock trading is one of the most challenging problems statisticians are trying to solve. There are multiple technical indicators, such as trend direction, momentum or lack of momentum in the market, volatility for profit potential, and volume measures to monitor the popularity in the market, to name a few. These indicators can be used to create strategy to high-probability trading opportunities. Days/weeks/months can be spent discovering the relationships between technical indicators. An efficient and less time-consuming tool, such as a decision tree, can be used. The main advantage of a decision tree is that it is a powerful and easily interpretable algorithm, which gives a good head start.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec38"/>Getting ready</h2></div></div></div><p>In order to perform naive Bayes, we will be using a dataset collected from the stock markets dataset.</p><div class="section" title="Step 1 - collecting and describing the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec97"/>Step 1 - collecting and describing the data</h3></div></div></div><p>The dataset to be used is the Apple Inc. daily closing stock value between January 1, 2012 and January 1, 2014. This dataset is freely available on <a class="ulink" href="https://www.yahoo.com/">https://www.yahoo.com/</a>, from where we will be downloading the data.</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec39"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - exploring the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec98"/>Step 2 - exploring the data</h3></div></div></div><p>The following packages need to be loaded as the first step to be carried out:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; install.packages("quantmod")</strong></span>
<span class="strong"><strong>    &gt; install.packages("lubridate")</strong></span>
<span class="strong"><strong>    &gt; install.packages("e1071")</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Version info: Code for this page was tested in R version 3.3.0 (2016-05-03)</p></div></div><p>Each of the following libraries needs to be installed:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; library("quantmod")</strong></span>
<span class="strong"><strong>    &gt; library("lubridate")</strong></span>
<span class="strong"><strong>    &gt; library("e1071")</strong></span>
</pre><p>Let's download the data. We will begin by marking the start and end date for the time period in which the data is desired.</p><p>The <code class="literal">as.Date()</code> function is used to convert the character representation and objects of the <span class="emphasis"><em>Date</em></span> class, which represents the calendar dates.</p><p>The start date for the dataset is stored in <code class="literal">startDate</code>, which represents the character vector representation of the calendar date. The format for representation is <span class="emphasis"><em>YYYY-MM-DD</em></span>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; startDate = as.Date("2012-01-01")</strong></span>
</pre><p>The end date for the dataset is stored in <code class="literal">endDate</code>, which represents the character vector representation of the calendar date. The format for representation is YYYY-MM-DD:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; endDate = as.Date("2014-01-01")</strong></span>
</pre><p>Loading the data using the <code class="literal">getSymbols()</code> function. The function loads data from multiple sources, either local or remote. Data is fetched and saved in the <code class="literal">env</code> specified. The default value is <code class="literal">.GlobalEnv</code> for <code class="literal">env</code>. <code class="literal">AAPL</code> is the character vector, which specifies the name of the symbol to be loaded. <code class="literal">src = yahoo</code> specifies the sourcing method:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; getSymbols("AAPL", env = .GlobalEnv, src = "yahoo", from = startDate,  to = endDate)</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_06_066.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>Exploring the days of the week when data is available. The <code class="literal">wday()</code> function is used. The function returns the day of the week in decimal format. <code class="literal">AAPL</code> represents the data frame. <code class="literal">label = TRUE</code> displays the day of the week as a character string, for example, Sunday. The result is then stored in the <code class="literal">weekDays</code> data frame:
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; weekDays &lt;- wday(AAPL, label=TRUE)</strong></span>
</pre><p>Printing the <code class="literal">weekDays</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">weekDays</code> data frame. The <code class="literal">weekDays</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(weekDays)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_067.jpg" alt="Step 2 - exploring the data"/></div><p>
</p></div><div class="section" title="Step 3 - preparing variables to build datasets"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec99"/>Step 3 - preparing variables to build datasets</h3></div></div></div><p>Calculating the difference between closing and opening prices. <code class="literal">Cl</code> stands for closing prices and <code class="literal">Op</code> for opening prices. The results are stored in the <code class="literal">changeInPrices</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; changeInPrices &lt;- Cl(AAPL) - Op(AAPL)</strong></span>
</pre><p>Printing the <code class="literal">changeInPrices</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">changeInPrices</code> data frame. The <code class="literal">changeInPrices</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(changeInPrices)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_068.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">changeInPrices</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(changeInPrices)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_069.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Exploring the dimensions of the <code class="literal">changeInPrices</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">changeInPrices</code> frame. The <code class="literal">changeInPrices</code> data frame is passed as an input parameter. The result clearly states that there are 502 rows of data and 1 column:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dim(changeInPrices)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_070.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Creating a binary classification variable. The <code class="literal">ifelse()</code> function uses a test expression to return the value, which is itself a vector, and is of the same length as the test expression. The vector returned has an element from <code class="literal">x</code> if the corresponding value of the test expression is <code class="literal">TRUE</code>, or from <code class="literal">y</code> if the corresponding value of the test expression is <code class="literal">FALSE</code>.</p><p>Here, <code class="literal">changeInPrices&gt;0</code> is the test function which is to test a logical mode. <code class="literal">UP</code> and <code class="literal">DOWN</code> perform the logical test. The result is then stored in the <code class="literal">binaryClassification</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; binaryClassification &lt;- ifelse(changeInPrices&gt;0,"UP","DOWN")</strong></span>
</pre><p>Displaying the <code class="literal">binaryClassification</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; binaryClassification</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_071.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">binaryClassification</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(binaryClassification)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_072.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Creating the dataset to be used. The <code class="literal">data.frame()</code> function is used to create data frames based on a tightly coupled set of variables. These variables share the properties of matrices.</p><p>The variables passed as parameters to <code class="literal">data.frame()</code> are <code class="literal">weekDays</code> and 
<code class="literal">binaryClassification</code>. The result is then stored in the <code class="literal">DataSet</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; AAPLDataSet &lt;- data.frame(weekDays,binaryClassification)</strong></span>
</pre><p>Displaying the <code class="literal">AAPLDataSet</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; AAPLDataSet</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_073.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Printing the <code class="literal">AAPLDataSet</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">AAPLDataSet</code> data frame. The <code class="literal">AAPLDataSet</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(AAPLDataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_074.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Exploring the dimensions of the <code class="literal">AAPLDataSet</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">AAPLDataSet</code> data frame. The <code class="literal">AAPLDataSet</code> data frame is passed as an input parameter. The result clearly states that there are 502 rows of data and 2 columns:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dim(AAPLDataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_075.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p></div><div class="section" title="Step 4 - building the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec100"/>Step 4 - building the model</h3></div></div></div><p>Building the naives Bayes classifier by specifying the indicators. The <code class="literal">naiveBayes()</code> function will be used. It uses the Bayes rule to compute posterior probabilities for a given set of class variables given independent predictor variables. The function assumes a Gaussian distribution of metric predictors. <code class="literal">NaiveBayesclassifier</code> is the outcome of the function, where the independent variable is <code class="literal">AAPLDataSet[,1]</code> and the dependent variable is <code class="literal">AAPLDataSet[,2]</code>
:
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; NaiveBayesclassifier &lt;- naiveBayes(AAPLDataSet[,1], AAPLDataSet[,2])</strong></span>
</pre><p>Displaying the <code class="literal">NaiveBayesclassifier</code> result:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; NaiveBayesclassifier</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_076.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>The result is over the entire dataset, and shows the probability of a price increase or decrease. It is bearish in nature.</p></div><div class="section" title="Step 5 - creating data for a new, improved model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec101"/>Step 5 - creating data for a new, improved model</h3></div></div></div><p>Developing a sophisticated strategy, looking ahead more than a day. Calculating moving average to the model for a period of 5 years. <code class="literal">EMA()</code> uses the AAPL symbol as a price series. <code class="literal">n = 5</code> represents the time period to average over. The result is then stored in the <code class="literal">exponentialMovingAverage5</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; exponentialMovingAverage5 &lt;- EMA(Op(AAPL),n = 5)</strong></span>
</pre><p>Displaying the <code class="literal">exponentialMovingAverage5</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; exponentialMovingAverage5</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_077.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>
</p><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">exponentialMovingAverage5 </code>data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(exponentialMovingAverage5)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_078.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>
</p><p>Calculating moving average to the model for a period of 10 years.</p><p>
<code class="literal">EMA()</code> uses the AAPL symbol as a price series. <code class="literal">n = 10</code> represents the time period to average over. The result is then stored in the <code class="literal">exponentialMovingAverage10</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; exponentialMovingAverage10 &lt;- EMA(Op(AAPL),n = 10)</strong></span>
</pre><p>Displaying the <code class="literal">exponentialMovingAverage10</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; exponentialMovingAverage10</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_079.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>
</p><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">exponentialMovingAverage10</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(exponentialMovingAverage10)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_080.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>
</p><p>Exploring the dimensions of the <code class="literal">exponentialMovingAverage10</code> data frame. The <code class="literal">dim() </code>function returns the dimensions of the <code class="literal">exponentialMovingAverage10</code> frame. The <code class="literal">exponentialMovingAverage10</code> data frame is passed as an input parameter. The result clearly states that there are 502 rows of data and 1 column:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dim(exponentialMovingAverage10)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_081.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>
</p><p>Calculating the difference between <code class="literal">exponentialMovingAverage5</code> and <code class="literal">exponentialMovingAverage10</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; exponentialMovingAverageDiff &lt;- exponentialMovingAverage5 - exponentialMovingAverage10</strong></span>
</pre><p>Displaying the <code class="literal">exponentialMovingAverageDiff</code> value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; exponentialMovingAverageDiff</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_082.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>
</p><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">exponentialMovingAverageDiff</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(exponentialMovingAverageDiff)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_083.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>
</p><p>Rounding off the <code class="literal">exponentialMovingAverageDiff</code> data frame to two significant digits:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; exponentialMovingAverageDiffRound &lt;- round(exponentialMovingAverageDiff, 2)</strong></span>
</pre><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">exponentialMovingAverageDiffRound</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(exponentialMovingAverageDiffRound)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_084.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>
</p></div><div class="section" title="Step 6 - improving the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec102"/>Step 6 - improving the model</h3></div></div></div><p>Creating the dataset to be used. The <code class="literal">data.frame()</code> function is used to create data frames based on a tightly coupled set of variables. These variables share the properties of matrices. The variables passed as parameters to <code class="literal">data.frame()</code> are <code class="literal">weekDays</code>, <code class="literal">exponentialMovingAverageDiffRound</code>, and <code class="literal">binaryClassification</code>. The result is then stored in the <code class="literal">AAPLDataSetNew</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; AAPLDataSetNew &lt;- data.frame(weekDays,exponentialMovingAverageDiffRound, binaryClassification) </strong></span>
</pre><p>Displaying the <code class="literal">AAPLDataSetNew </code>value:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; AAPLDataSetNew </strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_086.jpg" alt="Step 6 - improving the model"/></div><p>
</p><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">AAPLDataSetNew</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(AAPLDataSetNew)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_087.jpg" alt="Step 6 - improving the model"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; AAPLDataSetNew &lt;- AAPLDataSetNew[-c(1:10),]</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_088.jpg" alt="Step 6 - improving the model"/></div><p>
</p><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">AAPLDataSetNew</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(AAPLDataSetNew) </strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_089.jpg" alt="Step 6 - improving the model"/></div><p>
</p><p>Exploring the dimensions of the <code class="literal">AAPLDataSetNew</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">AAPLDataSetNew</code> frame. The <code class="literal">AAPLDataSetNew</code> data frame is passed as an input parameter. The result clearly states that there are 492 rows of data and 3 columns:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dim(AAPLDataSetNew)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_090.jpg" alt="Step 6 - improving the model"/></div><p>
</p><p>Building a training dataset. Two-thirds of the elements in the <code class="literal">AAPLDataSetNew</code> data frame will be used as the training dataset, while one-third of the elements in the <code class="literal">AAPLDataSetNew</code> data frame will be used as the testing dataset.</p><p>The training dataset will be stored in the <code class="literal">trainingDataSet</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; trainingDataSet &lt;- AAPLDataSetNew[1:328,] </strong></span>
</pre><p>Exploring the dimensions of the <code class="literal">trainingDataSet</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">trainingDataSet</code> data frame. The <code class="literal">trainingDataSet</code> data frame is passed as an input parameter. The result clearly states that there are 328 rows of data and 3 columns:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dim(trainingDataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_091.jpg" alt="Step 6 - improving the model"/></div><p>
</p><p>Exploring the summary of change in prices. The <code class="literal">trainingDataSet()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">trainingDataSet</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(trainingDataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_092.jpg" alt="Step 6 - improving the model"/></div><p>
</p><p>The training dataset will be stored in the <code class="literal">TestDataSet</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; TestDataSet &lt;- AAPLDataSetNew[329:492,]</strong></span>
</pre><p>Exploring the dimensions of the <code class="literal">TestDataSet</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">TestDataSet </code>frame. The <code class="literal">TestDataSet</code> data frame is passed as an input parameter. The result clearly states that there are 164 rows of data and 3 columns:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dim(TestDataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_093.jpg" alt="Step 6 - improving the model"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(TestDataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_094.jpg" alt="Step 6 - improving the model"/></div><p>
</p><p>Building the naives Bayes classifier by specifying the indicators. The <code class="literal">naiveBayes()</code> function will be used. It uses the Bayes rule to compute posterior probabilities for a given set of class variables given independent predictor variables. The function assumes a Gaussian distribution of metric predictors.</p><p>
<code class="literal">exponentialMovingAverageDiffRoundModel</code> is the outcome of the function, where the independent variable is <code class="literal">trainingDataSet[,1:2]</code> and the dependent variable is <code class="literal">trainingDataSet[,3]</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; exponentialMovingAverageDiffRoundModel &lt;-
naiveBayes(trainingDataSet[,1:2],trainingDataSet[,3])</strong></span>
</pre><p>Displaying the <code class="literal">exponentialMovingAverageDiffRoundModel</code> result:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; exponentialMovingAverageDiffRoundModel</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_095.jpg" alt="Step 6 - improving the model"/></div><p>
</p><p>Testing the result:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; table(predict(exponentialMovingAverageDiffRoundModel,TestDataSet),</strong></span>
<span class="strong"><strong>TestDataSet[,3],dnn=list('Predicted','Actual')) </strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_096.jpg" alt="Step 6 - improving the model"/></div><p>
</p></div></div></div>
<div class="section" title="Random forest - currency trading strategy"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Random forest - currency trading strategy</h1></div></div></div><p>The goal of forecasting future price trends for forex markets can be scientifically achieved after carrying out technical analysis. Forex traders develop strategies based on multiple technical analyses such as market trend, volume, range, support and resistance levels, chart patterns and indicators, as well as conducting a multiple time frame analysis using different time-frame charts. Based on statistics of past market action, such as past prices and past volume, a technical analysis strategy is created for evaluating the assets. The main goal for analysis is not to measure an asset's underlying value but to calculate future performance of markets indicated by the historical performance.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec40"/>Getting ready</h2></div></div></div><p>In order to perform random forest, we will be using a dataset collected from the US Dollar and GB Pound dataset.</p><div class="section" title="Step 1 - collecting and describing the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec103"/>Step 1 - collecting and describing the data</h3></div></div></div><p>The dataset titled <code class="literal">PoundDollar.csv</code> will be used. The dataset is in standard format. There are 5,257 rows of data and 6 variables. The numeric variables are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Date</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Open</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">High</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Low</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Close</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Volume</code></li></ul></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec41"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - exploring the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec104"/>Step 2 - exploring the data</h3></div></div></div><p>The following packages need to be loaded as the first step to be carried out:</p><pre class="programlisting">
<span class="strong"><strong>&gt; install.packages("quantmod")
&gt; install.packages("randomForest")
&gt; install.packages("Hmisc")</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>Version info: Code for this page was tested in R version 3.3.0 (2016-05-03).</p></div></div><p>Each of the following libraries needs to be installed:</p><pre class="programlisting">
<span class="strong"><strong>&gt; library("quantmod")
&gt; library("randomForest")
&gt; library("Hmisc")</strong></span>
</pre><p>Let's explore the data and understand the relationships between the variables. We'll begin by importing the CSV data file named <code class="literal">PoundDollar.csv</code>. We will be saving the data to the <code class="literal">PoundDollar</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; PoundDollar &lt;- read.csv("d:/PoundDollar.csv")</strong></span>
</pre><p>Printing the <code class="literal">PoundDollar</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">PoundDollar</code> data frame. The <code class="literal">PoundDollar</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(PoundDollar)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_097.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>Printing the summary of the <code class="literal">PoundDollar</code> data frame. The <code class="literal">summary()</code> function is a multipurpose function. <code class="literal">summary()</code> is a generic function, which provides a summary of the data related to the individual object or data frame. The <code class="literal">PoundDollar</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(PoundDollar)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_098.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>Exploring the dimensions of the <code class="literal">PoundDollar</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">PoundDollar</code> frame. The <code class="literal">PoundDollar</code> data frame is passed as an input parameter. The result clearly states that there are 5,257 rows of data and 7 columns:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dim(PoundDollar)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_099.jpg" alt="Step 2 - exploring the data"/></div><p>
</p></div><div class="section" title="Step 3 - preparing variables to build datasets"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec105"/>Step 3 - preparing variables to build datasets</h3></div></div></div><p>Representing calendar dates and times. The <code class="literal">as.POSIXlt()</code> function manipulates the objects to represent date and time. <code class="literal">PoundDollar</code> is passed as an argument. <code class="literal">format="%m/%d/%y %H:%M</code> represents the date-time format. The results are stored in the <code class="literal">DateAndTime</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; DateAndTime &lt;- as.POSIXlt(PoundDollar[,2],format="%m/%d/%y %H:%M")</strong></span>
</pre><p>Capturing the <code class="literal">High</code>, <code class="literal">Low</code>, and <code class="literal">Close</code> values:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; HighLowClose &lt;- PoundDollar[,4:6]</strong></span>
</pre><p>The <code class="literal">PoundDollar</code> data frame captures the <code class="literal">High</code>, <code class="literal">Low</code>, and <code class="literal">Close</code> values located in the fourth, fifth, and sixth columns. Printing the <code class="literal">HighLowClose</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">HighLowClose</code> data frame. The <code class="literal">HighLowClose</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(HighLowClose)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_100.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Printing the summary of the <code class="literal">HighLowClose</code> data frame. The <code class="literal">summary()</code> function is a multipurpose function. <code class="literal">summary()</code> is a generic function, which provides a summary of the data related to the individual object or data frame. The <code class="literal">HighLowClose</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(HighLowClose)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_101.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Exploring the internal structure of the <code class="literal">HighLowClose</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">HighLowClose</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; str(HighLowClose)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_102.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Creating the dataset to be used. The <code class="literal">data.frame()</code> function is used to create data frames based on a tightly coupled set of variables. These variables share the properties of matrices. The variable passed as parameter to <code class="literal">data.frame()</code> is <code class="literal">HighLowClose</code>. The result is then stored in the <code class="literal">HighLowClosets</code> data frame. <code class="literal">row.names=DateAndTime</code> represents a single integer string specifying a column to be used as row names. The result is stored in the <code class="literal">HighLowClose</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; HighLowClosets &lt;- data.frame(HighLowClose, row.names=DateAndTime) </strong></span>
</pre><p>Describing the dataset. The <code class="literal">describe()</code> function provides the item analysis. <code class="literal">HighLowClosets</code> is passed as an input argument:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; describe(HighLowClosets)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_103.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Creating time series objects. The <code class="literal">as.xts()</code> function is used. It converts the data objects of arbitrary classes to class <code class="literal">xts</code> without losing any attributes of the original format. <code class="literal">HighLowClosets</code> is passed as an input object:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; HighLowClosexts &lt;- as.xts(HighLowClosets)</strong></span>
</pre><p>Calculating the Bollinger Bands. Bollinger Bands are range-bound indicators that calculate standard deviation from the moving average. Bollinger Bands operate under the logic that a currency pair's price is most likely to gravitate toward its average, and hence when it strays too far, such as two standard deviations away, it is due to retrace back to its moving average. The <code class="literal">BBands()</code> function is used to calculate Bollinger Bands. <code class="literal">HighLowClosexts</code> is passed as an object that is changed to a matrix, which contains high-low-close prices. <code class="literal">n=20</code> indicates the number of periods for moving average. SMA names the function to be called. <code class="literal">sd=2</code> indicates two standard deviations:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; BollingerBands &lt;- BBands(HighLowClosexts,n=20,SMA,sd=2)</strong></span>
</pre><p>Describing the dataset. The <code class="literal">describe()</code> function provides item analysis. <code class="literal">BollingerBands</code> is passed as an input argument:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; describe(BollingerBands)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_104.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Building the upper band:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; Upper &lt;- BollingerBands$up - HighLowClosexts$Close</strong></span>
</pre><p>Printing the summary of the <code class="literal">Upper</code> data frame. The <code class="literal">summary()</code> function is a multipurpose function. <code class="literal">summary()</code> is a generic function, which provides a summary of the data related to the individual object or data frame. The <code class="literal">Upper</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(Upper)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_105.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Building the lower band:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; Lower &lt;- BollingerBands$dn - HighLowClosexts$Close</strong></span>
</pre><p>Printing the summary of the <code class="literal">Lower</code> data frame. The <code class="literal">summary()</code> function is a multipurpose function. <code class="literal">summary()</code> is a generic function, which provides a summary of the data related to the individual object or data frame. The Lower data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(Upper)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_106.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Building the middle band:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; Middle &lt;- BollingerBands$mavg - HighLowClosexts$Close</strong></span>
</pre><p>Printing the summary of the <code class="literal">Middle</code> data frame. The <code class="literal">summary()</code> function is a multipurpose function. <code class="literal">summary()</code> is a generic function which provides a summary of the data related to the individual object or data frame. The <code class="literal">Middle</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(Middle)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_107.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Calculating the percentage change. The <code class="literal">Delt()</code> function is used to calculate the percentage change from one period to another of a given series. <code class="literal">k=1</code> indicates the change over the periods. The result is stored in the <code class="literal">PercentageChngpctB</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; PercentageChngpctB &lt;- Delt(BollingerBands$pctB,k=1)</strong></span>
</pre><p>Describing the dataset. The <code class="literal">describe()</code> function provides item analysis. <code class="literal">PercentageChngpctB</code> is passed as an input argument:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; describe(PercentageChngpctB)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_108.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Calculating the percentage change of the <code class="literal">Upper</code> data frame. <code class="literal">k=1</code> indicates the change over the periods:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; PercentageChngUp &lt;- Delt(Upper,k=1)</strong></span>
</pre><p>Describing the dataset. The <code class="literal">describe()</code> function provides item analysis. <code class="literal">PercentageChngUp</code> is passed as an input argument:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; describe(PercentageChngUp)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_109.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Calculating the percentage change of the <code class="literal">Lower</code> data frame. <code class="literal">k=1</code> indicates the change over the periods:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; PercentageChngLow &lt;- Delt(Lower, k=1)</strong></span>
</pre><p>Describing the dataset. The <code class="literal">describe()</code> function provides item analysis. <code class="literal">PercentageChngLow</code> is passed as an input argument:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; describe(PercentageChngLow)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_110.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Calculating the percentage change of the <code class="literal">Middle</code> data frame. <code class="literal">k=1</code> indicates the change over the periods:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; PercentageChngMid &lt;- Delt(Middle,k=1)</strong></span>
</pre><p>Describing the dataset. The <code class="literal">describe()</code> function provides item analysis. <code class="literal">PercentageChngMid</code> is passed as an input argument:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; describe(PercentageChngMid)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_111.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Calculating the percentage change of the <code class="literal">HighLowClosexts$Close</code> variable. <code class="literal">k=1</code> indicates the change over the periods:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; Returns &lt;- Delt(HighLowClosexts$Close, k=1)</strong></span>
</pre></div><div class="section" title="Step 4 - building the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec106"/>Step 4 - building the model</h3></div></div></div><p>Creating a binary classification variable. The <code class="literal">ifelse()</code> function uses a test expression to return the value, which is itself a vector, and is of the same length as the test expression. The vector returned has an element from <code class="literal">x</code> if the corresponding value of the test expression is <code class="literal">TRUE</code>, or from <code class="literal">y</code> if the corresponding value of the test expression is <code class="literal">FALSE</code>.</p><p>Here, <code class="literal">Returns&gt;0</code> is the test function, which is to be tested in a logical mode. <code class="literal">UP</code> and <code class="literal">DOWN</code> perform the logical test. The result is then stored in the <code class="literal">binaryClassification</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; binaryClassification &lt;- ifelse(Returns&gt;0,"Up","Down") </strong></span>
</pre><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">binaryClassification</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(binaryClassification)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_112.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>Shifting class back one:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; ClassShifted &lt;- binaryClassification[-1]</strong></span>
</pre><p>Combining all the features. The <code class="literal">data.frame()</code> function is used to create data frames based on a tightly coupled set of variables. These variables share the properties of matrices.</p><p>The variables passed as parameters to <code class="literal">data.frame()</code> are <code class="literal">Upper</code>, <code class="literal">Lower</code>
, 
<code class="literal">Middle</code>, <code class="literal">BollingerBands$pctB</code>, <code class="literal">PercentageChngpctB</code>, <code class="literal">PercentageChngUp</code>, <code class="literal">PercentageChngLow</code>, and <code class="literal">PercentageChngMid</code>. The result is then stored in the <code class="literal">FeaturesCombined</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; FeaturesCombined &lt;- data.frame(Upper, Lower, Middle, BollingerBands$pctB, PercentageChngpctB, PercentageChngUp, PercentageChngLow, PercentageChngMid)</strong></span>
</pre><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">FeaturesCombined</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(FeaturesCombined)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_113.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>Matching the class:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; FeaturesShifted &lt;- FeaturesCombined[-5257,]</strong></span>
</pre><p>Combining the <code class="literal">FeaturesShifted</code> and <code class="literal">ClassShifted</code> data frames. The variables passed as parameters to <code class="literal">data.frame()</code> are <code class="literal">FeaturesShifted</code> and <code class="literal">ClassShifted</code>. The result is then stored in the <code class="literal">FeaturesClassData</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; FeaturesClassData &lt;- data.frame(FeaturesShifted, ClassShifted)</strong></span>
</pre><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">FeaturesClassData</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(FeaturesClassData)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_114.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>Calculated indicators being removed:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; FinalModelData &lt;- FeaturesClassData[-c(1:20),]</strong></span>
</pre><p>Naming the columns. The <code class="literal">c()</code> function is used to combine the arguments into vectors:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; colnames(FinalModelData) &lt;- c("pctB","LowDiff","UpDiff","MidDiff","PercentageChngpctB","PercentageChngUp","PercentageChngLow","PercentageChngMid","binaryClassification")</strong></span>
</pre><p>Exploring the internal structure of the <code class="literal">FinalModelData</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">FinalModelData</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; str(FinalModelData)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_115.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>Setting initial random variables:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; set.seed(1)</strong></span>
</pre><p>Evaluating the features (columns 1 to 9) using the class (column 9) to find the optimal number of features per tree. <code class="literal">FinalModelData[,-9]</code> indicates the data frame of predictor variables, and <code class="literal">FinalModelData[,9]</code> indicates the data frame of response variables. <code class="literal">ntreeTry=100</code> indicates the number of trees used at the tuning step. <code class="literal">stepFactor=1.5</code> indicates each iteration; <code class="literal">mtry</code> is inflated (or deflated) by this value, and <code class="literal">improve=0.01</code> means the (relative) improvement in out-of-bag error must be by this much for the search to continue. <code class="literal">trace=TRUE</code> indicates whether to print the progress of the search. <code class="literal">dobest=FALSE</code> means whether to run a forest using the optimal<code class="literal"> mtry</code> found:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; FeatureNumber &lt;- tuneRF(FinalModelData[,-9], FinalModelData[,9], ntreeTry=100, stepFactor=1.5, improve=0.01, trace=TRUE, plot=TRUE, dobest=FALSE)</strong></span>
</pre><p>Using all the features to predict the class, with two features per tree. The <code class="literal">randomForest()</code> function is used. <code class="literal">data=FinalModelData</code> indicates the data frame containing the variables in the model.
<code class="literal">mtry=2</code> indicates the number of variables randomly sampled as candidates at each split. <code class="literal">ntree=2000</code> indicates the number of trees to grow. <code class="literal">keep.forest=TRUE</code> indicates that the forest will be retained in the output object. <code class="literal">importance=TRUE</code> indicates the importance of predictors to be assessed:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; RandomForest &lt;- randomForest(binaryClassification~., data=FinalModelData, mtry=2,  ntree=2000, keep.forest=TRUE, importance=TRUE)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_116.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>Plotting the random forest:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; varImpPlot(RandomForest, main = 'Random Forest: Measurement of Importance of Each Feature',pch=16,col='blue' )</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_117.jpg" alt="Step 4 - building the model"/></div><p>
</p></div></div></div>
<div class="section" title="Support vector machine - currency trading strategy"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Support vector machine - currency trading strategy</h1></div></div></div><p>The forex market is an international trading market where the currencies of every country are sold and bought freely. The price of one currency determined only by market participants is driven by supply and demand. The trading is conducted through individual contracts. The standard contract size (also called a lot) is usually 100,000 units. This means that for every standard contract acquired, the control is of 100,000 units of the base currency. For this contract size, each pip (the smallest price increment) is worth $10. Depending on the trading strategy of a trader, a position can be maintained for a very short time or for longer periods, even years. There are several tools that allow the trader to be able to understand and make decisions on the market, grouped basically under fundamental or technical analysis. Fundamental analysis takes into account the constant exchange of political and economic information. Technical analysis is based essentially on prices, time, and volume--the lowest and highest prices that a currency has reached, time of period, number of transactions performed, and so on. Technical analysis also assumes the repetitiveness of the market, which it most probably will perform again in the future as it has already performed in the past. It analyzes past quotes and predicts the prices to come based on statistical and mathematical calculations.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec42"/>Getting ready</h2></div></div></div><p>In order to perform Support Vector Machine, we will be using a dataset collected from the US Dollar and GB Pound dataset.</p><div class="section" title="Step 1 - collecting and describing the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec107"/>Step 1 - collecting and describing the data</h3></div></div></div><p>The dataset titled <code class="literal">PoundDollar.csv</code> will be used. The dataset is in standard format. There are 5,257 rows of data and 6 variables. The numeric variables are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Date</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Open</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">High</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Low</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Close</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Volume</code></li></ul></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec43"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - exploring the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec108"/>Step 2 - exploring the data</h3></div></div></div><p>The following packages need to be loaded as the first step to be carried out:</p><pre class="programlisting">
<span class="strong"><strong>&gt; install.packages("quantmod")
&gt; install.packages("e1071")
&gt; install.packages("Hmisc")
&gt; install.packages("ggplot2")</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>Version info: Code for this page was tested in R version 3.3.0 (2016-05-03).</p></div></div><p>Each of the following libraries needs to be installed:</p><pre class="programlisting">
<span class="strong"><strong>&gt; library("quantmod")
&gt; library("e1071")
&gt; library("Hmisc")
&gt; install.packages("ggplot2")</strong></span>
</pre><p>Let's explore the data and understand the relationships between the variables. We'll begin by importing the CSV data file named <code class="literal">PoundDollar.csv</code>. We will be saving the data to the <code class="literal">PoundDollar</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; PoundDollar &lt;- read.csv("d:/PoundDollar.csv")</strong></span>
</pre><p>Printing the <code class="literal">PoundDollar</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">PoundDollar</code> data frame. The <code class="literal">PoundDollar</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(PoundDollar)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_118.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>Exploring the internal structure of the <code class="literal">PoundDollar</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">PoundDollar</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; str(PoundDollar)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_119.jpg" alt="Step 2 - exploring the data"/></div><p>
</p></div><div class="section" title="Step 3 - calculating the indicators"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec109"/>Step 3 - calculating the indicators</h3></div></div></div><p>The Relative Strength Index is calculated. It is a ratio of recent upward price movements to absolute price movement. The <code class="literal">RSI()</code> function is used to calculate the Relative Strength Index. The <code class="literal">PoundDollar</code> data frame is used as a price series. <code class="literal">n = 3</code> represents the number of the period for moving averages. The result is then stored in the <code class="literal">relativeStrengthIndex3</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; relativeStrengthIndex3 &lt;- RSI(Op(PoundDollar), n= 3)</strong></span>
</pre><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">relativeStrengthIndex3</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(relativeStrengthIndex3)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_120.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Calculating <span class="strong"><strong>moving averages</strong></span> (<span class="strong"><strong>MA</strong></span>) of the <code class="literal">PoundDollar</code> series. <code class="literal">SMA</code> calculates the arithmetic mean of the series over the past set of observations. <code class="literal">n=50</code> indicates the number of periods to average over:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; SeriesMeanAvg50 &lt;- SMA(Op(PoundDollar), n=50)</strong></span>
</pre><p>Printing the summary of the <code class="literal">SeriesMeanAvg50</code> data frame. The <code class="literal">summary()</code> function is a multipurpose function. <code class="literal">summary()</code> is a generic function, which provides a summary of the data related to the individual object or data frame. The <code class="literal">SeriesMeanAvg50</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(SeriesMeanAvg50)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_121.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Describing the dataset. The <code class="literal">describe()</code> function provides the item analysis. <code class="literal">SeriesMeanAvg50</code> is passed as an input argument:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; describe(SeriesMeanAvg50)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_122.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Measuring the trend. Finding the difference between opening price and the 50-period simple moving average:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; Trend &lt;- Op(PoundDollar) - SeriesMeanAvg50</strong></span>
</pre><p>Printing the summary of the <code class="literal">SeriesMeanAvg50</code> data frame. The <code class="literal">Trend</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(Trend)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_123.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Calculating the price difference between closing and opening prices. The result is stored in the data frame <code class="literal">PriceDiff</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; PriceDiff &lt;- Cl(PoundDollar) - Op(PoundDollar)</strong></span>
</pre><p>Printing the summary of the <code class="literal">PriceDiff</code> data frame. The <code class="literal">Trend</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(PriceDiff)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_124.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p></div><div class="section" title="Step 4 - preparing variables to build datasets"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec110"/>Step 4 - preparing variables to build datasets</h3></div></div></div><p>Creating a binary classification variable. The <code class="literal">ifelse()</code> function uses a test expression to return the value, which is itself a vector and is of the same length as the test expression. The vector returned has an element from <code class="literal">x</code> if the corresponding value of the test expression is <code class="literal">TRUE</code>, or from <code class="literal">y</code> if the corresponding value of the test expression is <code class="literal">FALSE</code>.</p><p>Here, <code class="literal">PriceChange&gt;0</code> is the test function, which is to be tested in a logical mode. <code class="literal">UP</code> and <code class="literal">DOWN</code> perform the logical test. The result is then stored in the <code class="literal">binaryClassification</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; binaryClassification &lt;- ifelse(PriceDiff&gt;0,"UP","DOWN")</strong></span>
</pre><p>Printing the summary of the <code class="literal">binaryClassification</code> data frame. The <code class="literal">Trend</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(binaryClassification)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_125.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Combining the relative <code class="literal">StrengthIndex3</code>, <code class="literal">Trend</code>, and <code class="literal">binaryClassification</code> data frames. The variables passed as parameters to <code class="literal">data.frame()</code> are <code class="literal">relativeStrengthIndex3</code>, <code class="literal">Trend</code>, and <code class="literal">binaryClassification</code>. The result is then stored in the <code class="literal">DataSet</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; DataSet &lt;- data.frame(relativeStrengthIndex3, Trend, binaryClassification)</strong></span>
</pre><p>Printing the summary of the <code class="literal">DataSet</code> data frame. The <code class="literal">Trend</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(DataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_126.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Exploring the internal structure of the <code class="literal">DataSet</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">DataSet</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; str(DataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_127.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Calculating the indicators, creating a dataset, and removing the points:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; DataSet &lt;- DataSet[-c(1:49),]</strong></span>
</pre><p>Exploring the dimensions of the <code class="literal">DataSet</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">DataSet</code> frame. The <code class="literal">DataSet</code> data frame is passed as an input parameter. The result clearly states that there are 5,208 rows of data and 3 columns:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dim(DataSet) </strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_128.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Separating the training dataset:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; TrainingDataSet &lt;- DataSet[1:4528,]</strong></span>
</pre><p>Exploring the dimensions of the <code class="literal">TrainingDataSet</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">TrainingDataSet</code> frame. The <code class="literal">TrainingDataSet</code> data frame is passed as an input parameter. The result clearly states that there are 4,528 rows of data and 3 columns:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dim(TrainingDataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_129.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Printing the summary of the <code class="literal">TrainingDataSet</code> data frame. The <code class="literal">TrainingDataSet</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(TrainingDataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_130.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Separating the testing dataset:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; TestDataSet &lt;- DataSet[4529:6038,]</strong></span>
</pre><p>Exploring the dimensions of the <code class="literal">TestDataSet</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">TestDataSet</code> frame. The <code class="literal">TestDataSet</code> data frame is passed as an input parameter. The result clearly states that there are 1,510 rows of data and 3 columns:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dim(TestDataSet)</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_06_131.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Printing the summary of the <code class="literal">TestDataSet</code> data frame. The <code class="literal">TestDataSet</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(TestDataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_132.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p></div><div class="section" title="Step 5 - building the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec111"/>Step 5 - building the model</h3></div></div></div><p>Building support vector machines using the <code class="literal">svm()</code> function. <code class="literal">binaryClassification~relativeStrengthIndex3+Trend</code> is used as the formula. <code class="literal">data=TrainingDataSet</code> is used as a data frame which contains the variables of the model. <code class="literal">kernel="radial"</code> means that the radial basis kernel function is used in training and predicting. <code class="literal">cost=1</code> indicates the cost of constraints violation. <code class="literal">gamma=1/2</code> indicates the parameter needed for all kernel functions except linear:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; SVM &lt;- svm(binaryClassification~relativeStrengthIndex3+Trend, data=TrainingDataSet, kernel="radial", cost=1, gamma=1/2)</strong></span>
</pre><p>Printing the summary of the <code class="literal">SVM</code> data frame. The <code class="literal">SVM</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(SVM)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_133.jpg" alt="Step 5 - building the model"/></div><p>
</p><p>In order to predict the value based on the model object, we will use the <code class="literal">predict()</code> function. <code class="literal">SVM</code> is passed as an object. The <code class="literal">TrainingDataSet</code> data object is passed as an object in which to look for variables with which to predict:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; TrainingPredictions &lt;- predict(SVM, TrainingDataSet, type="class")</strong></span>
</pre><p>Printing the summary of the <code class="literal">TrainingPredictions</code> data frame. The <code class="literal">SVM</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(TrainingPredictions)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_134.jpg" alt="Step 5 - building the model"/></div><p>
</p><p>Describing the dataset. The <code class="literal">describe()</code> function provides item analysis. <code class="literal">TrainingPredictions</code> is passed as an input argument:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; describe(TrainingPredictions)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_135.jpg" alt="Step 5 - building the model"/></div><p>
</p><p>Combining the <code class="literal">TrainingDataSet</code> and <code class="literal">TrainingPredictions</code> data frames. The variables passed as parameters to <code class="literal">data.frame()</code> are <code class="literal">TrainingDataSet</code> and <code class="literal">TrainingPredictions</code>. The result is then stored in the <code class="literal">TrainingDatadata</code> frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; TrainingData &lt;- data.frame (TrainingDataSet, TrainingPredictions)</strong></span>
</pre><p>Printing the summary of the <code class="literal">TrainingData</code> data frame. The <code class="literal">TrainingData</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; summary(TrainingData)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_136.jpg" alt="Step 5 - building the model"/></div><p>
</p><p>Printing the <code class="literal">TrainingData</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; ggplot(TrainingData,aes(x=Trend,y=relativeStrengthIndex3))    +stat_density2d(geom="contour",aes(color=TrainingPredictions))    +labs(,x="Open - SMA50",y="RSI3",color="Training Predictions")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_137.jpg" alt="Step 5 - building the model"/></div><p>
</p></div></div></div>
<div class="section" title="Stochastic gradient descent - adult income"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Stochastic gradient descent - adult income</h1></div></div></div><p>
<span class="strong"><strong>Stochastic gradient descent</strong></span> also known as <span class="strong"><strong>incremental</strong></span> gradient descent, is a stochastic approximation of the gradient descent optimization method for minimizing an objective function that is written as a sum of differentiable functions. It tries to find minima or maxima by iteration. In stochastic gradient descent, the true gradient of <span class="emphasis"><em>Q(w)</em></span> is approximated by a gradient at a single example:</p><p>
</p><div class="mediaobject"><img src="graphics/B04714_06_new.jpg" alt="Stochastic gradient descent - adult income"/></div><p>
</p><p>As the algorithm sweeps through the training set, it performs the above update for each training example. Several passes can be made over the training set until the algorithm converges. If this is done, the data can be shuffled for each pass to prevent cycles. Typical implementations may use an adaptive learning rate so that the algorithm converges.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Getting ready</h2></div></div></div><p>In order to perform stochastic gradient descent, we will be using a dataset collected from census data to predict income.</p><div class="section" title="Step 1 - collecting and describing the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec112"/>Step 1 - collecting and describing the data</h3></div></div></div><p>The dataset titled <code class="literal">adult.txt</code> will be used. The dataset is in standard format. There are 32,561 rows of data and 15 variables. The numeric variables are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">age</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">fnlwgt</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">education-num</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">capital-gain</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">capital-loss</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">hours-per-week</code></li></ul></div><p>The non-numeric variables are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">workclass</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">education</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">marital-status</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">occupation</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">relationship</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">race</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sex</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">native-country</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">incomerange</code></li></ul></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec45"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - exploring the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec113"/>Step 2 - exploring the data</h3></div></div></div><p>Each of the following libraries is required to be installed:</p><pre class="programlisting">
<span class="strong"><strong>&gt; library("klar")
&gt; library("caret")
&gt; library ("stringr")</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>Version info: Code for this page was tested in R version 3.3.0 (2016-05-03).</p></div></div><p>Let's explore the data and understand the relationships between the variables. We'll begin by importing the TXT data file named <code class="literal">adult.txt</code>. We will be saving the data to the labels data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; labels &lt;- read.csv("d:/adult.txt")</strong></span>
</pre><p>Exploring the internal structure of the <code class="literal">allData</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. <code class="literal">allData</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; str(allData)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_138.jpg" alt="Step 2 - exploring the data"/></div><p>
</p></div><div class="section" title="Step 3 - preparing the data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec114"/>Step 3 - preparing the data</h3></div></div></div><p>Grabbing the labels from the main file. The <code class="literal">as.factor()</code> function is used to encode the <code class="literal">allData[,15]</code> vector as a factor. This is to ensure format compatibility. The result is then stored in the <code class="literal">labels</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; labels &lt;- as.factor(allData[,15])</strong></span>
</pre><p>Grabbing all the features of the data after removing the labels. The result is stored in the <code class="literal">allFeatures</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; allFeatures &lt;- allData[,-c(15)]</strong></span>
</pre><p>Printing the <code class="literal">allFeatures</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">allFeatures</code> data frame. The <code class="literal">allFeatures</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(allFeatures)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_139.jpg" alt="Step 3 - preparing the data"/></div><p>
</p><p>Normalizing the features. The mean and scale are converted to <code class="literal">z</code> scores so that the <code class="literal">variance = 1</code>. <code class="literal">scale()</code> function's default method centers and/or scales the columns of a numeric matrix. <code class="literal">continuousFeatures</code> is the numeric matrix. The result is then stored in the <code class="literal">continuousFeatures</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; continuousFeatures &lt;- scale(continuousFeatures)</strong></span>
</pre><p>Printing the <code class="literal">continuousFeatures</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">continuousFeatures</code> data frame. The <code class="literal">continuousFeatures</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; head(continuousFeatures)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_140.jpg" alt="Step 3 - preparing the data"/></div><p>
</p><p>Converting labels into a <code class="literal">1</code> or <code class="literal">-1</code>. The <code class="literal">rep()</code> function is used to replicate values. The result is then stored in the <code class="literal">labels.n</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; labels.n = rep(0,length(labels))     
&gt; labels.n[labels==" &lt;=50K"] = -1     
&gt; labels.n[labels==" &gt;50K"] = 1     
&gt; labels = labels.n     
&gt; rm(labels.n)</strong></span>
</pre><p>Separating training datasets. The <code class="literal">createDataPartition()</code> function creates a set of training data partitions. <code class="literal">y=labels</code> indicates the vector for outcomes. <code class="literal">p=.8</code> means 80% of the data is used for training datasets:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; trainingData &lt;- createDataPartition(y=labels, p=.8, list=FALSE)</strong></span>
</pre><p>Exploring the dimensions of the <code class="literal">trainingData</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">trainingData</code> frame. The <code class="literal">trainingData</code> data frame is passed as an input parameter. The result clearly states that there are 26,049 rows of data and a single column:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dim(trainingData)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_141.jpg" alt="Step 3 - preparing the data"/></div><p>
</p><p>Creating training features and training labels of the <code class="literal">trainingData</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; trainingFeatures &lt;- continuousFeatures[trainingData,]     
&gt; trainingLabels &lt;- labels[trainingData]</strong></span>
</pre><p>Figuring out the remaining 20% of data for testing and validation:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; remainingLabels &lt;- labels[-trainingData]     
&gt; remainingFeatures &lt;- continuousFeatures[-trainingData,]</strong></span>
</pre><p>Creating the testing features and testing labels of the <code class="literal">trainingData</code> data frame. Of the 20% data, 50% of that data is used for testing purposes, while the remaining 50% is used for validation purposes.</p><p>The <code class="literal">createDataPartition()</code> function creates a set of training data partitions. <code class="literal">y= remainingLabels</code> indicates the vector for outcomes. <code class="literal">p=.5</code> means 50% of the data is used for training datasets. The result is then stored in the <code class="literal">testingData</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; testingData &lt;- createDataPartition(y=remainingLabels, p=.5, list=FALSE)     
&gt; testingLabels &lt;- remainingLabels[testingData]     
&gt; testingFeatures &lt;- remainingFeatures[testingData,]</strong></span>
</pre><p>Creating validation features and testing labels of the <code class="literal">testingData</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; validationLabels &lt;- remainingLabels[-testingData]</strong></span>
<span class="strong"><strong>    &gt; validationFeatures &lt;- remainingFeatures[-testingData,]</strong></span>
</pre><p>Defining the accuracy measure required:</p><pre class="programlisting">
<span class="strong"><strong>&gt; getAccuracy &gt;- function(a,b,features,labels){
+ estFxn = features %*% a + b;
+ predictedLabels = rep(0,length(labels));
+ predictedLabels [estFxn &lt; 0] = -1 ;
+ predictedLabels [estFxn &gt;= 0] = 1 ;
+ return(sum(predictedLabels == labels) / length(labels))
+ }</strong></span>
</pre></div><div class="section" title="Step 4 - building the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec115"/>Step 4 - building the model</h3></div></div></div><p>Setting up the initial parameters:</p><pre class="programlisting">
<span class="strong"><strong>&gt; numEpochs = 100
&gt; numStepsPerEpoch = 500
&gt; nStepsPerPlot = 30
&gt; evalidationSetSize = 50
&gt; c1 = 0.01
&gt; c2 = 50</strong></span>
</pre><p>Combining a set of arguments. The result is stored in the <code class="literal">lambda_vals</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; lambda_vals = c(0.001, 0.01, 0.1, 1)     
&gt; bestAccuracy = 0</strong></span>
</pre><p>Exploring the internal structure of the <code class="literal">lambda_vals</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">lambda_vals</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; str(lambda_vals)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_142.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>Creating a matrix for each epoch from a given set of values. The <code class="literal">matrix()</code> function is used. <code class="literal">nrow = (numStepsPerEpoch/nStepsPerPlot)*numEpochs+1</code> denotes the number of rows of the matrix, and <code class="literal">ncol = length(lambda_vals)</code> denotes the number of columns of the matrix:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; accMat &lt;- matrix(NA, nrow = (numStepsPerEpoch/nStepsPerPlot)*numEpochs+1, ncol = length(lambda_vals))</strong></span>
</pre><p>Creating a matrix for accuracy on a validation set from a given set of values. The <code class="literal">matrix()</code> function is used. <code class="literal">nrow = (numStepsPerEpoch/nStepsPerPlot)*numEpochs+1</code> denotes the number of rows of the matrix, and <code class="literal">ncol = length(lambda_vals)</code> denotes the number of columns of the matrix:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; accMatv &lt;- matrix(NA, nrow = (numStepsPerEpoch/nStepsPerPlot)*numEpochs+1, ncol = length(lambda_vals))</strong></span>
</pre><p>Setting up the classifier model:</p><pre class="programlisting">
<span class="strong"><strong>    for(i in 1:4){ </strong></span>
<span class="strong"><strong>      lambda = lambda_vals[i] </strong></span>
<span class="strong"><strong>      accMatRow = 1 </strong></span>
<span class="strong"><strong>      accMatCol = i </strong></span>
<span class="strong"><strong>      a = rep(0,ncol(continuousFeatures)) </strong></span>
<span class="strong"><strong>      b = 0 </strong></span>
<span class="strong"><strong>      stepIndex = 0 </strong></span>
<span class="strong"><strong>       for (e in 1:numEpochs){</strong></span>
</pre><p>The <code class="literal">#createDataPartition()</code> function creates a set of training data partitions. <code class="literal">y= trainingLabels</code> indicates the vector for outcomes. <code class="literal">p = (1 - evalidationSetSize/length(trainingLabels))</code> % of data is used for training datasets. The result is then stored in the <code class="literal">etrainingData</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>etrainingData &lt;- createDataPartition(y=trainingLabels, p=(1 -   evalidationSetSize/length(trainingLabels)), list=FALSE) </strong></span>
<span class="strong"><strong> etrainingFeatures &lt;- trainingFeatures[etrainingData,] </strong></span>
<span class="strong"><strong> etrainingLabels &lt;- trainingLabels[etrainingData] </strong></span>
<span class="strong"><strong> evalidationFeatures &lt;- trainingFeatures[-etrainingData,] </strong></span>
<span class="strong"><strong> evalidationLabels &lt;- trainingLabels[-etrainingData] </strong></span>
<span class="strong"><strong> steplength = 1 / (e*c1 + c2) </strong></span>
<span class="strong"><strong>    for (step in 1:numStepsPerEpoch){ </strong></span>
<span class="strong"><strong>      stepIndex = stepIndex+1 </strong></span>
<span class="strong"><strong>      index = sample.int(nrow(etrainingFeatures),1) </strong></span>
<span class="strong"><strong>      xk = etrainingFeatures[index,] </strong></span>
<span class="strong"><strong>      yk = etrainingLabels[index] </strong></span>
<span class="strong"><strong>       costfxn = yk * (a %*% xk + b) </strong></span>
<span class="strong"><strong>       if(costfxn &gt;= 1){ </strong></span>
<span class="strong"><strong>        a_dir = lambda * a </strong></span>
<span class="strong"><strong>        a = a - steplength * a_dir </strong></span>
<span class="strong"><strong>      } else { </strong></span>
<span class="strong"><strong>        a_dir = (lambda * a) - (yk * xk) </strong></span>
<span class="strong"><strong>        a = a - steplength * a_dir </strong></span>
<span class="strong"><strong>        b_dir = -yk </strong></span>
<span class="strong"><strong>        b = b - (steplength * b_dir) </strong></span>
<span class="strong"><strong>      } </strong></span>
</pre><p>Logging in the accuracy. <code class="literal">getAccuracy()</code> is called:</p><pre class="programlisting">
<span class="strong"><strong>    if (stepIndex %% nStepsPerPlot == 1){#30){ </strong></span>
<span class="strong"><strong>    accMat[accMatRow,accMatCol] = getAccuracy(a,b,evalidationFeatures,evalidationLabels) </strong></span>
<span class="strong"><strong>    accMatv[accMatRow,accMatCol] = getAccuracy(a,b,validationFeatures,validationLabels) </strong></span>
<span class="strong"><strong>    accMatRow = accMatRow + 1 </strong></span>
<span class="strong"><strong>    } </strong></span>
<span class="strong"><strong>    } </strong></span>
<span class="strong"><strong>    } </strong></span>
<span class="strong"><strong>    tempAccuracy = getAccuracy(a,b,validationFeatures,validationLabels) </strong></span>
<span class="strong"><strong>    print(str_c("tempAcc = ", tempAccuracy," and bestAcc = ", bestAccuracy) ) </strong></span>
<span class="strong"><strong>    if(tempAccuracy &gt; bestAccuracy){ </strong></span>
<span class="strong"><strong>    bestAccuracy = tempAccuracy </strong></span>
<span class="strong"><strong>    best_a = a </strong></span>
<span class="strong"><strong>    best_b = b </strong></span>
<span class="strong"><strong>    best_lambdaIndex = i </strong></span>
<span class="strong"><strong>    } </strong></span>
<span class="strong"><strong>   }</strong></span>
</pre><p>Calculating the accuracy of the model. <code class="literal">getAccuracy()</code>, as defined previously, is used:</p><pre class="programlisting">
<span class="strong"><strong>   &gt; getAccuracy(best_a,best_b, testingFeatures, testingLabels)</strong></span>
</pre></div><div class="section" title="Step 5 - plotting the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec116"/>Step 5 - plotting the model</h3></div></div></div><p>Plotting the accuracy of the model during training. The <code class="literal">c()</code> function is used to combine the arguments into vectors:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; colors = c("red","blue","green","black")</strong></span>
</pre><p>Setting the vectors to be used in the graph:</p><pre class="programlisting">
<span class="strong"><strong>&gt; xaxislabel = "Step"
&gt; yaxislabels = c("Accuracy on Randomized Epoch Validation
Set","Accuracy on Validation Set")
&gt;
&gt; ylims=c(0,1)
&gt; stepValues = seq(1,15000,length=500)</strong></span>
</pre><p>Creating a generic vector. <code class="literal">list()</code> is called, which concatenates the <code class="literal">accMat</code> and <code class="literal">accMatv</code> data frames:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; mats =  list(accMat,accMatv)</strong></span>
</pre><p>Plotting the graph:</p><pre class="programlisting">
<span class="strong"><strong>&gt; for(j in 1:length(mats)){
mat = mats[[j]]
for(i in 1:4){
if(i == 1){</strong></span>
</pre><p>The <code class="literal"># plot()</code> function is a generic function for plotting R objects. The <code class="literal">stepValues</code> data frame is passed as a function value:</p><pre class="programlisting">
<span class="strong"><strong>
    plot(stepValues, mat[1:500,i], type = "l",xlim=c(0, 15000), ylim=ylims,
</strong></span>
<span class="strong"><strong>
         col=colors[i],xlab=xaxislabel,ylab=yaxislabels[j],main=title)
</strong></span>
<span class="strong"><strong>
    } else{
</strong></span>
<span class="strong"><strong>
      lines(stepValues, mat[1:500,i], type = "l",xlim=c(0, 15000), ylim=ylims,
</strong></span>
<span class="strong"><strong>
          col=colors[i],xlab=xaxislabel,ylab=yaxislabels[j],main=title)
</strong></span>
<span class="strong"><strong>
    }
</strong></span>
<span class="strong"><strong>
   Sys.sleep(1)
</strong></span>
<span class="strong"><strong>
  }
</strong></span>
<span class="strong"><strong>
  legend(x=10000,y=.5,legend=c("lambda=.001","lambda=.01","lambda=.1","lambda=1"),fill=colors)
</strong></span>
<span class="strong"><strong>
}
</strong></span>
</pre><p>The resulting graph will look like the following:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_143.jpg" alt="Step 5 - plotting the model"/></div><p>
</p></div></div></div></body></html>