["```py\nimport numpy as np \nimport matplotlib.pyplot as plt \nimport cv2 \n# With jupyter notebook uncomment below line \n# %matplotlib inline \n# This plots figures inside the notebook\n\n```", "```py\n# read an image \nimg = cv2.imread('flower.png')\n\n```", "```py\ndef plot_cv_img(input_image):     \n    \"\"\"     \n    Converts an image from BGR to RGB and plots     \n    \"\"\"   \n    # change color channels order for matplotlib     \n    plt.imshow(cv2.cvtColor(input_image, cv2.COLOR_BGR2RGB))          \n\n    # For easier view, turn off axis around image     \n    plt.axis('off')  \n    plt.show()\n\n```", "```py\nplot_cv_img(img[100:400, 100:400]) \n```", "```py\n# read an image \nimg = cv2.imread('gray_flower.png')\n```", "```py\n# converts rgb image to grayscale \ngray_output = cv2.cvtColor(color_input, cv2.COLOR_BGR2GRAY)\n```", "```py\ndef plot_cv_img(input_image,is_gray=False): \n    \"\"\" \n    Takes in image with flag showing, if gray or not\n    Plots image using matplotlib\n    \"\"\" \n    # change color channels order for matplotlib \n    if not is_gray:\n        plt.imshow(cv2.cvtColor(input_image, cv2.COLOR_BGR2RGB))\n    else:\n        plt.imshow(input_image, cmap='gray')\n\n    # For easier view, turn off axis around image \n    plt.axis('off')\n    plt.show()\n```", "```py\n# read the image\nflower = cv2.imread('../figures/flower.png')\n\n# convert to gray scale \ngray_flower = cv2.cvtColor(flower, cv2.COLOR_BGR2GRAY)\n\n# take out a patch of pixels\npatch_gray = gray_flower[250:260, 250:260]\n\n#plot the patch as well as print the values \nplot_cv_img(patch_gray, is_gray=True)\nprint(patch_gray)\n```", "```py\n[[142 147 150 154 164 113  39  40  39  38]\n [146 145 148 152 156  78  42  41  40  40]\n [147 148 147 147 143  62  42  42  44  44]\n [155 148 147 145 142  91  42  44  43  44]\n [156 154 149 147 143 113  43  42  42  48]\n [155 157 152 149 149 133  68  45  47  50]\n [155 154 155 150 152 145  94  48  48  48]\n [152 151 153 151 152 146 106  51  50  47]\n [155 157 152 150 153 145 112  50  49  49]\n [156 154 152 151 149 147 115  49  52  52]]\n```", "```py\n# initialize noise image with zeros\nnoise = np.zeros((400, 600))\n\n# fill the image with random numbers in given range\ncv2.randu(noise, 0, 256)\n```", "```py\n# add noise to existing image \nnoisy_gray = gray + np.array(0.2*noise, dtype=np.int)\n```", "```py\nimport numpy as np \nimport matplotlib.pyplot as plt \nimport cv2 \n\ndef point_operation(img, K, L):\n    \"\"\"\n    Applies point operation to given grayscale image\n    \"\"\"\n    img = np.asarray(img, dtype=np.float)\n    img = img*K + L\n    # clip pixel values\n    img[img > 255] = 255 \n    img[img < 0] = 0\n    return np.asarray(img, dtype = np.int)\n\ndef main():\n    # read an image \n    img = cv2.imread('../figures/flower.png')\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    # k = 0.5, l = 0\n    out1 = point_operation(gray, 0.5, 0)\n\n    # k = 1., l = 10\n    out2 = point_operation(gray, 1., 10)\n\n    # k = 0.8, l = 15\n    out3 = point_operation(gray, 0.7, 25)\n\n    res = np.hstack([gray,out1, out2, out3])\n    plt.imshow(res, cmap='gray')\n    plt.axis('off')\n\n    plt.show()\n\nif __name__ == '__main__':\n    main()\n```", "```py\n# design a kernel matrix, here is uniform 5x5\nkernel = np.ones((5,5),np.float32)/25\n\n# apply on the input image, here grayscale  input\ndst = cv2.filter2D(gray,-1,kernel)\n```", "```py\ndef plot_cv_img(input_image, output_image): \n    \"\"\" \n    Converts an image from BGR to RGB and plots \n    \"\"\" \n\n    fig, ax = plt.subplots(nrows=1, ncols=2)\n\n    ax[0].imshow(cv2.cvtColor(input_image, cv2.COLOR_BGR2RGB)) \n    ax[0].set_title('Input Image')\n    ax[0].axis('off')\n\n    ax[1].imshow(cv2.cvtColor(output_image, cv2.COLOR_BGR2RGB)) \n    ax[1].set_title('Box Filter (5,5)')\n    ax[1].axis('off') \n    plt.show()\n\ndef main():\n    # read an image \n    img = cv2.imread('../figures/flower.png')\n\n    # To try different kernel, change size here.  \n    kernel_size = (5,5)\n\n    # opencv has implementation for kernel based box blurring\n    blur = cv2.blur(img,kernel_size)\n\n    # Do plot\n    plot_cv_img(img, blur)\n\nif __name__ == '__main__':\n    main()\n```", "```py\ndef plot_cv_img(input_image, output_image): \n    \"\"\" \n    Converts an image from BGR to RGB and plots \n    \"\"\" \n    fig, ax = plt.subplots(nrows=1, ncols=2)\n\n    ax[0].imshow(cv2.cvtColor(input_image, cv2.COLOR_BGR2RGB)) \n    ax[0].set_title('Input Image')\n    ax[0].axis('off')\n\n    ax[1].imshow(cv2.cvtColor(output_image, cv2.COLOR_BGR2RGB)) \n    ax[1].set_title('Gaussian Blurred')\n    ax[1].axis('off')\n    plt.show()\n\ndef main():\n    # read an image \n    img = cv2.imread('../figures/flower.png')\n\n    # apply gaussian blur,\n\n    # kernel of size 5x5, \n    # change here for other sizes \n    kernel_size = (5,5)\n    # sigma values are same in both direction \n    blur = cv2.GaussianBlur(img,(5,5),0)\n\n    plot_cv_img(img, blur)\n\nif __name__ == '__main__':\n    main()\n```", "```py\ndef plot_gray(input_image, output_image): \n    \"\"\" \n    Converts an image from BGR to RGB and plots \n    \"\"\" \n    # change color channels order for matplotlib \n    fig, ax = plt.subplots(nrows=1, ncols=2)\n\n    ax[0].imshow(input_image, cmap='gray') \n    ax[0].set_title('Input Image')\n    ax[0].axis('off')\n\n    ax[1].imshow(output_image, cmap='gray') \n    ax[1].set_title('Histogram Equalized ')\n    ax[1].axis('off') \n\n    plt.savefig('../figures/03_histogram_equalized.png')\n\n    plt.show()\n\ndef main():\n    # read an image \n    img = cv2.imread('../figures/flower.png')\n\n    # grayscale image is used for equalization\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    # following function performs equalization on input image     \n    equ = cv2.equalizeHist(gray)\n\n    # for visualizing input and output side by side\n    plot_gray(gray, equ)\n\nif __name__ == '__main__':\n    main()\n```", "```py\n# read the image\nflower = cv2.imread('../figures/flower.png')\n\n# initialize noise image with zeros\nnoise = np.zeros(flower.shape[:2])\n\n# fill the image with random numbers in given range\ncv2.randu(noise, 0, 256)\n\n# add noise to existing image, apply channel wise\nnoise_factor = 0.1\nnoisy_flower = np.zeros(flower.shape)\nfor i in range(flower.shape[2]):\n    noisy_flower[:,:,i] = flower[:,:,i] + np.array(noise_factor*noise, dtype=np.int)\n\n# convert data type for use\nnoisy_flower = np.asarray(noisy_flower, dtype=np.uint8)\n```", "```py\n# apply median filter of kernel size 5\nkernel_5 = 5\nmedian_5 = cv2.medianBlur(noisy_flower,kernel_5)\n\n# apply median filter of kernel size 3\nkernel_3 = 3\nmedian_3 = cv2.medianBlur(noisy_flower,kernel_3)\n```", "```py\ndef plot_cv_img(input_image, output_image1, output_image2, output_image3): \n    \"\"\" \n    Converts an image from BGR to RGB and plots \n    \"\"\" \n\n    fig, ax = plt.subplots(nrows=1, ncols=4)\n\n    ax[0].imshow(cv2.cvtColor(input_image, cv2.COLOR_BGR2RGB)) \n    ax[0].set_title('Input Image')\n    ax[0].axis('off')\n\n    ax[1].imshow(cv2.cvtColor(output_image1, cv2.COLOR_BGR2RGB)) \n    ax[1].set_title('Median Filter (3,3)')\n    ax[1].axis('off')\n\n    ax[2].imshow(cv2.cvtColor(output_image2, cv2.COLOR_BGR2RGB)) \n    ax[2].set_title('Median Filter (5,5)')\n    ax[2].axis('off') \n\n    ax[3].imshow(cv2.cvtColor(output_image3, cv2.COLOR_BGR2RGB)) \n    ax[3].set_title('Median Filter (7,7)')\n    ax[3].axis('off')\n\n    plt.show()\n\ndef main():\n    # read an image \n    img = cv2.imread('../figures/flower.png')\n\n    # compute median filtered image varying kernel size\n    median1 = cv2.medianBlur(img,3)\n    median2 = cv2.medianBlur(img,5)\n    median3 = cv2.medianBlur(img,7)\n\n    # Do plot\n    plot_cv_img(img, median1, median2, median3)\n\nif __name__ == '__main__':\n    main()\n```", "```py\n# sobel \nx_sobel = cv2.Sobel(img,cv2.CV_64F,1,0,ksize=5)\ny_sobel = cv2.Sobel(img,cv2.CV_64F,0,1,ksize=5)\n\n# laplacian\nlapl = cv2.Laplacian(img,cv2.CV_64F, ksize=5)\n\n# gaussian blur\nblur = cv2.GaussianBlur(img,(5,5),0)\n# laplacian of gaussian\nlog = cv2.Laplacian(blur,cv2.CV_64F, ksize=5)\n```", "```py\n# input shape\nw, h = flower.shape[1], flower.shape[0]\n\n# create translation matrix\ntx = w/2 # half of width\nty = h/2 # half of height\ntranslation_matrix = np.float32([[1,0,tx],\n                                 [0,1,ty]])\n\n# apply translation operation using warp affine function. \noutput_size = (w*2,h*2)\ntranslated_flower = cv2.warpAffine(flower, translation_matrix, output_size)\n```", "```py\n# input shape\nw, h = flower.shape[1], flower.shape[0]\n\n# create rotation matrix\nrot_angle = 90 # in degrees\nscale = 1 # keep the size same\nrotation_matrix = cv2.getRotationMatrix2D((w/2,h/2),rot_angle,1)\n\n# apply rotation using warpAffine \noutput_size = (w*2,h*2)\nrotated_flower = cv2.warpAffine(flower,rotation_matrix,output_size)\n```", "```py\n# create transformation matrix form preselected points\npts1 = np.float32([[50,50],[200,50],[50,200]])\npts2 = np.float32([[10,100],[200,50],[100,250]])\n\naffine_tr = cv2.getAffineTransform(pts1,pts2)\ntransformed = cv2.warpAffine(img, affine_tr, (img.shape[1]*2,img.shape[0]*2))\n```", "```py\n# downsample image by halving both width and height\n# input:(h, w) --> output:(h/2, w/2)\nlower_resolution_img = cv2.pyrDown(img)\n```", "```py\n# Upsamples image by doubling both width and height\n# input:(h, w) --> output:(h*2, w*2)\nhigher_resolution_img = cv2.pyrUp(img)\n```"]