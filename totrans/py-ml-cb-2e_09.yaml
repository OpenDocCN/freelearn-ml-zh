- en: Dissecting Time Series and Sequential Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构时间序列和顺序数据
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Transforming data into a time series format
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据转换为时间序列格式
- en: Slicing time series data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切分时间序列数据
- en: Operating on time series data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对时间序列数据进行操作
- en: Extracting statistics from time series data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从时间序列数据中提取统计数据
- en: Building HMMs for sequential data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为顺序数据构建HMM
- en: Building CRFs for sequential text data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为顺序文本数据构建CRF
- en: Analyzing stock market data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析股票市场数据
- en: Using RNNs to predict time series data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RNN预测时间序列数据
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To address the recipes in this chapter, you need the following files (available
    on GitHub):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理本章中的食谱，你需要以下文件（可在GitHub上找到）：
- en: '`convert_to_timeseries.py`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convert_to_timeseries.py`'
- en: '`data_timeseries.txt`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data_timeseries.txt`'
- en: '`slicing_data.py`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slicing_data.py`'
- en: '`operating_on_data.py`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operating_on_data.py`'
- en: '`extract_stats.py`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extract_stats.py`'
- en: '`hmm.py`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hmm.py`'
- en: '`` `data_hmm.txt` ``'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `data_hmm.txt` ``'
- en: '`crf.py`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crf.py`'
- en: '`AmazonStock.py`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AmazonStock.py`'
- en: '`AMZN.csv`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AMZN.csv`'
- en: '`LSTMstock.py`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LSTMstock.py`'
- en: Introducing time series
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍时间序列
- en: Time series data is basically a sequence of measurements that are collected
    over time. These measurements are taken with respect to a predetermined variable
    and at regular time intervals. One of the main characteristics of time series
    data is that the ordering matters!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列数据基本上是一系列随时间收集的测量值。这些测量值是在预定变量和固定时间间隔下进行的。时间序列数据的一个主要特征是顺序很重要！
- en: The list of observations that we collect is ordered on a timeline, and the order
    in which they appear says a lot about underlying patterns. If you change the order,
    this would totally change the meaning of the data. Sequential data is a generalized
    notion that encompasses any data that comes in a sequential form, including time
    series data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收集的观察结果列表按时间线排序，它们出现的顺序在很大程度上揭示了潜在的规律。如果你改变顺序，这将会完全改变数据的意义。顺序数据是一个广义的概念，包括任何以顺序形式出现的数据，包括时间序列数据。
- en: Our objective here is to build a model that describes the pattern of the time
    series or any sequence in general. Such models are used to describe important
    features of the time series pattern. We can use these models to explain how the
    past might affect the future. We can also use them to see how two datasets can
    be correlated, to forecast future values, or to control a given variable that
    is based on some metric.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是构建一个描述时间序列或任何一般序列模式的模型。这些模型用于描述时间序列模式的重要特征。我们可以使用这些模型来解释过去如何影响未来。我们还可以使用它们来查看两个数据集如何相关联，预测未来的值，或者控制基于某些指标的给定变量。
- en: To visualize time series data, we tend to plot it using line charts or bar graphs.
    Time series data analysis is frequently used in finance, signal processing, weather
    prediction, trajectory forecasting, predicting earthquakes, or any field where
    we have to deal with temporal data. The models that we build in time series and
    sequential data analysis should take into account the ordering of data and extract
    the relationships among neighbors. Let's go ahead and check out a few recipes
    to analyze time series and sequential data in Python.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化时间序列数据，我们倾向于使用折线图或条形图来绘制。时间序列数据分析常用于金融、信号处理、天气预报、轨迹预测、预测地震或任何需要处理时间数据的领域。我们在时间序列和顺序数据分析中构建的模型应考虑数据的顺序并提取邻居之间的关系。让我们继续查看一些食谱，以分析Python中的时间序列和顺序数据。
- en: Transforming data into a time series format
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据转换为时间序列格式
- en: A **time series** constitutes a sequence of observations of a phenomenon that's
    carried out in consecutive instants or time intervals that are usually, even if
    not necessarily, evenly spaced or of the same length. It follows that time is
    a fundamental parameter in the analysis of a time series. To start, we must therefore
    acquire a certain confidence in manipulating data that represents a long-term
    observation of a certain phenomenon.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间序列**构成了一系列现象的观察结果，这些观察是在连续的瞬间或时间间隔内进行的，通常（即使不是必然的）是均匀分布或长度相同。因此，时间是时间序列分析中的一个基本参数。因此，我们首先必须对代表某种现象长期观察的数据进行操作有一定的信心。'
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start by understanding how to convert a sequence of observations into
    time series data and visualize it. We will use a library called `pandas` to analyze
    time series data. Make sure that you install `pandas` before you proceed further.
    You can find the installation instructions for `pandas` at the following link: [http://pandas.pydata.org/pandas-docs/stable/install.html](http://pandas.pydata.org/pandas-docs/stable/install.html).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解如何将一系列观察结果转换为时间序列数据并可视化它。我们将使用一个名为`pandas`的库来分析时间序列数据。在继续之前，请确保你已经安装了`pandas`。你可以在以下链接找到`pandas`的安装说明：[http://pandas.pydata.org/pandas-docs/stable/install.html](http://pandas.pydata.org/pandas-docs/stable/install.html)。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how we can transform data into a time series format:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将数据转换为时间序列格式：
- en: 'Create a new Python file (the full code is given in the `convert_to_timeseries.py` file
    that is provided for you) and import the following packages:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件（完整的代码在提供的`convert_to_timeseries.py`文件中），并导入以下包：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s define a function that reads an input file and converts sequential observations
    into time-indexed data:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个函数，该函数读取输入文件并将顺序观察结果转换为时间索引数据：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will use a text file consisting of four columns. The first column denotes
    the year, the second column denotes the month, and the third and fourth columns
    denote data. Let''s load this into a NumPy array:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个包含四个列的文本文件。第一列表示年份，第二列表示月份，第三和第四列表示数据。让我们将其加载到一个NumPy数组中：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As this is arranged chronologically, the first row contains the start date
    and the last row contains the end date. Let''s extract the start and end dates
    of this dataset:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是按时间顺序排列的，第一行包含开始日期，最后一行包含结束日期。让我们提取这个数据集的开始和结束日期：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is also a `verbose` mode for this function. So, if this is set to `true`, it
    will print a few things. Let''s print out the start and end dates:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数还有一个`verbose`模式。因此，如果将其设置为`true`，它将打印一些信息。让我们打印出开始和结束日期：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s create a `pandas` variable, which contains the date sequence with monthly
    intervals:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个包含每月间隔日期序列的`pandas`变量：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our next step is to convert the given column into time series data. You can
    access this data using the month and the year (as opposed to the index):'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的下一步是将给定的列转换为时间序列数据。你可以使用月份和年份（而不是索引）来访问此数据：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use the `verbose` mode to print out the first 10 elements:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`verbose`模式打印出前10个元素：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Return the time-indexed variable, as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回时间索引变量，如下所示：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define the main function, as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义主函数，如下所示：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will use the `data_timeseries.txt` file that is already provided to you:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用已经提供给你的`data_timeseries.txt`文件：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Load the third column from this text file and convert it into time series data:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个文本文件中加载第三列并将其转换为时间序列数据：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `pandas` library provides a nice plotting function that you can run directly
    on the variable:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pandas`库提供了一个很好的绘图函数，可以直接在变量上运行：'
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you run the code, you will see the following output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行代码，你将看到以下输出：
- en: '![](img/940ee777-eb54-4832-b1c5-f6c2fcdbbb17.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/940ee777-eb54-4832-b1c5-f6c2fcdbbb17.png)'
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we learned how to convert a sequence of observations into time
    series data and display it. To do this, we first loaded the input file in a `.txt`
    format, so we extracted the start and end dates. Then, we created a sequence of
    dates with monthly intervals and converted the data into time series data. Finally,
    we plotted the time series data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们学习了如何将一系列观察结果转换为时间序列数据并显示它。为此，我们首先以`.txt`格式加载了输入文件，因此我们提取了开始和结束日期。然后，我们创建了一个按月间隔的日期序列，并将数据转换为时间序列数据。最后，我们绘制了时间序列数据。
- en: There's more…
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `pandas` library is particularly suitable for working with time series data
    for all domains, thanks to the extensive capabilities and features it has. These
    features take advantage of the NumPy `datetime64` and `timedelta64` variables, and
    a large number of functionality from other Python libraries such as `scikits.timeseries.`
    These features have made `pandas` particularly efficient for manipulating time
    series data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`库特别适合处理所有领域的时间序列数据，这得益于其广泛的特性和功能。这些特性利用了NumPy的`datetime64`和`timedelta64`变量，以及来自其他Python库（如`scikits.timeseries`）的大量功能。这些特性使得`pandas`在处理时间序列数据时特别高效。'
- en: See also
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Refer to the official documentation of the `pandas` time series and date functionality:
    [https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考官方的 `pandas` 时间序列和日期功能文档：[https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html)
- en: '*Time Series Basics* (from The Pennsylvania State University): [https://newonlinecourses.science.psu.edu/stat510/node/41/](https://newonlinecourses.science.psu.edu/stat510/node/41/)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*时间序列基础*（来自宾夕法尼亚州立大学）: [https://newonlinecourses.science.psu.edu/stat510/node/41/](https://newonlinecourses.science.psu.edu/stat510/node/41/)'
- en: Slicing time series data
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片时间序列数据
- en: '**Slice** and **dice** are two terms that refer to a dataset meaning to divide
    a large DataFrame into smaller parts or examine them from different points of
    view to understand it better. The term comes from culinary jargon and describes
    two types of knife skills that every chef has to master. To slice means to cut,
    while to dice means to cut food into very small and uniform sections, and the
    two actions are often performed in sequence. In data analysis, the term **slice
    and dice** generally involves a systematic reduction of a large dataset into smaller
    parts to extract more information.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**切片**和**切块**是两个指代数据集的术语，意味着将大的 DataFrame 划分成更小的部分或从不同的角度检查它们以更好地理解。这个术语来自烹饪术语，描述了每个厨师都必须掌握的两种刀工。切片意味着切割，而切块意味着将食物切成非常小且均匀的部分，这两个动作通常按顺序执行。在数据分析中，**切片和切块**术语通常涉及系统地减少大型数据集以提取更多信息。'
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will learn how to slice time series data. This will help
    you extract information from various intervals in the time series data. We will
    learn how to use dates to handle subsets of our data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何切片时间序列数据。这将帮助你从时间序列数据的不同区间中提取信息。我们将学习如何使用日期来处理我们数据的子集。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how we can perform slicing time series data:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何执行切片时间序列数据：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `slicing_data.py` file that is provided for you):'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Python 文件并导入以下包（完整的代码在提供的 `slicing_data.py` 文件中给出）：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `convert_to_timeseries` is the function we defined in the previous recipe *Transforming
    data into a time series format*, that reads an input file and converts sequential
    observations into time-indexed data.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`convert_to_timeseries` 是我们在前一个菜谱 *将数据转换成时间序列格式* 中定义的函数，它读取输入文件并将顺序观测值转换为时间索引数据。
- en: 'We will use the same text file that we used in the previous recipe (`data_timeseries.txt`)
    to slice and dice the data:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用与前一个菜谱中相同的文本文件（`data_timeseries.txt`）来切片和切块数据：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will extract only the third column:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将只提取第三列：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s assume that we want to extract the data between the given `start` and
    `end` years. Let''s define these, as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们想要提取给定 `start` 和 `end` 年份之间的数据。让我们定义如下：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Plot the data between the given year range:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在给定的年份范围内绘制数据：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can also slice the data based on a certain range of months:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以根据一定的月份范围来切片数据：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Plot the data, as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式绘制数据：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you run the code, you will see the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行代码，你会看到以下截图：
- en: '![](img/fb612a80-360f-4836-8904-92fa1215cb67.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb612a80-360f-4836-8904-92fa1215cb67.png)'
- en: 'The following screenshot displays a smaller time frame; hence, it looks as
    if we have zoomed into it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个较小的时间框架；因此，它看起来像是我们将其放大了：
- en: '![](img/99f7bdeb-2652-4ff9-b62a-c46bf625924d.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99f7bdeb-2652-4ff9-b62a-c46bf625924d.png)'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we learned how to break up time series data. First, we imported
    the data contained in a `.txt` file. This data was transformed into a time series
    format using a function that we defined in the previous recipe. Thus, we have
    plotted the data, first within a certain period of years, and then within a certain
    range of dates.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们学习了如何分解时间序列数据。首先，我们导入了包含在 `.txt` 文件中的数据。这些数据使用我们在前一个菜谱中定义的函数转换成了时间序列格式。因此，我们首先在一定的年份范围内绘制了数据，然后在一定的日期范围内绘制了数据。
- en: There's more…
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: To transform data into a time series format, the `pandas` library was used.
    This library is particularly efficient for manipulating time series data.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据转换成时间序列格式，我们使用了 `pandas` 库。这个库在处理时间序列数据方面特别高效。
- en: See also
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: Refer to the official documentation of the pandas time series and date functionality: [https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考 pandas 时间序列和日期功能的官方文档：[https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html)
- en: '*Time Series* (by Prof Gesine Reinert, from the University of Oxford): [http://www.stats.ox.ac.uk/~reinert/time/notesht10short.pdf](http://www.stats.ox.ac.uk/~reinert/time/notesht10short.pdf)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*时间序列*（由牛津大学的 Gesine Reinert 教授撰写）：[http://www.stats.ox.ac.uk/~reinert/time/notesht10short.pdf](http://www.stats.ox.ac.uk/~reinert/time/notesht10short.pdf)'
- en: Operating on time series data
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对时间序列数据进行操作
- en: Now that we know how to slice data and extract various subsets, let's discuss
    how to operate on time series data. You can filter the data in many different
    ways. The `pandas` library allows you to operate on time series data in any way
    that you want.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何切片数据和提取各种子集，让我们讨论如何对时间序列数据进行操作。您可以通过许多不同的方式过滤数据。`pandas` 库允许您以任何您想要的方式对时间序列数据进行操作。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use data contained in a `.txt` file and load it. Then,
    we will filter the data using a certain threshold to extract only a portion of
    the starting dataset that meets specific requirements.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `.txt` 文件中的数据并加载它。然后，我们将使用某个阈值过滤数据，以提取仅满足特定要求的起始数据集的一部分。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how we can operate on time series data:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何对时间序列数据进行操作：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `operating_on_data.py` file that is provided for you):'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Python 文件并导入以下包（完整的代码在提供的 `operating_on_data.py` 文件中给出）：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, `convert_to_timeseries` is the function we defined in the previous recipe, *Transforming
    data into a time series format*, that read an input file and converted sequential
    observations into time-indexed data.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`convert_to_timeseries` 是我们在上一个菜谱中定义的函数，*将数据转换为时间序列格式*，该函数读取输入文件并将顺序观测值转换为时间索引数据。
- en: 'We will use the same text file that we used in the previous recipes (`data_timeseries.txt`):'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用与之前菜谱中相同的文本文件（记住，Python 从位置0开始列出数据，因此第三列和第四列的索引是2和3）：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will use both the third and fourth columns in this `.txt` file (remember,
    Python lists the data starting from position 0, so the third and fourth columns
    have the indices 2 and 3):'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个 `.txt` 文件中，我们将使用第三列和第四列（记住，Python 从位置0开始列出数据，所以第三列和第四列的索引是2和3）：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Convert the data into a `pandas` DataFrame:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据转换为 `pandas` DataFrame：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Plot the data in the given year range:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在给定年份范围内绘制数据：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s assume that we want to plot the difference between the two columns that
    we just loaded in the given year range. We can do this using the following lines:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们想绘制给定年份范围内两列之间的差异。我们可以使用以下行来完成此操作：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we want to filter the data based on different conditions for the first and
    second columns, we can just specify these conditions and plot this:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想根据第一列和第二列的不同条件过滤数据，我们只需指定这些条件并绘制如下：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you run the preceding code, the first output will look as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行前面的代码，第一个输出将如下所示：
- en: '![](img/95ef968f-8117-466e-83cc-bb02335bfc8f.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95ef968f-8117-466e-83cc-bb02335bfc8f.png)'
- en: 'The second output screenshot denotes the difference, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二张输出截图表示差异，如下所示：
- en: '![](img/2496b36b-19df-4b72-b296-917d135271f1.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2496b36b-19df-4b72-b296-917d135271f1.png)'
- en: 'The third output screenshot denotes the filtered data, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第三张输出截图表示过滤后的数据，如下所示：
- en: '![](img/d7837dd2-957f-479c-a374-bae91b59aa16.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d7837dd2-957f-479c-a374-bae91b59aa16.png)'
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we learned how to filter the data contained in a time series.
    First, we plotted the data between two years (from 1952 to 1955). Then, we plotted
    the difference between the data contained in two columns for a specific time interval
    (from 1952 to 1955). Finally, we plotted data using a certain threshold to extract
    only a portion of the starting dataset that meets specific requirements—in particular,
    when the first column is greater than 60 and when the second column is smaller
    than 20.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们学习了如何过滤时间序列中的数据。首先，我们在两个年份之间（从1952年到1955年）绘制了数据。然后，我们在特定时间间隔内（从1952年到1955年）绘制了两个列中包含的数据之间的差异。最后，我们使用某个阈值绘制数据，以提取仅满足特定要求的起始数据集的一部分——特别是当第一列大于60且第二列小于20时。
- en: There's more…
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To perform two-column filtering at the same time, the `&` operator was used.
    The `&` (and) operator is a logical operator (Boolean operator) of logical conjunction
    between two propositions. Given two propositions, A and B, the logical conjunction
    determines a third proposition, C*,* that manifests itself as true only when both
    propositions are true.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要同时进行两列过滤，使用了`&`运算符。`&`（与）运算符是两个命题之间的逻辑运算符（布尔运算符），表示逻辑合取。给定两个命题，A和B，逻辑合取确定第三个命题，C*，*，只有当两个命题都为真时，该命题才为真。
- en: See also
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the *Fundamental concepts in Time Series Analysis* lecture, (from
    the University of Lausanne): [https://math.unice.fr/~frapetti/CorsoP/chapitre_1_part_1_IMEA_1.pdf](https://math.unice.fr/~frapetti/CorsoP/chapitre_1_part_1_IMEA_1.pdf)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅*时间序列分析的基本概念*讲座（来自洛桑大学）：[https://math.unice.fr/~frapetti/CorsoP/chapitre_1_part_1_IMEA_1.pdf](https://math.unice.fr/~frapetti/CorsoP/chapitre_1_part_1_IMEA_1.pdf)
- en: Extracting statistics from time series data
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从时间序列数据中提取统计数据
- en: One of the main reasons that we want to analyze time series data is to extract
    interesting statistics from it. This provides a lot of information regarding the
    nature of the data.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要分析时间序列数据的主要原因是从中提取有趣的统计数据。这提供了有关数据性质的大量信息。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will take a look at how to extract some statistics.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将探讨如何提取一些统计数据。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how we can extract statistics from time series data:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何从时间序列数据中提取统计数据：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `extract_stats.py` file that is provided for you):'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件并导入以下包（完整的代码在提供的`extract_stats.py`文件中给出）：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `convert_to_timeseries` function is the function we defined in the previous
    recipe, *Transforming data into a time series format*, that read an input file
    and converted sequential observations into time-indexed data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`convert_to_timeseries`函数是我们之前在*将数据转换为时间序列格式*食谱中定义的函数，它读取输入文件并将顺序观测值转换为时间索引数据。'
- en: 'We will use the same text file that we used in the previous recipes for analysis
    (`data_timeseries.txt`):'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用之前食谱中用于分析的相同文本文件（`data_timeseries.txt`）：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Load both the data columns (third and fourth columns):'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载数据的列（第三和第四列）：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a `pandas` data structure to hold this data. This DataFrame is like
    a dictionary that has keys and values:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`pandas`数据结构来存储这些数据。这个DataFrame就像一个有键和值的字典：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s start extracting some stats now. To extract the maximum and minimum
    values, use the following code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们开始提取一些统计数据。要提取最大值和最小值，请使用以下代码：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To print the mean values of your data or just the row-wise mean, use the following
    code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打印数据的平均值或仅打印行平均值，请使用以下代码：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The rolling mean is an important statistic that''s used a lot in time series
    processing. One of the most famous applications is smoothing a signal to remove
    noise. *Rolling mean* refers to computing the mean of a signal in a window that
    keeps sliding on the time scale. Let''s consider a window size of `24` and plot
    this, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动平均值是时间序列处理中常用的重要统计量。最著名的应用之一是平滑信号以去除噪声。“滚动平均值”指的是在时间尺度上滑动窗口中信号的均值计算。让我们考虑窗口大小为`24`并绘制如下：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Correlation coefficients are useful in understanding the nature of the data,
    as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相关系数在理解数据性质方面很有用，如下所示：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s plot this using a window size of `60`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用窗口大小为`60`来绘制这个：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you run the preceding code, the rolling mean will look as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行前面的代码，滚动平均值将如下所示：
- en: '![](img/ca055cc5-4cb0-4389-ac92-7b969f423cb1.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca055cc5-4cb0-4389-ac92-7b969f423cb1.png)'
- en: 'The second output indicates the rolling correlation (the following output is
    the result of a zoomed rectangle operation that was performed in the `matplotlib`
    window):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个输出指示滚动相关性（以下输出是在`matplotlib`窗口中执行缩放矩形操作的结果）：
- en: '![](img/40cb9669-d1a2-49a1-8a6d-df47979ae75b.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40cb9669-d1a2-49a1-8a6d-df47979ae75b.png)'
- en: 'In the upper half of the Terminal, you will the see max, min, and mean values
    printed, as shown in the following output:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端的上半部分，您将看到打印出的最大值、最小值和平均值，如下所示：
- en: '![](img/f5eab4b8-8343-4a9b-9dd6-a1c217637675.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5eab4b8-8343-4a9b-9dd6-a1c217637675.png)'
- en: 'In the lower half of the terminal, you will see the row-wise mean stats and
    correlation coefficients printed, as shown in the following output:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端的下半部分，您将看到打印出行平均值统计和相关性系数，如下所示：
- en: '![](img/cf91ac64-c670-4527-aa2b-309b00cb6896.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf91ac64-c670-4527-aa2b-309b00cb6896.png)'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we learned how to extract some statistics. We started by calculating
    the minimum, maximum, and mean of each of the two columns that were extracted
    from the dataset. Then, we calculated the mean for each row for the first 10 rows
    of the DataFrame. Finally, we performed a correlation analysis between the two
    features.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们学习了如何提取一些统计数据。我们首先计算了从数据集中提取的两个列的最小值、最大值和平均值。然后，我们计算了DataFrame前10行的每一行的平均值。最后，我们对两个特征进行了相关性分析。
- en: There's more…
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'To perform a correlation analysis, the `pandas.DataFrame.corr` function was
    used. This function computes a pairwise correlation of columns, excluding N/A
    or null values. The following methods are available:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行相关性分析，使用了`pandas.DataFrame.corr`函数。此函数计算列之间的成对相关性，排除N/A或空值。以下方法可用：
- en: '`pearson`: This is the standard correlation coefficient'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pearson`：这是标准的相关系数'
- en: '`kendall`: This is the **Kendall Tau** correlation coefficient'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kendall`：这是**肯德尔tau**相关系数'
- en: '`spearman`: This is the **Spearman rank** correlation coefficient'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spearman`：这是**斯皮尔曼秩**相关系数'
- en: See also
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Refer to the official documentation of the `pandas.DataFrame.corr` function:
    [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.corr.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.corr.html)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考官方文档中的`pandas.DataFrame.corr`函数：[https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.corr.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.corr.html)
- en: '*Correlation* (from the SRM University): [http://www.srmuniv.ac.in/sites/default/files/downloads/CORRELATION.pdf](http://www.srmuniv.ac.in/sites/default/files/downloads/CORRELATION.pdf)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*相关性*（来自SRM大学）：[http://www.srmuniv.ac.in/sites/default/files/downloads/CORRELATION.pdf](http://www.srmuniv.ac.in/sites/default/files/downloads/CORRELATION.pdf)'
- en: Building HMMs for sequential data
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为序列数据构建HMMs
- en: '**Hidden Markov models** (**HMMs**) are particularly suitable for sequential
    data analysis problems. They are widely used in fields such as speech analysis,
    finance, word sequencing, weather forecasting, and so on.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐藏马尔可夫模型**（**HMMs**）特别适合于序列数据分析问题。它们在语音分析、金融、词序列、天气预报等领域得到广泛应用。'
- en: Any source of data that produces a sequence of outputs can produce patterns.
    Note that HMMs are generative models, which means that they can generate the data
    once they learn the underlying structure. HMMs cannot discriminate between classes
    in their base forms. This is in contrast to discriminative models that can learn
    to discriminate between classes but cannot generate data.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 任何产生输出序列的数据源都可以产生模式。请注意，HMMs是生成模型，这意味着一旦它们学会了底层结构，它们就可以生成数据。HMMs在其基本形式中不能区分类别。这与可以学习区分类别但不能生成数据的判别模型形成对比。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s say that we want to predict whether the weather will be sunny, chilly,
    or rainy tomorrow. To do this, we look at all the parameters, such as temperature,
    pressure, and so on, whereas the underlying state is hidden. Here, the underlying
    state refers to the three available options: sunny, chilly, or rainy.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要预测明天的天气是晴朗、寒冷还是雨天。为此，我们查看所有参数，如温度、压力等，而底层状态是隐藏的。在这里，底层状态指的是三个可用的选项：晴朗、寒冷或雨天。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how we can build HMMs for sequential data:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何为序列数据构建HMMs：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `hmm.py` file that is provided for you):'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件并导入以下包（完整的代码在提供的`hmm.py`文件中给出）：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will use the data from a file named `data_hmm.txt` that is already provided
    to you. This file contains comma-separated lines. Each line contains three values:
    a year, a month, and a piece of floating-point data. Let''s load this into a NumPy
    array:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用名为`data_hmm.txt`的文件中的数据，该文件已经提供给你。该文件包含逗号分隔的行。每行包含三个值：一个年份、一个月和一段浮点数据。让我们将其加载到一个NumPy数组中：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s stack the data column-wise for analysis. We don''t need to technically
    column-stack this because it''s only one column. However, if you have more than
    one column to analyze, you can use the following structure:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将数据列堆叠起来进行分析。实际上我们不需要技术上列堆叠，因为这只有一个列。然而，如果你有多个列要分析，可以使用以下结构：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create and train the HMM using four components. The number of components is
    a hyperparameter that we have to choose. Here, by selecting four, we say that
    the data is being generated using four underlying states. We will see how the
    performance varies with this parameter:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用四个组件创建和训练HMM。组件的数量是一个超参数，我们必须选择。在这里，通过选择四个，我们说数据正在使用四个潜在状态生成。我们将看到性能如何随着这个参数的变化而变化：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run the predictor to get the hidden states:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行预测器以获取隐藏状态：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Compute the mean and variance of the hidden states:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算隐藏状态的均值和方差：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As we discussed earlier, HMMs are generative models. So, let''s generate, for
    example, `1000` samples and plot this:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，HMMs是生成模型。所以，让我们生成，例如，`1000`个样本并绘制这个：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The full code is given in the `hmm.py` file that is already provided to you.
    If you run the preceding code, you will see the following output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码在提供的`hmm.py`文件中给出。如果你运行前面的代码，你会看到以下输出：
- en: '![](img/3f7ca760-fe8a-4f2e-9775-42e56d237035.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f7ca760-fe8a-4f2e-9775-42e56d237035.png)'
- en: 'You can experiment with the `n_components` parameter to see how the curve gets
    nicer as you increase it. You can basically give it more freedom to train and
    customize by allowing a larger number of hidden states. If you increase it to
    `8`, you will see the following output:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过实验`n_components`参数来观察随着它的增加曲线如何变得更加平滑。你基本上可以给它更多的自由度来训练和定制，允许更多的隐藏状态。如果你将其增加到`8`，你会看到以下输出：
- en: '![](img/f808d661-11ee-48ad-868b-cfbd6a10a5ac.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f808d661-11ee-48ad-868b-cfbd6a10a5ac.png)'
- en: 'If you increase this to `12`, it will get even smoother:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将其增加到`12`，它将变得更加平滑：
- en: '![](img/6f68f940-7cb3-453f-9198-0ed5de91f93f.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f68f940-7cb3-453f-9198-0ed5de91f93f.png)'
- en: 'In the terminal, you will get the following output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，你会得到以下输出：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: HMM is a model in which the system being modeled is assumed to be a Markov process
    with unobserved states. A stochastic process is called Markovian when, having
    chosen a certain instance of *t* for observation, the evolution of the process,
    starting with *t*, depends only on *t* and does not depend in any way on the previous
    instances. Thus, a process is Markovian when, given the moment of observation,
    only this instance determines the future evolution of the process, while this
    evolution does not depend on the past. In this recipe, we learned how to use HMMs
    to generate a time series.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: HMM是一种模型，其中被建模的系统被假定为具有未观察状态的马尔可夫过程。一个随机过程被称为马尔可夫的，当在观察中选择了某个特定的*t*实例后，该过程的演变，从*t*开始，只依赖于*t*，而不以任何方式依赖于之前的实例。因此，一个过程是马尔可夫的，当给定观察时刻时，只有这个实例决定了过程的未来演变，而这一演变不依赖于过去。在这个菜谱中，我们学习了如何使用HMMs生成时间序列。
- en: There's more…
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In this recipe, we used `hmmlearn` to build and train HMMs, which implements
    the HMMs. A HMM is a generative probabilistic model, wherein a sequence of observable
    variables is computed using a sequence of hidden internal states. Hidden states
    are not observed directly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了`hmmlearn`来构建和训练HMMs，它实现了HMMs。HMM是一种生成概率模型，其中使用一系列隐藏内部状态计算一系列可观察变量。隐藏状态不能直接观察到。
- en: See also
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the official documentation of the `hmmlearn` library to find out more: [https://hmmlearn.readthedocs.io/en/latest/](https://hmmlearn.readthedocs.io/en/latest/)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多信息请参考`hmmlearn`库的官方文档：[https://hmmlearn.readthedocs.io/en/latest/](https://hmmlearn.readthedocs.io/en/latest/)
- en: '*A Tutorial on Hidden Markov Models* (by Lawrence R Rabiner from Oxford University):
    [https://www.robots.ox.ac.uk/~vgg/rg/slides/hmm.pdf](https://www.robots.ox.ac.uk/~vgg/rg/slides/hmm.pdf)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《隐藏马尔可夫模型教程》*（由牛津大学的劳伦斯·R·拉比纳尔编写）：[https://www.robots.ox.ac.uk/~vgg/rg/slides/hmm.pdf](https://www.robots.ox.ac.uk/~vgg/rg/slides/hmm.pdf)'
- en: Building CRFs for sequential text data
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用于序列文本数据的CRFs
- en: '**Conditional random fields** (**CRFs**) are probabilistic models that are
    used to analyze structured data. They are frequently used to label and segment
    sequential data. CRFs are discriminative models as opposed to HMMs, which are
    generative models. CRFs are used extensively to analyze sequences, stock, speech,
    words, and so on. In these models, given a particular labeled observation sequence,
    we define a conditional probability distribution over this sequence. This is in
    contrast to HMMs, where we define a joint distribution over the label and the
    observed sequence.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件随机场**（**CRFs**）是用于分析结构化数据的概率模型。它们通常用于标记和分割序列数据。与生成模型HMMs相比，CRFs是判别模型。CRFs被广泛用于分析序列、股票、语音、单词等。在这些模型中，给定一个特定的标记观察序列，我们定义这个序列的条件概率分布。这与HMMs不同，在HMMs中，我们定义标签和观察序列的联合分布。'
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use a library called `pystruct` to build and train CRFs.
    Make sure that you install this before you proceed. You can find the installation
    instructions at [https://pystruct.github.io/installation.html](https://pystruct.github.io/installation.html).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用一个名为`pystruct`的库来构建和训练CRFs。确保你在继续之前安装它。你可以找到安装说明在[https://pystruct.github.io/installation.html](https://pystruct.github.io/installation.html)。
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see how we can build CRFs for sequential text data:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何为序列文本数据构建CRFs：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `crf.py` file that is provided for you):'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件并导入以下包（完整的代码在提供的`crf.py`文件中给出）：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Define an argument parser to take the `C` value as an input argument. Here,
    `C` is a hyperparameter that controls how specific you want your model to be without
    losing the power to generalize:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个参数解析器以接受`C`值作为输入参数。在这里，`C`是一个超参数，它控制你希望你的模型有多具体，同时不失泛化能力：
- en: '[PRE45]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Define a `class` to handle all CRF-related processing:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`class`来处理所有与CRF相关的处理：
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Define an `init` function to initialize the values:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`init`函数来初始化值：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will use `ChainCRF` to analyze the data. We need to add an error check to
    this, as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`ChainCRF`来分析数据。我们需要添加一个错误检查，如下所示：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Define the classifier that we will use with our CRF model. We will use a type
    of SVM to achieve this:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们将与CRF模型一起使用的分类器。我们将使用一种SVM类型来实现这一点：
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Load the `letters` dataset. This dataset consists of segmented letters and
    their associated feature vectors. We will not analyze the images because we already
    have the feature vectors. The first letter from each word has been removed, so
    all we have are lowercase letters:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`letters`数据集。这个数据集包括分割后的字母及其相关的特征向量。我们不会分析图像，因为我们已经有了特征向量。每个单词的第一个字母已经被移除，所以我们只剩下小写字母：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Load the data and labels into their respective variables:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据和标签加载到各自的变量中：
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Define a training method, as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一种训练方法，如下所示：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Define a method to evaluate the performance of the model:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个方法来评估模型的表现：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Define a method to classify new data:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个方法来分类新数据：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The letters are indexed in a numbered array. To check the output and make it
    readable, we need to transform these numbers into alphabets. Define a function
    to do this:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字母被索引在一个编号数组中。为了检查输出并使其可读，我们需要将这些数字转换成字母。定义一个函数来做这件事：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Define the main function and parse the input arguments:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义主函数并解析输入参数：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Initialize the variable with the class and the `C` value:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类和`C`值初始化变量：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Load the `letters` data:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`letters`数据：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Separate the data into training and testing datasets:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据分为训练集和测试集：
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Train the CRF model, as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式训练CRF模型：
- en: '[PRE60]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Evaluate the performance of the CRF model:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估CRF模型的表现：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s take a random test vector and predict the output using the model:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们随机取一个测试向量并使用模型进行预测：
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If you run the preceding code, you will get the following output on your terminal.
    As we can see, the word is supposed to be `commanding`. The CRF does a pretty
    good job of predicting all the letters:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你将在你的终端上得到以下输出。正如我们所见，单词应该是`commanding`。CRF在预测所有字母方面做得相当不错：
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: HMMs assume that the current output is statistically independent of the previous
    outputs. This is needed by HMMs to ensure that the inference works in a robust
    way. However, this assumption doesn't always have to be true! The current output
    in a time series setup, more often than not, depends on previous outputs. One
    of the main advantages of CRFs over HMMs is that they are conditional by nature,
    which means that we are not assuming any independence between output observations.
    There are a few other advantages of using CRFs over HMMs. CRFs tend to outperform
    HMMs in a number of applications, such as linguistics, bioinformatics, speech
    analysis, and so on. In this recipe, we will learn how to use CRFs to analyze
    sequences of letters.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: HMMs假设当前输出在统计上与先前输出独立。这是HMMs确保推理以稳健方式工作所必需的。然而，这个假设并不总是必须成立的！在时间序列设置中，当前输出往往依赖于先前输出。CRFs相对于HMMs的主要优势之一是它们本质上是有条件的，这意味着我们不会假设输出观测之间有任何独立性。使用CRFs而不是HMMs还有其他一些优势。CRFs在许多应用中往往优于HMMs，例如语言学、生物信息学、语音分析和如此等等。在这个菜谱中，我们将学习如何使用CRFs来分析字母序列。
- en: There's more…
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: PyStruct is a structured library of easy-to-use machine learning algorithms.
    It implements the max-margin and perceptron methods. Examples of learning algorithms
    that are implemented in PyStruct are CRFs, **maximum-margin Markov** **random
    fields** (**M3Ns**), and structural SVMs.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: PyStruct是一个易于使用的机器学习算法的结构化库。它实现了最大间隔和感知器方法。PyStruct中实现的算法示例包括CRFs、**最大间隔马尔可夫**
    **随机字段**（**M3Ns**）和结构化SVMs。
- en: See also
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the official documentation of the `pystruct` library for more information: [https://pystruct.github.io/](https://pystruct.github.io/)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多信息请参考`pystruct`库的官方文档：[https://pystruct.github.io/](https://pystruct.github.io/)
- en: 'Look at the *Conditional Random Fields* lecture (from the University of Notre
    Dame): [https://www3.nd.edu/~dchiang/teaching/nlp/2015/notes/chapter8v1.pdf](https://www3.nd.edu/~dchiang/teaching/nlp/2015/notes/chapter8v1.pdf)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看来自圣母大学的*条件随机字段*讲座（[https://www3.nd.edu/~dchiang/teaching/nlp/2015/notes/chapter8v1.pdf](https://www3.nd.edu/~dchiang/teaching/nlp/2015/notes/chapter8v1.pdf)）
- en: Analyzing stock market data
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析股票市场数据
- en: The stock market has always been a very popular topic; this is because stock
    market trends involve a truly impressive turnover. The interest that this topic
    arouses is clearly linked to the opportunity to get rich through good forecasting
    by a stock market title. A positive difference between the purchased stock price
    and that of the sold stock price entails a gain on the part of the investor. But,
    as we know, the performance of the stock market depends on multiple factors.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 股票市场一直是一个非常热门的话题；这是因为股票市场趋势涉及真正令人印象深刻的交易量。这个话题引起的兴趣显然与通过股票市场标题的良好预测获得财富的机会有关。购买股票价格与卖出股票价格之间的正差价意味着投资者获得了收益。但是，正如我们所知，股票市场的表现取决于多个因素。
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll look at how to analyze the stock price of a very popular
    company: I am referring to Amazon, the US e-commerce company, based in Seattle,
    Washington, which is the largest internet company in the world.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何分析一家非常流行的公司的股票价格：我指的是亚马逊，一家位于华盛顿州西雅图的美国电子商务公司，它是世界上最大的互联网公司。
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how we analyze stock market data:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何分析股票市场数据：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `AmazonStock.py` file that is provided for you):'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件并导入以下包（完整的代码在提供的`AmazonStock.py`文件中）：
- en: '[PRE64]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Get the stock quotes from the `AMZN.csv` file that is provided for you:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从提供的`AMZN.csv`文件中获取股票报价：
- en: '[PRE65]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To extract preliminary information about the imported dataset, we can invoke
    the `info()` function:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要提取导入数据集的初步信息，我们可以调用`info()`函数：
- en: '[PRE66]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following results are returned:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This function prints information about a DataFrame, including the index and
    the `dtypes` column, `non-null` values, and `memory usage`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数打印有关DataFrame的信息，包括索引和`dtypes`列、`non-null`值和`memory usage`。
- en: 'To display the first five rows of the imported DataFrame, we can use the `head()`
    function, as follows:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示导入的DataFrame的前五行，我们可以使用`head()`函数，如下所示：
- en: '[PRE68]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This function returns the first *n* rows for the object based on position.
    It is useful for quickly testing whether your object has the right type of data
    in it. By default, (if *n* is omitted), the first five rows are displayed. The
    following results are returned:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数根据位置返回对象的前 *n* 行。这对于快速测试对象中是否包含正确的数据类型很有用。默认情况下（如果省略 *n*），显示前五行。以下结果被返回：
- en: '[PRE69]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To get a preview of the data contained in it, we can calculate a series of
    basic statistics. To do so, we will use the `describe()` function in the following
    way:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要预览其中包含的数据，我们可以计算一系列基本统计量。为此，我们将使用以下方式的 `describe()` 函数：
- en: '[PRE70]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `describe()` function generates descriptive statistics that summarize the
    central tendency, the dispersion, and the form of the distribution of a dataset,
    excluding the `NaN` values. This function analyzes both numerical and object series,
    as well as the DataFrame column sets of mixed data types. The following results
    are returned:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe()` 函数生成描述性统计量，总结数据集的中心趋势、离散程度和分布形式，排除 `NaN` 值。此函数分析数值和对象序列，以及混合数据类型的
    DataFrame 列集。以下结果被返回：'
- en: '[PRE71]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, we are going to perform an initial visual exploratory analysis of the
    time series:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将对时间序列进行初步的视觉探索性分析：
- en: '[PRE72]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the following graph, Amazon stock prices from 2000-11-21 to 2018-11-21 are
    shown:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图表中，显示了从2000年11月21日到2018年11月21日的亚马逊股票价格：
- en: '![](img/7dd54eda-2970-4787-99af-3b14fa0b5bb3.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dd54eda-2970-4787-99af-3b14fa0b5bb3.png)'
- en: From the analysis of the previous graph, we can see that prices have increased
    considerably over time. In particular, starting from 2015, this increase has shown
    an exponential trend.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前图表的分析中，我们可以看到价格随着时间的推移显著增加。特别是，从2015年开始，这种增长显示出指数趋势。
- en: 'Now, let''s try to obtain a deeper understanding of the change that Amazon
    stock has recorded over time. To calculate percentage changes in Python, we will
    use the `pct_change()` function. This function returns percentage changes over
    a given number of periods:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试更深入地了解亚马逊股票随时间记录的变化。为了在Python中计算百分比变化，我们将使用 `pct_change()` 函数。此函数返回给定数量的期间的百分比变化：
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: What we have just calculated coincides with the concept of return.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚计算的结果与回报的概念相符。
- en: 'To calculate the logarithm of returns, we will use the `log()` function from
    `numpy`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要计算回报的对数，我们将使用来自 `numpy` 的 `log()` 函数：
- en: '[PRE74]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `tail()` function returns the last *n* rows from the object, based on position.
    It is useful for quickly verifying data—for example, after sorting or appending
    rows. The following values are returned (the last 10 rows of the `LogReturns`
    object):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail()` 函数根据位置从对象返回最后 *n* 行。这对于快速验证数据很有用——例如，在排序或追加行之后。以下值被返回（`LogReturns`
    对象的最后10行）：'
- en: '[PRE75]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, we will draw a diagram with the logarithm of the returns we have calculated:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将绘制我们计算出的回报对数的图表：
- en: '[PRE76]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As we have done previously, we first set the dimensions of the graph, then
    we will plot the graph, and finally we will visualize it. The following graph
    shows the logarithm of the returns:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，我们首先设置图表的维度，然后我们将绘制图表，最后我们将可视化它。以下图表显示了回报的对数：
- en: '![](img/067332e5-a62c-40f6-ab09-29ea44dd5d21.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/067332e5-a62c-40f6-ab09-29ea44dd5d21.png)'
- en: How it works...
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To study the evolution of a phenomenon, a graph of its time series is not enough;
    we need to make comparisons between the intensity of the phenomenon at different
    times, that is, calculating the variations of intensity from one period to another.
    Furthermore, it can be interesting to analyze the trend of the variations of the
    phenomenon that occurred between adjoining periods of time. We indicate a time
    series with Y1,..., Yt,..., Yn. The time series is the chronological recording
    of experimental observations of a variable, such as price trends, stock market
    indices, spreads, and unemployment rates. It is therefore a succession of data
    that's been ordered over time from which we want to extract information for the
    characterization of the phenomenon under observation, and for the prediction of
    future values.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要研究一个现象的演变，仅有一个时间序列图是不够的；我们需要比较不同时间点的现象强度，即计算从一个时期到另一个时期的强度变化。此外，分析相邻时间段内现象变化的趋势可能也很有趣。我们用
    Y1,..., Yt,..., Yn 表示时间序列。时间序列是变量的实验观察的按时间顺序记录，例如价格趋势、股票市场指数、价差和失业率。因此，它是一系列按时间顺序排列的数据，我们希望从中提取信息以表征观察到的现象，并预测未来的值。
- en: 'The variation that occurs between two different times (let''s indicate them
    with *t* and *t + 1*) can be measured using the following ratio:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 两个不同时间之间发生的变化（让我们用 *t* 和 *t + 1* 来表示）可以使用以下比率来衡量：
- en: '![](img/6f1d5748-9875-4c3d-a708-3bfe00fa6cb2.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f1d5748-9875-4c3d-a708-3bfe00fa6cb2.png)'
- en: This index is a percentage ratio and is called a **percentage change**. In particular,
    this is the percentage rate of variation of the phenomenon *Y* of the time *t
    + 1*, with respect to the previous time, *t*. This method gives a more detailed
    explanation about how the data has changed over a period of time. With this technique,
    we can track the prices of individual stocks and large market indices, as well
    as compare the values of different currencies.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此指数是一个百分比比率，称为**百分比变化**。特别是，这是现象 *Y* 在时间 *t + 1* 相对于之前时间 *t* 的百分比变化率。这种方法提供了关于数据随时间变化更详细的解释。使用这种技术，我们可以追踪个别股票和大型市场指数的价格，以及比较不同货币的价值。
- en: There's more…
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The advantage of using returns, compared to prices, lies in the normalization
    that allows us to measure all the variables in a comparable metric, thus allowing
    for the evaluation of analytical relationships between two or more variables.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 与价格相比，使用回报的优势在于标准化，这使得我们能够以可比较的指标来衡量所有变量，从而允许评估两个或更多变量之间的分析关系。
- en: See also
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the official documentation of the `pandas.DataFrame.pct_change` function:
    [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pct_change.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pct_change.html)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考官方文档的`pandas.DataFrame.pct_change`函数：[https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pct_change.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pct_change.html)
- en: Using RNNs to predict time series data
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RNN预测时序数据
- en: '**Long short-term memory** (**LSTM**) is a particular architecture of **recurrent
    neural networks** (**RNNs**). RNNs are based on the need to preserve the memory
    of past events; this behavior is not possible with normal networks, and that is
    why RNNs are used in areas where the classic networks do not produce results,
    such as the prediction of time series (weather, quotations, and so on) that refer
    to previous data.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**长短期记忆**（**LSTM**）是**循环神经网络**（**RNNs**）的一种特定架构。RNNs基于对过去事件记忆的需求；这种行为在普通网络中是不可能的，这就是为什么RNNs被用于经典网络无法产生结果的领域，例如预测与先前数据相关的时序数据（天气、报价等）。'
- en: 'An LSTM network consists of cells (LSTM blocks) that are linked together. Each
    cell is, in turn, composed of three types of ports: the input gate, output gate,
    and forget gate. They implement the write, read, and reset functions on the cell
    memory, respectively, so the LSTM modules are able to regulate what is stored
    and deleted. This is possible thanks to the presence of various elements called
    **gates**, which are composed of a sigmoid neural layer and a pointwise product. The
    output of each gate is in the range (0, 1), representing the percentage of information
    that flows inside it.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: LSTM网络由相互连接的细胞（LSTM块）组成。每个细胞反过来又由三种类型的端口组成：输入门、输出门和遗忘门。它们分别对细胞内存执行写入、读取和重置功能，因此LSTM模块能够调节存储和删除的内容。这得益于存在各种称为**门**的元素，这些门由一个sigmoid神经网络层和一个逐点乘积组成。每个门的输出在（0，1）范围内，表示其中流动的信息百分比。
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll look at how the LSTM model can be applied to predict
    the future stock price of a very popular company: I refer to Amazon, the US e-commerce
    company, based in Seattle, Washington, which is the largest internet company in
    the world.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何将LSTM模型应用于预测一家非常受欢迎的公司的未来股价：我指的是总部位于华盛顿州西雅图的美国电子商务公司亚马逊，它是世界上最大的互联网公司。
- en: How to do it...
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how we can use RNNs to predict time series data:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用RNN来预测时序数据：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `LSTMstock.py` file that is provided for you). The first part of
    the file was tackled in the previous recipe, *Analyzing stock market data*. We
    report it only for the completeness of the algorithm:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件并导入以下包（完整的代码在提供的`LSTMstock.py`文件中给出）。文件的前一部分在之前的菜谱中已经处理过，*分析股票市场数据*。我们只报告它以完整算法：
- en: '[PRE77]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'It is good practice to rescale the data before training an LSTM algorithm.
    With rescaling, data units are eliminated, allowing you to compare data from different
    locations easily. In this case, we will use the min-max method (usually called
    **feature scaling**) to get all the scaled data in the range [0, 1]. To perform
    feature scaling, we can use the preprocessing package that''s available in the
    `sklearn` library:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在训练LSTM算法之前对数据进行缩放是一种良好的实践。通过缩放，消除了数据单位，这使得你可以轻松地比较来自不同位置的数据。在这个例子中，我们将使用最小-最大方法（通常称为**特征缩放**）来获取所有缩放数据在[0,
    1]范围内的数据。为了执行特征缩放，我们可以使用`sklearn`库中可用的预处理包：
- en: '[PRE78]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, let''s split the data for the training and test model. Training and testing
    the model forms the basis for further usage of the model for prediction in predictive
    analytics. Given a dataset of 4,529 rows of data, we split it into a convenient
    ratio (say 70:30) and allocate 3,170 rows for training and 1,359 rows for testing:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将数据分为训练和测试模型两部分。训练和测试模型是进一步使用模型进行预测性分析的基础。给定一个包含4,529行数据的数据集，我们将其按方便的比例（例如70:30）分割，并将3,170行分配给训练，1,359行分配给测试：
- en: '[PRE79]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The following results are returned:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果被返回：
- en: '[PRE80]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, we need input and output to train and test our network. It is clear that
    the input is represented by the data that''s present in the dataset. Therefore,
    we must construct our output; we will do so by supposing we want to predict the
    Amazon stock price at time *t + 1* with respect to the value stored at time *t*. A
    recurrent network has memory, and this is maintained by fixing the so-called time
    step. The time step is all about how many steps back in time backpropagation uses
    when calculating gradients for weight updates during training. In this way, we
    set `TimeStep=1`. Then, we define a function that gives a dataset and a time step,
    which then returns the input and output data:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要输入和输出以训练和测试我们的网络。很明显，输入由数据集中现有的数据表示。因此，我们必须构建我们的输出；我们将通过假设我们想要预测时间*t
    + 1*的亚马逊股价相对于时间*t*存储的值来做到这一点。一个循环网络具有记忆，这是通过固定所谓的步长来维持的。步长是关于反向传播在计算权重更新时的梯度时回溯多长时间的问题。这样，我们设置`TimeStep=1`。然后，我们定义一个函数，它接受一个数据集和一个时间步长，然后返回输入和输出数据：
- en: '[PRE81]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In this function, `dataX =Input= data(t)` is the input variable and `DataY=output=
    data(t + 1)` is the predicted value at the next time period.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，`dataX = Input = data(t)`是输入变量，`DataY = output = data(t + 1)`是下一个时间段的预测值。
- en: 'Let''s use this function to set the train and test datasets that we will use
    in the next phase (network modeling):'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用这个函数来设置我们在下一阶段（网络建模）中将要使用的训练和测试数据集：
- en: '[PRE82]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In an LSTM/RNN network, the input for each LSTM layer must contain the following
    information:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在LSTM/RNN网络中，每个LSTM层的输入必须包含以下信息：
- en: '**Observations**: Number of observations collected'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观测数**：收集到的观测数'
- en: '**Time steps**: A time step is an observation point in the sample'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间步长**：时间步长是样本中的观测点'
- en: '**Features**: One feature for each step'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特征**：每步一个特征'
- en: 'Therefore, it is necessary to add a temporal dimension to those foreseen for
    a classical network. Thus, the input shape is as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有必要为那些经典网络预见的添加一个时间维度。因此，输入形状如下：
- en: (*Number of observations, number of time steps, number of features per steps*)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: (*观测数，时间步数，每步特征数*)
- en: In this way, the input for each LSTM layer becomes three-dimensional.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每个LSTM层的输入就变成了三维的。
- en: 'To transform the input datasets into 3D form, we will use the `np.reshape()`
    function, as follows:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将输入数据集转换为3D形式，我们将使用`np.reshape()`函数，如下所示：
- en: '[PRE83]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now that the data is in the right format, it''s time to create the model. Let''s
    start by importing the libraries:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在数据已经处于正确的格式，是时候创建模型了。让我们先导入库：
- en: '[PRE84]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We will use a `Sequential` model, that is, a linear stack of layers. To create
    a sequential model, we have to pass a list of layer instances to the constructor.
    We can also simply add layers via the `add()` method:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`Sequential`模型，即层的一个线性堆叠。为了创建一个序列模型，我们必须将一个层实例的列表传递给构造函数。我们也可以通过`add()`方法简单地添加层：
- en: '[PRE85]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The following result is printed:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果被打印出来：
- en: '![](img/b0198263-2a08-40c5-a32f-5ba727792200.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0198263-2a08-40c5-a32f-5ba727792200.png)'
- en: 'To evaluate the performance of the model we have just adapted, we can use the
    `evaluate()` function, as follows:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了评估我们刚刚调整的模型的表现，我们可以使用`evaluate()`函数，如下所示：
- en: '[PRE86]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The preceding function displays the loss value and metrics values for the model
    in the test mode. This is computed in batches. The following results are returned:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数在测试模式下显示模型的损失值和指标值。这是分批计算的。以下结果被返回：
- en: '[PRE87]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The model is now ready for use. We can therefore use it to execute our predictions:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型现在已准备好使用。因此，我们可以用它来执行我们的预测：
- en: '[PRE88]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The predictions must be reported in their original form so that they can be
    compared to the actual values:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预测必须以原始形式报告，以便可以与实际值进行比较：
- en: '[PRE89]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To verify the correct prediction of data, we can now visualize the results
    by drawing an appropriate graph. To display the time series correctly, a prediction
    shift is required. This operation must be carried out both on the train set and
    the test set:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证数据的正确预测，我们现在可以通过绘制适当的图表来可视化结果。为了正确显示时间序列，需要预测偏移。这个操作必须在训练集和测试集上执行：
- en: '[PRE90]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'As we stated previously, the same operation must then be performed on the test
    set:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们之前所述，然后必须在测试集上执行相同的操作：
- en: '[PRE91]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Finally, we have to plot the actual data and the predictions:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须绘制实际数据和预测结果：
- en: '[PRE92]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The following screenshot shows the actual data and the predictions:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了实际数据和预测结果：
- en: '![](img/b0a827d7-3058-4be1-a038-b0b715dd7d6b.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0a827d7-3058-4be1-a038-b0b715dd7d6b.png)'
- en: How it works...
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'At the beginning of this recipe, we said that the LSTM modules are able to
    regulate what is stored and deleted. This is possible thanks to the presence of
    various elements called gates, which are composed of a sigmoid neural layer and
    a pointwise product. The first part of the LSTM module decides what information
    is deleted from the cell. The gate takes the inputs and returns a value between
    0 and 1 for each state of the cell. The gate output can take two values:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的开头，我们说LSTM模块能够调节存储和删除的内容。这要归功于存在各种称为门的元素，它们由一个sigmoid神经网络层和一个逐点乘积组成。LSTM模块的第一部分决定从单元格中删除哪些信息。门接收输入并为每个单元格状态返回一个介于0和1之间的值。门输出可以取两个值：
- en: '`0`: Complete reset of the cell status'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：完全重置单元格状态'
- en: '`1`: Total storage of the cell value'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：单元格值的总存储'
- en: 'Data storage is divided into two phases:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储分为两个阶段：
- en: The first is entrusted to one sigmoid layer called the **input gate layer**;
    it carries out an operation that establishes which values will need to be updated.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分委托给一个名为**输入门层**的sigmoid层；它执行一个操作，确定哪些值需要更新。
- en: The second phase is instead entrusted to a `tanh` layer that creates a vector
    of values, intended to be updated. To create an updated set of values, the outputs
    of the two layers are combined.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二阶段则委托给一个`tanh`层，该层创建一个待更新的值向量。为了创建一个更新的值集，将两个层的输出结合起来。
- en: Finally, the result will be given by a `sigmoid` layer, which determines which
    parts of the cell will contribute to the output and from the current state of
    the cell, filtered through a `tanh` function to obtain a range from -1 to 1. The
    result of this operation is multiplied by the value of the `sigmoid` layer so
    that only the desired outputs are given.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，结果将由一个sigmoid层给出，该层确定哪些单元格部分将对输出做出贡献，并从当前单元格状态中，通过`tanh`函数过滤，以获得-1到1的范围。此操作的输出乘以sigmoid层的值，以便只给出所需的输出。
- en: There's more…
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: A RNN is a neural model in which a bidirectional flow of information is present.
    In other words, while the propagation of signals in feedforward networks takes
    place only in a continuous manner in one direction, from inputs to outputs, recurrent
    networks are different. In recurrent networks, this propagation can also occur
    from a neural layer following a previous one, between neurons belonging to the
    same layer, or even between a neuron and itself.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: RNN是一种神经网络，其中存在信息双向流动。换句话说，在前馈网络中，信号的传播只在单一方向上连续进行，从输入到输出，而循环网络则不同。在循环网络中，这种传播也可以发生在前一个神经层之后的神经层之间，属于同一层的神经元之间，甚至是一个神经元与其自身之间。
- en: See also
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the official documentation of the Keras library: [https://keras.io/](https://keras.io/)
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅Keras库的官方文档：[https://keras.io/](https://keras.io/)
- en: 'Refer to *Recurrent Neural Networks* (from Yale University): [http://euler.stat.yale.edu/~tba3/stat665/lectures/lec21/lecture21.pdf](http://euler.stat.yale.edu/~tba3/stat665/lectures/lec21/lecture21.pdf)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅耶鲁大学的*循环神经网络*（[http://euler.stat.yale.edu/~tba3/stat665/lectures/lec21/lecture21.pdf](http://euler.stat.yale.edu/~tba3/stat665/lectures/lec21/lecture21.pdf)）
- en: 'Refer to *Long Short-Term Memory* (from the University of Wisconsin, Madison):
    [http://pages.cs.wisc.edu/~shavlik/cs638/lectureNotes/Long%20Short-Term%20Memory%20Networks.pdf](http://pages.cs.wisc.edu/~shavlik/cs638/lectureNotes/Long%20Short-Term%20Memory%20Networks.pdf)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考来自威斯康星大学麦迪逊分校的 *长短期记忆*（[http://pages.cs.wisc.edu/~shavlik/cs638/lectureNotes/Long%20Short-Term%20Memory%20Networks.pdf](http://pages.cs.wisc.edu/~shavlik/cs638/lectureNotes/Long%20Short-Term%20Memory%20Networks.pdf)）
