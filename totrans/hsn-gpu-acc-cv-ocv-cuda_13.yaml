- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章
- en: 'The three options to increase the performance are as follows:'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提高性能的三种选项如下：
- en: Having faster clock speed
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有更快的时钟速度
- en: More work per clock cycle by a single processor
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个处理器每个时钟周期完成更多的工作
- en: Many small processors that can work in parallel. This option is used by GPU
    to improve performance.
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多可以并行工作的小型处理器。这个选项被GPU用来提高性能。
- en: 'True'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: CPUs are designed to improve latency and GPUs are designed to improve Throughput.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU的设计是为了提高延迟，而GPU的设计是为了提高吞吐量。
- en: The car will take 4 hours to reach the destination but it can only accommodate
    5 persons, while the bus that can accommodate 40 persons takes 6 hours to reach
    the destination. The bus can transport 6.66 persons per hour, while the car can
    transport 1.2 persons per hour. Thus, car has better latency, and bus has better
    throughput.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汽车需要4小时才能到达目的地，但它只能容纳5人，而可以容纳40人的公交车需要6小时才能到达目的地。公交车每小时可以运输6.66人，而汽车每小时可以运输1.2人。因此，汽车具有更好的延迟，而公交车具有更好的吞吐量。
- en: Image is nothing but a two dimensional array. Most of the computer vision applications
    involve processing of these two-dimensional arrays. It involves similar operations
    on a large amount of data, which can be efficiently performed by GPUs. So GPUs
    and CUDA are very useful in computer vision applications.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像不过是一个二维数组。大多数计算机视觉应用都涉及这些二维数组的处理。这涉及到对大量数据进行类似操作，这些操作可以通过GPU高效地执行。因此，GPU和CUDA在计算机视觉应用中非常有用。
- en: 'False'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: '`printf` statement is executed on the host'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`printf`语句在主机上执行'
- en: Chapter 2
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章
- en: 'CUDA program to subtract two numbers by passing parameters as value is as follows:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递参数作为值来减去两个数字的CUDA程序如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'CUDA program to multiply two numbers by passing parameters as reference is
    as follows:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递参数作为引用来乘以两个数字的CUDA程序如下：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Three ways to launch 5000 threads for `gpuMul` kernel as are follows:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`gpuMul`内核启动5000个线程的三种方法如下：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'False'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: The program to find GPU Devices with version 5.0 or greater is as follows
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找具有5.0或更高版本的GPU设备的程序如下
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'CUDA program to find Cube of Number is as follows:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找数字立方的CUDA程序如下：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Communication pattern for a particular application is given as shown here:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特定应用的通信模式如下所示：
- en: Image Processing - stencil
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像处理 - 模板
- en: Moving Average - gather
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动平均 - 聚合
- en: Sorting Array in ascending order - Scatter
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按升序排序数组 - 散射
- en: Finding cube of numbers in Array - Map
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数组中查找数字的立方 - 映射
- en: Chapter 3
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章
- en: 'The best method to choose the number of threads and number of blocks is as
    follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择线程数和块数的最佳方法如下：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is a limit to the number of threads that can be launched per block which
    is 512 or 1024 for the latest processors. The same way there is a limit to the
    number of blocks per grid. So if there are a large number of threads then it is
    better to launch kernel by a small number of blocks and threads as described.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个块可以启动的线程数量有限，对于最新的处理器来说，这个数量是512或1024。同样，每个网格的块数量也有限制。因此，如果有大量线程，那么最好通过少量块和线程来启动内核，如上所述。
- en: 'Following is the CUDA program to find the cube of 50000 number:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是为查找50000个数字的立方而编写的CUDA程序：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: True, because it only needs to access local memory, which is a faster memory.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确，因为它只需要访问局部内存，这是一种更快的内存。
- en: When variables of the kernel do not fit in register files, they uses local memory.
    This is called as register spilling. Because some of the data is not in the registers,
    it will need more time to fetch it from memory. This will take more time, and
    hence the performance of the program will be affected.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当内核的变量不适合寄存器文件时，它们使用局部内存。这被称为寄存器溢出。因为一些数据不在寄存器中，它将需要更多时间从内存中检索它。这将花费更多时间，因此程序的性能将受到影响。
- en: No, because all the threads are running in parallel. So data might be read before
    it has been written, and thus it might not give the desired output.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，因为所有线程都在并行运行。所以数据可能在写入之前就被读取，因此可能不会给出期望的输出。
- en: True. In atomic operations, all the other threads have to wait when one thread
    is accessing a particular memory location. This will incur time overhead when
    many threads are accessing the same memory locations. So, atomic operations will
    increase the execution time of the CUDA program.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确。在原子操作中，当一个线程正在访问特定的内存位置时，其他所有线程都必须等待。当许多线程访问相同的内存位置时，这将产生时间开销。因此，原子操作会增加CUDA程序的执行时间。
- en: Stencil communication pattern is ideal for texture memory.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Stencil通信模式非常适合纹理内存。
- en: When `__syncthreads` directive is used inside an `if` statement, then for threads
    that have this condition, `false` will never reach this point and `__syncthreads`
    will continuously wait for all the threads to reach this point. Thus, the program
    will never be terminated.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在 `if` 语句中使用 `__syncthreads` 指令时，对于具有此条件的线程，`false` 永远不会到达这个点，`__syncthreads`
    将持续等待所有线程到达这个点。因此，程序将永远不会终止。
- en: Chapter 4
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章
- en: CPU timers will include time overhead of thread latency in OS and scheduling
    in OS, among many other factors. The time measured using CPU will also depend
    on the availability of high precision CPU timer. The host is frequently performing
    asynchronous computation while GPU kernel is running, and hence CPU timers may
    not give correct time for kernel executions.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU 计时器将包括操作系统中的线程延迟和调度的时间开销，以及其他许多因素。使用 CPU 测量的时间也将取决于高精度 CPU 计时器的可用性。主机在 GPU
    内核运行时经常执行异步计算，因此 CPU 计时器可能无法给出内核执行的准确时间。
- en: Open Nvidia Visual profiler from `C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\libnvvp`.
    Then, go to -> New Session and Select `.exe` file for matrix multiplication example.
    You can visualize the performance of your code.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\libnvvp` 打开 Nvidia
    Visual profiler。然后，转到 -> 新会话并选择矩阵乘法示例的 `.exe` 文件。您可以可视化您代码的性能。
- en: Divide by zero, incorrect variable types or sizes, nonexistent variables, subscripts
    out of range etc are examples of semantic errors.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除以零、变量类型或大小不正确、不存在变量、下标超出范围等是语义错误的例子。
- en: 'An example of thread divergence can be given as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以给出线程发散的例子如下：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the code, odd and even number of threads are performing different operations,
    and hence they will take different amount of time for completion. After `if` statement,
    these threads will again merge. This will incur time overhead because fast threads
    have to wait for slow threads. This will slow down the performance of the code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，奇数和偶数线程执行不同的操作，因此它们完成所需的时间不同。在 `if` 语句之后，这些线程将再次合并。这将产生时间开销，因为快速线程必须等待慢速线程。这将降低代码的性能。
- en: '`cudaHostAlloc` function should be used with proper care because this memory
    is not swapped out of disk; your system may run out of memory. It may affect the
    performance of other applications running on the system.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cudaHostAlloc` 函数应谨慎使用，因为这种内存不会被交换到磁盘上；您的系统可能会耗尽内存。这可能会影响系统上运行的其他应用程序的性能。'
- en: The order of operation is important in CUDA stream operations as we want to
    overlap memory copy operations with kernel execution operations. So, operation
    queues should be made in such a way that these operations can overlap with each
    other, or else using CUDA stream won't help the performance of the program.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 CUDA 流操作中，操作顺序很重要，因为我们希望重叠内存复制操作与内核执行操作。因此，操作队列应设置为这些操作可以相互重叠，否则使用 CUDA 流不会提高程序的性能。
- en: For 1024 x 1024 image, number of threads should be 32x32 (if your system supports
    1024 threads per block), and the number of blocks should be 32 x 32, which can
    be determined by image size divided by number of threads per block.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 1024 x 1024 的图像，线程数应为 32x32（如果您的系统支持每个块 1024 个线程），块数也应为 32 x 32，这可以通过将图像大小除以每个块线程数来确定。
- en: Chapter 5
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章
- en: There is a difference between image processing and computer vision fields. Image
    processing is concerned with improving the visual quality of images by modifying
    pixel values, whereas computer vision is concerned with extracting important information
    from the images. So, in image processing, both input and output are images, while
    in computer vision, input is an image but the output is the information extracted
    from that image.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像处理和计算机视觉领域之间存在差异。图像处理关注通过修改像素值来提高图像的视觉质量，而计算机视觉关注从图像中提取重要信息。因此，在图像处理中，输入和输出都是图像，而在计算机视觉中，输入是图像，但输出是从该图像中提取的信息。
- en: The OpenCV library has an interface in C, C++, Java, and Python languages and
    it can be used in all operating systems like Windows, Linux, Mac, and Android
    without modifying the single line of code. This library can also take advantage
    of multi-core processing. It can take advantage of OpenGL and CUDA for parallel
    processing. As OpenCV is lightweight, it can be used on embedded platforms like
    Raspberry Pi as well. This makes it ideal for deploying computer vision applications
    on embedded systems in real life scenarios.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenCV库在C、C++、Java和Python语言中都有接口，并且可以在Windows、Linux、Mac和Android等所有操作系统上使用，而无需修改单行代码。这个库还可以利用多核处理。它可以利用OpenGL和CUDA进行并行处理。由于OpenCV轻量级，它也可以在树莓派等嵌入式平台上使用。这使得它在实际场景中部署计算机视觉应用成为理想选择。
- en: 'The command to initialize image with red color is as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化图像为红色的命令如下：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The program to capture video from webcam and store it on disk is as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从网络摄像头捕获视频并将其存储在磁盘上的程序如下：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: BGR color format is used by OpenCV to read and display an Image.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenCV使用BGR颜色格式来读取和显示图像。
- en: 'Program to capture video from a webcam and convert it to gray scale is as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从网络摄像头捕获视频并将其转换为灰度的程序如下：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'OpenCV program to measure the performance of add and subtract operation is
    as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量加法和减法操作性能的OpenCV程序如下：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'OpenCV program for bitwise `AND` and `OR` operations is as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenCV程序用于执行位运算AND和OR操作如下：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Chapter 6
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: 'OpenCV function to print pixel intensity at location`(200,200)` of any color
    image on the console is as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印任何颜色图像在`(200,200)`位置像素强度的OpenCV函数如下：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'OpenCV function to resize an image to `(300,200)` pixels using bilinear Interpolation
    method is as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用双线性插值方法将图像调整大小到`(300,200)`像素的OpenCV函数如下：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'OpenCV function to upsample an image by 2 using `AREA` interpolation is as
    follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`AREA`插值将图像上采样2倍的OpenCV函数如下：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: False. Blurring increases as we increase the size of a filter.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误。随着滤波器大小的增加，模糊程度也会增加。
- en: False. The median filter can't remove Gaussian noise. It can remove salt and
    pepper noise.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误。中值滤波器不能去除高斯噪声。它可以去除椒盐噪声。
- en: The image has to be blurred using an Averaging or Gaussian filter before applying
    lapacian operator to remove noise sensitivity.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用拉普拉斯算子以去除噪声敏感性之前，必须使用平均或高斯滤波器对图像进行模糊处理。
- en: 'OpenCV function to implement top hat and black hat morphological operation
    is as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现顶帽和黑帽形态学操作的OpenCV函数如下：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Chapter 7
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: 'OpenCV code to detect objects with yellow color from a video is as follows:
    Note that the boilerplate code is not repeated here.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从视频中检测黄色物体的OpenCV代码如下：请注意，这里没有重复样板代码。
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the color of an object is the same as the color of background, then color
    based object detection will fail. If there is a change in illumination, even then
    it can fail.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当物体的颜色与背景颜色相同时，基于颜色的目标检测将失败。即使有光照变化，也可能失败。
- en: The first step of canny edge detection algorithm is Gaussian blurring, which
    removes the noise present in the image. After that, the gradient is computed.
    Thus, the edges detected will be less affected by noise here, than other edge
    detection algorithms seen earlier.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Canny边缘检测算法的第一步是高斯模糊，这可以去除图像中存在的噪声。之后，计算梯度。因此，检测到的边缘将比之前看到的其他边缘检测算法受噪声影响更小。
- en: When the image is affected by Gaussian or salt-pepper noise, then the result
    of the Hough transform is very poor. To improve the result image must be filtered
    by Gaussian and Median filter, as a preprocessing step.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当图像受到高斯或椒盐噪声的影响时，霍夫变换的结果非常差。为了改善结果，必须在预处理步骤中通过高斯和中值滤波器对图像进行滤波。
- en: When the intensity threshold for computing FAST keypoints is low, then more
    keypoints will pass the segment test and will be categorized as key-points. As
    this threshold is increased, the number of key-points detected will gradually
    decrease.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当计算FAST关键点的强度阈值较低时，则更多的关键点将通过段测试并被分类为关键点。随着这个阈值的增加，检测到的关键点数量将逐渐减少。
- en: The larger value of hessian threshold in SURF will result in fewer but more
    salient interest points and a smaller value will result in more numerous but less
    salient points.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SURF中，Hessian阈值的较大值将导致更少但更显著的特征点，而较小值将导致更多但不太显著的特征点。
- en: When the scale factor of Haar cascade is increased from 1.01 to 1.05, then image
    size will be reduced by a larger factor at every scale. Thus, fewer images need
    to be processed per frame, which reduces computation time; however, this may fail
    to detect some of the objects.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Haar 级联的缩放因子从 1.01 增加到 1.05 时，图像大小在每一尺度上都会以更大的因子减小。因此，每帧需要处理的图像更少，这减少了计算时间；然而，这可能导致无法检测到某些对象。
- en: '`MoG` is faster and less noisy compared to `GMG` algorithm for background subtraction.
    The morphological operation like opening and closing can be applied to the output
    of GMG to reduce the noise present.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MoG` 相比于 `GMG` 算法在背景减法方面更快且噪声更少。可以将开闭等形态学操作应用于 GMG 的输出，以减少存在的噪声。'
- en: Chapter 8
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章
- en: Jetson TX1 offers performance in terms of Tera floating point operations per
    second, which is far better than Raspberry Pi. So Jetson TX1 can be used in computationally
    intensive applications like computer vision and deep learning for deployment in
    real time.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jetson TX1 在每秒 Tera 级浮点运算性能方面优于 Raspberry Pi。因此，Jetson TX1 可以用于计算密集型应用，如计算机视觉和深度学习，以实现实时部署。
- en: Jetson TX1 development board supports up to six 2-lane or three 4-lane cameras.
    It has one 5 megapixel camera attached to it.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jetson TX1 开发板支持多达六个 2 通道或三个 4 通道相机。它附带一个 500 万像素的相机。
- en: The USB hub has to be used to connect more than two USB peripherals with Jetson
    TX1\.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须使用 USB 集线器来连接 Jetson TX1 与超过两个 USB 外设。
- en: 'True'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'True'
- en: False. Jetson TX1 contains one ARM Cortex A57 quad-core CPU operating at 1.73
    GHz.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: False. Jetson TX1 包含一个 1.73 GHz 运行的 ARM Cortex A57 四核 CPU。
- en: Though Jetson TX1 comes with pre-flashed Ubuntu, it does not contain any software
    packages needed for Computer Vision applications. The Jetpack contains Linux of
    Tegra (L4T) board support packages, TensorRT, which is used for deep learning
    inference in computer vision applications, latest CUDA toolkit, cuDNN, which is
    CUDA deep neural network library, Visionworks, which is also used for computer
    vision and deep learning applications, and OpenCV. So, by installing Jetpack,
    we can install all software packages needed to build computer vision applications
    rapidly.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管 Jetson TX1 预装了 Ubuntu，但它不包含计算机视觉应用所需的任何软件包。Jetpack 包含 Tegra (L4T) 板支持包的 Linux，TensorRT，用于计算机视觉应用中的深度学习推理，最新的
    CUDA 工具包，cuDNN，这是 CUDA 深度神经网络库，Visionworks，也用于计算机视觉和深度学习应用，以及 OpenCV。因此，通过安装 Jetpack，我们可以快速安装构建计算机视觉应用所需的全部软件包。
- en: Chapter 9
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章
- en: The global memory for the GPU device on Jetson TX1 is around 4 GB with a GPU
    clock speed of around 1 GHz. This clock speed is slower than Geforce 940 GPU used
    earlier in this book. The memory clock speed is only 13 MHz compared to 2.505
    GHz on Geforce 940, which makes Jetson TX1 slower. The L2 cache is 256 KB compared
    to 1 MB on Geforce 940\. Most of the other properties are similar to GeForce 940.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jetson TX1 上的 GPU 设备全局内存大约为 4 GB，GPU 时钟速度约为 1 GHz。这个时钟速度比本书之前使用的 GeForce 940
    GPU 慢。内存时钟速度仅为 13 MHz，而 GeForce 940 为 2.505 GHz，这使得 Jetson TX1 更慢。L2 缓存为 256 KB，而
    GeForce 940 为 1 MB。大多数其他属性与 GeForce 940 相似。
- en: 'True'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'True'
- en: In the latest Jetpack, OpenCV is not compiled with CUDA support nor does it
    have GStreamer support, which is needed for accessing the camera from the code.
    So, it is a good idea to remove OpenCV installation that comes with Jetpack and
    compile the new version of OpenCV with CUGA and GStreamer support.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最新的 Jetpack 中，OpenCV 没有编译 CUDA 支持，也没有 GStreamer 支持，这是从代码中访问相机所需的。因此，移除 Jetpack
    中包含的 OpenCV 安装，并使用 CUGA 和 GStreamer 支持编译新的 OpenCV 版本是个好主意。
- en: False. OpenCV can capture video from both USB and CSI camera connected to Jetson
    TX1 board.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: False. OpenCV 可以从连接到 Jetson TX1 板的 USB 和 CSI 相机捕获视频。
- en: True. CSI camera is more close to hardware so frames are read quickly than USB
    camera so it is better to use CSI camera for computationally intensive applications.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: True. CSI 相机更接近硬件，因此读取帧的速度比 USB 相机快，因此在计算密集型应用中最好使用 CSI 相机。
- en: Python OpenCV binding is not supported by CUDA acceleration so it is better
    to use C++ OpenCV binding for a computationally intensive task.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python OpenCV 绑定不支持 CUDA 加速，因此对于计算密集型任务，最好使用 C++ OpenCV 绑定。
- en: No. Jetson TX1 comes preinstalled with python2 and python3 interpreter, while
    OpenCV is compiled for Jetson TX1; it also installs python binaries so there is
    no need to install separate python OpenCV bindings.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: No. Jetson TX1 预装了 python2 和 python3 解释器，同时 OpenCV 也为 Jetson TX1 编译了；它还安装了 python
    二进制文件，因此无需单独安装 python OpenCV 绑定。
- en: Chapter 10
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章
- en: Python is Open Source and has a large user community contributing to the language
    in terms of modules. These modules can be used easily to develop applications
    in a small time with few lines of code. The syntax of Python language is easy
    to read and interpret, which makes it easier to learn for a new programmer. It
    is an interpreted language that allows line by line execution of the code. These
    are the few advantages of python over C/C++.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 是开源的，拥有庞大的用户社区，他们通过模块为语言做出贡献。这些模块可以轻松地用少量代码在短时间内开发应用程序。Python 语言的语法易于阅读和解释，这使得它对新程序员来说更容易学习。它是一种允许逐行执行代码的解释型语言。这些都是
    Python 相对于 C/C++ 的几个优点。
- en: The whole code is checked and converted to machine code in compiled type languages,
    while one statement at a time is translated in an interpreted language. An interpreted
    language requires less amount of time to analyze the source code, but the overall
    execution time is slower compared to compile type languages. Interpreted languages
    do not generate intermediate code as in the case of compiled type languages.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编译型语言中，整个代码被检查并转换为机器代码，而在解释型语言中，每次只翻译一条语句。解释型语言分析源代码所需的时间较少，但与编译型语言相比，整体执行时间较慢。解释型语言不会像编译型语言那样生成中间代码。
- en: False. Python is an interpreted language, which makes it slower than C/C++.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误。Python 是一种解释型语言，这使得它比 C/C++ 慢。
- en: PyOpenCL can take advantage of any Graphics processing Unit, while PyCUDA requires
    Nvidia GPU and CUDA toolkit.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyOpenCL 可以利用任何图形处理单元，而 PyCUDA 需要Nvidia GPU和CUDA工具包。
- en: True. Python allows C/C++ code in a python script, and hence the computationally
    complex task can be written in C/C++ for faster processing, and python wrapper
    can be created for it. PyCUDA can leverage this capability for kernel code.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确。Python 允许在 Python 脚本中包含 C/C++ 代码，因此计算密集型任务可以写成 C/C++ 代码以实现更快的处理，并为它创建 Python
    包装器。PyCUDA 可以利用这一功能来处理内核代码。
- en: Chapter 11
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: C/C++ programming language is used to write kernel function inside `SourceModule`
    class, and this kernel function is compiled by `nvcc` (Nvidia C ) Compiler.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C/C++ 编程语言用于在 `SourceModule` 类中编写内核函数，并且这个内核函数由 `nvcc`（Nvidia C）编译器编译。
- en: 'The kernel call function is as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核调用函数如下：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: False. The order of block execution is random in PyCUDA program, and it can't
    be determined by PyCUDA programmer.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误。在 PyCUDA 程序中，块执行的顺序是随机的，PyCUDA 程序员无法确定。
- en: The directives from driver class remove the need of separate allocation of memory
    for the Array, uploading it to the device and downloading the result back to host.
    All operations are performed simultaneously during a kernel call. This makes the
    code simpler and easy to read.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驱动类中的指令消除了为数组单独分配内存、将其上传到设备以及将结果下载回主机的要求。所有操作都在内核调用期间同时执行。这使得代码更简单，更容易阅读。
- en: 'The PyCUDA code for adding two to every element in an array is shown below:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数组中每个元素加二的 PyCUDA 代码如下所示：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The use of Python time measuring options for measuring the performance of PyCUDA
    programs will not give accurate results. It will include time overhead of thread
    latency in OS and scheduling in OS, among many other factors. The time measured
    using time class will also depend on the availability of high precision CPU timer.
    Many a times, host is performing asynchronous computation while GPU kernel is
    running, and hence CPU timers of Python may not give correct time for kernel executions.
    We can overcome these drawbacks by using CUDA events.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Python 时间测量选项来测量 PyCUDA 程序的性能不会给出准确的结果。它将包括许多其他因素中的线程延迟在操作系统中的时间开销和调度。使用时间类测量的时间也将取决于高精度
    CPU 定时器的可用性。很多时候，主机在进行异步计算的同时GPU内核正在运行，因此Python的CPU计时器可能无法给出内核执行的正确时间。我们可以通过使用CUDA事件来克服这些缺点。
- en: 'True'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: Chapter 12
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: False. This line represents a read-modify-write operation that can yield wrong
    results when multiple threads are trying to increment the same memory location,
    as in the case of histogram calculation.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误。这一行代表一个读取-修改-写入操作，当多个线程试图增加相同的内存位置时，如直方图计算的情况，可能会产生错误的结果。
- en: In the case of using shared memory, fewer threads are trying to access 256 memory
    elements in shared memory, instead of all threads as in the case without shared
    memory. This will help in reducing time overhead in the atomic operation.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用共享内存的情况下，较少的线程试图访问共享内存中的256个内存元素，而不是没有共享内存时所有线程的情况。这将有助于减少原子操作中的时间开销。
- en: 'The kernel call function in case of using share memory is as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用共享内存的情况下，内核调用函数如下：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The size of the shared memory should be defined, while calling the kernel. This
    is specified by using the shared argument in the kernel call function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用内核时，应该定义共享内存的大小。这可以通过在内核调用函数中使用共享参数来指定。
- en: The histogram is a statistical feature that gives important information regarding
    the contrast and brightness of an image. If it has a uniform distribution, then
    the image will have a good contrast. The histogram also conveys the information
    about the brightness of an image. If the histogram is concentrated on the left-hand
    side of the plot, then the image will be too dark, and if it is concentrated on
    the right-hand side, then the image will be too bright.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直方图是一种统计特征，它提供了关于图像对比度和亮度的关键信息。如果它具有均匀分布，那么图像将具有良好的对比度。直方图还传达了关于图像亮度的信息。如果直方图集中在图表的左侧，那么图像将太暗，如果集中在右侧，那么图像将太亮。
- en: True. As RGB and BGR color format is same just the order of channels is different.
    The equation of conversion will still remain the same.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真的。因为RGB和BGR颜色格式相同，只是通道的顺序不同。转换的方程式仍然保持不变。
- en: It is simpler to work with single dimensional threads and blocks than multidimensional.
    It simplifies the indexing mechanism inside the kernel function, and hence it
    is performed in every example that appears in the chapter. It is not mandatory
    if we are working with multidimensional threads and blocks.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与多维线程和块相比，处理单维线程和块更简单。它简化了内核函数内部的索引机制，因此在每个章节中出现的示例中都进行了这种简化。如果我们正在处理多维线程和块，则这不是强制性的。
- en: The `imshow` function, used to display an image on the screen, requires an image
    in unsigned integer format. So all the results computed by kernel function are
    converted `uint8` datatype of `numpy` library before displaying on the screen.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`imshow`函数，用于在屏幕上显示图像，需要一个无符号整数的图像。因此，在屏幕上显示之前，所有由内核函数计算的结果都转换为`numpy`库的`uint8`数据类型。'
