["```py\n\nfrom qiskit import * \n\nimport numpy as np \n\nqc = QuantumCircuit(2) \n\nqc.z(0) \n\nqc.y(1) \n\nqc.cry(np.pi/2, 0, 1) \n\nqc.u(np.pi/4, np.pi, 0, 0) \n\nqc.rz(np.pi/4,1)\n\n```", "```py\n\nimport pennylane as qml \n\nimport numpy as np \n\ndev = qml.device(’default.qubit’, wires = 2) \n\n@qml.qnode(dev) \n\ndef qcircA(): \n\n    qml.PauliX(wires = 0) \n\n    qml.RX(np.pi/4, wires = 1) \n\n    qml.CNOT(wires = [0,1]) \n\n    qml.U3(np.pi/3, 0, np.pi, wires = 0) \n\n    return qml.state() \n\n@qml.qnode(dev) \n\ndef qcircB(): \n\n    qml.PauliZ(wires = 0) \n\n    qml.PauliY(wires = 1) \n\n    qml.CRY(np.pi/2, wires = [0,1]) \n\n    qml.U3(np.pi/4, np.pi, 0, wires = 0) \n\n    qml.RZ(np.pi/4, wires = 1) \n\n    return qml.state()\n\n```", "```py\n\ntensor([ 0\\.        +0.j        , -0.35355339+0.85355339j, \n         0\\.        +0.j        ,  0.14644661-0.35355339j], \n         requires_grad=True)\n\n```", "```py\n\nStatevector([-5.65831421e-17-3.20736464e-17j, \n              2.34375049e-17+1.32853393e-17j, \n             -3.53553391e-01+8.53553391e-01j, \n              1.46446609e-01-3.53553391e-01j], \n            dims=(2, 2))\n\n```", "```py\n\nfrom qiskit.quantum_info import Pauli \n\nfrom qiskit.opflow.primitive_ops import PauliOp \n\nfrom qiskit.quantum_info import Statevector \n\nH_cut = PauliOp(Pauli(\"ZZI\")) + PauliOp(Pauli(\"ZIZ\")) \n\nfor x in range(8): # We consider x=0,1...7 \n\n    psi = Statevector.from_int(x, dims = 8) \n\n    print(\"The expectation value of |\",x,\">\", \"is\", \n\n        psi.expectation_value(H_cut))\n\n```", "```py\n\nThe expectation value of | 0 > is (2+0j) \n\nThe expectation value of | 1 > is 0j \n\nThe expectation value of | 2 > is 0j \n\nThe expectation value of | 3 > is (-2+0j) \n\nThe expectation value of | 4 > is (-2+0j) \n\nThe expectation value of | 5 > is 0j \n\nThe expectation value of | 6 > is 0j \n\nThe expectation value of | 7 > is (2+0j)\n\n```", "```py\n\nimport dimod \n\nJ = {(0,1):-1, (0,2):1} \n\nh = {1:2} \n\nproblem = dimod.BinaryQuadraticModel(h, J, 0.0, dimod.BINARY) \n\nprint(\"The problem we are going to solve is:\") \n\nprint(problem)\n\n```", "```py\n\nfrom dwave.system import DWaveSampler \n\nfrom dwave.system import EmbeddingComposite \n\nsampler = EmbeddingComposite(DWaveSampler()) \n\nresult = sampler.sample(problem, num_reads=10) \n\nprint(\"The solutions that we have obtained are\") \n\nprint(result)\n\n```", "```py\n\n{0: {4, 5, 6, 7, 128}, 1: {4, 5, 6, 7, 129}, \n\n 2: {4, 5, 6, 7, 130}, 3: {4, 5, 6, 7, 131}, \n\n 4: {0, 1, 2, 3, 12}, 5: {0, 1, 2, 3, 13}, \n\n 6: {0, 1, 2, 3, 14}, 7: {0, 1, 2, 3, 15}}\n\n```", "```py\n\nsampler = DWaveSampler(solver = \"DW_2000Q_6\") \n\nprint(\"The default annealing time is\", \n\n    sampler.properties[\"default_annealing_time\"],\"microsends\") \n\nprint(\"The possible values for the annealing time (in microseconds)\"\\ \n\n    \" lie in the range\",sampler.properties[\"annealing_time_range\"])\n\n```", "```py\n\nThe default annealing time is 20.0 microsends \n\nThe possible values for the annealing time (in microseconds) \n\n    lie in the range [1.0, 2000.0]\n\n```", "```py\n\nfrom qiskit import Aer \n\nfrom qiskit.algorithms import QAOA \n\nfrom qiskit.algorithms.optimizers import COBYLA \n\nfrom qiskit.utils import algorithm_globals, QuantumInstance \n\nfrom qiskit_optimization.algorithms import MinimumEigenOptimizer \n\nseed = 1234 \n\nalgorithm_globals.random_seed = seed \n\nquantum_instance = QuantumInstance(Aer.get_backend(\"aer_simulator\"), \n\n    shots = 1024, seed_simulator=seed, seed_transpiler=seed) \n\nqaoa = QAOA(optimizer = COBYLA(), \n\n            quantum_instance=quantum_instance, reps = 1) \n\nqaoa_optimizer = MinimumEigenOptimizer(qaoa) \n\nresult = qaoa_optimizer.solve(qp) \n\nprint(’Variable order:’, [var.name for var in result.variables]) \n\nfor s in result.samples: \n\n    print(s)\n\n```", "```py\n\ncoefficients = [-3,2,-1] \n\npaulis = [PauliZ(0)@PauliZ(1)@PauliZ(2), \n\n    PauliZ(1)@PauliZ(2),PauliZ(2)] \n\nH = qml.Hamiltonian(coefficients,paulis)\n\n```", "```py\n\nH = -3*PauliZ(0)@PauliZ(1)@PauliZ(2) \n\n    + 2*PauliZ(1)@PauliZ(2) -PauliZ(2)\n\n```", "```py\n\nfrom qiskit_optimization.problems import QuadraticProgram \n\nfrom qiskit_optimization.algorithms import GroverOptimizer \n\nfrom qiskit import Aer \n\nfrom qiskit.utils import algorithm_globals, QuantumInstance \n\nseed = 1234 \n\nalgorithm_globals.random_seed = seed \n\nqp = QuadraticProgram() \n\nqp.binary_var(’x’) \n\nqp.binary_var(’y’) \n\nqp.binary_var(’z’) \n\nqp.minimize(linear = {’x’:3,’y’:2,’z’:-3}, quadratic = {(’x’,’y’):3}) \n\nquantum_instance = QuantumInstance(Aer.get_backend(\"aer_simulator\"), \n\n    shots = 1024, seed_simulator = seed, seed_transpiler=seed) \n\ngrover_optimizer = GroverOptimizer(num_value_qubits = 5, \n\n    num_iterations=4, quantum_instance=quantum_instance) \n\nresults = grover_optimizer.solve(qp) \n\nprint(results)\n\n```", "```py\n\nfrom qiskit.circuit.library import EfficientSU2 \n\nfrom qiskit.algorithms import VQE \n\nfrom qiskit import Aer \n\nfrom qiskit.utils import QuantumInstance \n\nimport numpy as np \n\nfrom qiskit.algorithms.optimizers import COBYLA \n\nfrom qiskit.opflow import Z, I \n\nseed = 1234 \n\nnp.random.seed(seed) \n\nH= (Z^Z^I^I^I) + (I^Z^Z^I^I) + (I^I^Z^Z^I) + (I^I^I^Z^Z) + (Z^I^I^I^Z) \n\nansatz = EfficientSU2(num_qubits=5, reps=1, entanglement=\"linear\", \n\n    insert_barriers = True) \n\noptimizer = COBYLA() \n\ninitial_point = np.random.random(ansatz.num_parameters) \n\nquantum_instance = QuantumInstance(backend = \n\n    Aer.get_backend(’aer_simulator_statevector’)) \n\nvqe = VQE(ansatz=ansatz, optimizer=optimizer, \n\n    initial_point=initial_point, \n\n    quantum_instance=quantum_instance) \n\nresult = vqe.compute_minimum_eigenvalue(H) \n\nprint(result)\n\n```", "```py\n\nfrom qiskit_nature.drivers import Molecule \n\nfrom qiskit_nature.drivers.second_quantization import \\ \n\n    ElectronicStructureMoleculeDriver, ElectronicStructureDriverType \n\nfrom qiskit_nature.problems.second_quantization import \\ \n\n    ElectronicStructureProblem \n\nfrom qiskit_nature.converters.second_quantization import QubitConverter \n\nfrom qiskit_nature.mappers.second_quantization import JordanWignerMapper \n\nfrom qiskit_nature.algorithms import VQEUCCFactory \n\nfrom qiskit import Aer \n\nfrom qiskit.utils import QuantumInstance \n\nfrom qiskit_nature.algorithms import GroundStateEigensolver \n\nimport matplotlib.pyplot as plt \n\nimport numpy as np \n\nquantum_instance = QuantumInstance( \n\n    backend = Aer.get_backend(’aer_simulator_statevector’)) \n\nvqeuccf = VQEUCCFactory(quantum_instance = quantum_instance) \n\nqconverter = QubitConverter(JordanWignerMapper()) \n\nsolver = GroundStateEigensolver(qconverter, vqeuccf) \n\nenergies = [] \n\ndistances = np.arange(0.2, 2.01, 0.01) \n\nfor d in distances: \n\n  mol = Molecule(geometry=[[’H’, [0., 0., -d/2]], \n\n                              [’H’, [0., 0., d/2]]]) \n\n  driver = ElectronicStructureMoleculeDriver(mol, basis=’sto3g’, \n\n        driver_type=ElectronicStructureDriverType.PYSCF) \n\n  problem = ElectronicStructureProblem(driver) \n\n  result = solver.solve(problem) \n\n  energies.append(result.total_energies) \n\nplt.plot(distances, energies) \n\nplt.title(’Dissociation profile’) \n\nplt.xlabel(’Distance’) \n\nplt.ylabel(’Energy’);\n\n```", "```py\n\nfrom qiskit import * \n\nfrom qiskit.providers.aer import AerSimulator \n\nfrom qiskit.utils.mitigation import CompleteMeasFitter \n\nfrom qiskit.utils import QuantumInstance \n\nprovider = IBMQ.load_account() \n\nbackend = AerSimulator.from_backend( \n\n    provider.get_backend(’ibmq_manila’)) \n\nshots = 1024 \n\nqc = QuantumCircuit(2,2) \n\nqc.h(0) \n\nqc.cx(0,1) \n\nqc.measure(range(2),range(2)) \n\nresult = execute(qc, backend, shots = shots) \n\nprint(\"Result of noisy simulation:\") \n\nprint(result.result().get_counts()) \n\nquantum_instance = QuantumInstance( \n\n    backend = backend, shots = shots, \n\n    measurement_error_mitigation_cls=CompleteMeasFitter) \n\nresult = quantum_instance.execute(qc) \n\nprint(\"Result of noisy simulation with error mitigation:\") \n\nprint(result.get_counts())\n\n```", "```py\n\nResult of noisy simulation: \n\n{’01’: 88, ’10’: 50, ’00’: 453, ’11’: 433} \n\nResult of noisy simulation with error mitigation: \n\n{’00’: 475, ’01’: 12, ’10’: 14, ’11’: 523}\n\n```", "```py\n\nfrom qiskit.opflow import Z \n\nfrom qiskit.providers.aer import AerSimulator \n\nfrom qiskit.algorithms import QAOA \n\nfrom qiskit.utils import QuantumInstance \n\nfrom qiskit import Aer, IBMQ \n\nfrom qiskit.algorithms.optimizers import COBYLA \n\nfrom qiskit.utils.mitigation import CompleteMeasFitter \n\nH1 = Z^Z \n\nprovider = IBMQ.load_account() \n\nbackend = AerSimulator.from_backend( \n\n    provider.get_backend(’ibmq_manila’)) \n\nquantum_instance = QuantumInstance(backend=backend, \n\n                   shots = 1024) \n\nqaoa = QAOA(optimizer = COBYLA(), quantum_instance=quantum_instance) \n\nresult = qaoa.compute_minimum_eigenvalue(H1) \n\nprint(\"Result of noisy simulation:\",result.optimal_value) \n\nquantum_instance = QuantumInstance(backend=backend, \n\n    measurement_error_mitigation_cls=CompleteMeasFitter, \n\n    shots = 1024) \n\nqaoa = QAOA(optimizer = COBYLA(), quantum_instance=quantum_instance) \n\nresult = qaoa.compute_minimum_eigenvalue(H1) \n\nprint(\"Result of noisy simulation with error mitigation:\", \n\n    result.optimal_value)\n\n```", "```py\n\nResult of noisy simulation: -0.8066406250000001 \n\nResult of noisy simulation with error mitigation: -0.93359375\n\n```", "```py\n\nval_loss = history.history[\"val_loss\"] \n\ntrain_loss = history.history[\"loss\"] \n\nepochs = range(len(train_loss)) \n\nplt.plot(epochs, train_loss, label = \"Training loss\") \n\nplt.plot(epochs, val_loss, label = \"Validation loss\") \n\nplt.legend() \n\nplt.show()\n\n```", "```py\n\nfrom qiskit import * \n\nfrom qiskit . circuit import ParameterVector \n\ndef AngleEncodingX(n): \n\n    x = ParameterVector(\"x\", length = n) \n\n    qc = QuantumCircuit(n) \n\n    for i in range(n): \n\n        qc.rx(parameter[i], i) \n\n    return qc\n\n```", "```py\n\nnqubits = 5 \n\ndev = qml.device(\"default.qubit\", wires=nqubits) \n\ndef qnn_circuit(inputs, theta): \n\n    qml.AmplitudeEmbedding(features = [a for a in inputs], \n\n        wires = range(nqubits), normalize = True, pad_with = 0.) \n\n    TwoLocal(nqubits = nqubits, theta = theta, reps = 2) \n\n    return qml.expval(qml.Hermitian(M, wires = [0])) \n\nqnn = qml.QNode(qnn_circuit, dev, interface=\"tf\") \n\nweights = {\"theta\": 15}\n\n```", "```py\n\nmodel = tf.keras.models.Sequential([ \n\n    tf.keras.layers.Input(20), \n\n    tf.keras.layers.Dense(16, activation = \"elu\"), \n\n    tf.keras.layers.Dense(8, activation = \"elu\"), \n\n    tf.keras.layers.Dense(4, activation = \"sigmoid\"), \n\n    qml.qnn.KerasLayer(qnn, weights, output_dim=1) \n\n])\n\n```", "```py\n\ndef objective(trial): \n\n    # Define the learning rate as an optimizable parameter. \n\n    lrate = trial.suggest_float(\"learning_rate\", 0.001, 0.1) \n\n    bsize = trial.suggest_int(\"batch_size\", 5, 50) \n\n    # Define the optimizer with the learning rate. \n\n    opt = tf.keras.optimizers.Adam(learning_rate = lrate) \n\n    # Prepare and compile the model. \n\n    model = tf.keras.models.Sequential([ \n\n        tf.keras.layers.Input(20), \n\n        tf.keras.layers.Dense(4, activation = \"sigmoid\"), \n\n        qml.qnn.KerasLayer(qnn, weights, output_dim=1) \n\n    ]) \n\n    model.compile(opt, loss=tf.keras.losses.BinaryCrossentropy()) \n\n    # Train it! \n\n    history = model.fit(x_tr, y_tr, epochs = 50, shuffle = True, \n\n        validation_data = (x_val, y_val), \n\n        batch_size = bsize, \n\n        callbacks = [earlystop], \n\n        verbose = 0 # We want TensorFlow to be quiet. \n\n    ) \n\n    # Return the validation accuracy. \n\n    return accuracy_score(model.predict(x_val) >= 0.5, y_val)\n\n```", "```py\n\nimport optuna \n\nfrom optuna.samplers import TPESampler \n\nseed = 1234 \n\ndef objective(trial): \n\n    x = trial.suggest_float(\"x\", -10, 10) \n\n    return (x-3)**2 \n\nstudy = optuna.create_study(direction=’minimize’, \n\nsampler=TPESampler(seed = seed)) \n\nstudy.optimize(objective, n_trials=100)\n\n```", "```py\n\nx, y = make_regression(n_samples = 1000, n_features = 20)\n\n```", "```py\n\nnqubits = 4 \n\ndev = qml.device(\"lightning.qubit\", wires = nqubits) \n\n@qml.qnode(dev, interface=\"tf\", diff_method = \"adjoint\") \n\ndef qnn(inputs, theta): \n\n    qml.AngleEmbedding(inputs, range(nqubits)) \n\n    TwoLocal(nqubits, theta, reps = 2) \n\n    return [qml.expval(qml.Hermitian(M, wires = [0]))] \n\nweights = {\"theta\": 12} \n\nmodel = tf.keras.models.Sequential([ \n\n    tf.keras.layers.Input(20), \n\n    tf.keras.layers.Dense(16, activation = \"elu\"), \n\n    tf.keras.layers.Dense(8, activation = \"elu\"), \n\n    tf.keras.layers.Dense(4, activation = \"sigmoid\"), \n\n    qml.qnn.KerasLayer(qnn, weights, output_dim=1), \n\n    tf.keras.layers.Dense(1) \n\n])\n\n```"]